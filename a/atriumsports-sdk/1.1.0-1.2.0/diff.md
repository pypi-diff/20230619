# Comparing `tmp/atriumsports_sdk-1.1.0.tar.gz` & `tmp/atriumsports_sdk-1.2.0.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "atriumsports_sdk-1.1.0.tar", last modified: Mon Apr 24 11:37:51 2023, max compression
+gzip compressed data, was "atriumsports_sdk-1.2.0.tar", last modified: Mon Jun 19 16:08:31 2023, max compression
```

## Comparing `atriumsports_sdk-1.1.0.tar` & `atriumsports_sdk-1.2.0.tar`

### file list

```diff
@@ -1,432 +1,433 @@
-drwxr-xr-x   0 k.kieda    (502) staff       (20)        0 2023-04-24 11:37:51.344570 atriumsports_sdk-1.1.0/
--rw-r--r--   0 k.kieda    (502) staff       (20)     1074 2023-03-17 13:13:15.000000 atriumsports_sdk-1.1.0/LICENSE
--rw-r--r--   0 k.kieda    (502) staff       (20)     5380 2023-04-24 11:37:51.344348 atriumsports_sdk-1.1.0/PKG-INFO
--rw-r--r--   0 k.kieda    (502) staff       (20)     4963 2023-03-17 13:13:15.000000 atriumsports_sdk-1.1.0/README.md
-drwxr-xr-x   0 k.kieda    (502) staff       (20)        0 2023-04-24 11:37:51.095889 atriumsports_sdk-1.1.0/atriumsports/
--rw-r--r--   0 k.kieda    (502) staff       (20)     1096 2023-03-17 13:13:15.000000 atriumsports_sdk-1.1.0/atriumsports/__init__.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     4294 2023-04-24 10:52:41.000000 atriumsports_sdk-1.1.0/atriumsports/atrium_response.py
-drwxr-xr-x   0 k.kieda    (502) staff       (20)        0 2023-04-24 11:37:51.097147 atriumsports_sdk-1.1.0/atriumsports/datacore/
--rw-r--r--   0 k.kieda    (502) staff       (20)        0 2022-11-21 11:07:25.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/__init__.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     6660 2023-04-24 10:52:41.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/datacore.py
-drwxr-xr-x   0 k.kieda    (502) staff       (20)        0 2023-04-24 11:37:51.101687 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/
--rw-r--r--   0 k.kieda    (502) staff       (20)    54172 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/__init__.py
-drwxr-xr-x   0 k.kieda    (502) staff       (20)        0 2023-04-24 11:37:51.168900 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/api/
--rw-r--r--   0 k.kieda    (502) staff       (20)     4630 2023-04-24 11:34:52.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/api/__init__.py
--rw-r--r--   0 k.kieda    (502) staff       (20)   120335 2023-04-24 11:34:52.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/api/awards_api.py
--rw-r--r--   0 k.kieda    (502) staff       (20)    39994 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/api/career_statistics_api.py
--rw-r--r--   0 k.kieda    (502) staff       (20)    18749 2023-04-24 11:34:52.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/api/change_log_api.py
--rw-r--r--   0 k.kieda    (502) staff       (20)    96547 2023-04-24 11:34:52.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/api/competition_statistics_api.py
--rw-r--r--   0 k.kieda    (502) staff       (20)   126349 2023-04-24 11:34:52.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/api/competitions_api.py
--rw-r--r--   0 k.kieda    (502) staff       (20)    77621 2023-04-24 11:34:52.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/api/conduct_api.py
--rw-r--r--   0 k.kieda    (502) staff       (20)   136916 2023-04-24 11:34:52.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/api/conferences_divisions_api.py
--rw-r--r--   0 k.kieda    (502) staff       (20)    65856 2023-04-24 11:34:52.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/api/download_video_api.py
--rw-r--r--   0 k.kieda    (502) staff       (20)    90687 2023-04-24 11:34:52.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/api/entities_api.py
--rw-r--r--   0 k.kieda    (502) staff       (20)    20848 2023-04-24 11:34:52.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/api/entity_fixture_history_api.py
--rw-r--r--   0 k.kieda    (502) staff       (20)   126825 2023-04-24 11:34:52.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/api/entity_fixture_statistics_api.py
--rw-r--r--   0 k.kieda    (502) staff       (20)    69659 2023-04-24 11:34:52.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/api/entity_groups_api.py
--rw-r--r--   0 k.kieda    (502) staff       (20)    58996 2023-04-24 11:34:52.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/api/fixture_entities_api.py
--rw-r--r--   0 k.kieda    (502) staff       (20)    11042 2023-04-24 11:34:52.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/api/fixture_live_summary_api.py
--rw-r--r--   0 k.kieda    (502) staff       (20)    58878 2023-04-24 11:34:52.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/api/fixture_persons_api.py
--rw-r--r--   0 k.kieda    (502) staff       (20)    77428 2023-04-24 11:34:52.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/api/fixture_playbyplay_api.py
--rw-r--r--   0 k.kieda    (502) staff       (20)    71847 2023-04-24 11:34:52.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/api/fixture_profiles_api.py
--rw-r--r--   0 k.kieda    (502) staff       (20)    76126 2023-04-24 11:34:52.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/api/fixture_progressions_api.py
--rw-r--r--   0 k.kieda    (502) staff       (20)    88732 2023-04-24 11:34:52.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/api/fixture_roster_api.py
--rw-r--r--   0 k.kieda    (502) staff       (20)   405590 2023-04-24 11:34:52.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/api/fixtures_api.py
--rw-r--r--   0 k.kieda    (502) staff       (20)   250029 2023-04-24 11:34:52.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/api/images_api.py
--rw-r--r--   0 k.kieda    (502) staff       (20)    70098 2023-04-24 11:34:52.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/api/leader_criteria_sets_api.py
--rw-r--r--   0 k.kieda    (502) staff       (20)    72853 2023-04-24 11:34:52.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/api/leader_qualifiers_api.py
--rw-r--r--   0 k.kieda    (502) staff       (20)    69528 2023-04-24 11:34:52.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/api/leagues_api.py
--rw-r--r--   0 k.kieda    (502) staff       (20)    73261 2023-04-24 11:34:52.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/api/local_video_endpoints_api.py
--rw-r--r--   0 k.kieda    (502) staff       (20)    69695 2023-04-24 11:34:52.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/api/merge_records_api.py
--rw-r--r--   0 k.kieda    (502) staff       (20)    65503 2023-04-24 11:34:52.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/api/organizations_api.py
--rw-r--r--   0 k.kieda    (502) staff       (20)    35587 2023-04-24 11:34:52.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/api/partner_apis_api.py
--rw-r--r--   0 k.kieda    (502) staff       (20)    23367 2023-04-24 11:34:52.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/api/person_fixture_history_api.py
--rw-r--r--   0 k.kieda    (502) staff       (20)   133701 2023-04-24 11:34:52.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/api/person_fixture_statistics_api.py
--rw-r--r--   0 k.kieda    (502) staff       (20)    90926 2023-04-24 11:34:52.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/api/persons_api.py
--rw-r--r--   0 k.kieda    (502) staff       (20)   106779 2023-04-24 11:34:52.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/api/rankings_api.py
--rw-r--r--   0 k.kieda    (502) staff       (20)   145983 2023-04-24 11:34:52.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/api/roles_api.py
--rw-r--r--   0 k.kieda    (502) staff       (20)    76763 2023-04-24 11:34:52.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/api/season_entities_api.py
--rw-r--r--   0 k.kieda    (502) staff       (20)    49272 2023-04-24 11:34:52.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/api/season_entity_base_statistics_api.py
--rw-r--r--   0 k.kieda    (502) staff       (20)    71128 2023-04-24 11:34:52.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/api/season_entity_placings_api.py
--rw-r--r--   0 k.kieda    (502) staff       (20)    44371 2023-04-24 11:34:52.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/api/season_leaders_api.py
--rw-r--r--   0 k.kieda    (502) staff       (20)    50510 2023-04-24 11:34:52.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/api/season_person_base_statistics_api.py
--rw-r--r--   0 k.kieda    (502) staff       (20)    71123 2023-04-24 11:34:52.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/api/season_person_placings_api.py
--rw-r--r--   0 k.kieda    (502) staff       (20)    60698 2023-04-24 11:34:52.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/api/season_persons_api.py
--rw-r--r--   0 k.kieda    (502) staff       (20)    97157 2023-04-24 11:34:52.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/api/season_roster_api.py
--rw-r--r--   0 k.kieda    (502) staff       (20)    88224 2023-04-24 11:34:52.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/api/season_series_api.py
--rw-r--r--   0 k.kieda    (502) staff       (20)   176950 2023-04-24 11:34:52.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/api/season_statistics_api.py
--rw-r--r--   0 k.kieda    (502) staff       (20)   114595 2023-04-24 11:34:52.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/api/seasons_api.py
--rw-r--r--   0 k.kieda    (502) staff       (20)    67943 2023-04-24 11:34:52.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/api/sites_api.py
--rw-r--r--   0 k.kieda    (502) staff       (20)   228438 2023-04-24 11:34:52.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/api/stages_pools_rounds_api.py
--rw-r--r--   0 k.kieda    (502) staff       (20)    76208 2023-04-24 11:34:52.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/api/standing_adjustments_api.py
--rw-r--r--   0 k.kieda    (502) staff       (20)    71135 2023-04-24 11:34:52.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/api/standing_configurations_api.py
--rw-r--r--   0 k.kieda    (502) staff       (20)   136411 2023-04-24 11:34:52.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/api/standings_api.py
--rw-r--r--   0 k.kieda    (502) staff       (20)    70601 2023-04-24 11:34:52.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/api/transfers_api.py
--rw-r--r--   0 k.kieda    (502) staff       (20)   100268 2023-04-24 11:34:52.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/api/venues_api.py
--rw-r--r--   0 k.kieda    (502) staff       (20)    73547 2023-04-24 11:34:52.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/api/video_stream_inputs_api.py
--rw-r--r--   0 k.kieda    (502) staff       (20)    75718 2023-04-24 11:34:52.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/api/video_stream_subscriptions_api.py
--rw-r--r--   0 k.kieda    (502) staff       (20)    71930 2023-04-24 11:34:52.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/api/video_streams_available_api.py
--rw-r--r--   0 k.kieda    (502) staff       (20)    27864 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/api_client.py
--rw-r--r--   0 k.kieda    (502) staff       (20)    14709 2023-04-24 11:34:50.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/configuration.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     5022 2023-04-24 11:34:46.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/exceptions.py
-drwxr-xr-x   0 k.kieda    (502) staff       (20)        0 2023-04-24 11:37:51.341696 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/
--rw-r--r--   0 k.kieda    (502) staff       (20)    35377 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/__init__.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     6019 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/award_post_body.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     5851 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/award_put_body.py
--rw-r--r--   0 k.kieda    (502) staff       (20)    10400 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/awards_model.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     2269 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/awards_model_organization.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     3488 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/awards_response.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     3050 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/blank_model_response.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     3524 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/career_person_statistics_model.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     2420 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/career_person_statistics_model_organization.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     3682 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/career_person_statistics_response.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     4387 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/change_log_model.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     2293 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/change_log_model_organization.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     3525 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/change_log_response.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     4398 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/competition_entity_statistics_model.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     2460 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/competition_entity_statistics_model_organization.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     3742 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/competition_entity_statistics_response.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     4295 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/competition_historical_name.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     4394 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/competition_person_statistics_model.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     2460 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/competition_person_statistics_model_organization.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     3742 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/competition_person_statistics_response.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     9158 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/competition_post_body.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     8929 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/competition_put_body.py
--rw-r--r--   0 k.kieda    (502) staff       (20)    11527 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/competitions_model.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     2255 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/competitions_model_league.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     2315 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/competitions_model_organization.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     3560 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/competitions_response.py
--rw-r--r--   0 k.kieda    (502) staff       (20)    11783 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/competitions_season_status_model.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     2375 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/competitions_season_status_model_league.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     2435 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/competitions_season_status_model_organization.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     3706 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/competitions_season_status_response.py
--rw-r--r--   0 k.kieda    (502) staff       (20)    23443 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/conduct_model.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     2276 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/conduct_model_organization.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     2877 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/conduct_penalty_result.py
--rw-r--r--   0 k.kieda    (502) staff       (20)    18620 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/conduct_post_body.py
--rw-r--r--   0 k.kieda    (502) staff       (20)    18472 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/conduct_put_body.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     3500 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/conduct_response.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     5618 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/conference_post_body.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     5099 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/conference_put_body.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     7512 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/conferences_model.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     2307 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/conferences_model_organization.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     3548 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/conferences_response.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     3107 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/contact_details.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     6034 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/division_post_body.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     5601 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/division_put_body.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     8471 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/divisions_model.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     2291 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/divisions_model_organization.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     3524 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/divisions_response.py
--rw-r--r--   0 k.kieda    (502) staff       (20)    17738 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/entities_model.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     2275 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/entities_model_entity_group.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     2282 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/entities_model_organization.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     3512 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/entities_response.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     2435 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/entity_additional_details.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     5166 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/entity_address.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     5207 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/entity_group_address.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     4869 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/entity_group_historical_name.py
--rw-r--r--   0 k.kieda    (502) staff       (20)    11168 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/entity_group_post_body.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     4215 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/entity_group_post_body_additional_names.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     3399 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/entity_group_post_body_colors.py
--rw-r--r--   0 k.kieda    (502) staff       (20)    10990 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/entity_group_put_body.py
--rw-r--r--   0 k.kieda    (502) staff       (20)    13106 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/entity_groups_model.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     2316 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/entity_groups_model_organization.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     3561 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/entity_groups_response.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     4829 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/entity_historical_name.py
--rw-r--r--   0 k.kieda    (502) staff       (20)    15240 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/entity_post_body.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     4151 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/entity_post_body_additional_names.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     3341 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/entity_post_body_colors.py
--rw-r--r--   0 k.kieda    (502) staff       (20)    15109 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/entity_put_body.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     1922 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/environmental_details.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     2788 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/error_list_model.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     2818 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/error_model.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     5903 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixture_competitor.py
--rw-r--r--   0 k.kieda    (502) staff       (20)    12402 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixture_entities_model.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     2295 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixture_entities_model_conference.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     2275 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixture_entities_model_division.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     2257 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixture_entities_model_entity.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     2363 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixture_entities_model_organization.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     8963 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixture_entities_post_body.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     3597 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixture_entities_response.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     2740 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixture_entity_period_statistics_post_body.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     4693 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixture_entity_statistics_model.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     2428 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixture_entity_statistics_model_organization.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     5186 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixture_entity_statistics_periods_model.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     2484 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixture_entity_statistics_periods_model_organization.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     3788 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixture_entity_statistics_periods_response.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     2237 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixture_entity_statistics_post_body.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     3694 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixture_entity_statistics_response.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     2696 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixture_live_summary_model.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     3634 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixture_live_summary_response.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     5384 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixture_participant.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     9937 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixture_pbp_event_model.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     2364 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixture_pbp_event_model_organization.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     3598 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixture_pbp_event_response.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     4479 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixture_pbp_model.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     2301 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixture_pbp_model_organization.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     2653 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixture_pbp_post_body.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     3537 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixture_pbp_response.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     7617 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixture_person_statistics_model.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     2428 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixture_person_statistics_model_organization.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     6083 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixture_person_statistics_periods_model.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     2485 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixture_person_statistics_periods_model_organization.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     3131 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixture_person_statistics_periods_post_body.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     3788 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixture_person_statistics_periods_response.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     4760 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixture_person_statistics_post_body.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     3694 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixture_person_statistics_response.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     9757 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixture_persons_model.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     2355 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixture_persons_model_organization.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     2248 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixture_persons_model_person.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     6822 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixture_persons_post_body.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     3585 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixture_persons_response.py
--rw-r--r--   0 k.kieda    (502) staff       (20)    21880 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixture_post_body.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     3953 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixture_profiles_model.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     2363 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixture_profiles_model_organization.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     2643 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixture_profiles_post_body.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     2386 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixture_profiles_put_body.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     3597 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixture_profiles_response.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     3471 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixture_progression_post_body.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     3150 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixture_progression_put_body.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     5895 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixture_progressions_model.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     2303 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixture_progressions_model_fixture.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     2396 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixture_progressions_model_organization.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     2293 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixture_progressions_model_season.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     3645 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixture_progressions_response.py
--rw-r--r--   0 k.kieda    (502) staff       (20)    21743 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixture_put_body.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     6649 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixture_roster_model.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     2325 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixture_roster_model_organization.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     3809 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixture_roster_post_body.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     3573 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixture_roster_response.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     3072 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixture_videosteam_post_body.py
--rw-r--r--   0 k.kieda    (502) staff       (20)    28273 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixtures_by_entity_model.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     3610 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixtures_by_entity_response.py
--rw-r--r--   0 k.kieda    (502) staff       (20)    28209 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixtures_model.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     2298 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixtures_model_fixture_profile.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     2283 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixtures_model_organization.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     2231 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixtures_model_round.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     2244 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixtures_model_series.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     2213 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixtures_model_venue.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     3512 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixtures_response.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     4972 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/game_log_entity_model.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     2326 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/game_log_entity_model_organization.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     3574 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/game_log_entity_response.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     7674 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/game_log_person_model.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     2326 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/game_log_person_model_organization.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     3574 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/game_log_person_response.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     1890 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/head_to_head_identification.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     2042 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/head_to_head_identification_for_subsequent_checks.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     2302 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/head_to_head_resolution.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     2438 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/head_to_head_resolution_for_extra_depth_h2h_s.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     9167 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/images_model.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     2268 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/images_model_organization.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     1750 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/images_post_body.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     2400 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/images_put_body.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     3488 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/images_response.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     1869 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/included_data.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     3193 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/leader_criteria_model.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     2354 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/leader_criteria_model_organization.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     2078 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/leader_criteria_post_body.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     1830 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/leader_criteria_put_body.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     3585 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/leader_criteria_response.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     3722 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/leader_qualifier_post_body.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     3538 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/leader_qualifier_put_body.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     5770 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/leader_qualifiers_model.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     2383 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/leader_qualifiers_model_leaders_criteria.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     2369 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/leader_qualifiers_model_organization.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     3609 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/leader_qualifiers_response.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     2721 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/leader_summary_model.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     3573 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/leader_summary_response.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     6532 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/league_post_body.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     6401 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/league_put_body.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     8464 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/leagues_model.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     2275 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/leagues_model_organization.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     3500 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/leagues_response.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     5874 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/organization_post_body.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     5655 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/organization_put_body.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     6990 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/organizations_model.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     3572 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/organizations_response.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     5503 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/person_additional_details.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     5826 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/person_historical_name.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     2549 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/person_list_default_response.py
--rw-r--r--   0 k.kieda    (502) staff       (20)    12703 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/person_post_body.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     5713 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/person_post_body_additional_names_value.py
--rw-r--r--   0 k.kieda    (502) staff       (20)    12630 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/person_put_body.py
--rw-r--r--   0 k.kieda    (502) staff       (20)    14658 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/persons_model.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     2275 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/persons_model_organization.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     3500 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/persons_response.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     6028 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/pool_post_body.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     5604 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/pool_put_body.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     5557 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/ranking_rows_model.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     4611 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/ranking_rows_post_body.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     4451 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/ranking_rows_put_body.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     3549 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/ranking_rows_response.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     2193 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/response_links.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     3405 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/response_meta_data.py
--rw-r--r--   0 k.kieda    (502) staff       (20)    11464 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/role_post_body.py
--rw-r--r--   0 k.kieda    (502) staff       (20)    11334 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/role_put_body.py
--rw-r--r--   0 k.kieda    (502) staff       (20)    15342 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/roles_model.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     2259 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/roles_model_organization.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     3476 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/roles_response.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     6982 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/round_post_body.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     6552 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/round_put_body.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     8665 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_entities_list_model.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     2383 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_entities_list_model_organization.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     3634 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_entities_list_response.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     8835 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_entities_model.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     5441 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_entities_post_body.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     3585 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_entities_response.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     6133 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_entity_base_statistics_model.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     2453 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_entity_base_statistics_model_organization.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     3616 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_entity_base_statistics_post_body.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     3731 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_entity_base_statistics_response.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     4052 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_entity_placings_model.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     3658 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_entity_placings_response.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     5234 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_entity_statistics_model.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     2420 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_entity_statistics_model_organization.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     3682 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_entity_statistics_response.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     6161 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_fixture_stages_pools_list_model.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     2465 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_fixture_stages_pools_list_model_organization.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     2381 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_fixture_stages_pools_list_model_pool.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     2391 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_fixture_stages_pools_list_model_stage.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     3765 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_fixture_stages_pools_list_response.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     6816 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_person_base_statistics_model.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     2453 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_person_base_statistics_model_organization.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     3796 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_person_base_statistics_post_body.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     3731 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_person_base_statistics_response.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     4052 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_person_placings_model.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     3658 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_person_placings_response.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     5724 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_person_statistics_model.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     2420 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_person_statistics_model_organization.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     6188 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_person_statistics_periods_model.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     3776 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_person_statistics_periods_response.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     3682 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_person_statistics_response.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     5098 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_person_total_statistics_model.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     2461 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_person_total_statistics_model_organization.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     3743 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_person_total_statistics_response.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     6707 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_persons_list_model.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     2375 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_persons_list_model_organization.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     3622 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_persons_list_response.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     6877 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_persons_model.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     3943 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_persons_post_body.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     3573 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_persons_response.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     8426 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_pools_model.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     2301 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_pools_model_organization.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     3549 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_pools_response.py
--rw-r--r--   0 k.kieda    (502) staff       (20)    17695 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_post_body.py
--rw-r--r--   0 k.kieda    (502) staff       (20)    17856 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_put_body.py
--rw-r--r--   0 k.kieda    (502) staff       (20)    10328 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_roster_model.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     2317 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_roster_model_organization.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     5861 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_roster_post_body.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     3561 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_roster_response.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     9921 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_rounds_model.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     2309 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_rounds_model_organization.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     3561 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_rounds_response.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     4297 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_series_competitor.py
--rw-r--r--   0 k.kieda    (502) staff       (20)    13526 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_series_model.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     2310 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_series_model_organization.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     3561 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_series_response.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     5658 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_stage_post_body.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     5173 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_stage_put_body.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     7462 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_stages_model.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     2316 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_stages_model_organization.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     3561 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_stages_response.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     5281 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_standings_stages_pools_list_model.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     2481 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_standings_stages_pools_list_model_organization.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     3789 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_standings_stages_pools_list_response.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     5215 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_venues_address.py
--rw-r--r--   0 k.kieda    (502) staff       (20)    10927 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_venues_list_model.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     2367 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_venues_list_model_organization.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     2265 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_venues_list_model_site.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     3610 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_venues_list_response.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     3536 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/seasonentity_placings_post_body.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     3347 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/seasonentity_placings_put_body.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     3536 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/seasonperson_placings_post_body.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     3347 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/seasonperson_placings_put_body.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     3950 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/seasonroster_configuration.py
--rw-r--r--   0 k.kieda    (502) staff       (20)    21742 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/seasons_model.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     2265 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/seasons_model_competition.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     2290 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/seasons_model_fixture_profile.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     2275 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/seasons_model_organization.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     2391 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/seasons_model_standing_configuration.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     3500 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/seasons_response.py
--rw-r--r--   0 k.kieda    (502) staff       (20)    10508 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/series_post_body.py
--rw-r--r--   0 k.kieda    (502) staff       (20)    10195 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/series_put_body.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     5150 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/site_address.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     6463 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/site_post_body.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     6279 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/site_put_body.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     7711 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/sites_model.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     2259 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/sites_model_organization.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     3476 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/sites_response.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     3238 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/social_media.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     2176 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/sorting.py
--rw-r--r--   0 k.kieda    (502) staff       (20)    12131 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/standing_adjustment_post_body.py
--rw-r--r--   0 k.kieda    (502) staff       (20)    12038 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/standing_adjustment_put_body.py
--rw-r--r--   0 k.kieda    (502) staff       (20)    17220 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/standing_adjustments_model.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     2396 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/standing_adjustments_model_organization.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     3645 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/standing_adjustments_response.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     4816 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/standing_building.py
--rw-r--r--   0 k.kieda    (502) staff       (20)    12841 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/standing_configuration.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     6147 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/standing_configurations_model.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     2421 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/standing_configurations_model_organization.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     4774 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/standing_configurations_post_body.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     4488 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/standing_configurations_put_body.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     3681 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/standing_configurations_response.py
--rw-r--r--   0 k.kieda    (502) staff       (20)    11834 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/standing_post_body.py
--rw-r--r--   0 k.kieda    (502) staff       (20)    17170 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/standing_post_body_calculated_value.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     4237 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/standing_post_body_points_value.py
--rw-r--r--   0 k.kieda    (502) staff       (20)    11808 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/standing_put_body.py
--rw-r--r--   0 k.kieda    (502) staff       (20)    17845 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/standings_model.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     2291 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/standings_model_organization.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     3524 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/standings_response.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     1771 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/success_model.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     3500 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/success_response.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     2617 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/transfer_component.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     7072 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/transfer_post_body.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     6904 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/transfer_put_body.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     9405 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/transfers_model.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     2293 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/transfers_model_organization.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     3524 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/transfers_response.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     5158 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/venue_address.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     5319 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/venue_historical_name.py
--rw-r--r--   0 k.kieda    (502) staff       (20)    10502 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/venue_post_body.py
--rw-r--r--   0 k.kieda    (502) staff       (20)    10334 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/venue_put_body.py
--rw-r--r--   0 k.kieda    (502) staff       (20)    12439 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/venues_model.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     2267 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/venues_model_organization.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     2187 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/venues_model_site.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     3488 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/venues_response.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     9131 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/video_file_post_body.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     2156 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/video_files_download_model.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     3634 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/video_files_download_response.py
--rw-r--r--   0 k.kieda    (502) staff       (20)    10976 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/video_files_model.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     2300 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/video_files_model_organization.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     3537 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/video_files_response.py
--rw-r--r--   0 k.kieda    (502) staff       (20)    11456 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/video_stream_inputs_model.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     2380 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/video_stream_inputs_model_organization.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     3622 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/video_stream_inputs_response.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     5282 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/video_stream_local_model.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     2372 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/video_stream_local_model_organization.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     3412 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/video_stream_local_post_body.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     3251 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/video_stream_local_put_body.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     3610 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/video_stream_local_response.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     9231 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/video_stream_outputs_model.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     2388 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/video_stream_outputs_model_organization.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     3634 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/video_stream_outputs_response.py
--rw-r--r--   0 k.kieda    (502) staff       (20)    11070 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/video_subscription_post_body.py
--rw-r--r--   0 k.kieda    (502) staff       (20)    11096 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/video_subscription_put_body.py
--rw-r--r--   0 k.kieda    (502) staff       (20)    13183 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/video_subscriptions_model.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     2386 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/video_subscriptions_model_organization.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     3633 2023-04-24 11:34:51.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/video_subscriptions_response.py
--rw-r--r--   0 k.kieda    (502) staff       (20)    12492 2023-04-24 11:34:50.000000 atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/rest.py
-drwxr-xr-x   0 k.kieda    (502) staff       (20)        0 2023-04-24 11:37:51.342416 atriumsports_sdk-1.1.0/atriumsports/datacore_stream/
--rw-r--r--   0 k.kieda    (502) staff       (20)        0 2023-03-17 13:13:17.000000 atriumsports_sdk-1.1.0/atriumsports/datacore_stream/__init__.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     6124 2023-04-24 10:52:46.000000 atriumsports_sdk-1.1.0/atriumsports/datacore_stream/datacore_stream.py
--rw-r--r--   0 k.kieda    (502) staff       (20)     1942 2023-04-24 11:27:56.000000 atriumsports_sdk-1.1.0/atriumsports/endpoints.py
-drwxr-xr-x   0 k.kieda    (502) staff       (20)        0 2023-04-24 11:37:51.343970 atriumsports_sdk-1.1.0/atriumsports_sdk.egg-info/
--rw-r--r--   0 k.kieda    (502) staff       (20)     5380 2023-04-24 11:37:51.000000 atriumsports_sdk-1.1.0/atriumsports_sdk.egg-info/PKG-INFO
--rw-r--r--   0 k.kieda    (502) staff       (20)    27005 2023-04-24 11:37:51.000000 atriumsports_sdk-1.1.0/atriumsports_sdk.egg-info/SOURCES.txt
--rw-r--r--   0 k.kieda    (502) staff       (20)        1 2023-04-24 11:37:51.000000 atriumsports_sdk-1.1.0/atriumsports_sdk.egg-info/dependency_links.txt
--rw-r--r--   0 k.kieda    (502) staff       (20)      108 2023-04-24 11:37:51.000000 atriumsports_sdk-1.1.0/atriumsports_sdk.egg-info/requires.txt
--rw-r--r--   0 k.kieda    (502) staff       (20)       13 2023-04-24 11:37:51.000000 atriumsports_sdk-1.1.0/atriumsports_sdk.egg-info/top_level.txt
--rw-r--r--   0 k.kieda    (502) staff       (20)       80 2023-04-24 10:51:20.000000 atriumsports_sdk-1.1.0/pyproject.toml
--rw-r--r--   0 k.kieda    (502) staff       (20)       38 2023-04-24 11:37:51.344624 atriumsports_sdk-1.1.0/setup.cfg
--rw-r--r--   0 k.kieda    (502) staff       (20)      947 2023-04-24 10:58:44.000000 atriumsports_sdk-1.1.0/setup.py
+drwxr-xr-x   0 k.kieda    (502) staff       (20)        0 2023-06-19 16:08:31.099343 atriumsports_sdk-1.2.0/
+-rw-r--r--   0 k.kieda    (502) staff       (20)     1074 2023-03-17 13:13:15.000000 atriumsports_sdk-1.2.0/LICENSE
+-rw-r--r--   0 k.kieda    (502) staff       (20)     5380 2023-06-19 16:08:31.099156 atriumsports_sdk-1.2.0/PKG-INFO
+-rw-r--r--   0 k.kieda    (502) staff       (20)     4963 2023-06-16 15:49:48.000000 atriumsports_sdk-1.2.0/README.md
+drwxr-xr-x   0 k.kieda    (502) staff       (20)        0 2023-06-19 16:08:30.933895 atriumsports_sdk-1.2.0/atriumsports/
+-rw-r--r--   0 k.kieda    (502) staff       (20)     1096 2023-03-17 13:13:15.000000 atriumsports_sdk-1.2.0/atriumsports/__init__.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     4294 2023-04-24 10:52:41.000000 atriumsports_sdk-1.2.0/atriumsports/atrium_response.py
+drwxr-xr-x   0 k.kieda    (502) staff       (20)        0 2023-06-19 16:08:30.935139 atriumsports_sdk-1.2.0/atriumsports/datacore/
+-rw-r--r--   0 k.kieda    (502) staff       (20)        0 2022-11-21 11:07:25.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/__init__.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     6660 2023-04-24 10:52:41.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/datacore.py
+drwxr-xr-x   0 k.kieda    (502) staff       (20)        0 2023-06-19 16:08:30.938499 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/
+-rw-r--r--   0 k.kieda    (502) staff       (20)    54239 2023-06-19 16:07:56.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/__init__.py
+drwxr-xr-x   0 k.kieda    (502) staff       (20)        0 2023-06-19 16:08:30.977493 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/api/
+-rw-r--r--   0 k.kieda    (502) staff       (20)     4630 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/api/__init__.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)   121018 2023-06-19 16:07:58.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/api/awards_api.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)    40271 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/api/career_statistics_api.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)    18925 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/api/change_log_api.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)    97107 2023-06-19 16:07:58.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/api/competition_statistics_api.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)   127164 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/api/competitions_api.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)    78128 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/api/conduct_api.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)   137833 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/api/conferences_divisions_api.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)    66311 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/api/download_video_api.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)    91278 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/api/entities_api.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)    21039 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/api/entity_fixture_history_api.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)   127554 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/api/entity_fixture_statistics_api.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)    70185 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/api/entity_groups_api.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)    59444 2023-06-19 16:07:58.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/api/fixture_entities_api.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)    11205 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/api/fixture_live_summary_api.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)    59323 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/api/fixture_persons_api.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)    77945 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/api/fixture_playbyplay_api.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)    72387 2023-06-19 16:07:58.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/api/fixture_profiles_api.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)    76686 2023-06-19 16:07:58.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/api/fixture_progressions_api.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)    89352 2023-06-19 16:07:58.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/api/fixture_roster_api.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)   407884 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/api/fixtures_api.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)   252466 2023-06-19 16:07:58.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/api/images_api.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)    70633 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/api/leader_criteria_sets_api.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)    73398 2023-06-19 16:07:58.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/api/leader_qualifiers_api.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)    70024 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/api/leagues_api.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)    73817 2023-06-19 16:07:58.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/api/local_video_endpoints_api.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)    70215 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/api/merge_records_api.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)    66029 2023-06-19 16:07:58.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/api/organizations_api.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)    36028 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/api/partner_apis_api.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)    23558 2023-06-19 16:07:58.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/api/person_fixture_history_api.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)   134432 2023-06-19 16:07:58.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/api/person_fixture_statistics_api.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)    91522 2023-06-19 16:07:58.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/api/persons_api.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)   107461 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/api/rankings_api.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)   150045 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/api/roles_api.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)    77289 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/api/season_entities_api.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)    49629 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/api/season_entity_base_statistics_api.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)    71603 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/api/season_entity_placings_api.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)    44646 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/api/season_leaders_api.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)    50867 2023-06-19 16:07:58.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/api/season_person_base_statistics_api.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)    71598 2023-06-19 16:07:58.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/api/season_person_placings_api.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)    61140 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/api/season_persons_api.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)    97800 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/api/season_roster_api.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)    90287 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/api/season_series_api.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)   177700 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/api/season_statistics_api.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)   120275 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/api/seasons_api.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)    68423 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/api/sites_api.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)   229910 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/api/stages_pools_rounds_api.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)    76768 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/api/standing_adjustments_api.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)    71710 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/api/standing_configurations_api.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)   137275 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/api/standings_api.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)    71111 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/api/transfers_api.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)   100928 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/api/venues_api.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)    73928 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/api/video_stream_inputs_api.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)    76269 2023-06-19 16:07:58.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/api/video_stream_subscriptions_api.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)    72341 2023-06-19 16:07:58.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/api/video_streams_available_api.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)    28317 2023-06-19 16:07:56.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/api_client.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)      779 2023-06-19 16:07:56.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/api_response.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)    14866 2023-06-19 16:07:56.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/configuration.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     5022 2023-06-19 16:07:51.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/exceptions.py
+drwxr-xr-x   0 k.kieda    (502) staff       (20)        0 2023-06-19 16:08:31.096957 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/
+-rw-r--r--   0 k.kieda    (502) staff       (20)    35377 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/__init__.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     6094 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/award_post_body.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     5926 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/award_put_body.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)    10475 2023-06-19 16:07:56.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/awards_model.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     2330 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/awards_model_organization.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     3495 2023-06-19 16:07:56.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/awards_response.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     3057 2023-06-19 16:07:56.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/blank_model_response.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     3531 2023-06-19 16:07:56.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/career_person_statistics_model.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     2481 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/career_person_statistics_model_organization.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     3689 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/career_person_statistics_response.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     4448 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/change_log_model.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     2354 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/change_log_model_organization.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     3532 2023-06-19 16:07:56.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/change_log_response.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     4405 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/competition_entity_statistics_model.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     2521 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/competition_entity_statistics_model_organization.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     3749 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/competition_entity_statistics_response.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     4302 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/competition_historical_name.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     4401 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/competition_person_statistics_model.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     2521 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/competition_person_statistics_model_organization.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     3749 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/competition_person_statistics_response.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     9341 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/competition_post_body.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     9112 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/competition_put_body.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)    11710 2023-06-19 16:07:56.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/competitions_model.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     2316 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/competitions_model_league.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     2376 2023-06-19 16:07:56.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/competitions_model_organization.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     3567 2023-06-19 16:07:56.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/competitions_response.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)    11966 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/competitions_season_status_model.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     2436 2023-06-19 16:07:56.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/competitions_season_status_model_league.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     2496 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/competitions_season_status_model_organization.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     3713 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/competitions_season_status_response.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)    23827 2023-06-19 16:07:56.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/conduct_model.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     2337 2023-06-19 16:07:56.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/conduct_model_organization.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     2938 2023-06-19 16:07:56.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/conduct_penalty_result.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)    18995 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/conduct_post_body.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)    18856 2023-06-19 16:07:56.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/conduct_put_body.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     3507 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/conduct_response.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     5693 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/conference_post_body.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     5174 2023-06-19 16:07:56.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/conference_put_body.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     7587 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/conferences_model.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     2368 2023-06-19 16:07:56.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/conferences_model_organization.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     3555 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/conferences_response.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     3114 2023-06-19 16:07:56.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/contact_details.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     6109 2023-06-19 16:07:56.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/division_post_body.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     5676 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/division_put_body.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     8546 2023-06-19 16:07:56.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/divisions_model.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     2352 2023-06-19 16:07:56.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/divisions_model_organization.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     3531 2023-06-19 16:07:56.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/divisions_response.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)    18029 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/entities_model.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     2336 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/entities_model_entity_group.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     2343 2023-06-19 16:07:56.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/entities_model_organization.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     3519 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/entities_response.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     2496 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/entity_additional_details.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     5227 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/entity_address.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     5268 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/entity_group_address.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     4876 2023-06-19 16:07:56.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/entity_group_historical_name.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)    11288 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/entity_group_post_body.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     4222 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/entity_group_post_body_additional_names.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     3406 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/entity_group_post_body_colors.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)    11119 2023-06-19 16:07:56.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/entity_group_put_body.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)    13235 2023-06-19 16:07:56.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/entity_groups_model.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     2377 2023-06-19 16:07:56.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/entity_groups_model_organization.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     3568 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/entity_groups_response.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     4836 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/entity_historical_name.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)    15522 2023-06-19 16:07:56.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/entity_post_body.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     4158 2023-06-19 16:07:56.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/entity_post_body_additional_names.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     3348 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/entity_post_body_colors.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)    15400 2023-06-19 16:07:56.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/entity_put_body.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     1929 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/environmental_details.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     2849 2023-06-19 16:07:56.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/error_list_model.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     2825 2023-06-19 16:07:56.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/error_model.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     6046 2023-06-19 16:07:56.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixture_competitor.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)    12585 2023-06-19 16:07:56.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixture_entities_model.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     2356 2023-06-19 16:07:56.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixture_entities_model_conference.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     2336 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixture_entities_model_division.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     2318 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixture_entities_model_entity.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     2424 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixture_entities_model_organization.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     9137 2023-06-19 16:07:56.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixture_entities_post_body.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     3604 2023-06-19 16:07:56.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixture_entities_response.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     2747 2023-06-19 16:07:56.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixture_entity_period_statistics_post_body.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     4700 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixture_entity_statistics_model.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     2489 2023-06-19 16:07:56.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixture_entity_statistics_model_organization.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     5193 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixture_entity_statistics_periods_model.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     2545 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixture_entity_statistics_periods_model_organization.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     3795 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixture_entity_statistics_periods_response.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     2244 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixture_entity_statistics_post_body.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     3701 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixture_entity_statistics_response.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     2703 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixture_live_summary_model.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     3641 2023-06-19 16:07:56.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixture_live_summary_response.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     5527 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixture_participant.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)    10059 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixture_pbp_event_model.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     2425 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixture_pbp_event_model_organization.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     3605 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixture_pbp_event_response.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     4486 2023-06-19 16:07:56.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixture_pbp_model.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     2362 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixture_pbp_model_organization.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     2660 2023-06-19 16:07:56.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixture_pbp_post_body.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     3544 2023-06-19 16:07:56.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixture_pbp_response.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     7624 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixture_person_statistics_model.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     2489 2023-06-19 16:07:56.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixture_person_statistics_model_organization.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     6090 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixture_person_statistics_periods_model.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     2546 2023-06-19 16:07:56.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixture_person_statistics_periods_model_organization.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     3138 2023-06-19 16:07:56.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixture_person_statistics_periods_post_body.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     3795 2023-06-19 16:07:56.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixture_person_statistics_periods_response.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     4767 2023-06-19 16:07:56.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixture_person_statistics_post_body.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     3701 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixture_person_statistics_response.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     9886 2023-06-19 16:07:56.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixture_persons_model.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     2416 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixture_persons_model_organization.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     2309 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixture_persons_model_person.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     6942 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixture_persons_post_body.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     3592 2023-06-19 16:07:56.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixture_persons_response.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)    22216 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixture_post_body.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     3960 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixture_profiles_model.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     2424 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixture_profiles_model_organization.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     2650 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixture_profiles_post_body.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     2393 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixture_profiles_put_body.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     3604 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixture_profiles_response.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     3546 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixture_progression_post_body.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     3225 2023-06-19 16:07:56.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixture_progression_put_body.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     5970 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixture_progressions_model.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     2364 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixture_progressions_model_fixture.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     2457 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixture_progressions_model_organization.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     2354 2023-06-19 16:07:56.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixture_progressions_model_season.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     3652 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixture_progressions_response.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)    22088 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixture_put_body.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     6724 2023-06-19 16:07:56.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixture_roster_model.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     2386 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixture_roster_model_organization.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     3884 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixture_roster_post_body.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     3580 2023-06-19 16:07:56.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixture_roster_response.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     3201 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixture_videosteam_post_body.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)    28618 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixtures_by_entity_model.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     3617 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixtures_by_entity_response.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)    28554 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixtures_model.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     2359 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixtures_model_fixture_profile.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     2344 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixtures_model_organization.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     2292 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixtures_model_round.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     2305 2023-06-19 16:07:56.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixtures_model_series.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     2274 2023-06-19 16:07:56.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixtures_model_venue.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     3519 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixtures_response.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     4979 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/game_log_entity_model.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     2387 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/game_log_entity_model_organization.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     3581 2023-06-19 16:07:56.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/game_log_entity_response.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     7681 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/game_log_person_model.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     2387 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/game_log_person_model_organization.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     3581 2023-06-19 16:07:56.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/game_log_person_response.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     1897 2023-06-19 16:07:56.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/head_to_head_identification.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     2049 2023-06-19 16:07:56.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/head_to_head_identification_for_subsequent_checks.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     2363 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/head_to_head_resolution.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     2499 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/head_to_head_resolution_for_extra_depth_h2h_s.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     9444 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/images_model.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     2329 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/images_model_organization.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     1757 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/images_post_body.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     2461 2023-06-19 16:07:56.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/images_put_body.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     3495 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/images_response.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     1876 2023-06-19 16:07:56.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/included_data.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     3200 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/leader_criteria_model.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     2415 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/leader_criteria_model_organization.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     2085 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/leader_criteria_post_body.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     1837 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/leader_criteria_put_body.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     3592 2023-06-19 16:07:56.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/leader_criteria_response.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     3810 2023-06-19 16:07:56.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/leader_qualifier_post_body.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     3635 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/leader_qualifier_put_body.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     5867 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/leader_qualifiers_model.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     2444 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/leader_qualifiers_model_leaders_criteria.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     2430 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/leader_qualifiers_model_organization.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     3616 2023-06-19 16:07:56.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/leader_qualifiers_response.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     2728 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/leader_summary_model.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     3580 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/leader_summary_response.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     6652 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/league_post_body.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     6530 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/league_put_body.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     8593 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/leagues_model.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     2336 2023-06-19 16:07:56.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/leagues_model_organization.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     3507 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/leagues_response.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     5994 2023-06-19 16:07:56.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/organization_post_body.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     5784 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/organization_put_body.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     7119 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/organizations_model.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     3579 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/organizations_response.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     5672 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/person_additional_details.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     5833 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/person_historical_name.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     2556 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/person_list_default_response.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)    13370 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/person_post_body.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     5720 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/person_post_body_additional_names_value.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)    13315 2023-06-19 16:07:56.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/person_put_body.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)    15343 2023-06-19 16:07:56.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/persons_model.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     2336 2023-06-19 16:07:56.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/persons_model_organization.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     3507 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/persons_response.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     6103 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/pool_post_body.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     5679 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/pool_put_body.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     5564 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/ranking_rows_model.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     4618 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/ranking_rows_post_body.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     4458 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/ranking_rows_put_body.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     3556 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/ranking_rows_response.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     2200 2023-06-19 16:07:56.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/response_links.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     3437 2023-06-19 16:07:56.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/response_meta_data.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)    11638 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/role_post_body.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)    11517 2023-06-19 16:07:56.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/role_put_body.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)    15525 2023-06-19 16:07:56.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/roles_model.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     2320 2023-06-19 16:07:56.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/roles_model_organization.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     3483 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/roles_response.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     7057 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/round_post_body.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     6627 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/round_put_body.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     8848 2023-06-19 16:07:56.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_entities_list_model.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     2444 2023-06-19 16:07:56.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_entities_list_model_organization.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     3641 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_entities_list_response.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     9018 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_entities_model.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     5624 2023-06-19 16:07:56.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_entities_post_body.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     3592 2023-06-19 16:07:56.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_entities_response.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     6248 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_entity_base_statistics_model.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     2514 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_entity_base_statistics_model_organization.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     3713 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_entity_base_statistics_post_body.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     3738 2023-06-19 16:07:56.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_entity_base_statistics_response.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     4059 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_entity_placings_model.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     3665 2023-06-19 16:07:56.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_entity_placings_response.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     5241 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_entity_statistics_model.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     2481 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_entity_statistics_model_organization.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     3689 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_entity_statistics_response.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     6222 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_fixture_stages_pools_list_model.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     2526 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_fixture_stages_pools_list_model_organization.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     2442 2023-06-19 16:07:56.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_fixture_stages_pools_list_model_pool.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     2452 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_fixture_stages_pools_list_model_stage.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     3772 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_fixture_stages_pools_list_response.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     6931 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_person_base_statistics_model.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     2514 2023-06-19 16:07:56.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_person_base_statistics_model_organization.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     3893 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_person_base_statistics_post_body.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     3738 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_person_base_statistics_response.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     4059 2023-06-19 16:07:56.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_person_placings_model.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     3665 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_person_placings_response.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     5731 2023-06-19 16:07:56.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_person_statistics_model.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     2481 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_person_statistics_model_organization.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     6195 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_person_statistics_periods_model.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     3783 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_person_statistics_periods_response.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     3689 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_person_statistics_response.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     5105 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_person_total_statistics_model.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     2522 2023-06-19 16:07:56.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_person_total_statistics_model_organization.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     3750 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_person_total_statistics_response.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     6836 2023-06-19 16:07:56.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_persons_list_model.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     2436 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_persons_list_model_organization.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     3629 2023-06-19 16:07:56.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_persons_list_response.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     7006 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_persons_model.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     4072 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_persons_post_body.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     3580 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_persons_response.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     8501 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_pools_model.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     2362 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_pools_model_organization.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     3556 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_pools_response.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)    18148 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_post_body.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)    18363 2023-06-19 16:07:56.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_put_body.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)    10457 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_roster_model.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     2378 2023-06-19 16:07:56.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_roster_model_organization.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     5981 2023-06-19 16:07:56.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_roster_post_body.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     3568 2023-06-19 16:07:56.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_roster_response.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     9996 2023-06-19 16:07:56.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_rounds_model.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     2370 2023-06-19 16:07:56.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_rounds_model_organization.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     3568 2023-06-19 16:07:56.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_rounds_response.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     4466 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_series_competitor.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)    16333 2023-06-19 16:07:56.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_series_model.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     2371 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_series_model_organization.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     3568 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_series_response.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     5733 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_stage_post_body.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     5248 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_stage_put_body.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     7537 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_stages_model.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     2377 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_stages_model_organization.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     3568 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_stages_response.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     5288 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_standings_stages_pools_list_model.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     2542 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_standings_stages_pools_list_model_organization.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     3796 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_standings_stages_pools_list_response.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     5276 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_venues_address.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)    11002 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_venues_list_model.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     2428 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_venues_list_model_organization.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     2326 2023-06-19 16:07:56.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_venues_list_model_site.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     3617 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_venues_list_response.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     3543 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/seasonentity_placings_post_body.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     3354 2023-06-19 16:07:56.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/seasonentity_placings_put_body.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     3543 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/seasonperson_placings_post_body.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     3354 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/seasonperson_placings_put_body.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     3957 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/seasonroster_configuration.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)    22249 2023-06-19 16:07:56.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/seasons_model.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     2326 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/seasons_model_competition.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     2351 2023-06-19 16:07:56.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/seasons_model_fixture_profile.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     2336 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/seasons_model_organization.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     2452 2023-06-19 16:07:56.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/seasons_model_standing_configuration.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     3507 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/seasons_response.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)    12210 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/series_post_body.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)    11915 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/series_put_body.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     5211 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/site_address.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     6538 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/site_post_body.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     6354 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/site_put_body.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     7786 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/sites_model.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     2320 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/sites_model_organization.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     3483 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/sites_response.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     3245 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/social_media.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     2237 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/sorting.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)    12332 2023-06-19 16:07:56.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/standing_adjustment_post_body.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)    12243 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/standing_adjustment_put_body.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)    17425 2023-06-19 16:07:56.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/standing_adjustments_model.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     2457 2023-06-19 16:07:56.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/standing_adjustments_model_organization.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     3652 2023-06-19 16:07:56.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/standing_adjustments_response.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     4994 2023-06-19 16:07:56.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/standing_building.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)    13200 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/standing_configuration.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     6222 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/standing_configurations_model.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     2482 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/standing_configurations_model_organization.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     4849 2023-06-19 16:07:56.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/standing_configurations_post_body.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     4563 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/standing_configurations_put_body.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     3688 2023-06-19 16:07:56.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/standing_configurations_response.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)    12098 2023-06-19 16:07:56.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/standing_post_body.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)    18313 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/standing_post_body_calculated_value.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     4442 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/standing_post_body_points_value.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)    12099 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/standing_put_body.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)    18136 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/standings_model.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     2352 2023-06-19 16:07:56.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/standings_model_organization.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     3531 2023-06-19 16:07:56.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/standings_response.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     1778 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/success_model.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     3507 2023-06-19 16:07:56.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/success_response.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     2624 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/transfer_component.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     7246 2023-06-19 16:07:56.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/transfer_post_body.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     7087 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/transfer_put_body.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     9588 2023-06-19 16:07:56.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/transfers_model.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     2354 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/transfers_model_organization.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     3531 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/transfers_response.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     5219 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/venue_address.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     5326 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/venue_historical_name.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)    10631 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/venue_post_body.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)    10463 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/venue_put_body.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)    12568 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/venues_model.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     2328 2023-06-19 16:07:56.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/venues_model_organization.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     2248 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/venues_model_site.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     3495 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/venues_response.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     9562 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/video_file_post_body.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     2163 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/video_files_download_model.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     3641 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/video_files_download_response.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)    11486 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/video_files_model.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     2361 2023-06-19 16:07:56.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/video_files_model_organization.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     3544 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/video_files_response.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)    11747 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/video_stream_inputs_model.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     2441 2023-06-19 16:07:56.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/video_stream_inputs_model_organization.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     3629 2023-06-19 16:07:56.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/video_stream_inputs_response.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     5343 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/video_stream_local_model.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     2433 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/video_stream_local_model_organization.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     3473 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/video_stream_local_post_body.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     3312 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/video_stream_local_put_body.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     3617 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/video_stream_local_response.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     9468 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/video_stream_outputs_model.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     2449 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/video_stream_outputs_model_organization.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     3641 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/video_stream_outputs_response.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)    11463 2023-06-19 16:07:56.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/video_subscription_post_body.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)    11577 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/video_subscription_put_body.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)    13664 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/video_subscriptions_model.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     2447 2023-06-19 16:07:57.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/video_subscriptions_model_organization.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     3640 2023-06-19 16:07:56.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/video_subscriptions_response.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)    12618 2023-06-19 16:07:56.000000 atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/rest.py
+drwxr-xr-x   0 k.kieda    (502) staff       (20)        0 2023-06-19 16:08:31.097460 atriumsports_sdk-1.2.0/atriumsports/datacore_stream/
+-rw-r--r--   0 k.kieda    (502) staff       (20)        0 2023-03-17 13:13:17.000000 atriumsports_sdk-1.2.0/atriumsports/datacore_stream/__init__.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     6124 2023-04-24 10:52:46.000000 atriumsports_sdk-1.2.0/atriumsports/datacore_stream/datacore_stream.py
+-rw-r--r--   0 k.kieda    (502) staff       (20)     1942 2023-06-16 15:50:29.000000 atriumsports_sdk-1.2.0/atriumsports/endpoints.py
+drwxr-xr-x   0 k.kieda    (502) staff       (20)        0 2023-06-19 16:08:31.098856 atriumsports_sdk-1.2.0/atriumsports_sdk.egg-info/
+-rw-r--r--   0 k.kieda    (502) staff       (20)     5380 2023-06-19 16:08:30.000000 atriumsports_sdk-1.2.0/atriumsports_sdk.egg-info/PKG-INFO
+-rw-r--r--   0 k.kieda    (502) staff       (20)    27051 2023-06-19 16:08:30.000000 atriumsports_sdk-1.2.0/atriumsports_sdk.egg-info/SOURCES.txt
+-rw-r--r--   0 k.kieda    (502) staff       (20)        1 2023-06-19 16:08:30.000000 atriumsports_sdk-1.2.0/atriumsports_sdk.egg-info/dependency_links.txt
+-rw-r--r--   0 k.kieda    (502) staff       (20)      108 2023-06-19 16:08:30.000000 atriumsports_sdk-1.2.0/atriumsports_sdk.egg-info/requires.txt
+-rw-r--r--   0 k.kieda    (502) staff       (20)       13 2023-06-19 16:08:30.000000 atriumsports_sdk-1.2.0/atriumsports_sdk.egg-info/top_level.txt
+-rw-r--r--   0 k.kieda    (502) staff       (20)       80 2023-04-24 10:51:20.000000 atriumsports_sdk-1.2.0/pyproject.toml
+-rw-r--r--   0 k.kieda    (502) staff       (20)       38 2023-06-19 16:08:31.099390 atriumsports_sdk-1.2.0/setup.cfg
+-rw-r--r--   0 k.kieda    (502) staff       (20)      947 2023-06-15 14:59:10.000000 atriumsports_sdk-1.2.0/setup.py
```

### Comparing `atriumsports_sdk-1.1.0/LICENSE` & `atriumsports_sdk-1.2.0/LICENSE`

 * *Files identical despite different names*

### Comparing `atriumsports_sdk-1.1.0/PKG-INFO` & `atriumsports_sdk-1.2.0/PKG-INFO`

 * *Files 2% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: atriumsports_sdk
-Version: 1.1.0
+Version: 1.2.0
 Summary: Python module for integration to Atrium Sports APIs
 Author: Atrium Sports
 Author-email: python_dev@atriumsports.com
 Classifier: Programming Language :: Python :: 3
 Classifier: License :: OSI Approved :: MIT License
 Classifier: Operating System :: OS Independent
 Requires-Python: >=3.7
@@ -21,15 +21,15 @@
 from atriumsports import AtriumSports
 
 atrium = AtriumSports(
     {
         "sport": "basketball",
         "credential_id": "XXXXX",
         "credential_secret": "YYYY",
-        "organizations": ["b1e34"],
+        "organizations": ["b1a23"],
     }
 )
 datacore = atrium.client("datacore")
 response = datacore.get("/o/b1a23/competitions", limit=500)
 for data in response.data():
     print(data)
 ```
@@ -45,15 +45,15 @@
 from atriumsports.datacore.openapi import CompetitionsApi
 
 atrium = AtriumSports(
     {
         "sport": "basketball",
         "credential_id": "XXXXX",
         "credential_secret": "YYYY",
-        "organizations": ["b1e34"],
+        "organizations": ["b1a23"],
     }
 )
 datacore = atrium.client("datacore")
 # prepare api client with access token and connection pool
 with datacore as api_client:
     # create api instance object for handling input and output of chosen endpoint
     api_instance = CompetitionsApi(api_client)
@@ -103,15 +103,15 @@
     )
 
     assert response.data[0].status == "ACTIVE"
 ```
 
 ### Response body
 
-Response body is a pydanitc object containing deserialized response data.
+Response body is a pydantic object containing deserialized response data.
 
 Example:
 
 ```python
 from atriumsports import AtriumSports
 from atriumsports.datacore.openapi import LeaguesApi
```

### Comparing `atriumsports_sdk-1.1.0/README.md` & `atriumsports_sdk-1.2.0/README.md`

 * *Files 1% similar despite different names*

```diff
@@ -8,15 +8,15 @@
 from atriumsports import AtriumSports
 
 atrium = AtriumSports(
     {
         "sport": "basketball",
         "credential_id": "XXXXX",
         "credential_secret": "YYYY",
-        "organizations": ["b1e34"],
+        "organizations": ["b1a23"],
     }
 )
 datacore = atrium.client("datacore")
 response = datacore.get("/o/b1a23/competitions", limit=500)
 for data in response.data():
     print(data)
 ```
@@ -32,15 +32,15 @@
 from atriumsports.datacore.openapi import CompetitionsApi
 
 atrium = AtriumSports(
     {
         "sport": "basketball",
         "credential_id": "XXXXX",
         "credential_secret": "YYYY",
-        "organizations": ["b1e34"],
+        "organizations": ["b1a23"],
     }
 )
 datacore = atrium.client("datacore")
 # prepare api client with access token and connection pool
 with datacore as api_client:
     # create api instance object for handling input and output of chosen endpoint
     api_instance = CompetitionsApi(api_client)
@@ -90,15 +90,15 @@
     )
 
     assert response.data[0].status == "ACTIVE"
 ```
 
 ### Response body
 
-Response body is a pydanitc object containing deserialized response data.
+Response body is a pydantic object containing deserialized response data.
 
 Example:
 
 ```python
 from atriumsports import AtriumSports
 from atriumsports.datacore.openapi import LeaguesApi
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/__init__.py` & `atriumsports_sdk-1.2.0/atriumsports/__init__.py`

 * *Files identical despite different names*

### Comparing `atriumsports_sdk-1.1.0/atriumsports/atrium_response.py` & `atriumsports_sdk-1.2.0/atriumsports/atrium_response.py`

 * *Files identical despite different names*

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/datacore.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/datacore.py`

 * *Files identical despite different names*

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/__init__.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/__init__.py`

 * *Files 0% similar despite different names*

```diff
@@ -237,15 +237,15 @@
 
 This **access token** must then be sent in the `Authorization` header for each subsequent API call.  Access tokens have a finite life and will expire. When the token expires you will need to create a new token to make more API calls.  Creation of tokens is rate-limited, so you should use the existing token as long as possible.
 
 <!-- ReDoc-Inject: <security-definitions> -->
   # noqa: E501
 """
 
-__version__ = "1.1.0"
+__version__ = "1.2.0"
 
 # import apis into sdk package
 from atriumsports.datacore.openapi.api.awards_api import AwardsApi
 from atriumsports.datacore.openapi.api.career_statistics_api import CareerStatisticsApi
 from atriumsports.datacore.openapi.api.change_log_api import ChangeLogApi
 from atriumsports.datacore.openapi.api.competition_statistics_api import CompetitionStatisticsApi
 from atriumsports.datacore.openapi.api.competitions_api import CompetitionsApi
@@ -297,14 +297,15 @@
 from atriumsports.datacore.openapi.api.venues_api import VenuesApi
 from atriumsports.datacore.openapi.api.video_stream_inputs_api import VideoStreamInputsApi
 from atriumsports.datacore.openapi.api.video_stream_subscriptions_api import VideoStreamSubscriptionsApi
 from atriumsports.datacore.openapi.api.video_streams_available_api import VideoStreamsAvailableApi
 
 # import ApiClient
 from atriumsports.datacore.openapi.api_client import ApiClient
+from atriumsports.datacore.openapi.api_response import ApiResponse
 from atriumsports.datacore.openapi.configuration import Configuration
 from atriumsports.datacore.openapi.exceptions import (
     ApiAttributeError,
     ApiException,
     ApiKeyError,
     ApiTypeError,
     ApiValueError,
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/api/__init__.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/api/__init__.py`

 * *Files identical despite different names*

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/api/awards_api.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/api/awards_api.py`

 * *Files 2% similar despite different names*

```diff
@@ -8,23 +8,26 @@
     The version of the OpenAPI document: v1
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the file manually.
 """
 
 
+import io
 import logging
 import re  # noqa: F401
+import warnings
 from datetime import datetime
 from typing import Optional
 
 from pydantic import Field, StrictBool, StrictInt, StrictStr, ValidationError, conint, constr, validate_arguments
 from typing_extensions import Annotated
 
 from atriumsports.datacore.openapi.api_client import ApiClient
+from atriumsports.datacore.openapi.api_response import ApiResponse
 from atriumsports.datacore.openapi.exceptions import ApiTypeError, ApiValueError  # noqa: F401
 from atriumsports.datacore.openapi.models.award_post_body import AwardPostBody
 from atriumsports.datacore.openapi.models.award_put_body import AwardPutBody
 from atriumsports.datacore.openapi.models.awards_response import AwardsResponse
 
 logger = logging.getLogger("openapi")
 
@@ -102,28 +105,28 @@
         :type force_delete: bool
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: AwardsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the award_delete_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.award_delete_with_http_info(
                 award_id, organization_id, sport, external, fields, force_delete, hide_null, include, **kwargs
             )  # noqa: E501
         except Exception as e:
             logger.error("Exception when calling AwardsApi->award_delete: %s\n" % e)
             raise
@@ -161,15 +164,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Delete an award  # noqa: E501
 
         Delete a specific award  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.award_delete_with_http_info(award_id, organization_id, sport, external, fields, force_delete, hide_null, include, async_req=True)
@@ -189,21 +192,22 @@
         :type force_delete: bool
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -381,28 +385,28 @@
         :type include: str
         :param limit: The maximum number of records to return. See [Pagination](#section/Introduction/Pagination) for more information.
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: AwardsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the awards_detail_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.awards_detail_with_http_info(
                 award_id, organization_id, sport, external, fields, hide_null, include, limit, offset, **kwargs
             )  # noqa: E501
         except Exception as e:
             logger.error("Exception when calling AwardsApi->awards_detail: %s\n" % e)
             raise
@@ -446,15 +450,15 @@
         offset: Annotated[
             Optional[StrictInt],
             Field(
                 description="The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Get an award  # noqa: E501
 
         Return detailed information about a specific award  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.awards_detail_with_http_info(award_id, organization_id, sport, external, fields, hide_null, include, limit, offset, async_req=True)
@@ -476,21 +480,22 @@
         :type include: str
         :param limit: The maximum number of records to return. See [Pagination](#section/Introduction/Pagination) for more information.
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -656,28 +661,28 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: AwardsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the awards_insert_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.awards_insert_with_http_info(
                 organization_id, sport, award_post_body, external, fields, hide_null, include, **kwargs
             )  # noqa: E501
         except Exception as e:
             logger.error("Exception when calling AwardsApi->awards_insert: %s\n" % e)
             raise
@@ -709,15 +714,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Create an award  # noqa: E501
 
         Add a new award  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.awards_insert_with_http_info(organization_id, sport, award_post_body, external, fields, hide_null, include, async_req=True)
@@ -735,21 +740,22 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -810,15 +816,15 @@
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params["award_post_body"]:
+        if _params["award_post_body"] is not None:
             _body_params = _params["award_post_body"]
 
         # set the HTTP header `Accept`
         _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501
 
         # set the HTTP header `Content-Type`
         _content_types_list = _params.get(
@@ -961,28 +967,28 @@
         :type person_id: str
         :param season_id: The unique identifier of the season
         :type season_id: str
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: AwardsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the awards_list_fixtures_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.awards_list_fixtures_with_http_info(
                 organization_id,
                 sport,
                 added,
                 award,
                 date_from_end,
@@ -1064,15 +1070,15 @@
         ] = None,
         person_id: Annotated[Optional[StrictStr], Field(description="The unique identifier of the person")] = None,
         season_id: Annotated[Optional[StrictStr], Field(description="The unique identifier of the season")] = None,
         updated: Annotated[
             Optional[datetime], Field(description="Record was modified after this date/time. In UTC.")
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Get a list of fixture awards  # noqa: E501
 
         Return a list of awards for the organization (linked to fixtures)  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.awards_list_fixtures_with_http_info(organization_id, sport, added, award, date_from_end, date_from_start, date_to_end, date_to_start, entity_id, external, fields, fixture_id, hide_null, include, limit, offset, person_id, season_id, updated, async_req=True)
@@ -1114,21 +1120,22 @@
         :type person_id: str
         :param season_id: The unique identifier of the season
         :type season_id: str
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1199,15 +1206,15 @@
                 _query_params.append(
                     ("added", _params["added"].strftime(self.api_client.configuration.datetime_format))
                 )
             else:
                 _query_params.append(("added", _params["added"]))
 
         if _params.get("award") is not None:  # noqa: E501
-            _query_params.append(("award", _params["award"]))
+            _query_params.append(("award", _params["award"].value))
 
         if _params.get("date_from_end") is not None:  # noqa: E501
             if isinstance(_params["date_from_end"], datetime):
                 _query_params.append(
                     ("dateFromEnd", _params["date_from_end"].strftime(self.api_client.configuration.datetime_format))
                 )
             else:
@@ -1416,28 +1423,28 @@
         :type offset: int
         :param person_id: The unique identifier of the person
         :type person_id: str
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: AwardsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the awards_list_non_fixtures_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.awards_list_non_fixtures_with_http_info(
                 organization_id,
                 sport,
                 added,
                 award,
                 date_from_end,
@@ -1515,15 +1522,15 @@
             ),
         ] = None,
         person_id: Annotated[Optional[StrictStr], Field(description="The unique identifier of the person")] = None,
         updated: Annotated[
             Optional[datetime], Field(description="Record was modified after this date/time. In UTC.")
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Get a list of non-fixture awards  # noqa: E501
 
         Return a list of awards not linked to fixtures  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.awards_list_non_fixtures_with_http_info(organization_id, sport, added, award, date_from_end, date_from_start, date_to_end, date_to_start, entity_id, external, fields, hide_null, include, limit, offset, person_id, updated, async_req=True)
@@ -1561,21 +1568,22 @@
         :type offset: int
         :param person_id: The unique identifier of the person
         :type person_id: str
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1646,15 +1654,15 @@
                 _query_params.append(
                     ("added", _params["added"].strftime(self.api_client.configuration.datetime_format))
                 )
             else:
                 _query_params.append(("added", _params["added"]))
 
         if _params.get("award") is not None:  # noqa: E501
-            _query_params.append(("award", _params["award"]))
+            _query_params.append(("award", _params["award"].value))
 
         if _params.get("date_from_end") is not None:  # noqa: E501
             if isinstance(_params["date_from_end"], datetime):
                 _query_params.append(
                     ("dateFromEnd", _params["date_from_end"].strftime(self.api_client.configuration.datetime_format))
                 )
             else:
@@ -1860,28 +1868,28 @@
         :type person_id: str
         :param season_id: The unique identifier of the season
         :type season_id: str
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: AwardsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the awards_list_seasons_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.awards_list_seasons_with_http_info(
                 organization_id,
                 sport,
                 added,
                 award,
                 date_from_end,
@@ -1961,15 +1969,15 @@
         ] = None,
         person_id: Annotated[Optional[StrictStr], Field(description="The unique identifier of the person")] = None,
         season_id: Annotated[Optional[StrictStr], Field(description="The unique identifier of the season")] = None,
         updated: Annotated[
             Optional[datetime], Field(description="Record was modified after this date/time. In UTC.")
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Get a list of season awards  # noqa: E501
 
         Return a list of awards for the organization (linked to seasons)  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.awards_list_seasons_with_http_info(organization_id, sport, added, award, date_from_end, date_from_start, date_to_end, date_to_start, entity_id, external, fields, hide_null, include, limit, offset, person_id, season_id, updated, async_req=True)
@@ -2009,21 +2017,22 @@
         :type person_id: str
         :param season_id: The unique identifier of the season
         :type season_id: str
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -2093,15 +2102,15 @@
                 _query_params.append(
                     ("added", _params["added"].strftime(self.api_client.configuration.datetime_format))
                 )
             else:
                 _query_params.append(("added", _params["added"]))
 
         if _params.get("award") is not None:  # noqa: E501
-            _query_params.append(("award", _params["award"]))
+            _query_params.append(("award", _params["award"].value))
 
         if _params.get("date_from_end") is not None:  # noqa: E501
             if isinstance(_params["date_from_end"], datetime):
                 _query_params.append(
                     ("dateFromEnd", _params["date_from_end"].strftime(self.api_client.configuration.datetime_format))
                 )
             else:
@@ -2261,28 +2270,28 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: AwardsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the awards_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.awards_update_with_http_info(
                 award_id, organization_id, sport, award_put_body, external, fields, hide_null, include, **kwargs
             )  # noqa: E501
         except Exception as e:
             logger.error("Exception when calling AwardsApi->awards_update: %s\n" % e)
             raise
@@ -2315,15 +2324,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Update an award  # noqa: E501
 
         Change the information of a specific award  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.awards_update_with_http_info(award_id, organization_id, sport, award_put_body, external, fields, hide_null, include, async_req=True)
@@ -2343,21 +2352,22 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -2430,15 +2440,15 @@
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params["award_put_body"]:
+        if _params["award_put_body"] is not None:
             _body_params = _params["award_put_body"]
 
         # set the HTTP header `Accept`
         _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501
 
         # set the HTTP header `Content-Type`
         _content_types_list = _params.get(
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/api/career_statistics_api.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/api/career_statistics_api.py`

 * *Files 2% similar despite different names*

```diff
@@ -8,22 +8,25 @@
     The version of the OpenAPI document: v1
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the file manually.
 """
 
 
+import io
 import logging
 import re  # noqa: F401
+import warnings
 from typing import Optional
 
 from pydantic import Field, StrictBool, StrictInt, StrictStr, ValidationError, conint, constr, validate_arguments
 from typing_extensions import Annotated
 
 from atriumsports.datacore.openapi.api_client import ApiClient
+from atriumsports.datacore.openapi.api_response import ApiResponse
 from atriumsports.datacore.openapi.exceptions import ApiTypeError, ApiValueError  # noqa: F401
 from atriumsports.datacore.openapi.models.career_person_statistics_response import CareerPersonStatisticsResponse
 
 logger = logging.getLogger("openapi")
 
 
 class CareerStatisticsApi(object):
@@ -139,28 +142,28 @@
         :type person_id: str
         :param starter: Is the person a starter in the fixture ?
         :type starter: bool
         :param win_loss: What the result was >- `DRAW` Draw >- `LOSS` Loss >- `WIN` Win
         :type win_loss: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: CareerPersonStatisticsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the caps_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.caps_list_with_http_info(
                 organization_id,
                 sport,
                 entity_id,
                 external,
                 fields,
@@ -238,15 +241,15 @@
         person_id: Annotated[Optional[StrictStr], Field(description="The unique identifier of the person")] = None,
         starter: Annotated[Optional[StrictBool], Field(description="Is the person a starter in the fixture ?")] = None,
         win_loss: Annotated[
             Optional[constr(strict=True, max_length=50)],
             Field(description="What the result was >- `DRAW` Draw >- `LOSS` Loss >- `WIN` Win "),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Person career statistics  # noqa: E501
 
         Return a list of person statistic totals for their career covering all competitions  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.caps_list_with_http_info(organization_id, sport, entity_id, external, fields, fixture_type, hide_null, home_away, include, is_player, is_team_official, limit, offset, person_id, starter, win_loss, async_req=True)
@@ -282,21 +285,22 @@
         :type person_id: str
         :param starter: Is the person a starter in the fixture ?
         :type starter: bool
         :param win_loss: What the result was >- `DRAW` Draw >- `LOSS` Loss >- `WIN` Win
         :type win_loss: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -365,21 +369,21 @@
         if _params.get("external") is not None:  # noqa: E501
             _query_params.append(("external", _params["external"]))
 
         if _params.get("fields") is not None:  # noqa: E501
             _query_params.append(("fields", _params["fields"]))
 
         if _params.get("fixture_type") is not None:  # noqa: E501
-            _query_params.append(("fixtureType", _params["fixture_type"]))
+            _query_params.append(("fixtureType", _params["fixture_type"].value))
 
         if _params.get("hide_null") is not None:  # noqa: E501
             _query_params.append(("hideNull", _params["hide_null"]))
 
         if _params.get("home_away") is not None:  # noqa: E501
-            _query_params.append(("homeAway", _params["home_away"]))
+            _query_params.append(("homeAway", _params["home_away"].value))
 
         if _params.get("include") is not None:  # noqa: E501
             _query_params.append(("include", _params["include"]))
 
         if _params.get("is_player") is not None:  # noqa: E501
             _query_params.append(("isPlayer", _params["is_player"]))
 
@@ -395,15 +399,15 @@
         if _params.get("person_id") is not None:  # noqa: E501
             _query_params.append(("personId", _params["person_id"]))
 
         if _params.get("starter") is not None:  # noqa: E501
             _query_params.append(("starter", _params["starter"]))
 
         if _params.get("win_loss") is not None:  # noqa: E501
-            _query_params.append(("winLoss", _params["win_loss"]))
+            _query_params.append(("winLoss", _params["win_loss"].value))
 
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
@@ -535,28 +539,28 @@
         :type offset: int
         :param starter: Is the person a starter in the fixture ?
         :type starter: bool
         :param win_loss: What the result was >- `DRAW` Draw >- `LOSS` Loss >- `WIN` Win
         :type win_loss: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: CareerPersonStatisticsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the caps_listperson_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.caps_listperson_with_http_info(
                 organization_id,
                 person_id,
                 sport,
                 external,
                 fields,
@@ -632,15 +636,15 @@
         ] = None,
         starter: Annotated[Optional[StrictBool], Field(description="Is the person a starter in the fixture ?")] = None,
         win_loss: Annotated[
             Optional[constr(strict=True, max_length=50)],
             Field(description="What the result was >- `DRAW` Draw >- `LOSS` Loss >- `WIN` Win "),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Statistics for a person in their career  # noqa: E501
 
         Return the statistics for a specific person in their career.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.caps_listperson_with_http_info(organization_id, person_id, sport, external, fields, fixture_type, hide_null, home_away, include, is_player, is_team_official, limit, offset, starter, win_loss, async_req=True)
@@ -674,21 +678,22 @@
         :type offset: int
         :param starter: Is the person a starter in the fixture ?
         :type starter: bool
         :param win_loss: What the result was >- `DRAW` Draw >- `LOSS` Loss >- `WIN` Win
         :type win_loss: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -756,21 +761,21 @@
         if _params.get("external") is not None:  # noqa: E501
             _query_params.append(("external", _params["external"]))
 
         if _params.get("fields") is not None:  # noqa: E501
             _query_params.append(("fields", _params["fields"]))
 
         if _params.get("fixture_type") is not None:  # noqa: E501
-            _query_params.append(("fixtureType", _params["fixture_type"]))
+            _query_params.append(("fixtureType", _params["fixture_type"].value))
 
         if _params.get("hide_null") is not None:  # noqa: E501
             _query_params.append(("hideNull", _params["hide_null"]))
 
         if _params.get("home_away") is not None:  # noqa: E501
-            _query_params.append(("homeAway", _params["home_away"]))
+            _query_params.append(("homeAway", _params["home_away"].value))
 
         if _params.get("include") is not None:  # noqa: E501
             _query_params.append(("include", _params["include"]))
 
         if _params.get("is_player") is not None:  # noqa: E501
             _query_params.append(("isPlayer", _params["is_player"]))
 
@@ -783,15 +788,15 @@
         if _params.get("offset") is not None:  # noqa: E501
             _query_params.append(("offset", _params["offset"]))
 
         if _params.get("starter") is not None:  # noqa: E501
             _query_params.append(("starter", _params["starter"]))
 
         if _params.get("win_loss") is not None:  # noqa: E501
-            _query_params.append(("winLoss", _params["win_loss"]))
+            _query_params.append(("winLoss", _params["win_loss"].value))
 
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/api/change_log_api.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/api/change_log_api.py`

 * *Files 1% similar despite different names*

```diff
@@ -8,23 +8,26 @@
     The version of the OpenAPI document: v1
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the file manually.
 """
 
 
+import io
 import logging
 import re  # noqa: F401
+import warnings
 from datetime import datetime
 from typing import Optional
 
 from pydantic import Field, StrictBool, StrictInt, StrictStr, ValidationError, conint, constr, validate_arguments
 from typing_extensions import Annotated
 
 from atriumsports.datacore.openapi.api_client import ApiClient
+from atriumsports.datacore.openapi.api_response import ApiResponse
 from atriumsports.datacore.openapi.exceptions import ApiTypeError, ApiValueError  # noqa: F401
 from atriumsports.datacore.openapi.models.change_log_response import ChangeLogResponse
 
 logger = logging.getLogger("openapi")
 
 
 class ChangeLogApi(object):
@@ -133,28 +136,28 @@
         :type offset: int
         :param primary_id: The unique identifier of the primaryType
         :type primary_id: str
         :param primary_type: The primary table changed
         :type primary_type: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: ChangeLogResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the change_log_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.change_log_list_with_http_info(
                 organization_id,
                 sport,
                 added,
                 change_type,
                 child_type,
@@ -228,15 +231,15 @@
         primary_id: Annotated[
             Optional[StrictStr], Field(description="The unique identifier of the primaryType")
         ] = None,
         primary_type: Annotated[
             Optional[constr(strict=True, max_length=30)], Field(description="The primary table changed")
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Get a list of changes  # noqa: E501
 
         Return a list of available changes  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.change_log_list_with_http_info(organization_id, sport, added, change_type, child_type, external, fields, hide_null, include, limit, offset, primary_id, primary_type, async_req=True)
@@ -266,21 +269,22 @@
         :type offset: int
         :param primary_id: The unique identifier of the primaryType
         :type primary_id: str
         :param primary_type: The primary table changed
         :type primary_type: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -345,15 +349,15 @@
                 _query_params.append(
                     ("added", _params["added"].strftime(self.api_client.configuration.datetime_format))
                 )
             else:
                 _query_params.append(("added", _params["added"]))
 
         if _params.get("change_type") is not None:  # noqa: E501
-            _query_params.append(("changeType", _params["change_type"]))
+            _query_params.append(("changeType", _params["change_type"].value))
 
         if _params.get("child_type") is not None:  # noqa: E501
             _query_params.append(("childType", _params["child_type"]))
 
         if _params.get("external") is not None:  # noqa: E501
             _query_params.append(("external", _params["external"]))
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/api/competition_statistics_api.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/api/competition_statistics_api.py`

 * *Files 3% similar despite different names*

```diff
@@ -8,22 +8,25 @@
     The version of the OpenAPI document: v1
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the file manually.
 """
 
 
+import io
 import logging
 import re  # noqa: F401
+import warnings
 from typing import Optional
 
 from pydantic import Field, StrictBool, StrictInt, StrictStr, ValidationError, conint, constr, validate_arguments
 from typing_extensions import Annotated
 
 from atriumsports.datacore.openapi.api_client import ApiClient
+from atriumsports.datacore.openapi.api_response import ApiResponse
 from atriumsports.datacore.openapi.exceptions import ApiTypeError, ApiValueError  # noqa: F401
 from atriumsports.datacore.openapi.models.competition_entity_statistics_response import (
     CompetitionEntityStatisticsResponse,
 )
 from atriumsports.datacore.openapi.models.competition_person_statistics_response import (
     CompetitionPersonStatisticsResponse,
 )
@@ -135,28 +138,28 @@
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param win_loss: What the result was >- `DRAW` Draw >- `LOSS` Loss >- `WIN` Win
         :type win_loss: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: CompetitionEntityStatisticsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the ces_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.ces_list_with_http_info(
                 competition_id,
                 organization_id,
                 sport,
                 entity_id,
                 external,
@@ -228,15 +231,15 @@
             ),
         ] = None,
         win_loss: Annotated[
             Optional[constr(strict=True, max_length=50)],
             Field(description="What the result was >- `DRAW` Draw >- `LOSS` Loss >- `WIN` Win "),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Entity statistics for a competition  # noqa: E501
 
         Return a list of entity statistic totals for a competition  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.ces_list_with_http_info(competition_id, organization_id, sport, entity_id, external, fields, fixture_type, hide_null, home_away, include, limit, offset, win_loss, async_req=True)
@@ -266,21 +269,22 @@
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param win_loss: What the result was >- `DRAW` Draw >- `LOSS` Loss >- `WIN` Win
         :type win_loss: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -349,33 +353,33 @@
         if _params.get("external") is not None:  # noqa: E501
             _query_params.append(("external", _params["external"]))
 
         if _params.get("fields") is not None:  # noqa: E501
             _query_params.append(("fields", _params["fields"]))
 
         if _params.get("fixture_type") is not None:  # noqa: E501
-            _query_params.append(("fixtureType", _params["fixture_type"]))
+            _query_params.append(("fixtureType", _params["fixture_type"].value))
 
         if _params.get("hide_null") is not None:  # noqa: E501
             _query_params.append(("hideNull", _params["hide_null"]))
 
         if _params.get("home_away") is not None:  # noqa: E501
-            _query_params.append(("homeAway", _params["home_away"]))
+            _query_params.append(("homeAway", _params["home_away"].value))
 
         if _params.get("include") is not None:  # noqa: E501
             _query_params.append(("include", _params["include"]))
 
         if _params.get("limit") is not None:  # noqa: E501
             _query_params.append(("limit", _params["limit"]))
 
         if _params.get("offset") is not None:  # noqa: E501
             _query_params.append(("offset", _params["offset"]))
 
         if _params.get("win_loss") is not None:  # noqa: E501
-            _query_params.append(("winLoss", _params["win_loss"]))
+            _query_params.append(("winLoss", _params["win_loss"].value))
 
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
@@ -506,28 +510,28 @@
         :type offset: int
         :param section: The section of the period (sub-period)
         :type section: str
         :param win_loss: What the result was >- `DRAW` Draw >- `LOSS` Loss >- `WIN` Win
         :type win_loss: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: CompetitionEntityStatisticsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the ces_listentity_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.ces_listentity_with_http_info(
                 competition_id,
                 entity_id,
                 organization_id,
                 sport,
                 external,
@@ -603,15 +607,15 @@
             Optional[constr(strict=True, max_length=100)], Field(description="The section of the period (sub-period)")
         ] = None,
         win_loss: Annotated[
             Optional[constr(strict=True, max_length=50)],
             Field(description="What the result was >- `DRAW` Draw >- `LOSS` Loss >- `WIN` Win "),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Statistics for an entity in a competition  # noqa: E501
 
         Return the statistic totals for a specific entity in a competition.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.ces_listentity_with_http_info(competition_id, entity_id, organization_id, sport, external, fields, fixture_type, hide_null, home_away, include, limit, offset, section, win_loss, async_req=True)
@@ -643,21 +647,22 @@
         :type offset: int
         :param section: The section of the period (sub-period)
         :type section: str
         :param win_loss: What the result was >- `DRAW` Draw >- `LOSS` Loss >- `WIN` Win
         :type win_loss: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -727,36 +732,36 @@
         if _params.get("external") is not None:  # noqa: E501
             _query_params.append(("external", _params["external"]))
 
         if _params.get("fields") is not None:  # noqa: E501
             _query_params.append(("fields", _params["fields"]))
 
         if _params.get("fixture_type") is not None:  # noqa: E501
-            _query_params.append(("fixtureType", _params["fixture_type"]))
+            _query_params.append(("fixtureType", _params["fixture_type"].value))
 
         if _params.get("hide_null") is not None:  # noqa: E501
             _query_params.append(("hideNull", _params["hide_null"]))
 
         if _params.get("home_away") is not None:  # noqa: E501
-            _query_params.append(("homeAway", _params["home_away"]))
+            _query_params.append(("homeAway", _params["home_away"].value))
 
         if _params.get("include") is not None:  # noqa: E501
             _query_params.append(("include", _params["include"]))
 
         if _params.get("limit") is not None:  # noqa: E501
             _query_params.append(("limit", _params["limit"]))
 
         if _params.get("offset") is not None:  # noqa: E501
             _query_params.append(("offset", _params["offset"]))
 
         if _params.get("section") is not None:  # noqa: E501
             _query_params.append(("section", _params["section"]))
 
         if _params.get("win_loss") is not None:  # noqa: E501
-            _query_params.append(("winLoss", _params["win_loss"]))
+            _query_params.append(("winLoss", _params["win_loss"].value))
 
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
@@ -890,28 +895,28 @@
         :type period_id: int
         :param section: The section of the period (sub-period)
         :type section: str
         :param win_loss: What the result was >- `DRAW` Draw >- `LOSS` Loss >- `WIN` Win
         :type win_loss: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: CompetitionEntityStatisticsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the ces_listentity_periods_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.ces_listentity_periods_with_http_info(
                 competition_id,
                 entity_id,
                 organization_id,
                 sport,
                 external,
@@ -989,15 +994,15 @@
             Optional[constr(strict=True, max_length=100)], Field(description="The section of the period (sub-period)")
         ] = None,
         win_loss: Annotated[
             Optional[constr(strict=True, max_length=50)],
             Field(description="What the result was >- `DRAW` Draw >- `LOSS` Loss >- `WIN` Win "),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Statistics for an entity in a competition  # noqa: E501
 
         Return the statistics for a specific entity in a competition.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.ces_listentity_periods_with_http_info(competition_id, entity_id, organization_id, sport, external, fields, fixture_type, hide_null, home_away, include, limit, offset, period_id, section, win_loss, async_req=True)
@@ -1031,21 +1036,22 @@
         :type period_id: int
         :param section: The section of the period (sub-period)
         :type section: str
         :param win_loss: What the result was >- `DRAW` Draw >- `LOSS` Loss >- `WIN` Win
         :type win_loss: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1116,21 +1122,21 @@
         if _params.get("external") is not None:  # noqa: E501
             _query_params.append(("external", _params["external"]))
 
         if _params.get("fields") is not None:  # noqa: E501
             _query_params.append(("fields", _params["fields"]))
 
         if _params.get("fixture_type") is not None:  # noqa: E501
-            _query_params.append(("fixtureType", _params["fixture_type"]))
+            _query_params.append(("fixtureType", _params["fixture_type"].value))
 
         if _params.get("hide_null") is not None:  # noqa: E501
             _query_params.append(("hideNull", _params["hide_null"]))
 
         if _params.get("home_away") is not None:  # noqa: E501
-            _query_params.append(("homeAway", _params["home_away"]))
+            _query_params.append(("homeAway", _params["home_away"].value))
 
         if _params.get("include") is not None:  # noqa: E501
             _query_params.append(("include", _params["include"]))
 
         if _params.get("limit") is not None:  # noqa: E501
             _query_params.append(("limit", _params["limit"]))
 
@@ -1140,15 +1146,15 @@
         if _params.get("period_id") is not None:  # noqa: E501
             _query_params.append(("periodId", _params["period_id"]))
 
         if _params.get("section") is not None:  # noqa: E501
             _query_params.append(("section", _params["section"]))
 
         if _params.get("win_loss") is not None:  # noqa: E501
-            _query_params.append(("winLoss", _params["win_loss"]))
+            _query_params.append(("winLoss", _params["win_loss"].value))
 
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
@@ -1279,28 +1285,28 @@
         :type period_id: int
         :param section: The section of the period (sub-period)
         :type section: str
         :param win_loss: What the result was >- `DRAW` Draw >- `LOSS` Loss >- `WIN` Win
         :type win_loss: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: CompetitionEntityStatisticsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the ces_listperiods_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.ces_listperiods_with_http_info(
                 competition_id,
                 organization_id,
                 sport,
                 external,
                 fields,
@@ -1376,15 +1382,15 @@
             Optional[constr(strict=True, max_length=100)], Field(description="The section of the period (sub-period)")
         ] = None,
         win_loss: Annotated[
             Optional[constr(strict=True, max_length=50)],
             Field(description="What the result was >- `DRAW` Draw >- `LOSS` Loss >- `WIN` Win "),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Entity statistics for a competition by period  # noqa: E501
 
         Return a list of entity statistics for a competition filterable by period. This still displays aggregated/summed data, and should return the same values as the non by-period call, this one can be further filtered by period.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.ces_listperiods_with_http_info(competition_id, organization_id, sport, external, fields, fixture_type, hide_null, home_away, include, limit, offset, period_id, section, win_loss, async_req=True)
@@ -1416,21 +1422,22 @@
         :type period_id: int
         :param section: The section of the period (sub-period)
         :type section: str
         :param win_loss: What the result was >- `DRAW` Draw >- `LOSS` Loss >- `WIN` Win
         :type win_loss: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1497,21 +1504,21 @@
         if _params.get("external") is not None:  # noqa: E501
             _query_params.append(("external", _params["external"]))
 
         if _params.get("fields") is not None:  # noqa: E501
             _query_params.append(("fields", _params["fields"]))
 
         if _params.get("fixture_type") is not None:  # noqa: E501
-            _query_params.append(("fixtureType", _params["fixture_type"]))
+            _query_params.append(("fixtureType", _params["fixture_type"].value))
 
         if _params.get("hide_null") is not None:  # noqa: E501
             _query_params.append(("hideNull", _params["hide_null"]))
 
         if _params.get("home_away") is not None:  # noqa: E501
-            _query_params.append(("homeAway", _params["home_away"]))
+            _query_params.append(("homeAway", _params["home_away"].value))
 
         if _params.get("include") is not None:  # noqa: E501
             _query_params.append(("include", _params["include"]))
 
         if _params.get("limit") is not None:  # noqa: E501
             _query_params.append(("limit", _params["limit"]))
 
@@ -1521,15 +1528,15 @@
         if _params.get("period_id") is not None:  # noqa: E501
             _query_params.append(("periodId", _params["period_id"]))
 
         if _params.get("section") is not None:  # noqa: E501
             _query_params.append(("section", _params["section"]))
 
         if _params.get("win_loss") is not None:  # noqa: E501
-            _query_params.append(("winLoss", _params["win_loss"]))
+            _query_params.append(("winLoss", _params["win_loss"].value))
 
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
@@ -1667,28 +1674,28 @@
         :type person_id: str
         :param starter: Is the person a starter in the fixture ?
         :type starter: bool
         :param win_loss: What the result was >- `DRAW` Draw >- `LOSS` Loss >- `WIN` Win
         :type win_loss: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: CompetitionPersonStatisticsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the cps_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.cps_list_with_http_info(
                 competition_id,
                 organization_id,
                 sport,
                 entity_id,
                 external,
@@ -1768,15 +1775,15 @@
         person_id: Annotated[Optional[StrictStr], Field(description="The unique identifier of the person")] = None,
         starter: Annotated[Optional[StrictBool], Field(description="Is the person a starter in the fixture ?")] = None,
         win_loss: Annotated[
             Optional[constr(strict=True, max_length=50)],
             Field(description="What the result was >- `DRAW` Draw >- `LOSS` Loss >- `WIN` Win "),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Person statistics for a competition  # noqa: E501
 
         Return a list of person statistic totals for a competition  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.cps_list_with_http_info(competition_id, organization_id, sport, entity_id, external, fields, fixture_type, hide_null, home_away, include, is_player, is_team_official, limit, offset, person_id, starter, win_loss, async_req=True)
@@ -1814,21 +1821,22 @@
         :type person_id: str
         :param starter: Is the person a starter in the fixture ?
         :type starter: bool
         :param win_loss: What the result was >- `DRAW` Draw >- `LOSS` Loss >- `WIN` Win
         :type win_loss: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1901,21 +1909,21 @@
         if _params.get("external") is not None:  # noqa: E501
             _query_params.append(("external", _params["external"]))
 
         if _params.get("fields") is not None:  # noqa: E501
             _query_params.append(("fields", _params["fields"]))
 
         if _params.get("fixture_type") is not None:  # noqa: E501
-            _query_params.append(("fixtureType", _params["fixture_type"]))
+            _query_params.append(("fixtureType", _params["fixture_type"].value))
 
         if _params.get("hide_null") is not None:  # noqa: E501
             _query_params.append(("hideNull", _params["hide_null"]))
 
         if _params.get("home_away") is not None:  # noqa: E501
-            _query_params.append(("homeAway", _params["home_away"]))
+            _query_params.append(("homeAway", _params["home_away"].value))
 
         if _params.get("include") is not None:  # noqa: E501
             _query_params.append(("include", _params["include"]))
 
         if _params.get("is_player") is not None:  # noqa: E501
             _query_params.append(("isPlayer", _params["is_player"]))
 
@@ -1931,15 +1939,15 @@
         if _params.get("person_id") is not None:  # noqa: E501
             _query_params.append(("personId", _params["person_id"]))
 
         if _params.get("starter") is not None:  # noqa: E501
             _query_params.append(("starter", _params["starter"]))
 
         if _params.get("win_loss") is not None:  # noqa: E501
-            _query_params.append(("winLoss", _params["win_loss"]))
+            _query_params.append(("winLoss", _params["win_loss"].value))
 
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/api/competitions_api.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/api/competitions_api.py`

 * *Files 6% similar despite different names*

```diff
@@ -8,23 +8,26 @@
     The version of the OpenAPI document: v1
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the file manually.
 """
 
 
+import io
 import logging
 import re  # noqa: F401
+import warnings
 from datetime import datetime
 from typing import Optional
 
 from pydantic import Field, StrictBool, StrictInt, StrictStr, ValidationError, conint, constr, validate_arguments
 from typing_extensions import Annotated
 
 from atriumsports.datacore.openapi.api_client import ApiClient
+from atriumsports.datacore.openapi.api_response import ApiResponse
 from atriumsports.datacore.openapi.exceptions import ApiTypeError, ApiValueError  # noqa: F401
 from atriumsports.datacore.openapi.models.competition_post_body import CompetitionPostBody
 from atriumsports.datacore.openapi.models.competition_put_body import CompetitionPutBody
 from atriumsports.datacore.openapi.models.competitions_response import CompetitionsResponse
 from atriumsports.datacore.openapi.models.competitions_season_status_response import CompetitionsSeasonStatusResponse
 
 logger = logging.getLogger("openapi")
@@ -103,28 +106,28 @@
         :type force_delete: bool
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: CompetitionsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the competition_delete_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.competition_delete_with_http_info(
                 competition_id, organization_id, sport, external, fields, force_delete, hide_null, include, **kwargs
             )  # noqa: E501
         except Exception as e:
             logger.error("Exception when calling CompetitionsApi->competition_delete: %s\n" % e)
             raise
@@ -162,15 +165,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Delete a competition  # noqa: E501
 
         Delete a specific competition  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.competition_delete_with_http_info(competition_id, organization_id, sport, external, fields, force_delete, hide_null, include, async_req=True)
@@ -190,21 +193,22 @@
         :type force_delete: bool
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -382,28 +386,28 @@
         :type include: str
         :param limit: The maximum number of records to return. See [Pagination](#section/Introduction/Pagination) for more information.
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: CompetitionsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the competition_detail_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.competition_detail_with_http_info(
                 competition_id, organization_id, sport, external, fields, hide_null, include, limit, offset, **kwargs
             )  # noqa: E501
         except Exception as e:
             logger.error("Exception when calling CompetitionsApi->competition_detail: %s\n" % e)
             raise
@@ -447,15 +451,15 @@
         offset: Annotated[
             Optional[StrictInt],
             Field(
                 description="The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Get a competition  # noqa: E501
 
         Return detailed information about a competition  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.competition_detail_with_http_info(competition_id, organization_id, sport, external, fields, hide_null, include, limit, offset, async_req=True)
@@ -477,21 +481,22 @@
         :type include: str
         :param limit: The maximum number of records to return. See [Pagination](#section/Introduction/Pagination) for more information.
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -657,28 +662,28 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: CompetitionsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the competition_insert_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.competition_insert_with_http_info(
                 organization_id, sport, competition_post_body, external, fields, hide_null, include, **kwargs
             )  # noqa: E501
         except Exception as e:
             logger.error("Exception when calling CompetitionsApi->competition_insert: %s\n" % e)
             raise
@@ -710,15 +715,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Create a competition  # noqa: E501
 
         Insert a new competition  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.competition_insert_with_http_info(organization_id, sport, competition_post_body, external, fields, hide_null, include, async_req=True)
@@ -736,21 +741,22 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -819,15 +825,15 @@
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params["competition_post_body"]:
+        if _params["competition_post_body"] is not None:
             _body_params = _params["competition_post_body"]
 
         # set the HTTP header `Accept`
         _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501
 
         # set the HTTP header `Content-Type`
         _content_types_list = _params.get(
@@ -946,28 +952,28 @@
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: CompetitionsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the competition_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.competition_list_with_http_info(
                 organization_id,
                 sport,
                 added,
                 age_group,
                 external,
@@ -1033,15 +1039,15 @@
                 description="The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information."
             ),
         ] = None,
         updated: Annotated[
             Optional[datetime], Field(description="Record was modified after this date/time. In UTC.")
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Get a list of competitions  # noqa: E501
 
         Return a list of available competitions  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.competition_list_with_http_info(organization_id, sport, added, age_group, external, fields, hide_null, include, limit, offset, updated, async_req=True)
@@ -1067,21 +1073,22 @@
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1144,15 +1151,15 @@
                 _query_params.append(
                     ("added", _params["added"].strftime(self.api_client.configuration.datetime_format))
                 )
             else:
                 _query_params.append(("added", _params["added"]))
 
         if _params.get("age_group") is not None:  # noqa: E501
-            _query_params.append(("ageGroup", _params["age_group"]))
+            _query_params.append(("ageGroup", _params["age_group"].value))
 
         if _params.get("external") is not None:  # noqa: E501
             _query_params.append(("external", _params["external"]))
 
         if _params.get("fields") is not None:  # noqa: E501
             _query_params.append(("fields", _params["fields"]))
 
@@ -1299,28 +1306,28 @@
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: CompetitionsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the competition_list_by_league_id_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.competition_list_by_league_id_with_http_info(
                 league_id,
                 organization_id,
                 sport,
                 added,
                 age_group,
@@ -1388,15 +1395,15 @@
                 description="The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information."
             ),
         ] = None,
         updated: Annotated[
             Optional[datetime], Field(description="Record was modified after this date/time. In UTC.")
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Get a list of competitions by for a league  # noqa: E501
 
         Return a list of available competitions for a specific league  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.competition_list_by_league_id_with_http_info(league_id, organization_id, sport, added, age_group, external, fields, hide_null, include, limit, offset, updated, async_req=True)
@@ -1424,21 +1431,22 @@
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1507,15 +1515,15 @@
                 _query_params.append(
                     ("added", _params["added"].strftime(self.api_client.configuration.datetime_format))
                 )
             else:
                 _query_params.append(("added", _params["added"]))
 
         if _params.get("age_group") is not None:  # noqa: E501
-            _query_params.append(("ageGroup", _params["age_group"]))
+            _query_params.append(("ageGroup", _params["age_group"].value))
 
         if _params.get("external") is not None:  # noqa: E501
             _query_params.append(("external", _params["external"]))
 
         if _params.get("fields") is not None:  # noqa: E501
             _query_params.append(("fields", _params["fields"]))
 
@@ -1683,28 +1691,28 @@
         :type season_updated: datetime
         :param season_video_production: Seasons data synchronization strategy with video production systems. Multiple allowed (comma-delimited). >- `AUTOMATED` Automated >- `MANUAL` Manual >- `NONE` None
         :type season_video_production: str
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: CompetitionsSeasonStatusResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the competition_list_season_status_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.competition_list_season_status_with_http_info(
                 organization_id,
                 sport,
                 added,
                 age_group,
                 comp_season_updated,
@@ -1790,15 +1798,15 @@
                 description="Seasons data synchronization strategy with video production systems. Multiple allowed (comma-delimited). >- `AUTOMATED` Automated >- `MANUAL` Manual >- `NONE` None "
             ),
         ] = None,
         updated: Annotated[
             Optional[datetime], Field(description="Record was modified after this date/time. In UTC.")
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Get a list of competitions that have active seasons  # noqa: E501
 
         Return a list of available competitions that have active seasons  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.competition_list_season_status_with_http_info(organization_id, sport, added, age_group, comp_season_updated, external, fields, hide_null, include, limit, offset, season_status, season_updated, season_video_production, updated, async_req=True)
@@ -1832,21 +1840,22 @@
         :type season_updated: datetime
         :param season_video_production: Seasons data synchronization strategy with video production systems. Multiple allowed (comma-delimited). >- `AUTOMATED` Automated >- `MANUAL` Manual >- `NONE` None
         :type season_video_production: str
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1915,15 +1924,15 @@
                 _query_params.append(
                     ("added", _params["added"].strftime(self.api_client.configuration.datetime_format))
                 )
             else:
                 _query_params.append(("added", _params["added"]))
 
         if _params.get("age_group") is not None:  # noqa: E501
-            _query_params.append(("ageGroup", _params["age_group"]))
+            _query_params.append(("ageGroup", _params["age_group"].value))
 
         if _params.get("comp_season_updated") is not None:  # noqa: E501
             if isinstance(_params["comp_season_updated"], datetime):
                 _query_params.append(
                     (
                         "compSeasonUpdated",
                         _params["comp_season_updated"].strftime(self.api_client.configuration.datetime_format),
@@ -1947,26 +1956,26 @@
         if _params.get("limit") is not None:  # noqa: E501
             _query_params.append(("limit", _params["limit"]))
 
         if _params.get("offset") is not None:  # noqa: E501
             _query_params.append(("offset", _params["offset"]))
 
         if _params.get("season_status") is not None:  # noqa: E501
-            _query_params.append(("seasonStatus", _params["season_status"]))
+            _query_params.append(("seasonStatus", _params["season_status"].value))
 
         if _params.get("season_updated") is not None:  # noqa: E501
             if isinstance(_params["season_updated"], datetime):
                 _query_params.append(
                     ("seasonUpdated", _params["season_updated"].strftime(self.api_client.configuration.datetime_format))
                 )
             else:
                 _query_params.append(("seasonUpdated", _params["season_updated"]))
 
         if _params.get("season_video_production") is not None:  # noqa: E501
-            _query_params.append(("seasonVideoProduction", _params["season_video_production"]))
+            _query_params.append(("seasonVideoProduction", _params["season_video_production"].value))
 
         if _params.get("updated") is not None:  # noqa: E501
             if isinstance(_params["updated"], datetime):
                 _query_params.append(
                     ("updated", _params["updated"].strftime(self.api_client.configuration.datetime_format))
                 )
             else:
@@ -2064,28 +2073,28 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: CompetitionsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the competition_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.competition_update_with_http_info(
                 competition_id,
                 organization_id,
                 sport,
                 competition_put_body,
                 external,
@@ -2126,15 +2135,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Update a competition  # noqa: E501
 
         Change the information of a specific competition  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.competition_update_with_http_info(competition_id, organization_id, sport, competition_put_body, external, fields, hide_null, include, async_req=True)
@@ -2154,21 +2163,22 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -2241,15 +2251,15 @@
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params["competition_put_body"]:
+        if _params["competition_put_body"] is not None:
             _body_params = _params["competition_put_body"]
 
         # set the HTTP header `Accept`
         _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501
 
         # set the HTTP header `Content-Type`
         _content_types_list = _params.get(
@@ -2360,28 +2370,28 @@
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: CompetitionsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the orggroup_competition_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.orggroup_competition_list_with_http_info(
                 organization_group_code,
                 sport,
                 added,
                 external,
                 fields,
@@ -2440,15 +2450,15 @@
                 description="The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information."
             ),
         ] = None,
         updated: Annotated[
             Optional[datetime], Field(description="Record was modified after this date/time. In UTC.")
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Get a list of competitions for the organization group  # noqa: E501
 
         Return a list of competitions for the organization group  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.orggroup_competition_list_with_http_info(organization_group_code, sport, added, external, fields, hide_null, include, limit, offset, updated, async_req=True)
@@ -2472,21 +2482,22 @@
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/api/conduct_api.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/api/conduct_api.py`

 * *Files 2% similar despite different names*

```diff
@@ -8,23 +8,26 @@
     The version of the OpenAPI document: v1
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the file manually.
 """
 
 
+import io
 import logging
 import re  # noqa: F401
+import warnings
 from datetime import datetime
 from typing import Optional
 
 from pydantic import Field, StrictBool, StrictInt, StrictStr, ValidationError, conint, constr, validate_arguments
 from typing_extensions import Annotated
 
 from atriumsports.datacore.openapi.api_client import ApiClient
+from atriumsports.datacore.openapi.api_response import ApiResponse
 from atriumsports.datacore.openapi.exceptions import ApiTypeError, ApiValueError  # noqa: F401
 from atriumsports.datacore.openapi.models.conduct_post_body import ConductPostBody
 from atriumsports.datacore.openapi.models.conduct_put_body import ConductPutBody
 from atriumsports.datacore.openapi.models.conduct_response import ConductResponse
 
 logger = logging.getLogger("openapi")
 
@@ -102,28 +105,28 @@
         :type force_delete: bool
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: ConductResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the conduct_delete_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.conduct_delete_with_http_info(
                 conduct_id, organization_id, sport, external, fields, force_delete, hide_null, include, **kwargs
             )  # noqa: E501
         except Exception as e:
             logger.error("Exception when calling ConductApi->conduct_delete: %s\n" % e)
             raise
@@ -161,15 +164,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Delete a conduct  # noqa: E501
 
         Delete a specific conduct  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.conduct_delete_with_http_info(conduct_id, organization_id, sport, external, fields, force_delete, hide_null, include, async_req=True)
@@ -189,21 +192,22 @@
         :type force_delete: bool
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -381,28 +385,28 @@
         :type include: str
         :param limit: The maximum number of records to return. See [Pagination](#section/Introduction/Pagination) for more information.
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: ConductResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the conduct_detail_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.conduct_detail_with_http_info(
                 conduct_id, organization_id, sport, external, fields, hide_null, include, limit, offset, **kwargs
             )  # noqa: E501
         except Exception as e:
             logger.error("Exception when calling ConductApi->conduct_detail: %s\n" % e)
             raise
@@ -446,15 +450,15 @@
         offset: Annotated[
             Optional[StrictInt],
             Field(
                 description="The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Get a conduct  # noqa: E501
 
         Return detailed information about a specific conduct  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.conduct_detail_with_http_info(conduct_id, organization_id, sport, external, fields, hide_null, include, limit, offset, async_req=True)
@@ -476,21 +480,22 @@
         :type include: str
         :param limit: The maximum number of records to return. See [Pagination](#section/Introduction/Pagination) for more information.
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -656,28 +661,28 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: ConductResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the conduct_insert_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.conduct_insert_with_http_info(
                 organization_id, sport, conduct_post_body, external, fields, hide_null, include, **kwargs
             )  # noqa: E501
         except Exception as e:
             logger.error("Exception when calling ConductApi->conduct_insert: %s\n" % e)
             raise
@@ -709,15 +714,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Create a conduct  # noqa: E501
 
         Insert a new conduct  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.conduct_insert_with_http_info(organization_id, sport, conduct_post_body, external, fields, hide_null, include, async_req=True)
@@ -735,21 +740,22 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -810,15 +816,15 @@
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params["conduct_post_body"]:
+        if _params["conduct_post_body"] is not None:
             _body_params = _params["conduct_post_body"]
 
         # set the HTTP header `Accept`
         _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501
 
         # set the HTTP header `Content-Type`
         _content_types_list = _params.get(
@@ -977,28 +983,28 @@
         :type person_id: str
         :param season_id: The unique identifier of the season
         :type season_id: str
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: ConductResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the conduct_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.conduct_list_with_http_info(
                 organization_id,
                 sport,
                 added,
                 competition_id,
                 conduct_status,
@@ -1095,15 +1101,15 @@
         ] = None,
         person_id: Annotated[Optional[StrictStr], Field(description="The unique identifier of the person")] = None,
         season_id: Annotated[Optional[StrictStr], Field(description="The unique identifier of the season")] = None,
         updated: Annotated[
             Optional[datetime], Field(description="Record was modified after this date/time. In UTC.")
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Get a list of conduct  # noqa: E501
 
         Return a list of available conduct records  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.conduct_list_with_http_info(organization_id, sport, added, competition_id, conduct_status, conduct_type, date_offence_local_end, date_offence_local_start, entity_group_id, entity_id, external, fields, fixture_id, hide_null, include, limit, offset, person_id, season_id, updated, async_req=True)
@@ -1147,21 +1153,22 @@
         :type person_id: str
         :param season_id: The unique identifier of the season
         :type season_id: str
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1236,18 +1243,18 @@
             else:
                 _query_params.append(("added", _params["added"]))
 
         if _params.get("competition_id") is not None:  # noqa: E501
             _query_params.append(("competitionId", _params["competition_id"]))
 
         if _params.get("conduct_status") is not None:  # noqa: E501
-            _query_params.append(("conductStatus", _params["conduct_status"]))
+            _query_params.append(("conductStatus", _params["conduct_status"].value))
 
         if _params.get("conduct_type") is not None:  # noqa: E501
-            _query_params.append(("conductType", _params["conduct_type"]))
+            _query_params.append(("conductType", _params["conduct_type"].value))
 
         if _params.get("date_offence_local_end") is not None:  # noqa: E501
             if isinstance(_params["date_offence_local_end"], datetime):
                 _query_params.append(
                     (
                         "dateOffenceLocalEnd",
                         _params["date_offence_local_end"].strftime(self.api_client.configuration.datetime_format),
@@ -1400,28 +1407,28 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: ConductResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the conduct_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.conduct_update_with_http_info(
                 conduct_id, organization_id, sport, conduct_put_body, external, fields, hide_null, include, **kwargs
             )  # noqa: E501
         except Exception as e:
             logger.error("Exception when calling ConductApi->conduct_update: %s\n" % e)
             raise
@@ -1454,15 +1461,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Update a conduct  # noqa: E501
 
         Change the information of a specific conduct  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.conduct_update_with_http_info(conduct_id, organization_id, sport, conduct_put_body, external, fields, hide_null, include, async_req=True)
@@ -1482,21 +1489,22 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1569,15 +1577,15 @@
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params["conduct_put_body"]:
+        if _params["conduct_put_body"] is not None:
             _body_params = _params["conduct_put_body"]
 
         # set the HTTP header `Accept`
         _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501
 
         # set the HTTP header `Content-Type`
         _content_types_list = _params.get(
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/api/conferences_divisions_api.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/api/conferences_divisions_api.py`

 * *Files 2% similar despite different names*

```diff
@@ -8,23 +8,26 @@
     The version of the OpenAPI document: v1
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the file manually.
 """
 
 
+import io
 import logging
 import re  # noqa: F401
+import warnings
 from datetime import datetime
 from typing import Optional
 
 from pydantic import Field, StrictBool, StrictInt, StrictStr, ValidationError, conint, constr, validate_arguments
 from typing_extensions import Annotated
 
 from atriumsports.datacore.openapi.api_client import ApiClient
+from atriumsports.datacore.openapi.api_response import ApiResponse
 from atriumsports.datacore.openapi.exceptions import ApiTypeError, ApiValueError  # noqa: F401
 from atriumsports.datacore.openapi.models.conference_post_body import ConferencePostBody
 from atriumsports.datacore.openapi.models.conference_put_body import ConferencePutBody
 from atriumsports.datacore.openapi.models.conferences_response import ConferencesResponse
 from atriumsports.datacore.openapi.models.division_post_body import DivisionPostBody
 from atriumsports.datacore.openapi.models.division_put_body import DivisionPutBody
 from atriumsports.datacore.openapi.models.divisions_response import DivisionsResponse
@@ -105,28 +108,28 @@
         :type force_delete: bool
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: ConferencesResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the conference_delete_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.conference_delete_with_http_info(
                 conference_id, organization_id, sport, external, fields, force_delete, hide_null, include, **kwargs
             )  # noqa: E501
         except Exception as e:
             logger.error("Exception when calling ConferencesDivisionsApi->conference_delete: %s\n" % e)
             raise
@@ -164,15 +167,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Delete a conference  # noqa: E501
 
         Delete a specific conference  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.conference_delete_with_http_info(conference_id, organization_id, sport, external, fields, force_delete, hide_null, include, async_req=True)
@@ -192,21 +195,22 @@
         :type force_delete: bool
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -384,28 +388,28 @@
         :type include: str
         :param limit: The maximum number of records to return. See [Pagination](#section/Introduction/Pagination) for more information.
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: ConferencesResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the conference_detail_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.conference_detail_with_http_info(
                 conference_id, organization_id, sport, external, fields, hide_null, include, limit, offset, **kwargs
             )  # noqa: E501
         except Exception as e:
             logger.error("Exception when calling ConferencesDivisionsApi->conference_detail: %s\n" % e)
             raise
@@ -449,15 +453,15 @@
         offset: Annotated[
             Optional[StrictInt],
             Field(
                 description="The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Get a conference  # noqa: E501
 
         Return detailed information about a specific conference  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.conference_detail_with_http_info(conference_id, organization_id, sport, external, fields, hide_null, include, limit, offset, async_req=True)
@@ -479,21 +483,22 @@
         :type include: str
         :param limit: The maximum number of records to return. See [Pagination](#section/Introduction/Pagination) for more information.
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -659,28 +664,28 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: ConferencesResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the conference_insert_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.conference_insert_with_http_info(
                 organization_id, sport, conference_post_body, external, fields, hide_null, include, **kwargs
             )  # noqa: E501
         except Exception as e:
             logger.error("Exception when calling ConferencesDivisionsApi->conference_insert: %s\n" % e)
             raise
@@ -712,15 +717,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Create a conference  # noqa: E501
 
         Create a new conference  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.conference_insert_with_http_info(organization_id, sport, conference_post_body, external, fields, hide_null, include, async_req=True)
@@ -738,21 +743,22 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -813,15 +819,15 @@
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params["conference_post_body"]:
+        if _params["conference_post_body"] is not None:
             _body_params = _params["conference_post_body"]
 
         # set the HTTP header `Accept`
         _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501
 
         # set the HTTP header `Content-Type`
         _content_types_list = _params.get(
@@ -932,28 +938,28 @@
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: ConferencesResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the conference_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.conference_list_with_http_info(
                 organization_id, sport, added, external, fields, hide_null, include, limit, offset, updated, **kwargs
             )  # noqa: E501
         except Exception as e:
             logger.error("Exception when calling ConferencesDivisionsApi->conference_list: %s\n" % e)
             raise
@@ -1002,15 +1008,15 @@
                 description="The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information."
             ),
         ] = None,
         updated: Annotated[
             Optional[datetime], Field(description="Record was modified after this date/time. In UTC.")
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Get a list of conferences  # noqa: E501
 
         Return a list of available conferences  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.conference_list_with_http_info(organization_id, sport, added, external, fields, hide_null, include, limit, offset, updated, async_req=True)
@@ -1034,21 +1040,22 @@
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1231,28 +1238,28 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: ConferencesResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the conference_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.conference_update_with_http_info(
                 conference_id,
                 organization_id,
                 sport,
                 conference_put_body,
                 external,
@@ -1293,15 +1300,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Update a conference  # noqa: E501
 
         Change the information of a specific conference  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.conference_update_with_http_info(conference_id, organization_id, sport, conference_put_body, external, fields, hide_null, include, async_req=True)
@@ -1321,21 +1328,22 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1408,15 +1416,15 @@
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params["conference_put_body"]:
+        if _params["conference_put_body"] is not None:
             _body_params = _params["conference_put_body"]
 
         # set the HTTP header `Accept`
         _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501
 
         # set the HTTP header `Content-Type`
         _content_types_list = _params.get(
@@ -1512,28 +1520,28 @@
         :type force_delete: bool
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: DivisionsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the division_delete_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.division_delete_with_http_info(
                 division_id, organization_id, sport, external, fields, force_delete, hide_null, include, **kwargs
             )  # noqa: E501
         except Exception as e:
             logger.error("Exception when calling ConferencesDivisionsApi->division_delete: %s\n" % e)
             raise
@@ -1571,15 +1579,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Delete a division  # noqa: E501
 
         Delete a specific division  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.division_delete_with_http_info(division_id, organization_id, sport, external, fields, force_delete, hide_null, include, async_req=True)
@@ -1599,21 +1607,22 @@
         :type force_delete: bool
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1791,28 +1800,28 @@
         :type include: str
         :param limit: The maximum number of records to return. See [Pagination](#section/Introduction/Pagination) for more information.
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: DivisionsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the division_detail_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.division_detail_with_http_info(
                 division_id, organization_id, sport, external, fields, hide_null, include, limit, offset, **kwargs
             )  # noqa: E501
         except Exception as e:
             logger.error("Exception when calling ConferencesDivisionsApi->division_detail: %s\n" % e)
             raise
@@ -1856,15 +1865,15 @@
         offset: Annotated[
             Optional[StrictInt],
             Field(
                 description="The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Get a division  # noqa: E501
 
         Return detailed information about a specific division  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.division_detail_with_http_info(division_id, organization_id, sport, external, fields, hide_null, include, limit, offset, async_req=True)
@@ -1886,21 +1895,22 @@
         :type include: str
         :param limit: The maximum number of records to return. See [Pagination](#section/Introduction/Pagination) for more information.
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -2069,28 +2079,28 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: DivisionsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the division_insert_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.division_insert_with_http_info(
                 conference_id,
                 organization_id,
                 sport,
                 division_post_body,
                 external,
@@ -2131,15 +2141,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Create a division  # noqa: E501
 
         Insert a new division  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.division_insert_with_http_info(conference_id, organization_id, sport, division_post_body, external, fields, hide_null, include, async_req=True)
@@ -2159,21 +2169,22 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -2246,15 +2257,15 @@
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params["division_post_body"]:
+        if _params["division_post_body"] is not None:
             _body_params = _params["division_post_body"]
 
         # set the HTTP header `Accept`
         _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501
 
         # set the HTTP header `Content-Type`
         _content_types_list = _params.get(
@@ -2368,28 +2379,28 @@
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: DivisionsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the division_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.division_list_with_http_info(
                 conference_id,
                 organization_id,
                 sport,
                 added,
                 external,
@@ -2450,15 +2461,15 @@
                 description="The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information."
             ),
         ] = None,
         updated: Annotated[
             Optional[datetime], Field(description="Record was modified after this date/time. In UTC.")
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Get a list of divisions  # noqa: E501
 
         Return a list of available divisions for a specific conference  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.division_list_with_http_info(conference_id, organization_id, sport, added, external, fields, hide_null, include, limit, offset, updated, async_req=True)
@@ -2484,21 +2495,22 @@
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -2685,28 +2697,28 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: DivisionsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the division_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.division_update_with_http_info(
                 division_id, organization_id, sport, division_put_body, external, fields, hide_null, include, **kwargs
             )  # noqa: E501
         except Exception as e:
             logger.error("Exception when calling ConferencesDivisionsApi->division_update: %s\n" % e)
             raise
@@ -2739,15 +2751,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Update a division  # noqa: E501
 
         Change the information of a specific division  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.division_update_with_http_info(division_id, organization_id, sport, division_put_body, external, fields, hide_null, include, async_req=True)
@@ -2767,21 +2779,22 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -2854,15 +2867,15 @@
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params["division_put_body"]:
+        if _params["division_put_body"] is not None:
             _body_params = _params["division_put_body"]
 
         # set the HTTP header `Accept`
         _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501
 
         # set the HTTP header `Content-Type`
         _content_types_list = _params.get(
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/api/download_video_api.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/api/download_video_api.py`

 * *Files 8% similar despite different names*

```diff
@@ -8,23 +8,26 @@
     The version of the OpenAPI document: v1
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the file manually.
 """
 
 
+import io
 import logging
 import re  # noqa: F401
+import warnings
 from datetime import datetime
 from typing import Optional
 
 from pydantic import Field, StrictBool, StrictInt, StrictStr, ValidationError, conint, constr, validate_arguments
 from typing_extensions import Annotated
 
 from atriumsports.datacore.openapi.api_client import ApiClient
+from atriumsports.datacore.openapi.api_response import ApiResponse
 from atriumsports.datacore.openapi.exceptions import ApiTypeError, ApiValueError  # noqa: F401
 from atriumsports.datacore.openapi.models.video_file_post_body import VideoFilePostBody
 from atriumsports.datacore.openapi.models.video_files_download_response import VideoFilesDownloadResponse
 from atriumsports.datacore.openapi.models.video_files_response import VideoFilesResponse
 
 logger = logging.getLogger("openapi")
 
@@ -102,28 +105,28 @@
         :type force_delete: bool
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: VideoFilesDownloadResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the video_file_delete_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.video_file_delete_with_http_info(
                 organization_id, sport, video_id, external, fields, force_delete, hide_null, include, **kwargs
             )  # noqa: E501
         except Exception as e:
             logger.error("Exception when calling DownloadVideoApi->video_file_delete: %s\n" % e)
             raise
@@ -161,15 +164,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Delete a video file  # noqa: E501
 
         Delete a video file  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.video_file_delete_with_http_info(organization_id, sport, video_id, external, fields, force_delete, hide_null, include, async_req=True)
@@ -189,21 +192,22 @@
         :type force_delete: bool
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -381,28 +385,28 @@
         :type include: str
         :param limit: The maximum number of records to return. See [Pagination](#section/Introduction/Pagination) for more information.
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: VideoFilesDownloadResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the video_file_detail_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.video_file_detail_with_http_info(
                 organization_id, sport, video_id, external, fields, hide_null, include, limit, offset, **kwargs
             )  # noqa: E501
         except Exception as e:
             logger.error("Exception when calling DownloadVideoApi->video_file_detail: %s\n" % e)
             raise
@@ -446,15 +450,15 @@
         offset: Annotated[
             Optional[StrictInt],
             Field(
                 description="The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Download URL  # noqa: E501
 
         Generate a url to download a video file for a fixture. This link is only valid for 30 minutes.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.video_file_detail_with_http_info(organization_id, sport, video_id, external, fields, hide_null, include, limit, offset, async_req=True)
@@ -476,21 +480,22 @@
         :type include: str
         :param limit: The maximum number of records to return. See [Pagination](#section/Introduction/Pagination) for more information.
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -659,28 +664,28 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: VideoFilesResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the video_file_insert_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.video_file_insert_with_http_info(
                 fixture_id, organization_id, sport, video_file_post_body, external, fields, hide_null, include, **kwargs
             )  # noqa: E501
         except Exception as e:
             logger.error("Exception when calling DownloadVideoApi->video_file_insert: %s\n" % e)
             raise
@@ -713,15 +718,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Add a new video file  # noqa: E501
 
         Add a new video file  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.video_file_insert_with_http_info(fixture_id, organization_id, sport, video_file_post_body, external, fields, hide_null, include, async_req=True)
@@ -741,21 +746,22 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -828,15 +834,15 @@
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params["video_file_post_body"]:
+        if _params["video_file_post_body"] is not None:
             _body_params = _params["video_file_post_body"]
 
         # set the HTTP header `Accept`
         _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501
 
         # set the HTTP header `Content-Type`
         _content_types_list = _params.get(
@@ -1011,28 +1017,28 @@
         :type status: str
         :param storage_provider: Where the video file is stored? >- `5STREAM` 5stream >- `KEEMOTION` Keemotion >- `SYNERGY` Synergy
         :type storage_provider: str
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: VideoFilesResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the video_file_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.video_file_list_with_http_info(
                 fixture_id,
                 organization_id,
                 sport,
                 added,
                 content,
@@ -1145,15 +1151,15 @@
                 description="Where the video file is stored? >- `5STREAM` 5stream >- `KEEMOTION` Keemotion >- `SYNERGY` Synergy "
             ),
         ] = None,
         updated: Annotated[
             Optional[datetime], Field(description="Record was modified after this date/time. In UTC.")
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """List available video files for a fixture  # noqa: E501
 
         List the video files for a fixture that are available for downloaded.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.video_file_list_with_http_info(fixture_id, organization_id, sport, added, content, external, feed_type, fields, format, hide_null, include, limit, locale, offset, origin, provider, source_number, status, storage_provider, updated, async_req=True)
@@ -1197,21 +1203,22 @@
         :type status: str
         :param storage_provider: Where the video file is stored? >- `5STREAM` 5stream >- `KEEMOTION` Keemotion >- `SYNERGY` Synergy
         :type storage_provider: str
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1286,27 +1293,27 @@
                 _query_params.append(
                     ("added", _params["added"].strftime(self.api_client.configuration.datetime_format))
                 )
             else:
                 _query_params.append(("added", _params["added"]))
 
         if _params.get("content") is not None:  # noqa: E501
-            _query_params.append(("content", _params["content"]))
+            _query_params.append(("content", _params["content"].value))
 
         if _params.get("external") is not None:  # noqa: E501
             _query_params.append(("external", _params["external"]))
 
         if _params.get("feed_type") is not None:  # noqa: E501
-            _query_params.append(("feedType", _params["feed_type"]))
+            _query_params.append(("feedType", _params["feed_type"].value))
 
         if _params.get("fields") is not None:  # noqa: E501
             _query_params.append(("fields", _params["fields"]))
 
         if _params.get("format") is not None:  # noqa: E501
-            _query_params.append(("format", _params["format"]))
+            _query_params.append(("format", _params["format"].value))
 
         if _params.get("hide_null") is not None:  # noqa: E501
             _query_params.append(("hideNull", _params["hide_null"]))
 
         if _params.get("include") is not None:  # noqa: E501
             _query_params.append(("include", _params["include"]))
 
@@ -1316,27 +1323,27 @@
         if _params.get("locale") is not None:  # noqa: E501
             _query_params.append(("locale", _params["locale"]))
 
         if _params.get("offset") is not None:  # noqa: E501
             _query_params.append(("offset", _params["offset"]))
 
         if _params.get("origin") is not None:  # noqa: E501
-            _query_params.append(("origin", _params["origin"]))
+            _query_params.append(("origin", _params["origin"].value))
 
         if _params.get("provider") is not None:  # noqa: E501
             _query_params.append(("provider", _params["provider"]))
 
         if _params.get("source_number") is not None:  # noqa: E501
             _query_params.append(("sourceNumber", _params["source_number"]))
 
         if _params.get("status") is not None:  # noqa: E501
-            _query_params.append(("status", _params["status"]))
+            _query_params.append(("status", _params["status"].value))
 
         if _params.get("storage_provider") is not None:  # noqa: E501
-            _query_params.append(("storageProvider", _params["storage_provider"]))
+            _query_params.append(("storageProvider", _params["storage_provider"].value))
 
         if _params.get("updated") is not None:  # noqa: E501
             if isinstance(_params["updated"], datetime):
                 _query_params.append(
                     ("updated", _params["updated"].strftime(self.api_client.configuration.datetime_format))
                 )
             else:
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/api/entities_api.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/api/entities_api.py`

 * *Files 3% similar despite different names*

```diff
@@ -8,23 +8,26 @@
     The version of the OpenAPI document: v1
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the file manually.
 """
 
 
+import io
 import logging
 import re  # noqa: F401
+import warnings
 from datetime import datetime
 from typing import Optional
 
 from pydantic import Field, StrictBool, StrictInt, StrictStr, ValidationError, conint, constr, validate_arguments
 from typing_extensions import Annotated
 
 from atriumsports.datacore.openapi.api_client import ApiClient
+from atriumsports.datacore.openapi.api_response import ApiResponse
 from atriumsports.datacore.openapi.exceptions import ApiTypeError, ApiValueError  # noqa: F401
 from atriumsports.datacore.openapi.models.entities_response import EntitiesResponse
 from atriumsports.datacore.openapi.models.entity_post_body import EntityPostBody
 from atriumsports.datacore.openapi.models.entity_put_body import EntityPutBody
 
 logger = logging.getLogger("openapi")
 
@@ -102,28 +105,28 @@
         :type force_delete: bool
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: EntitiesResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the entity_delete_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.entity_delete_with_http_info(
                 entity_id, organization_id, sport, external, fields, force_delete, hide_null, include, **kwargs
             )  # noqa: E501
         except Exception as e:
             logger.error("Exception when calling EntitiesApi->entity_delete: %s\n" % e)
             raise
@@ -161,15 +164,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Delete an entity  # noqa: E501
 
         Delete a specific entity  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.entity_delete_with_http_info(entity_id, organization_id, sport, external, fields, force_delete, hide_null, include, async_req=True)
@@ -189,21 +192,22 @@
         :type force_delete: bool
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -381,28 +385,28 @@
         :type include: str
         :param limit: The maximum number of records to return. See [Pagination](#section/Introduction/Pagination) for more information.
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: EntitiesResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the entity_detail_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.entity_detail_with_http_info(
                 entity_id, organization_id, sport, external, fields, hide_null, include, limit, offset, **kwargs
             )  # noqa: E501
         except Exception as e:
             logger.error("Exception when calling EntitiesApi->entity_detail: %s\n" % e)
             raise
@@ -446,15 +450,15 @@
         offset: Annotated[
             Optional[StrictInt],
             Field(
                 description="The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Get an entity  # noqa: E501
 
         Return detailed information about a specific entity  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.entity_detail_with_http_info(entity_id, organization_id, sport, external, fields, hide_null, include, limit, offset, async_req=True)
@@ -476,21 +480,22 @@
         :type include: str
         :param limit: The maximum number of records to return. See [Pagination](#section/Introduction/Pagination) for more information.
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -656,28 +661,28 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: EntitiesResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the entity_insert_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.entity_insert_with_http_info(
                 organization_id, sport, entity_post_body, external, fields, hide_null, include, **kwargs
             )  # noqa: E501
         except Exception as e:
             logger.error("Exception when calling EntitiesApi->entity_insert: %s\n" % e)
             raise
@@ -709,15 +714,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Create an entity  # noqa: E501
 
         Add a new entity  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.entity_insert_with_http_info(organization_id, sport, entity_post_body, external, fields, hide_null, include, async_req=True)
@@ -735,21 +740,22 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -810,15 +816,15 @@
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params["entity_post_body"]:
+        if _params["entity_post_body"] is not None:
             _body_params = _params["entity_post_body"]
 
         # set the HTTP header `Accept`
         _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501
 
         # set the HTTP header `Content-Type`
         _content_types_list = _params.get(
@@ -959,28 +965,28 @@
         :type sort_by: str
         :param status: Status >- `ACTIVE` Active >- `INACTIVE` Inactive >- `PENDING` Pending
         :type status: str
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: EntitiesResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the entity_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.entity_list_with_http_info(
                 organization_id,
                 sport,
                 added,
                 external,
                 fields,
@@ -1065,15 +1071,15 @@
             Optional[StrictStr],
             Field(description="Status >- `ACTIVE` Active >- `INACTIVE` Inactive >- `PENDING` Pending "),
         ] = None,
         updated: Annotated[
             Optional[datetime], Field(description="Record was modified after this date/time. In UTC.")
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Get a list of entities  # noqa: E501
 
         Return a list of available entities  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.entity_list_with_http_info(organization_id, sport, added, external, fields, hide_null, include, limit, name_full_latin_contains, name_full_local_contains, offset, sort_by, status, updated, async_req=True)
@@ -1105,21 +1111,22 @@
         :type sort_by: str
         :param status: Status >- `ACTIVE` Active >- `INACTIVE` Inactive >- `PENDING` Pending
         :type status: str
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1212,15 +1219,15 @@
         if _params.get("offset") is not None:  # noqa: E501
             _query_params.append(("offset", _params["offset"]))
 
         if _params.get("sort_by") is not None:  # noqa: E501
             _query_params.append(("sortBy", _params["sort_by"]))
 
         if _params.get("status") is not None:  # noqa: E501
-            _query_params.append(("status", _params["status"]))
+            _query_params.append(("status", _params["status"].value))
 
         if _params.get("updated") is not None:  # noqa: E501
             if isinstance(_params["updated"], datetime):
                 _query_params.append(
                     ("updated", _params["updated"].strftime(self.api_client.configuration.datetime_format))
                 )
             else:
@@ -1347,28 +1354,28 @@
         :type offset: int
         :param status: Status >- `ACTIVE` Active >- `INACTIVE` Inactive >- `PENDING` Pending
         :type status: str
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: EntitiesResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the entity_list_by_entity_group_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.entity_list_by_entity_group_with_http_info(
                 entity_group_id,
                 organization_id,
                 sport,
                 added,
                 external,
@@ -1434,15 +1441,15 @@
             Optional[StrictStr],
             Field(description="Status >- `ACTIVE` Active >- `INACTIVE` Inactive >- `PENDING` Pending "),
         ] = None,
         updated: Annotated[
             Optional[datetime], Field(description="Record was modified after this date/time. In UTC.")
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Get a list of entities for an entity group  # noqa: E501
 
         Return a list of available entities linked to a specific entity group  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.entity_list_by_entity_group_with_http_info(entity_group_id, organization_id, sport, added, external, fields, hide_null, include, limit, offset, status, updated, async_req=True)
@@ -1470,21 +1477,22 @@
         :type offset: int
         :param status: Status >- `ACTIVE` Active >- `INACTIVE` Inactive >- `PENDING` Pending
         :type status: str
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1571,15 +1579,15 @@
         if _params.get("limit") is not None:  # noqa: E501
             _query_params.append(("limit", _params["limit"]))
 
         if _params.get("offset") is not None:  # noqa: E501
             _query_params.append(("offset", _params["offset"]))
 
         if _params.get("status") is not None:  # noqa: E501
-            _query_params.append(("status", _params["status"]))
+            _query_params.append(("status", _params["status"].value))
 
         if _params.get("updated") is not None:  # noqa: E501
             if isinstance(_params["updated"], datetime):
                 _query_params.append(
                     ("updated", _params["updated"].strftime(self.api_client.configuration.datetime_format))
                 )
             else:
@@ -1677,28 +1685,28 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: EntitiesResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the entity_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.entity_update_with_http_info(
                 entity_id, organization_id, sport, entity_put_body, external, fields, hide_null, include, **kwargs
             )  # noqa: E501
         except Exception as e:
             logger.error("Exception when calling EntitiesApi->entity_update: %s\n" % e)
             raise
@@ -1731,15 +1739,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Update an entity  # noqa: E501
 
         Change the information of a specific entity  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.entity_update_with_http_info(entity_id, organization_id, sport, entity_put_body, external, fields, hide_null, include, async_req=True)
@@ -1759,21 +1767,22 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1846,15 +1855,15 @@
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params["entity_put_body"]:
+        if _params["entity_put_body"] is not None:
             _body_params = _params["entity_put_body"]
 
         # set the HTTP header `Accept`
         _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501
 
         # set the HTTP header `Content-Type`
         _content_types_list = _params.get(
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/api/entity_fixture_history_api.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/api/entity_fixture_history_api.py`

 * *Files 2% similar despite different names*

```diff
@@ -8,23 +8,26 @@
     The version of the OpenAPI document: v1
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the file manually.
 """
 
 
+import io
 import logging
 import re  # noqa: F401
+import warnings
 from datetime import datetime
 from typing import Optional
 
 from pydantic import Field, StrictBool, StrictInt, StrictStr, ValidationError, conint, constr, validate_arguments
 from typing_extensions import Annotated
 
 from atriumsports.datacore.openapi.api_client import ApiClient
+from atriumsports.datacore.openapi.api_response import ApiResponse
 from atriumsports.datacore.openapi.exceptions import ApiTypeError, ApiValueError  # noqa: F401
 from atriumsports.datacore.openapi.models.game_log_entity_response import GameLogEntityResponse
 
 logger = logging.getLogger("openapi")
 
 
 class EntityFixtureHistoryApi(object):
@@ -141,28 +144,28 @@
         :type offset: int
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param win_loss: What the result was >- `DRAW` Draw >- `LOSS` Loss >- `WIN` Win
         :type win_loss: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: GameLogEntityResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the gamelog_listentity_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.gamelog_listentity_with_http_info(
                 entity_id,
                 organization_id,
                 season_id,
                 sport,
                 added,
@@ -242,15 +245,15 @@
             Optional[datetime], Field(description="Record was modified after this date/time. In UTC.")
         ] = None,
         win_loss: Annotated[
             Optional[constr(strict=True, max_length=50)],
             Field(description="What the result was >- `DRAW` Draw >- `LOSS` Loss >- `WIN` Win "),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Fixture History for an entity  # noqa: E501
 
         Return the Fixture History (based on statistics present) for a specific entity in a season.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.gamelog_listentity_with_http_info(entity_id, organization_id, season_id, sport, added, external, fields, fixture_type, hide_null, home_away, include, limit, offset, updated, win_loss, async_req=True)
@@ -284,21 +287,22 @@
         :type offset: int
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param win_loss: What the result was >- `DRAW` Draw >- `LOSS` Loss >- `WIN` Win
         :type win_loss: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -377,21 +381,21 @@
         if _params.get("external") is not None:  # noqa: E501
             _query_params.append(("external", _params["external"]))
 
         if _params.get("fields") is not None:  # noqa: E501
             _query_params.append(("fields", _params["fields"]))
 
         if _params.get("fixture_type") is not None:  # noqa: E501
-            _query_params.append(("fixtureType", _params["fixture_type"]))
+            _query_params.append(("fixtureType", _params["fixture_type"].value))
 
         if _params.get("hide_null") is not None:  # noqa: E501
             _query_params.append(("hideNull", _params["hide_null"]))
 
         if _params.get("home_away") is not None:  # noqa: E501
-            _query_params.append(("homeAway", _params["home_away"]))
+            _query_params.append(("homeAway", _params["home_away"].value))
 
         if _params.get("include") is not None:  # noqa: E501
             _query_params.append(("include", _params["include"]))
 
         if _params.get("limit") is not None:  # noqa: E501
             _query_params.append(("limit", _params["limit"]))
 
@@ -403,15 +407,15 @@
                 _query_params.append(
                     ("updated", _params["updated"].strftime(self.api_client.configuration.datetime_format))
                 )
             else:
                 _query_params.append(("updated", _params["updated"]))
 
         if _params.get("win_loss") is not None:  # noqa: E501
-            _query_params.append(("winLoss", _params["win_loss"]))
+            _query_params.append(("winLoss", _params["win_loss"].value))
 
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/api/entity_fixture_statistics_api.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/api/entity_fixture_statistics_api.py`

 * *Files 2% similar despite different names*

```diff
@@ -8,23 +8,26 @@
     The version of the OpenAPI document: v1
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the file manually.
 """
 
 
+import io
 import logging
 import re  # noqa: F401
+import warnings
 from datetime import datetime
 from typing import Optional
 
 from pydantic import Field, StrictBool, StrictInt, StrictStr, ValidationError, conint, constr, validate_arguments
 from typing_extensions import Annotated
 
 from atriumsports.datacore.openapi.api_client import ApiClient
+from atriumsports.datacore.openapi.api_response import ApiResponse
 from atriumsports.datacore.openapi.exceptions import ApiTypeError, ApiValueError  # noqa: F401
 from atriumsports.datacore.openapi.models.fixture_entity_period_statistics_post_body import (
     FixtureEntityPeriodStatisticsPostBody,
 )
 from atriumsports.datacore.openapi.models.fixture_entity_statistics_periods_response import (
     FixtureEntityStatisticsPeriodsResponse,
 )
@@ -110,28 +113,28 @@
         :type force_delete: bool
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: FixtureEntityStatisticsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the fes_delete_all_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.fes_delete_all_with_http_info(
                 fixture_id,
                 organization_id,
                 sport,
                 entity_id,
                 external,
@@ -179,15 +182,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Delete entity total statistics  # noqa: E501
 
         Delete the total fixture statistics for for a given entity in the ~fixture.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.fes_delete_all_with_http_info(fixture_id, organization_id, sport, entity_id, external, fields, force_delete, hide_null, include, async_req=True)
@@ -209,21 +212,22 @@
         :type force_delete: bool
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -389,28 +393,28 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: FixtureEntityStatisticsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the fes_insert_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.fes_insert_update_with_http_info(
                 organization_id,
                 sport,
                 fixture_entity_statistics_post_body,
                 external,
                 fields,
@@ -449,15 +453,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Create/Update entity total statistics  # noqa: E501
 
         Depending on the data, Add or update a statistic record for ~ENTITYPREIX~ entity in the fixture.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.fes_insert_update_with_http_info(organization_id, sport, fixture_entity_statistics_post_body, external, fields, hide_null, include, async_req=True)
@@ -475,21 +479,22 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -558,15 +563,15 @@
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params["fixture_entity_statistics_post_body"]:
+        if _params["fixture_entity_statistics_post_body"] is not None:
             _body_params = _params["fixture_entity_statistics_post_body"]
 
         # set the HTTP header `Accept`
         _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501
 
         # set the HTTP header `Content-Type`
         _content_types_list = _params.get(
@@ -683,28 +688,28 @@
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: FixtureEntityStatisticsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the fes_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.fes_list_with_http_info(
                 fixture_id,
                 organization_id,
                 sport,
                 added,
                 entity_id,
@@ -767,15 +772,15 @@
                 description="The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information."
             ),
         ] = None,
         updated: Annotated[
             Optional[datetime], Field(description="Record was modified after this date/time. In UTC.")
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Entity total statistics  # noqa: E501
 
         Return a list of entity statistics for a fixture. Statistics are the totals (all periods added together) for the fixture.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.fes_list_with_http_info(fixture_id, organization_id, sport, added, entity_id, external, fields, hide_null, include, limit, offset, updated, async_req=True)
@@ -803,21 +808,22 @@
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1034,28 +1040,28 @@
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: FixtureEntityStatisticsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the fes_listlive_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.fes_listlive_with_http_info(
                 fixture_id,
                 organization_id,
                 sport,
                 added,
                 entity_id,
@@ -1118,15 +1124,15 @@
                 description="The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information."
             ),
         ] = None,
         updated: Annotated[
             Optional[datetime], Field(description="Record was modified after this date/time. In UTC.")
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Entity total statistics - live  # noqa: E501
 
              Return a list of live entity statistics for a fixture. Statistics are the totals (all periods     added together) for the fixture. This call will return records of fixtures still in-progress if available.     If the fixture is complete this call operates the same as the non 'live' route.      Rate limited to 2 requests every minute - returns HTTP 429 Too Many Requests if called more often.       # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.fes_listlive_with_http_info(fixture_id, organization_id, sport, added, entity_id, external, fields, hide_null, include, limit, offset, updated, async_req=True)
@@ -1154,21 +1160,22 @@
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1393,28 +1400,28 @@
         :type period_id: int
         :param section: The section of the period (sub-period)
         :type section: str
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: FixtureEntityStatisticsPeriodsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the fes_listperiod_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.fes_listperiod_with_http_info(
                 fixture_id,
                 organization_id,
                 sport,
                 added,
                 entity_id,
@@ -1483,15 +1490,15 @@
         section: Annotated[
             Optional[constr(strict=True, max_length=100)], Field(description="The section of the period (sub-period)")
         ] = None,
         updated: Annotated[
             Optional[datetime], Field(description="Record was modified after this date/time. In UTC.")
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Entity period statistics  # noqa: E501
 
         Return a list of entity statistics for a fixture broken down by period  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.fes_listperiod_with_http_info(fixture_id, organization_id, sport, added, entity_id, external, fields, hide_null, include, limit, offset, period_id, section, updated, async_req=True)
@@ -1523,21 +1530,22 @@
         :type period_id: int
         :param section: The section of the period (sub-period)
         :type section: str
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1770,28 +1778,28 @@
         :type period_id: int
         :param section: The section of the period (sub-period)
         :type section: str
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: FixtureEntityStatisticsPeriodsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the fes_listperiodlive_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.fes_listperiodlive_with_http_info(
                 fixture_id,
                 organization_id,
                 sport,
                 added,
                 entity_id,
@@ -1860,15 +1868,15 @@
         section: Annotated[
             Optional[constr(strict=True, max_length=100)], Field(description="The section of the period (sub-period)")
         ] = None,
         updated: Annotated[
             Optional[datetime], Field(description="Record was modified after this date/time. In UTC.")
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Entity period statistics - live  # noqa: E501
 
              Return a list of entity statistics for a fixture broken down by period. This call will return     records of fixtures still in-progress if available.  If the fixture is complete this call operates the same     as the non 'live' route.      Rate limited to 2 requests every minute - returns HTTP 429 Too Many Requests if called more often.       # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.fes_listperiodlive_with_http_info(fixture_id, organization_id, sport, added, entity_id, external, fields, hide_null, include, limit, offset, period_id, section, updated, async_req=True)
@@ -1900,21 +1908,22 @@
         :type period_id: int
         :param section: The section of the period (sub-period)
         :type section: str
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -2129,28 +2138,28 @@
         :type include: str
         :param period_id: The identifier for the period
         :type period_id: int
         :param section: The section of the period (sub-period)
         :type section: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: FixtureEntityStatisticsPeriodsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the fesp_delete_all_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.fesp_delete_all_with_http_info(
                 fixture_id,
                 organization_id,
                 sport,
                 entity_id,
                 external,
@@ -2204,15 +2213,15 @@
             ),
         ] = None,
         period_id: Annotated[Optional[StrictInt], Field(description="The identifier for the period")] = None,
         section: Annotated[
             Optional[constr(strict=True, max_length=100)], Field(description="The section of the period (sub-period)")
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Delete entity period statistics  # noqa: E501
 
         Delete statistics for a fixture for a given entity by period.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.fesp_delete_all_with_http_info(fixture_id, organization_id, sport, entity_id, external, fields, force_delete, hide_null, include, period_id, section, async_req=True)
@@ -2238,21 +2247,22 @@
         :type include: str
         :param period_id: The identifier for the period
         :type period_id: int
         :param section: The section of the period (sub-period)
         :type section: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -2426,28 +2436,28 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: FixtureEntityStatisticsPeriodsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the fesp_insert_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.fesp_insert_update_with_http_info(
                 organization_id,
                 sport,
                 fixture_entity_period_statistics_post_body,
                 external,
                 fields,
@@ -2486,15 +2496,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Create/Update entity period statistics  # noqa: E501
 
         Depending on the data, Add or update a statistic record for ~ENTITYPREIX~ entity in a period of the fixture.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.fesp_insert_update_with_http_info(organization_id, sport, fixture_entity_period_statistics_post_body, external, fields, hide_null, include, async_req=True)
@@ -2512,21 +2522,22 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -2595,15 +2606,15 @@
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params["fixture_entity_period_statistics_post_body"]:
+        if _params["fixture_entity_period_statistics_post_body"] is not None:
             _body_params = _params["fixture_entity_period_statistics_post_body"]
 
         # set the HTTP header `Accept`
         _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501
 
         # set the HTTP header `Content-Type`
         _content_types_list = _params.get(
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/api/entity_groups_api.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/api/entity_groups_api.py`

 * *Files 5% similar despite different names*

```diff
@@ -8,23 +8,26 @@
     The version of the OpenAPI document: v1
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the file manually.
 """
 
 
+import io
 import logging
 import re  # noqa: F401
+import warnings
 from datetime import datetime
 from typing import Optional
 
 from pydantic import Field, StrictBool, StrictInt, StrictStr, ValidationError, conint, constr, validate_arguments
 from typing_extensions import Annotated
 
 from atriumsports.datacore.openapi.api_client import ApiClient
+from atriumsports.datacore.openapi.api_response import ApiResponse
 from atriumsports.datacore.openapi.exceptions import ApiTypeError, ApiValueError  # noqa: F401
 from atriumsports.datacore.openapi.models.entity_group_post_body import EntityGroupPostBody
 from atriumsports.datacore.openapi.models.entity_group_put_body import EntityGroupPutBody
 from atriumsports.datacore.openapi.models.entity_groups_response import EntityGroupsResponse
 
 logger = logging.getLogger("openapi")
 
@@ -102,28 +105,28 @@
         :type force_delete: bool
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: EntityGroupsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the entity_group_delete_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.entity_group_delete_with_http_info(
                 entity_group_id, organization_id, sport, external, fields, force_delete, hide_null, include, **kwargs
             )  # noqa: E501
         except Exception as e:
             logger.error("Exception when calling EntityGroupsApi->entity_group_delete: %s\n" % e)
             raise
@@ -161,15 +164,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Delete an entity group  # noqa: E501
 
         Delete a specific entity group  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.entity_group_delete_with_http_info(entity_group_id, organization_id, sport, external, fields, force_delete, hide_null, include, async_req=True)
@@ -189,21 +192,22 @@
         :type force_delete: bool
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -381,28 +385,28 @@
         :type include: str
         :param limit: The maximum number of records to return. See [Pagination](#section/Introduction/Pagination) for more information.
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: EntityGroupsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the entity_group_detail_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.entity_group_detail_with_http_info(
                 entity_group_id, organization_id, sport, external, fields, hide_null, include, limit, offset, **kwargs
             )  # noqa: E501
         except Exception as e:
             logger.error("Exception when calling EntityGroupsApi->entity_group_detail: %s\n" % e)
             raise
@@ -446,15 +450,15 @@
         offset: Annotated[
             Optional[StrictInt],
             Field(
                 description="The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Get an entity group  # noqa: E501
 
         Return detailed information about a specific entity group  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.entity_group_detail_with_http_info(entity_group_id, organization_id, sport, external, fields, hide_null, include, limit, offset, async_req=True)
@@ -476,21 +480,22 @@
         :type include: str
         :param limit: The maximum number of records to return. See [Pagination](#section/Introduction/Pagination) for more information.
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -656,28 +661,28 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: EntityGroupsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the entity_group_insert_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.entity_group_insert_with_http_info(
                 organization_id, sport, entity_group_post_body, external, fields, hide_null, include, **kwargs
             )  # noqa: E501
         except Exception as e:
             logger.error("Exception when calling EntityGroupsApi->entity_group_insert: %s\n" % e)
             raise
@@ -709,15 +714,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Create an entity group  # noqa: E501
 
         Create a new entity group  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.entity_group_insert_with_http_info(organization_id, sport, entity_group_post_body, external, fields, hide_null, include, async_req=True)
@@ -735,21 +740,22 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -818,15 +824,15 @@
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params["entity_group_post_body"]:
+        if _params["entity_group_post_body"] is not None:
             _body_params = _params["entity_group_post_body"]
 
         # set the HTTP header `Accept`
         _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501
 
         # set the HTTP header `Content-Type`
         _content_types_list = _params.get(
@@ -943,28 +949,28 @@
         :type offset: int
         :param status: Status >- `ACTIVE` Active >- `INACTIVE` Inactive >- `PENDING` Pending
         :type status: str
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: EntityGroupsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the entity_group_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.entity_group_list_with_http_info(
                 organization_id,
                 sport,
                 added,
                 external,
                 fields,
@@ -1028,15 +1034,15 @@
             Optional[StrictStr],
             Field(description="Status >- `ACTIVE` Active >- `INACTIVE` Inactive >- `PENDING` Pending "),
         ] = None,
         updated: Annotated[
             Optional[datetime], Field(description="Record was modified after this date/time. In UTC.")
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Get a list of entity groups  # noqa: E501
 
         Return a list of available entity groups  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.entity_group_list_with_http_info(organization_id, sport, added, external, fields, hide_null, include, limit, offset, status, updated, async_req=True)
@@ -1062,21 +1068,22 @@
         :type offset: int
         :param status: Status >- `ACTIVE` Active >- `INACTIVE` Inactive >- `PENDING` Pending
         :type status: str
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1157,15 +1164,15 @@
         if _params.get("limit") is not None:  # noqa: E501
             _query_params.append(("limit", _params["limit"]))
 
         if _params.get("offset") is not None:  # noqa: E501
             _query_params.append(("offset", _params["offset"]))
 
         if _params.get("status") is not None:  # noqa: E501
-            _query_params.append(("status", _params["status"]))
+            _query_params.append(("status", _params["status"].value))
 
         if _params.get("updated") is not None:  # noqa: E501
             if isinstance(_params["updated"], datetime):
                 _query_params.append(
                     ("updated", _params["updated"].strftime(self.api_client.configuration.datetime_format))
                 )
             else:
@@ -1263,28 +1270,28 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: EntityGroupsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the entity_group_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.entity_group_update_with_http_info(
                 entity_group_id,
                 organization_id,
                 sport,
                 entity_group_put_body,
                 external,
@@ -1325,15 +1332,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Update an entity group  # noqa: E501
 
         Change the information of a specific entity group  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.entity_group_update_with_http_info(entity_group_id, organization_id, sport, entity_group_put_body, external, fields, hide_null, include, async_req=True)
@@ -1353,21 +1360,22 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1440,15 +1448,15 @@
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params["entity_group_put_body"]:
+        if _params["entity_group_put_body"] is not None:
             _body_params = _params["entity_group_put_body"]
 
         # set the HTTP header `Accept`
         _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501
 
         # set the HTTP header `Content-Type`
         _content_types_list = _params.get(
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/api/fixture_entities_api.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/api/fixture_entities_api.py`

 * *Files 2% similar despite different names*

```diff
@@ -8,23 +8,26 @@
     The version of the OpenAPI document: v1
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the file manually.
 """
 
 
+import io
 import logging
 import re  # noqa: F401
+import warnings
 from datetime import datetime
 from typing import Optional
 
 from pydantic import Field, StrictBool, StrictInt, StrictStr, ValidationError, conint, constr, validate_arguments
 from typing_extensions import Annotated
 
 from atriumsports.datacore.openapi.api_client import ApiClient
+from atriumsports.datacore.openapi.api_response import ApiResponse
 from atriumsports.datacore.openapi.exceptions import ApiTypeError, ApiValueError  # noqa: F401
 from atriumsports.datacore.openapi.models.fixture_entities_post_body import FixtureEntitiesPostBody
 from atriumsports.datacore.openapi.models.fixture_entities_response import FixtureEntitiesResponse
 
 logger = logging.getLogger("openapi")
 
 
@@ -112,28 +115,28 @@
         :type include: str
         :param limit: The maximum number of records to return. See [Pagination](#section/Introduction/Pagination) for more information.
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: FixtureEntitiesResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the fixture_entities_detail_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.fixture_entities_detail_with_http_info(
                 entity_id,
                 fixture_id,
                 organization_id,
                 sport,
                 external,
@@ -188,15 +191,15 @@
         offset: Annotated[
             Optional[StrictInt],
             Field(
                 description="The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Get an entity in a fixture  # noqa: E501
 
         Return the detail of a specific entity in a fixture  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.fixture_entities_detail_with_http_info(entity_id, fixture_id, organization_id, sport, external, fields, hide_null, include, limit, offset, async_req=True)
@@ -220,21 +223,22 @@
         :type include: str
         :param limit: The maximum number of records to return. See [Pagination](#section/Introduction/Pagination) for more information.
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -409,28 +413,28 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: FixtureEntitiesResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the fixture_entities_insert_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.fixture_entities_insert_update_with_http_info(
                 fixture_id,
                 organization_id,
                 sport,
                 fixture_entities_post_body,
                 external,
@@ -471,15 +475,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Add or Update an entity in a fixture  # noqa: E501
 
         Depending on primary keys, Add an entity or update an existing entitiy in a fixture  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.fixture_entities_insert_update_with_http_info(fixture_id, organization_id, sport, fixture_entities_post_body, external, fields, hide_null, include, async_req=True)
@@ -499,21 +503,22 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -588,15 +593,15 @@
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params["fixture_entities_post_body"]:
+        if _params["fixture_entities_post_body"] is not None:
             _body_params = _params["fixture_entities_post_body"]
 
         # set the HTTP header `Accept`
         _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501
 
         # set the HTTP header `Content-Type`
         _content_types_list = _params.get(
@@ -710,28 +715,28 @@
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: FixtureEntitiesResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the fixture_entities_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.fixture_entities_list_with_http_info(
                 fixture_id,
                 organization_id,
                 sport,
                 added,
                 external,
@@ -792,15 +797,15 @@
                 description="The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information."
             ),
         ] = None,
         updated: Annotated[
             Optional[datetime], Field(description="Record was modified after this date/time. In UTC.")
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Get a list of entities in the fixture  # noqa: E501
 
         Return a list of entities for a fixture  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.fixture_entities_list_with_http_info(fixture_id, organization_id, sport, added, external, fields, hide_null, include, limit, offset, updated, async_req=True)
@@ -826,21 +831,22 @@
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1035,28 +1041,28 @@
         :type force_delete: bool
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: FixtureEntitiesResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the fixture_entity_delete_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.fixture_entity_delete_with_http_info(
                 entity_id,
                 fixture_id,
                 organization_id,
                 sport,
                 external,
@@ -1104,15 +1110,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Delete an entity from a fixture  # noqa: E501
 
         Delete a specific entity from a fixture  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.fixture_entity_delete_with_http_info(entity_id, fixture_id, organization_id, sport, external, fields, force_delete, hide_null, include, async_req=True)
@@ -1134,21 +1140,22 @@
         :type force_delete: bool
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/api/fixture_live_summary_api.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/api/fixture_live_summary_api.py`

 * *Files 2% similar despite different names*

```diff
@@ -8,22 +8,25 @@
     The version of the OpenAPI document: v1
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the file manually.
 """
 
 
+import io
 import logging
 import re  # noqa: F401
+import warnings
 from typing import Optional
 
 from pydantic import Field, StrictInt, StrictStr, ValidationError, conint, constr, validate_arguments
 from typing_extensions import Annotated
 
 from atriumsports.datacore.openapi.api_client import ApiClient
+from atriumsports.datacore.openapi.api_response import ApiResponse
 from atriumsports.datacore.openapi.exceptions import ApiTypeError, ApiValueError  # noqa: F401
 from atriumsports.datacore.openapi.models.fixture_live_summary_response import FixtureLiveSummaryResponse
 
 logger = logging.getLogger("openapi")
 
 
 class FixtureLiveSummaryApi(object):
@@ -78,28 +81,28 @@
         :type sport: str
         :param limit: The maximum number of records to return. See [Pagination](#section/Introduction/Pagination) for more information.
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: FixtureLiveSummaryResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the fls_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.fls_list_with_http_info(
                 fixture_id, organization_id, sport, limit, offset, **kwargs
             )  # noqa: E501
         except Exception as e:
             logger.error("Exception when calling FixtureLiveSummaryApi->fls_list: %s\n" % e)
             raise
@@ -122,15 +125,15 @@
         offset: Annotated[
             Optional[StrictInt],
             Field(
                 description="The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Fixture Live Summary  # noqa: E501
 
              Return summary data for a fixture currently in progress on the streaming API.  This call will only return data     when the fixture is in progress - not post fixture.      Rate limited to 2 requests every minute - returns HTTP 429 Too Many Requests if called more often.       # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.fls_list_with_http_info(fixture_id, organization_id, sport, limit, offset, async_req=True)
@@ -144,21 +147,22 @@
         :type sport: str
         :param limit: The maximum number of records to return. See [Pagination](#section/Introduction/Pagination) for more information.
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/api/fixture_persons_api.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/api/fixture_persons_api.py`

 * *Files 2% similar despite different names*

```diff
@@ -8,23 +8,26 @@
     The version of the OpenAPI document: v1
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the file manually.
 """
 
 
+import io
 import logging
 import re  # noqa: F401
+import warnings
 from datetime import datetime
 from typing import Optional
 
 from pydantic import Field, StrictBool, StrictInt, StrictStr, ValidationError, conint, constr, validate_arguments
 from typing_extensions import Annotated
 
 from atriumsports.datacore.openapi.api_client import ApiClient
+from atriumsports.datacore.openapi.api_response import ApiResponse
 from atriumsports.datacore.openapi.exceptions import ApiTypeError, ApiValueError  # noqa: F401
 from atriumsports.datacore.openapi.models.fixture_persons_post_body import FixturePersonsPostBody
 from atriumsports.datacore.openapi.models.fixture_persons_response import FixturePersonsResponse
 
 logger = logging.getLogger("openapi")
 
 
@@ -104,28 +107,28 @@
         :type force_delete: bool
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: FixturePersonsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the fixture_person_delete_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.fixture_person_delete_with_http_info(
                 fixture_id,
                 organization_id,
                 person_id,
                 sport,
                 external,
@@ -173,15 +176,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Delete a person from a fixture  # noqa: E501
 
         Delete a specific person from a fixture  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.fixture_person_delete_with_http_info(fixture_id, organization_id, person_id, sport, external, fields, force_delete, hide_null, include, async_req=True)
@@ -203,21 +206,22 @@
         :type force_delete: bool
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -402,28 +406,28 @@
         :type include: str
         :param limit: The maximum number of records to return. See [Pagination](#section/Introduction/Pagination) for more information.
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: FixturePersonsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the fixture_persons_detail_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.fixture_persons_detail_with_http_info(
                 fixture_id,
                 organization_id,
                 person_id,
                 sport,
                 external,
@@ -478,15 +482,15 @@
         offset: Annotated[
             Optional[StrictInt],
             Field(
                 description="The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Get a person in a fixture  # noqa: E501
 
         Return the detail of a specific person in a fixture  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.fixture_persons_detail_with_http_info(fixture_id, organization_id, person_id, sport, external, fields, hide_null, include, limit, offset, async_req=True)
@@ -510,21 +514,22 @@
         :type include: str
         :param limit: The maximum number of records to return. See [Pagination](#section/Introduction/Pagination) for more information.
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -697,28 +702,28 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: FixturePersonsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the fixture_persons_insert_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.fixture_persons_insert_update_with_http_info(
                 fixture_id,
                 organization_id,
                 sport,
                 fixture_persons_post_body,
                 external,
@@ -759,15 +764,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Add or Update a person in a fixture  # noqa: E501
 
         Depending on primary keys, Add a person or update an existing person in a fixture  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.fixture_persons_insert_update_with_http_info(fixture_id, organization_id, sport, fixture_persons_post_body, external, fields, hide_null, include, async_req=True)
@@ -787,21 +792,22 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -876,15 +882,15 @@
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params["fixture_persons_post_body"]:
+        if _params["fixture_persons_post_body"] is not None:
             _body_params = _params["fixture_persons_post_body"]
 
         # set the HTTP header `Accept`
         _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501
 
         # set the HTTP header `Content-Type`
         _content_types_list = _params.get(
@@ -998,28 +1004,28 @@
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: FixturePersonsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the fixture_persons_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.fixture_persons_list_with_http_info(
                 fixture_id,
                 organization_id,
                 sport,
                 added,
                 external,
@@ -1080,15 +1086,15 @@
                 description="The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information."
             ),
         ] = None,
         updated: Annotated[
             Optional[datetime], Field(description="Record was modified after this date/time. In UTC.")
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Get a list of persons in the fixture  # noqa: E501
 
         Return a list of persons for a fixture  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.fixture_persons_list_with_http_info(fixture_id, organization_id, sport, added, external, fields, hide_null, include, limit, offset, updated, async_req=True)
@@ -1114,21 +1120,22 @@
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/api/fixture_playbyplay_api.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/api/fixture_playbyplay_api.py`

 * *Files 2% similar despite different names*

```diff
@@ -8,23 +8,26 @@
     The version of the OpenAPI document: v1
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the file manually.
 """
 
 
+import io
 import logging
 import re  # noqa: F401
+import warnings
 from datetime import datetime
 from typing import Optional
 
 from pydantic import Field, StrictBool, StrictInt, StrictStr, ValidationError, conint, constr, validate_arguments
 from typing_extensions import Annotated
 
 from atriumsports.datacore.openapi.api_client import ApiClient
+from atriumsports.datacore.openapi.api_response import ApiResponse
 from atriumsports.datacore.openapi.exceptions import ApiTypeError, ApiValueError  # noqa: F401
 from atriumsports.datacore.openapi.models.fixture_pbp_event_response import FixturePbpEventResponse
 from atriumsports.datacore.openapi.models.fixture_pbp_post_body import FixturePbpPostBody
 from atriumsports.datacore.openapi.models.fixture_pbp_response import FixturePbpResponse
 
 logger = logging.getLogger("openapi")
 
@@ -102,28 +105,28 @@
         :type force_delete: bool
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: FixturePbpResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the fixture_pbp_all_delete_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.fixture_pbp_all_delete_with_http_info(
                 fixture_id, organization_id, sport, external, fields, force_delete, hide_null, include, **kwargs
             )  # noqa: E501
         except Exception as e:
             logger.error("Exception when calling FixturePLAYBYPLAYApi->fixture_pbp_all_delete: %s\n" % e)
             raise
@@ -161,15 +164,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Delete all play-by-play records for a fixture  # noqa: E501
 
         Delete all play-by-play records for a fixture  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.fixture_pbp_all_delete_with_http_info(fixture_id, organization_id, sport, external, fields, force_delete, hide_null, include, async_req=True)
@@ -189,21 +192,22 @@
         :type force_delete: bool
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -381,28 +385,28 @@
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param section: The section of the period (sub-period)
         :type section: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: FixturePbpResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the fixture_pbp_delete_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.fixture_pbp_delete_with_http_info(
                 fixture_id,
                 organization_id,
                 period_id,
                 sport,
                 external,
@@ -454,15 +458,15 @@
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         section: Annotated[
             Optional[constr(strict=True, max_length=100)], Field(description="The section of the period (sub-period)")
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Delete a fixture play-by-play  # noqa: E501
 
         Delete a specific period play-by-play from a fixture  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.fixture_pbp_delete_with_http_info(fixture_id, organization_id, period_id, sport, external, fields, force_delete, hide_null, include, section, async_req=True)
@@ -486,21 +490,22 @@
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param section: The section of the period (sub-period)
         :type section: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -673,28 +678,28 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: FixturePbpResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the fixture_pbp_insert_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.fixture_pbp_insert_update_with_http_info(
                 fixture_id,
                 organization_id,
                 sport,
                 fixture_pbp_post_body,
                 external,
@@ -735,15 +740,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Add or Update historical play-by-play records for a fixture  # noqa: E501
 
              Depending on primary keys, Add a fixture play-by-play or update an existing record.  This call operates     in bulk for all events in a specific period. <b>Note:</b>This call should only be used to import historical data.     Changes to current/live data show be peformed only via your live capture software.  If this call is used data may     become invalid as statistics/actions may not be recalculated.       # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.fixture_pbp_insert_update_with_http_info(fixture_id, organization_id, sport, fixture_pbp_post_body, external, fields, hide_null, include, async_req=True)
@@ -763,21 +768,22 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -852,15 +858,15 @@
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params["fixture_pbp_post_body"]:
+        if _params["fixture_pbp_post_body"] is not None:
             _body_params = _params["fixture_pbp_post_body"]
 
         # set the HTTP header `Accept`
         _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501
 
         # set the HTTP header `Content-Type`
         _content_types_list = _params.get(
@@ -979,28 +985,28 @@
         :type offset: int
         :param period_id: The identifier for the period
         :type period_id: int
         :param to_timestamp: Where the date/time (UTC) this play-by-play event was sent <= this value
         :type to_timestamp: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: FixturePbpEventResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the fixture_pbp_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.fixture_pbp_list_with_http_info(
                 fixture_id,
                 organization_id,
                 sport,
                 external,
                 fields,
@@ -1065,15 +1071,15 @@
         ] = None,
         period_id: Annotated[Optional[StrictInt], Field(description="The identifier for the period")] = None,
         to_timestamp: Annotated[
             Optional[datetime],
             Field(description="Where the date/time (UTC) this play-by-play event was sent <= this value"),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Get a list play-by-play records for a fixture  # noqa: E501
 
         Return a list of play-by-play records for a fixture  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.fixture_pbp_list_with_http_info(fixture_id, organization_id, sport, external, fields, from_timestamp, hide_null, include, limit, offset, period_id, to_timestamp, async_req=True)
@@ -1101,21 +1107,22 @@
         :type offset: int
         :param period_id: The identifier for the period
         :type period_id: int
         :param to_timestamp: Where the date/time (UTC) this play-by-play event was sent <= this value
         :type to_timestamp: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1334,28 +1341,28 @@
         :type offset: int
         :param period_id: The identifier for the period
         :type period_id: int
         :param to_timestamp: Where the date/time (UTC) this play-by-play event was sent <= this value
         :type to_timestamp: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: FixturePbpEventResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the fixture_pbp_list_live_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.fixture_pbp_list_live_with_http_info(
                 fixture_id,
                 organization_id,
                 sport,
                 external,
                 fields,
@@ -1420,15 +1427,15 @@
         ] = None,
         period_id: Annotated[Optional[StrictInt], Field(description="The identifier for the period")] = None,
         to_timestamp: Annotated[
             Optional[datetime],
             Field(description="Where the date/time (UTC) this play-by-play event was sent <= this value"),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Get a list of live play-by-play records for a fixture  # noqa: E501
 
              Return a list of live play-by-play records for a fixture. This call will return records of fixtures     still in-progress if available.  If the fixture is complete this call operates the same as the non 'live'     route.      Rate limited to 2 requests every minute - returns HTTP 429 Too Many Requests if called more often.       # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.fixture_pbp_list_live_with_http_info(fixture_id, organization_id, sport, external, fields, from_timestamp, hide_null, include, limit, offset, period_id, to_timestamp, async_req=True)
@@ -1456,21 +1463,22 @@
         :type offset: int
         :param period_id: The identifier for the period
         :type period_id: int
         :param to_timestamp: Where the date/time (UTC) this play-by-play event was sent <= this value
         :type to_timestamp: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/api/fixture_profiles_api.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/api/fixture_profiles_api.py`

 * *Files 5% similar despite different names*

```diff
@@ -8,23 +8,26 @@
     The version of the OpenAPI document: v1
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the file manually.
 """
 
 
+import io
 import logging
 import re  # noqa: F401
+import warnings
 from datetime import datetime
 from typing import Optional
 
 from pydantic import Field, StrictBool, StrictInt, StrictStr, ValidationError, conint, constr, validate_arguments
 from typing_extensions import Annotated
 
 from atriumsports.datacore.openapi.api_client import ApiClient
+from atriumsports.datacore.openapi.api_response import ApiResponse
 from atriumsports.datacore.openapi.exceptions import ApiTypeError, ApiValueError  # noqa: F401
 from atriumsports.datacore.openapi.models.fixture_profiles_post_body import FixtureProfilesPostBody
 from atriumsports.datacore.openapi.models.fixture_profiles_put_body import FixtureProfilesPutBody
 from atriumsports.datacore.openapi.models.fixture_profiles_response import FixtureProfilesResponse
 
 logger = logging.getLogger("openapi")
 
@@ -102,28 +105,28 @@
         :type force_delete: bool
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: FixtureProfilesResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the fixture_profiles_delete_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.fixture_profiles_delete_with_http_info(
                 organization_id, profile_id, sport, external, fields, force_delete, hide_null, include, **kwargs
             )  # noqa: E501
         except Exception as e:
             logger.error("Exception when calling FixtureProfilesApi->fixture_profiles_delete: %s\n" % e)
             raise
@@ -161,15 +164,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Delete a fixture profile  # noqa: E501
 
         Delete a specific fixture profile  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.fixture_profiles_delete_with_http_info(organization_id, profile_id, sport, external, fields, force_delete, hide_null, include, async_req=True)
@@ -189,21 +192,22 @@
         :type force_delete: bool
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -383,28 +387,28 @@
         :type include: str
         :param limit: The maximum number of records to return. See [Pagination](#section/Introduction/Pagination) for more information.
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: FixtureProfilesResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the fixture_profiles_detail_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.fixture_profiles_detail_with_http_info(
                 organization_id, profile_id, sport, external, fields, hide_null, include, limit, offset, **kwargs
             )  # noqa: E501
         except Exception as e:
             logger.error("Exception when calling FixtureProfilesApi->fixture_profiles_detail: %s\n" % e)
             raise
@@ -448,15 +452,15 @@
         offset: Annotated[
             Optional[StrictInt],
             Field(
                 description="The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Get a fixture profile  # noqa: E501
 
         Return detailed information about a specific fixture profile  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.fixture_profiles_detail_with_http_info(organization_id, profile_id, sport, external, fields, hide_null, include, limit, offset, async_req=True)
@@ -478,21 +482,22 @@
         :type include: str
         :param limit: The maximum number of records to return. See [Pagination](#section/Introduction/Pagination) for more information.
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -660,28 +665,28 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: FixtureProfilesResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the fixture_profiles_insert_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.fixture_profiles_insert_with_http_info(
                 organization_id, sport, fixture_profiles_post_body, external, fields, hide_null, include, **kwargs
             )  # noqa: E501
         except Exception as e:
             logger.error("Exception when calling FixtureProfilesApi->fixture_profiles_insert: %s\n" % e)
             raise
@@ -713,15 +718,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Create a new fixture profile  # noqa: E501
 
         Add a new fixture profile  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.fixture_profiles_insert_with_http_info(organization_id, sport, fixture_profiles_post_body, external, fields, hide_null, include, async_req=True)
@@ -739,21 +744,22 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -824,15 +830,15 @@
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params["fixture_profiles_post_body"]:
+        if _params["fixture_profiles_post_body"] is not None:
             _body_params = _params["fixture_profiles_post_body"]
 
         # set the HTTP header `Accept`
         _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501
 
         # set the HTTP header `Content-Type`
         _content_types_list = _params.get(
@@ -956,28 +962,28 @@
         :type name_contains: str
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: FixtureProfilesResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the fixture_profiles_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.fixture_profiles_list_with_http_info(
                 organization_id,
                 sport,
                 added,
                 default_profile,
                 external,
@@ -1047,15 +1053,15 @@
                 description="The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information."
             ),
         ] = None,
         updated: Annotated[
             Optional[datetime], Field(description="Record was modified after this date/time. In UTC.")
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Get a list of fixture profiles  # noqa: E501
 
         Return a list of available fixture profiles.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.fixture_profiles_list_with_http_info(organization_id, sport, added, default_profile, external, fields, hide_null, include, limit, name_contains, offset, updated, async_req=True)
@@ -1083,21 +1089,22 @@
         :type name_contains: str
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1288,28 +1295,28 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: FixtureProfilesResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the fixture_profiles_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.fixture_profiles_update_with_http_info(
                 organization_id,
                 profile_id,
                 sport,
                 fixture_profiles_put_body,
                 external,
@@ -1350,15 +1357,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Update a fixture profile  # noqa: E501
 
         Change the information of a specific fixture profile  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.fixture_profiles_update_with_http_info(organization_id, profile_id, sport, fixture_profiles_put_body, external, fields, hide_null, include, async_req=True)
@@ -1378,21 +1385,22 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1467,15 +1475,15 @@
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params["fixture_profiles_put_body"]:
+        if _params["fixture_profiles_put_body"] is not None:
             _body_params = _params["fixture_profiles_put_body"]
 
         # set the HTTP header `Accept`
         _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501
 
         # set the HTTP header `Content-Type`
         _content_types_list = _params.get(
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/api/fixture_progressions_api.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/api/fixture_progressions_api.py`

 * *Files 1% similar despite different names*

```diff
@@ -8,23 +8,26 @@
     The version of the OpenAPI document: v1
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the file manually.
 """
 
 
+import io
 import logging
 import re  # noqa: F401
+import warnings
 from datetime import datetime
 from typing import Optional
 
 from pydantic import Field, StrictBool, StrictInt, StrictStr, ValidationError, conint, constr, validate_arguments
 from typing_extensions import Annotated
 
 from atriumsports.datacore.openapi.api_client import ApiClient
+from atriumsports.datacore.openapi.api_response import ApiResponse
 from atriumsports.datacore.openapi.exceptions import ApiTypeError, ApiValueError  # noqa: F401
 from atriumsports.datacore.openapi.models.fixture_progression_post_body import FixtureProgressionPostBody
 from atriumsports.datacore.openapi.models.fixture_progression_put_body import FixtureProgressionPutBody
 from atriumsports.datacore.openapi.models.fixture_progressions_response import FixtureProgressionsResponse
 
 logger = logging.getLogger("openapi")
 
@@ -108,28 +111,28 @@
         :type force_delete: bool
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: FixtureProgressionsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the fixture_progressions_delete_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.fixture_progressions_delete_with_http_info(
                 fixture_id,
                 organization_id,
                 placing,
                 season_id,
                 sport,
@@ -179,15 +182,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Delete a fixture progression  # noqa: E501
 
         Delete a specific fixture progression  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.fixture_progressions_delete_with_http_info(fixture_id, organization_id, placing, season_id, sport, external, fields, force_delete, hide_null, include, async_req=True)
@@ -211,21 +214,22 @@
         :type force_delete: bool
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -419,28 +423,28 @@
         :type include: str
         :param limit: The maximum number of records to return. See [Pagination](#section/Introduction/Pagination) for more information.
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: FixtureProgressionsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the fixture_progressions_detail_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.fixture_progressions_detail_with_http_info(
                 fixture_id,
                 organization_id,
                 placing,
                 season_id,
                 sport,
@@ -497,15 +501,15 @@
         offset: Annotated[
             Optional[StrictInt],
             Field(
                 description="The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Get a fixture progression  # noqa: E501
 
         Return detailed information about a specific fixture progression  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.fixture_progressions_detail_with_http_info(fixture_id, organization_id, placing, season_id, sport, external, fields, hide_null, include, limit, offset, async_req=True)
@@ -531,21 +535,22 @@
         :type include: str
         :param limit: The maximum number of records to return. See [Pagination](#section/Introduction/Pagination) for more information.
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -724,28 +729,28 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: FixtureProgressionsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the fixture_progressions_insert_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.fixture_progressions_insert_with_http_info(
                 organization_id,
                 season_id,
                 sport,
                 fixture_progression_post_body,
                 external,
@@ -786,15 +791,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Create a fixture progression  # noqa: E501
 
         Add a new fixture progression  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.fixture_progressions_insert_with_http_info(organization_id, season_id, sport, fixture_progression_post_body, external, fields, hide_null, include, async_req=True)
@@ -814,21 +819,22 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -903,15 +909,15 @@
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params["fixture_progression_post_body"]:
+        if _params["fixture_progression_post_body"] is not None:
             _body_params = _params["fixture_progression_post_body"]
 
         # set the HTTP header `Accept`
         _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501
 
         # set the HTTP header `Content-Type`
         _content_types_list = _params.get(
@@ -1033,28 +1039,28 @@
         :type offset: int
         :param to_fixture_id: The unique identifier of the destination fixture
         :type to_fixture_id: str
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: FixtureProgressionsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the fixture_progressions_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.fixture_progressions_list_with_http_info(
                 organization_id,
                 season_id,
                 sport,
                 added,
                 external,
@@ -1121,15 +1127,15 @@
         to_fixture_id: Annotated[
             Optional[StrictStr], Field(description="The unique identifier of the destination fixture")
         ] = None,
         updated: Annotated[
             Optional[datetime], Field(description="Record was modified after this date/time. In UTC.")
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Get a list of fixture progressions  # noqa: E501
 
         Return a list of fixture progressions  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.fixture_progressions_list_with_http_info(organization_id, season_id, sport, added, external, fields, fixture_id, hide_null, include, limit, offset, to_fixture_id, updated, async_req=True)
@@ -1159,21 +1165,22 @@
         :type offset: int
         :param to_fixture_id: The unique identifier of the destination fixture
         :type to_fixture_id: str
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1376,28 +1383,28 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: FixtureProgressionsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the fixture_progressions_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.fixture_progressions_update_with_http_info(
                 fixture_id,
                 organization_id,
                 placing,
                 season_id,
                 sport,
@@ -1442,15 +1449,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Update a fixture progression  # noqa: E501
 
         Change the information of a specific fixture progression  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.fixture_progressions_update_with_http_info(fixture_id, organization_id, placing, season_id, sport, fixture_progression_put_body, external, fields, hide_null, include, async_req=True)
@@ -1474,21 +1481,22 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1571,15 +1579,15 @@
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params["fixture_progression_put_body"]:
+        if _params["fixture_progression_put_body"] is not None:
             _body_params = _params["fixture_progression_put_body"]
 
         # set the HTTP header `Accept`
         _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501
 
         # set the HTTP header `Content-Type`
         _content_types_list = _params.get(
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/api/fixture_roster_api.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/api/fixture_roster_api.py`

 * *Files 2% similar despite different names*

```diff
@@ -8,23 +8,26 @@
     The version of the OpenAPI document: v1
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the file manually.
 """
 
 
+import io
 import logging
 import re  # noqa: F401
+import warnings
 from datetime import datetime
 from typing import Optional
 
 from pydantic import Field, StrictBool, StrictInt, StrictStr, ValidationError, conint, constr, validate_arguments
 from typing_extensions import Annotated
 
 from atriumsports.datacore.openapi.api_client import ApiClient
+from atriumsports.datacore.openapi.api_response import ApiResponse
 from atriumsports.datacore.openapi.exceptions import ApiTypeError, ApiValueError  # noqa: F401
 from atriumsports.datacore.openapi.models.fixture_roster_post_body import FixtureRosterPostBody
 from atriumsports.datacore.openapi.models.fixture_roster_response import FixtureRosterResponse
 
 logger = logging.getLogger("openapi")
 
 
@@ -104,28 +107,28 @@
         :type force_delete: bool
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: FixtureRosterResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the fixture_roster_delete_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.fixture_roster_delete_with_http_info(
                 fixture_id,
                 organization_id,
                 person_id,
                 sport,
                 external,
@@ -173,15 +176,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Delete a fixture roster entry  # noqa: E501
 
         Delete a specific fixture roster  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.fixture_roster_delete_with_http_info(fixture_id, organization_id, person_id, sport, external, fields, force_delete, hide_null, include, async_req=True)
@@ -203,21 +206,22 @@
         :type force_delete: bool
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -391,28 +395,28 @@
         :type force_delete: bool
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: FixtureRosterResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the fixture_roster_delete_all_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.fixture_roster_delete_all_with_http_info(
                 fixture_id, organization_id, sport, external, fields, force_delete, hide_null, include, **kwargs
             )  # noqa: E501
         except Exception as e:
             logger.error("Exception when calling FixtureRosterApi->fixture_roster_delete_all: %s\n" % e)
             raise
@@ -450,15 +454,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Delete entire fixture roster  # noqa: E501
 
         Delete entire fixture roster  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.fixture_roster_delete_all_with_http_info(fixture_id, organization_id, sport, external, fields, force_delete, hide_null, include, async_req=True)
@@ -478,21 +482,22 @@
         :type force_delete: bool
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -675,28 +680,28 @@
         :type include: str
         :param limit: The maximum number of records to return. See [Pagination](#section/Introduction/Pagination) for more information.
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: FixtureRosterResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the fixture_roster_detail_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.fixture_roster_detail_with_http_info(
                 fixture_id,
                 organization_id,
                 person_id,
                 sport,
                 external,
@@ -751,15 +756,15 @@
         offset: Annotated[
             Optional[StrictInt],
             Field(
                 description="The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Get the roster information for a person in a fixture  # noqa: E501
 
         Return the detailed roster information for a person in a fixture  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.fixture_roster_detail_with_http_info(fixture_id, organization_id, person_id, sport, external, fields, hide_null, include, limit, offset, async_req=True)
@@ -783,21 +788,22 @@
         :type include: str
         :param limit: The maximum number of records to return. See [Pagination](#section/Introduction/Pagination) for more information.
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -970,28 +976,28 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: FixtureRosterResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the fixture_roster_insert_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.fixture_roster_insert_update_with_http_info(
                 fixture_id,
                 organization_id,
                 sport,
                 fixture_roster_post_body,
                 external,
@@ -1032,15 +1038,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Create/Update a fixture roster  # noqa: E501
 
         Depending on the data, Add a new fixture roster entry or update an existing one  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.fixture_roster_insert_update_with_http_info(fixture_id, organization_id, sport, fixture_roster_post_body, external, fields, hide_null, include, async_req=True)
@@ -1060,21 +1066,22 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1149,15 +1156,15 @@
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params["fixture_roster_post_body"]:
+        if _params["fixture_roster_post_body"] is not None:
             _body_params = _params["fixture_roster_post_body"]
 
         # set the HTTP header `Accept`
         _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501
 
         # set the HTTP header `Content-Type`
         _content_types_list = _params.get(
@@ -1271,28 +1278,28 @@
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: FixtureRosterResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the fixture_roster_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.fixture_roster_list_with_http_info(
                 fixture_id,
                 organization_id,
                 sport,
                 added,
                 external,
@@ -1353,15 +1360,15 @@
                 description="The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information."
             ),
         ] = None,
         updated: Annotated[
             Optional[datetime], Field(description="Record was modified after this date/time. In UTC.")
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Get the roster for a fixture  # noqa: E501
 
         Return a list of persons in the roster for a fixture  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.fixture_roster_list_with_http_info(fixture_id, organization_id, sport, added, external, fields, hide_null, include, limit, offset, updated, async_req=True)
@@ -1387,21 +1394,22 @@
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1614,28 +1622,28 @@
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: FixtureRosterResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the fixture_roster_list_by_entity_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.fixture_roster_list_by_entity_with_http_info(
                 entity_id,
                 fixture_id,
                 organization_id,
                 sport,
                 added,
@@ -1698,15 +1706,15 @@
                 description="The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information."
             ),
         ] = None,
         updated: Annotated[
             Optional[datetime], Field(description="Record was modified after this date/time. In UTC.")
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Get the roster for an entity in a fixture  # noqa: E501
 
         Return a list of persons in the roster for an entity in a fixture  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.fixture_roster_list_by_entity_with_http_info(entity_id, fixture_id, organization_id, sport, added, external, fields, hide_null, include, limit, offset, updated, async_req=True)
@@ -1734,21 +1742,22 @@
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/api/fixtures_api.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/api/fixtures_api.py`

 * *Files 2% similar despite different names*

```diff
@@ -8,23 +8,26 @@
     The version of the OpenAPI document: v1
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the file manually.
 """
 
 
+import io
 import logging
 import re  # noqa: F401
+import warnings
 from datetime import datetime
 from typing import Any, Dict, Optional
 
 from pydantic import Field, StrictBool, StrictInt, StrictStr, ValidationError, conint, constr, validate_arguments
 from typing_extensions import Annotated
 
 from atriumsports.datacore.openapi.api_client import ApiClient
+from atriumsports.datacore.openapi.api_response import ApiResponse
 from atriumsports.datacore.openapi.exceptions import ApiTypeError, ApiValueError  # noqa: F401
 from atriumsports.datacore.openapi.models.fixture_post_body import FixturePostBody
 from atriumsports.datacore.openapi.models.fixture_put_body import FixturePutBody
 from atriumsports.datacore.openapi.models.fixture_videosteam_post_body import FixtureVideosteamPostBody
 from atriumsports.datacore.openapi.models.fixtures_by_entity_response import FixturesByEntityResponse
 from atriumsports.datacore.openapi.models.fixtures_response import FixturesResponse
 from atriumsports.datacore.openapi.models.season_fixture_stages_pools_list_response import (
@@ -211,28 +214,28 @@
         :type to_time_utc: datetime
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param venue_id: The unique identifier of the venue
         :type venue_id: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: FixturesByEntityResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the fixture_by_entity_all_seasons_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.fixture_by_entity_all_seasons_list_with_http_info(
                 entity_id,
                 organization_id,
                 sport,
                 added,
                 competitor_type,
@@ -360,15 +363,15 @@
             Optional[datetime], Field(description="Where fixture start time (in UTC) <= this value")
         ] = None,
         updated: Annotated[
             Optional[datetime], Field(description="Record was modified after this date/time. In UTC.")
         ] = None,
         venue_id: Annotated[Optional[StrictStr], Field(description="The unique identifier of the venue")] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Get a list of fixtures for an Entity  # noqa: E501
 
         Return a list of fixtures, for a specific Entity  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.fixture_by_entity_all_seasons_list_with_http_info(entity_id, organization_id, sport, added, competitor_type, external, fields, fixture_type, from_time_local, from_time_utc, hide_null, include, is_home, limit, live_data_available, live_video_available, locked, offset, pool_code, round_code, round_number, season_id, stage_code, status, times_unconfirmed, to_time_local, to_time_utc, updated, venue_id, async_req=True)
@@ -430,21 +433,22 @@
         :type to_time_utc: datetime
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param venue_id: The unique identifier of the venue
         :type venue_id: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -530,24 +534,24 @@
                 _query_params.append(
                     ("added", _params["added"].strftime(self.api_client.configuration.datetime_format))
                 )
             else:
                 _query_params.append(("added", _params["added"]))
 
         if _params.get("competitor_type") is not None:  # noqa: E501
-            _query_params.append(("competitorType", _params["competitor_type"]))
+            _query_params.append(("competitorType", _params["competitor_type"].value))
 
         if _params.get("external") is not None:  # noqa: E501
             _query_params.append(("external", _params["external"]))
 
         if _params.get("fields") is not None:  # noqa: E501
             _query_params.append(("fields", _params["fields"]))
 
         if _params.get("fixture_type") is not None:  # noqa: E501
-            _query_params.append(("fixtureType", _params["fixture_type"]))
+            _query_params.append(("fixtureType", _params["fixture_type"].value))
 
         if _params.get("from_time_local") is not None:  # noqa: E501
             if isinstance(_params["from_time_local"], datetime):
                 _query_params.append(
                     (
                         "fromTimeLocal",
                         _params["from_time_local"].strftime(self.api_client.configuration.datetime_format),
@@ -600,15 +604,15 @@
         if _params.get("season_id") is not None:  # noqa: E501
             _query_params.append(("seasonId", _params["season_id"]))
 
         if _params.get("stage_code") is not None:  # noqa: E501
             _query_params.append(("stageCode", _params["stage_code"]))
 
         if _params.get("status") is not None:  # noqa: E501
-            _query_params.append(("status", _params["status"]))
+            _query_params.append(("status", _params["status"].value))
 
         if _params.get("times_unconfirmed") is not None:  # noqa: E501
             _query_params.append(("timesUnconfirmed", _params["times_unconfirmed"]))
 
         if _params.get("to_time_local") is not None:  # noqa: E501
             if isinstance(_params["to_time_local"], datetime):
                 _query_params.append(
@@ -844,28 +848,28 @@
         :type to_time_utc: datetime
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param venue_id: The unique identifier of the venue
         :type venue_id: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: FixturesByEntityResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the fixture_by_entity_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.fixture_by_entity_list_with_http_info(
                 entity_id,
                 organization_id,
                 season_id,
                 sport,
                 added,
@@ -1000,15 +1004,15 @@
             Optional[datetime], Field(description="Where fixture start time (in UTC) <= this value")
         ] = None,
         updated: Annotated[
             Optional[datetime], Field(description="Record was modified after this date/time. In UTC.")
         ] = None,
         venue_id: Annotated[Optional[StrictStr], Field(description="The unique identifier of the venue")] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Get a list of fixtures for an Entity  # noqa: E501
 
         Return a list of fixtures, within ~seasonprefix~ season, for a specific Entity  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.fixture_by_entity_list_with_http_info(entity_id, organization_id, season_id, sport, added, competitor_type, external, fields, fixture_type, from_time_local, from_time_utc, hide_null, include, is_home, limit, live_data_available, live_video_available, locked, offset, pool_code, round_code, round_number, sort_by, stage_code, status, times_unconfirmed, to_time_local, to_time_utc, updated, venue_id, async_req=True)
@@ -1072,21 +1076,22 @@
         :type to_time_utc: datetime
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param venue_id: The unique identifier of the venue
         :type venue_id: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1174,24 +1179,24 @@
                 _query_params.append(
                     ("added", _params["added"].strftime(self.api_client.configuration.datetime_format))
                 )
             else:
                 _query_params.append(("added", _params["added"]))
 
         if _params.get("competitor_type") is not None:  # noqa: E501
-            _query_params.append(("competitorType", _params["competitor_type"]))
+            _query_params.append(("competitorType", _params["competitor_type"].value))
 
         if _params.get("external") is not None:  # noqa: E501
             _query_params.append(("external", _params["external"]))
 
         if _params.get("fields") is not None:  # noqa: E501
             _query_params.append(("fields", _params["fields"]))
 
         if _params.get("fixture_type") is not None:  # noqa: E501
-            _query_params.append(("fixtureType", _params["fixture_type"]))
+            _query_params.append(("fixtureType", _params["fixture_type"].value))
 
         if _params.get("from_time_local") is not None:  # noqa: E501
             if isinstance(_params["from_time_local"], datetime):
                 _query_params.append(
                     (
                         "fromTimeLocal",
                         _params["from_time_local"].strftime(self.api_client.configuration.datetime_format),
@@ -1244,15 +1249,15 @@
         if _params.get("sort_by") is not None:  # noqa: E501
             _query_params.append(("sortBy", _params["sort_by"]))
 
         if _params.get("stage_code") is not None:  # noqa: E501
             _query_params.append(("stageCode", _params["stage_code"]))
 
         if _params.get("status") is not None:  # noqa: E501
-            _query_params.append(("status", _params["status"]))
+            _query_params.append(("status", _params["status"].value))
 
         if _params.get("times_unconfirmed") is not None:  # noqa: E501
             _query_params.append(("timesUnconfirmed", _params["times_unconfirmed"]))
 
         if _params.get("to_time_local") is not None:  # noqa: E501
             if isinstance(_params["to_time_local"], datetime):
                 _query_params.append(
@@ -1377,28 +1382,28 @@
         :type force_delete: bool
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: FixturesResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the fixture_delete_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.fixture_delete_with_http_info(
                 fixture_id, organization_id, sport, external, fields, force_delete, hide_null, include, **kwargs
             )  # noqa: E501
         except Exception as e:
             logger.error("Exception when calling FixturesApi->fixture_delete: %s\n" % e)
             raise
@@ -1436,15 +1441,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Delete a fixture  # noqa: E501
 
         Delete a specific fixture  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.fixture_delete_with_http_info(fixture_id, organization_id, sport, external, fields, force_delete, hide_null, include, async_req=True)
@@ -1464,21 +1469,22 @@
         :type force_delete: bool
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1656,28 +1662,28 @@
         :type include: str
         :param limit: The maximum number of records to return. See [Pagination](#section/Introduction/Pagination) for more information.
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: FixturesResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the fixture_detail_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.fixture_detail_with_http_info(
                 fixture_id, organization_id, sport, external, fields, hide_null, include, limit, offset, **kwargs
             )  # noqa: E501
         except Exception as e:
             logger.error("Exception when calling FixturesApi->fixture_detail: %s\n" % e)
             raise
@@ -1721,15 +1727,15 @@
         offset: Annotated[
             Optional[StrictInt],
             Field(
                 description="The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Get a fixture  # noqa: E501
 
         Return detailed information about a specific fixture  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.fixture_detail_with_http_info(fixture_id, organization_id, sport, external, fields, hide_null, include, limit, offset, async_req=True)
@@ -1751,21 +1757,22 @@
         :type include: str
         :param limit: The maximum number of records to return. See [Pagination](#section/Introduction/Pagination) for more information.
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1934,28 +1941,28 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: FixturesResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the fixture_insert_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.fixture_insert_with_http_info(
                 organization_id, season_id, sport, fixture_post_body, external, fields, hide_null, include, **kwargs
             )  # noqa: E501
         except Exception as e:
             logger.error("Exception when calling FixturesApi->fixture_insert: %s\n" % e)
             raise
@@ -1988,15 +1995,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Create a fixture  # noqa: E501
 
         Add a new fixture  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.fixture_insert_with_http_info(organization_id, season_id, sport, fixture_post_body, external, fields, hide_null, include, async_req=True)
@@ -2016,21 +2023,22 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -2103,15 +2111,15 @@
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params["fixture_post_body"]:
+        if _params["fixture_post_body"] is not None:
             _body_params = _params["fixture_post_body"]
 
         # set the HTTP header `Accept`
         _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501
 
         # set the HTTP header `Content-Type`
         _content_types_list = _params.get(
@@ -2199,28 +2207,28 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: FixturesResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the fixture_insert_base_route_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.fixture_insert_base_route_with_http_info(
                 organization_id, sport, fixture_post_body, external, fields, hide_null, include, **kwargs
             )  # noqa: E501
         except Exception as e:
             logger.error("Exception when calling FixturesApi->fixture_insert_base_route: %s\n" % e)
             raise
@@ -2252,15 +2260,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Create a fixture base route  # noqa: E501
 
         Add a new fixture, allowing seasonId to be in payload  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.fixture_insert_base_route_with_http_info(organization_id, sport, fixture_post_body, external, fields, hide_null, include, async_req=True)
@@ -2278,21 +2286,22 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -2355,15 +2364,15 @@
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params["fixture_post_body"]:
+        if _params["fixture_post_body"] is not None:
             _body_params = _params["fixture_post_body"]
 
         # set the HTTP header `Accept`
         _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501
 
         # set the HTTP header `Content-Type`
         _content_types_list = _params.get(
@@ -2577,28 +2586,28 @@
         :type to_time_utc: datetime
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param venue_id: The unique identifier of the venue
         :type venue_id: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: FixturesResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the fixture_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.fixture_list_with_http_info(
                 organization_id,
                 season_id,
                 sport,
                 added,
                 competitor_type,
@@ -2739,15 +2748,15 @@
             Optional[datetime], Field(description="Where fixture start time (in UTC) <= this value")
         ] = None,
         updated: Annotated[
             Optional[datetime], Field(description="Record was modified after this date/time. In UTC.")
         ] = None,
         venue_id: Annotated[Optional[StrictStr], Field(description="The unique identifier of the venue")] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Get a list of fixtures  # noqa: E501
 
         Return a list of fixtures for the season  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.fixture_list_with_http_info(organization_id, season_id, sport, added, competitor_type, external, feature_match, fields, fixture_type, from_time_local, from_time_utc, hide_null, include, limit, live_data_available, live_video_available, locked, offset, pool_code, round_code, round_number, series_code, series_fixture_number, sort_by, stage_code, status, times_unconfirmed, to_time_local, to_time_utc, updated, venue_id, async_req=True)
@@ -2813,21 +2822,22 @@
         :type to_time_utc: datetime
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param venue_id: The unique identifier of the venue
         :type venue_id: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -2913,27 +2923,27 @@
                 _query_params.append(
                     ("added", _params["added"].strftime(self.api_client.configuration.datetime_format))
                 )
             else:
                 _query_params.append(("added", _params["added"]))
 
         if _params.get("competitor_type") is not None:  # noqa: E501
-            _query_params.append(("competitorType", _params["competitor_type"]))
+            _query_params.append(("competitorType", _params["competitor_type"].value))
 
         if _params.get("external") is not None:  # noqa: E501
             _query_params.append(("external", _params["external"]))
 
         if _params.get("feature_match") is not None:  # noqa: E501
             _query_params.append(("featureMatch", _params["feature_match"]))
 
         if _params.get("fields") is not None:  # noqa: E501
             _query_params.append(("fields", _params["fields"]))
 
         if _params.get("fixture_type") is not None:  # noqa: E501
-            _query_params.append(("fixtureType", _params["fixture_type"]))
+            _query_params.append(("fixtureType", _params["fixture_type"].value))
 
         if _params.get("from_time_local") is not None:  # noqa: E501
             if isinstance(_params["from_time_local"], datetime):
                 _query_params.append(
                     (
                         "fromTimeLocal",
                         _params["from_time_local"].strftime(self.api_client.configuration.datetime_format),
@@ -2989,15 +2999,15 @@
         if _params.get("sort_by") is not None:  # noqa: E501
             _query_params.append(("sortBy", _params["sort_by"]))
 
         if _params.get("stage_code") is not None:  # noqa: E501
             _query_params.append(("stageCode", _params["stage_code"]))
 
         if _params.get("status") is not None:  # noqa: E501
-            _query_params.append(("status", _params["status"]))
+            _query_params.append(("status", _params["status"].value))
 
         if _params.get("times_unconfirmed") is not None:  # noqa: E501
             _query_params.append(("timesUnconfirmed", _params["times_unconfirmed"]))
 
         if _params.get("to_time_local") is not None:  # noqa: E501
             if isinstance(_params["to_time_local"], datetime):
                 _query_params.append(
@@ -3117,28 +3127,28 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: SuccessResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the fixture_locking_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.fixture_locking_with_http_info(
                 fixture_id, organization_id, sport, body, external, fields, hide_null, include, **kwargs
             )  # noqa: E501
         except Exception as e:
             logger.error("Exception when calling FixturesApi->fixture_locking: %s\n" % e)
             raise
@@ -3171,15 +3181,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Locking fixture  # noqa: E501
 
         Locking a specific fixture record  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.fixture_locking_with_http_info(fixture_id, organization_id, sport, body, external, fields, hide_null, include, async_req=True)
@@ -3199,21 +3209,22 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -3277,15 +3288,15 @@
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params["body"]:
+        if _params["body"] is not None:
             _body_params = _params["body"]
 
         # set the HTTP header `Accept`
         _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501
 
         # set the HTTP header `Content-Type`
         _content_types_list = _params.get(
@@ -3384,28 +3395,28 @@
         :type force_delete: bool
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: SuccessResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the fixture_reset_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.fixture_reset_with_http_info(
                 fixture_id, organization_id, sport, body, external, fields, force_delete, hide_null, include, **kwargs
             )  # noqa: E501
         except Exception as e:
             logger.error("Exception when calling FixturesApi->fixture_reset: %s\n" % e)
             raise
@@ -3444,15 +3455,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Reset fixture  # noqa: E501
 
         Reset a specific fixture record. Removes statistics, events and PLAY-BY-PLAY records  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.fixture_reset_with_http_info(fixture_id, organization_id, sport, body, external, fields, force_delete, hide_null, include, async_req=True)
@@ -3474,21 +3485,22 @@
         :type force_delete: bool
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -3565,15 +3577,15 @@
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params["body"]:
+        if _params["body"] is not None:
             _body_params = _params["body"]
 
         # set the HTTP header `Accept`
         _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501
 
         # set the HTTP header `Content-Type`
         _content_types_list = _params.get(
@@ -3664,28 +3676,28 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: SuccessResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the fixture_unlocking_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.fixture_unlocking_with_http_info(
                 fixture_id, organization_id, sport, body, external, fields, hide_null, include, **kwargs
             )  # noqa: E501
         except Exception as e:
             logger.error("Exception when calling FixturesApi->fixture_unlocking: %s\n" % e)
             raise
@@ -3718,15 +3730,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Unlock fixture  # noqa: E501
 
         Unlock a specific fixture record  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.fixture_unlocking_with_http_info(fixture_id, organization_id, sport, body, external, fields, hide_null, include, async_req=True)
@@ -3746,21 +3758,22 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -3824,15 +3837,15 @@
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params["body"]:
+        if _params["body"] is not None:
             _body_params = _params["body"]
 
         # set the HTTP header `Accept`
         _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501
 
         # set the HTTP header `Content-Type`
         _content_types_list = _params.get(
@@ -3923,28 +3936,28 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: FixturesResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the fixture_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.fixture_update_with_http_info(
                 fixture_id, organization_id, sport, fixture_put_body, external, fields, hide_null, include, **kwargs
             )  # noqa: E501
         except Exception as e:
             logger.error("Exception when calling FixturesApi->fixture_update: %s\n" % e)
             raise
@@ -3977,15 +3990,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Update a fixture  # noqa: E501
 
         Change the information of a specific fixture  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.fixture_update_with_http_info(fixture_id, organization_id, sport, fixture_put_body, external, fields, hide_null, include, async_req=True)
@@ -4005,21 +4018,22 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -4092,15 +4106,15 @@
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params["fixture_put_body"]:
+        if _params["fixture_put_body"] is not None:
             _body_params = _params["fixture_put_body"]
 
         # set the HTTP header `Accept`
         _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501
 
         # set the HTTP header `Content-Type`
         _content_types_list = _params.get(
@@ -4191,28 +4205,28 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: SuccessResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the fixture_videostream_disable_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.fixture_videostream_disable_with_http_info(
                 fixture_id,
                 organization_id,
                 sport,
                 fixture_videosteam_post_body,
                 external,
@@ -4253,15 +4267,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Disable a fixture live video stream  # noqa: E501
 
         Disable a specific fixture live video stream  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.fixture_videostream_disable_with_http_info(fixture_id, organization_id, sport, fixture_videosteam_post_body, external, fields, hide_null, include, async_req=True)
@@ -4281,21 +4295,22 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -4370,15 +4385,15 @@
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params["fixture_videosteam_post_body"]:
+        if _params["fixture_videosteam_post_body"] is not None:
             _body_params = _params["fixture_videosteam_post_body"]
 
         # set the HTTP header `Accept`
         _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501
 
         # set the HTTP header `Content-Type`
         _content_types_list = _params.get(
@@ -4469,28 +4484,28 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: SuccessResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the fixture_videostream_enable_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.fixture_videostream_enable_with_http_info(
                 fixture_id,
                 organization_id,
                 sport,
                 fixture_videosteam_post_body,
                 external,
@@ -4531,15 +4546,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Enable a fixture live video stream  # noqa: E501
 
         Enable a specific fixture live video stream  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.fixture_videostream_enable_with_http_info(fixture_id, organization_id, sport, fixture_videosteam_post_body, external, fields, hide_null, include, async_req=True)
@@ -4559,21 +4574,22 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -4648,15 +4664,15 @@
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params["fixture_videosteam_post_body"]:
+        if _params["fixture_videosteam_post_body"] is not None:
             _body_params = _params["fixture_videosteam_post_body"]
 
         # set the HTTP header `Accept`
         _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501
 
         # set the HTTP header `Content-Type`
         _content_types_list = _params.get(
@@ -4747,28 +4763,28 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: SuccessResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the fixture_videostream_start_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.fixture_videostream_start_with_http_info(
                 fixture_id,
                 organization_id,
                 sport,
                 fixture_videosteam_post_body,
                 external,
@@ -4809,15 +4825,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Start a fixture live video stream recording  # noqa: E501
 
         Start a specific fixture live video stream recording  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.fixture_videostream_start_with_http_info(fixture_id, organization_id, sport, fixture_videosteam_post_body, external, fields, hide_null, include, async_req=True)
@@ -4837,21 +4853,22 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -4926,15 +4943,15 @@
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params["fixture_videosteam_post_body"]:
+        if _params["fixture_videosteam_post_body"] is not None:
             _body_params = _params["fixture_videosteam_post_body"]
 
         # set the HTTP header `Accept`
         _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501
 
         # set the HTTP header `Content-Type`
         _content_types_list = _params.get(
@@ -5025,28 +5042,28 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: SuccessResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the fixture_videostream_stop_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.fixture_videostream_stop_with_http_info(
                 fixture_id,
                 organization_id,
                 sport,
                 fixture_videosteam_post_body,
                 external,
@@ -5087,15 +5104,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Stop a fixture live video stream recording  # noqa: E501
 
         Stop a specific fixture live video stream recording  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.fixture_videostream_stop_with_http_info(fixture_id, organization_id, sport, fixture_videosteam_post_body, external, fields, hide_null, include, async_req=True)
@@ -5115,21 +5132,22 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -5204,15 +5222,15 @@
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params["fixture_videosteam_post_body"]:
+        if _params["fixture_videosteam_post_body"] is not None:
             _body_params = _params["fixture_videosteam_post_body"]
 
         # set the HTTP header `Accept`
         _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501
 
         # set the HTTP header `Content-Type`
         _content_types_list = _params.get(
@@ -5426,28 +5444,28 @@
         :type to_time_utc: datetime
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param venue_id: The unique identifier of the venue
         :type venue_id: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: FixturesResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the organization_fixture_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.organization_fixture_list_with_http_info(
                 organization_id,
                 sport,
                 added,
                 competitor_type,
                 external,
@@ -5588,15 +5606,15 @@
             Optional[datetime], Field(description="Where fixture start time (in UTC) <= this value")
         ] = None,
         updated: Annotated[
             Optional[datetime], Field(description="Record was modified after this date/time. In UTC.")
         ] = None,
         venue_id: Annotated[Optional[StrictStr], Field(description="The unique identifier of the venue")] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Get a list of fixtures for the organization  # noqa: E501
 
         Return a list of fixtures for the organization  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.organization_fixture_list_with_http_info(organization_id, sport, added, competitor_type, external, feature_match, fields, fixture_type, from_time_local, from_time_utc, hide_null, include, limit, live_data_available, live_video_available, locked, offset, pool_code, round_code, round_number, season_id, series_code, series_fixture_number, sort_by, stage_code, status, times_unconfirmed, to_time_local, to_time_utc, updated, venue_id, async_req=True)
@@ -5662,21 +5680,22 @@
         :type to_time_utc: datetime
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param venue_id: The unique identifier of the venue
         :type venue_id: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -5761,27 +5780,27 @@
                 _query_params.append(
                     ("added", _params["added"].strftime(self.api_client.configuration.datetime_format))
                 )
             else:
                 _query_params.append(("added", _params["added"]))
 
         if _params.get("competitor_type") is not None:  # noqa: E501
-            _query_params.append(("competitorType", _params["competitor_type"]))
+            _query_params.append(("competitorType", _params["competitor_type"].value))
 
         if _params.get("external") is not None:  # noqa: E501
             _query_params.append(("external", _params["external"]))
 
         if _params.get("feature_match") is not None:  # noqa: E501
             _query_params.append(("featureMatch", _params["feature_match"]))
 
         if _params.get("fields") is not None:  # noqa: E501
             _query_params.append(("fields", _params["fields"]))
 
         if _params.get("fixture_type") is not None:  # noqa: E501
-            _query_params.append(("fixtureType", _params["fixture_type"]))
+            _query_params.append(("fixtureType", _params["fixture_type"].value))
 
         if _params.get("from_time_local") is not None:  # noqa: E501
             if isinstance(_params["from_time_local"], datetime):
                 _query_params.append(
                     (
                         "fromTimeLocal",
                         _params["from_time_local"].strftime(self.api_client.configuration.datetime_format),
@@ -5840,15 +5859,15 @@
         if _params.get("sort_by") is not None:  # noqa: E501
             _query_params.append(("sortBy", _params["sort_by"]))
 
         if _params.get("stage_code") is not None:  # noqa: E501
             _query_params.append(("stageCode", _params["stage_code"]))
 
         if _params.get("status") is not None:  # noqa: E501
-            _query_params.append(("status", _params["status"]))
+            _query_params.append(("status", _params["status"].value))
 
         if _params.get("times_unconfirmed") is not None:  # noqa: E501
             _query_params.append(("timesUnconfirmed", _params["times_unconfirmed"]))
 
         if _params.get("to_time_local") is not None:  # noqa: E501
             if isinstance(_params["to_time_local"], datetime):
                 _query_params.append(
@@ -5981,28 +6000,28 @@
         :type include: str
         :param limit: The maximum number of records to return. See [Pagination](#section/Introduction/Pagination) for more information.
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: FixturesResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the orggroup_fixture_detail_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.orggroup_fixture_detail_with_http_info(
                 fixture_id,
                 organization_group_code,
                 sport,
                 external,
                 fields,
@@ -6055,15 +6074,15 @@
         offset: Annotated[
             Optional[StrictInt],
             Field(
                 description="The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Get a single fixture for the organization group  # noqa: E501
 
         Return detailed information about a specific fixture for the organization group  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.orggroup_fixture_detail_with_http_info(fixture_id, organization_group_code, sport, external, fields, hide_null, include, limit, offset, async_req=True)
@@ -6085,21 +6104,22 @@
         :type include: str
         :param limit: The maximum number of records to return. See [Pagination](#section/Introduction/Pagination) for more information.
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -6372,28 +6392,28 @@
         :type to_time_utc: datetime
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param venue_id: The unique identifier of the venue
         :type venue_id: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: FixturesResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the orggroup_fixture_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.orggroup_fixture_list_with_http_info(
                 organization_group_code,
                 sport,
                 added,
                 competitor_type,
                 external,
@@ -6517,15 +6537,15 @@
             Optional[datetime], Field(description="Where fixture start time (in UTC) <= this value")
         ] = None,
         updated: Annotated[
             Optional[datetime], Field(description="Record was modified after this date/time. In UTC.")
         ] = None,
         venue_id: Annotated[Optional[StrictStr], Field(description="The unique identifier of the venue")] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Get a list of fixtures for the organization group  # noqa: E501
 
         Return a list of fixtures for the organization group  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.orggroup_fixture_list_with_http_info(organization_group_code, sport, added, competitor_type, external, fields, fixture_type, from_time_local, from_time_utc, hide_null, include, limit, live_data_available, live_video_available, locked, offset, pool_code, round_code, round_number, season_id, stage_code, status, times_unconfirmed, to_time_local, to_time_utc, updated, venue_id, async_req=True)
@@ -6583,21 +6603,22 @@
         :type to_time_utc: datetime
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param venue_id: The unique identifier of the venue
         :type venue_id: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -6676,24 +6697,24 @@
                 _query_params.append(
                     ("added", _params["added"].strftime(self.api_client.configuration.datetime_format))
                 )
             else:
                 _query_params.append(("added", _params["added"]))
 
         if _params.get("competitor_type") is not None:  # noqa: E501
-            _query_params.append(("competitorType", _params["competitor_type"]))
+            _query_params.append(("competitorType", _params["competitor_type"].value))
 
         if _params.get("external") is not None:  # noqa: E501
             _query_params.append(("external", _params["external"]))
 
         if _params.get("fields") is not None:  # noqa: E501
             _query_params.append(("fields", _params["fields"]))
 
         if _params.get("fixture_type") is not None:  # noqa: E501
-            _query_params.append(("fixtureType", _params["fixture_type"]))
+            _query_params.append(("fixtureType", _params["fixture_type"].value))
 
         if _params.get("from_time_local") is not None:  # noqa: E501
             if isinstance(_params["from_time_local"], datetime):
                 _query_params.append(
                     (
                         "fromTimeLocal",
                         _params["from_time_local"].strftime(self.api_client.configuration.datetime_format),
@@ -6743,15 +6764,15 @@
         if _params.get("season_id") is not None:  # noqa: E501
             _query_params.append(("seasonId", _params["season_id"]))
 
         if _params.get("stage_code") is not None:  # noqa: E501
             _query_params.append(("stageCode", _params["stage_code"]))
 
         if _params.get("status") is not None:  # noqa: E501
-            _query_params.append(("status", _params["status"]))
+            _query_params.append(("status", _params["status"].value))
 
         if _params.get("times_unconfirmed") is not None:  # noqa: E501
             _query_params.append(("timesUnconfirmed", _params["times_unconfirmed"]))
 
         if _params.get("to_time_local") is not None:  # noqa: E501
             if isinstance(_params["to_time_local"], datetime):
                 _query_params.append(
@@ -6897,28 +6918,28 @@
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param stage_code: The stage identifier within a season
         :type stage_code: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: SeasonFixtureStagesPoolsListResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the season_fixture_stages_pools_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.season_fixture_stages_pools_list_with_http_info(
                 organization_id,
                 season_id,
                 sport,
                 external,
                 fields,
@@ -6982,15 +7003,15 @@
                 description="The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information."
             ),
         ] = None,
         stage_code: Annotated[
             Optional[constr(strict=True, max_length=30)], Field(description="The stage identifier within a season")
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Get a list of stages and pools used by fixtures in the season  # noqa: E501
 
         Return a list of stages and pools used by fixtures for a season  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.season_fixture_stages_pools_list_with_http_info(organization_id, season_id, sport, external, fields, fixture_type, hide_null, include, limit, offset, stage_code, async_req=True)
@@ -7016,21 +7037,22 @@
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param stage_code: The stage identifier within a season
         :type stage_code: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -7096,15 +7118,15 @@
         if _params.get("external") is not None:  # noqa: E501
             _query_params.append(("external", _params["external"]))
 
         if _params.get("fields") is not None:  # noqa: E501
             _query_params.append(("fields", _params["fields"]))
 
         if _params.get("fixture_type") is not None:  # noqa: E501
-            _query_params.append(("fixtureType", _params["fixture_type"]))
+            _query_params.append(("fixtureType", _params["fixture_type"].value))
 
         if _params.get("hide_null") is not None:  # noqa: E501
             _query_params.append(("hideNull", _params["hide_null"]))
 
         if _params.get("include") is not None:  # noqa: E501
             _query_params.append(("include", _params["include"]))
 
@@ -7212,28 +7234,28 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: SuccessResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the season_venue_videostream_disable_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.season_venue_videostream_disable_with_http_info(
                 organization_id,
                 season_id,
                 sport,
                 venue_id,
                 fixture_videosteam_post_body,
@@ -7276,15 +7298,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Disable season live video streams for all fixtures for a venue  # noqa: E501
 
         Disable live video stream for all fixtures in season for a venue  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.season_venue_videostream_disable_with_http_info(organization_id, season_id, sport, venue_id, fixture_videosteam_post_body, external, fields, hide_null, include, async_req=True)
@@ -7306,21 +7328,22 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -7399,15 +7422,15 @@
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params["fixture_videosteam_post_body"]:
+        if _params["fixture_videosteam_post_body"] is not None:
             _body_params = _params["fixture_videosteam_post_body"]
 
         # set the HTTP header `Accept`
         _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501
 
         # set the HTTP header `Content-Type`
         _content_types_list = _params.get(
@@ -7501,28 +7524,28 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: SuccessResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the season_venue_videostream_enable_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.season_venue_videostream_enable_with_http_info(
                 organization_id,
                 season_id,
                 sport,
                 venue_id,
                 fixture_videosteam_post_body,
@@ -7565,15 +7588,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Enable season live video streams for all fixtures for a venue  # noqa: E501
 
         Enable live video stream for all fixtures in season for a venue  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.season_venue_videostream_enable_with_http_info(organization_id, season_id, sport, venue_id, fixture_videosteam_post_body, external, fields, hide_null, include, async_req=True)
@@ -7595,21 +7618,22 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -7688,15 +7712,15 @@
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params["fixture_videosteam_post_body"]:
+        if _params["fixture_videosteam_post_body"] is not None:
             _body_params = _params["fixture_videosteam_post_body"]
 
         # set the HTTP header `Accept`
         _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501
 
         # set the HTTP header `Content-Type`
         _content_types_list = _params.get(
@@ -7787,28 +7811,28 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: SuccessResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the season_videostream_disable_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.season_videostream_disable_with_http_info(
                 organization_id,
                 season_id,
                 sport,
                 fixture_videosteam_post_body,
                 external,
@@ -7849,15 +7873,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Disable season live video streams for all fixtures  # noqa: E501
 
         Disable live video stream for all fixtures in season  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.season_videostream_disable_with_http_info(organization_id, season_id, sport, fixture_videosteam_post_body, external, fields, hide_null, include, async_req=True)
@@ -7877,21 +7901,22 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -7966,15 +7991,15 @@
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params["fixture_videosteam_post_body"]:
+        if _params["fixture_videosteam_post_body"] is not None:
             _body_params = _params["fixture_videosteam_post_body"]
 
         # set the HTTP header `Accept`
         _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501
 
         # set the HTTP header `Content-Type`
         _content_types_list = _params.get(
@@ -8065,28 +8090,28 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: SuccessResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the season_videostream_enable_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.season_videostream_enable_with_http_info(
                 organization_id,
                 season_id,
                 sport,
                 fixture_videosteam_post_body,
                 external,
@@ -8127,15 +8152,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Enable season live video streams for all fixtures  # noqa: E501
 
         Enable live video stream for all fixtures in season  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.season_videostream_enable_with_http_info(organization_id, season_id, sport, fixture_videosteam_post_body, external, fields, hide_null, include, async_req=True)
@@ -8155,21 +8180,22 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -8244,15 +8270,15 @@
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params["fixture_videosteam_post_body"]:
+        if _params["fixture_videosteam_post_body"] is not None:
             _body_params = _params["fixture_videosteam_post_body"]
 
         # set the HTTP header `Accept`
         _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501
 
         # set the HTTP header `Content-Type`
         _content_types_list = _params.get(
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/api/images_api.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/api/images_api.py`

 * *Files 2% similar despite different names*

```diff
@@ -8,23 +8,36 @@
     The version of the OpenAPI document: v1
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the file manually.
 """
 
 
+import io
 import logging
 import re  # noqa: F401
+import warnings
 from datetime import datetime
-from typing import Optional
+from typing import Optional, Union
 
-from pydantic import Field, StrictBool, StrictInt, StrictStr, ValidationError, conint, constr, validate_arguments
+from pydantic import (
+    Field,
+    StrictBool,
+    StrictBytes,
+    StrictInt,
+    StrictStr,
+    ValidationError,
+    conint,
+    constr,
+    validate_arguments,
+)
 from typing_extensions import Annotated
 
 from atriumsports.datacore.openapi.api_client import ApiClient
+from atriumsports.datacore.openapi.api_response import ApiResponse
 from atriumsports.datacore.openapi.exceptions import ApiTypeError, ApiValueError  # noqa: F401
 from atriumsports.datacore.openapi.models.images_post_body import ImagesPostBody
 from atriumsports.datacore.openapi.models.images_put_body import ImagesPutBody
 from atriumsports.datacore.openapi.models.images_response import ImagesResponse
 
 logger = logging.getLogger("openapi")
 
@@ -102,28 +115,28 @@
         :type force_delete: bool
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: ImagesResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the images_delete_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.images_delete_with_http_info(
                 image_id, organization_id, sport, external, fields, force_delete, hide_null, include, **kwargs
             )  # noqa: E501
         except Exception as e:
             logger.error("Exception when calling ImagesApi->images_delete: %s\n" % e)
             raise
@@ -161,15 +174,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Delete an image  # noqa: E501
 
         Delete an image  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.images_delete_with_http_info(image_id, organization_id, sport, external, fields, force_delete, hide_null, include, async_req=True)
@@ -189,21 +202,22 @@
         :type force_delete: bool
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -381,28 +395,28 @@
         :type include: str
         :param limit: The maximum number of records to return. See [Pagination](#section/Introduction/Pagination) for more information.
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: ImagesResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the images_detail_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.images_detail_with_http_info(
                 image_id, organization_id, sport, external, fields, hide_null, include, limit, offset, **kwargs
             )  # noqa: E501
         except Exception as e:
             logger.error("Exception when calling ImagesApi->images_detail: %s\n" % e)
             raise
@@ -446,15 +460,15 @@
         offset: Annotated[
             Optional[StrictInt],
             Field(
                 description="The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Get an image  # noqa: E501
 
         Return detailed information about a specific image  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.images_detail_with_http_info(image_id, organization_id, sport, external, fields, hide_null, include, limit, offset, async_req=True)
@@ -476,21 +490,22 @@
         :type include: str
         :param limit: The maximum number of records to return. See [Pagination](#section/Introduction/Pagination) for more information.
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -624,15 +639,15 @@
             ),
         ],
         organization_id: Annotated[
             constr(strict=True, max_length=5, min_length=5),
             Field(..., description="The unique identifier of the organization"),
         ],
         sport: Annotated[StrictStr, Field(..., description="Sport name")],
-        body: StrictStr,
+        body: Union[StrictBytes, StrictStr],
         external: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of fields that will instead be interpreted as an externalId. See [External Ids](#section/Introduction/External-Ids) for more information."
             ),
         ] = None,
         fields: Annotated[
@@ -679,28 +694,28 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: ImagesResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the images_insert_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.images_insert_with_http_info(
                 base_id,
                 base_type,
                 image_type,
                 organization_id,
                 sport,
@@ -736,15 +751,15 @@
             ),
         ],
         organization_id: Annotated[
             constr(strict=True, max_length=5, min_length=5),
             Field(..., description="The unique identifier of the organization"),
         ],
         sport: Annotated[StrictStr, Field(..., description="Sport name")],
-        body: StrictStr,
+        body: Union[StrictBytes, StrictStr],
         external: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of fields that will instead be interpreted as an externalId. See [External Ids](#section/Introduction/External-Ids) for more information."
             ),
         ] = None,
         fields: Annotated[
@@ -759,15 +774,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Upload a new image  # noqa: E501
 
          You can upload the image in one of two ways:  - A binary blob in the POST data - A 'file' field in a multipart/form-data   **Binary Blob**  Upload the image by supplying the image as binary in the POST data.  The HTTP request would look like      POST /v1/basketball/o/b1a23/images/for/PERSON/81814d2c-d640-11e8-9f8b-f2801f1b9fd1/PERSON_HEAD     Host: example.com     Authorization: Bearer some-token     Content-Length: 808     Content-Type: image/png      [file content goes there]   **Multi-part form**  Upload the image by supplying it as a 'file' field in a multipart form. The file field must be called `filedata` and the content-type must be set to `multipart/form-data`  **Note**: By uploading the image you confirm that you have the legal right to do so and to allow this image to be distributed.   # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.images_insert_with_http_info(base_id, base_type, image_type, organization_id, sport, body, external, fields, hide_null, include, async_req=True)
@@ -791,21 +806,22 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -886,16 +902,21 @@
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params["body"]:
+        if _params["body"] is not None:
             _body_params = _params["body"]
+            # convert to byte array if the input is a file name (str)
+            if isinstance(_body_params, str):
+                with io.open(_body_params, "rb") as _fp:
+                    _body_params_from_file = _fp.read()
+                _body_params = _body_params_from_file
 
         # set the HTTP header `Accept`
         _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501
 
         # set the HTTP header `Content-Type`
         _content_types_list = _params.get(
             "_content_type", self.api_client.select_header_content_type(["application/octet-stream"])
@@ -1005,28 +1026,28 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: ImagesResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the images_insert_from_url_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.images_insert_from_url_with_http_info(
                 base_id,
                 base_type,
                 image_type,
                 organization_id,
                 sport,
@@ -1085,15 +1106,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Upload a new image from a URL  # noqa: E501
 
         This method allows a new image to uploaded by providing a URL where the image can be downloaded from.  **Note**: By uploading the image you confirm that you have the legal right to do so and to allow this image to be distributed.   # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.images_insert_from_url_with_http_info(base_id, base_type, image_type, organization_id, sport, images_post_body, external, fields, hide_null, include, async_req=True)
@@ -1117,21 +1138,22 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1212,15 +1234,15 @@
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params["images_post_body"]:
+        if _params["images_post_body"] is not None:
             _body_params = _params["images_post_body"]
 
         # set the HTTP header `Accept`
         _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501
 
         # set the HTTP header `Content-Type`
         _content_types_list = _params.get(
@@ -1266,15 +1288,15 @@
             ),
         ],
         organization_id: Annotated[
             constr(strict=True, max_length=5, min_length=5),
             Field(..., description="The unique identifier of the organization"),
         ],
         sport: Annotated[StrictStr, Field(..., description="Sport name")],
-        body: StrictStr,
+        body: Union[StrictBytes, StrictStr],
         base_type: Annotated[
             Optional[constr(strict=True, max_length=100)],
             Field(
                 description="Media Base Type >- `COMPETITION` Competition >- `CONFERENCE` Conference >- `DIVISION` Division >- `ENTITY` Entity >- `ENTITYGROUP` Entity Group >- `LEAGUE` League >- `ORGANIZATION` Organization >- `PERSON` Person >- `SEASON` Season "
             ),
         ] = None,
         external: Annotated[
@@ -1325,28 +1347,28 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: ImagesResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the images_insert_organization_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.images_insert_organization_with_http_info(
                 image_type, organization_id, sport, body, base_type, external, fields, hide_null, include, **kwargs
             )  # noqa: E501
         except Exception as e:
             logger.error("Exception when calling ImagesApi->images_insert_organization: %s\n" % e)
             raise
@@ -1362,15 +1384,15 @@
             ),
         ],
         organization_id: Annotated[
             constr(strict=True, max_length=5, min_length=5),
             Field(..., description="The unique identifier of the organization"),
         ],
         sport: Annotated[StrictStr, Field(..., description="Sport name")],
-        body: StrictStr,
+        body: Union[StrictBytes, StrictStr],
         base_type: Annotated[
             Optional[constr(strict=True, max_length=100)],
             Field(
                 description="Media Base Type >- `COMPETITION` Competition >- `CONFERENCE` Conference >- `DIVISION` Division >- `ENTITY` Entity >- `ENTITYGROUP` Entity Group >- `LEAGUE` League >- `ORGANIZATION` Organization >- `PERSON` Person >- `SEASON` Season "
             ),
         ] = None,
         external: Annotated[
@@ -1391,15 +1413,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Upload a new image for the organization  # noqa: E501
 
         Add a new image for the organization. You can upload the image in one of two ways:  - A binary blob in the POST data - A 'file' field in a multipart/form-data   **Binary Blob**  Upload the image by supplying the image as binary in the POST data.  The HTTP request would look like      POST /v1/basketball/o/b1a23/images/for/PERSON/81814d2c-d640-11e8-9f8b-f2801f1b9fd1/PERSON_HEAD     Host: example.com     Authorization: Bearer some-token     Content-Length: 808     Content-Type: image/png      [file content goes there]   **Multi-part form**  Upload the image by supplying it as a 'file' field in a multipart form. The file field must be called `filedata` and the content-type must be set to `multipart/form-data`  **Note**: By uploading the image you confirm that you have the legal right to do so and to allow this image to be distributed.   # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.images_insert_organization_with_http_info(image_type, organization_id, sport, body, base_type, external, fields, hide_null, include, async_req=True)
@@ -1421,21 +1443,22 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1493,15 +1516,15 @@
 
         if _params["sport"]:
             _path_params["sport"] = _params["sport"]
 
         # process the query parameters
         _query_params = []
         if _params.get("base_type") is not None:  # noqa: E501
-            _query_params.append(("baseType", _params["base_type"]))
+            _query_params.append(("baseType", _params["base_type"].value))
 
         if _params.get("external") is not None:  # noqa: E501
             _query_params.append(("external", _params["external"]))
 
         if _params.get("fields") is not None:  # noqa: E501
             _query_params.append(("fields", _params["fields"]))
 
@@ -1514,16 +1537,21 @@
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params["body"]:
+        if _params["body"] is not None:
             _body_params = _params["body"]
+            # convert to byte array if the input is a file name (str)
+            if isinstance(_body_params, str):
+                with io.open(_body_params, "rb") as _fp:
+                    _body_params_from_file = _fp.read()
+                _body_params = _body_params_from_file
 
         # set the HTTP header `Accept`
         _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501
 
         # set the HTTP header `Content-Type`
         _content_types_list = _params.get(
             "_content_type", self.api_client.select_header_content_type(["application/octet-stream"])
@@ -1627,28 +1655,28 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: ImagesResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the images_insert_organization_from_url_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.images_insert_organization_from_url_with_http_info(
                 image_type,
                 organization_id,
                 sport,
                 images_post_body,
                 base_type,
@@ -1702,15 +1730,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Upload a new image for the organization from a URL  # noqa: E501
 
         This method allows a new image to be uploaded against the organization type by providing a URL where the image can be downloaded from.  **Note**: By uploading the image you confirm that you have the legal right to do so and to allow this image to be distributed.   # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.images_insert_organization_from_url_with_http_info(image_type, organization_id, sport, images_post_body, base_type, external, fields, hide_null, include, async_req=True)
@@ -1732,21 +1760,22 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1804,15 +1833,15 @@
 
         if _params["sport"]:
             _path_params["sport"] = _params["sport"]
 
         # process the query parameters
         _query_params = []
         if _params.get("base_type") is not None:  # noqa: E501
-            _query_params.append(("baseType", _params["base_type"]))
+            _query_params.append(("baseType", _params["base_type"].value))
 
         if _params.get("external") is not None:  # noqa: E501
             _query_params.append(("external", _params["external"]))
 
         if _params.get("fields") is not None:  # noqa: E501
             _query_params.append(("fields", _params["fields"]))
 
@@ -1825,15 +1854,15 @@
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params["images_post_body"]:
+        if _params["images_post_body"] is not None:
             _body_params = _params["images_post_body"]
 
         # set the HTTP header `Accept`
         _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501
 
         # set the HTTP header `Content-Type`
         _content_types_list = _params.get(
@@ -1900,15 +1929,15 @@
             constr(strict=True, max_length=100),
             Field(
                 ...,
                 description="Media Secondary Type >- `COMPETITION` Competition >- `CONFERENCE` Conference >- `DIVISION` Division >- `ENTITY` Entity >- `ENTITYGROUP` Entity Group >- `LEAGUE` League >- `ORGANIZATION` Organization >- `SEASON` Season ",
             ),
         ],
         sport: Annotated[StrictStr, Field(..., description="Sport name")],
-        body: StrictStr,
+        body: Union[StrictBytes, StrictStr],
         external: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of fields that will instead be interpreted as an externalId. See [External Ids](#section/Introduction/External-Ids) for more information."
             ),
         ] = None,
         fields: Annotated[
@@ -1959,28 +1988,28 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: ImagesResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the images_insert_secondary_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.images_insert_secondary_with_http_info(
                 base_id,
                 base_type,
                 image_type,
                 organization_id,
                 secondary_id,
@@ -2029,15 +2058,15 @@
             constr(strict=True, max_length=100),
             Field(
                 ...,
                 description="Media Secondary Type >- `COMPETITION` Competition >- `CONFERENCE` Conference >- `DIVISION` Division >- `ENTITY` Entity >- `ENTITYGROUP` Entity Group >- `LEAGUE` League >- `ORGANIZATION` Organization >- `SEASON` Season ",
             ),
         ],
         sport: Annotated[StrictStr, Field(..., description="Sport name")],
-        body: StrictStr,
+        body: Union[StrictBytes, StrictStr],
         external: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of fields that will instead be interpreted as an externalId. See [External Ids](#section/Introduction/External-Ids) for more information."
             ),
         ] = None,
         fields: Annotated[
@@ -2052,15 +2081,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Upload a new image in a secondary type  # noqa: E501
 
         Add a new image for a type in a secondary type. You can upload the image in one of two ways:  - A binary blob in the POST data - A 'file' field in a multipart/form-data   **Binary Blob**  Upload the image by supplying the image as binary in the POST data.  The HTTP request would look like      POST /v1/basketball/o/b1a23/images/for/PERSON/81814d2c-d640-11e8-9f8b-f2801f1b9fd1/PERSON_HEAD     Host: example.com     Authorization: Bearer some-token     Content-Length: 808     Content-Type: image/png      [file content goes there]   **Multi-part form**  Upload the image by supplying it as a 'file' field in a multipart form. The file field must be called `filedata` and the content-type must be set to `multipart/form-data`  **Note**: By uploading the image you confirm that you have the legal right to do so and to allow this image to be distributed.   # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.images_insert_secondary_with_http_info(base_id, base_type, image_type, organization_id, secondary_id, secondary_type, sport, body, external, fields, hide_null, include, async_req=True)
@@ -2088,21 +2117,22 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -2193,16 +2223,21 @@
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params["body"]:
+        if _params["body"] is not None:
             _body_params = _params["body"]
+            # convert to byte array if the input is a file name (str)
+            if isinstance(_body_params, str):
+                with io.open(_body_params, "rb") as _fp:
+                    _body_params_from_file = _fp.read()
+                _body_params = _body_params_from_file
 
         # set the HTTP header `Accept`
         _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501
 
         # set the HTTP header `Content-Type`
         _content_types_list = _params.get(
             "_content_type", self.api_client.select_header_content_type(["application/octet-stream"])
@@ -2327,28 +2362,28 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: ImagesResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the images_insert_secondary_from_url_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.images_insert_secondary_from_url_with_http_info(
                 base_id,
                 base_type,
                 image_type,
                 organization_id,
                 secondary_id,
@@ -2420,15 +2455,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Upload a new image in a secondary type from a URL  # noqa: E501
 
         This method allows a new image to be uploaded against a secondary type by providing a URL where the image can be downloaded from.  **Note**: By uploading the image you confirm that you have the legal right to do so and to allow this image to be distributed.   # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.images_insert_secondary_from_url_with_http_info(base_id, base_type, image_type, organization_id, secondary_id, secondary_type, sport, images_post_body, external, fields, hide_null, include, async_req=True)
@@ -2456,21 +2491,22 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -2561,15 +2597,15 @@
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params["images_post_body"]:
+        if _params["images_post_body"] is not None:
             _body_params = _params["images_post_body"]
 
         # set the HTTP header `Accept`
         _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501
 
         # set the HTTP header `Content-Type`
         _content_types_list = _params.get(
@@ -2703,28 +2739,28 @@
         :type offset: int
         :param rating: Media Rating >- `HIGH` High >- `LOW` Low >- `MEDIUM` Medium >- `UNKNOWN` Uknown
         :type rating: str
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: ImagesResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the images_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.images_list_with_http_info(
                 base_type,
                 organization_id,
                 sport,
                 added,
                 external,
@@ -2803,15 +2839,15 @@
             Optional[constr(strict=True, max_length=100)],
             Field(description="Media Rating >- `HIGH` High >- `LOW` Low >- `MEDIUM` Medium >- `UNKNOWN` Uknown "),
         ] = None,
         updated: Annotated[
             Optional[datetime], Field(description="Record was modified after this date/time. In UTC.")
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Get a list of images  # noqa: E501
 
         Return a list of images for the type  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.images_list_with_http_info(base_type, organization_id, sport, added, external, fields, hide_null, image_type, include, limit, offset, rating, updated, async_req=True)
@@ -2841,21 +2877,22 @@
         :type offset: int
         :param rating: Media Rating >- `HIGH` High >- `LOW` Low >- `MEDIUM` Medium >- `UNKNOWN` Uknown
         :type rating: str
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -2932,27 +2969,27 @@
         if _params.get("fields") is not None:  # noqa: E501
             _query_params.append(("fields", _params["fields"]))
 
         if _params.get("hide_null") is not None:  # noqa: E501
             _query_params.append(("hideNull", _params["hide_null"]))
 
         if _params.get("image_type") is not None:  # noqa: E501
-            _query_params.append(("imageType", _params["image_type"]))
+            _query_params.append(("imageType", _params["image_type"].value))
 
         if _params.get("include") is not None:  # noqa: E501
             _query_params.append(("include", _params["include"]))
 
         if _params.get("limit") is not None:  # noqa: E501
             _query_params.append(("limit", _params["limit"]))
 
         if _params.get("offset") is not None:  # noqa: E501
             _query_params.append(("offset", _params["offset"]))
 
         if _params.get("rating") is not None:  # noqa: E501
-            _query_params.append(("rating", _params["rating"]))
+            _query_params.append(("rating", _params["rating"].value))
 
         if _params.get("updated") is not None:  # noqa: E501
             if isinstance(_params["updated"], datetime):
                 _query_params.append(
                     ("updated", _params["updated"].strftime(self.api_client.configuration.datetime_format))
                 )
             else:
@@ -3098,28 +3135,28 @@
         :type offset: int
         :param rating: Media Rating >- `HIGH` High >- `LOW` Low >- `MEDIUM` Medium >- `UNKNOWN` Uknown
         :type rating: str
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: ImagesResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the images_list_id_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.images_list_id_with_http_info(
                 base_id,
                 base_type,
                 organization_id,
                 sport,
                 added,
@@ -3202,15 +3239,15 @@
             Optional[constr(strict=True, max_length=100)],
             Field(description="Media Rating >- `HIGH` High >- `LOW` Low >- `MEDIUM` Medium >- `UNKNOWN` Uknown "),
         ] = None,
         updated: Annotated[
             Optional[datetime], Field(description="Record was modified after this date/time. In UTC.")
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Get a list of images for a specific type and id  # noqa: E501
 
         Return a list of images for the type and id  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.images_list_id_with_http_info(base_id, base_type, organization_id, sport, added, external, fields, hide_null, image_type, include, limit, offset, rating, updated, async_req=True)
@@ -3242,21 +3279,22 @@
         :type offset: int
         :param rating: Media Rating >- `HIGH` High >- `LOW` Low >- `MEDIUM` Medium >- `UNKNOWN` Uknown
         :type rating: str
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -3337,27 +3375,27 @@
         if _params.get("fields") is not None:  # noqa: E501
             _query_params.append(("fields", _params["fields"]))
 
         if _params.get("hide_null") is not None:  # noqa: E501
             _query_params.append(("hideNull", _params["hide_null"]))
 
         if _params.get("image_type") is not None:  # noqa: E501
-            _query_params.append(("imageType", _params["image_type"]))
+            _query_params.append(("imageType", _params["image_type"].value))
 
         if _params.get("include") is not None:  # noqa: E501
             _query_params.append(("include", _params["include"]))
 
         if _params.get("limit") is not None:  # noqa: E501
             _query_params.append(("limit", _params["limit"]))
 
         if _params.get("offset") is not None:  # noqa: E501
             _query_params.append(("offset", _params["offset"]))
 
         if _params.get("rating") is not None:  # noqa: E501
-            _query_params.append(("rating", _params["rating"]))
+            _query_params.append(("rating", _params["rating"].value))
 
         if _params.get("updated") is not None:  # noqa: E501
             if isinstance(_params["updated"], datetime):
                 _query_params.append(
                     ("updated", _params["updated"].strftime(self.api_client.configuration.datetime_format))
                 )
             else:
@@ -3518,28 +3556,28 @@
         :type offset: int
         :param rating: Media Rating >- `HIGH` High >- `LOW` Low >- `MEDIUM` Medium >- `UNKNOWN` Uknown
         :type rating: str
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: ImagesResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the images_list_id_secondary_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.images_list_id_secondary_with_http_info(
                 base_id,
                 base_type,
                 organization_id,
                 secondary_id,
                 secondary_type,
@@ -3635,15 +3673,15 @@
             Optional[constr(strict=True, max_length=100)],
             Field(description="Media Rating >- `HIGH` High >- `LOW` Low >- `MEDIUM` Medium >- `UNKNOWN` Uknown "),
         ] = None,
         updated: Annotated[
             Optional[datetime], Field(description="Record was modified after this date/time. In UTC.")
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Get a list of images for a specific base and secondary id  # noqa: E501
 
         Return a list of images for the base id for a secondary id  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.images_list_id_secondary_with_http_info(base_id, base_type, organization_id, secondary_id, secondary_type, sport, added, external, fields, hide_null, image_type, include, limit, offset, rating, updated, async_req=True)
@@ -3679,21 +3717,22 @@
         :type offset: int
         :param rating: Media Rating >- `HIGH` High >- `LOW` Low >- `MEDIUM` Medium >- `UNKNOWN` Uknown
         :type rating: str
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -3784,27 +3823,27 @@
         if _params.get("fields") is not None:  # noqa: E501
             _query_params.append(("fields", _params["fields"]))
 
         if _params.get("hide_null") is not None:  # noqa: E501
             _query_params.append(("hideNull", _params["hide_null"]))
 
         if _params.get("image_type") is not None:  # noqa: E501
-            _query_params.append(("imageType", _params["image_type"]))
+            _query_params.append(("imageType", _params["image_type"].value))
 
         if _params.get("include") is not None:  # noqa: E501
             _query_params.append(("include", _params["include"]))
 
         if _params.get("limit") is not None:  # noqa: E501
             _query_params.append(("limit", _params["limit"]))
 
         if _params.get("offset") is not None:  # noqa: E501
             _query_params.append(("offset", _params["offset"]))
 
         if _params.get("rating") is not None:  # noqa: E501
-            _query_params.append(("rating", _params["rating"]))
+            _query_params.append(("rating", _params["rating"].value))
 
         if _params.get("updated") is not None:  # noqa: E501
             if isinstance(_params["updated"], datetime):
                 _query_params.append(
                     ("updated", _params["updated"].strftime(self.api_client.configuration.datetime_format))
                 )
             else:
@@ -3944,28 +3983,28 @@
         :type offset: int
         :param rating: Media Rating >- `HIGH` High >- `LOW` Low >- `MEDIUM` Medium >- `UNKNOWN` Uknown
         :type rating: str
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: ImagesResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the images_list_organization_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.images_list_organization_with_http_info(
                 organization_id,
                 sport,
                 added,
                 base_type,
                 external,
@@ -4043,15 +4082,15 @@
             Optional[constr(strict=True, max_length=100)],
             Field(description="Media Rating >- `HIGH` High >- `LOW` Low >- `MEDIUM` Medium >- `UNKNOWN` Uknown "),
         ] = None,
         updated: Annotated[
             Optional[datetime], Field(description="Record was modified after this date/time. In UTC.")
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Get a list of images for the Organization  # noqa: E501
 
         Return a list of images for the Organization  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.images_list_organization_with_http_info(organization_id, sport, added, base_type, external, fields, hide_null, image_type, include, limit, offset, rating, updated, async_req=True)
@@ -4081,21 +4120,22 @@
         :type offset: int
         :param rating: Media Rating >- `HIGH` High >- `LOW` Low >- `MEDIUM` Medium >- `UNKNOWN` Uknown
         :type rating: str
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -4162,39 +4202,39 @@
                 _query_params.append(
                     ("added", _params["added"].strftime(self.api_client.configuration.datetime_format))
                 )
             else:
                 _query_params.append(("added", _params["added"]))
 
         if _params.get("base_type") is not None:  # noqa: E501
-            _query_params.append(("baseType", _params["base_type"]))
+            _query_params.append(("baseType", _params["base_type"].value))
 
         if _params.get("external") is not None:  # noqa: E501
             _query_params.append(("external", _params["external"]))
 
         if _params.get("fields") is not None:  # noqa: E501
             _query_params.append(("fields", _params["fields"]))
 
         if _params.get("hide_null") is not None:  # noqa: E501
             _query_params.append(("hideNull", _params["hide_null"]))
 
         if _params.get("image_type") is not None:  # noqa: E501
-            _query_params.append(("imageType", _params["image_type"]))
+            _query_params.append(("imageType", _params["image_type"].value))
 
         if _params.get("include") is not None:  # noqa: E501
             _query_params.append(("include", _params["include"]))
 
         if _params.get("limit") is not None:  # noqa: E501
             _query_params.append(("limit", _params["limit"]))
 
         if _params.get("offset") is not None:  # noqa: E501
             _query_params.append(("offset", _params["offset"]))
 
         if _params.get("rating") is not None:  # noqa: E501
-            _query_params.append(("rating", _params["rating"]))
+            _query_params.append(("rating", _params["rating"].value))
 
         if _params.get("updated") is not None:  # noqa: E501
             if isinstance(_params["updated"], datetime):
                 _query_params.append(
                     ("updated", _params["updated"].strftime(self.api_client.configuration.datetime_format))
                 )
             else:
@@ -4350,28 +4390,28 @@
         :type offset: int
         :param rating: Media Rating >- `HIGH` High >- `LOW` Low >- `MEDIUM` Medium >- `UNKNOWN` Uknown
         :type rating: str
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: ImagesResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the images_list_secondary_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.images_list_secondary_with_http_info(
                 base_type,
                 organization_id,
                 secondary_id,
                 secondary_type,
                 sport,
@@ -4463,15 +4503,15 @@
             Optional[constr(strict=True, max_length=100)],
             Field(description="Media Rating >- `HIGH` High >- `LOW` Low >- `MEDIUM` Medium >- `UNKNOWN` Uknown "),
         ] = None,
         updated: Annotated[
             Optional[datetime], Field(description="Record was modified after this date/time. In UTC.")
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Get a list of images for a type in a secondary Type  # noqa: E501
 
         Return a list of images assigned to type for a secondary type and Id  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.images_list_secondary_with_http_info(base_type, organization_id, secondary_id, secondary_type, sport, added, external, fields, hide_null, image_type, include, limit, offset, rating, updated, async_req=True)
@@ -4505,21 +4545,22 @@
         :type offset: int
         :param rating: Media Rating >- `HIGH` High >- `LOW` Low >- `MEDIUM` Medium >- `UNKNOWN` Uknown
         :type rating: str
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -4604,27 +4645,27 @@
         if _params.get("fields") is not None:  # noqa: E501
             _query_params.append(("fields", _params["fields"]))
 
         if _params.get("hide_null") is not None:  # noqa: E501
             _query_params.append(("hideNull", _params["hide_null"]))
 
         if _params.get("image_type") is not None:  # noqa: E501
-            _query_params.append(("imageType", _params["image_type"]))
+            _query_params.append(("imageType", _params["image_type"].value))
 
         if _params.get("include") is not None:  # noqa: E501
             _query_params.append(("include", _params["include"]))
 
         if _params.get("limit") is not None:  # noqa: E501
             _query_params.append(("limit", _params["limit"]))
 
         if _params.get("offset") is not None:  # noqa: E501
             _query_params.append(("offset", _params["offset"]))
 
         if _params.get("rating") is not None:  # noqa: E501
-            _query_params.append(("rating", _params["rating"]))
+            _query_params.append(("rating", _params["rating"].value))
 
         if _params.get("updated") is not None:  # noqa: E501
             if isinstance(_params["updated"], datetime):
                 _query_params.append(
                     ("updated", _params["updated"].strftime(self.api_client.configuration.datetime_format))
                 )
             else:
@@ -4722,28 +4763,28 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: ImagesResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the images_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.images_update_with_http_info(
                 image_id, organization_id, sport, images_put_body, external, fields, hide_null, include, **kwargs
             )  # noqa: E501
         except Exception as e:
             logger.error("Exception when calling ImagesApi->images_update: %s\n" % e)
             raise
@@ -4776,15 +4817,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Update the rating for an image  # noqa: E501
 
         Set the rating for an image  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.images_update_with_http_info(image_id, organization_id, sport, images_put_body, external, fields, hide_null, include, async_req=True)
@@ -4804,21 +4845,22 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -4891,15 +4933,15 @@
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params["images_put_body"]:
+        if _params["images_put_body"] is not None:
             _body_params = _params["images_put_body"]
 
         # set the HTTP header `Accept`
         _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501
 
         # set the HTTP header `Content-Type`
         _content_types_list = _params.get(
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/api/leader_criteria_sets_api.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/api/leader_criteria_sets_api.py`

 * *Files 4% similar despite different names*

```diff
@@ -8,22 +8,25 @@
     The version of the OpenAPI document: v1
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the file manually.
 """
 
 
+import io
 import logging
 import re  # noqa: F401
+import warnings
 from typing import Optional
 
 from pydantic import Field, StrictBool, StrictInt, StrictStr, ValidationError, conint, constr, validate_arguments
 from typing_extensions import Annotated
 
 from atriumsports.datacore.openapi.api_client import ApiClient
+from atriumsports.datacore.openapi.api_response import ApiResponse
 from atriumsports.datacore.openapi.exceptions import ApiTypeError, ApiValueError  # noqa: F401
 from atriumsports.datacore.openapi.models.leader_criteria_post_body import LeaderCriteriaPostBody
 from atriumsports.datacore.openapi.models.leader_criteria_put_body import LeaderCriteriaPutBody
 from atriumsports.datacore.openapi.models.leader_criteria_response import LeaderCriteriaResponse
 
 logger = logging.getLogger("openapi")
 
@@ -103,28 +106,28 @@
         :type force_delete: bool
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: LeaderCriteriaResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the leader_criteria_delete_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.leader_criteria_delete_with_http_info(
                 leader_criteria_id, organization_id, sport, external, fields, force_delete, hide_null, include, **kwargs
             )  # noqa: E501
         except Exception as e:
             logger.error("Exception when calling LeaderCriteriaSetsApi->leader_criteria_delete: %s\n" % e)
             raise
@@ -164,15 +167,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Delete leader criteria  # noqa: E501
 
         Delete a specific leader criterion  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.leader_criteria_delete_with_http_info(leader_criteria_id, organization_id, sport, external, fields, force_delete, hide_null, include, async_req=True)
@@ -192,21 +195,22 @@
         :type force_delete: bool
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -386,28 +390,28 @@
         :type include: str
         :param limit: The maximum number of records to return. See [Pagination](#section/Introduction/Pagination) for more information.
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: LeaderCriteriaResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the leader_criteria_detail_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.leader_criteria_detail_with_http_info(
                 leader_criteria_id,
                 organization_id,
                 sport,
                 external,
                 fields,
@@ -462,15 +466,15 @@
         offset: Annotated[
             Optional[StrictInt],
             Field(
                 description="The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Get a leader criterion  # noqa: E501
 
         Return detailed information about a specific leader criterion  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.leader_criteria_detail_with_http_info(leader_criteria_id, organization_id, sport, external, fields, hide_null, include, limit, offset, async_req=True)
@@ -492,21 +496,22 @@
         :type include: str
         :param limit: The maximum number of records to return. See [Pagination](#section/Introduction/Pagination) for more information.
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -672,28 +677,28 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: LeaderCriteriaResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the leader_criteria_insert_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.leader_criteria_insert_with_http_info(
                 organization_id, sport, leader_criteria_post_body, external, fields, hide_null, include, **kwargs
             )  # noqa: E501
         except Exception as e:
             logger.error("Exception when calling LeaderCriteriaSetsApi->leader_criteria_insert: %s\n" % e)
             raise
@@ -725,15 +730,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Create a new leader criterion  # noqa: E501
 
         Insert a new leader criterion  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.leader_criteria_insert_with_http_info(organization_id, sport, leader_criteria_post_body, external, fields, hide_null, include, async_req=True)
@@ -751,21 +756,22 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -834,15 +840,15 @@
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params["leader_criteria_post_body"]:
+        if _params["leader_criteria_post_body"] is not None:
             _body_params = _params["leader_criteria_post_body"]
 
         # set the HTTP header `Accept`
         _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501
 
         # set the HTTP header `Content-Type`
         _content_types_list = _params.get(
@@ -954,28 +960,28 @@
         :type name: str
         :param name_contains: Fields that allow a 'Contains' query string parameter search for words separated by a space, matching characters left to right. Example: nameFullLatin=David Johnson nameContains=Dav will match nameContains=John will match nameContains=son will not match
         :type name_contains: str
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: LeaderCriteriaResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the leader_criteria_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.leader_criteria_list_with_http_info(
                 organization_id,
                 sport,
                 external,
                 fields,
                 hide_null,
@@ -1035,15 +1041,15 @@
         offset: Annotated[
             Optional[StrictInt],
             Field(
                 description="The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Get a list of leader criteria sets  # noqa: E501
 
         Return a list of leader criteria sets  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.leader_criteria_list_with_http_info(organization_id, sport, external, fields, hide_null, include, limit, name, name_contains, offset, async_req=True)
@@ -1067,21 +1073,22 @@
         :type name: str
         :param name_contains: Fields that allow a 'Contains' query string parameter search for words separated by a space, matching characters left to right. Example: nameFullLatin=David Johnson nameContains=Dav will match nameContains=John will match nameContains=son will not match
         :type name_contains: str
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1256,28 +1263,28 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: LeaderCriteriaResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the leader_criteria_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.leader_criteria_update_with_http_info(
                 leader_criteria_id,
                 organization_id,
                 sport,
                 leader_criteria_put_body,
                 external,
@@ -1320,15 +1327,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Update a leader criteria  # noqa: E501
 
         Update a leader criterion  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.leader_criteria_update_with_http_info(leader_criteria_id, organization_id, sport, leader_criteria_put_body, external, fields, hide_null, include, async_req=True)
@@ -1348,21 +1355,22 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1435,15 +1443,15 @@
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params["leader_criteria_put_body"]:
+        if _params["leader_criteria_put_body"] is not None:
             _body_params = _params["leader_criteria_put_body"]
 
         # set the HTTP header `Accept`
         _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501
 
         # set the HTTP header `Content-Type`
         _content_types_list = _params.get(
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/api/leader_qualifiers_api.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/api/leader_qualifiers_api.py`

 * *Files 2% similar despite different names*

```diff
@@ -8,22 +8,25 @@
     The version of the OpenAPI document: v1
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the file manually.
 """
 
 
+import io
 import logging
 import re  # noqa: F401
+import warnings
 from typing import Optional
 
 from pydantic import Field, StrictBool, StrictInt, StrictStr, ValidationError, conint, constr, validate_arguments
 from typing_extensions import Annotated
 
 from atriumsports.datacore.openapi.api_client import ApiClient
+from atriumsports.datacore.openapi.api_response import ApiResponse
 from atriumsports.datacore.openapi.exceptions import ApiTypeError, ApiValueError  # noqa: F401
 from atriumsports.datacore.openapi.models.leader_qualifier_post_body import LeaderQualifierPostBody
 from atriumsports.datacore.openapi.models.leader_qualifier_put_body import LeaderQualifierPutBody
 from atriumsports.datacore.openapi.models.leader_qualifiers_response import LeaderQualifiersResponse
 
 logger = logging.getLogger("openapi")
 
@@ -106,28 +109,28 @@
         :type force_delete: bool
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: LeaderQualifiersResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the leader_qualifiers_delete_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.leader_qualifiers_delete_with_http_info(
                 leader_criteria_id,
                 organization_id,
                 qualifier_id,
                 sport,
                 external,
@@ -177,15 +180,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Delete leader qualifier  # noqa: E501
 
         Delete a specific leader qualifier  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.leader_qualifiers_delete_with_http_info(leader_criteria_id, organization_id, qualifier_id, sport, external, fields, force_delete, hide_null, include, async_req=True)
@@ -207,21 +210,22 @@
         :type force_delete: bool
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -410,28 +414,28 @@
         :type include: str
         :param limit: The maximum number of records to return. See [Pagination](#section/Introduction/Pagination) for more information.
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: LeaderQualifiersResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the leader_qualifiers_detail_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.leader_qualifiers_detail_with_http_info(
                 leader_criteria_id,
                 organization_id,
                 qualifier_id,
                 sport,
                 external,
@@ -488,15 +492,15 @@
         offset: Annotated[
             Optional[StrictInt],
             Field(
                 description="The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Get a specific leader qualifier  # noqa: E501
 
         Return detailed information about a specific leader qualifier  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.leader_qualifiers_detail_with_http_info(leader_criteria_id, organization_id, qualifier_id, sport, external, fields, hide_null, include, limit, offset, async_req=True)
@@ -520,21 +524,22 @@
         :type include: str
         :param limit: The maximum number of records to return. See [Pagination](#section/Introduction/Pagination) for more information.
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -711,28 +716,28 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: LeaderQualifiersResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the leader_qualifiers_insert_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.leader_qualifiers_insert_with_http_info(
                 leader_criteria_id,
                 organization_id,
                 sport,
                 leader_qualifier_post_body,
                 external,
@@ -775,15 +780,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Create a new leader qualifier in a criteria set  # noqa: E501
 
         Insert a new leader qualifier  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.leader_qualifiers_insert_with_http_info(leader_criteria_id, organization_id, sport, leader_qualifier_post_body, external, fields, hide_null, include, async_req=True)
@@ -803,21 +808,22 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -892,15 +898,15 @@
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params["leader_qualifier_post_body"]:
+        if _params["leader_qualifier_post_body"] is not None:
             _body_params = _params["leader_qualifier_post_body"]
 
         # set the HTTP header `Accept`
         _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501
 
         # set the HTTP header `Content-Type`
         _content_types_list = _params.get(
@@ -1011,28 +1017,28 @@
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param statistic_field: The name of the statistic
         :type statistic_field: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: LeaderQualifiersResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the leader_qualifiers_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.leader_qualifiers_list_with_http_info(
                 leader_criteria_id,
                 organization_id,
                 sport,
                 external,
                 fields,
@@ -1091,15 +1097,15 @@
                 description="The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information."
             ),
         ] = None,
         statistic_field: Annotated[
             Optional[constr(strict=True, max_length=50)], Field(description="The name of the statistic")
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Get a list of leader qualifiers for a criteria set  # noqa: E501
 
         Return a list of leader qualifiers  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.leader_qualifiers_list_with_http_info(leader_criteria_id, organization_id, sport, external, fields, hide_null, include, limit, offset, statistic_field, async_req=True)
@@ -1123,21 +1129,22 @@
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param statistic_field: The name of the statistic
         :type statistic_field: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1315,28 +1322,28 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: LeaderQualifiersResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the leader_qualifiers_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.leader_qualifiers_update_with_http_info(
                 leader_criteria_id,
                 organization_id,
                 qualifier_id,
                 sport,
                 leader_qualifier_put_body,
@@ -1381,15 +1388,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Update a leader qualifier  # noqa: E501
 
         Updates a specific leader qualifier  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.leader_qualifiers_update_with_http_info(leader_criteria_id, organization_id, qualifier_id, sport, leader_qualifier_put_body, external, fields, hide_null, include, async_req=True)
@@ -1411,21 +1418,22 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1504,15 +1512,15 @@
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params["leader_qualifier_put_body"]:
+        if _params["leader_qualifier_put_body"] is not None:
             _body_params = _params["leader_qualifier_put_body"]
 
         # set the HTTP header `Accept`
         _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501
 
         # set the HTTP header `Content-Type`
         _content_types_list = _params.get(
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/api/leagues_api.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/api/leagues_api.py`

 * *Files 4% similar despite different names*

```diff
@@ -8,23 +8,26 @@
     The version of the OpenAPI document: v1
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the file manually.
 """
 
 
+import io
 import logging
 import re  # noqa: F401
+import warnings
 from datetime import datetime
 from typing import Optional
 
 from pydantic import Field, StrictBool, StrictInt, StrictStr, ValidationError, conint, constr, validate_arguments
 from typing_extensions import Annotated
 
 from atriumsports.datacore.openapi.api_client import ApiClient
+from atriumsports.datacore.openapi.api_response import ApiResponse
 from atriumsports.datacore.openapi.exceptions import ApiTypeError, ApiValueError  # noqa: F401
 from atriumsports.datacore.openapi.models.league_post_body import LeaguePostBody
 from atriumsports.datacore.openapi.models.league_put_body import LeaguePutBody
 from atriumsports.datacore.openapi.models.leagues_response import LeaguesResponse
 
 logger = logging.getLogger("openapi")
 
@@ -102,28 +105,28 @@
         :type force_delete: bool
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: LeaguesResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the league_delete_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.league_delete_with_http_info(
                 league_id, organization_id, sport, external, fields, force_delete, hide_null, include, **kwargs
             )  # noqa: E501
         except Exception as e:
             logger.error("Exception when calling LeaguesApi->league_delete: %s\n" % e)
             raise
@@ -161,15 +164,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Delete a league  # noqa: E501
 
         Delete a specific league  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.league_delete_with_http_info(league_id, organization_id, sport, external, fields, force_delete, hide_null, include, async_req=True)
@@ -189,21 +192,22 @@
         :type force_delete: bool
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -381,28 +385,28 @@
         :type include: str
         :param limit: The maximum number of records to return. See [Pagination](#section/Introduction/Pagination) for more information.
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: LeaguesResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the league_detail_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.league_detail_with_http_info(
                 league_id, organization_id, sport, external, fields, hide_null, include, limit, offset, **kwargs
             )  # noqa: E501
         except Exception as e:
             logger.error("Exception when calling LeaguesApi->league_detail: %s\n" % e)
             raise
@@ -446,15 +450,15 @@
         offset: Annotated[
             Optional[StrictInt],
             Field(
                 description="The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Get a league  # noqa: E501
 
         Return detailed information about a specific league.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.league_detail_with_http_info(league_id, organization_id, sport, external, fields, hide_null, include, limit, offset, async_req=True)
@@ -476,21 +480,22 @@
         :type include: str
         :param limit: The maximum number of records to return. See [Pagination](#section/Introduction/Pagination) for more information.
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -656,28 +661,28 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: LeaguesResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the league_insert_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.league_insert_with_http_info(
                 organization_id, sport, league_post_body, external, fields, hide_null, include, **kwargs
             )  # noqa: E501
         except Exception as e:
             logger.error("Exception when calling LeaguesApi->league_insert: %s\n" % e)
             raise
@@ -709,15 +714,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Create a new league  # noqa: E501
 
         Add a new league to the organization.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.league_insert_with_http_info(organization_id, sport, league_post_body, external, fields, hide_null, include, async_req=True)
@@ -735,21 +740,22 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -810,15 +816,15 @@
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params["league_post_body"]:
+        if _params["league_post_body"] is not None:
             _body_params = _params["league_post_body"]
 
         # set the HTTP header `Accept`
         _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501
 
         # set the HTTP header `Content-Type`
         _content_types_list = _params.get(
@@ -942,28 +948,28 @@
         :type offset: int
         :param region_type: The region type >- `INTERNATIONAL` Multiple countries >- `LOCAL` Local area >- `NATIONAL` One country >- `STATE` One state
         :type region_type: str
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: LeaguesResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the league_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.league_list_with_http_info(
                 organization_id,
                 sport,
                 added,
                 country_code,
                 external,
@@ -1033,15 +1039,15 @@
                 description="The region type >- `INTERNATIONAL` Multiple countries >- `LOCAL` Local area >- `NATIONAL` One country >- `STATE` One state "
             ),
         ] = None,
         updated: Annotated[
             Optional[datetime], Field(description="Record was modified after this date/time. In UTC.")
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Get a list of leagues  # noqa: E501
 
         Return a list of available leagues within the organization.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.league_list_with_http_info(organization_id, sport, added, country_code, external, fields, hide_null, include, limit, offset, region_type, updated, async_req=True)
@@ -1069,21 +1075,22 @@
         :type offset: int
         :param region_type: The region type >- `INTERNATIONAL` Multiple countries >- `LOCAL` Local area >- `NATIONAL` One country >- `STATE` One state
         :type region_type: str
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1168,15 +1175,15 @@
         if _params.get("limit") is not None:  # noqa: E501
             _query_params.append(("limit", _params["limit"]))
 
         if _params.get("offset") is not None:  # noqa: E501
             _query_params.append(("offset", _params["offset"]))
 
         if _params.get("region_type") is not None:  # noqa: E501
-            _query_params.append(("regionType", _params["region_type"]))
+            _query_params.append(("regionType", _params["region_type"].value))
 
         if _params.get("updated") is not None:  # noqa: E501
             if isinstance(_params["updated"], datetime):
                 _query_params.append(
                     ("updated", _params["updated"].strftime(self.api_client.configuration.datetime_format))
                 )
             else:
@@ -1274,28 +1281,28 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: LeaguesResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the league_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.league_update_with_http_info(
                 league_id, organization_id, sport, league_put_body, external, fields, hide_null, include, **kwargs
             )  # noqa: E501
         except Exception as e:
             logger.error("Exception when calling LeaguesApi->league_update: %s\n" % e)
             raise
@@ -1328,15 +1335,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Update a league  # noqa: E501
 
         Change the information of a specific league  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.league_update_with_http_info(league_id, organization_id, sport, league_put_body, external, fields, hide_null, include, async_req=True)
@@ -1356,21 +1363,22 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1443,15 +1451,15 @@
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params["league_put_body"]:
+        if _params["league_put_body"] is not None:
             _body_params = _params["league_put_body"]
 
         # set the HTTP header `Accept`
         _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501
 
         # set the HTTP header `Content-Type`
         _content_types_list = _params.get(
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/api/local_video_endpoints_api.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/api/local_video_endpoints_api.py`

 * *Files 2% similar despite different names*

```diff
@@ -8,23 +8,26 @@
     The version of the OpenAPI document: v1
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the file manually.
 """
 
 
+import io
 import logging
 import re  # noqa: F401
+import warnings
 from datetime import datetime
 from typing import Optional
 
 from pydantic import Field, StrictBool, StrictInt, StrictStr, ValidationError, conint, constr, validate_arguments
 from typing_extensions import Annotated
 
 from atriumsports.datacore.openapi.api_client import ApiClient
+from atriumsports.datacore.openapi.api_response import ApiResponse
 from atriumsports.datacore.openapi.exceptions import ApiTypeError, ApiValueError  # noqa: F401
 from atriumsports.datacore.openapi.models.video_stream_local_post_body import VideoStreamLocalPostBody
 from atriumsports.datacore.openapi.models.video_stream_local_put_body import VideoStreamLocalPutBody
 from atriumsports.datacore.openapi.models.video_stream_local_response import VideoStreamLocalResponse
 
 logger = logging.getLogger("openapi")
 
@@ -102,28 +105,28 @@
         :type force_delete: bool
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: VideoStreamLocalResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the video_stream_local_delete_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.video_stream_local_delete_with_http_info(
                 organization_id, sport, url_id, external, fields, force_delete, hide_null, include, **kwargs
             )  # noqa: E501
         except Exception as e:
             logger.error("Exception when calling LocalVideoEndpointsApi->video_stream_local_delete: %s\n" % e)
             raise
@@ -161,15 +164,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Delete a local streaming video endpoint  # noqa: E501
 
         Delete a specific streamed local video endpoint record  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.video_stream_local_delete_with_http_info(organization_id, sport, url_id, external, fields, force_delete, hide_null, include, async_req=True)
@@ -189,21 +192,22 @@
         :type force_delete: bool
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -383,28 +387,28 @@
         :type include: str
         :param limit: The maximum number of records to return. See [Pagination](#section/Introduction/Pagination) for more information.
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: VideoStreamLocalResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the video_stream_local_detail_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.video_stream_local_detail_with_http_info(
                 organization_id, sport, url_id, external, fields, hide_null, include, limit, offset, **kwargs
             )  # noqa: E501
         except Exception as e:
             logger.error("Exception when calling LocalVideoEndpointsApi->video_stream_local_detail: %s\n" % e)
             raise
@@ -448,15 +452,15 @@
         offset: Annotated[
             Optional[StrictInt],
             Field(
                 description="The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Get local video endpoint details  # noqa: E501
 
         Return detailed information about a specific local streaming endpoint  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.video_stream_local_detail_with_http_info(organization_id, sport, url_id, external, fields, hide_null, include, limit, offset, async_req=True)
@@ -478,21 +482,22 @@
         :type include: str
         :param limit: The maximum number of records to return. See [Pagination](#section/Introduction/Pagination) for more information.
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -663,28 +668,28 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: VideoStreamLocalResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the video_stream_local_insert_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.video_stream_local_insert_with_http_info(
                 fixture_id,
                 organization_id,
                 sport,
                 video_stream_local_post_body,
                 external,
@@ -725,15 +730,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Create a new local streaming endpoint record  # noqa: E501
 
         Insert a new streamed endpoint video record  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.video_stream_local_insert_with_http_info(fixture_id, organization_id, sport, video_stream_local_post_body, external, fields, hide_null, include, async_req=True)
@@ -753,21 +758,22 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -842,15 +848,15 @@
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params["video_stream_local_post_body"]:
+        if _params["video_stream_local_post_body"] is not None:
             _body_params = _params["video_stream_local_post_body"]
 
         # set the HTTP header `Accept`
         _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501
 
         # set the HTTP header `Content-Type`
         _content_types_list = _params.get(
@@ -980,28 +986,28 @@
         :type provider: str
         :param source_number: Unique identifier for the video source
         :type source_number: int
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: VideoStreamLocalResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the video_stream_local_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.video_stream_local_list_with_http_info(
                 fixture_id,
                 organization_id,
                 sport,
                 added,
                 external,
@@ -1075,15 +1081,15 @@
         source_number: Annotated[
             Optional[StrictInt], Field(description="Unique identifier for the video source")
         ] = None,
         updated: Annotated[
             Optional[datetime], Field(description="Record was modified after this date/time. In UTC.")
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Get a list of streaming endpoints  # noqa: E501
 
         Return a list of streaming endpoints  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.video_stream_local_list_with_http_info(fixture_id, organization_id, sport, added, external, fields, format, hide_null, include, limit, offset, provider, source_number, updated, async_req=True)
@@ -1115,21 +1121,22 @@
         :type provider: str
         :param source_number: Unique identifier for the video source
         :type source_number: int
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1206,15 +1213,15 @@
         if _params.get("external") is not None:  # noqa: E501
             _query_params.append(("external", _params["external"]))
 
         if _params.get("fields") is not None:  # noqa: E501
             _query_params.append(("fields", _params["fields"]))
 
         if _params.get("format") is not None:  # noqa: E501
-            _query_params.append(("format", _params["format"]))
+            _query_params.append(("format", _params["format"].value))
 
         if _params.get("hide_null") is not None:  # noqa: E501
             _query_params.append(("hideNull", _params["hide_null"]))
 
         if _params.get("include") is not None:  # noqa: E501
             _query_params.append(("include", _params["include"]))
 
@@ -1330,28 +1337,28 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: VideoStreamLocalResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the video_stream_local_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.video_stream_local_update_with_http_info(
                 organization_id,
                 sport,
                 url_id,
                 video_stream_local_put_body,
                 external,
@@ -1392,15 +1399,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Update a local streaming endpoint  # noqa: E501
 
         Change the information of a specific local streaming endpoint  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.video_stream_local_update_with_http_info(organization_id, sport, url_id, video_stream_local_put_body, external, fields, hide_null, include, async_req=True)
@@ -1420,21 +1427,22 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1509,15 +1517,15 @@
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params["video_stream_local_put_body"]:
+        if _params["video_stream_local_put_body"] is not None:
             _body_params = _params["video_stream_local_put_body"]
 
         # set the HTTP header `Accept`
         _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501
 
         # set the HTTP header `Content-Type`
         _content_types_list = _params.get(
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/api/merge_records_api.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/api/merge_records_api.py`

 * *Files 1% similar despite different names*

```diff
@@ -8,22 +8,25 @@
     The version of the OpenAPI document: v1
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the file manually.
 """
 
 
+import io
 import logging
 import re  # noqa: F401
+import warnings
 from typing import Any, Dict, Optional
 
 from pydantic import Field, StrictBool, StrictStr, ValidationError, constr, validate_arguments
 from typing_extensions import Annotated
 
 from atriumsports.datacore.openapi.api_client import ApiClient
+from atriumsports.datacore.openapi.api_response import ApiResponse
 from atriumsports.datacore.openapi.exceptions import ApiTypeError, ApiValueError  # noqa: F401
 from atriumsports.datacore.openapi.models.success_response import SuccessResponse
 
 logger = logging.getLogger("openapi")
 
 
 class MergeRecordsApi(object):
@@ -97,28 +100,28 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: SuccessResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the entity_merge_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.entity_merge_with_http_info(
                 from_entity_id,
                 organization_id,
                 sport,
                 to_entity_id,
                 body,
@@ -161,15 +164,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Merge two entity records  # noqa: E501
 
         Merge the records of two entities  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.entity_merge_with_http_info(from_entity_id, organization_id, sport, to_entity_id, body, external, fields, hide_null, include, async_req=True)
@@ -191,21 +194,22 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -282,15 +286,15 @@
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params["body"]:
+        if _params["body"] is not None:
             _body_params = _params["body"]
 
         # set the HTTP header `Accept`
         _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501
 
         # set the HTTP header `Content-Type`
         _content_types_list = _params.get(
@@ -387,28 +391,28 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: SuccessResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the entity_swap_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.entity_swap_with_http_info(
                 from_entity_id,
                 organization_id,
                 season_id,
                 sport,
                 to_entity_id,
@@ -453,15 +457,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """For a given season, swap two entity records  # noqa: E501
 
         For a given season, swap the records of two entities  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.entity_swap_with_http_info(from_entity_id, organization_id, season_id, sport, to_entity_id, body, external, fields, hide_null, include, async_req=True)
@@ -485,21 +489,22 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -580,15 +585,15 @@
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params["body"]:
+        if _params["body"] is not None:
             _body_params = _params["body"]
 
         # set the HTTP header `Accept`
         _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501
 
         # set the HTTP header `Content-Type`
         _content_types_list = _params.get(
@@ -682,28 +687,28 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: SuccessResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the person_merge_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.person_merge_with_http_info(
                 from_person_id,
                 organization_id,
                 sport,
                 to_person_id,
                 body,
@@ -746,15 +751,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Merge two person records  # noqa: E501
 
         Merge the records of two persons  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.person_merge_with_http_info(from_person_id, organization_id, sport, to_person_id, body, external, fields, hide_null, include, async_req=True)
@@ -776,21 +781,22 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -867,15 +873,15 @@
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params["body"]:
+        if _params["body"] is not None:
             _body_params = _params["body"]
 
         # set the HTTP header `Accept`
         _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501
 
         # set the HTTP header `Content-Type`
         _content_types_list = _params.get(
@@ -972,28 +978,28 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: SuccessResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the person_swap_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.person_swap_with_http_info(
                 fixture_id,
                 from_person_id,
                 organization_id,
                 sport,
                 to_person_id,
@@ -1038,15 +1044,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """For a given fixture, swap two person records  # noqa: E501
 
         For a given fixture, swap the records of two persons  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.person_swap_with_http_info(fixture_id, from_person_id, organization_id, sport, to_person_id, body, external, fields, hide_null, include, async_req=True)
@@ -1070,21 +1076,22 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1165,15 +1172,15 @@
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params["body"]:
+        if _params["body"] is not None:
             _body_params = _params["body"]
 
         # set the HTTP header `Accept`
         _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501
 
         # set the HTTP header `Content-Type`
         _content_types_list = _params.get(
@@ -1270,28 +1277,28 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: SuccessResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the season_move_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.season_move_with_http_info(
                 from_competition_id,
                 organization_id,
                 season_id,
                 sport,
                 to_competition_id,
@@ -1336,15 +1343,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Move a season to a different competition  # noqa: E501
 
         Move a season under a different competition  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.season_move_with_http_info(from_competition_id, organization_id, season_id, sport, to_competition_id, body, external, fields, hide_null, include, async_req=True)
@@ -1368,21 +1375,22 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1463,15 +1471,15 @@
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params["body"]:
+        if _params["body"] is not None:
             _body_params = _params["body"]
 
         # set the HTTP header `Accept`
         _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501
 
         # set the HTTP header `Content-Type`
         _content_types_list = _params.get(
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/api/organizations_api.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/api/organizations_api.py`

 * *Files 3% similar despite different names*

```diff
@@ -8,23 +8,26 @@
     The version of the OpenAPI document: v1
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the file manually.
 """
 
 
+import io
 import logging
 import re  # noqa: F401
+import warnings
 from datetime import datetime
 from typing import Optional
 
 from pydantic import Field, StrictBool, StrictInt, StrictStr, ValidationError, conint, constr, validate_arguments
 from typing_extensions import Annotated
 
 from atriumsports.datacore.openapi.api_client import ApiClient
+from atriumsports.datacore.openapi.api_response import ApiResponse
 from atriumsports.datacore.openapi.exceptions import ApiTypeError, ApiValueError  # noqa: F401
 from atriumsports.datacore.openapi.models.organization_post_body import OrganizationPostBody
 from atriumsports.datacore.openapi.models.organization_put_body import OrganizationPutBody
 from atriumsports.datacore.openapi.models.organizations_response import OrganizationsResponse
 
 logger = logging.getLogger("openapi")
 
@@ -91,28 +94,28 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: OrganizationsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the organization_delete_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.organization_delete_with_http_info(
                 organization_id, sport, external, fields, hide_null, include, **kwargs
             )  # noqa: E501
         except Exception as e:
             logger.error("Exception when calling OrganizationsApi->organization_delete: %s\n" % e)
             raise
@@ -143,15 +146,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Delete an organization  # noqa: E501
 
         Delete an organization  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.organization_delete_with_http_info(organization_id, sport, external, fields, hide_null, include, async_req=True)
@@ -167,21 +170,22 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -341,28 +345,28 @@
         :type include: str
         :param limit: The maximum number of records to return. See [Pagination](#section/Introduction/Pagination) for more information.
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: OrganizationsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the organization_detail_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.organization_detail_with_http_info(
                 organization_id, sport, external, fields, hide_null, include, limit, offset, **kwargs
             )  # noqa: E501
         except Exception as e:
             logger.error("Exception when calling OrganizationsApi->organization_detail: %s\n" % e)
             raise
@@ -405,15 +409,15 @@
         offset: Annotated[
             Optional[StrictInt],
             Field(
                 description="The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Get an organization  # noqa: E501
 
         Return detailed information about a specific organization  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.organization_detail_with_http_info(organization_id, sport, external, fields, hide_null, include, limit, offset, async_req=True)
@@ -433,21 +437,22 @@
         :type include: str
         :param limit: The maximum number of records to return. See [Pagination](#section/Introduction/Pagination) for more information.
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -594,28 +599,28 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: OrganizationsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the organization_insert_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.organization_insert_with_http_info(
                 sport, organization_post_body, external, fields, hide_null, include, **kwargs
             )  # noqa: E501
         except Exception as e:
             logger.error("Exception when calling OrganizationsApi->organization_insert: %s\n" % e)
             raise
@@ -643,15 +648,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Create a new organization  # noqa: E501
 
         Add a new organization to the system  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.organization_insert_with_http_info(sport, organization_post_body, external, fields, hide_null, include, async_req=True)
@@ -667,21 +672,22 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -739,15 +745,15 @@
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params["organization_post_body"]:
+        if _params["organization_post_body"] is not None:
             _body_params = _params["organization_post_body"]
 
         # set the HTTP header `Accept`
         _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501
 
         # set the HTTP header `Content-Type`
         _content_types_list = _params.get(
@@ -865,28 +871,28 @@
         :type offset: int
         :param region_type: The region type >- `INTERNATIONAL` Multiple countries >- `LOCAL` Local area >- `NATIONAL` One country >- `STATE` One state
         :type region_type: str
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: OrganizationsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the organization_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.organization_list_with_http_info(
                 sport,
                 added,
                 country_code,
                 external,
                 fields,
@@ -951,15 +957,15 @@
                 description="The region type >- `INTERNATIONAL` Multiple countries >- `LOCAL` Local area >- `NATIONAL` One country >- `STATE` One state "
             ),
         ] = None,
         updated: Annotated[
             Optional[datetime], Field(description="Record was modified after this date/time. In UTC.")
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Get a list of organizations  # noqa: E501
 
         Return a list of available organizations  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.organization_list_with_http_info(sport, added, country_code, external, fields, hide_null, include, limit, offset, region_type, updated, async_req=True)
@@ -985,21 +991,22 @@
         :type offset: int
         :param region_type: The region type >- `INTERNATIONAL` Multiple countries >- `LOCAL` Local area >- `NATIONAL` One country >- `STATE` One state
         :type region_type: str
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1080,15 +1087,15 @@
         if _params.get("limit") is not None:  # noqa: E501
             _query_params.append(("limit", _params["limit"]))
 
         if _params.get("offset") is not None:  # noqa: E501
             _query_params.append(("offset", _params["offset"]))
 
         if _params.get("region_type") is not None:  # noqa: E501
-            _query_params.append(("regionType", _params["region_type"]))
+            _query_params.append(("regionType", _params["region_type"].value))
 
         if _params.get("updated") is not None:  # noqa: E501
             if isinstance(_params["updated"], datetime):
                 _query_params.append(
                     ("updated", _params["updated"].strftime(self.api_client.configuration.datetime_format))
                 )
             else:
@@ -1183,28 +1190,28 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: OrganizationsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the organization_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.organization_update_with_http_info(
                 organization_id, sport, organization_put_body, external, fields, hide_null, include, **kwargs
             )  # noqa: E501
         except Exception as e:
             logger.error("Exception when calling OrganizationsApi->organization_update: %s\n" % e)
             raise
@@ -1236,15 +1243,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Update an organization  # noqa: E501
 
         Change the information of a specific organization  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.organization_update_with_http_info(organization_id, sport, organization_put_body, external, fields, hide_null, include, async_req=True)
@@ -1262,21 +1269,22 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1345,15 +1353,15 @@
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params["organization_put_body"]:
+        if _params["organization_put_body"] is not None:
             _body_params = _params["organization_put_body"]
 
         # set the HTTP header `Accept`
         _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501
 
         # set the HTTP header `Content-Type`
         _content_types_list = _params.get(
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/api/partner_apis_api.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/api/partner_apis_api.py`

 * *Files 4% similar despite different names*

```diff
@@ -8,22 +8,25 @@
     The version of the OpenAPI document: v1
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the file manually.
 """
 
 
+import io
 import logging
 import re  # noqa: F401
+import warnings
 from typing import Any, Dict
 
 from pydantic import Field, StrictStr, ValidationError, constr, validate_arguments
 from typing_extensions import Annotated
 
 from atriumsports.datacore.openapi.api_client import ApiClient
+from atriumsports.datacore.openapi.api_response import ApiResponse
 from atriumsports.datacore.openapi.exceptions import ApiTypeError, ApiValueError  # noqa: F401
 from atriumsports.datacore.openapi.models.blank_model_response import BlankModelResponse
 
 logger = logging.getLogger("openapi")
 
 
 class PartnerAPIsApi(object):
@@ -68,28 +71,28 @@
         :type pathsubpath: str
         :param sport: Sport name (required)
         :type sport: str
         :param body: (required)
         :type body: object
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: BlankModelResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the partners_delete_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.partners_delete_with_http_info(
                 organization_id, partner, pathsubpath, sport, body, **kwargs
             )  # noqa: E501
         except Exception as e:
             logger.error("Exception when calling PartnerAPIsApi->partners_delete: %s\n" % e)
             raise
@@ -102,15 +105,15 @@
             Field(..., description="The unique identifier of the organization"),
         ],
         partner: Annotated[StrictStr, Field(..., description="Partner for partner integrations")],
         pathsubpath: Annotated[StrictStr, Field(..., description="Subpath for partner integrations")],
         sport: Annotated[StrictStr, Field(..., description="Sport name")],
         body: Dict[str, Any],
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Call a partner API DELETE service  # noqa: E501
 
         For detail check the documentation for the specific partner type.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.partners_delete_with_http_info(organization_id, partner, pathsubpath, sport, body, async_req=True)
@@ -124,21 +127,22 @@
         :type pathsubpath: str
         :param sport: Sport name (required)
         :type sport: str
         :param body: (required)
         :type body: object
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -193,15 +197,15 @@
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params["body"]:
+        if _params["body"] is not None:
             _body_params = _params["body"]
 
         # set the HTTP header `Accept`
         _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501
 
         # set the HTTP header `Content-Type`
         _content_types_list = _params.get(
@@ -266,28 +270,28 @@
         :type pathsubpath: str
         :param sport: Sport name (required)
         :type sport: str
         :param body: (required)
         :type body: object
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: BlankModelResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the partners_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.partners_get_with_http_info(
                 organization_id, partner, pathsubpath, sport, body, **kwargs
             )  # noqa: E501
         except Exception as e:
             logger.error("Exception when calling PartnerAPIsApi->partners_get: %s\n" % e)
             raise
@@ -300,15 +304,15 @@
             Field(..., description="The unique identifier of the organization"),
         ],
         partner: Annotated[StrictStr, Field(..., description="Partner for partner integrations")],
         pathsubpath: Annotated[StrictStr, Field(..., description="Subpath for partner integrations")],
         sport: Annotated[StrictStr, Field(..., description="Sport name")],
         body: Dict[str, Any],
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Call a partner API GET service  # noqa: E501
 
         For detail check the documentation for the specific partner type.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.partners_get_with_http_info(organization_id, partner, pathsubpath, sport, body, async_req=True)
@@ -322,21 +326,22 @@
         :type pathsubpath: str
         :param sport: Sport name (required)
         :type sport: str
         :param body: (required)
         :type body: object
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -391,15 +396,15 @@
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params["body"]:
+        if _params["body"] is not None:
             _body_params = _params["body"]
 
         # set the HTTP header `Accept`
         _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501
 
         # set the HTTP header `Content-Type`
         _content_types_list = _params.get(
@@ -464,28 +469,28 @@
         :type pathsubpath: str
         :param sport: Sport name (required)
         :type sport: str
         :param body: (required)
         :type body: object
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: BlankModelResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the partners_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.partners_post_with_http_info(
                 organization_id, partner, pathsubpath, sport, body, **kwargs
             )  # noqa: E501
         except Exception as e:
             logger.error("Exception when calling PartnerAPIsApi->partners_post: %s\n" % e)
             raise
@@ -498,15 +503,15 @@
             Field(..., description="The unique identifier of the organization"),
         ],
         partner: Annotated[StrictStr, Field(..., description="Partner for partner integrations")],
         pathsubpath: Annotated[StrictStr, Field(..., description="Subpath for partner integrations")],
         sport: Annotated[StrictStr, Field(..., description="Sport name")],
         body: Dict[str, Any],
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Call a partner API POST service  # noqa: E501
 
         For detail check the documentation for the specific partner type.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.partners_post_with_http_info(organization_id, partner, pathsubpath, sport, body, async_req=True)
@@ -520,21 +525,22 @@
         :type pathsubpath: str
         :param sport: Sport name (required)
         :type sport: str
         :param body: (required)
         :type body: object
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -589,15 +595,15 @@
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params["body"]:
+        if _params["body"] is not None:
             _body_params = _params["body"]
 
         # set the HTTP header `Accept`
         _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501
 
         # set the HTTP header `Content-Type`
         _content_types_list = _params.get(
@@ -662,28 +668,28 @@
         :type pathsubpath: str
         :param sport: Sport name (required)
         :type sport: str
         :param body: (required)
         :type body: object
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: BlankModelResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the partners_put_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.partners_put_with_http_info(
                 organization_id, partner, pathsubpath, sport, body, **kwargs
             )  # noqa: E501
         except Exception as e:
             logger.error("Exception when calling PartnerAPIsApi->partners_put: %s\n" % e)
             raise
@@ -696,15 +702,15 @@
             Field(..., description="The unique identifier of the organization"),
         ],
         partner: Annotated[StrictStr, Field(..., description="Partner for partner integrations")],
         pathsubpath: Annotated[StrictStr, Field(..., description="Subpath for partner integrations")],
         sport: Annotated[StrictStr, Field(..., description="Sport name")],
         body: Dict[str, Any],
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Call a partner API PUT service  # noqa: E501
 
         For detail check the documentation for the specific partner type.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.partners_put_with_http_info(organization_id, partner, pathsubpath, sport, body, async_req=True)
@@ -718,21 +724,22 @@
         :type pathsubpath: str
         :param sport: Sport name (required)
         :type sport: str
         :param body: (required)
         :type body: object
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -787,15 +794,15 @@
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params["body"]:
+        if _params["body"] is not None:
             _body_params = _params["body"]
 
         # set the HTTP header `Accept`
         _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501
 
         # set the HTTP header `Content-Type`
         _content_types_list = _params.get(
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/api/person_fixture_history_api.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/api/person_fixture_history_api.py`

 * *Files 3% similar despite different names*

```diff
@@ -8,23 +8,26 @@
     The version of the OpenAPI document: v1
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the file manually.
 """
 
 
+import io
 import logging
 import re  # noqa: F401
+import warnings
 from datetime import datetime
 from typing import Optional
 
 from pydantic import Field, StrictBool, StrictInt, StrictStr, ValidationError, conint, constr, validate_arguments
 from typing_extensions import Annotated
 
 from atriumsports.datacore.openapi.api_client import ApiClient
+from atriumsports.datacore.openapi.api_response import ApiResponse
 from atriumsports.datacore.openapi.exceptions import ApiTypeError, ApiValueError  # noqa: F401
 from atriumsports.datacore.openapi.models.game_log_person_response import GameLogPersonResponse
 
 logger = logging.getLogger("openapi")
 
 
 class PersonFixtureHistoryApi(object):
@@ -153,28 +156,28 @@
         :type starter: bool
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param win_loss: What the result was >- `DRAW` Draw >- `LOSS` Loss >- `WIN` Win
         :type win_loss: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: GameLogPersonResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the gamelog_listperson_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.gamelog_listperson_with_http_info(
                 organization_id,
                 person_id,
                 season_id,
                 sport,
                 added,
@@ -262,15 +265,15 @@
             Optional[datetime], Field(description="Record was modified after this date/time. In UTC.")
         ] = None,
         win_loss: Annotated[
             Optional[constr(strict=True, max_length=50)],
             Field(description="What the result was >- `DRAW` Draw >- `LOSS` Loss >- `WIN` Win "),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Fixture History for a person  # noqa: E501
 
         Return the Fixture History (based on statistics present) for a specific person in a season.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.gamelog_listperson_with_http_info(organization_id, person_id, season_id, sport, added, entity_id, external, fields, fixture_type, hide_null, home_away, include, is_player, is_team_official, limit, offset, starter, updated, win_loss, async_req=True)
@@ -312,21 +315,22 @@
         :type starter: bool
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param win_loss: What the result was >- `DRAW` Draw >- `LOSS` Loss >- `WIN` Win
         :type win_loss: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -412,21 +416,21 @@
         if _params.get("external") is not None:  # noqa: E501
             _query_params.append(("external", _params["external"]))
 
         if _params.get("fields") is not None:  # noqa: E501
             _query_params.append(("fields", _params["fields"]))
 
         if _params.get("fixture_type") is not None:  # noqa: E501
-            _query_params.append(("fixtureType", _params["fixture_type"]))
+            _query_params.append(("fixtureType", _params["fixture_type"].value))
 
         if _params.get("hide_null") is not None:  # noqa: E501
             _query_params.append(("hideNull", _params["hide_null"]))
 
         if _params.get("home_away") is not None:  # noqa: E501
-            _query_params.append(("homeAway", _params["home_away"]))
+            _query_params.append(("homeAway", _params["home_away"].value))
 
         if _params.get("include") is not None:  # noqa: E501
             _query_params.append(("include", _params["include"]))
 
         if _params.get("is_player") is not None:  # noqa: E501
             _query_params.append(("isPlayer", _params["is_player"]))
 
@@ -447,15 +451,15 @@
                 _query_params.append(
                     ("updated", _params["updated"].strftime(self.api_client.configuration.datetime_format))
                 )
             else:
                 _query_params.append(("updated", _params["updated"]))
 
         if _params.get("win_loss") is not None:  # noqa: E501
-            _query_params.append(("winLoss", _params["win_loss"]))
+            _query_params.append(("winLoss", _params["win_loss"].value))
 
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/api/person_fixture_statistics_api.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/api/person_fixture_statistics_api.py`

 * *Files 2% similar despite different names*

```diff
@@ -8,23 +8,26 @@
     The version of the OpenAPI document: v1
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the file manually.
 """
 
 
+import io
 import logging
 import re  # noqa: F401
+import warnings
 from datetime import datetime
 from typing import Optional
 
 from pydantic import Field, StrictBool, StrictInt, StrictStr, ValidationError, conint, constr, validate_arguments
 from typing_extensions import Annotated
 
 from atriumsports.datacore.openapi.api_client import ApiClient
+from atriumsports.datacore.openapi.api_response import ApiResponse
 from atriumsports.datacore.openapi.exceptions import ApiTypeError, ApiValueError  # noqa: F401
 from atriumsports.datacore.openapi.models.fixture_person_statistics_periods_post_body import (
     FixturePersonStatisticsPeriodsPostBody,
 )
 from atriumsports.datacore.openapi.models.fixture_person_statistics_periods_response import (
     FixturePersonStatisticsPeriodsResponse,
 )
@@ -113,28 +116,28 @@
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param person_id: The unique identifier of the person
         :type person_id: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: FixturePersonStatisticsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the fps_delete_all_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.fps_delete_all_with_http_info(
                 fixture_id,
                 organization_id,
                 sport,
                 entity_id,
                 external,
@@ -184,15 +187,15 @@
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         person_id: Annotated[Optional[StrictStr], Field(description="The unique identifier of the person")] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Delete person total statistics  # noqa: E501
 
         Delete a total statistic record for a person in a fixture.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.fps_delete_all_with_http_info(fixture_id, organization_id, sport, entity_id, external, fields, force_delete, hide_null, include, person_id, async_req=True)
@@ -216,21 +219,22 @@
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param person_id: The unique identifier of the person
         :type person_id: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -400,28 +404,28 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: FixturePersonStatisticsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the fps_insert_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.fps_insert_update_with_http_info(
                 organization_id,
                 sport,
                 fixture_person_statistics_post_body,
                 external,
                 fields,
@@ -460,15 +464,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Create/Update person total statistics  # noqa: E501
 
         Depending on the data, add or update a total statistic record for a person in a fixture.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.fps_insert_update_with_http_info(organization_id, sport, fixture_person_statistics_post_body, external, fields, hide_null, include, async_req=True)
@@ -486,21 +490,22 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -569,15 +574,15 @@
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params["fixture_person_statistics_post_body"]:
+        if _params["fixture_person_statistics_post_body"] is not None:
             _body_params = _params["fixture_person_statistics_post_body"]
 
         # set the HTTP header `Accept`
         _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501
 
         # set the HTTP header `Content-Type`
         _content_types_list = _params.get(
@@ -706,28 +711,28 @@
         :type person_id: str
         :param starter: Is the person a starter in the fixture ?
         :type starter: bool
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: FixturePersonStatisticsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the fps_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.fps_list_with_http_info(
                 fixture_id,
                 organization_id,
                 sport,
                 added,
                 entity_id,
@@ -798,15 +803,15 @@
         ] = None,
         person_id: Annotated[Optional[StrictStr], Field(description="The unique identifier of the person")] = None,
         starter: Annotated[Optional[StrictBool], Field(description="Is the person a starter in the fixture ?")] = None,
         updated: Annotated[
             Optional[datetime], Field(description="Record was modified after this date/time. In UTC.")
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Person total statistics  # noqa: E501
 
         Return a list of person total statistics for a fixture. Statistics are the totals (all periods added together) for the fixture.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.fps_list_with_http_info(fixture_id, organization_id, sport, added, entity_id, external, fields, hide_null, include, is_player, is_team_official, limit, offset, person_id, starter, updated, async_req=True)
@@ -842,21 +847,22 @@
         :type person_id: str
         :param starter: Is the person a starter in the fixture ?
         :type starter: bool
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1101,28 +1107,28 @@
         :type person_id: str
         :param starter: Is the person a starter in the fixture ?
         :type starter: bool
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: FixturePersonStatisticsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the fps_listlive_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.fps_listlive_with_http_info(
                 fixture_id,
                 organization_id,
                 sport,
                 added,
                 entity_id,
@@ -1193,15 +1199,15 @@
         ] = None,
         person_id: Annotated[Optional[StrictStr], Field(description="The unique identifier of the person")] = None,
         starter: Annotated[Optional[StrictBool], Field(description="Is the person a starter in the fixture ?")] = None,
         updated: Annotated[
             Optional[datetime], Field(description="Record was modified after this date/time. In UTC.")
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Person total statistics - live  # noqa: E501
 
              Return a list of live person total statistics for a fixture. Statistics are the totals     (all periods added together) for the fixture. This call will return records of fixtures still in-progress     if available.  If the fixture is complete this call operates the same as the non 'live' route.      Rate limited to 2 requests every minute - returns HTTP 429 Too Many Requests if called more often.       # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.fps_listlive_with_http_info(fixture_id, organization_id, sport, added, entity_id, external, fields, hide_null, include, is_player, is_team_official, limit, offset, person_id, starter, updated, async_req=True)
@@ -1237,21 +1243,22 @@
         :type person_id: str
         :param starter: Is the person a starter in the fixture ?
         :type starter: bool
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1477,28 +1484,28 @@
         :type period_id: int
         :param person_id: The unique identifier of the person
         :type person_id: str
         :param section: The section of the period (sub-period)
         :type section: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: FixturePersonStatisticsPeriodsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the fpsp_delete_all_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.fpsp_delete_all_with_http_info(
                 fixture_id,
                 organization_id,
                 sport,
                 entity_id,
                 external,
@@ -1554,15 +1561,15 @@
         ] = None,
         period_id: Annotated[Optional[StrictInt], Field(description="The identifier for the period")] = None,
         person_id: Annotated[Optional[StrictStr], Field(description="The unique identifier of the person")] = None,
         section: Annotated[
             Optional[constr(strict=True, max_length=100)], Field(description="The section of the period (sub-period)")
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Delete person period statistics  # noqa: E501
 
         Delete a period statistic record for a person in a fixture.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.fpsp_delete_all_with_http_info(fixture_id, organization_id, sport, entity_id, external, fields, force_delete, hide_null, include, period_id, person_id, section, async_req=True)
@@ -1590,21 +1597,22 @@
         :type period_id: int
         :param person_id: The unique identifier of the person
         :type person_id: str
         :param section: The section of the period (sub-period)
         :type section: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1782,28 +1790,28 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: FixturePersonStatisticsPeriodsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the fpsp_insert_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.fpsp_insert_update_with_http_info(
                 organization_id,
                 sport,
                 fixture_person_statistics_periods_post_body,
                 external,
                 fields,
@@ -1842,15 +1850,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Create/Update person period statistics  # noqa: E501
 
         Depending on the data, add or update a period statistic record for a person in a fixture.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.fpsp_insert_update_with_http_info(organization_id, sport, fixture_person_statistics_periods_post_body, external, fields, hide_null, include, async_req=True)
@@ -1868,21 +1876,22 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1951,15 +1960,15 @@
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params["fixture_person_statistics_periods_post_body"]:
+        if _params["fixture_person_statistics_periods_post_body"] is not None:
             _body_params = _params["fixture_person_statistics_periods_post_body"]
 
         # set the HTTP header `Accept`
         _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501
 
         # set the HTTP header `Content-Type`
         _content_types_list = _params.get(
@@ -2087,28 +2096,28 @@
         :type person_id: str
         :param section: The section of the period (sub-period)
         :type section: str
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: FixturePersonStatisticsPeriodsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the fpsp_listperiod_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.fpsp_listperiod_with_http_info(
                 fixture_id,
                 organization_id,
                 sport,
                 added,
                 entity_id,
@@ -2179,15 +2188,15 @@
         section: Annotated[
             Optional[constr(strict=True, max_length=100)], Field(description="The section of the period (sub-period)")
         ] = None,
         updated: Annotated[
             Optional[datetime], Field(description="Record was modified after this date/time. In UTC.")
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Person period statistics  # noqa: E501
 
         Return a list of person period statistics for a fixture  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.fpsp_listperiod_with_http_info(fixture_id, organization_id, sport, added, entity_id, external, fields, hide_null, include, limit, offset, period_id, person_id, section, updated, async_req=True)
@@ -2221,21 +2230,22 @@
         :type person_id: str
         :param section: The section of the period (sub-period)
         :type section: str
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -2475,28 +2485,28 @@
         :type person_id: str
         :param section: The section of the period (sub-period)
         :type section: str
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: FixturePersonStatisticsPeriodsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the fpsp_listperiodlive_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.fpsp_listperiodlive_with_http_info(
                 fixture_id,
                 organization_id,
                 sport,
                 added,
                 entity_id,
@@ -2567,15 +2577,15 @@
         section: Annotated[
             Optional[constr(strict=True, max_length=100)], Field(description="The section of the period (sub-period)")
         ] = None,
         updated: Annotated[
             Optional[datetime], Field(description="Record was modified after this date/time. In UTC.")
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Person period statistics - live  # noqa: E501
 
         Return a list of person period statistics for a fixture  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.fpsp_listperiodlive_with_http_info(fixture_id, organization_id, sport, added, entity_id, external, fields, hide_null, include, limit, offset, period_id, person_id, section, updated, async_req=True)
@@ -2609,21 +2619,22 @@
         :type person_id: str
         :param section: The section of the period (sub-period)
         :type section: str
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/api/persons_api.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/api/persons_api.py`

 * *Files 6% similar despite different names*

```diff
@@ -8,23 +8,26 @@
     The version of the OpenAPI document: v1
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the file manually.
 """
 
 
+import io
 import logging
 import re  # noqa: F401
+import warnings
 from datetime import datetime
 from typing import Optional
 
 from pydantic import Field, StrictBool, StrictInt, StrictStr, ValidationError, conint, constr, validate_arguments
 from typing_extensions import Annotated
 
 from atriumsports.datacore.openapi.api_client import ApiClient
+from atriumsports.datacore.openapi.api_response import ApiResponse
 from atriumsports.datacore.openapi.exceptions import ApiTypeError, ApiValueError  # noqa: F401
 from atriumsports.datacore.openapi.models.person_post_body import PersonPostBody
 from atriumsports.datacore.openapi.models.person_put_body import PersonPutBody
 from atriumsports.datacore.openapi.models.persons_response import PersonsResponse
 
 logger = logging.getLogger("openapi")
 
@@ -102,28 +105,28 @@
         :type force_delete: bool
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: PersonsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the person_delete_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.person_delete_with_http_info(
                 organization_id, person_id, sport, external, fields, force_delete, hide_null, include, **kwargs
             )  # noqa: E501
         except Exception as e:
             logger.error("Exception when calling PersonsApi->person_delete: %s\n" % e)
             raise
@@ -161,15 +164,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Delete a person  # noqa: E501
 
         Delete a specific person  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.person_delete_with_http_info(organization_id, person_id, sport, external, fields, force_delete, hide_null, include, async_req=True)
@@ -189,21 +192,22 @@
         :type force_delete: bool
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -381,28 +385,28 @@
         :type include: str
         :param limit: The maximum number of records to return. See [Pagination](#section/Introduction/Pagination) for more information.
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: PersonsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the person_detail_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.person_detail_with_http_info(
                 organization_id, person_id, sport, external, fields, hide_null, include, limit, offset, **kwargs
             )  # noqa: E501
         except Exception as e:
             logger.error("Exception when calling PersonsApi->person_detail: %s\n" % e)
             raise
@@ -446,15 +450,15 @@
         offset: Annotated[
             Optional[StrictInt],
             Field(
                 description="The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Get a person  # noqa: E501
 
         Return detailed information about a specific person  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.person_detail_with_http_info(organization_id, person_id, sport, external, fields, hide_null, include, limit, offset, async_req=True)
@@ -476,21 +480,22 @@
         :type include: str
         :param limit: The maximum number of records to return. See [Pagination](#section/Introduction/Pagination) for more information.
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -656,28 +661,28 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: PersonsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the person_insert_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.person_insert_with_http_info(
                 organization_id, sport, person_post_body, external, fields, hide_null, include, **kwargs
             )  # noqa: E501
         except Exception as e:
             logger.error("Exception when calling PersonsApi->person_insert: %s\n" % e)
             raise
@@ -709,15 +714,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Create a person  # noqa: E501
 
         Insert a new person  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.person_insert_with_http_info(organization_id, sport, person_post_body, external, fields, hide_null, include, async_req=True)
@@ -735,21 +740,22 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -810,15 +816,15 @@
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params["person_post_body"]:
+        if _params["person_post_body"] is not None:
             _body_params = _params["person_post_body"]
 
         # set the HTTP header `Accept`
         _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501
 
         # set the HTTP header `Content-Type`
         _content_types_list = _params.get(
@@ -906,28 +912,28 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: PersonsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the person_insert_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.person_insert_update_with_http_info(
                 organization_id, sport, person_post_body, external, fields, hide_null, include, **kwargs
             )  # noqa: E501
         except Exception as e:
             logger.error("Exception when calling PersonsApi->person_insert_update: %s\n" % e)
             raise
@@ -959,15 +965,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Create/Update a person  # noqa: E501
 
         Depending on data, Add a new person or update an existing one  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.person_insert_update_with_http_info(organization_id, sport, person_post_body, external, fields, hide_null, include, async_req=True)
@@ -985,21 +991,22 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1060,15 +1067,15 @@
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params["person_post_body"]:
+        if _params["person_post_body"] is not None:
             _body_params = _params["person_post_body"]
 
         # set the HTTP header `Accept`
         _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501
 
         # set the HTTP header `Content-Type`
         _content_types_list = _params.get(
@@ -1242,28 +1249,28 @@
         :type sort_by: str
         :param status: Status >- `ACTIVE` Active >- `DECEASED` Deceased >- `INACTIVE` Inactive >- `PENDING` Pending >- `UNREGISTERED` UnRegistered
         :type status: str
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: PersonsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the person_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.person_list_with_http_info(
                 organization_id,
                 sport,
                 added,
                 external,
                 fields,
@@ -1375,15 +1382,15 @@
                 description="Status >- `ACTIVE` Active >- `DECEASED` Deceased >- `INACTIVE` Inactive >- `PENDING` Pending >- `UNREGISTERED` UnRegistered "
             ),
         ] = None,
         updated: Annotated[
             Optional[datetime], Field(description="Record was modified after this date/time. In UTC.")
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Get a list of persons  # noqa: E501
 
         Return a list of available persons  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.person_list_with_http_info(organization_id, sport, added, external, fields, gender, hide_null, include, limit, name_family_latin_starts_with, name_family_local_starts_with, name_full_latin, name_full_latin_contains, name_full_local, name_full_local_contains, nationality, offset, sort_by, status, updated, async_req=True)
@@ -1427,21 +1434,22 @@
         :type sort_by: str
         :param status: Status >- `ACTIVE` Active >- `DECEASED` Deceased >- `INACTIVE` Inactive >- `PENDING` Pending >- `UNREGISTERED` UnRegistered
         :type status: str
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1519,15 +1527,15 @@
         if _params.get("external") is not None:  # noqa: E501
             _query_params.append(("external", _params["external"]))
 
         if _params.get("fields") is not None:  # noqa: E501
             _query_params.append(("fields", _params["fields"]))
 
         if _params.get("gender") is not None:  # noqa: E501
-            _query_params.append(("gender", _params["gender"]))
+            _query_params.append(("gender", _params["gender"].value))
 
         if _params.get("hide_null") is not None:  # noqa: E501
             _query_params.append(("hideNull", _params["hide_null"]))
 
         if _params.get("include") is not None:  # noqa: E501
             _query_params.append(("include", _params["include"]))
 
@@ -1558,15 +1566,15 @@
         if _params.get("offset") is not None:  # noqa: E501
             _query_params.append(("offset", _params["offset"]))
 
         if _params.get("sort_by") is not None:  # noqa: E501
             _query_params.append(("sortBy", _params["sort_by"]))
 
         if _params.get("status") is not None:  # noqa: E501
-            _query_params.append(("status", _params["status"]))
+            _query_params.append(("status", _params["status"].value))
 
         if _params.get("updated") is not None:  # noqa: E501
             if isinstance(_params["updated"], datetime):
                 _query_params.append(
                     ("updated", _params["updated"].strftime(self.api_client.configuration.datetime_format))
                 )
             else:
@@ -1664,28 +1672,28 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: PersonsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the person_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.person_update_with_http_info(
                 organization_id, person_id, sport, person_put_body, external, fields, hide_null, include, **kwargs
             )  # noqa: E501
         except Exception as e:
             logger.error("Exception when calling PersonsApi->person_update: %s\n" % e)
             raise
@@ -1718,15 +1726,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Update a person  # noqa: E501
 
         Change the information of a specific person  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.person_update_with_http_info(organization_id, person_id, sport, person_put_body, external, fields, hide_null, include, async_req=True)
@@ -1746,21 +1754,22 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1833,15 +1842,15 @@
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params["person_put_body"]:
+        if _params["person_put_body"] is not None:
             _body_params = _params["person_put_body"]
 
         # set the HTTP header `Accept`
         _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501
 
         # set the HTTP header `Content-Type`
         _content_types_list = _params.get(
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/api/rankings_api.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/api/rankings_api.py`

 * *Files 3% similar despite different names*

```diff
@@ -8,23 +8,26 @@
     The version of the OpenAPI document: v1
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the file manually.
 """
 
 
+import io
 import logging
 import re  # noqa: F401
+import warnings
 from datetime import datetime
 from typing import Optional
 
 from pydantic import Field, StrictBool, StrictInt, StrictStr, ValidationError, conint, constr, validate_arguments
 from typing_extensions import Annotated
 
 from atriumsports.datacore.openapi.api_client import ApiClient
+from atriumsports.datacore.openapi.api_response import ApiResponse
 from atriumsports.datacore.openapi.exceptions import ApiTypeError, ApiValueError  # noqa: F401
 from atriumsports.datacore.openapi.models.ranking_rows_post_body import RankingRowsPostBody
 from atriumsports.datacore.openapi.models.ranking_rows_put_body import RankingRowsPutBody
 from atriumsports.datacore.openapi.models.ranking_rows_response import RankingRowsResponse
 
 logger = logging.getLogger("openapi")
 
@@ -105,28 +108,28 @@
         :type force_delete: bool
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: RankingRowsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the ranking_row_delete_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.ranking_row_delete_with_http_info(
                 organization_id, ranking_id, row_id, sport, external, fields, force_delete, hide_null, include, **kwargs
             )  # noqa: E501
         except Exception as e:
             logger.error("Exception when calling RankingsApi->ranking_row_delete: %s\n" % e)
             raise
@@ -165,15 +168,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Delete an ranking row  # noqa: E501
 
         Delete a specific ranking row  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.ranking_row_delete_with_http_info(organization_id, ranking_id, row_id, sport, external, fields, force_delete, hide_null, include, async_req=True)
@@ -195,21 +198,22 @@
         :type force_delete: bool
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -386,28 +390,28 @@
         :type force_delete: bool
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: RankingRowsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the ranking_row_delete_all_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.ranking_row_delete_all_with_http_info(
                 organization_id,
                 ranking_id,
                 ranking_run_id,
                 sport,
                 external,
@@ -455,15 +459,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Delete all rows for a rankingId and a rankingRunId  # noqa: E501
 
         Delete all rows for a rankingId and a rankingRunId  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.ranking_row_delete_all_with_http_info(organization_id, ranking_id, ranking_run_id, sport, external, fields, force_delete, hide_null, include, async_req=True)
@@ -485,21 +489,22 @@
         :type force_delete: bool
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -684,28 +689,28 @@
         :type include: str
         :param limit: The maximum number of records to return. See [Pagination](#section/Introduction/Pagination) for more information.
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: RankingRowsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the ranking_rows_detail_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.ranking_rows_detail_with_http_info(
                 organization_id,
                 ranking_id,
                 row_id,
                 sport,
                 external,
@@ -760,15 +765,15 @@
         offset: Annotated[
             Optional[StrictInt],
             Field(
                 description="The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Get a ranking row   # noqa: E501
 
         Return a single ranking row record  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.ranking_rows_detail_with_http_info(organization_id, ranking_id, row_id, sport, external, fields, hide_null, include, limit, offset, async_req=True)
@@ -792,21 +797,22 @@
         :type include: str
         :param limit: The maximum number of records to return. See [Pagination](#section/Introduction/Pagination) for more information.
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -982,28 +988,28 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: RankingRowsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the ranking_rows_insert_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.ranking_rows_insert_with_http_info(
                 organization_id,
                 ranking_id,
                 ranking_run_id,
                 sport,
                 ranking_rows_post_body,
@@ -1046,15 +1052,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Create an ranking row  # noqa: E501
 
         Add a new ranking row  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.ranking_rows_insert_with_http_info(organization_id, ranking_id, ranking_run_id, sport, ranking_rows_post_body, external, fields, hide_null, include, async_req=True)
@@ -1076,21 +1082,22 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1167,15 +1174,15 @@
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params["ranking_rows_post_body"]:
+        if _params["ranking_rows_post_body"] is not None:
             _body_params = _params["ranking_rows_post_body"]
 
         # set the HTTP header `Accept`
         _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501
 
         # set the HTTP header `Content-Type`
         _content_types_list = _params.get(
@@ -1300,28 +1307,28 @@
         :type offset: int
         :param sort_by: Comma-delimited list of one or more fields to sort by, each field can have '-' as prefix to sort in descending order, and '+' (or no prefix) to sort in ascending order.
         :type sort_by: str
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: RankingRowsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the ranking_rows_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.ranking_rows_list_with_http_info(
                 organization_id,
                 ranking_id,
                 sport,
                 added,
                 entity_id,
@@ -1391,15 +1398,15 @@
                 description="Comma-delimited list of one or more fields to sort by, each field can have '-' as prefix to sort in descending order, and '+' (or no prefix) to sort in ascending order."
             ),
         ] = None,
         updated: Annotated[
             Optional[datetime], Field(description="Record was modified after this date/time. In UTC.")
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Get a list of the latest ranking rows   # noqa: E501
 
         Return a list of ranking_rows for a rankingId  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.ranking_rows_list_with_http_info(organization_id, ranking_id, sport, added, entity_id, external, fields, hide_null, include, limit, offset, sort_by, updated, async_req=True)
@@ -1429,21 +1436,22 @@
         :type offset: int
         :param sort_by: Comma-delimited list of one or more fields to sort by, each field can have '-' as prefix to sort in descending order, and '+' (or no prefix) to sort in ascending order.
         :type sort_by: str
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1641,28 +1649,28 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: RankingRowsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the ranking_rows_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.ranking_rows_update_with_http_info(
                 organization_id,
                 ranking_id,
                 row_id,
                 sport,
                 ranking_rows_put_body,
@@ -1705,15 +1713,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Update an ranking row  # noqa: E501
 
         Change the information of a specific ranking row  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.ranking_rows_update_with_http_info(organization_id, ranking_id, row_id, sport, ranking_rows_put_body, external, fields, hide_null, include, async_req=True)
@@ -1735,21 +1743,22 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1826,15 +1835,15 @@
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params["ranking_rows_put_body"]:
+        if _params["ranking_rows_put_body"] is not None:
             _body_params = _params["ranking_rows_put_body"]
 
         # set the HTTP header `Accept`
         _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501
 
         # set the HTTP header `Content-Type`
         _content_types_list = _params.get(
@@ -1962,28 +1971,28 @@
         :type offset: int
         :param sort_by: Comma-delimited list of one or more fields to sort by, each field can have '-' as prefix to sort in descending order, and '+' (or no prefix) to sort in ascending order.
         :type sort_by: str
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: RankingRowsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the ranking_runs_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.ranking_runs_list_with_http_info(
                 organization_id,
                 ranking_id,
                 ranking_run_id,
                 sport,
                 added,
@@ -2055,15 +2064,15 @@
                 description="Comma-delimited list of one or more fields to sort by, each field can have '-' as prefix to sort in descending order, and '+' (or no prefix) to sort in ascending order."
             ),
         ] = None,
         updated: Annotated[
             Optional[datetime], Field(description="Record was modified after this date/time. In UTC.")
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Get a list of the ranking rows for a run  # noqa: E501
 
         Return a list of ranking_rows for a rankingId and rankingRunId  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.ranking_runs_list_with_http_info(organization_id, ranking_id, ranking_run_id, sport, added, entity_id, external, fields, hide_null, include, limit, offset, sort_by, updated, async_req=True)
@@ -2095,21 +2104,22 @@
         :type offset: int
         :param sort_by: Comma-delimited list of one or more fields to sort by, each field can have '-' as prefix to sort in descending order, and '+' (or no prefix) to sort in ascending order.
         :type sort_by: str
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/api/roles_api.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/api/roles_api.py`

 * *Files 6% similar despite different names*

```diff
@@ -8,23 +8,26 @@
     The version of the OpenAPI document: v1
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the file manually.
 """
 
 
+import io
 import logging
 import re  # noqa: F401
+import warnings
 from datetime import datetime
 from typing import Optional
 
 from pydantic import Field, StrictBool, StrictInt, StrictStr, ValidationError, conint, constr, validate_arguments
 from typing_extensions import Annotated
 
 from atriumsports.datacore.openapi.api_client import ApiClient
+from atriumsports.datacore.openapi.api_response import ApiResponse
 from atriumsports.datacore.openapi.exceptions import ApiTypeError, ApiValueError  # noqa: F401
 from atriumsports.datacore.openapi.models.role_post_body import RolePostBody
 from atriumsports.datacore.openapi.models.role_put_body import RolePutBody
 from atriumsports.datacore.openapi.models.roles_response import RolesResponse
 
 logger = logging.getLogger("openapi")
 
@@ -102,28 +105,28 @@
         :type force_delete: bool
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: RolesResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the role_all_delete_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.role_all_delete_with_http_info(
                 fixture_id, organization_id, sport, external, fields, force_delete, hide_null, include, **kwargs
             )  # noqa: E501
         except Exception as e:
             logger.error("Exception when calling RolesApi->role_all_delete: %s\n" % e)
             raise
@@ -161,15 +164,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Delete all a role  # noqa: E501
 
         Delete all role  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.role_all_delete_with_http_info(fixture_id, organization_id, sport, external, fields, force_delete, hide_null, include, async_req=True)
@@ -189,21 +192,22 @@
         :type force_delete: bool
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -373,28 +377,28 @@
         :type force_delete: bool
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: RolesResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the role_delete_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.role_delete_with_http_info(
                 organization_id, role_id, sport, external, fields, force_delete, hide_null, include, **kwargs
             )  # noqa: E501
         except Exception as e:
             logger.error("Exception when calling RolesApi->role_delete: %s\n" % e)
             raise
@@ -432,15 +436,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Delete a role  # noqa: E501
 
         Delete a specific role  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.role_delete_with_http_info(organization_id, role_id, sport, external, fields, force_delete, hide_null, include, async_req=True)
@@ -460,21 +464,22 @@
         :type force_delete: bool
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -652,28 +657,28 @@
         :type include: str
         :param limit: The maximum number of records to return. See [Pagination](#section/Introduction/Pagination) for more information.
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: RolesResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the roles_detail_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.roles_detail_with_http_info(
                 organization_id, role_id, sport, external, fields, hide_null, include, limit, offset, **kwargs
             )  # noqa: E501
         except Exception as e:
             logger.error("Exception when calling RolesApi->roles_detail: %s\n" % e)
             raise
@@ -717,15 +722,15 @@
         offset: Annotated[
             Optional[StrictInt],
             Field(
                 description="The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Get a role  # noqa: E501
 
         Return detailed information about a specific role  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.roles_detail_with_http_info(organization_id, role_id, sport, external, fields, hide_null, include, limit, offset, async_req=True)
@@ -747,21 +752,22 @@
         :type include: str
         :param limit: The maximum number of records to return. See [Pagination](#section/Introduction/Pagination) for more information.
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -927,28 +933,28 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: RolesResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the roles_insert_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.roles_insert_with_http_info(
                 organization_id, sport, role_post_body, external, fields, hide_null, include, **kwargs
             )  # noqa: E501
         except Exception as e:
             logger.error("Exception when calling RolesApi->roles_insert: %s\n" % e)
             raise
@@ -980,15 +986,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Create a role  # noqa: E501
 
         Add a new role  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.roles_insert_with_http_info(organization_id, sport, role_post_body, external, fields, hide_null, include, async_req=True)
@@ -1006,21 +1012,22 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1081,15 +1088,15 @@
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params["role_post_body"]:
+        if _params["role_post_body"] is not None:
             _body_params = _params["role_post_body"]
 
         # set the HTTP header `Accept`
         _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501
 
         # set the HTTP header `Content-Type`
         _content_types_list = _params.get(
@@ -1170,15 +1177,15 @@
                 description="The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information."
             ),
         ] = None,
         person_id: Annotated[Optional[StrictStr], Field(description="The unique identifier of the person")] = None,
         role: Annotated[
             Optional[StrictStr],
             Field(
-                description="Role. Can specify multiple values delimited by comma. >- `CAPTAIN` Captain >- `CAPTAIN_VICE` Vice Captain >- `CEO` CEO >- `COACH` Coach >- `COACH_ASSISTANT` Assistant Coach >- `COACH_ASSISTANT_HEAD` Assistant Head Coach >- `COACH_ASSOCIATE_HEAD` Associate Head Coach >- `COACH_DEVELOPMENT` Development Coach >- `COACH_HEAD` Head Coach >- `COACH_HEAD_INTERIM` Interim Head Coach >- `COACH_OTHER` Other coaching staff >- `COACH_SC` Strengh and Conditioning Coach >- `COACH_SENIOR` Senior Coach >- `COACH_SPECIALIST` Specialist Coach >- `COMMISSIONER` Commissioner >- `COMMITTEE` Committee >- `CREW_CHIEF` Crew Chief >- `DIRECTOR` Director >- `DOCTOR` Doctor >- `GENERAL` General >- `GROUNDSKEEPER` Groundskeeper >- `JUDGE_SCORING` Scoring Judge (SJ) >- `JUDGE_TIMING` Timing Judge (TJ) >- `MANAGER` Manager >- `MATCH_OFFICIAL` Match Official >- `MEDIA_OFFICER` Media Officer >- `MEDICAL_STAFF` Medical Staff >- `OTHER` Other >- `PHYSIOTHERAPIST` Physiotherapist >- `PRESIDENT` President >- `PRESIDENT_VICE` Vice President >- `REFEREE` Referee >- `REFEREE_ASSISTANT` Referee Assistant >- `REFEREE_ASSISTANT_RESERVE` Reserve Assistant Referee >- `REFEREE_RESERVE` Reserve Referee >- `SCOREKEEPER` Scorekeeper >- `SCOREKEEPER_ASSISTANT` Assistant Scorekeeper >- `SCORER` Scorer >- `SCORER_ASSISTANT` Assistant Scorer >- `SECRETARY` Secretary >- `SHOT_CLOCK_OPERATOR` Shot Clock Operator >- `STATISTICIAN` Statistician >- `TECHNICAL_OFFICIAL` Technical Official (TO) >- `TIMEKEEPER` Timekeeper >- `TIMER` Timer >- `TRAINER` Trainer >- `TRAINER_ASSISTANT` Assitant Trainer >- `TRANSLATOR` Translator >- `TREASURER` Treasurer >- `UMPIRE` Umpire >- `UMPIRE_1` Umpire 1 >- `UMPIRE_2` Umpire 2 >- `UMPIRE_RESERVE` Reserve Umpire (RU) >- `UMPIRE_VIDEO` Video Umpire (VU) >- `VIDEO_TECHNICIAN` Video Technician (VT) "
+                description="Role. Can specify multiple values delimited by comma. >- `ASSISTANT_REFEREE_1` Assistant Referee 1 >- `ASSISTANT_REFEREE_2` Assistant Referee 2 >- `CAPTAIN` Captain >- `CAPTAIN_VICE` Vice Captain >- `CEO` CEO >- `COACH` Coach >- `COACH_ASSISTANT` Assistant Coach >- `COACH_ASSISTANT_HEAD` Assistant Head Coach >- `COACH_ASSOCIATE_HEAD` Associate Head Coach >- `COACH_DEVELOPMENT` Development Coach >- `COACH_HEAD` Head Coach >- `COACH_HEAD_INTERIM` Interim Head Coach >- `COACH_OTHER` Other coaching staff >- `COACH_SC` Strength and Conditioning Coach >- `COACH_SENIOR` Senior Coach >- `COACH_SPECIALIST` Specialist Coach >- `COMMISSIONER` Commissioner >- `COMMITTEE` Committee >- `CREW_CHIEF` Crew Chief >- `DELEGATE` Delegate >- `DIRECTOR` Director >- `DOCTOR` Doctor >- `GENERAL` General >- `GROUNDSKEEPER` Groundskeeper >- `JUDGE_SCORING` Scoring Judge (SJ) >- `JUDGE_TIMING` Timing Judge (TJ) >- `MANAGER` Manager >- `MATCH_OFFICIAL` Match Official >- `MATCH_SUPERVISOR` Match Supervisor >- `MEDIA_OFFICER` Media Officer >- `MEDICAL_STAFF` Medical Staff >- `OTHER` Other >- `PHYSIOTHERAPIST` Physiotherapist >- `PRESIDENT` President >- `PRESIDENT_VICE` Vice President >- `REFEREE` Referee >- `REFEREE_ASSISTANT` Referee Assistant >- `REFEREE_ASSISTANT_RESERVE` Reserve Assistant Referee >- `REFEREE_OBSERVER` Referee Observer >- `REFEREE_RESERVE` Reserve Referee >- `SCOREKEEPER` Scorekeeper >- `SCOREKEEPER_ASSISTANT` Assistant Scorekeeper >- `SCORER` Scorer >- `SCORER_ASSISTANT` Assistant Scorer >- `SCOUT_1` Scout 1 >- `SCOUT_2` Scout 2 >- `SCOUT_SUPERVISOR` Scout Supervisor >- `SECRETARY` Secretary >- `SHOT_CLOCK_OPERATOR` Shot Clock Operator >- `STATISTICIAN` Statistician >- `TECHNICAL_OFFICIAL` Technical Official (TO) >- `TIMEKEEPER` Timekeeper >- `TIMER` Timer >- `TRAINER` Trainer >- `TRAINER_ASSISTANT` Assistant Trainer >- `TRANSLATOR` Translator >- `TREASURER` Treasurer >- `UMPIRE` Umpire >- `UMPIRE_1` Umpire 1 >- `UMPIRE_2` Umpire 2 >- `UMPIRE_RESERVE` Reserve Umpire (RU) >- `UMPIRE_VIDEO` Video Umpire (VU) >- `VIDEO_TECHNICIAN` Video Technician (VT) "
             ),
         ] = None,
         status: Annotated[
             Optional[StrictStr],
             Field(description="Status >- `ACTIVE` Active >- `INACTIVE` Inactive >- `PENDING` Pending "),
         ] = None,
         updated: Annotated[
@@ -1215,36 +1222,36 @@
         :type include: str
         :param limit: The maximum number of records to return. See [Pagination](#section/Introduction/Pagination) for more information.
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param person_id: The unique identifier of the person
         :type person_id: str
-        :param role: Role. Can specify multiple values delimited by comma. >- `CAPTAIN` Captain >- `CAPTAIN_VICE` Vice Captain >- `CEO` CEO >- `COACH` Coach >- `COACH_ASSISTANT` Assistant Coach >- `COACH_ASSISTANT_HEAD` Assistant Head Coach >- `COACH_ASSOCIATE_HEAD` Associate Head Coach >- `COACH_DEVELOPMENT` Development Coach >- `COACH_HEAD` Head Coach >- `COACH_HEAD_INTERIM` Interim Head Coach >- `COACH_OTHER` Other coaching staff >- `COACH_SC` Strengh and Conditioning Coach >- `COACH_SENIOR` Senior Coach >- `COACH_SPECIALIST` Specialist Coach >- `COMMISSIONER` Commissioner >- `COMMITTEE` Committee >- `CREW_CHIEF` Crew Chief >- `DIRECTOR` Director >- `DOCTOR` Doctor >- `GENERAL` General >- `GROUNDSKEEPER` Groundskeeper >- `JUDGE_SCORING` Scoring Judge (SJ) >- `JUDGE_TIMING` Timing Judge (TJ) >- `MANAGER` Manager >- `MATCH_OFFICIAL` Match Official >- `MEDIA_OFFICER` Media Officer >- `MEDICAL_STAFF` Medical Staff >- `OTHER` Other >- `PHYSIOTHERAPIST` Physiotherapist >- `PRESIDENT` President >- `PRESIDENT_VICE` Vice President >- `REFEREE` Referee >- `REFEREE_ASSISTANT` Referee Assistant >- `REFEREE_ASSISTANT_RESERVE` Reserve Assistant Referee >- `REFEREE_RESERVE` Reserve Referee >- `SCOREKEEPER` Scorekeeper >- `SCOREKEEPER_ASSISTANT` Assistant Scorekeeper >- `SCORER` Scorer >- `SCORER_ASSISTANT` Assistant Scorer >- `SECRETARY` Secretary >- `SHOT_CLOCK_OPERATOR` Shot Clock Operator >- `STATISTICIAN` Statistician >- `TECHNICAL_OFFICIAL` Technical Official (TO) >- `TIMEKEEPER` Timekeeper >- `TIMER` Timer >- `TRAINER` Trainer >- `TRAINER_ASSISTANT` Assitant Trainer >- `TRANSLATOR` Translator >- `TREASURER` Treasurer >- `UMPIRE` Umpire >- `UMPIRE_1` Umpire 1 >- `UMPIRE_2` Umpire 2 >- `UMPIRE_RESERVE` Reserve Umpire (RU) >- `UMPIRE_VIDEO` Video Umpire (VU) >- `VIDEO_TECHNICIAN` Video Technician (VT)
+        :param role: Role. Can specify multiple values delimited by comma. >- `ASSISTANT_REFEREE_1` Assistant Referee 1 >- `ASSISTANT_REFEREE_2` Assistant Referee 2 >- `CAPTAIN` Captain >- `CAPTAIN_VICE` Vice Captain >- `CEO` CEO >- `COACH` Coach >- `COACH_ASSISTANT` Assistant Coach >- `COACH_ASSISTANT_HEAD` Assistant Head Coach >- `COACH_ASSOCIATE_HEAD` Associate Head Coach >- `COACH_DEVELOPMENT` Development Coach >- `COACH_HEAD` Head Coach >- `COACH_HEAD_INTERIM` Interim Head Coach >- `COACH_OTHER` Other coaching staff >- `COACH_SC` Strength and Conditioning Coach >- `COACH_SENIOR` Senior Coach >- `COACH_SPECIALIST` Specialist Coach >- `COMMISSIONER` Commissioner >- `COMMITTEE` Committee >- `CREW_CHIEF` Crew Chief >- `DELEGATE` Delegate >- `DIRECTOR` Director >- `DOCTOR` Doctor >- `GENERAL` General >- `GROUNDSKEEPER` Groundskeeper >- `JUDGE_SCORING` Scoring Judge (SJ) >- `JUDGE_TIMING` Timing Judge (TJ) >- `MANAGER` Manager >- `MATCH_OFFICIAL` Match Official >- `MATCH_SUPERVISOR` Match Supervisor >- `MEDIA_OFFICER` Media Officer >- `MEDICAL_STAFF` Medical Staff >- `OTHER` Other >- `PHYSIOTHERAPIST` Physiotherapist >- `PRESIDENT` President >- `PRESIDENT_VICE` Vice President >- `REFEREE` Referee >- `REFEREE_ASSISTANT` Referee Assistant >- `REFEREE_ASSISTANT_RESERVE` Reserve Assistant Referee >- `REFEREE_OBSERVER` Referee Observer >- `REFEREE_RESERVE` Reserve Referee >- `SCOREKEEPER` Scorekeeper >- `SCOREKEEPER_ASSISTANT` Assistant Scorekeeper >- `SCORER` Scorer >- `SCORER_ASSISTANT` Assistant Scorer >- `SCOUT_1` Scout 1 >- `SCOUT_2` Scout 2 >- `SCOUT_SUPERVISOR` Scout Supervisor >- `SECRETARY` Secretary >- `SHOT_CLOCK_OPERATOR` Shot Clock Operator >- `STATISTICIAN` Statistician >- `TECHNICAL_OFFICIAL` Technical Official (TO) >- `TIMEKEEPER` Timekeeper >- `TIMER` Timer >- `TRAINER` Trainer >- `TRAINER_ASSISTANT` Assistant Trainer >- `TRANSLATOR` Translator >- `TREASURER` Treasurer >- `UMPIRE` Umpire >- `UMPIRE_1` Umpire 1 >- `UMPIRE_2` Umpire 2 >- `UMPIRE_RESERVE` Reserve Umpire (RU) >- `UMPIRE_VIDEO` Video Umpire (VU) >- `VIDEO_TECHNICIAN` Video Technician (VT)
         :type role: str
         :param status: Status >- `ACTIVE` Active >- `INACTIVE` Inactive >- `PENDING` Pending
         :type status: str
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: RolesResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the roles_list_by_fixture_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.roles_list_by_fixture_with_http_info(
                 fixture_id,
                 organization_id,
                 sport,
                 added,
                 entity_id,
@@ -1310,26 +1317,26 @@
                 description="The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information."
             ),
         ] = None,
         person_id: Annotated[Optional[StrictStr], Field(description="The unique identifier of the person")] = None,
         role: Annotated[
             Optional[StrictStr],
             Field(
-                description="Role. Can specify multiple values delimited by comma. >- `CAPTAIN` Captain >- `CAPTAIN_VICE` Vice Captain >- `CEO` CEO >- `COACH` Coach >- `COACH_ASSISTANT` Assistant Coach >- `COACH_ASSISTANT_HEAD` Assistant Head Coach >- `COACH_ASSOCIATE_HEAD` Associate Head Coach >- `COACH_DEVELOPMENT` Development Coach >- `COACH_HEAD` Head Coach >- `COACH_HEAD_INTERIM` Interim Head Coach >- `COACH_OTHER` Other coaching staff >- `COACH_SC` Strengh and Conditioning Coach >- `COACH_SENIOR` Senior Coach >- `COACH_SPECIALIST` Specialist Coach >- `COMMISSIONER` Commissioner >- `COMMITTEE` Committee >- `CREW_CHIEF` Crew Chief >- `DIRECTOR` Director >- `DOCTOR` Doctor >- `GENERAL` General >- `GROUNDSKEEPER` Groundskeeper >- `JUDGE_SCORING` Scoring Judge (SJ) >- `JUDGE_TIMING` Timing Judge (TJ) >- `MANAGER` Manager >- `MATCH_OFFICIAL` Match Official >- `MEDIA_OFFICER` Media Officer >- `MEDICAL_STAFF` Medical Staff >- `OTHER` Other >- `PHYSIOTHERAPIST` Physiotherapist >- `PRESIDENT` President >- `PRESIDENT_VICE` Vice President >- `REFEREE` Referee >- `REFEREE_ASSISTANT` Referee Assistant >- `REFEREE_ASSISTANT_RESERVE` Reserve Assistant Referee >- `REFEREE_RESERVE` Reserve Referee >- `SCOREKEEPER` Scorekeeper >- `SCOREKEEPER_ASSISTANT` Assistant Scorekeeper >- `SCORER` Scorer >- `SCORER_ASSISTANT` Assistant Scorer >- `SECRETARY` Secretary >- `SHOT_CLOCK_OPERATOR` Shot Clock Operator >- `STATISTICIAN` Statistician >- `TECHNICAL_OFFICIAL` Technical Official (TO) >- `TIMEKEEPER` Timekeeper >- `TIMER` Timer >- `TRAINER` Trainer >- `TRAINER_ASSISTANT` Assitant Trainer >- `TRANSLATOR` Translator >- `TREASURER` Treasurer >- `UMPIRE` Umpire >- `UMPIRE_1` Umpire 1 >- `UMPIRE_2` Umpire 2 >- `UMPIRE_RESERVE` Reserve Umpire (RU) >- `UMPIRE_VIDEO` Video Umpire (VU) >- `VIDEO_TECHNICIAN` Video Technician (VT) "
+                description="Role. Can specify multiple values delimited by comma. >- `ASSISTANT_REFEREE_1` Assistant Referee 1 >- `ASSISTANT_REFEREE_2` Assistant Referee 2 >- `CAPTAIN` Captain >- `CAPTAIN_VICE` Vice Captain >- `CEO` CEO >- `COACH` Coach >- `COACH_ASSISTANT` Assistant Coach >- `COACH_ASSISTANT_HEAD` Assistant Head Coach >- `COACH_ASSOCIATE_HEAD` Associate Head Coach >- `COACH_DEVELOPMENT` Development Coach >- `COACH_HEAD` Head Coach >- `COACH_HEAD_INTERIM` Interim Head Coach >- `COACH_OTHER` Other coaching staff >- `COACH_SC` Strength and Conditioning Coach >- `COACH_SENIOR` Senior Coach >- `COACH_SPECIALIST` Specialist Coach >- `COMMISSIONER` Commissioner >- `COMMITTEE` Committee >- `CREW_CHIEF` Crew Chief >- `DELEGATE` Delegate >- `DIRECTOR` Director >- `DOCTOR` Doctor >- `GENERAL` General >- `GROUNDSKEEPER` Groundskeeper >- `JUDGE_SCORING` Scoring Judge (SJ) >- `JUDGE_TIMING` Timing Judge (TJ) >- `MANAGER` Manager >- `MATCH_OFFICIAL` Match Official >- `MATCH_SUPERVISOR` Match Supervisor >- `MEDIA_OFFICER` Media Officer >- `MEDICAL_STAFF` Medical Staff >- `OTHER` Other >- `PHYSIOTHERAPIST` Physiotherapist >- `PRESIDENT` President >- `PRESIDENT_VICE` Vice President >- `REFEREE` Referee >- `REFEREE_ASSISTANT` Referee Assistant >- `REFEREE_ASSISTANT_RESERVE` Reserve Assistant Referee >- `REFEREE_OBSERVER` Referee Observer >- `REFEREE_RESERVE` Reserve Referee >- `SCOREKEEPER` Scorekeeper >- `SCOREKEEPER_ASSISTANT` Assistant Scorekeeper >- `SCORER` Scorer >- `SCORER_ASSISTANT` Assistant Scorer >- `SCOUT_1` Scout 1 >- `SCOUT_2` Scout 2 >- `SCOUT_SUPERVISOR` Scout Supervisor >- `SECRETARY` Secretary >- `SHOT_CLOCK_OPERATOR` Shot Clock Operator >- `STATISTICIAN` Statistician >- `TECHNICAL_OFFICIAL` Technical Official (TO) >- `TIMEKEEPER` Timekeeper >- `TIMER` Timer >- `TRAINER` Trainer >- `TRAINER_ASSISTANT` Assistant Trainer >- `TRANSLATOR` Translator >- `TREASURER` Treasurer >- `UMPIRE` Umpire >- `UMPIRE_1` Umpire 1 >- `UMPIRE_2` Umpire 2 >- `UMPIRE_RESERVE` Reserve Umpire (RU) >- `UMPIRE_VIDEO` Video Umpire (VU) >- `VIDEO_TECHNICIAN` Video Technician (VT) "
             ),
         ] = None,
         status: Annotated[
             Optional[StrictStr],
             Field(description="Status >- `ACTIVE` Active >- `INACTIVE` Inactive >- `PENDING` Pending "),
         ] = None,
         updated: Annotated[
             Optional[datetime], Field(description="Record was modified after this date/time. In UTC.")
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Get a list of roles in a fixture  # noqa: E501
 
         Return a list of roles for a fixture  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.roles_list_by_fixture_with_http_info(fixture_id, organization_id, sport, added, entity_id, external, fields, hide_null, include, limit, offset, person_id, role, status, updated, async_req=True)
@@ -1355,29 +1362,30 @@
         :type include: str
         :param limit: The maximum number of records to return. See [Pagination](#section/Introduction/Pagination) for more information.
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param person_id: The unique identifier of the person
         :type person_id: str
-        :param role: Role. Can specify multiple values delimited by comma. >- `CAPTAIN` Captain >- `CAPTAIN_VICE` Vice Captain >- `CEO` CEO >- `COACH` Coach >- `COACH_ASSISTANT` Assistant Coach >- `COACH_ASSISTANT_HEAD` Assistant Head Coach >- `COACH_ASSOCIATE_HEAD` Associate Head Coach >- `COACH_DEVELOPMENT` Development Coach >- `COACH_HEAD` Head Coach >- `COACH_HEAD_INTERIM` Interim Head Coach >- `COACH_OTHER` Other coaching staff >- `COACH_SC` Strengh and Conditioning Coach >- `COACH_SENIOR` Senior Coach >- `COACH_SPECIALIST` Specialist Coach >- `COMMISSIONER` Commissioner >- `COMMITTEE` Committee >- `CREW_CHIEF` Crew Chief >- `DIRECTOR` Director >- `DOCTOR` Doctor >- `GENERAL` General >- `GROUNDSKEEPER` Groundskeeper >- `JUDGE_SCORING` Scoring Judge (SJ) >- `JUDGE_TIMING` Timing Judge (TJ) >- `MANAGER` Manager >- `MATCH_OFFICIAL` Match Official >- `MEDIA_OFFICER` Media Officer >- `MEDICAL_STAFF` Medical Staff >- `OTHER` Other >- `PHYSIOTHERAPIST` Physiotherapist >- `PRESIDENT` President >- `PRESIDENT_VICE` Vice President >- `REFEREE` Referee >- `REFEREE_ASSISTANT` Referee Assistant >- `REFEREE_ASSISTANT_RESERVE` Reserve Assistant Referee >- `REFEREE_RESERVE` Reserve Referee >- `SCOREKEEPER` Scorekeeper >- `SCOREKEEPER_ASSISTANT` Assistant Scorekeeper >- `SCORER` Scorer >- `SCORER_ASSISTANT` Assistant Scorer >- `SECRETARY` Secretary >- `SHOT_CLOCK_OPERATOR` Shot Clock Operator >- `STATISTICIAN` Statistician >- `TECHNICAL_OFFICIAL` Technical Official (TO) >- `TIMEKEEPER` Timekeeper >- `TIMER` Timer >- `TRAINER` Trainer >- `TRAINER_ASSISTANT` Assitant Trainer >- `TRANSLATOR` Translator >- `TREASURER` Treasurer >- `UMPIRE` Umpire >- `UMPIRE_1` Umpire 1 >- `UMPIRE_2` Umpire 2 >- `UMPIRE_RESERVE` Reserve Umpire (RU) >- `UMPIRE_VIDEO` Video Umpire (VU) >- `VIDEO_TECHNICIAN` Video Technician (VT)
+        :param role: Role. Can specify multiple values delimited by comma. >- `ASSISTANT_REFEREE_1` Assistant Referee 1 >- `ASSISTANT_REFEREE_2` Assistant Referee 2 >- `CAPTAIN` Captain >- `CAPTAIN_VICE` Vice Captain >- `CEO` CEO >- `COACH` Coach >- `COACH_ASSISTANT` Assistant Coach >- `COACH_ASSISTANT_HEAD` Assistant Head Coach >- `COACH_ASSOCIATE_HEAD` Associate Head Coach >- `COACH_DEVELOPMENT` Development Coach >- `COACH_HEAD` Head Coach >- `COACH_HEAD_INTERIM` Interim Head Coach >- `COACH_OTHER` Other coaching staff >- `COACH_SC` Strength and Conditioning Coach >- `COACH_SENIOR` Senior Coach >- `COACH_SPECIALIST` Specialist Coach >- `COMMISSIONER` Commissioner >- `COMMITTEE` Committee >- `CREW_CHIEF` Crew Chief >- `DELEGATE` Delegate >- `DIRECTOR` Director >- `DOCTOR` Doctor >- `GENERAL` General >- `GROUNDSKEEPER` Groundskeeper >- `JUDGE_SCORING` Scoring Judge (SJ) >- `JUDGE_TIMING` Timing Judge (TJ) >- `MANAGER` Manager >- `MATCH_OFFICIAL` Match Official >- `MATCH_SUPERVISOR` Match Supervisor >- `MEDIA_OFFICER` Media Officer >- `MEDICAL_STAFF` Medical Staff >- `OTHER` Other >- `PHYSIOTHERAPIST` Physiotherapist >- `PRESIDENT` President >- `PRESIDENT_VICE` Vice President >- `REFEREE` Referee >- `REFEREE_ASSISTANT` Referee Assistant >- `REFEREE_ASSISTANT_RESERVE` Reserve Assistant Referee >- `REFEREE_OBSERVER` Referee Observer >- `REFEREE_RESERVE` Reserve Referee >- `SCOREKEEPER` Scorekeeper >- `SCOREKEEPER_ASSISTANT` Assistant Scorekeeper >- `SCORER` Scorer >- `SCORER_ASSISTANT` Assistant Scorer >- `SCOUT_1` Scout 1 >- `SCOUT_2` Scout 2 >- `SCOUT_SUPERVISOR` Scout Supervisor >- `SECRETARY` Secretary >- `SHOT_CLOCK_OPERATOR` Shot Clock Operator >- `STATISTICIAN` Statistician >- `TECHNICAL_OFFICIAL` Technical Official (TO) >- `TIMEKEEPER` Timekeeper >- `TIMER` Timer >- `TRAINER` Trainer >- `TRAINER_ASSISTANT` Assistant Trainer >- `TRANSLATOR` Translator >- `TREASURER` Treasurer >- `UMPIRE` Umpire >- `UMPIRE_1` Umpire 1 >- `UMPIRE_2` Umpire 2 >- `UMPIRE_RESERVE` Reserve Umpire (RU) >- `UMPIRE_VIDEO` Video Umpire (VU) >- `VIDEO_TECHNICIAN` Video Technician (VT)
         :type role: str
         :param status: Status >- `ACTIVE` Active >- `INACTIVE` Inactive >- `PENDING` Pending
         :type status: str
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1471,18 +1479,18 @@
         if _params.get("offset") is not None:  # noqa: E501
             _query_params.append(("offset", _params["offset"]))
 
         if _params.get("person_id") is not None:  # noqa: E501
             _query_params.append(("personId", _params["person_id"]))
 
         if _params.get("role") is not None:  # noqa: E501
-            _query_params.append(("role", _params["role"]))
+            _query_params.append(("role", _params["role"].value))
 
         if _params.get("status") is not None:  # noqa: E501
-            _query_params.append(("status", _params["status"]))
+            _query_params.append(("status", _params["status"].value))
 
         if _params.get("updated") is not None:  # noqa: E501
             if isinstance(_params["updated"], datetime):
                 _query_params.append(
                     ("updated", _params["updated"].strftime(self.api_client.configuration.datetime_format))
                 )
             else:
@@ -1569,15 +1577,15 @@
                 description="The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information."
             ),
         ] = None,
         person_id: Annotated[Optional[StrictStr], Field(description="The unique identifier of the person")] = None,
         role: Annotated[
             Optional[StrictStr],
             Field(
-                description="Role. Can specify multiple values delimited by comma. >- `CAPTAIN` Captain >- `CAPTAIN_VICE` Vice Captain >- `CEO` CEO >- `COACH` Coach >- `COACH_ASSISTANT` Assistant Coach >- `COACH_ASSISTANT_HEAD` Assistant Head Coach >- `COACH_ASSOCIATE_HEAD` Associate Head Coach >- `COACH_DEVELOPMENT` Development Coach >- `COACH_HEAD` Head Coach >- `COACH_HEAD_INTERIM` Interim Head Coach >- `COACH_OTHER` Other coaching staff >- `COACH_SC` Strengh and Conditioning Coach >- `COACH_SENIOR` Senior Coach >- `COACH_SPECIALIST` Specialist Coach >- `COMMISSIONER` Commissioner >- `COMMITTEE` Committee >- `CREW_CHIEF` Crew Chief >- `DIRECTOR` Director >- `DOCTOR` Doctor >- `GENERAL` General >- `GROUNDSKEEPER` Groundskeeper >- `JUDGE_SCORING` Scoring Judge (SJ) >- `JUDGE_TIMING` Timing Judge (TJ) >- `MANAGER` Manager >- `MATCH_OFFICIAL` Match Official >- `MEDIA_OFFICER` Media Officer >- `MEDICAL_STAFF` Medical Staff >- `OTHER` Other >- `PHYSIOTHERAPIST` Physiotherapist >- `PRESIDENT` President >- `PRESIDENT_VICE` Vice President >- `REFEREE` Referee >- `REFEREE_ASSISTANT` Referee Assistant >- `REFEREE_ASSISTANT_RESERVE` Reserve Assistant Referee >- `REFEREE_RESERVE` Reserve Referee >- `SCOREKEEPER` Scorekeeper >- `SCOREKEEPER_ASSISTANT` Assistant Scorekeeper >- `SCORER` Scorer >- `SCORER_ASSISTANT` Assistant Scorer >- `SECRETARY` Secretary >- `SHOT_CLOCK_OPERATOR` Shot Clock Operator >- `STATISTICIAN` Statistician >- `TECHNICAL_OFFICIAL` Technical Official (TO) >- `TIMEKEEPER` Timekeeper >- `TIMER` Timer >- `TRAINER` Trainer >- `TRAINER_ASSISTANT` Assitant Trainer >- `TRANSLATOR` Translator >- `TREASURER` Treasurer >- `UMPIRE` Umpire >- `UMPIRE_1` Umpire 1 >- `UMPIRE_2` Umpire 2 >- `UMPIRE_RESERVE` Reserve Umpire (RU) >- `UMPIRE_VIDEO` Video Umpire (VU) >- `VIDEO_TECHNICIAN` Video Technician (VT) "
+                description="Role. Can specify multiple values delimited by comma. >- `ASSISTANT_REFEREE_1` Assistant Referee 1 >- `ASSISTANT_REFEREE_2` Assistant Referee 2 >- `CAPTAIN` Captain >- `CAPTAIN_VICE` Vice Captain >- `CEO` CEO >- `COACH` Coach >- `COACH_ASSISTANT` Assistant Coach >- `COACH_ASSISTANT_HEAD` Assistant Head Coach >- `COACH_ASSOCIATE_HEAD` Associate Head Coach >- `COACH_DEVELOPMENT` Development Coach >- `COACH_HEAD` Head Coach >- `COACH_HEAD_INTERIM` Interim Head Coach >- `COACH_OTHER` Other coaching staff >- `COACH_SC` Strength and Conditioning Coach >- `COACH_SENIOR` Senior Coach >- `COACH_SPECIALIST` Specialist Coach >- `COMMISSIONER` Commissioner >- `COMMITTEE` Committee >- `CREW_CHIEF` Crew Chief >- `DELEGATE` Delegate >- `DIRECTOR` Director >- `DOCTOR` Doctor >- `GENERAL` General >- `GROUNDSKEEPER` Groundskeeper >- `JUDGE_SCORING` Scoring Judge (SJ) >- `JUDGE_TIMING` Timing Judge (TJ) >- `MANAGER` Manager >- `MATCH_OFFICIAL` Match Official >- `MATCH_SUPERVISOR` Match Supervisor >- `MEDIA_OFFICER` Media Officer >- `MEDICAL_STAFF` Medical Staff >- `OTHER` Other >- `PHYSIOTHERAPIST` Physiotherapist >- `PRESIDENT` President >- `PRESIDENT_VICE` Vice President >- `REFEREE` Referee >- `REFEREE_ASSISTANT` Referee Assistant >- `REFEREE_ASSISTANT_RESERVE` Reserve Assistant Referee >- `REFEREE_OBSERVER` Referee Observer >- `REFEREE_RESERVE` Reserve Referee >- `SCOREKEEPER` Scorekeeper >- `SCOREKEEPER_ASSISTANT` Assistant Scorekeeper >- `SCORER` Scorer >- `SCORER_ASSISTANT` Assistant Scorer >- `SCOUT_1` Scout 1 >- `SCOUT_2` Scout 2 >- `SCOUT_SUPERVISOR` Scout Supervisor >- `SECRETARY` Secretary >- `SHOT_CLOCK_OPERATOR` Shot Clock Operator >- `STATISTICIAN` Statistician >- `TECHNICAL_OFFICIAL` Technical Official (TO) >- `TIMEKEEPER` Timekeeper >- `TIMER` Timer >- `TRAINER` Trainer >- `TRAINER_ASSISTANT` Assistant Trainer >- `TRANSLATOR` Translator >- `TREASURER` Treasurer >- `UMPIRE` Umpire >- `UMPIRE_1` Umpire 1 >- `UMPIRE_2` Umpire 2 >- `UMPIRE_RESERVE` Reserve Umpire (RU) >- `UMPIRE_VIDEO` Video Umpire (VU) >- `VIDEO_TECHNICIAN` Video Technician (VT) "
             ),
         ] = None,
         season_id: Annotated[Optional[StrictStr], Field(description="The unique identifier of the season")] = None,
         status: Annotated[
             Optional[StrictStr],
             Field(description="Status >- `ACTIVE` Active >- `INACTIVE` Inactive >- `PENDING` Pending "),
         ] = None,
@@ -1613,38 +1621,38 @@
         :type include: str
         :param limit: The maximum number of records to return. See [Pagination](#section/Introduction/Pagination) for more information.
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param person_id: The unique identifier of the person
         :type person_id: str
-        :param role: Role. Can specify multiple values delimited by comma. >- `CAPTAIN` Captain >- `CAPTAIN_VICE` Vice Captain >- `CEO` CEO >- `COACH` Coach >- `COACH_ASSISTANT` Assistant Coach >- `COACH_ASSISTANT_HEAD` Assistant Head Coach >- `COACH_ASSOCIATE_HEAD` Associate Head Coach >- `COACH_DEVELOPMENT` Development Coach >- `COACH_HEAD` Head Coach >- `COACH_HEAD_INTERIM` Interim Head Coach >- `COACH_OTHER` Other coaching staff >- `COACH_SC` Strengh and Conditioning Coach >- `COACH_SENIOR` Senior Coach >- `COACH_SPECIALIST` Specialist Coach >- `COMMISSIONER` Commissioner >- `COMMITTEE` Committee >- `CREW_CHIEF` Crew Chief >- `DIRECTOR` Director >- `DOCTOR` Doctor >- `GENERAL` General >- `GROUNDSKEEPER` Groundskeeper >- `JUDGE_SCORING` Scoring Judge (SJ) >- `JUDGE_TIMING` Timing Judge (TJ) >- `MANAGER` Manager >- `MATCH_OFFICIAL` Match Official >- `MEDIA_OFFICER` Media Officer >- `MEDICAL_STAFF` Medical Staff >- `OTHER` Other >- `PHYSIOTHERAPIST` Physiotherapist >- `PRESIDENT` President >- `PRESIDENT_VICE` Vice President >- `REFEREE` Referee >- `REFEREE_ASSISTANT` Referee Assistant >- `REFEREE_ASSISTANT_RESERVE` Reserve Assistant Referee >- `REFEREE_RESERVE` Reserve Referee >- `SCOREKEEPER` Scorekeeper >- `SCOREKEEPER_ASSISTANT` Assistant Scorekeeper >- `SCORER` Scorer >- `SCORER_ASSISTANT` Assistant Scorer >- `SECRETARY` Secretary >- `SHOT_CLOCK_OPERATOR` Shot Clock Operator >- `STATISTICIAN` Statistician >- `TECHNICAL_OFFICIAL` Technical Official (TO) >- `TIMEKEEPER` Timekeeper >- `TIMER` Timer >- `TRAINER` Trainer >- `TRAINER_ASSISTANT` Assitant Trainer >- `TRANSLATOR` Translator >- `TREASURER` Treasurer >- `UMPIRE` Umpire >- `UMPIRE_1` Umpire 1 >- `UMPIRE_2` Umpire 2 >- `UMPIRE_RESERVE` Reserve Umpire (RU) >- `UMPIRE_VIDEO` Video Umpire (VU) >- `VIDEO_TECHNICIAN` Video Technician (VT)
+        :param role: Role. Can specify multiple values delimited by comma. >- `ASSISTANT_REFEREE_1` Assistant Referee 1 >- `ASSISTANT_REFEREE_2` Assistant Referee 2 >- `CAPTAIN` Captain >- `CAPTAIN_VICE` Vice Captain >- `CEO` CEO >- `COACH` Coach >- `COACH_ASSISTANT` Assistant Coach >- `COACH_ASSISTANT_HEAD` Assistant Head Coach >- `COACH_ASSOCIATE_HEAD` Associate Head Coach >- `COACH_DEVELOPMENT` Development Coach >- `COACH_HEAD` Head Coach >- `COACH_HEAD_INTERIM` Interim Head Coach >- `COACH_OTHER` Other coaching staff >- `COACH_SC` Strength and Conditioning Coach >- `COACH_SENIOR` Senior Coach >- `COACH_SPECIALIST` Specialist Coach >- `COMMISSIONER` Commissioner >- `COMMITTEE` Committee >- `CREW_CHIEF` Crew Chief >- `DELEGATE` Delegate >- `DIRECTOR` Director >- `DOCTOR` Doctor >- `GENERAL` General >- `GROUNDSKEEPER` Groundskeeper >- `JUDGE_SCORING` Scoring Judge (SJ) >- `JUDGE_TIMING` Timing Judge (TJ) >- `MANAGER` Manager >- `MATCH_OFFICIAL` Match Official >- `MATCH_SUPERVISOR` Match Supervisor >- `MEDIA_OFFICER` Media Officer >- `MEDICAL_STAFF` Medical Staff >- `OTHER` Other >- `PHYSIOTHERAPIST` Physiotherapist >- `PRESIDENT` President >- `PRESIDENT_VICE` Vice President >- `REFEREE` Referee >- `REFEREE_ASSISTANT` Referee Assistant >- `REFEREE_ASSISTANT_RESERVE` Reserve Assistant Referee >- `REFEREE_OBSERVER` Referee Observer >- `REFEREE_RESERVE` Reserve Referee >- `SCOREKEEPER` Scorekeeper >- `SCOREKEEPER_ASSISTANT` Assistant Scorekeeper >- `SCORER` Scorer >- `SCORER_ASSISTANT` Assistant Scorer >- `SCOUT_1` Scout 1 >- `SCOUT_2` Scout 2 >- `SCOUT_SUPERVISOR` Scout Supervisor >- `SECRETARY` Secretary >- `SHOT_CLOCK_OPERATOR` Shot Clock Operator >- `STATISTICIAN` Statistician >- `TECHNICAL_OFFICIAL` Technical Official (TO) >- `TIMEKEEPER` Timekeeper >- `TIMER` Timer >- `TRAINER` Trainer >- `TRAINER_ASSISTANT` Assistant Trainer >- `TRANSLATOR` Translator >- `TREASURER` Treasurer >- `UMPIRE` Umpire >- `UMPIRE_1` Umpire 1 >- `UMPIRE_2` Umpire 2 >- `UMPIRE_RESERVE` Reserve Umpire (RU) >- `UMPIRE_VIDEO` Video Umpire (VU) >- `VIDEO_TECHNICIAN` Video Technician (VT)
         :type role: str
         :param season_id: The unique identifier of the season
         :type season_id: str
         :param status: Status >- `ACTIVE` Active >- `INACTIVE` Inactive >- `PENDING` Pending
         :type status: str
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: RolesResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the roles_list_fixtures_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.roles_list_fixtures_with_http_info(
                 organization_id,
                 sport,
                 added,
                 entity_id,
                 external,
@@ -1709,27 +1717,27 @@
                 description="The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information."
             ),
         ] = None,
         person_id: Annotated[Optional[StrictStr], Field(description="The unique identifier of the person")] = None,
         role: Annotated[
             Optional[StrictStr],
             Field(
-                description="Role. Can specify multiple values delimited by comma. >- `CAPTAIN` Captain >- `CAPTAIN_VICE` Vice Captain >- `CEO` CEO >- `COACH` Coach >- `COACH_ASSISTANT` Assistant Coach >- `COACH_ASSISTANT_HEAD` Assistant Head Coach >- `COACH_ASSOCIATE_HEAD` Associate Head Coach >- `COACH_DEVELOPMENT` Development Coach >- `COACH_HEAD` Head Coach >- `COACH_HEAD_INTERIM` Interim Head Coach >- `COACH_OTHER` Other coaching staff >- `COACH_SC` Strengh and Conditioning Coach >- `COACH_SENIOR` Senior Coach >- `COACH_SPECIALIST` Specialist Coach >- `COMMISSIONER` Commissioner >- `COMMITTEE` Committee >- `CREW_CHIEF` Crew Chief >- `DIRECTOR` Director >- `DOCTOR` Doctor >- `GENERAL` General >- `GROUNDSKEEPER` Groundskeeper >- `JUDGE_SCORING` Scoring Judge (SJ) >- `JUDGE_TIMING` Timing Judge (TJ) >- `MANAGER` Manager >- `MATCH_OFFICIAL` Match Official >- `MEDIA_OFFICER` Media Officer >- `MEDICAL_STAFF` Medical Staff >- `OTHER` Other >- `PHYSIOTHERAPIST` Physiotherapist >- `PRESIDENT` President >- `PRESIDENT_VICE` Vice President >- `REFEREE` Referee >- `REFEREE_ASSISTANT` Referee Assistant >- `REFEREE_ASSISTANT_RESERVE` Reserve Assistant Referee >- `REFEREE_RESERVE` Reserve Referee >- `SCOREKEEPER` Scorekeeper >- `SCOREKEEPER_ASSISTANT` Assistant Scorekeeper >- `SCORER` Scorer >- `SCORER_ASSISTANT` Assistant Scorer >- `SECRETARY` Secretary >- `SHOT_CLOCK_OPERATOR` Shot Clock Operator >- `STATISTICIAN` Statistician >- `TECHNICAL_OFFICIAL` Technical Official (TO) >- `TIMEKEEPER` Timekeeper >- `TIMER` Timer >- `TRAINER` Trainer >- `TRAINER_ASSISTANT` Assitant Trainer >- `TRANSLATOR` Translator >- `TREASURER` Treasurer >- `UMPIRE` Umpire >- `UMPIRE_1` Umpire 1 >- `UMPIRE_2` Umpire 2 >- `UMPIRE_RESERVE` Reserve Umpire (RU) >- `UMPIRE_VIDEO` Video Umpire (VU) >- `VIDEO_TECHNICIAN` Video Technician (VT) "
+                description="Role. Can specify multiple values delimited by comma. >- `ASSISTANT_REFEREE_1` Assistant Referee 1 >- `ASSISTANT_REFEREE_2` Assistant Referee 2 >- `CAPTAIN` Captain >- `CAPTAIN_VICE` Vice Captain >- `CEO` CEO >- `COACH` Coach >- `COACH_ASSISTANT` Assistant Coach >- `COACH_ASSISTANT_HEAD` Assistant Head Coach >- `COACH_ASSOCIATE_HEAD` Associate Head Coach >- `COACH_DEVELOPMENT` Development Coach >- `COACH_HEAD` Head Coach >- `COACH_HEAD_INTERIM` Interim Head Coach >- `COACH_OTHER` Other coaching staff >- `COACH_SC` Strength and Conditioning Coach >- `COACH_SENIOR` Senior Coach >- `COACH_SPECIALIST` Specialist Coach >- `COMMISSIONER` Commissioner >- `COMMITTEE` Committee >- `CREW_CHIEF` Crew Chief >- `DELEGATE` Delegate >- `DIRECTOR` Director >- `DOCTOR` Doctor >- `GENERAL` General >- `GROUNDSKEEPER` Groundskeeper >- `JUDGE_SCORING` Scoring Judge (SJ) >- `JUDGE_TIMING` Timing Judge (TJ) >- `MANAGER` Manager >- `MATCH_OFFICIAL` Match Official >- `MATCH_SUPERVISOR` Match Supervisor >- `MEDIA_OFFICER` Media Officer >- `MEDICAL_STAFF` Medical Staff >- `OTHER` Other >- `PHYSIOTHERAPIST` Physiotherapist >- `PRESIDENT` President >- `PRESIDENT_VICE` Vice President >- `REFEREE` Referee >- `REFEREE_ASSISTANT` Referee Assistant >- `REFEREE_ASSISTANT_RESERVE` Reserve Assistant Referee >- `REFEREE_OBSERVER` Referee Observer >- `REFEREE_RESERVE` Reserve Referee >- `SCOREKEEPER` Scorekeeper >- `SCOREKEEPER_ASSISTANT` Assistant Scorekeeper >- `SCORER` Scorer >- `SCORER_ASSISTANT` Assistant Scorer >- `SCOUT_1` Scout 1 >- `SCOUT_2` Scout 2 >- `SCOUT_SUPERVISOR` Scout Supervisor >- `SECRETARY` Secretary >- `SHOT_CLOCK_OPERATOR` Shot Clock Operator >- `STATISTICIAN` Statistician >- `TECHNICAL_OFFICIAL` Technical Official (TO) >- `TIMEKEEPER` Timekeeper >- `TIMER` Timer >- `TRAINER` Trainer >- `TRAINER_ASSISTANT` Assistant Trainer >- `TRANSLATOR` Translator >- `TREASURER` Treasurer >- `UMPIRE` Umpire >- `UMPIRE_1` Umpire 1 >- `UMPIRE_2` Umpire 2 >- `UMPIRE_RESERVE` Reserve Umpire (RU) >- `UMPIRE_VIDEO` Video Umpire (VU) >- `VIDEO_TECHNICIAN` Video Technician (VT) "
             ),
         ] = None,
         season_id: Annotated[Optional[StrictStr], Field(description="The unique identifier of the season")] = None,
         status: Annotated[
             Optional[StrictStr],
             Field(description="Status >- `ACTIVE` Active >- `INACTIVE` Inactive >- `PENDING` Pending "),
         ] = None,
         updated: Annotated[
             Optional[datetime], Field(description="Record was modified after this date/time. In UTC.")
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Get a list of fixture roles  # noqa: E501
 
         Return a list of roles for the organization (linked to fixtures)  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.roles_list_fixtures_with_http_info(organization_id, sport, added, entity_id, external, fields, hide_null, include, limit, offset, person_id, role, season_id, status, updated, async_req=True)
@@ -1753,31 +1761,32 @@
         :type include: str
         :param limit: The maximum number of records to return. See [Pagination](#section/Introduction/Pagination) for more information.
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param person_id: The unique identifier of the person
         :type person_id: str
-        :param role: Role. Can specify multiple values delimited by comma. >- `CAPTAIN` Captain >- `CAPTAIN_VICE` Vice Captain >- `CEO` CEO >- `COACH` Coach >- `COACH_ASSISTANT` Assistant Coach >- `COACH_ASSISTANT_HEAD` Assistant Head Coach >- `COACH_ASSOCIATE_HEAD` Associate Head Coach >- `COACH_DEVELOPMENT` Development Coach >- `COACH_HEAD` Head Coach >- `COACH_HEAD_INTERIM` Interim Head Coach >- `COACH_OTHER` Other coaching staff >- `COACH_SC` Strengh and Conditioning Coach >- `COACH_SENIOR` Senior Coach >- `COACH_SPECIALIST` Specialist Coach >- `COMMISSIONER` Commissioner >- `COMMITTEE` Committee >- `CREW_CHIEF` Crew Chief >- `DIRECTOR` Director >- `DOCTOR` Doctor >- `GENERAL` General >- `GROUNDSKEEPER` Groundskeeper >- `JUDGE_SCORING` Scoring Judge (SJ) >- `JUDGE_TIMING` Timing Judge (TJ) >- `MANAGER` Manager >- `MATCH_OFFICIAL` Match Official >- `MEDIA_OFFICER` Media Officer >- `MEDICAL_STAFF` Medical Staff >- `OTHER` Other >- `PHYSIOTHERAPIST` Physiotherapist >- `PRESIDENT` President >- `PRESIDENT_VICE` Vice President >- `REFEREE` Referee >- `REFEREE_ASSISTANT` Referee Assistant >- `REFEREE_ASSISTANT_RESERVE` Reserve Assistant Referee >- `REFEREE_RESERVE` Reserve Referee >- `SCOREKEEPER` Scorekeeper >- `SCOREKEEPER_ASSISTANT` Assistant Scorekeeper >- `SCORER` Scorer >- `SCORER_ASSISTANT` Assistant Scorer >- `SECRETARY` Secretary >- `SHOT_CLOCK_OPERATOR` Shot Clock Operator >- `STATISTICIAN` Statistician >- `TECHNICAL_OFFICIAL` Technical Official (TO) >- `TIMEKEEPER` Timekeeper >- `TIMER` Timer >- `TRAINER` Trainer >- `TRAINER_ASSISTANT` Assitant Trainer >- `TRANSLATOR` Translator >- `TREASURER` Treasurer >- `UMPIRE` Umpire >- `UMPIRE_1` Umpire 1 >- `UMPIRE_2` Umpire 2 >- `UMPIRE_RESERVE` Reserve Umpire (RU) >- `UMPIRE_VIDEO` Video Umpire (VU) >- `VIDEO_TECHNICIAN` Video Technician (VT)
+        :param role: Role. Can specify multiple values delimited by comma. >- `ASSISTANT_REFEREE_1` Assistant Referee 1 >- `ASSISTANT_REFEREE_2` Assistant Referee 2 >- `CAPTAIN` Captain >- `CAPTAIN_VICE` Vice Captain >- `CEO` CEO >- `COACH` Coach >- `COACH_ASSISTANT` Assistant Coach >- `COACH_ASSISTANT_HEAD` Assistant Head Coach >- `COACH_ASSOCIATE_HEAD` Associate Head Coach >- `COACH_DEVELOPMENT` Development Coach >- `COACH_HEAD` Head Coach >- `COACH_HEAD_INTERIM` Interim Head Coach >- `COACH_OTHER` Other coaching staff >- `COACH_SC` Strength and Conditioning Coach >- `COACH_SENIOR` Senior Coach >- `COACH_SPECIALIST` Specialist Coach >- `COMMISSIONER` Commissioner >- `COMMITTEE` Committee >- `CREW_CHIEF` Crew Chief >- `DELEGATE` Delegate >- `DIRECTOR` Director >- `DOCTOR` Doctor >- `GENERAL` General >- `GROUNDSKEEPER` Groundskeeper >- `JUDGE_SCORING` Scoring Judge (SJ) >- `JUDGE_TIMING` Timing Judge (TJ) >- `MANAGER` Manager >- `MATCH_OFFICIAL` Match Official >- `MATCH_SUPERVISOR` Match Supervisor >- `MEDIA_OFFICER` Media Officer >- `MEDICAL_STAFF` Medical Staff >- `OTHER` Other >- `PHYSIOTHERAPIST` Physiotherapist >- `PRESIDENT` President >- `PRESIDENT_VICE` Vice President >- `REFEREE` Referee >- `REFEREE_ASSISTANT` Referee Assistant >- `REFEREE_ASSISTANT_RESERVE` Reserve Assistant Referee >- `REFEREE_OBSERVER` Referee Observer >- `REFEREE_RESERVE` Reserve Referee >- `SCOREKEEPER` Scorekeeper >- `SCOREKEEPER_ASSISTANT` Assistant Scorekeeper >- `SCORER` Scorer >- `SCORER_ASSISTANT` Assistant Scorer >- `SCOUT_1` Scout 1 >- `SCOUT_2` Scout 2 >- `SCOUT_SUPERVISOR` Scout Supervisor >- `SECRETARY` Secretary >- `SHOT_CLOCK_OPERATOR` Shot Clock Operator >- `STATISTICIAN` Statistician >- `TECHNICAL_OFFICIAL` Technical Official (TO) >- `TIMEKEEPER` Timekeeper >- `TIMER` Timer >- `TRAINER` Trainer >- `TRAINER_ASSISTANT` Assistant Trainer >- `TRANSLATOR` Translator >- `TREASURER` Treasurer >- `UMPIRE` Umpire >- `UMPIRE_1` Umpire 1 >- `UMPIRE_2` Umpire 2 >- `UMPIRE_RESERVE` Reserve Umpire (RU) >- `UMPIRE_VIDEO` Video Umpire (VU) >- `VIDEO_TECHNICIAN` Video Technician (VT)
         :type role: str
         :param season_id: The unique identifier of the season
         :type season_id: str
         :param status: Status >- `ACTIVE` Active >- `INACTIVE` Inactive >- `PENDING` Pending
         :type status: str
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1868,21 +1877,21 @@
         if _params.get("offset") is not None:  # noqa: E501
             _query_params.append(("offset", _params["offset"]))
 
         if _params.get("person_id") is not None:  # noqa: E501
             _query_params.append(("personId", _params["person_id"]))
 
         if _params.get("role") is not None:  # noqa: E501
-            _query_params.append(("role", _params["role"]))
+            _query_params.append(("role", _params["role"].value))
 
         if _params.get("season_id") is not None:  # noqa: E501
             _query_params.append(("seasonId", _params["season_id"]))
 
         if _params.get("status") is not None:  # noqa: E501
-            _query_params.append(("status", _params["status"]))
+            _query_params.append(("status", _params["status"].value))
 
         if _params.get("updated") is not None:  # noqa: E501
             if isinstance(_params["updated"], datetime):
                 _query_params.append(
                     ("updated", _params["updated"].strftime(self.api_client.configuration.datetime_format))
                 )
             else:
@@ -1973,15 +1982,15 @@
                 description="The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information."
             ),
         ] = None,
         person_id: Annotated[Optional[StrictStr], Field(description="The unique identifier of the person")] = None,
         role: Annotated[
             Optional[StrictStr],
             Field(
-                description="Role. Can specify multiple values delimited by comma. >- `CAPTAIN` Captain >- `CAPTAIN_VICE` Vice Captain >- `CEO` CEO >- `COACH` Coach >- `COACH_ASSISTANT` Assistant Coach >- `COACH_ASSISTANT_HEAD` Assistant Head Coach >- `COACH_ASSOCIATE_HEAD` Associate Head Coach >- `COACH_DEVELOPMENT` Development Coach >- `COACH_HEAD` Head Coach >- `COACH_HEAD_INTERIM` Interim Head Coach >- `COACH_OTHER` Other coaching staff >- `COACH_SC` Strengh and Conditioning Coach >- `COACH_SENIOR` Senior Coach >- `COACH_SPECIALIST` Specialist Coach >- `COMMISSIONER` Commissioner >- `COMMITTEE` Committee >- `CREW_CHIEF` Crew Chief >- `DIRECTOR` Director >- `DOCTOR` Doctor >- `GENERAL` General >- `GROUNDSKEEPER` Groundskeeper >- `JUDGE_SCORING` Scoring Judge (SJ) >- `JUDGE_TIMING` Timing Judge (TJ) >- `MANAGER` Manager >- `MATCH_OFFICIAL` Match Official >- `MEDIA_OFFICER` Media Officer >- `MEDICAL_STAFF` Medical Staff >- `OTHER` Other >- `PHYSIOTHERAPIST` Physiotherapist >- `PRESIDENT` President >- `PRESIDENT_VICE` Vice President >- `REFEREE` Referee >- `REFEREE_ASSISTANT` Referee Assistant >- `REFEREE_ASSISTANT_RESERVE` Reserve Assistant Referee >- `REFEREE_RESERVE` Reserve Referee >- `SCOREKEEPER` Scorekeeper >- `SCOREKEEPER_ASSISTANT` Assistant Scorekeeper >- `SCORER` Scorer >- `SCORER_ASSISTANT` Assistant Scorer >- `SECRETARY` Secretary >- `SHOT_CLOCK_OPERATOR` Shot Clock Operator >- `STATISTICIAN` Statistician >- `TECHNICAL_OFFICIAL` Technical Official (TO) >- `TIMEKEEPER` Timekeeper >- `TIMER` Timer >- `TRAINER` Trainer >- `TRAINER_ASSISTANT` Assitant Trainer >- `TRANSLATOR` Translator >- `TREASURER` Treasurer >- `UMPIRE` Umpire >- `UMPIRE_1` Umpire 1 >- `UMPIRE_2` Umpire 2 >- `UMPIRE_RESERVE` Reserve Umpire (RU) >- `UMPIRE_VIDEO` Video Umpire (VU) >- `VIDEO_TECHNICIAN` Video Technician (VT) "
+                description="Role. Can specify multiple values delimited by comma. >- `ASSISTANT_REFEREE_1` Assistant Referee 1 >- `ASSISTANT_REFEREE_2` Assistant Referee 2 >- `CAPTAIN` Captain >- `CAPTAIN_VICE` Vice Captain >- `CEO` CEO >- `COACH` Coach >- `COACH_ASSISTANT` Assistant Coach >- `COACH_ASSISTANT_HEAD` Assistant Head Coach >- `COACH_ASSOCIATE_HEAD` Associate Head Coach >- `COACH_DEVELOPMENT` Development Coach >- `COACH_HEAD` Head Coach >- `COACH_HEAD_INTERIM` Interim Head Coach >- `COACH_OTHER` Other coaching staff >- `COACH_SC` Strength and Conditioning Coach >- `COACH_SENIOR` Senior Coach >- `COACH_SPECIALIST` Specialist Coach >- `COMMISSIONER` Commissioner >- `COMMITTEE` Committee >- `CREW_CHIEF` Crew Chief >- `DELEGATE` Delegate >- `DIRECTOR` Director >- `DOCTOR` Doctor >- `GENERAL` General >- `GROUNDSKEEPER` Groundskeeper >- `JUDGE_SCORING` Scoring Judge (SJ) >- `JUDGE_TIMING` Timing Judge (TJ) >- `MANAGER` Manager >- `MATCH_OFFICIAL` Match Official >- `MATCH_SUPERVISOR` Match Supervisor >- `MEDIA_OFFICER` Media Officer >- `MEDICAL_STAFF` Medical Staff >- `OTHER` Other >- `PHYSIOTHERAPIST` Physiotherapist >- `PRESIDENT` President >- `PRESIDENT_VICE` Vice President >- `REFEREE` Referee >- `REFEREE_ASSISTANT` Referee Assistant >- `REFEREE_ASSISTANT_RESERVE` Reserve Assistant Referee >- `REFEREE_OBSERVER` Referee Observer >- `REFEREE_RESERVE` Reserve Referee >- `SCOREKEEPER` Scorekeeper >- `SCOREKEEPER_ASSISTANT` Assistant Scorekeeper >- `SCORER` Scorer >- `SCORER_ASSISTANT` Assistant Scorer >- `SCOUT_1` Scout 1 >- `SCOUT_2` Scout 2 >- `SCOUT_SUPERVISOR` Scout Supervisor >- `SECRETARY` Secretary >- `SHOT_CLOCK_OPERATOR` Shot Clock Operator >- `STATISTICIAN` Statistician >- `TECHNICAL_OFFICIAL` Technical Official (TO) >- `TIMEKEEPER` Timekeeper >- `TIMER` Timer >- `TRAINER` Trainer >- `TRAINER_ASSISTANT` Assistant Trainer >- `TRANSLATOR` Translator >- `TREASURER` Treasurer >- `UMPIRE` Umpire >- `UMPIRE_1` Umpire 1 >- `UMPIRE_2` Umpire 2 >- `UMPIRE_RESERVE` Reserve Umpire (RU) >- `UMPIRE_VIDEO` Video Umpire (VU) >- `VIDEO_TECHNICIAN` Video Technician (VT) "
             ),
         ] = None,
         season_id: Annotated[Optional[StrictStr], Field(description="The unique identifier of the season")] = None,
         status: Annotated[
             Optional[StrictStr],
             Field(description="Status >- `ACTIVE` Active >- `INACTIVE` Inactive >- `PENDING` Pending "),
         ] = None,
@@ -2025,38 +2034,38 @@
         :type include: str
         :param limit: The maximum number of records to return. See [Pagination](#section/Introduction/Pagination) for more information.
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param person_id: The unique identifier of the person
         :type person_id: str
-        :param role: Role. Can specify multiple values delimited by comma. >- `CAPTAIN` Captain >- `CAPTAIN_VICE` Vice Captain >- `CEO` CEO >- `COACH` Coach >- `COACH_ASSISTANT` Assistant Coach >- `COACH_ASSISTANT_HEAD` Assistant Head Coach >- `COACH_ASSOCIATE_HEAD` Associate Head Coach >- `COACH_DEVELOPMENT` Development Coach >- `COACH_HEAD` Head Coach >- `COACH_HEAD_INTERIM` Interim Head Coach >- `COACH_OTHER` Other coaching staff >- `COACH_SC` Strengh and Conditioning Coach >- `COACH_SENIOR` Senior Coach >- `COACH_SPECIALIST` Specialist Coach >- `COMMISSIONER` Commissioner >- `COMMITTEE` Committee >- `CREW_CHIEF` Crew Chief >- `DIRECTOR` Director >- `DOCTOR` Doctor >- `GENERAL` General >- `GROUNDSKEEPER` Groundskeeper >- `JUDGE_SCORING` Scoring Judge (SJ) >- `JUDGE_TIMING` Timing Judge (TJ) >- `MANAGER` Manager >- `MATCH_OFFICIAL` Match Official >- `MEDIA_OFFICER` Media Officer >- `MEDICAL_STAFF` Medical Staff >- `OTHER` Other >- `PHYSIOTHERAPIST` Physiotherapist >- `PRESIDENT` President >- `PRESIDENT_VICE` Vice President >- `REFEREE` Referee >- `REFEREE_ASSISTANT` Referee Assistant >- `REFEREE_ASSISTANT_RESERVE` Reserve Assistant Referee >- `REFEREE_RESERVE` Reserve Referee >- `SCOREKEEPER` Scorekeeper >- `SCOREKEEPER_ASSISTANT` Assistant Scorekeeper >- `SCORER` Scorer >- `SCORER_ASSISTANT` Assistant Scorer >- `SECRETARY` Secretary >- `SHOT_CLOCK_OPERATOR` Shot Clock Operator >- `STATISTICIAN` Statistician >- `TECHNICAL_OFFICIAL` Technical Official (TO) >- `TIMEKEEPER` Timekeeper >- `TIMER` Timer >- `TRAINER` Trainer >- `TRAINER_ASSISTANT` Assitant Trainer >- `TRANSLATOR` Translator >- `TREASURER` Treasurer >- `UMPIRE` Umpire >- `UMPIRE_1` Umpire 1 >- `UMPIRE_2` Umpire 2 >- `UMPIRE_RESERVE` Reserve Umpire (RU) >- `UMPIRE_VIDEO` Video Umpire (VU) >- `VIDEO_TECHNICIAN` Video Technician (VT)
+        :param role: Role. Can specify multiple values delimited by comma. >- `ASSISTANT_REFEREE_1` Assistant Referee 1 >- `ASSISTANT_REFEREE_2` Assistant Referee 2 >- `CAPTAIN` Captain >- `CAPTAIN_VICE` Vice Captain >- `CEO` CEO >- `COACH` Coach >- `COACH_ASSISTANT` Assistant Coach >- `COACH_ASSISTANT_HEAD` Assistant Head Coach >- `COACH_ASSOCIATE_HEAD` Associate Head Coach >- `COACH_DEVELOPMENT` Development Coach >- `COACH_HEAD` Head Coach >- `COACH_HEAD_INTERIM` Interim Head Coach >- `COACH_OTHER` Other coaching staff >- `COACH_SC` Strength and Conditioning Coach >- `COACH_SENIOR` Senior Coach >- `COACH_SPECIALIST` Specialist Coach >- `COMMISSIONER` Commissioner >- `COMMITTEE` Committee >- `CREW_CHIEF` Crew Chief >- `DELEGATE` Delegate >- `DIRECTOR` Director >- `DOCTOR` Doctor >- `GENERAL` General >- `GROUNDSKEEPER` Groundskeeper >- `JUDGE_SCORING` Scoring Judge (SJ) >- `JUDGE_TIMING` Timing Judge (TJ) >- `MANAGER` Manager >- `MATCH_OFFICIAL` Match Official >- `MATCH_SUPERVISOR` Match Supervisor >- `MEDIA_OFFICER` Media Officer >- `MEDICAL_STAFF` Medical Staff >- `OTHER` Other >- `PHYSIOTHERAPIST` Physiotherapist >- `PRESIDENT` President >- `PRESIDENT_VICE` Vice President >- `REFEREE` Referee >- `REFEREE_ASSISTANT` Referee Assistant >- `REFEREE_ASSISTANT_RESERVE` Reserve Assistant Referee >- `REFEREE_OBSERVER` Referee Observer >- `REFEREE_RESERVE` Reserve Referee >- `SCOREKEEPER` Scorekeeper >- `SCOREKEEPER_ASSISTANT` Assistant Scorekeeper >- `SCORER` Scorer >- `SCORER_ASSISTANT` Assistant Scorer >- `SCOUT_1` Scout 1 >- `SCOUT_2` Scout 2 >- `SCOUT_SUPERVISOR` Scout Supervisor >- `SECRETARY` Secretary >- `SHOT_CLOCK_OPERATOR` Shot Clock Operator >- `STATISTICIAN` Statistician >- `TECHNICAL_OFFICIAL` Technical Official (TO) >- `TIMEKEEPER` Timekeeper >- `TIMER` Timer >- `TRAINER` Trainer >- `TRAINER_ASSISTANT` Assistant Trainer >- `TRANSLATOR` Translator >- `TREASURER` Treasurer >- `UMPIRE` Umpire >- `UMPIRE_1` Umpire 1 >- `UMPIRE_2` Umpire 2 >- `UMPIRE_RESERVE` Reserve Umpire (RU) >- `UMPIRE_VIDEO` Video Umpire (VU) >- `VIDEO_TECHNICIAN` Video Technician (VT)
         :type role: str
         :param season_id: The unique identifier of the season
         :type season_id: str
         :param status: Status >- `ACTIVE` Active >- `INACTIVE` Inactive >- `PENDING` Pending
         :type status: str
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: RolesResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the roles_list_non_fixtures_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.roles_list_non_fixtures_with_http_info(
                 organization_id,
                 sport,
                 added,
                 date_from_end,
                 date_from_start,
@@ -2129,27 +2138,27 @@
                 description="The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information."
             ),
         ] = None,
         person_id: Annotated[Optional[StrictStr], Field(description="The unique identifier of the person")] = None,
         role: Annotated[
             Optional[StrictStr],
             Field(
-                description="Role. Can specify multiple values delimited by comma. >- `CAPTAIN` Captain >- `CAPTAIN_VICE` Vice Captain >- `CEO` CEO >- `COACH` Coach >- `COACH_ASSISTANT` Assistant Coach >- `COACH_ASSISTANT_HEAD` Assistant Head Coach >- `COACH_ASSOCIATE_HEAD` Associate Head Coach >- `COACH_DEVELOPMENT` Development Coach >- `COACH_HEAD` Head Coach >- `COACH_HEAD_INTERIM` Interim Head Coach >- `COACH_OTHER` Other coaching staff >- `COACH_SC` Strengh and Conditioning Coach >- `COACH_SENIOR` Senior Coach >- `COACH_SPECIALIST` Specialist Coach >- `COMMISSIONER` Commissioner >- `COMMITTEE` Committee >- `CREW_CHIEF` Crew Chief >- `DIRECTOR` Director >- `DOCTOR` Doctor >- `GENERAL` General >- `GROUNDSKEEPER` Groundskeeper >- `JUDGE_SCORING` Scoring Judge (SJ) >- `JUDGE_TIMING` Timing Judge (TJ) >- `MANAGER` Manager >- `MATCH_OFFICIAL` Match Official >- `MEDIA_OFFICER` Media Officer >- `MEDICAL_STAFF` Medical Staff >- `OTHER` Other >- `PHYSIOTHERAPIST` Physiotherapist >- `PRESIDENT` President >- `PRESIDENT_VICE` Vice President >- `REFEREE` Referee >- `REFEREE_ASSISTANT` Referee Assistant >- `REFEREE_ASSISTANT_RESERVE` Reserve Assistant Referee >- `REFEREE_RESERVE` Reserve Referee >- `SCOREKEEPER` Scorekeeper >- `SCOREKEEPER_ASSISTANT` Assistant Scorekeeper >- `SCORER` Scorer >- `SCORER_ASSISTANT` Assistant Scorer >- `SECRETARY` Secretary >- `SHOT_CLOCK_OPERATOR` Shot Clock Operator >- `STATISTICIAN` Statistician >- `TECHNICAL_OFFICIAL` Technical Official (TO) >- `TIMEKEEPER` Timekeeper >- `TIMER` Timer >- `TRAINER` Trainer >- `TRAINER_ASSISTANT` Assitant Trainer >- `TRANSLATOR` Translator >- `TREASURER` Treasurer >- `UMPIRE` Umpire >- `UMPIRE_1` Umpire 1 >- `UMPIRE_2` Umpire 2 >- `UMPIRE_RESERVE` Reserve Umpire (RU) >- `UMPIRE_VIDEO` Video Umpire (VU) >- `VIDEO_TECHNICIAN` Video Technician (VT) "
+                description="Role. Can specify multiple values delimited by comma. >- `ASSISTANT_REFEREE_1` Assistant Referee 1 >- `ASSISTANT_REFEREE_2` Assistant Referee 2 >- `CAPTAIN` Captain >- `CAPTAIN_VICE` Vice Captain >- `CEO` CEO >- `COACH` Coach >- `COACH_ASSISTANT` Assistant Coach >- `COACH_ASSISTANT_HEAD` Assistant Head Coach >- `COACH_ASSOCIATE_HEAD` Associate Head Coach >- `COACH_DEVELOPMENT` Development Coach >- `COACH_HEAD` Head Coach >- `COACH_HEAD_INTERIM` Interim Head Coach >- `COACH_OTHER` Other coaching staff >- `COACH_SC` Strength and Conditioning Coach >- `COACH_SENIOR` Senior Coach >- `COACH_SPECIALIST` Specialist Coach >- `COMMISSIONER` Commissioner >- `COMMITTEE` Committee >- `CREW_CHIEF` Crew Chief >- `DELEGATE` Delegate >- `DIRECTOR` Director >- `DOCTOR` Doctor >- `GENERAL` General >- `GROUNDSKEEPER` Groundskeeper >- `JUDGE_SCORING` Scoring Judge (SJ) >- `JUDGE_TIMING` Timing Judge (TJ) >- `MANAGER` Manager >- `MATCH_OFFICIAL` Match Official >- `MATCH_SUPERVISOR` Match Supervisor >- `MEDIA_OFFICER` Media Officer >- `MEDICAL_STAFF` Medical Staff >- `OTHER` Other >- `PHYSIOTHERAPIST` Physiotherapist >- `PRESIDENT` President >- `PRESIDENT_VICE` Vice President >- `REFEREE` Referee >- `REFEREE_ASSISTANT` Referee Assistant >- `REFEREE_ASSISTANT_RESERVE` Reserve Assistant Referee >- `REFEREE_OBSERVER` Referee Observer >- `REFEREE_RESERVE` Reserve Referee >- `SCOREKEEPER` Scorekeeper >- `SCOREKEEPER_ASSISTANT` Assistant Scorekeeper >- `SCORER` Scorer >- `SCORER_ASSISTANT` Assistant Scorer >- `SCOUT_1` Scout 1 >- `SCOUT_2` Scout 2 >- `SCOUT_SUPERVISOR` Scout Supervisor >- `SECRETARY` Secretary >- `SHOT_CLOCK_OPERATOR` Shot Clock Operator >- `STATISTICIAN` Statistician >- `TECHNICAL_OFFICIAL` Technical Official (TO) >- `TIMEKEEPER` Timekeeper >- `TIMER` Timer >- `TRAINER` Trainer >- `TRAINER_ASSISTANT` Assistant Trainer >- `TRANSLATOR` Translator >- `TREASURER` Treasurer >- `UMPIRE` Umpire >- `UMPIRE_1` Umpire 1 >- `UMPIRE_2` Umpire 2 >- `UMPIRE_RESERVE` Reserve Umpire (RU) >- `UMPIRE_VIDEO` Video Umpire (VU) >- `VIDEO_TECHNICIAN` Video Technician (VT) "
             ),
         ] = None,
         season_id: Annotated[Optional[StrictStr], Field(description="The unique identifier of the season")] = None,
         status: Annotated[
             Optional[StrictStr],
             Field(description="Status >- `ACTIVE` Active >- `INACTIVE` Inactive >- `PENDING` Pending "),
         ] = None,
         updated: Annotated[
             Optional[datetime], Field(description="Record was modified after this date/time. In UTC.")
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Get a list of non-fixture roles  # noqa: E501
 
         Return a list of roles for the organization (not linked to fixtures)  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.roles_list_non_fixtures_with_http_info(organization_id, sport, added, date_from_end, date_from_start, date_to_end, date_to_start, entity_id, external, fields, hide_null, include, limit, offset, person_id, role, season_id, status, updated, async_req=True)
@@ -2181,31 +2190,32 @@
         :type include: str
         :param limit: The maximum number of records to return. See [Pagination](#section/Introduction/Pagination) for more information.
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param person_id: The unique identifier of the person
         :type person_id: str
-        :param role: Role. Can specify multiple values delimited by comma. >- `CAPTAIN` Captain >- `CAPTAIN_VICE` Vice Captain >- `CEO` CEO >- `COACH` Coach >- `COACH_ASSISTANT` Assistant Coach >- `COACH_ASSISTANT_HEAD` Assistant Head Coach >- `COACH_ASSOCIATE_HEAD` Associate Head Coach >- `COACH_DEVELOPMENT` Development Coach >- `COACH_HEAD` Head Coach >- `COACH_HEAD_INTERIM` Interim Head Coach >- `COACH_OTHER` Other coaching staff >- `COACH_SC` Strengh and Conditioning Coach >- `COACH_SENIOR` Senior Coach >- `COACH_SPECIALIST` Specialist Coach >- `COMMISSIONER` Commissioner >- `COMMITTEE` Committee >- `CREW_CHIEF` Crew Chief >- `DIRECTOR` Director >- `DOCTOR` Doctor >- `GENERAL` General >- `GROUNDSKEEPER` Groundskeeper >- `JUDGE_SCORING` Scoring Judge (SJ) >- `JUDGE_TIMING` Timing Judge (TJ) >- `MANAGER` Manager >- `MATCH_OFFICIAL` Match Official >- `MEDIA_OFFICER` Media Officer >- `MEDICAL_STAFF` Medical Staff >- `OTHER` Other >- `PHYSIOTHERAPIST` Physiotherapist >- `PRESIDENT` President >- `PRESIDENT_VICE` Vice President >- `REFEREE` Referee >- `REFEREE_ASSISTANT` Referee Assistant >- `REFEREE_ASSISTANT_RESERVE` Reserve Assistant Referee >- `REFEREE_RESERVE` Reserve Referee >- `SCOREKEEPER` Scorekeeper >- `SCOREKEEPER_ASSISTANT` Assistant Scorekeeper >- `SCORER` Scorer >- `SCORER_ASSISTANT` Assistant Scorer >- `SECRETARY` Secretary >- `SHOT_CLOCK_OPERATOR` Shot Clock Operator >- `STATISTICIAN` Statistician >- `TECHNICAL_OFFICIAL` Technical Official (TO) >- `TIMEKEEPER` Timekeeper >- `TIMER` Timer >- `TRAINER` Trainer >- `TRAINER_ASSISTANT` Assitant Trainer >- `TRANSLATOR` Translator >- `TREASURER` Treasurer >- `UMPIRE` Umpire >- `UMPIRE_1` Umpire 1 >- `UMPIRE_2` Umpire 2 >- `UMPIRE_RESERVE` Reserve Umpire (RU) >- `UMPIRE_VIDEO` Video Umpire (VU) >- `VIDEO_TECHNICIAN` Video Technician (VT)
+        :param role: Role. Can specify multiple values delimited by comma. >- `ASSISTANT_REFEREE_1` Assistant Referee 1 >- `ASSISTANT_REFEREE_2` Assistant Referee 2 >- `CAPTAIN` Captain >- `CAPTAIN_VICE` Vice Captain >- `CEO` CEO >- `COACH` Coach >- `COACH_ASSISTANT` Assistant Coach >- `COACH_ASSISTANT_HEAD` Assistant Head Coach >- `COACH_ASSOCIATE_HEAD` Associate Head Coach >- `COACH_DEVELOPMENT` Development Coach >- `COACH_HEAD` Head Coach >- `COACH_HEAD_INTERIM` Interim Head Coach >- `COACH_OTHER` Other coaching staff >- `COACH_SC` Strength and Conditioning Coach >- `COACH_SENIOR` Senior Coach >- `COACH_SPECIALIST` Specialist Coach >- `COMMISSIONER` Commissioner >- `COMMITTEE` Committee >- `CREW_CHIEF` Crew Chief >- `DELEGATE` Delegate >- `DIRECTOR` Director >- `DOCTOR` Doctor >- `GENERAL` General >- `GROUNDSKEEPER` Groundskeeper >- `JUDGE_SCORING` Scoring Judge (SJ) >- `JUDGE_TIMING` Timing Judge (TJ) >- `MANAGER` Manager >- `MATCH_OFFICIAL` Match Official >- `MATCH_SUPERVISOR` Match Supervisor >- `MEDIA_OFFICER` Media Officer >- `MEDICAL_STAFF` Medical Staff >- `OTHER` Other >- `PHYSIOTHERAPIST` Physiotherapist >- `PRESIDENT` President >- `PRESIDENT_VICE` Vice President >- `REFEREE` Referee >- `REFEREE_ASSISTANT` Referee Assistant >- `REFEREE_ASSISTANT_RESERVE` Reserve Assistant Referee >- `REFEREE_OBSERVER` Referee Observer >- `REFEREE_RESERVE` Reserve Referee >- `SCOREKEEPER` Scorekeeper >- `SCOREKEEPER_ASSISTANT` Assistant Scorekeeper >- `SCORER` Scorer >- `SCORER_ASSISTANT` Assistant Scorer >- `SCOUT_1` Scout 1 >- `SCOUT_2` Scout 2 >- `SCOUT_SUPERVISOR` Scout Supervisor >- `SECRETARY` Secretary >- `SHOT_CLOCK_OPERATOR` Shot Clock Operator >- `STATISTICIAN` Statistician >- `TECHNICAL_OFFICIAL` Technical Official (TO) >- `TIMEKEEPER` Timekeeper >- `TIMER` Timer >- `TRAINER` Trainer >- `TRAINER_ASSISTANT` Assistant Trainer >- `TRANSLATOR` Translator >- `TREASURER` Treasurer >- `UMPIRE` Umpire >- `UMPIRE_1` Umpire 1 >- `UMPIRE_2` Umpire 2 >- `UMPIRE_RESERVE` Reserve Umpire (RU) >- `UMPIRE_VIDEO` Video Umpire (VU) >- `VIDEO_TECHNICIAN` Video Technician (VT)
         :type role: str
         :param season_id: The unique identifier of the season
         :type season_id: str
         :param status: Status >- `ACTIVE` Active >- `INACTIVE` Inactive >- `PENDING` Pending
         :type status: str
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -2337,21 +2347,21 @@
         if _params.get("offset") is not None:  # noqa: E501
             _query_params.append(("offset", _params["offset"]))
 
         if _params.get("person_id") is not None:  # noqa: E501
             _query_params.append(("personId", _params["person_id"]))
 
         if _params.get("role") is not None:  # noqa: E501
-            _query_params.append(("role", _params["role"]))
+            _query_params.append(("role", _params["role"].value))
 
         if _params.get("season_id") is not None:  # noqa: E501
             _query_params.append(("seasonId", _params["season_id"]))
 
         if _params.get("status") is not None:  # noqa: E501
-            _query_params.append(("status", _params["status"]))
+            _query_params.append(("status", _params["status"].value))
 
         if _params.get("updated") is not None:  # noqa: E501
             if isinstance(_params["updated"], datetime):
                 _query_params.append(
                     ("updated", _params["updated"].strftime(self.api_client.configuration.datetime_format))
                 )
             else:
@@ -2449,28 +2459,28 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: RolesResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the roles_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.roles_update_with_http_info(
                 organization_id, role_id, sport, role_put_body, external, fields, hide_null, include, **kwargs
             )  # noqa: E501
         except Exception as e:
             logger.error("Exception when calling RolesApi->roles_update: %s\n" % e)
             raise
@@ -2503,15 +2513,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Update a role  # noqa: E501
 
         Change the information of a specific role  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.roles_update_with_http_info(organization_id, role_id, sport, role_put_body, external, fields, hide_null, include, async_req=True)
@@ -2531,21 +2541,22 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -2618,15 +2629,15 @@
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params["role_put_body"]:
+        if _params["role_put_body"] is not None:
             _body_params = _params["role_put_body"]
 
         # set the HTTP header `Accept`
         _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501
 
         # set the HTTP header `Content-Type`
         _content_types_list = _params.get(
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/api/season_entities_api.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/api/season_entities_api.py`

 * *Files 2% similar despite different names*

```diff
@@ -8,23 +8,26 @@
     The version of the OpenAPI document: v1
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the file manually.
 """
 
 
+import io
 import logging
 import re  # noqa: F401
+import warnings
 from datetime import datetime
 from typing import Optional
 
 from pydantic import Field, StrictBool, StrictInt, StrictStr, ValidationError, conint, constr, validate_arguments
 from typing_extensions import Annotated
 
 from atriumsports.datacore.openapi.api_client import ApiClient
+from atriumsports.datacore.openapi.api_response import ApiResponse
 from atriumsports.datacore.openapi.exceptions import ApiTypeError, ApiValueError  # noqa: F401
 from atriumsports.datacore.openapi.models.season_entities_list_response import SeasonEntitiesListResponse
 from atriumsports.datacore.openapi.models.season_entities_post_body import SeasonEntitiesPostBody
 from atriumsports.datacore.openapi.models.season_entities_response import SeasonEntitiesResponse
 
 logger = logging.getLogger("openapi")
 
@@ -105,28 +108,28 @@
         :type force_delete: bool
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: SeasonEntitiesResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the season_entities_delete_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.season_entities_delete_with_http_info(
                 entity_id,
                 organization_id,
                 season_id,
                 sport,
                 external,
@@ -174,15 +177,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Delete an entity from a season  # noqa: E501
 
         Delete a specific entity from a season  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.season_entities_delete_with_http_info(entity_id, organization_id, season_id, sport, external, fields, force_delete, hide_null, include, async_req=True)
@@ -204,21 +207,22 @@
         :type force_delete: bool
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -413,28 +417,28 @@
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: SeasonEntitiesResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the season_entities_detail_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.season_entities_detail_with_http_info(
                 entity_id,
                 organization_id,
                 season_id,
                 sport,
                 added,
@@ -497,15 +501,15 @@
                 description="The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information."
             ),
         ] = None,
         updated: Annotated[
             Optional[datetime], Field(description="Record was modified after this date/time. In UTC.")
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Get an entity in a season  # noqa: E501
 
         Return the detail of a specific entity in a season  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.season_entities_detail_with_http_info(entity_id, organization_id, season_id, sport, added, external, fields, hide_null, include, limit, offset, updated, async_req=True)
@@ -533,21 +537,22 @@
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -738,28 +743,28 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: SeasonEntitiesResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the season_entities_insert_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.season_entities_insert_update_with_http_info(
                 organization_id,
                 season_id,
                 sport,
                 season_entities_post_body,
                 external,
@@ -800,15 +805,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Add or Update an entity in a season  # noqa: E501
 
         Depending on primary keys, Add an entity or update an existing entitiy in a season  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.season_entities_insert_update_with_http_info(organization_id, season_id, sport, season_entities_post_body, external, fields, hide_null, include, async_req=True)
@@ -828,21 +833,22 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -917,15 +923,15 @@
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params["season_entities_post_body"]:
+        if _params["season_entities_post_body"] is not None:
             _body_params = _params["season_entities_post_body"]
 
         # set the HTTP header `Accept`
         _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501
 
         # set the HTTP header `Content-Type`
         _content_types_list = _params.get(
@@ -1039,28 +1045,28 @@
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: SeasonEntitiesListResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the season_entities_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.season_entities_list_with_http_info(
                 organization_id,
                 season_id,
                 sport,
                 added,
                 external,
@@ -1121,15 +1127,15 @@
                 description="The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information."
             ),
         ] = None,
         updated: Annotated[
             Optional[datetime], Field(description="Record was modified after this date/time. In UTC.")
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Get a list of entities in the season  # noqa: E501
 
         Return a list of entities for a season  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.season_entities_list_with_http_info(organization_id, season_id, sport, added, external, fields, hide_null, include, limit, offset, updated, async_req=True)
@@ -1155,21 +1161,22 @@
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1379,28 +1386,28 @@
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: SeasonEntitiesListResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the season_entity_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.season_entity_list_with_http_info(
                 entity_id,
                 organization_id,
                 sport,
                 added,
                 external,
@@ -1461,15 +1468,15 @@
                 description="The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information."
             ),
         ] = None,
         updated: Annotated[
             Optional[datetime], Field(description="Record was modified after this date/time. In UTC.")
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Get a list of seasons for an entity  # noqa: E501
 
         Return a list of seasons that an entity participated in  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.season_entity_list_with_http_info(entity_id, organization_id, sport, added, external, fields, hide_null, include, limit, offset, updated, async_req=True)
@@ -1495,21 +1502,22 @@
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/api/season_entity_base_statistics_api.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/api/season_entity_base_statistics_api.py`

 * *Files 2% similar despite different names*

```diff
@@ -8,23 +8,26 @@
     The version of the OpenAPI document: v1
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the file manually.
 """
 
 
+import io
 import logging
 import re  # noqa: F401
+import warnings
 from datetime import datetime
 from typing import Optional
 
 from pydantic import Field, StrictBool, StrictInt, StrictStr, ValidationError, conint, constr, validate_arguments
 from typing_extensions import Annotated
 
 from atriumsports.datacore.openapi.api_client import ApiClient
+from atriumsports.datacore.openapi.api_response import ApiResponse
 from atriumsports.datacore.openapi.exceptions import ApiTypeError, ApiValueError  # noqa: F401
 from atriumsports.datacore.openapi.models.season_entity_base_statistics_post_body import (
     SeasonEntityBaseStatisticsPostBody,
 )
 from atriumsports.datacore.openapi.models.season_entity_base_statistics_response import (
     SeasonEntityBaseStatisticsResponse,
 )
@@ -122,28 +125,28 @@
         :type force_delete: bool
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: SeasonEntityBaseStatisticsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the sebs_delete_all_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.sebs_delete_all_with_http_info(
                 organization_id,
                 season_id,
                 sport,
                 competitor_type,
                 entity_id,
@@ -203,15 +206,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Delete season entity base statistics  # noqa: E501
 
         Delete a base statistic record for an entity in a season.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.sebs_delete_all_with_http_info(organization_id, season_id, sport, competitor_type, entity_id, external, fields, fixture_type, force_delete, hide_null, include, async_req=True)
@@ -237,21 +240,22 @@
         :type force_delete: bool
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -309,27 +313,27 @@
 
         if _params["sport"]:
             _path_params["sport"] = _params["sport"]
 
         # process the query parameters
         _query_params = []
         if _params.get("competitor_type") is not None:  # noqa: E501
-            _query_params.append(("competitorType", _params["competitor_type"]))
+            _query_params.append(("competitorType", _params["competitor_type"].value))
 
         if _params.get("entity_id") is not None:  # noqa: E501
             _query_params.append(("entityId", _params["entity_id"]))
 
         if _params.get("external") is not None:  # noqa: E501
             _query_params.append(("external", _params["external"]))
 
         if _params.get("fields") is not None:  # noqa: E501
             _query_params.append(("fields", _params["fields"]))
 
         if _params.get("fixture_type") is not None:  # noqa: E501
-            _query_params.append(("fixtureType", _params["fixture_type"]))
+            _query_params.append(("fixtureType", _params["fixture_type"].value))
 
         if _params.get("force_delete") is not None:  # noqa: E501
             _query_params.append(("forceDelete", _params["force_delete"]))
 
         if _params.get("hide_null") is not None:  # noqa: E501
             _query_params.append(("hideNull", _params["hide_null"]))
 
@@ -425,28 +429,28 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: SeasonEntityBaseStatisticsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the sebs_insert_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.sebs_insert_update_with_http_info(
                 organization_id,
                 sport,
                 season_entity_base_statistics_post_body,
                 external,
                 fields,
@@ -485,15 +489,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Create/Update season entity base statistics  # noqa: E501
 
         Depending on the data, add or update a base statistic record for an entity in a season.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.sebs_insert_update_with_http_info(organization_id, sport, season_entity_base_statistics_post_body, external, fields, hide_null, include, async_req=True)
@@ -511,21 +515,22 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -594,15 +599,15 @@
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params["season_entity_base_statistics_post_body"]:
+        if _params["season_entity_base_statistics_post_body"] is not None:
             _body_params = _params["season_entity_base_statistics_post_body"]
 
         # set the HTTP header `Accept`
         _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501
 
         # set the HTTP header `Content-Type`
         _content_types_list = _params.get(
@@ -733,28 +738,28 @@
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: SeasonEntityBaseStatisticsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the sebs_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.sebs_list_with_http_info(
                 organization_id,
                 season_id,
                 sport,
                 added,
                 competitor_type,
@@ -829,15 +834,15 @@
                 description="The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information."
             ),
         ] = None,
         updated: Annotated[
             Optional[datetime], Field(description="Record was modified after this date/time. In UTC.")
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Entity season base statistics  # noqa: E501
 
         Return a list of entity base statistics for a season  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.sebs_list_with_http_info(organization_id, season_id, sport, added, competitor_type, entity_id, external, fields, fixture_type, hide_null, include, limit, offset, updated, async_req=True)
@@ -869,21 +874,22 @@
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -952,27 +958,27 @@
                 _query_params.append(
                     ("added", _params["added"].strftime(self.api_client.configuration.datetime_format))
                 )
             else:
                 _query_params.append(("added", _params["added"]))
 
         if _params.get("competitor_type") is not None:  # noqa: E501
-            _query_params.append(("competitorType", _params["competitor_type"]))
+            _query_params.append(("competitorType", _params["competitor_type"].value))
 
         if _params.get("entity_id") is not None:  # noqa: E501
             _query_params.append(("entityId", _params["entity_id"]))
 
         if _params.get("external") is not None:  # noqa: E501
             _query_params.append(("external", _params["external"]))
 
         if _params.get("fields") is not None:  # noqa: E501
             _query_params.append(("fields", _params["fields"]))
 
         if _params.get("fixture_type") is not None:  # noqa: E501
-            _query_params.append(("fixtureType", _params["fixture_type"]))
+            _query_params.append(("fixtureType", _params["fixture_type"].value))
 
         if _params.get("hide_null") is not None:  # noqa: E501
             _query_params.append(("hideNull", _params["hide_null"]))
 
         if _params.get("include") is not None:  # noqa: E501
             _query_params.append(("include", _params["include"]))
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/api/season_entity_placings_api.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/api/season_entity_placings_api.py`

 * *Files 3% similar despite different names*

```diff
@@ -8,23 +8,26 @@
     The version of the OpenAPI document: v1
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the file manually.
 """
 
 
+import io
 import logging
 import re  # noqa: F401
+import warnings
 from datetime import datetime
 from typing import Optional
 
 from pydantic import Field, StrictBool, StrictInt, StrictStr, ValidationError, conint, constr, validate_arguments
 from typing_extensions import Annotated
 
 from atriumsports.datacore.openapi.api_client import ApiClient
+from atriumsports.datacore.openapi.api_response import ApiResponse
 from atriumsports.datacore.openapi.exceptions import ApiTypeError, ApiValueError  # noqa: F401
 from atriumsports.datacore.openapi.models.season_entity_placings_response import SeasonEntityPlacingsResponse
 from atriumsports.datacore.openapi.models.seasonentity_placings_post_body import SEASONENTITYPlacingsPostBody
 from atriumsports.datacore.openapi.models.seasonentity_placings_put_body import SEASONENTITYPlacingsPutBody
 
 logger = logging.getLogger("openapi")
 
@@ -102,28 +105,28 @@
         :type force_delete: bool
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: SeasonEntityPlacingsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the sep_delete_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.sep_delete_with_http_info(
                 organization_id, placing_id, sport, external, fields, force_delete, hide_null, include, **kwargs
             )  # noqa: E501
         except Exception as e:
             logger.error("Exception when calling SeasonEntityPlacingsApi->sep_delete: %s\n" % e)
             raise
@@ -161,15 +164,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Delete a season entity placing  # noqa: E501
 
         Delete a specific season entity placing  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.sep_delete_with_http_info(organization_id, placing_id, sport, external, fields, force_delete, hide_null, include, async_req=True)
@@ -189,21 +192,22 @@
         :type force_delete: bool
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -381,28 +385,28 @@
         :type include: str
         :param limit: The maximum number of records to return. See [Pagination](#section/Introduction/Pagination) for more information.
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: SeasonEntityPlacingsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the sep_detail_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.sep_detail_with_http_info(
                 organization_id, placing_id, sport, external, fields, hide_null, include, limit, offset, **kwargs
             )  # noqa: E501
         except Exception as e:
             logger.error("Exception when calling SeasonEntityPlacingsApi->sep_detail: %s\n" % e)
             raise
@@ -446,15 +450,15 @@
         offset: Annotated[
             Optional[StrictInt],
             Field(
                 description="The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Get a season entity placing  # noqa: E501
 
         Return detailed information about a specific season entity placing  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.sep_detail_with_http_info(organization_id, placing_id, sport, external, fields, hide_null, include, limit, offset, async_req=True)
@@ -476,21 +480,22 @@
         :type include: str
         :param limit: The maximum number of records to return. See [Pagination](#section/Introduction/Pagination) for more information.
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -659,28 +664,28 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: SeasonEntityPlacingsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the sep_insert_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.sep_insert_with_http_info(
                 organization_id,
                 season_id,
                 sport,
                 seasonentity_placings_post_body,
                 external,
@@ -721,15 +726,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Create a new season entity placing  # noqa: E501
 
         Add a new season entity placing  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.sep_insert_with_http_info(organization_id, season_id, sport, seasonentity_placings_post_body, external, fields, hide_null, include, async_req=True)
@@ -749,21 +754,22 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -836,15 +842,15 @@
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params["seasonentity_placings_post_body"]:
+        if _params["seasonentity_placings_post_body"] is not None:
             _body_params = _params["seasonentity_placings_post_body"]
 
         # set the HTTP header `Accept`
         _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501
 
         # set the HTTP header `Content-Type`
         _content_types_list = _params.get(
@@ -961,28 +967,28 @@
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: SeasonEntityPlacingsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the sep_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.sep_list_with_http_info(
                 organization_id,
                 season_id,
                 sport,
                 added,
                 entity_id,
@@ -1045,15 +1051,15 @@
                 description="The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information."
             ),
         ] = None,
         updated: Annotated[
             Optional[datetime], Field(description="Record was modified after this date/time. In UTC.")
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Get a list of placings for entity in a season  # noqa: E501
 
         Return a list of final placings for an entity in a season  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.sep_list_with_http_info(organization_id, season_id, sport, added, entity_id, external, fields, hide_null, include, limit, offset, updated, async_req=True)
@@ -1081,21 +1087,22 @@
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1286,28 +1293,28 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: SeasonEntityPlacingsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the sep_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.sep_update_with_http_info(
                 organization_id,
                 placing_id,
                 sport,
                 seasonentity_placings_put_body,
                 external,
@@ -1348,15 +1355,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Update a specific season entity placing  # noqa: E501
 
         Change the information of a specific season entity placing  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.sep_update_with_http_info(organization_id, placing_id, sport, seasonentity_placings_put_body, external, fields, hide_null, include, async_req=True)
@@ -1376,21 +1383,22 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1463,15 +1471,15 @@
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params["seasonentity_placings_put_body"]:
+        if _params["seasonentity_placings_put_body"] is not None:
             _body_params = _params["seasonentity_placings_put_body"]
 
         # set the HTTP header `Accept`
         _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501
 
         # set the HTTP header `Content-Type`
         _content_types_list = _params.get(
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/api/season_leaders_api.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/api/season_leaders_api.py`

 * *Files 2% similar despite different names*

```diff
@@ -8,22 +8,25 @@
     The version of the OpenAPI document: v1
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the file manually.
 """
 
 
+import io
 import logging
 import re  # noqa: F401
+import warnings
 from typing import Optional
 
 from pydantic import Field, StrictBool, StrictInt, StrictStr, ValidationError, conint, constr, validate_arguments
 from typing_extensions import Annotated
 
 from atriumsports.datacore.openapi.api_client import ApiClient
+from atriumsports.datacore.openapi.api_response import ApiResponse
 from atriumsports.datacore.openapi.exceptions import ApiTypeError, ApiValueError  # noqa: F401
 from atriumsports.datacore.openapi.models.leader_summary_response import LeaderSummaryResponse
 from atriumsports.datacore.openapi.models.season_person_statistics_response import SeasonPersonStatisticsResponse
 
 logger = logging.getLogger("openapi")
 
 
@@ -146,28 +149,28 @@
         :type person_id: str
         :param starter: Is the person a starter in the fixture ?
         :type starter: bool
         :param win_loss: What the result was >- `DRAW` Draw >- `LOSS` Loss >- `WIN` Win
         :type win_loss: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: SeasonPersonStatisticsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the sl_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.sl_list_with_http_info(
                 organization_id,
                 season_id,
                 sport,
                 statistic,
                 entity_id,
@@ -249,15 +252,15 @@
         person_id: Annotated[Optional[StrictStr], Field(description="The unique identifier of the person")] = None,
         starter: Annotated[Optional[StrictBool], Field(description="Is the person a starter in the fixture ?")] = None,
         win_loss: Annotated[
             Optional[constr(strict=True, max_length=50)],
             Field(description="What the result was >- `DRAW` Draw >- `LOSS` Loss >- `WIN` Win "),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Season statistical leaders  # noqa: E501
 
         Return a list of the leading persons for a statistic in a season.  This call is similar to the person fixture statistics call~ however this call applies the qualification criteria (defined in the leaders qualification api calls) to each person.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.sl_list_with_http_info(organization_id, season_id, sport, statistic, entity_id, external, fields, fixture_type, hide_null, home_away, include, is_player, is_team_official, limit, offset, person_id, starter, win_loss, async_req=True)
@@ -297,21 +300,22 @@
         :type person_id: str
         :param starter: Is the person a starter in the fixture ?
         :type starter: bool
         :param win_loss: What the result was >- `DRAW` Draw >- `LOSS` Loss >- `WIN` Win
         :type win_loss: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -388,21 +392,21 @@
         if _params.get("external") is not None:  # noqa: E501
             _query_params.append(("external", _params["external"]))
 
         if _params.get("fields") is not None:  # noqa: E501
             _query_params.append(("fields", _params["fields"]))
 
         if _params.get("fixture_type") is not None:  # noqa: E501
-            _query_params.append(("fixtureType", _params["fixture_type"]))
+            _query_params.append(("fixtureType", _params["fixture_type"].value))
 
         if _params.get("hide_null") is not None:  # noqa: E501
             _query_params.append(("hideNull", _params["hide_null"]))
 
         if _params.get("home_away") is not None:  # noqa: E501
-            _query_params.append(("homeAway", _params["home_away"]))
+            _query_params.append(("homeAway", _params["home_away"].value))
 
         if _params.get("include") is not None:  # noqa: E501
             _query_params.append(("include", _params["include"]))
 
         if _params.get("is_player") is not None:  # noqa: E501
             _query_params.append(("isPlayer", _params["is_player"]))
 
@@ -418,15 +422,15 @@
         if _params.get("person_id") is not None:  # noqa: E501
             _query_params.append(("personId", _params["person_id"]))
 
         if _params.get("starter") is not None:  # noqa: E501
             _query_params.append(("starter", _params["starter"]))
 
         if _params.get("win_loss") is not None:  # noqa: E501
-            _query_params.append(("winLoss", _params["win_loss"]))
+            _query_params.append(("winLoss", _params["win_loss"].value))
 
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
@@ -570,28 +574,28 @@
         :type starter: bool
         :param statistics: The name of the statistic. Can specify multiple, delimited by comma.
         :type statistics: str
         :param win_loss: What the result was >- `DRAW` Draw >- `LOSS` Loss >- `WIN` Win
         :type win_loss: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: LeaderSummaryResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the sl_list_summary_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.sl_list_summary_with_http_info(
                 organization_id,
                 season_id,
                 sport,
                 entity_id,
                 external,
@@ -676,15 +680,15 @@
             Field(description="The name of the statistic. Can specify multiple, delimited by comma."),
         ] = None,
         win_loss: Annotated[
             Optional[constr(strict=True, max_length=50)],
             Field(description="What the result was >- `DRAW` Draw >- `LOSS` Loss >- `WIN` Win "),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Season statistical leader summary  # noqa: E501
 
         Return a summary of the leading persons for a number of statistics in a season.  This call allows you to specify multiple statistics at the same time.  It will return objects for each statistic.  In the 'statistics' object only the requested statistic will be returned, not all available statistics.  This call also applies the qualification criteria (defined in the leaders qualification api calls) to each person.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.sl_list_summary_with_http_info(organization_id, season_id, sport, entity_id, external, fields, fixture_type, hide_null, home_away, include, is_player, is_team_official, limit, offset, person_id, starter, statistics, win_loss, async_req=True)
@@ -724,21 +728,22 @@
         :type starter: bool
         :param statistics: The name of the statistic. Can specify multiple, delimited by comma.
         :type statistics: str
         :param win_loss: What the result was >- `DRAW` Draw >- `LOSS` Loss >- `WIN` Win
         :type win_loss: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -812,21 +817,21 @@
         if _params.get("external") is not None:  # noqa: E501
             _query_params.append(("external", _params["external"]))
 
         if _params.get("fields") is not None:  # noqa: E501
             _query_params.append(("fields", _params["fields"]))
 
         if _params.get("fixture_type") is not None:  # noqa: E501
-            _query_params.append(("fixtureType", _params["fixture_type"]))
+            _query_params.append(("fixtureType", _params["fixture_type"].value))
 
         if _params.get("hide_null") is not None:  # noqa: E501
             _query_params.append(("hideNull", _params["hide_null"]))
 
         if _params.get("home_away") is not None:  # noqa: E501
-            _query_params.append(("homeAway", _params["home_away"]))
+            _query_params.append(("homeAway", _params["home_away"].value))
 
         if _params.get("include") is not None:  # noqa: E501
             _query_params.append(("include", _params["include"]))
 
         if _params.get("is_player") is not None:  # noqa: E501
             _query_params.append(("isPlayer", _params["is_player"]))
 
@@ -845,15 +850,15 @@
         if _params.get("starter") is not None:  # noqa: E501
             _query_params.append(("starter", _params["starter"]))
 
         if _params.get("statistics") is not None:  # noqa: E501
             _query_params.append(("statistics", _params["statistics"]))
 
         if _params.get("win_loss") is not None:  # noqa: E501
-            _query_params.append(("winLoss", _params["win_loss"]))
+            _query_params.append(("winLoss", _params["win_loss"].value))
 
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/api/season_person_base_statistics_api.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/api/season_person_base_statistics_api.py`

 * *Files 5% similar despite different names*

```diff
@@ -8,23 +8,26 @@
     The version of the OpenAPI document: v1
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the file manually.
 """
 
 
+import io
 import logging
 import re  # noqa: F401
+import warnings
 from datetime import datetime
 from typing import Optional
 
 from pydantic import Field, StrictBool, StrictInt, StrictStr, ValidationError, conint, constr, validate_arguments
 from typing_extensions import Annotated
 
 from atriumsports.datacore.openapi.api_client import ApiClient
+from atriumsports.datacore.openapi.api_response import ApiResponse
 from atriumsports.datacore.openapi.exceptions import ApiTypeError, ApiValueError  # noqa: F401
 from atriumsports.datacore.openapi.models.season_person_base_statistics_post_body import (
     SeasonPersonBaseStatisticsPostBody,
 )
 from atriumsports.datacore.openapi.models.season_person_base_statistics_response import (
     SeasonPersonBaseStatisticsResponse,
 )
@@ -125,28 +128,28 @@
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param person_id: The unique identifier of the person
         :type person_id: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: SeasonPersonBaseStatisticsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the spbs_delete_all_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.spbs_delete_all_with_http_info(
                 organization_id,
                 season_id,
                 sport,
                 competitor_type,
                 entity_id,
@@ -208,15 +211,15 @@
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         person_id: Annotated[Optional[StrictStr], Field(description="The unique identifier of the person")] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Delete season person base statistics  # noqa: E501
 
         Delete a base statistic record for a person in a season.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.spbs_delete_all_with_http_info(organization_id, season_id, sport, competitor_type, entity_id, external, fields, fixture_type, force_delete, hide_null, include, person_id, async_req=True)
@@ -244,21 +247,22 @@
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param person_id: The unique identifier of the person
         :type person_id: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -317,27 +321,27 @@
 
         if _params["sport"]:
             _path_params["sport"] = _params["sport"]
 
         # process the query parameters
         _query_params = []
         if _params.get("competitor_type") is not None:  # noqa: E501
-            _query_params.append(("competitorType", _params["competitor_type"]))
+            _query_params.append(("competitorType", _params["competitor_type"].value))
 
         if _params.get("entity_id") is not None:  # noqa: E501
             _query_params.append(("entityId", _params["entity_id"]))
 
         if _params.get("external") is not None:  # noqa: E501
             _query_params.append(("external", _params["external"]))
 
         if _params.get("fields") is not None:  # noqa: E501
             _query_params.append(("fields", _params["fields"]))
 
         if _params.get("fixture_type") is not None:  # noqa: E501
-            _query_params.append(("fixtureType", _params["fixture_type"]))
+            _query_params.append(("fixtureType", _params["fixture_type"].value))
 
         if _params.get("force_delete") is not None:  # noqa: E501
             _query_params.append(("forceDelete", _params["force_delete"]))
 
         if _params.get("hide_null") is not None:  # noqa: E501
             _query_params.append(("hideNull", _params["hide_null"]))
 
@@ -436,28 +440,28 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: SeasonPersonBaseStatisticsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the spbs_insert_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.spbs_insert_update_with_http_info(
                 organization_id,
                 sport,
                 season_person_base_statistics_post_body,
                 external,
                 fields,
@@ -496,15 +500,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Create/Update season person base statistics  # noqa: E501
 
         Depending on the data, add or update a base statistic record for a person in a season.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.spbs_insert_update_with_http_info(organization_id, sport, season_person_base_statistics_post_body, external, fields, hide_null, include, async_req=True)
@@ -522,21 +526,22 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -605,15 +610,15 @@
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params["season_person_base_statistics_post_body"]:
+        if _params["season_person_base_statistics_post_body"] is not None:
             _body_params = _params["season_person_base_statistics_post_body"]
 
         # set the HTTP header `Accept`
         _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501
 
         # set the HTTP header `Content-Type`
         _content_types_list = _params.get(
@@ -747,28 +752,28 @@
         :type offset: int
         :param person_id: The unique identifier of the person
         :type person_id: str
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: SeasonPersonBaseStatisticsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the spbs_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.spbs_list_with_http_info(
                 organization_id,
                 season_id,
                 sport,
                 added,
                 competitor_type,
@@ -845,15 +850,15 @@
             ),
         ] = None,
         person_id: Annotated[Optional[StrictStr], Field(description="The unique identifier of the person")] = None,
         updated: Annotated[
             Optional[datetime], Field(description="Record was modified after this date/time. In UTC.")
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Person season base statistics  # noqa: E501
 
         Return a list of person base statistics for a season  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.spbs_list_with_http_info(organization_id, season_id, sport, added, competitor_type, entity_id, external, fields, fixture_type, hide_null, include, limit, offset, person_id, updated, async_req=True)
@@ -887,21 +892,22 @@
         :type offset: int
         :param person_id: The unique identifier of the person
         :type person_id: str
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -971,27 +977,27 @@
                 _query_params.append(
                     ("added", _params["added"].strftime(self.api_client.configuration.datetime_format))
                 )
             else:
                 _query_params.append(("added", _params["added"]))
 
         if _params.get("competitor_type") is not None:  # noqa: E501
-            _query_params.append(("competitorType", _params["competitor_type"]))
+            _query_params.append(("competitorType", _params["competitor_type"].value))
 
         if _params.get("entity_id") is not None:  # noqa: E501
             _query_params.append(("entityId", _params["entity_id"]))
 
         if _params.get("external") is not None:  # noqa: E501
             _query_params.append(("external", _params["external"]))
 
         if _params.get("fields") is not None:  # noqa: E501
             _query_params.append(("fields", _params["fields"]))
 
         if _params.get("fixture_type") is not None:  # noqa: E501
-            _query_params.append(("fixtureType", _params["fixture_type"]))
+            _query_params.append(("fixtureType", _params["fixture_type"].value))
 
         if _params.get("hide_null") is not None:  # noqa: E501
             _query_params.append(("hideNull", _params["hide_null"]))
 
         if _params.get("include") is not None:  # noqa: E501
             _query_params.append(("include", _params["include"]))
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/api/season_person_placings_api.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/api/season_person_placings_api.py`

 * *Files 3% similar despite different names*

```diff
@@ -8,23 +8,26 @@
     The version of the OpenAPI document: v1
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the file manually.
 """
 
 
+import io
 import logging
 import re  # noqa: F401
+import warnings
 from datetime import datetime
 from typing import Optional
 
 from pydantic import Field, StrictBool, StrictInt, StrictStr, ValidationError, conint, constr, validate_arguments
 from typing_extensions import Annotated
 
 from atriumsports.datacore.openapi.api_client import ApiClient
+from atriumsports.datacore.openapi.api_response import ApiResponse
 from atriumsports.datacore.openapi.exceptions import ApiTypeError, ApiValueError  # noqa: F401
 from atriumsports.datacore.openapi.models.season_person_placings_response import SeasonPersonPlacingsResponse
 from atriumsports.datacore.openapi.models.seasonperson_placings_post_body import SEASONPERSONPlacingsPostBody
 from atriumsports.datacore.openapi.models.seasonperson_placings_put_body import SEASONPERSONPlacingsPutBody
 
 logger = logging.getLogger("openapi")
 
@@ -102,28 +105,28 @@
         :type force_delete: bool
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: SeasonPersonPlacingsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the spp_delete_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.spp_delete_with_http_info(
                 organization_id, placing_id, sport, external, fields, force_delete, hide_null, include, **kwargs
             )  # noqa: E501
         except Exception as e:
             logger.error("Exception when calling SeasonPersonPlacingsApi->spp_delete: %s\n" % e)
             raise
@@ -161,15 +164,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Delete a season person placing  # noqa: E501
 
         Delete a specific season person placing  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.spp_delete_with_http_info(organization_id, placing_id, sport, external, fields, force_delete, hide_null, include, async_req=True)
@@ -189,21 +192,22 @@
         :type force_delete: bool
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -381,28 +385,28 @@
         :type include: str
         :param limit: The maximum number of records to return. See [Pagination](#section/Introduction/Pagination) for more information.
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: SeasonPersonPlacingsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the spp_detail_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.spp_detail_with_http_info(
                 organization_id, placing_id, sport, external, fields, hide_null, include, limit, offset, **kwargs
             )  # noqa: E501
         except Exception as e:
             logger.error("Exception when calling SeasonPersonPlacingsApi->spp_detail: %s\n" % e)
             raise
@@ -446,15 +450,15 @@
         offset: Annotated[
             Optional[StrictInt],
             Field(
                 description="The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Get a season person placing  # noqa: E501
 
         Return detailed information about a specific season person placing  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.spp_detail_with_http_info(organization_id, placing_id, sport, external, fields, hide_null, include, limit, offset, async_req=True)
@@ -476,21 +480,22 @@
         :type include: str
         :param limit: The maximum number of records to return. See [Pagination](#section/Introduction/Pagination) for more information.
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -659,28 +664,28 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: SeasonPersonPlacingsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the spp_insert_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.spp_insert_with_http_info(
                 organization_id,
                 season_id,
                 sport,
                 seasonperson_placings_post_body,
                 external,
@@ -721,15 +726,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Create a new season person placing  # noqa: E501
 
         Add a new season person placing  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.spp_insert_with_http_info(organization_id, season_id, sport, seasonperson_placings_post_body, external, fields, hide_null, include, async_req=True)
@@ -749,21 +754,22 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -836,15 +842,15 @@
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params["seasonperson_placings_post_body"]:
+        if _params["seasonperson_placings_post_body"] is not None:
             _body_params = _params["seasonperson_placings_post_body"]
 
         # set the HTTP header `Accept`
         _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501
 
         # set the HTTP header `Content-Type`
         _content_types_list = _params.get(
@@ -961,28 +967,28 @@
         :type offset: int
         :param person_id: The unique identifier of the person
         :type person_id: str
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: SeasonPersonPlacingsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the spp_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.spp_list_with_http_info(
                 organization_id,
                 season_id,
                 sport,
                 added,
                 external,
@@ -1045,15 +1051,15 @@
             ),
         ] = None,
         person_id: Annotated[Optional[StrictStr], Field(description="The unique identifier of the person")] = None,
         updated: Annotated[
             Optional[datetime], Field(description="Record was modified after this date/time. In UTC.")
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Get a list of placings for persons in a season  # noqa: E501
 
         Return a list of final placings for a person in a season  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.spp_list_with_http_info(organization_id, season_id, sport, added, external, fields, hide_null, include, limit, offset, person_id, updated, async_req=True)
@@ -1081,21 +1087,22 @@
         :type offset: int
         :param person_id: The unique identifier of the person
         :type person_id: str
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1286,28 +1293,28 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: SeasonPersonPlacingsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the spp_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.spp_update_with_http_info(
                 organization_id,
                 placing_id,
                 sport,
                 seasonperson_placings_put_body,
                 external,
@@ -1348,15 +1355,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Update a specific season person placing  # noqa: E501
 
         Change the information of a specific season person placing  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.spp_update_with_http_info(organization_id, placing_id, sport, seasonperson_placings_put_body, external, fields, hide_null, include, async_req=True)
@@ -1376,21 +1383,22 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1463,15 +1471,15 @@
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params["seasonperson_placings_put_body"]:
+        if _params["seasonperson_placings_put_body"] is not None:
             _body_params = _params["seasonperson_placings_put_body"]
 
         # set the HTTP header `Accept`
         _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501
 
         # set the HTTP header `Content-Type`
         _content_types_list = _params.get(
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/api/season_persons_api.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/api/season_persons_api.py`

 * *Files 3% similar despite different names*

```diff
@@ -8,23 +8,26 @@
     The version of the OpenAPI document: v1
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the file manually.
 """
 
 
+import io
 import logging
 import re  # noqa: F401
+import warnings
 from datetime import datetime
 from typing import Optional
 
 from pydantic import Field, StrictBool, StrictInt, StrictStr, ValidationError, conint, constr, validate_arguments
 from typing_extensions import Annotated
 
 from atriumsports.datacore.openapi.api_client import ApiClient
+from atriumsports.datacore.openapi.api_response import ApiResponse
 from atriumsports.datacore.openapi.exceptions import ApiTypeError, ApiValueError  # noqa: F401
 from atriumsports.datacore.openapi.models.season_persons_list_response import SeasonPersonsListResponse
 from atriumsports.datacore.openapi.models.season_persons_post_body import SeasonPersonsPostBody
 from atriumsports.datacore.openapi.models.season_persons_response import SeasonPersonsResponse
 
 logger = logging.getLogger("openapi")
 
@@ -105,28 +108,28 @@
         :type force_delete: bool
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: SeasonPersonsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the season_persons_delete_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.season_persons_delete_with_http_info(
                 organization_id,
                 person_id,
                 season_id,
                 sport,
                 external,
@@ -174,15 +177,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Delete a person from a season  # noqa: E501
 
         Delete a specific person from a season  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.season_persons_delete_with_http_info(organization_id, person_id, season_id, sport, external, fields, force_delete, hide_null, include, async_req=True)
@@ -204,21 +207,22 @@
         :type force_delete: bool
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -413,28 +417,28 @@
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: SeasonPersonsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the season_persons_detail_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.season_persons_detail_with_http_info(
                 organization_id,
                 person_id,
                 season_id,
                 sport,
                 added,
@@ -497,15 +501,15 @@
                 description="The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information."
             ),
         ] = None,
         updated: Annotated[
             Optional[datetime], Field(description="Record was modified after this date/time. In UTC.")
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Get a person in a season  # noqa: E501
 
         Return the detail of a specific person in a season  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.season_persons_detail_with_http_info(organization_id, person_id, season_id, sport, added, external, fields, hide_null, include, limit, offset, updated, async_req=True)
@@ -533,21 +537,22 @@
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -738,28 +743,28 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: SeasonPersonsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the season_persons_insert_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.season_persons_insert_update_with_http_info(
                 organization_id,
                 season_id,
                 sport,
                 season_persons_post_body,
                 external,
@@ -800,15 +805,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Add or Update a person in a season  # noqa: E501
 
         Depending on primary keys, Add an entity or update an existing entitiy in a season  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.season_persons_insert_update_with_http_info(organization_id, season_id, sport, season_persons_post_body, external, fields, hide_null, include, async_req=True)
@@ -828,21 +833,22 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -917,15 +923,15 @@
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params["season_persons_post_body"]:
+        if _params["season_persons_post_body"] is not None:
             _body_params = _params["season_persons_post_body"]
 
         # set the HTTP header `Accept`
         _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501
 
         # set the HTTP header `Content-Type`
         _content_types_list = _params.get(
@@ -1039,28 +1045,28 @@
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: SeasonPersonsListResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the season_persons_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.season_persons_list_with_http_info(
                 organization_id,
                 season_id,
                 sport,
                 added,
                 external,
@@ -1121,15 +1127,15 @@
                 description="The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information."
             ),
         ] = None,
         updated: Annotated[
             Optional[datetime], Field(description="Record was modified after this date/time. In UTC.")
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Get a list of persons in the season  # noqa: E501
 
         Return a list of persons for a season  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.season_persons_list_with_http_info(organization_id, season_id, sport, added, external, fields, hide_null, include, limit, offset, updated, async_req=True)
@@ -1155,21 +1161,22 @@
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/api/season_roster_api.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/api/season_roster_api.py`

 * *Files 1% similar despite different names*

```diff
@@ -8,23 +8,26 @@
     The version of the OpenAPI document: v1
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the file manually.
 """
 
 
+import io
 import logging
 import re  # noqa: F401
+import warnings
 from datetime import datetime
 from typing import Optional
 
 from pydantic import Field, StrictBool, StrictInt, StrictStr, ValidationError, conint, constr, validate_arguments
 from typing_extensions import Annotated
 
 from atriumsports.datacore.openapi.api_client import ApiClient
+from atriumsports.datacore.openapi.api_response import ApiResponse
 from atriumsports.datacore.openapi.exceptions import ApiTypeError, ApiValueError  # noqa: F401
 from atriumsports.datacore.openapi.models.season_roster_post_body import SeasonRosterPostBody
 from atriumsports.datacore.openapi.models.season_roster_response import SeasonRosterResponse
 
 logger = logging.getLogger("openapi")
 
 
@@ -104,28 +107,28 @@
         :type force_delete: bool
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: SeasonRosterResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the season_roster_delete_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.season_roster_delete_with_http_info(
                 organization_id,
                 person_id,
                 season_id,
                 sport,
                 external,
@@ -173,15 +176,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Delete a season roster  # noqa: E501
 
         Delete a person from the roster in a season  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.season_roster_delete_with_http_info(organization_id, person_id, season_id, sport, external, fields, force_delete, hide_null, include, async_req=True)
@@ -203,21 +206,22 @@
         :type force_delete: bool
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -410,28 +414,28 @@
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param status: Participation status >- `ACTIVE` Active >- `INJURED` Injured >- `OTHER_NOT_PARTICIPATING` Other Non-Participation >- `OUT` Out >- `SUSPENSED` Suspended
         :type status: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: SeasonRosterResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the season_roster_detail_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.season_roster_detail_with_http_info(
                 organization_id,
                 person_id,
                 season_id,
                 sport,
                 external,
@@ -493,15 +497,15 @@
         status: Annotated[
             Optional[constr(strict=True, max_length=100)],
             Field(
                 description="Participation status >- `ACTIVE` Active >- `INJURED` Injured >- `OTHER_NOT_PARTICIPATING` Other Non-Participation >- `OUT` Out >- `SUSPENSED` Suspended "
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Get the roster detail for a person for the season  # noqa: E501
 
         Return the detailed roster detail for a specific person for the season  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.season_roster_detail_with_http_info(organization_id, person_id, season_id, sport, external, fields, hide_null, include, limit, offset, status, async_req=True)
@@ -527,21 +531,22 @@
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param status: Participation status >- `ACTIVE` Active >- `INJURED` Injured >- `OTHER_NOT_PARTICIPATING` Other Non-Participation >- `OUT` Out >- `SUSPENSED` Suspended
         :type status: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -620,15 +625,15 @@
         if _params.get("limit") is not None:  # noqa: E501
             _query_params.append(("limit", _params["limit"]))
 
         if _params.get("offset") is not None:  # noqa: E501
             _query_params.append(("offset", _params["offset"]))
 
         if _params.get("status") is not None:  # noqa: E501
-            _query_params.append(("status", _params["status"]))
+            _query_params.append(("status", _params["status"].value))
 
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
@@ -718,28 +723,28 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: SeasonRosterResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the season_roster_insert_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.season_roster_insert_update_with_http_info(
                 organization_id,
                 season_id,
                 sport,
                 season_roster_post_body,
                 external,
@@ -780,15 +785,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Create/Update a roster  # noqa: E501
 
         Depending on the data, either add a person to a roster, or update an existing roster  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.season_roster_insert_update_with_http_info(organization_id, season_id, sport, season_roster_post_body, external, fields, hide_null, include, async_req=True)
@@ -808,21 +813,22 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -897,15 +903,15 @@
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params["season_roster_post_body"]:
+        if _params["season_roster_post_body"] is not None:
             _body_params = _params["season_roster_post_body"]
 
         # set the HTTP header `Accept`
         _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501
 
         # set the HTTP header `Content-Type`
         _content_types_list = _params.get(
@@ -1027,28 +1033,28 @@
         :type offset: int
         :param status: Participation status >- `ACTIVE` Active >- `INJURED` Injured >- `OTHER_NOT_PARTICIPATING` Other Non-Participation >- `OUT` Out >- `SUSPENSED` Suspended
         :type status: str
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: SeasonRosterResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the season_roster_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.season_roster_list_with_http_info(
                 organization_id,
                 season_id,
                 sport,
                 added,
                 external,
@@ -1116,15 +1122,15 @@
                 description="Participation status >- `ACTIVE` Active >- `INJURED` Injured >- `OTHER_NOT_PARTICIPATING` Other Non-Participation >- `OUT` Out >- `SUSPENSED` Suspended "
             ),
         ] = None,
         updated: Annotated[
             Optional[datetime], Field(description="Record was modified after this date/time. In UTC.")
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Get all rosters for a season  # noqa: E501
 
         Return a list of all rosters for a season  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.season_roster_list_with_http_info(organization_id, season_id, sport, added, external, fields, hide_null, include, limit, offset, status, updated, async_req=True)
@@ -1152,21 +1158,22 @@
         :type offset: int
         :param status: Participation status >- `ACTIVE` Active >- `INJURED` Injured >- `OTHER_NOT_PARTICIPATING` Other Non-Participation >- `OUT` Out >- `SUSPENSED` Suspended
         :type status: str
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1251,15 +1258,15 @@
         if _params.get("limit") is not None:  # noqa: E501
             _query_params.append(("limit", _params["limit"]))
 
         if _params.get("offset") is not None:  # noqa: E501
             _query_params.append(("offset", _params["offset"]))
 
         if _params.get("status") is not None:  # noqa: E501
-            _query_params.append(("status", _params["status"]))
+            _query_params.append(("status", _params["status"].value))
 
         if _params.get("updated") is not None:  # noqa: E501
             if isinstance(_params["updated"], datetime):
                 _query_params.append(
                     ("updated", _params["updated"].strftime(self.api_client.configuration.datetime_format))
                 )
             else:
@@ -1391,28 +1398,28 @@
         :type offset: int
         :param status: Participation status >- `ACTIVE` Active >- `INJURED` Injured >- `OTHER_NOT_PARTICIPATING` Other Non-Participation >- `OUT` Out >- `SUSPENSED` Suspended
         :type status: str
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: SeasonRosterResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the season_roster_list_by_entity_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.season_roster_list_by_entity_with_http_info(
                 entity_id,
                 organization_id,
                 season_id,
                 sport,
                 added,
@@ -1482,15 +1489,15 @@
                 description="Participation status >- `ACTIVE` Active >- `INJURED` Injured >- `OTHER_NOT_PARTICIPATING` Other Non-Participation >- `OUT` Out >- `SUSPENSED` Suspended "
             ),
         ] = None,
         updated: Annotated[
             Optional[datetime], Field(description="Record was modified after this date/time. In UTC.")
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Get the roster for an entity for the season  # noqa: E501
 
         Return the roster for an entity for the season  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.season_roster_list_by_entity_with_http_info(entity_id, organization_id, season_id, sport, added, external, fields, hide_null, include, limit, offset, status, updated, async_req=True)
@@ -1520,21 +1527,22 @@
         :type offset: int
         :param status: Participation status >- `ACTIVE` Active >- `INJURED` Injured >- `OTHER_NOT_PARTICIPATING` Other Non-Participation >- `OUT` Out >- `SUSPENSED` Suspended
         :type status: str
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1625,15 +1633,15 @@
         if _params.get("limit") is not None:  # noqa: E501
             _query_params.append(("limit", _params["limit"]))
 
         if _params.get("offset") is not None:  # noqa: E501
             _query_params.append(("offset", _params["offset"]))
 
         if _params.get("status") is not None:  # noqa: E501
-            _query_params.append(("status", _params["status"]))
+            _query_params.append(("status", _params["status"].value))
 
         if _params.get("updated") is not None:  # noqa: E501
             if isinstance(_params["updated"], datetime):
                 _query_params.append(
                     ("updated", _params["updated"].strftime(self.api_client.configuration.datetime_format))
                 )
             else:
@@ -1767,28 +1775,28 @@
         :type season_ids: str
         :param status: Participation status >- `ACTIVE` Active >- `INJURED` Injured >- `OTHER_NOT_PARTICIPATING` Other Non-Participation >- `OUT` Out >- `SUSPENSED` Suspended
         :type status: str
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: SeasonRosterResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the seasons_roster_list_by_entity_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.seasons_roster_list_by_entity_with_http_info(
                 entity_id,
                 organization_id,
                 sport,
                 added,
                 external,
@@ -1860,15 +1868,15 @@
                 description="Participation status >- `ACTIVE` Active >- `INJURED` Injured >- `OTHER_NOT_PARTICIPATING` Other Non-Participation >- `OUT` Out >- `SUSPENSED` Suspended "
             ),
         ] = None,
         updated: Annotated[
             Optional[datetime], Field(description="Record was modified after this date/time. In UTC.")
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Get the rosters for an entity for all seasons  # noqa: E501
 
         Return the rosters for an entity for all seasons  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.seasons_roster_list_by_entity_with_http_info(entity_id, organization_id, sport, added, external, fields, hide_null, include, limit, offset, season_ids, status, updated, async_req=True)
@@ -1898,21 +1906,22 @@
         :type season_ids: str
         :param status: Participation status >- `ACTIVE` Active >- `INJURED` Injured >- `OTHER_NOT_PARTICIPATING` Other Non-Participation >- `OUT` Out >- `SUSPENSED` Suspended
         :type status: str
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -2003,15 +2012,15 @@
         if _params.get("offset") is not None:  # noqa: E501
             _query_params.append(("offset", _params["offset"]))
 
         if _params.get("season_ids") is not None:  # noqa: E501
             _query_params.append(("seasonIds", _params["season_ids"]))
 
         if _params.get("status") is not None:  # noqa: E501
-            _query_params.append(("status", _params["status"]))
+            _query_params.append(("status", _params["status"].value))
 
         if _params.get("updated") is not None:  # noqa: E501
             if isinstance(_params["updated"], datetime):
                 _query_params.append(
                     ("updated", _params["updated"].strftime(self.api_client.configuration.datetime_format))
                 )
             else:
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/api/season_series_api.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/api/season_series_api.py`

 * *Files 2% similar despite different names*

```diff
@@ -8,23 +8,26 @@
     The version of the OpenAPI document: v1
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the file manually.
 """
 
 
+import io
 import logging
 import re  # noqa: F401
+import warnings
 from datetime import datetime
 from typing import Optional
 
 from pydantic import Field, StrictBool, StrictInt, StrictStr, ValidationError, conint, constr, validate_arguments
 from typing_extensions import Annotated
 
 from atriumsports.datacore.openapi.api_client import ApiClient
+from atriumsports.datacore.openapi.api_response import ApiResponse
 from atriumsports.datacore.openapi.exceptions import ApiTypeError, ApiValueError  # noqa: F401
 from atriumsports.datacore.openapi.models.season_series_response import SeasonSeriesResponse
 from atriumsports.datacore.openapi.models.series_post_body import SeriesPostBody
 from atriumsports.datacore.openapi.models.series_put_body import SeriesPutBody
 from atriumsports.datacore.openapi.models.success_response import SuccessResponse
 
 logger = logging.getLogger("openapi")
@@ -116,28 +119,28 @@
         :type include: str
         :param limit: The maximum number of records to return. See [Pagination](#section/Introduction/Pagination) for more information.
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: SuccessResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the season_series_calculate_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.season_series_calculate_with_http_info(
                 organization_id,
                 season_id,
                 series_code,
                 sport,
                 external,
@@ -194,15 +197,15 @@
         offset: Annotated[
             Optional[StrictInt],
             Field(
                 description="The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Calculate season series competitors score related fields  # noqa: E501
 
         Calculate season series competitors score related fields  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.season_series_calculate_with_http_info(organization_id, season_id, series_code, sport, external, fields, hide_null, include, limit, offset, async_req=True)
@@ -226,21 +229,22 @@
         :type include: str
         :param limit: The maximum number of records to return. See [Pagination](#section/Introduction/Pagination) for more information.
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -425,28 +429,28 @@
         :type force_delete: bool
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: SeasonSeriesResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the season_series_delete_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.season_series_delete_with_http_info(
                 organization_id,
                 season_id,
                 series_code,
                 sport,
                 external,
@@ -496,15 +500,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Delete a series  # noqa: E501
 
         Delete a specific series  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.season_series_delete_with_http_info(organization_id, season_id, series_code, sport, external, fields, force_delete, hide_null, include, async_req=True)
@@ -526,21 +530,22 @@
         :type force_delete: bool
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -727,28 +732,28 @@
         :type include: str
         :param limit: The maximum number of records to return. See [Pagination](#section/Introduction/Pagination) for more information.
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: SeasonSeriesResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the season_series_detail_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.season_series_detail_with_http_info(
                 organization_id,
                 season_id,
                 series_code,
                 sport,
                 external,
@@ -805,15 +810,15 @@
         offset: Annotated[
             Optional[StrictInt],
             Field(
                 description="The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Get a series  # noqa: E501
 
         Return detailed information about a specific season series  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.season_series_detail_with_http_info(organization_id, season_id, series_code, sport, external, fields, hide_null, include, limit, offset, async_req=True)
@@ -837,21 +842,22 @@
         :type include: str
         :param limit: The maximum number of records to return. See [Pagination](#section/Introduction/Pagination) for more information.
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1024,28 +1030,28 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: SeasonSeriesResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the season_series_insert_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.season_series_insert_with_http_info(
                 organization_id, season_id, sport, series_post_body, external, fields, hide_null, include, **kwargs
             )  # noqa: E501
         except Exception as e:
             logger.error("Exception when calling SeasonSeriesApi->season_series_insert: %s\n" % e)
             raise
@@ -1078,15 +1084,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Create a series  # noqa: E501
 
         Add a new series in a season  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.season_series_insert_with_http_info(organization_id, season_id, sport, series_post_body, external, fields, hide_null, include, async_req=True)
@@ -1106,21 +1112,22 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1193,15 +1200,15 @@
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params["series_post_body"]:
+        if _params["series_post_body"] is not None:
             _body_params = _params["series_post_body"]
 
         # set the HTTP header `Accept`
         _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501
 
         # set the HTTP header `Content-Type`
         _content_types_list = _params.get(
@@ -1277,32 +1284,38 @@
         ] = None,
         offset: Annotated[
             Optional[StrictInt],
             Field(
                 description="The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information."
             ),
         ] = None,
+        pool_code: Annotated[
+            Optional[constr(strict=True, max_length=30)], Field(description="The pool identifier within a season")
+        ] = None,
         series_type: Annotated[
             Optional[constr(strict=True, max_length=50)],
             Field(
                 description="The type of series >- `BEST_OF` Best of >- `HEAD_TO_HEAD` Head to Head >- `HOME_AND_AWAY` Home and Away >- `KNOCKOUT` Knockout >- `TOURNAMENT` Tournament "
             ),
         ] = None,
+        stage_code: Annotated[
+            Optional[constr(strict=True, max_length=30)], Field(description="The stage identifier within a season")
+        ] = None,
         updated: Annotated[
             Optional[datetime], Field(description="Record was modified after this date/time. In UTC.")
         ] = None,
         **kwargs
     ) -> SeasonSeriesResponse:  # noqa: E501
         """Get a list of series  # noqa: E501
 
         Return a list of series for a season  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
-        >>> thread = api.season_series_list(organization_id, season_id, sport, added, external, fields, hide_null, include, limit, offset, series_type, updated, async_req=True)
+        >>> thread = api.season_series_list(organization_id, season_id, sport, added, external, fields, hide_null, include, limit, offset, pool_code, series_type, stage_code, updated, async_req=True)
         >>> result = thread.get()
 
         :param organization_id: The unique identifier of the organization (required)
         :type organization_id: str
         :param season_id: The unique identifier of the season (required)
         :type season_id: str
         :param sport: Sport name (required)
@@ -1317,47 +1330,53 @@
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param limit: The maximum number of records to return. See [Pagination](#section/Introduction/Pagination) for more information.
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
+        :param pool_code: The pool identifier within a season
+        :type pool_code: str
         :param series_type: The type of series >- `BEST_OF` Best of >- `HEAD_TO_HEAD` Head to Head >- `HOME_AND_AWAY` Home and Away >- `KNOCKOUT` Knockout >- `TOURNAMENT` Tournament
         :type series_type: str
+        :param stage_code: The stage identifier within a season
+        :type stage_code: str
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: SeasonSeriesResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the season_series_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.season_series_list_with_http_info(
                 organization_id,
                 season_id,
                 sport,
                 added,
                 external,
                 fields,
                 hide_null,
                 include,
                 limit,
                 offset,
+                pool_code,
                 series_type,
+                stage_code,
                 updated,
                 **kwargs
             )  # noqa: E501
         except Exception as e:
             logger.error("Exception when calling SeasonSeriesApi->season_series_list: %s\n" % e)
             raise
 
@@ -1402,32 +1421,38 @@
         ] = None,
         offset: Annotated[
             Optional[StrictInt],
             Field(
                 description="The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information."
             ),
         ] = None,
+        pool_code: Annotated[
+            Optional[constr(strict=True, max_length=30)], Field(description="The pool identifier within a season")
+        ] = None,
         series_type: Annotated[
             Optional[constr(strict=True, max_length=50)],
             Field(
                 description="The type of series >- `BEST_OF` Best of >- `HEAD_TO_HEAD` Head to Head >- `HOME_AND_AWAY` Home and Away >- `KNOCKOUT` Knockout >- `TOURNAMENT` Tournament "
             ),
         ] = None,
+        stage_code: Annotated[
+            Optional[constr(strict=True, max_length=30)], Field(description="The stage identifier within a season")
+        ] = None,
         updated: Annotated[
             Optional[datetime], Field(description="Record was modified after this date/time. In UTC.")
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Get a list of series  # noqa: E501
 
         Return a list of series for a season  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
-        >>> thread = api.season_series_list_with_http_info(organization_id, season_id, sport, added, external, fields, hide_null, include, limit, offset, series_type, updated, async_req=True)
+        >>> thread = api.season_series_list_with_http_info(organization_id, season_id, sport, added, external, fields, hide_null, include, limit, offset, pool_code, series_type, stage_code, updated, async_req=True)
         >>> result = thread.get()
 
         :param organization_id: The unique identifier of the organization (required)
         :type organization_id: str
         :param season_id: The unique identifier of the season (required)
         :type season_id: str
         :param sport: Sport name (required)
@@ -1442,27 +1467,32 @@
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param limit: The maximum number of records to return. See [Pagination](#section/Introduction/Pagination) for more information.
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
+        :param pool_code: The pool identifier within a season
+        :type pool_code: str
         :param series_type: The type of series >- `BEST_OF` Best of >- `HEAD_TO_HEAD` Head to Head >- `HOME_AND_AWAY` Home and Away >- `KNOCKOUT` Knockout >- `TOURNAMENT` Tournament
         :type series_type: str
+        :param stage_code: The stage identifier within a season
+        :type stage_code: str
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1483,15 +1513,17 @@
             "added",
             "external",
             "fields",
             "hide_null",
             "include",
             "limit",
             "offset",
+            "pool_code",
             "series_type",
+            "stage_code",
             "updated",
         ]
         _all_params.extend(
             [
                 "async_req",
                 "_return_http_data_only",
                 "_preload_content",
@@ -1546,16 +1578,22 @@
 
         if _params.get("limit") is not None:  # noqa: E501
             _query_params.append(("limit", _params["limit"]))
 
         if _params.get("offset") is not None:  # noqa: E501
             _query_params.append(("offset", _params["offset"]))
 
+        if _params.get("pool_code") is not None:  # noqa: E501
+            _query_params.append(("poolCode", _params["pool_code"]))
+
         if _params.get("series_type") is not None:  # noqa: E501
-            _query_params.append(("seriesType", _params["series_type"]))
+            _query_params.append(("seriesType", _params["series_type"].value))
+
+        if _params.get("stage_code") is not None:  # noqa: E501
+            _query_params.append(("stageCode", _params["stage_code"]))
 
         if _params.get("updated") is not None:  # noqa: E501
             if isinstance(_params["updated"], datetime):
                 _query_params.append(
                     ("updated", _params["updated"].strftime(self.api_client.configuration.datetime_format))
                 )
             else:
@@ -1658,28 +1696,28 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: SeasonSeriesResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the season_series_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.season_series_update_with_http_info(
                 organization_id,
                 season_id,
                 series_code,
                 sport,
                 series_put_body,
@@ -1724,15 +1762,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Update a series  # noqa: E501
 
         Change the information of a specific season series  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.season_series_update_with_http_info(organization_id, season_id, series_code, sport, series_put_body, external, fields, hide_null, include, async_req=True)
@@ -1754,21 +1792,22 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1845,15 +1884,15 @@
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params["series_put_body"]:
+        if _params["series_put_body"] is not None:
             _body_params = _params["series_put_body"]
 
         # set the HTTP header `Accept`
         _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501
 
         # set the HTTP header `Content-Type`
         _content_types_list = _params.get(
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/api/season_statistics_api.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/api/season_statistics_api.py`

 * *Files 2% similar despite different names*

```diff
@@ -8,23 +8,26 @@
     The version of the OpenAPI document: v1
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the file manually.
 """
 
 
+import io
 import logging
 import re  # noqa: F401
+import warnings
 from datetime import datetime
 from typing import Optional
 
 from pydantic import Field, StrictBool, StrictInt, StrictStr, ValidationError, conint, constr, validate_arguments
 from typing_extensions import Annotated
 
 from atriumsports.datacore.openapi.api_client import ApiClient
+from atriumsports.datacore.openapi.api_response import ApiResponse
 from atriumsports.datacore.openapi.exceptions import ApiTypeError, ApiValueError  # noqa: F401
 from atriumsports.datacore.openapi.models.season_entity_statistics_response import SeasonEntityStatisticsResponse
 from atriumsports.datacore.openapi.models.season_person_statistics_periods_response import (
     SeasonPersonStatisticsPeriodsResponse,
 )
 from atriumsports.datacore.openapi.models.season_person_statistics_response import SeasonPersonStatisticsResponse
 from atriumsports.datacore.openapi.models.season_person_total_statistics_response import (
@@ -163,28 +166,28 @@
         :type season_id: str
         :param season_type: The type of matches added to this season >- `ONE_OFF` One off match >- `SEASON` Season >- `TOURNAMENT` Tournament
         :type season_type: str
         :param standard: The playing standard of the season or entity >- `ELITE` Professional/elite organisation >- `FRIENDLY` International Friendly >- `GRASS_ROOT` Normal >- `INTERNATIONAL` International >- `NONCONTINENTAL_CHAMPIONSHIP` Non-continental Championship >- `OLYMPIC` Olympics >- `REGION` Regional >- `TIER2` lesser standard than elite >- `TIER3` lesser standard than tier 2 >- `WORLD_CHAMPIONSHIP` World Championship >- `ZONE_CHAMPIONSHIP` International Zone Championship
         :type standard: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: SeasonPersonStatisticsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the pss_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.pss_list_with_http_info(
                 organization_id,
                 person_id,
                 sport,
                 age_group,
                 competition_id,
@@ -278,15 +281,15 @@
         standard: Annotated[
             Optional[StrictStr],
             Field(
                 description="The playing standard of the season or entity >- `ELITE` Professional/elite organisation >- `FRIENDLY` International Friendly >- `GRASS_ROOT` Normal >- `INTERNATIONAL` International >- `NONCONTINENTAL_CHAMPIONSHIP` Non-continental Championship >- `OLYMPIC` Olympics >- `REGION` Regional >- `TIER2` lesser standard than elite >- `TIER3` lesser standard than tier 2 >- `WORLD_CHAMPIONSHIP` World Championship >- `ZONE_CHAMPIONSHIP` International Zone Championship "
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Person season statistics  # noqa: E501
 
         Return a list of person statistics for all seasons  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.pss_list_with_http_info(organization_id, person_id, sport, age_group, competition_id, external, fields, fixture_type, hide_null, include, limit, offset, representation, season_id, season_type, standard, async_req=True)
@@ -322,21 +325,22 @@
         :type season_id: str
         :param season_type: The type of matches added to this season >- `ONE_OFF` One off match >- `SEASON` Season >- `TOURNAMENT` Tournament
         :type season_type: str
         :param standard: The playing standard of the season or entity >- `ELITE` Professional/elite organisation >- `FRIENDLY` International Friendly >- `GRASS_ROOT` Normal >- `INTERNATIONAL` International >- `NONCONTINENTAL_CHAMPIONSHIP` Non-continental Championship >- `OLYMPIC` Olympics >- `REGION` Regional >- `TIER2` lesser standard than elite >- `TIER3` lesser standard than tier 2 >- `WORLD_CHAMPIONSHIP` World Championship >- `ZONE_CHAMPIONSHIP` International Zone Championship
         :type standard: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -399,51 +403,51 @@
 
         if _params["sport"]:
             _path_params["sport"] = _params["sport"]
 
         # process the query parameters
         _query_params = []
         if _params.get("age_group") is not None:  # noqa: E501
-            _query_params.append(("ageGroup", _params["age_group"]))
+            _query_params.append(("ageGroup", _params["age_group"].value))
 
         if _params.get("competition_id") is not None:  # noqa: E501
             _query_params.append(("competitionId", _params["competition_id"]))
 
         if _params.get("external") is not None:  # noqa: E501
             _query_params.append(("external", _params["external"]))
 
         if _params.get("fields") is not None:  # noqa: E501
             _query_params.append(("fields", _params["fields"]))
 
         if _params.get("fixture_type") is not None:  # noqa: E501
-            _query_params.append(("fixtureType", _params["fixture_type"]))
+            _query_params.append(("fixtureType", _params["fixture_type"].value))
 
         if _params.get("hide_null") is not None:  # noqa: E501
             _query_params.append(("hideNull", _params["hide_null"]))
 
         if _params.get("include") is not None:  # noqa: E501
             _query_params.append(("include", _params["include"]))
 
         if _params.get("limit") is not None:  # noqa: E501
             _query_params.append(("limit", _params["limit"]))
 
         if _params.get("offset") is not None:  # noqa: E501
             _query_params.append(("offset", _params["offset"]))
 
         if _params.get("representation") is not None:  # noqa: E501
-            _query_params.append(("representation", _params["representation"]))
+            _query_params.append(("representation", _params["representation"].value))
 
         if _params.get("season_id") is not None:  # noqa: E501
             _query_params.append(("seasonId", _params["season_id"]))
 
         if _params.get("season_type") is not None:  # noqa: E501
-            _query_params.append(("seasonType", _params["season_type"]))
+            _query_params.append(("seasonType", _params["season_type"].value))
 
         if _params.get("standard") is not None:  # noqa: E501
-            _query_params.append(("standard", _params["standard"]))
+            _query_params.append(("standard", _params["standard"].value))
 
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
@@ -594,28 +598,28 @@
         :type season_id: str
         :param season_type: The type of matches added to this season >- `ONE_OFF` One off match >- `SEASON` Season >- `TOURNAMENT` Tournament
         :type season_type: str
         :param standard: The playing standard of the season or entity >- `ELITE` Professional/elite organisation >- `FRIENDLY` International Friendly >- `GRASS_ROOT` Normal >- `INTERNATIONAL` International >- `NONCONTINENTAL_CHAMPIONSHIP` Non-continental Championship >- `OLYMPIC` Olympics >- `REGION` Regional >- `TIER2` lesser standard than elite >- `TIER3` lesser standard than tier 2 >- `WORLD_CHAMPIONSHIP` World Championship >- `ZONE_CHAMPIONSHIP` International Zone Championship
         :type standard: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: SeasonPersonTotalStatisticsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the psts_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.psts_list_with_http_info(
                 organization_id,
                 person_id,
                 sport,
                 age_group,
                 competition_id,
@@ -709,15 +713,15 @@
         standard: Annotated[
             Optional[StrictStr],
             Field(
                 description="The playing standard of the season or entity >- `ELITE` Professional/elite organisation >- `FRIENDLY` International Friendly >- `GRASS_ROOT` Normal >- `INTERNATIONAL` International >- `NONCONTINENTAL_CHAMPIONSHIP` Non-continental Championship >- `OLYMPIC` Olympics >- `REGION` Regional >- `TIER2` lesser standard than elite >- `TIER3` lesser standard than tier 2 >- `WORLD_CHAMPIONSHIP` World Championship >- `ZONE_CHAMPIONSHIP` International Zone Championship "
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Person season statistics - combined teams  # noqa: E501
 
              Return a list of person statistic totals for a season.     If a person plays for multiple entities in a season then their statistics are normally     separated out by entity.     For this call the statistics are combined - and hence entity data is not available.       # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.psts_list_with_http_info(organization_id, person_id, sport, age_group, competition_id, external, fields, fixture_type, hide_null, include, limit, offset, representation, season_id, season_type, standard, async_req=True)
@@ -753,21 +757,22 @@
         :type season_id: str
         :param season_type: The type of matches added to this season >- `ONE_OFF` One off match >- `SEASON` Season >- `TOURNAMENT` Tournament
         :type season_type: str
         :param standard: The playing standard of the season or entity >- `ELITE` Professional/elite organisation >- `FRIENDLY` International Friendly >- `GRASS_ROOT` Normal >- `INTERNATIONAL` International >- `NONCONTINENTAL_CHAMPIONSHIP` Non-continental Championship >- `OLYMPIC` Olympics >- `REGION` Regional >- `TIER2` lesser standard than elite >- `TIER3` lesser standard than tier 2 >- `WORLD_CHAMPIONSHIP` World Championship >- `ZONE_CHAMPIONSHIP` International Zone Championship
         :type standard: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -830,51 +835,51 @@
 
         if _params["sport"]:
             _path_params["sport"] = _params["sport"]
 
         # process the query parameters
         _query_params = []
         if _params.get("age_group") is not None:  # noqa: E501
-            _query_params.append(("ageGroup", _params["age_group"]))
+            _query_params.append(("ageGroup", _params["age_group"].value))
 
         if _params.get("competition_id") is not None:  # noqa: E501
             _query_params.append(("competitionId", _params["competition_id"]))
 
         if _params.get("external") is not None:  # noqa: E501
             _query_params.append(("external", _params["external"]))
 
         if _params.get("fields") is not None:  # noqa: E501
             _query_params.append(("fields", _params["fields"]))
 
         if _params.get("fixture_type") is not None:  # noqa: E501
-            _query_params.append(("fixtureType", _params["fixture_type"]))
+            _query_params.append(("fixtureType", _params["fixture_type"].value))
 
         if _params.get("hide_null") is not None:  # noqa: E501
             _query_params.append(("hideNull", _params["hide_null"]))
 
         if _params.get("include") is not None:  # noqa: E501
             _query_params.append(("include", _params["include"]))
 
         if _params.get("limit") is not None:  # noqa: E501
             _query_params.append(("limit", _params["limit"]))
 
         if _params.get("offset") is not None:  # noqa: E501
             _query_params.append(("offset", _params["offset"]))
 
         if _params.get("representation") is not None:  # noqa: E501
-            _query_params.append(("representation", _params["representation"]))
+            _query_params.append(("representation", _params["representation"].value))
 
         if _params.get("season_id") is not None:  # noqa: E501
             _query_params.append(("seasonId", _params["season_id"]))
 
         if _params.get("season_type") is not None:  # noqa: E501
-            _query_params.append(("seasonType", _params["season_type"]))
+            _query_params.append(("seasonType", _params["season_type"].value))
 
         if _params.get("standard") is not None:  # noqa: E501
-            _query_params.append(("standard", _params["standard"]))
+            _query_params.append(("standard", _params["standard"].value))
 
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
@@ -1028,28 +1033,28 @@
         :type stage_code: str
         :param to_time_utc: Where fixture start time (in UTC) <= this value
         :type to_time_utc: datetime
         :param win_loss: What the result was >- `DRAW` Draw >- `LOSS` Loss >- `WIN` Win
         :type win_loss: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: SeasonEntityStatisticsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the ses_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.ses_list_with_http_info(
                 organization_id,
                 season_id,
                 sport,
                 entity_id,
                 external,
@@ -1143,15 +1148,15 @@
             Optional[datetime], Field(description="Where fixture start time (in UTC) <= this value")
         ] = None,
         win_loss: Annotated[
             Optional[constr(strict=True, max_length=50)],
             Field(description="What the result was >- `DRAW` Draw >- `LOSS` Loss >- `WIN` Win "),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Entity statistics  # noqa: E501
 
         Return a list of entity statistic totals for a season  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.ses_list_with_http_info(organization_id, season_id, sport, entity_id, external, fields, fixture_type, from_time_utc, hide_null, home_away, include, limit, offset, pool_code, round_code, round_number, stage_code, to_time_utc, win_loss, async_req=True)
@@ -1193,21 +1198,22 @@
         :type stage_code: str
         :param to_time_utc: Where fixture start time (in UTC) <= this value
         :type to_time_utc: datetime
         :param win_loss: What the result was >- `DRAW` Draw >- `LOSS` Loss >- `WIN` Win
         :type win_loss: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1282,29 +1288,29 @@
         if _params.get("external") is not None:  # noqa: E501
             _query_params.append(("external", _params["external"]))
 
         if _params.get("fields") is not None:  # noqa: E501
             _query_params.append(("fields", _params["fields"]))
 
         if _params.get("fixture_type") is not None:  # noqa: E501
-            _query_params.append(("fixtureType", _params["fixture_type"]))
+            _query_params.append(("fixtureType", _params["fixture_type"].value))
 
         if _params.get("from_time_utc") is not None:  # noqa: E501
             if isinstance(_params["from_time_utc"], datetime):
                 _query_params.append(
                     ("fromTimeUTC", _params["from_time_utc"].strftime(self.api_client.configuration.datetime_format))
                 )
             else:
                 _query_params.append(("fromTimeUTC", _params["from_time_utc"]))
 
         if _params.get("hide_null") is not None:  # noqa: E501
             _query_params.append(("hideNull", _params["hide_null"]))
 
         if _params.get("home_away") is not None:  # noqa: E501
-            _query_params.append(("homeAway", _params["home_away"]))
+            _query_params.append(("homeAway", _params["home_away"].value))
 
         if _params.get("include") is not None:  # noqa: E501
             _query_params.append(("include", _params["include"]))
 
         if _params.get("limit") is not None:  # noqa: E501
             _query_params.append(("limit", _params["limit"]))
 
@@ -1328,15 +1334,15 @@
                 _query_params.append(
                     ("toTimeUTC", _params["to_time_utc"].strftime(self.api_client.configuration.datetime_format))
                 )
             else:
                 _query_params.append(("toTimeUTC", _params["to_time_utc"]))
 
         if _params.get("win_loss") is not None:  # noqa: E501
-            _query_params.append(("winLoss", _params["win_loss"]))
+            _query_params.append(("winLoss", _params["win_loss"].value))
 
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
@@ -1498,28 +1504,28 @@
         :type stage_code: str
         :param to_time_utc: Where fixture start time (in UTC) <= this value
         :type to_time_utc: datetime
         :param win_loss: What the result was >- `DRAW` Draw >- `LOSS` Loss >- `WIN` Win
         :type win_loss: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: SeasonEntityStatisticsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the ses_listperiods_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.ses_listperiods_with_http_info(
                 organization_id,
                 season_id,
                 sport,
                 entity_id,
                 external,
@@ -1619,15 +1625,15 @@
             Optional[datetime], Field(description="Where fixture start time (in UTC) <= this value")
         ] = None,
         win_loss: Annotated[
             Optional[constr(strict=True, max_length=50)],
             Field(description="What the result was >- `DRAW` Draw >- `LOSS` Loss >- `WIN` Win "),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Entity statistics by period  # noqa: E501
 
         Return a list of entity statistics for a season filterable by period.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.ses_listperiods_with_http_info(organization_id, season_id, sport, entity_id, external, fields, fixture_type, from_time_utc, hide_null, home_away, include, limit, offset, period_id, pool_code, round_code, round_number, section, stage_code, to_time_utc, win_loss, async_req=True)
@@ -1673,21 +1679,22 @@
         :type stage_code: str
         :param to_time_utc: Where fixture start time (in UTC) <= this value
         :type to_time_utc: datetime
         :param win_loss: What the result was >- `DRAW` Draw >- `LOSS` Loss >- `WIN` Win
         :type win_loss: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1764,29 +1771,29 @@
         if _params.get("external") is not None:  # noqa: E501
             _query_params.append(("external", _params["external"]))
 
         if _params.get("fields") is not None:  # noqa: E501
             _query_params.append(("fields", _params["fields"]))
 
         if _params.get("fixture_type") is not None:  # noqa: E501
-            _query_params.append(("fixtureType", _params["fixture_type"]))
+            _query_params.append(("fixtureType", _params["fixture_type"].value))
 
         if _params.get("from_time_utc") is not None:  # noqa: E501
             if isinstance(_params["from_time_utc"], datetime):
                 _query_params.append(
                     ("fromTimeUTC", _params["from_time_utc"].strftime(self.api_client.configuration.datetime_format))
                 )
             else:
                 _query_params.append(("fromTimeUTC", _params["from_time_utc"]))
 
         if _params.get("hide_null") is not None:  # noqa: E501
             _query_params.append(("hideNull", _params["hide_null"]))
 
         if _params.get("home_away") is not None:  # noqa: E501
-            _query_params.append(("homeAway", _params["home_away"]))
+            _query_params.append(("homeAway", _params["home_away"].value))
 
         if _params.get("include") is not None:  # noqa: E501
             _query_params.append(("include", _params["include"]))
 
         if _params.get("limit") is not None:  # noqa: E501
             _query_params.append(("limit", _params["limit"]))
 
@@ -1816,15 +1823,15 @@
                 _query_params.append(
                     ("toTimeUTC", _params["to_time_utc"].strftime(self.api_client.configuration.datetime_format))
                 )
             else:
                 _query_params.append(("toTimeUTC", _params["to_time_utc"]))
 
         if _params.get("win_loss") is not None:  # noqa: E501
-            _query_params.append(("winLoss", _params["win_loss"]))
+            _query_params.append(("winLoss", _params["win_loss"].value))
 
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
@@ -1990,28 +1997,28 @@
         :type starter: bool
         :param to_time_utc: Where fixture start time (in UTC) <= this value
         :type to_time_utc: datetime
         :param win_loss: What the result was >- `DRAW` Draw >- `LOSS` Loss >- `WIN` Win
         :type win_loss: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: SeasonPersonStatisticsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the sps_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.sps_list_with_http_info(
                 organization_id,
                 season_id,
                 sport,
                 entity_id,
                 external,
@@ -2113,15 +2120,15 @@
             Optional[datetime], Field(description="Where fixture start time (in UTC) <= this value")
         ] = None,
         win_loss: Annotated[
             Optional[constr(strict=True, max_length=50)],
             Field(description="What the result was >- `DRAW` Draw >- `LOSS` Loss >- `WIN` Win "),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Season person statistics  # noqa: E501
 
         Return a list of person statistic totals for a season  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.sps_list_with_http_info(organization_id, season_id, sport, entity_id, external, fields, fixture_type, from_time_utc, hide_null, home_away, include, is_player, is_team_official, limit, offset, person_id, pool_code, round_code, round_number, stage_code, starter, to_time_utc, win_loss, async_req=True)
@@ -2171,21 +2178,22 @@
         :type starter: bool
         :param to_time_utc: Where fixture start time (in UTC) <= this value
         :type to_time_utc: datetime
         :param win_loss: What the result was >- `DRAW` Draw >- `LOSS` Loss >- `WIN` Win
         :type win_loss: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -2264,29 +2272,29 @@
         if _params.get("external") is not None:  # noqa: E501
             _query_params.append(("external", _params["external"]))
 
         if _params.get("fields") is not None:  # noqa: E501
             _query_params.append(("fields", _params["fields"]))
 
         if _params.get("fixture_type") is not None:  # noqa: E501
-            _query_params.append(("fixtureType", _params["fixture_type"]))
+            _query_params.append(("fixtureType", _params["fixture_type"].value))
 
         if _params.get("from_time_utc") is not None:  # noqa: E501
             if isinstance(_params["from_time_utc"], datetime):
                 _query_params.append(
                     ("fromTimeUTC", _params["from_time_utc"].strftime(self.api_client.configuration.datetime_format))
                 )
             else:
                 _query_params.append(("fromTimeUTC", _params["from_time_utc"]))
 
         if _params.get("hide_null") is not None:  # noqa: E501
             _query_params.append(("hideNull", _params["hide_null"]))
 
         if _params.get("home_away") is not None:  # noqa: E501
-            _query_params.append(("homeAway", _params["home_away"]))
+            _query_params.append(("homeAway", _params["home_away"].value))
 
         if _params.get("include") is not None:  # noqa: E501
             _query_params.append(("include", _params["include"]))
 
         if _params.get("is_player") is not None:  # noqa: E501
             _query_params.append(("isPlayer", _params["is_player"]))
 
@@ -2322,15 +2330,15 @@
                 _query_params.append(
                     ("toTimeUTC", _params["to_time_utc"].strftime(self.api_client.configuration.datetime_format))
                 )
             else:
                 _query_params.append(("toTimeUTC", _params["to_time_utc"]))
 
         if _params.get("win_loss") is not None:  # noqa: E501
-            _query_params.append(("winLoss", _params["win_loss"]))
+            _query_params.append(("winLoss", _params["win_loss"].value))
 
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
@@ -2514,28 +2522,28 @@
         :type to_time_local: datetime
         :param to_time_utc: Where fixture start time (in UTC) <= this value
         :type to_time_utc: datetime
         :param win_loss: What the result was >- `DRAW` Draw >- `LOSS` Loss >- `WIN` Win
         :type win_loss: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: SeasonPersonStatisticsPeriodsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the spsp_listperiods_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.spsp_listperiods_with_http_info(
                 organization_id,
                 season_id,
                 sport,
                 entity_id,
                 external,
@@ -2651,15 +2659,15 @@
             Optional[datetime], Field(description="Where fixture start time (in UTC) <= this value")
         ] = None,
         win_loss: Annotated[
             Optional[constr(strict=True, max_length=50)],
             Field(description="What the result was >- `DRAW` Draw >- `LOSS` Loss >- `WIN` Win "),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Person season statistics by period  # noqa: E501
 
         Return a list of person statistics for a season broken down and filterable by period.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.spsp_listperiods_with_http_info(organization_id, season_id, sport, entity_id, external, fields, fixture_type, from_time_local, from_time_utc, hide_null, home_away, include, is_player, is_team_official, limit, offset, period_id, person_id, pool_code, round_code, round_number, section, stage_code, starter, to_time_local, to_time_utc, win_loss, async_req=True)
@@ -2717,21 +2725,22 @@
         :type to_time_local: datetime
         :param to_time_utc: Where fixture start time (in UTC) <= this value
         :type to_time_utc: datetime
         :param win_loss: What the result was >- `DRAW` Draw >- `LOSS` Loss >- `WIN` Win
         :type win_loss: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -2814,15 +2823,15 @@
         if _params.get("external") is not None:  # noqa: E501
             _query_params.append(("external", _params["external"]))
 
         if _params.get("fields") is not None:  # noqa: E501
             _query_params.append(("fields", _params["fields"]))
 
         if _params.get("fixture_type") is not None:  # noqa: E501
-            _query_params.append(("fixtureType", _params["fixture_type"]))
+            _query_params.append(("fixtureType", _params["fixture_type"].value))
 
         if _params.get("from_time_local") is not None:  # noqa: E501
             if isinstance(_params["from_time_local"], datetime):
                 _query_params.append(
                     (
                         "fromTimeLocal",
                         _params["from_time_local"].strftime(self.api_client.configuration.datetime_format),
@@ -2839,15 +2848,15 @@
             else:
                 _query_params.append(("fromTimeUTC", _params["from_time_utc"]))
 
         if _params.get("hide_null") is not None:  # noqa: E501
             _query_params.append(("hideNull", _params["hide_null"]))
 
         if _params.get("home_away") is not None:  # noqa: E501
-            _query_params.append(("homeAway", _params["home_away"]))
+            _query_params.append(("homeAway", _params["home_away"].value))
 
         if _params.get("include") is not None:  # noqa: E501
             _query_params.append(("include", _params["include"]))
 
         if _params.get("is_player") is not None:  # noqa: E501
             _query_params.append(("isPlayer", _params["is_player"]))
 
@@ -2897,15 +2906,15 @@
                 _query_params.append(
                     ("toTimeUTC", _params["to_time_utc"].strftime(self.api_client.configuration.datetime_format))
                 )
             else:
                 _query_params.append(("toTimeUTC", _params["to_time_utc"]))
 
         if _params.get("win_loss") is not None:  # noqa: E501
-            _query_params.append(("winLoss", _params["win_loss"]))
+            _query_params.append(("winLoss", _params["win_loss"].value))
 
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
@@ -3081,28 +3090,28 @@
         :type to_time_local: datetime
         :param to_time_utc: Where fixture start time (in UTC) <= this value
         :type to_time_utc: datetime
         :param win_loss: What the result was >- `DRAW` Draw >- `LOSS` Loss >- `WIN` Win
         :type win_loss: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: SeasonPersonTotalStatisticsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the spts_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.spts_list_with_http_info(
                 organization_id,
                 season_id,
                 sport,
                 entity_id,
                 external,
@@ -3212,15 +3221,15 @@
             Optional[datetime], Field(description="Where fixture start time (in UTC) <= this value")
         ] = None,
         win_loss: Annotated[
             Optional[constr(strict=True, max_length=50)],
             Field(description="What the result was >- `DRAW` Draw >- `LOSS` Loss >- `WIN` Win "),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Person season statistics - combined teams  # noqa: E501
 
              Return a list of person statistic totals for a person over multiple seasons.     If a person plays for multiple entities in a season then their statistics are normally separated     out by entity. For this call the statistics are combined - and hence entity data is not available.       # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.spts_list_with_http_info(organization_id, season_id, sport, entity_id, external, fields, fixture_type, from_time_local, from_time_utc, hide_null, home_away, include, is_player, is_team_official, limit, offset, person_id, pool_code, round_code, round_number, stage_code, starter, to_time_local, to_time_utc, win_loss, async_req=True)
@@ -3274,21 +3283,22 @@
         :type to_time_local: datetime
         :param to_time_utc: Where fixture start time (in UTC) <= this value
         :type to_time_utc: datetime
         :param win_loss: What the result was >- `DRAW` Draw >- `LOSS` Loss >- `WIN` Win
         :type win_loss: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -3369,15 +3379,15 @@
         if _params.get("external") is not None:  # noqa: E501
             _query_params.append(("external", _params["external"]))
 
         if _params.get("fields") is not None:  # noqa: E501
             _query_params.append(("fields", _params["fields"]))
 
         if _params.get("fixture_type") is not None:  # noqa: E501
-            _query_params.append(("fixtureType", _params["fixture_type"]))
+            _query_params.append(("fixtureType", _params["fixture_type"].value))
 
         if _params.get("from_time_local") is not None:  # noqa: E501
             if isinstance(_params["from_time_local"], datetime):
                 _query_params.append(
                     (
                         "fromTimeLocal",
                         _params["from_time_local"].strftime(self.api_client.configuration.datetime_format),
@@ -3394,15 +3404,15 @@
             else:
                 _query_params.append(("fromTimeUTC", _params["from_time_utc"]))
 
         if _params.get("hide_null") is not None:  # noqa: E501
             _query_params.append(("hideNull", _params["hide_null"]))
 
         if _params.get("home_away") is not None:  # noqa: E501
-            _query_params.append(("homeAway", _params["home_away"]))
+            _query_params.append(("homeAway", _params["home_away"].value))
 
         if _params.get("include") is not None:  # noqa: E501
             _query_params.append(("include", _params["include"]))
 
         if _params.get("is_player") is not None:  # noqa: E501
             _query_params.append(("isPlayer", _params["is_player"]))
 
@@ -3446,15 +3456,15 @@
                 _query_params.append(
                     ("toTimeUTC", _params["to_time_utc"].strftime(self.api_client.configuration.datetime_format))
                 )
             else:
                 _query_params.append(("toTimeUTC", _params["to_time_utc"]))
 
         if _params.get("win_loss") is not None:  # noqa: E501
-            _query_params.append(("winLoss", _params["win_loss"]))
+            _query_params.append(("winLoss", _params["win_loss"].value))
 
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/api/seasons_api.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/api/seasons_api.py`

 * *Files 4% similar despite different names*

```diff
@@ -8,23 +8,26 @@
     The version of the OpenAPI document: v1
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the file manually.
 """
 
 
+import io
 import logging
 import re  # noqa: F401
+import warnings
 from datetime import date, datetime
 from typing import Optional
 
 from pydantic import Field, StrictBool, StrictInt, StrictStr, ValidationError, conint, constr, validate_arguments
 from typing_extensions import Annotated
 
 from atriumsports.datacore.openapi.api_client import ApiClient
+from atriumsports.datacore.openapi.api_response import ApiResponse
 from atriumsports.datacore.openapi.exceptions import ApiTypeError, ApiValueError  # noqa: F401
 from atriumsports.datacore.openapi.models.season_post_body import SeasonPostBody
 from atriumsports.datacore.openapi.models.season_put_body import SeasonPutBody
 from atriumsports.datacore.openapi.models.seasons_response import SeasonsResponse
 
 logger = logging.getLogger("openapi")
 
@@ -102,28 +105,28 @@
         :type force_delete: bool
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: SeasonsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the season_delete_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.season_delete_with_http_info(
                 organization_id, season_id, sport, external, fields, force_delete, hide_null, include, **kwargs
             )  # noqa: E501
         except Exception as e:
             logger.error("Exception when calling SeasonsApi->season_delete: %s\n" % e)
             raise
@@ -161,15 +164,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Delete a season  # noqa: E501
 
         Delete a specific season  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.season_delete_with_http_info(organization_id, season_id, sport, external, fields, force_delete, hide_null, include, async_req=True)
@@ -189,21 +192,22 @@
         :type force_delete: bool
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -381,28 +385,28 @@
         :type include: str
         :param limit: The maximum number of records to return. See [Pagination](#section/Introduction/Pagination) for more information.
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: SeasonsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the season_detail_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.season_detail_with_http_info(
                 organization_id, season_id, sport, external, fields, hide_null, include, limit, offset, **kwargs
             )  # noqa: E501
         except Exception as e:
             logger.error("Exception when calling SeasonsApi->season_detail: %s\n" % e)
             raise
@@ -446,15 +450,15 @@
         offset: Annotated[
             Optional[StrictInt],
             Field(
                 description="The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Get a season  # noqa: E501
 
         Return detailed information about a specific season  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.season_detail_with_http_info(organization_id, season_id, sport, external, fields, hide_null, include, limit, offset, async_req=True)
@@ -476,21 +480,22 @@
         :type include: str
         :param limit: The maximum number of records to return. See [Pagination](#section/Introduction/Pagination) for more information.
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -659,28 +664,28 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: SeasonsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the season_insert_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.season_insert_with_http_info(
                 competition_id, organization_id, sport, season_post_body, external, fields, hide_null, include, **kwargs
             )  # noqa: E501
         except Exception as e:
             logger.error("Exception when calling SeasonsApi->season_insert: %s\n" % e)
             raise
@@ -713,15 +718,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Create a new season  # noqa: E501
 
         Add a new season  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.season_insert_with_http_info(competition_id, organization_id, sport, season_post_body, external, fields, hide_null, include, async_req=True)
@@ -741,21 +746,22 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -828,15 +834,15 @@
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params["season_post_body"]:
+        if _params["season_post_body"] is not None:
             _body_params = _params["season_post_body"]
 
         # set the HTTP header `Accept`
         _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501
 
         # set the HTTP header `Content-Type`
         _content_types_list = _params.get(
@@ -1040,28 +1046,28 @@
         :type status: str
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param video_production: Data synchronization strategy with video production systems. Multiple allowed (comma-delimited). >- `AUTOMATED` Automated >- `MANUAL` Manual >- `NONE` None
         :type video_production: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: SeasonsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the season_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.season_list_with_http_info(
                 competition_id,
                 organization_id,
                 sport,
                 added,
                 age_group,
@@ -1199,15 +1205,15 @@
         video_production: Annotated[
             Optional[constr(strict=True, max_length=50)],
             Field(
                 description="Data synchronization strategy with video production systems. Multiple allowed (comma-delimited). >- `AUTOMATED` Automated >- `MANUAL` Manual >- `NONE` None "
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Get a list of seasons  # noqa: E501
 
         Return a list of seasons in the competition.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.season_list_with_http_info(competition_id, organization_id, sport, added, age_group, end_date, event_type, external, fields, gender, hide_null, include, limit, name_latin_contains, name_local_contains, offset, representation, season_type, sort_by, standard, start_date, status, updated, video_production, async_req=True)
@@ -1259,21 +1265,22 @@
         :type status: str
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param video_production: Data synchronization strategy with video production systems. Multiple allowed (comma-delimited). >- `AUTOMATED` Automated >- `MANUAL` Manual >- `NONE` None
         :type video_production: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1352,35 +1359,35 @@
                 _query_params.append(
                     ("added", _params["added"].strftime(self.api_client.configuration.datetime_format))
                 )
             else:
                 _query_params.append(("added", _params["added"]))
 
         if _params.get("age_group") is not None:  # noqa: E501
-            _query_params.append(("ageGroup", _params["age_group"]))
+            _query_params.append(("ageGroup", _params["age_group"].value))
 
         if _params.get("end_date") is not None:  # noqa: E501
             if isinstance(_params["end_date"], datetime):
-                _query_parame.append(
+                _query_params.append(
                     ("endDate", _params["end_date"].strftime(self.api_client.configuration.date_format))
                 )
             else:
                 _query_params.append(("endDate", _params["end_date"]))
 
         if _params.get("event_type") is not None:  # noqa: E501
-            _query_params.append(("eventType", _params["event_type"]))
+            _query_params.append(("eventType", _params["event_type"].value))
 
         if _params.get("external") is not None:  # noqa: E501
             _query_params.append(("external", _params["external"]))
 
         if _params.get("fields") is not None:  # noqa: E501
             _query_params.append(("fields", _params["fields"]))
 
         if _params.get("gender") is not None:  # noqa: E501
-            _query_params.append(("gender", _params["gender"]))
+            _query_params.append(("gender", _params["gender"].value))
 
         if _params.get("hide_null") is not None:  # noqa: E501
             _query_params.append(("hideNull", _params["hide_null"]))
 
         if _params.get("include") is not None:  # noqa: E501
             _query_params.append(("include", _params["include"]))
 
@@ -1393,46 +1400,46 @@
         if _params.get("name_local_contains") is not None:  # noqa: E501
             _query_params.append(("nameLocalContains", _params["name_local_contains"]))
 
         if _params.get("offset") is not None:  # noqa: E501
             _query_params.append(("offset", _params["offset"]))
 
         if _params.get("representation") is not None:  # noqa: E501
-            _query_params.append(("representation", _params["representation"]))
+            _query_params.append(("representation", _params["representation"].value))
 
         if _params.get("season_type") is not None:  # noqa: E501
-            _query_params.append(("seasonType", _params["season_type"]))
+            _query_params.append(("seasonType", _params["season_type"].value))
 
         if _params.get("sort_by") is not None:  # noqa: E501
             _query_params.append(("sortBy", _params["sort_by"]))
 
         if _params.get("standard") is not None:  # noqa: E501
-            _query_params.append(("standard", _params["standard"]))
+            _query_params.append(("standard", _params["standard"].value))
 
         if _params.get("start_date") is not None:  # noqa: E501
             if isinstance(_params["start_date"], datetime):
-                _query_parame.append(
+                _query_params.append(
                     ("startDate", _params["start_date"].strftime(self.api_client.configuration.date_format))
                 )
             else:
                 _query_params.append(("startDate", _params["start_date"]))
 
         if _params.get("status") is not None:  # noqa: E501
-            _query_params.append(("status", _params["status"]))
+            _query_params.append(("status", _params["status"].value))
 
         if _params.get("updated") is not None:  # noqa: E501
             if isinstance(_params["updated"], datetime):
                 _query_params.append(
                     ("updated", _params["updated"].strftime(self.api_client.configuration.datetime_format))
                 )
             else:
                 _query_params.append(("updated", _params["updated"]))
 
         if _params.get("video_production") is not None:  # noqa: E501
-            _query_params.append(("videoProduction", _params["video_production"]))
+            _query_params.append(("videoProduction", _params["video_production"].value))
 
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
@@ -1520,14 +1527,26 @@
         ] = None,
         limit: Annotated[
             Optional[conint(strict=True, le=1000, ge=1)],
             Field(
                 description="The maximum number of records to return. See [Pagination](#section/Introduction/Pagination) for more information."
             ),
         ] = None,
+        name_latin_contains: Annotated[
+            Optional[constr(strict=True, max_length=50, min_length=2)],
+            Field(
+                description="Fields that allow a 'Contains' query string parameter search for words separated by a space, matching characters left to right. Example: nameLatin=David Johnson nameLatinContains=Dav will match nameLatinContains=John will match nameLatinContains=son will not match"
+            ),
+        ] = None,
+        name_local_contains: Annotated[
+            Optional[constr(strict=True, max_length=50, min_length=2)],
+            Field(
+                description="Fields that allow a 'Contains' query string parameter search for words separated by a space, matching characters left to right. Example: nameLocal=David Johnson nameLocalContains=Dav will match nameLocalContains=John will match nameLocalContains=son will not match"
+            ),
+        ] = None,
         offset: Annotated[
             Optional[StrictInt],
             Field(
                 description="The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information."
             ),
         ] = None,
         representation: Annotated[
@@ -1538,14 +1557,20 @@
         ] = None,
         season_type: Annotated[
             Optional[StrictStr],
             Field(
                 description="The type of matches added to this season >- `ONE_OFF` One off match >- `SEASON` Season >- `TOURNAMENT` Tournament "
             ),
         ] = None,
+        sort_by: Annotated[
+            Optional[StrictStr],
+            Field(
+                description="Comma-delimited list of one or more fields to sort by, each field can have '-' as prefix to sort in descending order, and '+' (or no prefix) to sort in ascending order."
+            ),
+        ] = None,
         standard: Annotated[
             Optional[StrictStr],
             Field(
                 description="The playing standard of the season or entity >- `ELITE` Professional/elite organisation >- `FRIENDLY` International Friendly >- `GRASS_ROOT` Normal >- `INTERNATIONAL` International >- `NONCONTINENTAL_CHAMPIONSHIP` Non-continental Championship >- `OLYMPIC` Olympics >- `REGION` Regional >- `TIER2` lesser standard than elite >- `TIER3` lesser standard than tier 2 >- `WORLD_CHAMPIONSHIP` World Championship >- `ZONE_CHAMPIONSHIP` International Zone Championship "
             ),
         ] = None,
         start_date: Annotated[Optional[date], Field(description="startDate on or after this date")] = None,
@@ -1566,15 +1591,15 @@
     ) -> SeasonsResponse:  # noqa: E501
         """Get a list of seasons for an organization  # noqa: E501
 
         Return a list of seasons in an organization.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
-        >>> thread = api.season_list_by_organization(organization_id, sport, added, age_group, competition_id, end_date, event_type, external, fields, gender, hide_null, include, limit, offset, representation, season_type, standard, start_date, status, updated, video_production, async_req=True)
+        >>> thread = api.season_list_by_organization(organization_id, sport, added, age_group, competition_id, end_date, event_type, external, fields, gender, hide_null, include, limit, name_latin_contains, name_local_contains, offset, representation, season_type, sort_by, standard, start_date, status, updated, video_production, async_req=True)
         >>> result = thread.get()
 
         :param organization_id: The unique identifier of the organization (required)
         :type organization_id: str
         :param sport: Sport name (required)
         :type sport: str
         :param added: Record was added after this date/time. In UTC.
@@ -1595,46 +1620,52 @@
         :type gender: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param limit: The maximum number of records to return. See [Pagination](#section/Introduction/Pagination) for more information.
         :type limit: int
+        :param name_latin_contains: Fields that allow a 'Contains' query string parameter search for words separated by a space, matching characters left to right. Example: nameLatin=David Johnson nameLatinContains=Dav will match nameLatinContains=John will match nameLatinContains=son will not match
+        :type name_latin_contains: str
+        :param name_local_contains: Fields that allow a 'Contains' query string parameter search for words separated by a space, matching characters left to right. Example: nameLocal=David Johnson nameLocalContains=Dav will match nameLocalContains=John will match nameLocalContains=son will not match
+        :type name_local_contains: str
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param representation: What level are the competitors representing >- `CLUB` Club >- `COUNTRY` Country >- `PERSON` Person
         :type representation: str
         :param season_type: The type of matches added to this season >- `ONE_OFF` One off match >- `SEASON` Season >- `TOURNAMENT` Tournament
         :type season_type: str
+        :param sort_by: Comma-delimited list of one or more fields to sort by, each field can have '-' as prefix to sort in descending order, and '+' (or no prefix) to sort in ascending order.
+        :type sort_by: str
         :param standard: The playing standard of the season or entity >- `ELITE` Professional/elite organisation >- `FRIENDLY` International Friendly >- `GRASS_ROOT` Normal >- `INTERNATIONAL` International >- `NONCONTINENTAL_CHAMPIONSHIP` Non-continental Championship >- `OLYMPIC` Olympics >- `REGION` Regional >- `TIER2` lesser standard than elite >- `TIER3` lesser standard than tier 2 >- `WORLD_CHAMPIONSHIP` World Championship >- `ZONE_CHAMPIONSHIP` International Zone Championship
         :type standard: str
         :param start_date: startDate on or after this date
         :type start_date: date
         :param status: Status >- `ACTIVE` Active >- `INACTIVE` Inactive >- `PENDING` Pending
         :type status: str
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param video_production: Data synchronization strategy with video production systems. Multiple allowed (comma-delimited). >- `AUTOMATED` Automated >- `MANUAL` Manual >- `NONE` None
         :type video_production: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: SeasonsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the season_list_by_organization_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.season_list_by_organization_with_http_info(
                 organization_id,
                 sport,
                 added,
                 age_group,
                 competition_id,
@@ -1642,17 +1673,20 @@
                 event_type,
                 external,
                 fields,
                 gender,
                 hide_null,
                 include,
                 limit,
+                name_latin_contains,
+                name_local_contains,
                 offset,
                 representation,
                 season_type,
+                sort_by,
                 standard,
                 start_date,
                 status,
                 updated,
                 video_production,
                 **kwargs
             )  # noqa: E501
@@ -1714,14 +1748,26 @@
         ] = None,
         limit: Annotated[
             Optional[conint(strict=True, le=1000, ge=1)],
             Field(
                 description="The maximum number of records to return. See [Pagination](#section/Introduction/Pagination) for more information."
             ),
         ] = None,
+        name_latin_contains: Annotated[
+            Optional[constr(strict=True, max_length=50, min_length=2)],
+            Field(
+                description="Fields that allow a 'Contains' query string parameter search for words separated by a space, matching characters left to right. Example: nameLatin=David Johnson nameLatinContains=Dav will match nameLatinContains=John will match nameLatinContains=son will not match"
+            ),
+        ] = None,
+        name_local_contains: Annotated[
+            Optional[constr(strict=True, max_length=50, min_length=2)],
+            Field(
+                description="Fields that allow a 'Contains' query string parameter search for words separated by a space, matching characters left to right. Example: nameLocal=David Johnson nameLocalContains=Dav will match nameLocalContains=John will match nameLocalContains=son will not match"
+            ),
+        ] = None,
         offset: Annotated[
             Optional[StrictInt],
             Field(
                 description="The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information."
             ),
         ] = None,
         representation: Annotated[
@@ -1732,14 +1778,20 @@
         ] = None,
         season_type: Annotated[
             Optional[StrictStr],
             Field(
                 description="The type of matches added to this season >- `ONE_OFF` One off match >- `SEASON` Season >- `TOURNAMENT` Tournament "
             ),
         ] = None,
+        sort_by: Annotated[
+            Optional[StrictStr],
+            Field(
+                description="Comma-delimited list of one or more fields to sort by, each field can have '-' as prefix to sort in descending order, and '+' (or no prefix) to sort in ascending order."
+            ),
+        ] = None,
         standard: Annotated[
             Optional[StrictStr],
             Field(
                 description="The playing standard of the season or entity >- `ELITE` Professional/elite organisation >- `FRIENDLY` International Friendly >- `GRASS_ROOT` Normal >- `INTERNATIONAL` International >- `NONCONTINENTAL_CHAMPIONSHIP` Non-continental Championship >- `OLYMPIC` Olympics >- `REGION` Regional >- `TIER2` lesser standard than elite >- `TIER3` lesser standard than tier 2 >- `WORLD_CHAMPIONSHIP` World Championship >- `ZONE_CHAMPIONSHIP` International Zone Championship "
             ),
         ] = None,
         start_date: Annotated[Optional[date], Field(description="startDate on or after this date")] = None,
@@ -1753,22 +1805,22 @@
         video_production: Annotated[
             Optional[constr(strict=True, max_length=50)],
             Field(
                 description="Data synchronization strategy with video production systems. Multiple allowed (comma-delimited). >- `AUTOMATED` Automated >- `MANUAL` Manual >- `NONE` None "
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Get a list of seasons for an organization  # noqa: E501
 
         Return a list of seasons in an organization.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
-        >>> thread = api.season_list_by_organization_with_http_info(organization_id, sport, added, age_group, competition_id, end_date, event_type, external, fields, gender, hide_null, include, limit, offset, representation, season_type, standard, start_date, status, updated, video_production, async_req=True)
+        >>> thread = api.season_list_by_organization_with_http_info(organization_id, sport, added, age_group, competition_id, end_date, event_type, external, fields, gender, hide_null, include, limit, name_latin_contains, name_local_contains, offset, representation, season_type, sort_by, standard, start_date, status, updated, video_production, async_req=True)
         >>> result = thread.get()
 
         :param organization_id: The unique identifier of the organization (required)
         :type organization_id: str
         :param sport: Sport name (required)
         :type sport: str
         :param added: Record was added after this date/time. In UTC.
@@ -1789,39 +1841,46 @@
         :type gender: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param limit: The maximum number of records to return. See [Pagination](#section/Introduction/Pagination) for more information.
         :type limit: int
+        :param name_latin_contains: Fields that allow a 'Contains' query string parameter search for words separated by a space, matching characters left to right. Example: nameLatin=David Johnson nameLatinContains=Dav will match nameLatinContains=John will match nameLatinContains=son will not match
+        :type name_latin_contains: str
+        :param name_local_contains: Fields that allow a 'Contains' query string parameter search for words separated by a space, matching characters left to right. Example: nameLocal=David Johnson nameLocalContains=Dav will match nameLocalContains=John will match nameLocalContains=son will not match
+        :type name_local_contains: str
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param representation: What level are the competitors representing >- `CLUB` Club >- `COUNTRY` Country >- `PERSON` Person
         :type representation: str
         :param season_type: The type of matches added to this season >- `ONE_OFF` One off match >- `SEASON` Season >- `TOURNAMENT` Tournament
         :type season_type: str
+        :param sort_by: Comma-delimited list of one or more fields to sort by, each field can have '-' as prefix to sort in descending order, and '+' (or no prefix) to sort in ascending order.
+        :type sort_by: str
         :param standard: The playing standard of the season or entity >- `ELITE` Professional/elite organisation >- `FRIENDLY` International Friendly >- `GRASS_ROOT` Normal >- `INTERNATIONAL` International >- `NONCONTINENTAL_CHAMPIONSHIP` Non-continental Championship >- `OLYMPIC` Olympics >- `REGION` Regional >- `TIER2` lesser standard than elite >- `TIER3` lesser standard than tier 2 >- `WORLD_CHAMPIONSHIP` World Championship >- `ZONE_CHAMPIONSHIP` International Zone Championship
         :type standard: str
         :param start_date: startDate on or after this date
         :type start_date: date
         :param status: Status >- `ACTIVE` Active >- `INACTIVE` Inactive >- `PENDING` Pending
         :type status: str
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param video_production: Data synchronization strategy with video production systems. Multiple allowed (comma-delimited). >- `AUTOMATED` Automated >- `MANUAL` Manual >- `NONE` None
         :type video_production: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1845,17 +1904,20 @@
             "event_type",
             "external",
             "fields",
             "gender",
             "hide_null",
             "include",
             "limit",
+            "name_latin_contains",
+            "name_local_contains",
             "offset",
             "representation",
             "season_type",
+            "sort_by",
             "standard",
             "start_date",
             "status",
             "updated",
             "video_production",
         ]
         _all_params.extend(
@@ -1896,81 +1958,90 @@
                 _query_params.append(
                     ("added", _params["added"].strftime(self.api_client.configuration.datetime_format))
                 )
             else:
                 _query_params.append(("added", _params["added"]))
 
         if _params.get("age_group") is not None:  # noqa: E501
-            _query_params.append(("ageGroup", _params["age_group"]))
+            _query_params.append(("ageGroup", _params["age_group"].value))
 
         if _params.get("competition_id") is not None:  # noqa: E501
             _query_params.append(("competitionId", _params["competition_id"]))
 
         if _params.get("end_date") is not None:  # noqa: E501
             if isinstance(_params["end_date"], datetime):
-                _query_parame.append(
+                _query_params.append(
                     ("endDate", _params["end_date"].strftime(self.api_client.configuration.date_format))
                 )
             else:
                 _query_params.append(("endDate", _params["end_date"]))
 
         if _params.get("event_type") is not None:  # noqa: E501
-            _query_params.append(("eventType", _params["event_type"]))
+            _query_params.append(("eventType", _params["event_type"].value))
 
         if _params.get("external") is not None:  # noqa: E501
             _query_params.append(("external", _params["external"]))
 
         if _params.get("fields") is not None:  # noqa: E501
             _query_params.append(("fields", _params["fields"]))
 
         if _params.get("gender") is not None:  # noqa: E501
-            _query_params.append(("gender", _params["gender"]))
+            _query_params.append(("gender", _params["gender"].value))
 
         if _params.get("hide_null") is not None:  # noqa: E501
             _query_params.append(("hideNull", _params["hide_null"]))
 
         if _params.get("include") is not None:  # noqa: E501
             _query_params.append(("include", _params["include"]))
 
         if _params.get("limit") is not None:  # noqa: E501
             _query_params.append(("limit", _params["limit"]))
 
+        if _params.get("name_latin_contains") is not None:  # noqa: E501
+            _query_params.append(("nameLatinContains", _params["name_latin_contains"]))
+
+        if _params.get("name_local_contains") is not None:  # noqa: E501
+            _query_params.append(("nameLocalContains", _params["name_local_contains"]))
+
         if _params.get("offset") is not None:  # noqa: E501
             _query_params.append(("offset", _params["offset"]))
 
         if _params.get("representation") is not None:  # noqa: E501
-            _query_params.append(("representation", _params["representation"]))
+            _query_params.append(("representation", _params["representation"].value))
 
         if _params.get("season_type") is not None:  # noqa: E501
-            _query_params.append(("seasonType", _params["season_type"]))
+            _query_params.append(("seasonType", _params["season_type"].value))
+
+        if _params.get("sort_by") is not None:  # noqa: E501
+            _query_params.append(("sortBy", _params["sort_by"]))
 
         if _params.get("standard") is not None:  # noqa: E501
-            _query_params.append(("standard", _params["standard"]))
+            _query_params.append(("standard", _params["standard"].value))
 
         if _params.get("start_date") is not None:  # noqa: E501
             if isinstance(_params["start_date"], datetime):
-                _query_parame.append(
+                _query_params.append(
                     ("startDate", _params["start_date"].strftime(self.api_client.configuration.date_format))
                 )
             else:
                 _query_params.append(("startDate", _params["start_date"]))
 
         if _params.get("status") is not None:  # noqa: E501
-            _query_params.append(("status", _params["status"]))
+            _query_params.append(("status", _params["status"].value))
 
         if _params.get("updated") is not None:  # noqa: E501
             if isinstance(_params["updated"], datetime):
                 _query_params.append(
                     ("updated", _params["updated"].strftime(self.api_client.configuration.datetime_format))
                 )
             else:
                 _query_params.append(("updated", _params["updated"]))
 
         if _params.get("video_production") is not None:  # noqa: E501
-            _query_params.append(("videoProduction", _params["video_production"]))
+            _query_params.append(("videoProduction", _params["video_production"].value))
 
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
@@ -2060,28 +2131,28 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: SeasonsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the season_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.season_update_with_http_info(
                 organization_id, season_id, sport, season_put_body, external, fields, hide_null, include, **kwargs
             )  # noqa: E501
         except Exception as e:
             logger.error("Exception when calling SeasonsApi->season_update: %s\n" % e)
             raise
@@ -2114,15 +2185,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Update a season  # noqa: E501
 
         Change the information of a specific season  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.season_update_with_http_info(organization_id, season_id, sport, season_put_body, external, fields, hide_null, include, async_req=True)
@@ -2142,21 +2213,22 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -2229,15 +2301,15 @@
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params["season_put_body"]:
+        if _params["season_put_body"] is not None:
             _body_params = _params["season_put_body"]
 
         # set the HTTP header `Accept`
         _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501
 
         # set the HTTP header `Content-Type`
         _content_types_list = _params.get(
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/api/sites_api.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/api/sites_api.py`

 * *Files 6% similar despite different names*

```diff
@@ -8,23 +8,26 @@
     The version of the OpenAPI document: v1
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the file manually.
 """
 
 
+import io
 import logging
 import re  # noqa: F401
+import warnings
 from datetime import datetime
 from typing import Optional
 
 from pydantic import Field, StrictBool, StrictInt, StrictStr, ValidationError, conint, constr, validate_arguments
 from typing_extensions import Annotated
 
 from atriumsports.datacore.openapi.api_client import ApiClient
+from atriumsports.datacore.openapi.api_response import ApiResponse
 from atriumsports.datacore.openapi.exceptions import ApiTypeError, ApiValueError  # noqa: F401
 from atriumsports.datacore.openapi.models.site_post_body import SitePostBody
 from atriumsports.datacore.openapi.models.site_put_body import SitePutBody
 from atriumsports.datacore.openapi.models.sites_response import SitesResponse
 
 logger = logging.getLogger("openapi")
 
@@ -102,28 +105,28 @@
         :type force_delete: bool
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: SitesResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the site_delete_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.site_delete_with_http_info(
                 organization_id, site_id, sport, external, fields, force_delete, hide_null, include, **kwargs
             )  # noqa: E501
         except Exception as e:
             logger.error("Exception when calling SitesApi->site_delete: %s\n" % e)
             raise
@@ -161,15 +164,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Delete a site  # noqa: E501
 
         Delete a specific site  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.site_delete_with_http_info(organization_id, site_id, sport, external, fields, force_delete, hide_null, include, async_req=True)
@@ -189,21 +192,22 @@
         :type force_delete: bool
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -381,28 +385,28 @@
         :type include: str
         :param limit: The maximum number of records to return. See [Pagination](#section/Introduction/Pagination) for more information.
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: SitesResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the site_detail_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.site_detail_with_http_info(
                 organization_id, site_id, sport, external, fields, hide_null, include, limit, offset, **kwargs
             )  # noqa: E501
         except Exception as e:
             logger.error("Exception when calling SitesApi->site_detail: %s\n" % e)
             raise
@@ -446,15 +450,15 @@
         offset: Annotated[
             Optional[StrictInt],
             Field(
                 description="The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Get a site  # noqa: E501
 
         Return detailed information about a specific site  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.site_detail_with_http_info(organization_id, site_id, sport, external, fields, hide_null, include, limit, offset, async_req=True)
@@ -476,21 +480,22 @@
         :type include: str
         :param limit: The maximum number of records to return. See [Pagination](#section/Introduction/Pagination) for more information.
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -656,28 +661,28 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: SitesResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the site_insert_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.site_insert_with_http_info(
                 organization_id, sport, site_post_body, external, fields, hide_null, include, **kwargs
             )  # noqa: E501
         except Exception as e:
             logger.error("Exception when calling SitesApi->site_insert: %s\n" % e)
             raise
@@ -709,15 +714,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Create a site  # noqa: E501
 
         Add a new site  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.site_insert_with_http_info(organization_id, sport, site_post_body, external, fields, hide_null, include, async_req=True)
@@ -735,21 +740,22 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -810,15 +816,15 @@
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params["site_post_body"]:
+        if _params["site_post_body"] is not None:
             _body_params = _params["site_post_body"]
 
         # set the HTTP header `Accept`
         _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501
 
         # set the HTTP header `Content-Type`
         _content_types_list = _params.get(
@@ -934,28 +940,28 @@
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: SitesResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the site_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.site_list_with_http_info(
                 organization_id,
                 sport,
                 added,
                 country_code,
                 external,
@@ -1018,15 +1024,15 @@
                 description="The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information."
             ),
         ] = None,
         updated: Annotated[
             Optional[datetime], Field(description="Record was modified after this date/time. In UTC.")
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Get a list of sites  # noqa: E501
 
         Return a list of available sites  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.site_list_with_http_info(organization_id, sport, added, country_code, external, fields, hide_null, include, limit, offset, updated, async_req=True)
@@ -1052,21 +1058,22 @@
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1253,28 +1260,28 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: SitesResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the site_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.site_update_with_http_info(
                 organization_id, site_id, sport, site_put_body, external, fields, hide_null, include, **kwargs
             )  # noqa: E501
         except Exception as e:
             logger.error("Exception when calling SitesApi->site_update: %s\n" % e)
             raise
@@ -1307,15 +1314,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Update a site  # noqa: E501
 
         Change the information of a specific site  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.site_update_with_http_info(organization_id, site_id, sport, site_put_body, external, fields, hide_null, include, async_req=True)
@@ -1335,21 +1342,22 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1422,15 +1430,15 @@
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params["site_put_body"]:
+        if _params["site_put_body"] is not None:
             _body_params = _params["site_put_body"]
 
         # set the HTTP header `Accept`
         _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501
 
         # set the HTTP header `Content-Type`
         _content_types_list = _params.get(
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/api/stages_pools_rounds_api.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/api/stages_pools_rounds_api.py`

 * *Files 5% similar despite different names*

```diff
@@ -8,23 +8,26 @@
     The version of the OpenAPI document: v1
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the file manually.
 """
 
 
+import io
 import logging
 import re  # noqa: F401
+import warnings
 from datetime import datetime
 from typing import Optional
 
 from pydantic import Field, StrictBool, StrictInt, StrictStr, ValidationError, conint, constr, validate_arguments
 from typing_extensions import Annotated
 
 from atriumsports.datacore.openapi.api_client import ApiClient
+from atriumsports.datacore.openapi.api_response import ApiResponse
 from atriumsports.datacore.openapi.exceptions import ApiTypeError, ApiValueError  # noqa: F401
 from atriumsports.datacore.openapi.models.pool_post_body import PoolPostBody
 from atriumsports.datacore.openapi.models.pool_put_body import PoolPutBody
 from atriumsports.datacore.openapi.models.round_post_body import RoundPostBody
 from atriumsports.datacore.openapi.models.round_put_body import RoundPutBody
 from atriumsports.datacore.openapi.models.season_pools_response import SeasonPoolsResponse
 from atriumsports.datacore.openapi.models.season_rounds_response import SeasonRoundsResponse
@@ -121,28 +124,28 @@
         :type include: str
         :param limit: The maximum number of records to return. See [Pagination](#section/Introduction/Pagination) for more information.
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: SeasonPoolsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the season_pool_detail_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.season_pool_detail_with_http_info(
                 organization_id,
                 pool_code,
                 season_id,
                 sport,
                 external,
@@ -199,15 +202,15 @@
         offset: Annotated[
             Optional[StrictInt],
             Field(
                 description="The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Get a pool  # noqa: E501
 
         Return detailed information about a specific pool  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.season_pool_detail_with_http_info(organization_id, pool_code, season_id, sport, external, fields, hide_null, include, limit, offset, async_req=True)
@@ -231,21 +234,22 @@
         :type include: str
         :param limit: The maximum number of records to return. See [Pagination](#section/Introduction/Pagination) for more information.
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -418,28 +422,28 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: SeasonPoolsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the season_pool_insert_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.season_pool_insert_with_http_info(
                 organization_id, season_id, sport, pool_post_body, external, fields, hide_null, include, **kwargs
             )  # noqa: E501
         except Exception as e:
             logger.error("Exception when calling StagesPoolsRoundsApi->season_pool_insert: %s\n" % e)
             raise
@@ -472,15 +476,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Create a pool  # noqa: E501
 
         Add a new pool into a season  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.season_pool_insert_with_http_info(organization_id, season_id, sport, pool_post_body, external, fields, hide_null, include, async_req=True)
@@ -500,21 +504,22 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -587,15 +592,15 @@
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params["pool_post_body"]:
+        if _params["pool_post_body"] is not None:
             _body_params = _params["pool_post_body"]
 
         # set the HTTP header `Accept`
         _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501
 
         # set the HTTP header `Content-Type`
         _content_types_list = _params.get(
@@ -714,28 +719,28 @@
         :type offset: int
         :param stage_code: The stage identifier within a season
         :type stage_code: str
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: SeasonPoolsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the season_pool_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.season_pool_list_with_http_info(
                 organization_id,
                 season_id,
                 sport,
                 added,
                 external,
@@ -800,15 +805,15 @@
         stage_code: Annotated[
             Optional[constr(strict=True, max_length=30)], Field(description="The stage identifier within a season")
         ] = None,
         updated: Annotated[
             Optional[datetime], Field(description="Record was modified after this date/time. In UTC.")
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Get a list of pools  # noqa: E501
 
         Return a list of the pools for a season  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.season_pool_list_with_http_info(organization_id, season_id, sport, added, external, fields, hide_null, include, limit, offset, stage_code, updated, async_req=True)
@@ -836,21 +841,22 @@
         :type offset: int
         :param stage_code: The stage identifier within a season
         :type stage_code: str
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1046,28 +1052,28 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: SeasonPoolsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the season_pool_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.season_pool_update_with_http_info(
                 organization_id,
                 pool_code,
                 season_id,
                 sport,
                 pool_put_body,
@@ -1112,15 +1118,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Update a pool  # noqa: E501
 
         Change the information of a specific pool  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.season_pool_update_with_http_info(organization_id, pool_code, season_id, sport, pool_put_body, external, fields, hide_null, include, async_req=True)
@@ -1142,21 +1148,22 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1233,15 +1240,15 @@
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params["pool_put_body"]:
+        if _params["pool_put_body"] is not None:
             _body_params = _params["pool_put_body"]
 
         # set the HTTP header `Accept`
         _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501
 
         # set the HTTP header `Content-Type`
         _content_types_list = _params.get(
@@ -1342,28 +1349,28 @@
         :type force_delete: bool
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: SeasonPoolsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the season_pools_delete_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.season_pools_delete_with_http_info(
                 organization_id,
                 pool_code,
                 season_id,
                 sport,
                 external,
@@ -1413,15 +1420,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Delete a pool  # noqa: E501
 
         Delete a specific pool  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.season_pools_delete_with_http_info(organization_id, pool_code, season_id, sport, external, fields, force_delete, hide_null, include, async_req=True)
@@ -1443,21 +1450,22 @@
         :type force_delete: bool
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1644,28 +1652,28 @@
         :type include: str
         :param limit: The maximum number of records to return. See [Pagination](#section/Introduction/Pagination) for more information.
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: SeasonRoundsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the season_round_detail_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.season_round_detail_with_http_info(
                 organization_id,
                 round_code,
                 season_id,
                 sport,
                 external,
@@ -1722,15 +1730,15 @@
         offset: Annotated[
             Optional[StrictInt],
             Field(
                 description="The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Get a round  # noqa: E501
 
         Return detailed information about a specific round  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.season_round_detail_with_http_info(organization_id, round_code, season_id, sport, external, fields, hide_null, include, limit, offset, async_req=True)
@@ -1754,21 +1762,22 @@
         :type include: str
         :param limit: The maximum number of records to return. See [Pagination](#section/Introduction/Pagination) for more information.
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1941,28 +1950,28 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: SeasonRoundsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the season_round_insert_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.season_round_insert_with_http_info(
                 organization_id, season_id, sport, round_post_body, external, fields, hide_null, include, **kwargs
             )  # noqa: E501
         except Exception as e:
             logger.error("Exception when calling StagesPoolsRoundsApi->season_round_insert: %s\n" % e)
             raise
@@ -1995,15 +2004,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Create a round  # noqa: E501
 
         Add a new round in a season  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.season_round_insert_with_http_info(organization_id, season_id, sport, round_post_body, external, fields, hide_null, include, async_req=True)
@@ -2023,21 +2032,22 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -2110,15 +2120,15 @@
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params["round_post_body"]:
+        if _params["round_post_body"] is not None:
             _body_params = _params["round_post_body"]
 
         # set the HTTP header `Accept`
         _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501
 
         # set the HTTP header `Content-Type`
         _content_types_list = _params.get(
@@ -2209,28 +2219,28 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: SeasonRoundsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the season_round_insert_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.season_round_insert_update_with_http_info(
                 organization_id, season_id, sport, round_post_body, external, fields, hide_null, include, **kwargs
             )  # noqa: E501
         except Exception as e:
             logger.error("Exception when calling StagesPoolsRoundsApi->season_round_insert_update: %s\n" % e)
             raise
@@ -2263,15 +2273,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Create or Update a round  # noqa: E501
 
         Depending on primary keys, insert a new round or update an existing one  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.season_round_insert_update_with_http_info(organization_id, season_id, sport, round_post_body, external, fields, hide_null, include, async_req=True)
@@ -2291,21 +2301,22 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -2380,15 +2391,15 @@
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params["round_post_body"]:
+        if _params["round_post_body"] is not None:
             _body_params = _params["round_post_body"]
 
         # set the HTTP header `Accept`
         _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501
 
         # set the HTTP header `Content-Type`
         _content_types_list = _params.get(
@@ -2512,28 +2523,28 @@
         :type pool_code: str
         :param stage_code: The stage identifier within a season
         :type stage_code: str
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: SeasonRoundsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the season_round_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.season_round_list_with_http_info(
                 organization_id,
                 season_id,
                 sport,
                 added,
                 external,
@@ -2602,15 +2613,15 @@
         stage_code: Annotated[
             Optional[constr(strict=True, max_length=30)], Field(description="The stage identifier within a season")
         ] = None,
         updated: Annotated[
             Optional[datetime], Field(description="Record was modified after this date/time. In UTC.")
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Get a list of rounds  # noqa: E501
 
         Return a list of rounds in a season  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.season_round_list_with_http_info(organization_id, season_id, sport, added, external, fields, hide_null, include, limit, offset, pool_code, stage_code, updated, async_req=True)
@@ -2640,21 +2651,22 @@
         :type pool_code: str
         :param stage_code: The stage identifier within a season
         :type stage_code: str
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -2854,28 +2866,28 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: SeasonRoundsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the season_round_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.season_round_update_with_http_info(
                 organization_id,
                 round_code,
                 season_id,
                 sport,
                 round_put_body,
@@ -2920,15 +2932,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Update a round  # noqa: E501
 
         Change the information of a specific round  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.season_round_update_with_http_info(organization_id, round_code, season_id, sport, round_put_body, external, fields, hide_null, include, async_req=True)
@@ -2950,21 +2962,22 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -3041,15 +3054,15 @@
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params["round_put_body"]:
+        if _params["round_put_body"] is not None:
             _body_params = _params["round_put_body"]
 
         # set the HTTP header `Accept`
         _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501
 
         # set the HTTP header `Content-Type`
         _content_types_list = _params.get(
@@ -3150,28 +3163,28 @@
         :type force_delete: bool
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: SeasonRoundsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the season_rounds_delete_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.season_rounds_delete_with_http_info(
                 organization_id,
                 round_code,
                 season_id,
                 sport,
                 external,
@@ -3221,15 +3234,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Delete a round  # noqa: E501
 
         Delete a specific round  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.season_rounds_delete_with_http_info(organization_id, round_code, season_id, sport, external, fields, force_delete, hide_null, include, async_req=True)
@@ -3251,21 +3264,22 @@
         :type force_delete: bool
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -3452,28 +3466,28 @@
         :type include: str
         :param limit: The maximum number of records to return. See [Pagination](#section/Introduction/Pagination) for more information.
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: SeasonStagesResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the season_stage_detail_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.season_stage_detail_with_http_info(
                 organization_id,
                 season_id,
                 sport,
                 stage_code,
                 external,
@@ -3530,15 +3544,15 @@
         offset: Annotated[
             Optional[StrictInt],
             Field(
                 description="The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Get a stage  # noqa: E501
 
         Return detailed information about a specific stage  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.season_stage_detail_with_http_info(organization_id, season_id, sport, stage_code, external, fields, hide_null, include, limit, offset, async_req=True)
@@ -3562,21 +3576,22 @@
         :type include: str
         :param limit: The maximum number of records to return. See [Pagination](#section/Introduction/Pagination) for more information.
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -3749,28 +3764,28 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: SeasonStagesResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the season_stage_insert_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.season_stage_insert_with_http_info(
                 organization_id,
                 season_id,
                 sport,
                 season_stage_post_body,
                 external,
@@ -3811,15 +3826,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Create a stage  # noqa: E501
 
         Add a new stage in a season  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.season_stage_insert_with_http_info(organization_id, season_id, sport, season_stage_post_body, external, fields, hide_null, include, async_req=True)
@@ -3839,21 +3854,22 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -3926,15 +3942,15 @@
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params["season_stage_post_body"]:
+        if _params["season_stage_post_body"] is not None:
             _body_params = _params["season_stage_post_body"]
 
         # set the HTTP header `Accept`
         _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501
 
         # set the HTTP header `Content-Type`
         _content_types_list = _params.get(
@@ -4048,28 +4064,28 @@
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: SeasonStagesResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the season_stage_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.season_stage_list_with_http_info(
                 organization_id,
                 season_id,
                 sport,
                 added,
                 external,
@@ -4130,15 +4146,15 @@
                 description="The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information."
             ),
         ] = None,
         updated: Annotated[
             Optional[datetime], Field(description="Record was modified after this date/time. In UTC.")
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Get a list of stages  # noqa: E501
 
         Return a list of stages for a season  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.season_stage_list_with_http_info(organization_id, season_id, sport, added, external, fields, hide_null, include, limit, offset, updated, async_req=True)
@@ -4164,21 +4180,22 @@
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -4370,28 +4387,28 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: SeasonStagesResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the season_stage_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.season_stage_update_with_http_info(
                 organization_id,
                 season_id,
                 sport,
                 stage_code,
                 season_stage_put_body,
@@ -4436,15 +4453,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Update a stage  # noqa: E501
 
         Change the information of a specific stage  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.season_stage_update_with_http_info(organization_id, season_id, sport, stage_code, season_stage_put_body, external, fields, hide_null, include, async_req=True)
@@ -4466,21 +4483,22 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -4557,15 +4575,15 @@
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params["season_stage_put_body"]:
+        if _params["season_stage_put_body"] is not None:
             _body_params = _params["season_stage_put_body"]
 
         # set the HTTP header `Accept`
         _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501
 
         # set the HTTP header `Content-Type`
         _content_types_list = _params.get(
@@ -4666,28 +4684,28 @@
         :type force_delete: bool
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: SeasonStagesResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the season_stages_delete_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.season_stages_delete_with_http_info(
                 organization_id,
                 season_id,
                 sport,
                 stage_code,
                 external,
@@ -4737,15 +4755,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Delete a stage  # noqa: E501
 
         Delete a specific stage  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.season_stages_delete_with_http_info(organization_id, season_id, sport, stage_code, external, fields, force_delete, hide_null, include, async_req=True)
@@ -4767,21 +4785,22 @@
         :type force_delete: bool
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/api/standing_adjustments_api.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/api/standing_adjustments_api.py`

 * *Files 2% similar despite different names*

```diff
@@ -8,23 +8,26 @@
     The version of the OpenAPI document: v1
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the file manually.
 """
 
 
+import io
 import logging
 import re  # noqa: F401
+import warnings
 from datetime import datetime
 from typing import Optional
 
 from pydantic import Field, StrictBool, StrictInt, StrictStr, ValidationError, conint, constr, validate_arguments
 from typing_extensions import Annotated
 
 from atriumsports.datacore.openapi.api_client import ApiClient
+from atriumsports.datacore.openapi.api_response import ApiResponse
 from atriumsports.datacore.openapi.exceptions import ApiTypeError, ApiValueError  # noqa: F401
 from atriumsports.datacore.openapi.models.standing_adjustment_post_body import StandingAdjustmentPostBody
 from atriumsports.datacore.openapi.models.standing_adjustment_put_body import StandingAdjustmentPutBody
 from atriumsports.datacore.openapi.models.standing_adjustments_response import StandingAdjustmentsResponse
 
 logger = logging.getLogger("openapi")
 
@@ -104,28 +107,28 @@
         :type force_delete: bool
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: StandingAdjustmentsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the standing_adjustments_delete_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.standing_adjustments_delete_with_http_info(
                 organization_id,
                 sport,
                 standing_adjustment_id,
                 external,
                 fields,
@@ -173,15 +176,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Delete standing adjustment  # noqa: E501
 
         Delete a specific standing adjustment  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.standing_adjustments_delete_with_http_info(organization_id, sport, standing_adjustment_id, external, fields, force_delete, hide_null, include, async_req=True)
@@ -201,21 +204,22 @@
         :type force_delete: bool
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -397,28 +401,28 @@
         :type include: str
         :param limit: The maximum number of records to return. See [Pagination](#section/Introduction/Pagination) for more information.
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: StandingAdjustmentsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the standing_adjustments_detail_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.standing_adjustments_detail_with_http_info(
                 organization_id,
                 sport,
                 standing_adjustment_id,
                 external,
                 fields,
@@ -473,15 +477,15 @@
         offset: Annotated[
             Optional[StrictInt],
             Field(
                 description="The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Get standing adjustment  # noqa: E501
 
         Return detailed information about a specific standing adjustment  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.standing_adjustments_detail_with_http_info(organization_id, sport, standing_adjustment_id, external, fields, hide_null, include, limit, offset, async_req=True)
@@ -503,21 +507,22 @@
         :type include: str
         :param limit: The maximum number of records to return. See [Pagination](#section/Introduction/Pagination) for more information.
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -688,28 +693,28 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: StandingAdjustmentsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the standing_adjustments_insert_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.standing_adjustments_insert_with_http_info(
                 organization_id,
                 season_id,
                 sport,
                 standing_adjustment_post_body,
                 external,
@@ -750,15 +755,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Create a new standing adjustment  # noqa: E501
 
         Insert a new standing adjustment  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.standing_adjustments_insert_with_http_info(organization_id, season_id, sport, standing_adjustment_post_body, external, fields, hide_null, include, async_req=True)
@@ -778,21 +783,22 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -867,15 +873,15 @@
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params["standing_adjustment_post_body"]:
+        if _params["standing_adjustment_post_body"] is not None:
             _body_params = _params["standing_adjustment_post_body"]
 
         # set the HTTP header `Accept`
         _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501
 
         # set the HTTP header `Content-Type`
         _content_types_list = _params.get(
@@ -1015,28 +1021,28 @@
         :type round_number: str
         :param stage_code: The stage identifier within a season
         :type stage_code: str
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: StandingAdjustmentsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the standing_adjustments_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.standing_adjustments_list_with_http_info(
                 organization_id,
                 season_id,
                 sport,
                 added,
                 conference_id,
@@ -1117,15 +1123,15 @@
         stage_code: Annotated[
             Optional[constr(strict=True, max_length=30)], Field(description="The stage identifier within a season")
         ] = None,
         updated: Annotated[
             Optional[datetime], Field(description="Record was modified after this date/time. In UTC.")
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Get a list of standing adjustments  # noqa: E501
 
         Return a list of standing adjustments  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.standing_adjustments_list_with_http_info(organization_id, season_id, sport, added, conference_id, division_id, external, fields, hide_null, include, limit, offset, pool_code, round_code, round_number, stage_code, updated, async_req=True)
@@ -1163,21 +1169,22 @@
         :type round_number: str
         :param stage_code: The stage identifier within a season
         :type stage_code: str
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1392,28 +1399,28 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: StandingAdjustmentsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the standing_adjustments_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.standing_adjustments_update_with_http_info(
                 organization_id,
                 sport,
                 standing_adjustment_id,
                 standing_adjustment_put_body,
                 external,
@@ -1456,15 +1463,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Update standing adjustment  # noqa: E501
 
         Change the information of a specific standing adjustment  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.standing_adjustments_update_with_http_info(organization_id, sport, standing_adjustment_id, standing_adjustment_put_body, external, fields, hide_null, include, async_req=True)
@@ -1484,21 +1491,22 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1573,15 +1581,15 @@
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params["standing_adjustment_put_body"]:
+        if _params["standing_adjustment_put_body"] is not None:
             _body_params = _params["standing_adjustment_put_body"]
 
         # set the HTTP header `Accept`
         _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501
 
         # set the HTTP header `Content-Type`
         _content_types_list = _params.get(
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/api/standing_configurations_api.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/api/standing_configurations_api.py`

 * *Files 2% similar despite different names*

```diff
@@ -8,23 +8,26 @@
     The version of the OpenAPI document: v1
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the file manually.
 """
 
 
+import io
 import logging
 import re  # noqa: F401
+import warnings
 from datetime import datetime
 from typing import Optional
 
 from pydantic import Field, StrictBool, StrictInt, StrictStr, ValidationError, conint, constr, validate_arguments
 from typing_extensions import Annotated
 
 from atriumsports.datacore.openapi.api_client import ApiClient
+from atriumsports.datacore.openapi.api_response import ApiResponse
 from atriumsports.datacore.openapi.exceptions import ApiTypeError, ApiValueError  # noqa: F401
 from atriumsports.datacore.openapi.models.standing_configurations_post_body import StandingConfigurationsPostBody
 from atriumsports.datacore.openapi.models.standing_configurations_put_body import StandingConfigurationsPutBody
 from atriumsports.datacore.openapi.models.standing_configurations_response import StandingConfigurationsResponse
 
 logger = logging.getLogger("openapi")
 
@@ -104,28 +107,28 @@
         :type force_delete: bool
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: StandingConfigurationsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the standing_configurations_delete_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.standing_configurations_delete_with_http_info(
                 organization_id,
                 sport,
                 standing_configuration_id,
                 external,
                 fields,
@@ -173,15 +176,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Delete standing configuration  # noqa: E501
 
         Delete a specific standing configuration  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.standing_configurations_delete_with_http_info(organization_id, sport, standing_configuration_id, external, fields, force_delete, hide_null, include, async_req=True)
@@ -201,21 +204,22 @@
         :type force_delete: bool
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -397,28 +401,28 @@
         :type include: str
         :param limit: The maximum number of records to return. See [Pagination](#section/Introduction/Pagination) for more information.
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: StandingConfigurationsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the standing_configurations_detail_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.standing_configurations_detail_with_http_info(
                 organization_id,
                 sport,
                 standing_configuration_id,
                 external,
                 fields,
@@ -473,15 +477,15 @@
         offset: Annotated[
             Optional[StrictInt],
             Field(
                 description="The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Get standing configuration  # noqa: E501
 
         Return detailed information about a specific standing configuration  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.standing_configurations_detail_with_http_info(organization_id, sport, standing_configuration_id, external, fields, hide_null, include, limit, offset, async_req=True)
@@ -503,21 +507,22 @@
         :type include: str
         :param limit: The maximum number of records to return. See [Pagination](#section/Introduction/Pagination) for more information.
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -685,28 +690,28 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: StandingConfigurationsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the standing_configurations_insert_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.standing_configurations_insert_with_http_info(
                 organization_id,
                 sport,
                 standing_configurations_post_body,
                 external,
                 fields,
@@ -745,15 +750,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Create a new standing configuration  # noqa: E501
 
         Insert a new standing configuration  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.standing_configurations_insert_with_http_info(organization_id, sport, standing_configurations_post_body, external, fields, hide_null, include, async_req=True)
@@ -771,21 +776,22 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -856,15 +862,15 @@
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params["standing_configurations_post_body"]:
+        if _params["standing_configurations_post_body"] is not None:
             _body_params = _params["standing_configurations_post_body"]
 
         # set the HTTP header `Accept`
         _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501
 
         # set the HTTP header `Content-Type`
         _content_types_list = _params.get(
@@ -975,28 +981,28 @@
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: StandingConfigurationsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the standing_configurations_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.standing_configurations_list_with_http_info(
                 organization_id, sport, added, external, fields, hide_null, include, limit, offset, updated, **kwargs
             )  # noqa: E501
         except Exception as e:
             logger.error("Exception when calling StandingConfigurationsApi->standing_configurations_list: %s\n" % e)
             raise
@@ -1045,15 +1051,15 @@
                 description="The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information."
             ),
         ] = None,
         updated: Annotated[
             Optional[datetime], Field(description="Record was modified after this date/time. In UTC.")
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Get a list of standing configurations  # noqa: E501
 
         Return a list of standing configurations  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.standing_configurations_list_with_http_info(organization_id, sport, added, external, fields, hide_null, include, limit, offset, updated, async_req=True)
@@ -1077,21 +1083,22 @@
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1278,28 +1285,28 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: StandingConfigurationsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the standing_configurations_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.standing_configurations_update_with_http_info(
                 organization_id,
                 sport,
                 standing_configuration_id,
                 standing_configurations_put_body,
                 external,
@@ -1342,15 +1349,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Update standing configuration  # noqa: E501
 
         Change the information of a specific standing configuration  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.standing_configurations_update_with_http_info(organization_id, sport, standing_configuration_id, standing_configurations_put_body, external, fields, hide_null, include, async_req=True)
@@ -1370,21 +1377,22 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1459,15 +1467,15 @@
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params["standing_configurations_put_body"]:
+        if _params["standing_configurations_put_body"] is not None:
             _body_params = _params["standing_configurations_put_body"]
 
         # set the HTTP header `Accept`
         _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501
 
         # set the HTTP header `Content-Type`
         _content_types_list = _params.get(
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/api/standings_api.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/api/standings_api.py`

 * *Files 2% similar despite different names*

```diff
@@ -8,23 +8,26 @@
     The version of the OpenAPI document: v1
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the file manually.
 """
 
 
+import io
 import logging
 import re  # noqa: F401
+import warnings
 from datetime import datetime
 from typing import Optional
 
 from pydantic import Field, StrictBool, StrictInt, StrictStr, ValidationError, conint, constr, validate_arguments
 from typing_extensions import Annotated
 
 from atriumsports.datacore.openapi.api_client import ApiClient
+from atriumsports.datacore.openapi.api_response import ApiResponse
 from atriumsports.datacore.openapi.exceptions import ApiTypeError, ApiValueError  # noqa: F401
 from atriumsports.datacore.openapi.models.season_standings_stages_pools_list_response import (
     SeasonStandingsStagesPoolsListResponse,
 )
 from atriumsports.datacore.openapi.models.standing_post_body import StandingPostBody
 from atriumsports.datacore.openapi.models.standing_put_body import StandingPutBody
 from atriumsports.datacore.openapi.models.standings_response import StandingsResponse
@@ -127,28 +130,28 @@
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param stage_code: The stage identifier within a season
         :type stage_code: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: SeasonStandingsStagesPoolsListResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the season_standings_stages_pools_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.season_standings_stages_pools_list_with_http_info(
                 organization_id,
                 season_id,
                 sport,
                 external,
                 fields,
@@ -212,15 +215,15 @@
                 description="The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information."
             ),
         ] = None,
         stage_code: Annotated[
             Optional[constr(strict=True, max_length=30)], Field(description="The stage identifier within a season")
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Get a list of ~stages~ and ~pools~ used by standings in the season  # noqa: E501
 
         Return a list of ~stages~ and ~pools~ used by standings for a season  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.season_standings_stages_pools_list_with_http_info(organization_id, season_id, sport, external, fields, fixture_type, hide_null, include, limit, offset, stage_code, async_req=True)
@@ -246,21 +249,22 @@
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param stage_code: The stage identifier within a season
         :type stage_code: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -326,15 +330,15 @@
         if _params.get("external") is not None:  # noqa: E501
             _query_params.append(("external", _params["external"]))
 
         if _params.get("fields") is not None:  # noqa: E501
             _query_params.append(("fields", _params["fields"]))
 
         if _params.get("fixture_type") is not None:  # noqa: E501
-            _query_params.append(("fixtureType", _params["fixture_type"]))
+            _query_params.append(("fixtureType", _params["fixture_type"].value))
 
         if _params.get("hide_null") is not None:  # noqa: E501
             _query_params.append(("hideNull", _params["hide_null"]))
 
         if _params.get("include") is not None:  # noqa: E501
             _query_params.append(("include", _params["include"]))
 
@@ -444,28 +448,28 @@
         :type force_delete: bool
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: SuccessResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the standing_all_delete_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.standing_all_delete_with_http_info(
                 organization_id, season_id, sport, external, fields, force_delete, hide_null, include, **kwargs
             )  # noqa: E501
         except Exception as e:
             logger.error("Exception when calling StandingsApi->standing_all_delete: %s\n" % e)
             raise
@@ -503,15 +507,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Delete all the standings for a season  # noqa: E501
 
         Delete all a specific seasons standing records  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.standing_all_delete_with_http_info(organization_id, season_id, sport, external, fields, force_delete, hide_null, include, async_req=True)
@@ -531,21 +535,22 @@
         :type force_delete: bool
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -707,28 +712,28 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: SuccessResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the standing_build_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.standing_build_with_http_info(
                 organization_id, season_id, sport, external, fields, hide_null, include, **kwargs
             )  # noqa: E501
         except Exception as e:
             logger.error("Exception when calling StandingsApi->standing_build: %s\n" % e)
             raise
@@ -760,15 +765,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Build a standing  # noqa: E501
 
         Build a standing  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.standing_build_with_http_info(organization_id, season_id, sport, external, fields, hide_null, include, async_req=True)
@@ -786,21 +791,22 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -950,28 +956,28 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: SuccessResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the standing_build_live_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.standing_build_live_with_http_info(
                 organization_id, season_id, sport, external, fields, hide_null, include, **kwargs
             )  # noqa: E501
         except Exception as e:
             logger.error("Exception when calling StandingsApi->standing_build_live: %s\n" % e)
             raise
@@ -1003,15 +1009,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Build a standing using live data  # noqa: E501
 
         Build a standing using live data.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.standing_build_live_with_http_info(organization_id, season_id, sport, external, fields, hide_null, include, async_req=True)
@@ -1029,21 +1035,22 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1201,28 +1208,28 @@
         :type force_delete: bool
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: StandingsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the standing_delete_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.standing_delete_with_http_info(
                 organization_id, sport, standing_id, external, fields, force_delete, hide_null, include, **kwargs
             )  # noqa: E501
         except Exception as e:
             logger.error("Exception when calling StandingsApi->standing_delete: %s\n" % e)
             raise
@@ -1260,15 +1267,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Delete a standing  # noqa: E501
 
         Delete a specific standing  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.standing_delete_with_http_info(organization_id, sport, standing_id, external, fields, force_delete, hide_null, include, async_req=True)
@@ -1288,21 +1295,22 @@
         :type force_delete: bool
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1480,28 +1488,28 @@
         :type include: str
         :param limit: The maximum number of records to return. See [Pagination](#section/Introduction/Pagination) for more information.
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: StandingsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the standing_detail_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.standing_detail_with_http_info(
                 organization_id, sport, standing_id, external, fields, hide_null, include, limit, offset, **kwargs
             )  # noqa: E501
         except Exception as e:
             logger.error("Exception when calling StandingsApi->standing_detail: %s\n" % e)
             raise
@@ -1545,15 +1553,15 @@
         offset: Annotated[
             Optional[StrictInt],
             Field(
                 description="The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Get a standing  # noqa: E501
 
         Return detailed information about a specific standing  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.standing_detail_with_http_info(organization_id, sport, standing_id, external, fields, hide_null, include, limit, offset, async_req=True)
@@ -1575,21 +1583,22 @@
         :type include: str
         :param limit: The maximum number of records to return. See [Pagination](#section/Introduction/Pagination) for more information.
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1758,28 +1767,28 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: StandingsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the standing_insert_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.standing_insert_with_http_info(
                 organization_id, season_id, sport, standing_post_body, external, fields, hide_null, include, **kwargs
             )  # noqa: E501
         except Exception as e:
             logger.error("Exception when calling StandingsApi->standing_insert: %s\n" % e)
             raise
@@ -1812,15 +1821,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Create a standing  # noqa: E501
 
         Insert a new standing  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.standing_insert_with_http_info(organization_id, season_id, sport, standing_post_body, external, fields, hide_null, include, async_req=True)
@@ -1840,21 +1849,22 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1927,15 +1937,15 @@
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params["standing_post_body"]:
+        if _params["standing_post_body"] is not None:
             _body_params = _params["standing_post_body"]
 
         # set the HTTP header `Accept`
         _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501
 
         # set the HTTP header `Content-Type`
         _content_types_list = _params.get(
@@ -2132,28 +2142,28 @@
         :type stage_code: str
         :param standing_configuration_id: The unique identifier of the configuration
         :type standing_configuration_id: str
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: StandingsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the standing_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.standing_list_with_http_info(
                 organization_id,
                 season_id,
                 sport,
                 added,
                 conference_id,
@@ -2281,15 +2291,15 @@
         standing_configuration_id: Annotated[
             Optional[StrictStr], Field(description="The unique identifier of the configuration")
         ] = None,
         updated: Annotated[
             Optional[datetime], Field(description="Record was modified after this date/time. In UTC.")
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Get a list of standings  # noqa: E501
 
         Return a list of available standings for a season  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.standing_list_with_http_info(organization_id, season_id, sport, added, conference_id, division_id, entity_id, external, fields, fixture_type, grouping_base, grouping_conference_division, grouping_stage_pool, hide_null, in_progress, include, latest, limit, live, offset, pool_code, round_code, round_number, sort_by, stage_code, standing_configuration_id, updated, async_req=True)
@@ -2347,21 +2357,22 @@
         :type stage_code: str
         :param standing_configuration_id: The unique identifier of the configuration
         :type standing_configuration_id: str
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -2458,24 +2469,24 @@
         if _params.get("external") is not None:  # noqa: E501
             _query_params.append(("external", _params["external"]))
 
         if _params.get("fields") is not None:  # noqa: E501
             _query_params.append(("fields", _params["fields"]))
 
         if _params.get("fixture_type") is not None:  # noqa: E501
-            _query_params.append(("fixtureType", _params["fixture_type"]))
+            _query_params.append(("fixtureType", _params["fixture_type"].value))
 
         if _params.get("grouping_base") is not None:  # noqa: E501
-            _query_params.append(("groupingBase", _params["grouping_base"]))
+            _query_params.append(("groupingBase", _params["grouping_base"].value))
 
         if _params.get("grouping_conference_division") is not None:  # noqa: E501
-            _query_params.append(("groupingConferenceDivision", _params["grouping_conference_division"]))
+            _query_params.append(("groupingConferenceDivision", _params["grouping_conference_division"].value))
 
         if _params.get("grouping_stage_pool") is not None:  # noqa: E501
-            _query_params.append(("groupingStagePool", _params["grouping_stage_pool"]))
+            _query_params.append(("groupingStagePool", _params["grouping_stage_pool"].value))
 
         if _params.get("hide_null") is not None:  # noqa: E501
             _query_params.append(("hideNull", _params["hide_null"]))
 
         if _params.get("in_progress") is not None:  # noqa: E501
             _query_params.append(("inProgress", _params["in_progress"]))
 
@@ -2612,28 +2623,28 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: StandingsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the standing_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.standing_update_with_http_info(
                 organization_id, sport, standing_id, standing_put_body, external, fields, hide_null, include, **kwargs
             )  # noqa: E501
         except Exception as e:
             logger.error("Exception when calling StandingsApi->standing_update: %s\n" % e)
             raise
@@ -2666,15 +2677,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Update a standing  # noqa: E501
 
         Change the information of a specific standing  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.standing_update_with_http_info(organization_id, sport, standing_id, standing_put_body, external, fields, hide_null, include, async_req=True)
@@ -2694,21 +2705,22 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -2781,15 +2793,15 @@
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params["standing_put_body"]:
+        if _params["standing_put_body"] is not None:
             _body_params = _params["standing_put_body"]
 
         # set the HTTP header `Accept`
         _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501
 
         # set the HTTP header `Content-Type`
         _content_types_list = _params.get(
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/api/transfers_api.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/api/transfers_api.py`

 * *Files 8% similar despite different names*

```diff
@@ -8,23 +8,26 @@
     The version of the OpenAPI document: v1
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the file manually.
 """
 
 
+import io
 import logging
 import re  # noqa: F401
+import warnings
 from datetime import datetime
 from typing import Optional
 
 from pydantic import Field, StrictBool, StrictInt, StrictStr, ValidationError, conint, constr, validate_arguments
 from typing_extensions import Annotated
 
 from atriumsports.datacore.openapi.api_client import ApiClient
+from atriumsports.datacore.openapi.api_response import ApiResponse
 from atriumsports.datacore.openapi.exceptions import ApiTypeError, ApiValueError  # noqa: F401
 from atriumsports.datacore.openapi.models.transfer_post_body import TransferPostBody
 from atriumsports.datacore.openapi.models.transfer_put_body import TransferPutBody
 from atriumsports.datacore.openapi.models.transfers_response import TransfersResponse
 
 logger = logging.getLogger("openapi")
 
@@ -110,28 +113,28 @@
         :type include: str
         :param limit: The maximum number of records to return. See [Pagination](#section/Introduction/Pagination) for more information.
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: TransfersResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the transfer_detail_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.transfer_detail_with_http_info(
                 organization_id, sport, transfer_id, external, fields, hide_null, include, limit, offset, **kwargs
             )  # noqa: E501
         except Exception as e:
             logger.error("Exception when calling TransfersApi->transfer_detail: %s\n" % e)
             raise
@@ -175,15 +178,15 @@
         offset: Annotated[
             Optional[StrictInt],
             Field(
                 description="The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Get a transfer  # noqa: E501
 
         Return detailed information about a specific transfer  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.transfer_detail_with_http_info(organization_id, sport, transfer_id, external, fields, hide_null, include, limit, offset, async_req=True)
@@ -205,21 +208,22 @@
         :type include: str
         :param limit: The maximum number of records to return. See [Pagination](#section/Introduction/Pagination) for more information.
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -393,28 +397,28 @@
         :type force_delete: bool
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: TransfersResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the transfers_delete_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.transfers_delete_with_http_info(
                 organization_id, sport, transfer_id, external, fields, force_delete, hide_null, include, **kwargs
             )  # noqa: E501
         except Exception as e:
             logger.error("Exception when calling TransfersApi->transfers_delete: %s\n" % e)
             raise
@@ -452,15 +456,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Delete a transfer  # noqa: E501
 
         Delete a specific transfer  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.transfers_delete_with_http_info(organization_id, sport, transfer_id, external, fields, force_delete, hide_null, include, async_req=True)
@@ -480,21 +484,22 @@
         :type force_delete: bool
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -656,28 +661,28 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: TransfersResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the transfers_insert_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.transfers_insert_with_http_info(
                 organization_id, sport, transfer_post_body, external, fields, hide_null, include, **kwargs
             )  # noqa: E501
         except Exception as e:
             logger.error("Exception when calling TransfersApi->transfers_insert: %s\n" % e)
             raise
@@ -709,15 +714,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Create a transfer  # noqa: E501
 
         Add a new transfer  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.transfers_insert_with_http_info(organization_id, sport, transfer_post_body, external, fields, hide_null, include, async_req=True)
@@ -735,21 +740,22 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -810,15 +816,15 @@
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params["transfer_post_body"]:
+        if _params["transfer_post_body"] is not None:
             _body_params = _params["transfer_post_body"]
 
         # set the HTTP header `Accept`
         _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501
 
         # set the HTTP header `Content-Type`
         _content_types_list = _params.get(
@@ -945,28 +951,28 @@
         :type season_id: str
         :param transfer_type: Type of transfer >- `DROPPED` Dropped >- `OTHER` Other >- `PERMIT` Permit >- `TRADE` Trade >- `TRANSFER` Transfer
         :type transfer_type: str
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: TransfersResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the transfers_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.transfers_list_with_http_info(
                 organization_id,
                 sport,
                 added,
                 competition_id,
                 external,
@@ -1038,15 +1044,15 @@
                 description="Type of transfer >- `DROPPED` Dropped >- `OTHER` Other >- `PERMIT` Permit >- `TRADE` Trade >- `TRANSFER` Transfer "
             ),
         ] = None,
         updated: Annotated[
             Optional[datetime], Field(description="Record was modified after this date/time. In UTC.")
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Get a list of transfers  # noqa: E501
 
         Return a list of transfers~  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.transfers_list_with_http_info(organization_id, sport, added, competition_id, external, fields, hide_null, include, limit, offset, season_id, transfer_type, updated, async_req=True)
@@ -1076,21 +1082,22 @@
         :type season_id: str
         :param transfer_type: Type of transfer >- `DROPPED` Dropped >- `OTHER` Other >- `PERMIT` Permit >- `TRADE` Trade >- `TRANSFER` Transfer
         :type transfer_type: str
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1179,15 +1186,15 @@
         if _params.get("offset") is not None:  # noqa: E501
             _query_params.append(("offset", _params["offset"]))
 
         if _params.get("season_id") is not None:  # noqa: E501
             _query_params.append(("seasonId", _params["season_id"]))
 
         if _params.get("transfer_type") is not None:  # noqa: E501
-            _query_params.append(("transferType", _params["transfer_type"]))
+            _query_params.append(("transferType", _params["transfer_type"].value))
 
         if _params.get("updated") is not None:  # noqa: E501
             if isinstance(_params["updated"], datetime):
                 _query_params.append(
                     ("updated", _params["updated"].strftime(self.api_client.configuration.datetime_format))
                 )
             else:
@@ -1285,28 +1292,28 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: TransfersResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the transfers_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.transfers_update_with_http_info(
                 organization_id, sport, transfer_id, transfer_put_body, external, fields, hide_null, include, **kwargs
             )  # noqa: E501
         except Exception as e:
             logger.error("Exception when calling TransfersApi->transfers_update: %s\n" % e)
             raise
@@ -1339,15 +1346,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Update a transfer  # noqa: E501
 
         Change the information of a specific transfer  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.transfers_update_with_http_info(organization_id, sport, transfer_id, transfer_put_body, external, fields, hide_null, include, async_req=True)
@@ -1367,21 +1374,22 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1454,15 +1462,15 @@
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params["transfer_put_body"]:
+        if _params["transfer_put_body"] is not None:
             _body_params = _params["transfer_put_body"]
 
         # set the HTTP header `Accept`
         _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501
 
         # set the HTTP header `Content-Type`
         _content_types_list = _params.get(
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/api/venues_api.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/api/venues_api.py`

 * *Files 2% similar despite different names*

```diff
@@ -8,23 +8,26 @@
     The version of the OpenAPI document: v1
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the file manually.
 """
 
 
+import io
 import logging
 import re  # noqa: F401
+import warnings
 from datetime import datetime
 from typing import Optional
 
 from pydantic import Field, StrictBool, StrictInt, StrictStr, ValidationError, conint, constr, validate_arguments
 from typing_extensions import Annotated
 
 from atriumsports.datacore.openapi.api_client import ApiClient
+from atriumsports.datacore.openapi.api_response import ApiResponse
 from atriumsports.datacore.openapi.exceptions import ApiTypeError, ApiValueError  # noqa: F401
 from atriumsports.datacore.openapi.models.season_venues_list_response import SeasonVenuesListResponse
 from atriumsports.datacore.openapi.models.venue_post_body import VenuePostBody
 from atriumsports.datacore.openapi.models.venue_put_body import VenuePutBody
 from atriumsports.datacore.openapi.models.venues_response import VenuesResponse
 
 logger = logging.getLogger("openapi")
@@ -111,28 +114,28 @@
         :type include: str
         :param limit: The maximum number of records to return. See [Pagination](#section/Introduction/Pagination) for more information.
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: SeasonVenuesListResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the season_venues_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.season_venues_list_with_http_info(
                 organization_id, season_id, sport, external, fields, hide_null, include, limit, offset, **kwargs
             )  # noqa: E501
         except Exception as e:
             logger.error("Exception when calling VenuesApi->season_venues_list: %s\n" % e)
             raise
@@ -176,15 +179,15 @@
         offset: Annotated[
             Optional[StrictInt],
             Field(
                 description="The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Get a list of venues in the season  # noqa: E501
 
         Return a list of venues for a season  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.season_venues_list_with_http_info(organization_id, season_id, sport, external, fields, hide_null, include, limit, offset, async_req=True)
@@ -206,21 +209,22 @@
         :type include: str
         :param limit: The maximum number of records to return. See [Pagination](#section/Introduction/Pagination) for more information.
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -394,28 +398,28 @@
         :type force_delete: bool
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: VenuesResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the venue_delete_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.venue_delete_with_http_info(
                 organization_id, sport, venue_id, external, fields, force_delete, hide_null, include, **kwargs
             )  # noqa: E501
         except Exception as e:
             logger.error("Exception when calling VenuesApi->venue_delete: %s\n" % e)
             raise
@@ -453,15 +457,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Delete a venue  # noqa: E501
 
         Delete a specific venue  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.venue_delete_with_http_info(organization_id, sport, venue_id, external, fields, force_delete, hide_null, include, async_req=True)
@@ -481,21 +485,22 @@
         :type force_delete: bool
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -673,28 +678,28 @@
         :type include: str
         :param limit: The maximum number of records to return. See [Pagination](#section/Introduction/Pagination) for more information.
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: VenuesResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the venue_detail_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.venue_detail_with_http_info(
                 organization_id, sport, venue_id, external, fields, hide_null, include, limit, offset, **kwargs
             )  # noqa: E501
         except Exception as e:
             logger.error("Exception when calling VenuesApi->venue_detail: %s\n" % e)
             raise
@@ -738,15 +743,15 @@
         offset: Annotated[
             Optional[StrictInt],
             Field(
                 description="The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Get a venue  # noqa: E501
 
         Return detailed information about a specific venue  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.venue_detail_with_http_info(organization_id, sport, venue_id, external, fields, hide_null, include, limit, offset, async_req=True)
@@ -768,21 +773,22 @@
         :type include: str
         :param limit: The maximum number of records to return. See [Pagination](#section/Introduction/Pagination) for more information.
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -948,28 +954,28 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: VenuesResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the venue_insert_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.venue_insert_with_http_info(
                 organization_id, sport, venue_post_body, external, fields, hide_null, include, **kwargs
             )  # noqa: E501
         except Exception as e:
             logger.error("Exception when calling VenuesApi->venue_insert: %s\n" % e)
             raise
@@ -1001,15 +1007,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Create a venue  # noqa: E501
 
         Add a new venue  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.venue_insert_with_http_info(organization_id, sport, venue_post_body, external, fields, hide_null, include, async_req=True)
@@ -1027,21 +1033,22 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1102,15 +1109,15 @@
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params["venue_post_body"]:
+        if _params["venue_post_body"] is not None:
             _body_params = _params["venue_post_body"]
 
         # set the HTTP header `Accept`
         _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501
 
         # set the HTTP header `Content-Type`
         _content_types_list = _params.get(
@@ -1232,28 +1239,28 @@
         :type offset: int
         :param status: Status >- `ACTIVE` Active >- `INACTIVE` Inactive >- `PENDING` Pending
         :type status: str
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: VenuesResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the venue_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.venue_list_with_http_info(
                 organization_id,
                 sport,
                 added,
                 country_code,
                 external,
@@ -1321,15 +1328,15 @@
             Optional[StrictStr],
             Field(description="Status >- `ACTIVE` Active >- `INACTIVE` Inactive >- `PENDING` Pending "),
         ] = None,
         updated: Annotated[
             Optional[datetime], Field(description="Record was modified after this date/time. In UTC.")
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Get a list of venues  # noqa: E501
 
         Return a list of available venues  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.venue_list_with_http_info(organization_id, sport, added, country_code, external, fields, hide_null, include, limit, offset, status, updated, async_req=True)
@@ -1357,21 +1364,22 @@
         :type offset: int
         :param status: Status >- `ACTIVE` Active >- `INACTIVE` Inactive >- `PENDING` Pending
         :type status: str
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1456,15 +1464,15 @@
         if _params.get("limit") is not None:  # noqa: E501
             _query_params.append(("limit", _params["limit"]))
 
         if _params.get("offset") is not None:  # noqa: E501
             _query_params.append(("offset", _params["offset"]))
 
         if _params.get("status") is not None:  # noqa: E501
-            _query_params.append(("status", _params["status"]))
+            _query_params.append(("status", _params["status"].value))
 
         if _params.get("updated") is not None:  # noqa: E501
             if isinstance(_params["updated"], datetime):
                 _query_params.append(
                     ("updated", _params["updated"].strftime(self.api_client.configuration.datetime_format))
                 )
             else:
@@ -1596,28 +1604,28 @@
         :type offset: int
         :param status: Status >- `ACTIVE` Active >- `INACTIVE` Inactive >- `PENDING` Pending
         :type status: str
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: VenuesResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the venue_list_by_site_id_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.venue_list_by_site_id_with_http_info(
                 organization_id,
                 site_id,
                 sport,
                 added,
                 country_code,
@@ -1687,15 +1695,15 @@
             Optional[StrictStr],
             Field(description="Status >- `ACTIVE` Active >- `INACTIVE` Inactive >- `PENDING` Pending "),
         ] = None,
         updated: Annotated[
             Optional[datetime], Field(description="Record was modified after this date/time. In UTC.")
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Get a list of venues by site  # noqa: E501
 
         Return a list of available venues  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.venue_list_by_site_id_with_http_info(organization_id, site_id, sport, added, country_code, external, fields, hide_null, include, limit, offset, status, updated, async_req=True)
@@ -1725,21 +1733,22 @@
         :type offset: int
         :param status: Status >- `ACTIVE` Active >- `INACTIVE` Inactive >- `PENDING` Pending
         :type status: str
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1828,15 +1837,15 @@
         if _params.get("limit") is not None:  # noqa: E501
             _query_params.append(("limit", _params["limit"]))
 
         if _params.get("offset") is not None:  # noqa: E501
             _query_params.append(("offset", _params["offset"]))
 
         if _params.get("status") is not None:  # noqa: E501
-            _query_params.append(("status", _params["status"]))
+            _query_params.append(("status", _params["status"].value))
 
         if _params.get("updated") is not None:  # noqa: E501
             if isinstance(_params["updated"], datetime):
                 _query_params.append(
                     ("updated", _params["updated"].strftime(self.api_client.configuration.datetime_format))
                 )
             else:
@@ -1934,28 +1943,28 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: VenuesResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the venue_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.venue_update_with_http_info(
                 organization_id, sport, venue_id, venue_put_body, external, fields, hide_null, include, **kwargs
             )  # noqa: E501
         except Exception as e:
             logger.error("Exception when calling VenuesApi->venue_update: %s\n" % e)
             raise
@@ -1988,15 +1997,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Update a venue  # noqa: E501
 
         Change the information of a specific venue  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.venue_update_with_http_info(organization_id, sport, venue_id, venue_put_body, external, fields, hide_null, include, async_req=True)
@@ -2016,21 +2025,22 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -2103,15 +2113,15 @@
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params["venue_put_body"]:
+        if _params["venue_put_body"] is not None:
             _body_params = _params["venue_put_body"]
 
         # set the HTTP header `Accept`
         _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501
 
         # set the HTTP header `Content-Type`
         _content_types_list = _params.get(
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/api/video_stream_inputs_api.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/api/video_stream_inputs_api.py`

 * *Files 4% similar despite different names*

```diff
@@ -8,23 +8,26 @@
     The version of the OpenAPI document: v1
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the file manually.
 """
 
 
+import io
 import logging
 import re  # noqa: F401
+import warnings
 from datetime import datetime
 from typing import Optional
 
 from pydantic import Field, StrictBool, StrictInt, StrictStr, ValidationError, conint, constr, validate_arguments
 from typing_extensions import Annotated
 
 from atriumsports.datacore.openapi.api_client import ApiClient
+from atriumsports.datacore.openapi.api_response import ApiResponse
 from atriumsports.datacore.openapi.exceptions import ApiTypeError, ApiValueError  # noqa: F401
 from atriumsports.datacore.openapi.models.video_stream_inputs_response import VideoStreamInputsResponse
 
 logger = logging.getLogger("openapi")
 
 
 class VideoStreamInputsApi(object):
@@ -146,28 +149,28 @@
         :type source_number: int
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param video_input_id: The unique identifier of the video input record
         :type video_input_id: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: VideoStreamInputsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the video_stream_inputs_fixture_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.video_stream_inputs_fixture_list_with_http_info(
                 fixture_id,
                 organization_id,
                 sport,
                 added,
                 external,
@@ -251,15 +254,15 @@
         updated: Annotated[
             Optional[datetime], Field(description="Record was modified after this date/time. In UTC.")
         ] = None,
         video_input_id: Annotated[
             Optional[StrictStr], Field(description="The unique identifier of the video input record")
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """List available video inputs for a fixture  # noqa: E501
 
         Display the list of video inputs for a fixture  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.video_stream_inputs_fixture_list_with_http_info(fixture_id, organization_id, sport, added, external, feed_type, fields, hide_null, include, limit, locale, offset, provider, source_number, updated, video_input_id, async_req=True)
@@ -295,21 +298,22 @@
         :type source_number: int
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param video_input_id: The unique identifier of the video input record
         :type video_input_id: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -385,15 +389,15 @@
             else:
                 _query_params.append(("added", _params["added"]))
 
         if _params.get("external") is not None:  # noqa: E501
             _query_params.append(("external", _params["external"]))
 
         if _params.get("feed_type") is not None:  # noqa: E501
-            _query_params.append(("feedType", _params["feed_type"]))
+            _query_params.append(("feedType", _params["feed_type"].value))
 
         if _params.get("fields") is not None:  # noqa: E501
             _query_params.append(("fields", _params["fields"]))
 
         if _params.get("hide_null") is not None:  # noqa: E501
             _query_params.append(("hideNull", _params["hide_null"]))
 
@@ -592,28 +596,28 @@
         :type to_time_utc: datetime
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param venue_id: The unique identifier of the venue
         :type venue_id: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: VideoStreamInputsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the video_stream_inputs_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.video_stream_inputs_list_with_http_info(
                 master_venue_id,
                 sport,
                 added,
                 competition_id,
                 external,
@@ -714,15 +718,15 @@
             Optional[datetime], Field(description="Where fixture start time (in UTC) <= this value")
         ] = None,
         updated: Annotated[
             Optional[datetime], Field(description="Record was modified after this date/time. In UTC.")
         ] = None,
         venue_id: Annotated[Optional[StrictStr], Field(description="The unique identifier of the venue")] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """List available video inputs for a master venue  # noqa: E501
 
         Display the list of video stream inputs for a master venue. This will only display inputs for fixtures in the future and from 12 hours in the past that have not been completed/cancelled.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.video_stream_inputs_list_with_http_info(master_venue_id, sport, added, competition_id, external, feed_type, fields, fixture_id, from_time_local, from_time_utc, hide_null, include, limit, locale, offset, provider, season_id, source_number, to_time_local, to_time_utc, updated, venue_id, async_req=True)
@@ -770,21 +774,22 @@
         :type to_time_utc: datetime
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param venue_id: The unique identifier of the venue
         :type venue_id: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -866,15 +871,15 @@
         if _params.get("competition_id") is not None:  # noqa: E501
             _query_params.append(("competitionId", _params["competition_id"]))
 
         if _params.get("external") is not None:  # noqa: E501
             _query_params.append(("external", _params["external"]))
 
         if _params.get("feed_type") is not None:  # noqa: E501
-            _query_params.append(("feedType", _params["feed_type"]))
+            _query_params.append(("feedType", _params["feed_type"].value))
 
         if _params.get("fields") is not None:  # noqa: E501
             _query_params.append(("fields", _params["fields"]))
 
         if _params.get("fixture_id") is not None:  # noqa: E501
             _query_params.append(("fixtureId", _params["fixture_id"]))
 
@@ -1122,28 +1127,28 @@
         :type updated: datetime
         :param venue_id: The unique identifier of the venue
         :type venue_id: str
         :param video_input_id: The unique identifier of the video input record
         :type video_input_id: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: VideoStreamInputsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the video_stream_inputs_org_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.video_stream_inputs_org_list_with_http_info(
                 organization_id,
                 sport,
                 added,
                 competition_id,
                 external,
@@ -1251,15 +1256,15 @@
             Optional[datetime], Field(description="Record was modified after this date/time. In UTC.")
         ] = None,
         venue_id: Annotated[Optional[StrictStr], Field(description="The unique identifier of the venue")] = None,
         video_input_id: Annotated[
             Optional[StrictStr], Field(description="The unique identifier of the video input record")
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """List available video inputs for an organization  # noqa: E501
 
         Display the list of video inputs for an organization. This will only display inputs for fixtures in the future and from 12 hours in the past that have not been completed/cancelled.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.video_stream_inputs_org_list_with_http_info(organization_id, sport, added, competition_id, external, feed_type, fields, fixture_id, from_time_local, from_time_utc, hide_null, include, limit, locale, offset, provider, season_id, source_number, to_time_local, to_time_utc, updated, venue_id, video_input_id, async_req=True)
@@ -1309,21 +1314,22 @@
         :type updated: datetime
         :param venue_id: The unique identifier of the venue
         :type venue_id: str
         :param video_input_id: The unique identifier of the video input record
         :type video_input_id: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1406,15 +1412,15 @@
         if _params.get("competition_id") is not None:  # noqa: E501
             _query_params.append(("competitionId", _params["competition_id"]))
 
         if _params.get("external") is not None:  # noqa: E501
             _query_params.append(("external", _params["external"]))
 
         if _params.get("feed_type") is not None:  # noqa: E501
-            _query_params.append(("feedType", _params["feed_type"]))
+            _query_params.append(("feedType", _params["feed_type"].value))
 
         if _params.get("fields") is not None:  # noqa: E501
             _query_params.append(("fields", _params["fields"]))
 
         if _params.get("fixture_id") is not None:  # noqa: E501
             _query_params.append(("fixtureId", _params["fixture_id"]))
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/api/video_stream_subscriptions_api.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/api/video_stream_subscriptions_api.py`

 * *Files 8% similar despite different names*

```diff
@@ -8,23 +8,26 @@
     The version of the OpenAPI document: v1
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the file manually.
 """
 
 
+import io
 import logging
 import re  # noqa: F401
+import warnings
 from datetime import datetime
 from typing import Optional
 
 from pydantic import Field, StrictBool, StrictInt, StrictStr, ValidationError, conint, constr, validate_arguments
 from typing_extensions import Annotated
 
 from atriumsports.datacore.openapi.api_client import ApiClient
+from atriumsports.datacore.openapi.api_response import ApiResponse
 from atriumsports.datacore.openapi.exceptions import ApiTypeError, ApiValueError  # noqa: F401
 from atriumsports.datacore.openapi.models.video_subscription_post_body import VideoSubscriptionPostBody
 from atriumsports.datacore.openapi.models.video_subscription_put_body import VideoSubscriptionPutBody
 from atriumsports.datacore.openapi.models.video_subscriptions_response import VideoSubscriptionsResponse
 
 logger = logging.getLogger("openapi")
 
@@ -104,28 +107,28 @@
         :type force_delete: bool
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: VideoSubscriptionsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the video_subscription_delete_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.video_subscription_delete_with_http_info(
                 organization_id, sport, subscription_id, external, fields, force_delete, hide_null, include, **kwargs
             )  # noqa: E501
         except Exception as e:
             logger.error("Exception when calling VideoStreamSubscriptionsApi->video_subscription_delete: %s\n" % e)
             raise
@@ -165,15 +168,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Delete a video stream subscription  # noqa: E501
 
         Delete an existing subscription  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.video_subscription_delete_with_http_info(organization_id, sport, subscription_id, external, fields, force_delete, hide_null, include, async_req=True)
@@ -193,21 +196,22 @@
         :type force_delete: bool
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -389,28 +393,28 @@
         :type include: str
         :param limit: The maximum number of records to return. See [Pagination](#section/Introduction/Pagination) for more information.
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: VideoSubscriptionsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the video_subscription_detail_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.video_subscription_detail_with_http_info(
                 organization_id, sport, subscription_id, external, fields, hide_null, include, limit, offset, **kwargs
             )  # noqa: E501
         except Exception as e:
             logger.error("Exception when calling VideoStreamSubscriptionsApi->video_subscription_detail: %s\n" % e)
             raise
@@ -456,15 +460,15 @@
         offset: Annotated[
             Optional[StrictInt],
             Field(
                 description="The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Get a video stream subscription  # noqa: E501
 
         Return detailed information about a specific video stream subscription.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.video_subscription_detail_with_http_info(organization_id, sport, subscription_id, external, fields, hide_null, include, limit, offset, async_req=True)
@@ -486,21 +490,22 @@
         :type include: str
         :param limit: The maximum number of records to return. See [Pagination](#section/Introduction/Pagination) for more information.
         :type limit: int
         :param offset: The offset of the records. See [Pagination](#section/Introduction/Pagination) for more information.
         :type offset: int
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -668,28 +673,28 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: VideoSubscriptionsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the video_subscription_insert_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.video_subscription_insert_with_http_info(
                 organization_id, sport, video_subscription_post_body, external, fields, hide_null, include, **kwargs
             )  # noqa: E501
         except Exception as e:
             logger.error("Exception when calling VideoStreamSubscriptionsApi->video_subscription_insert: %s\n" % e)
             raise
@@ -721,15 +726,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Subscribe to a video stream  # noqa: E501
 
         Subscribe to an upcoming video stream. Any subscription must be in place a minimum of 1 hour before the scheduled start time.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.video_subscription_insert_with_http_info(organization_id, sport, video_subscription_post_body, external, fields, hide_null, include, async_req=True)
@@ -747,21 +752,22 @@
         :type fields: str
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -832,15 +838,15 @@
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params["video_subscription_post_body"]:
+        if _params["video_subscription_post_body"] is not None:
             _body_params = _params["video_subscription_post_body"]
 
         # set the HTTP header `Accept`
         _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501
 
         # set the HTTP header `Content-Type`
         _content_types_list = _params.get(
@@ -973,28 +979,28 @@
         :type season_id: str
         :param to_time_utc: Where fixture start time (in UTC) <= this value
         :type to_time_utc: datetime
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: VideoSubscriptionsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the video_subscription_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.video_subscription_list_with_http_info(
                 organization_id,
                 sport,
                 added,
                 external,
                 fields,
@@ -1070,15 +1076,15 @@
         to_time_utc: Annotated[
             Optional[datetime], Field(description="Where fixture start time (in UTC) <= this value")
         ] = None,
         updated: Annotated[
             Optional[datetime], Field(description="Record was modified after this date/time. In UTC.")
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """List video stream subscriptions  # noqa: E501
 
         Display the list of video stream subscriptions for fixtures.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.video_subscription_list_with_http_info(organization_id, sport, added, external, fields, fixture_id, from_time_utc, hide_null, include, limit, offset, only_upcoming, season_id, to_time_utc, updated, async_req=True)
@@ -1112,21 +1118,22 @@
         :type season_id: str
         :param to_time_utc: Where fixture start time (in UTC) <= this value
         :type to_time_utc: datetime
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1351,28 +1358,28 @@
         :type force_delete: bool
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: VideoSubscriptionsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the video_subscriptions_update_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.video_subscriptions_update_with_http_info(
                 organization_id,
                 sport,
                 subscription_id,
                 video_subscription_put_body,
                 external,
@@ -1422,15 +1429,15 @@
         include: Annotated[
             Optional[StrictStr],
             Field(
                 description="A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information."
             ),
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """Update a video subscription  # noqa: E501
 
         Change the information of an existing video subscription  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.video_subscriptions_update_with_http_info(organization_id, sport, subscription_id, video_subscription_put_body, external, fields, force_delete, hide_null, include, async_req=True)
@@ -1452,21 +1459,22 @@
         :type force_delete: bool
         :param hide_null: Don't display data fields with null values or empty structures
         :type hide_null: bool
         :param include: A comma separated list of resource types to include. See [Resource Inclusion](#section/Introduction/Resource-Inclusion) for more information.
         :type include: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1545,15 +1553,15 @@
         # process the header parameters
         _header_params = dict(_params.get("_headers", {}))
         # process the form parameters
         _form_params = []
         _files = {}
         # process the body parameter
         _body_params = None
-        if _params["video_subscription_put_body"]:
+        if _params["video_subscription_put_body"] is not None:
             _body_params = _params["video_subscription_put_body"]
 
         # set the HTTP header `Accept`
         _header_params["Accept"] = self.api_client.select_header_accept(["application/json"])  # noqa: E501
 
         # set the HTTP header `Content-Type`
         _content_types_list = _params.get(
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/api/video_streams_available_api.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/api/video_streams_available_api.py`

 * *Files 2% similar despite different names*

```diff
@@ -8,23 +8,26 @@
     The version of the OpenAPI document: v1
     Generated by OpenAPI Generator (https://openapi-generator.tech)
 
     Do not edit the file manually.
 """
 
 
+import io
 import logging
 import re  # noqa: F401
+import warnings
 from datetime import datetime
 from typing import Optional
 
 from pydantic import Field, StrictBool, StrictInt, StrictStr, ValidationError, conint, constr, validate_arguments
 from typing_extensions import Annotated
 
 from atriumsports.datacore.openapi.api_client import ApiClient
+from atriumsports.datacore.openapi.api_response import ApiResponse
 from atriumsports.datacore.openapi.exceptions import ApiTypeError, ApiValueError  # noqa: F401
 from atriumsports.datacore.openapi.models.video_stream_outputs_response import VideoStreamOutputsResponse
 
 logger = logging.getLogger("openapi")
 
 
 class VideoStreamsAvailableApi(object):
@@ -149,28 +152,28 @@
         :type provider: str
         :param source_number: Unique identifier for the video source
         :type source_number: int
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: VideoStreamOutputsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the video_stream_outputs_fixture_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.video_stream_outputs_fixture_list_with_http_info(
                 fixture_id,
                 organization_id,
                 sport,
                 added,
                 content,
@@ -257,15 +260,15 @@
         source_number: Annotated[
             Optional[StrictInt], Field(description="Unique identifier for the video source")
         ] = None,
         updated: Annotated[
             Optional[datetime], Field(description="Record was modified after this date/time. In UTC.")
         ] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """List available video streams for a fixture  # noqa: E501
 
         Display the list of video streams for a fixture  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.video_stream_outputs_fixture_list_with_http_info(fixture_id, organization_id, sport, added, content, external, feed_type, fields, hide_null, include, limit, locale, offset, provider, source_number, updated, async_req=True)
@@ -301,21 +304,22 @@
         :type provider: str
         :param source_number: Unique identifier for the video source
         :type source_number: int
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -388,21 +392,21 @@
                 _query_params.append(
                     ("added", _params["added"].strftime(self.api_client.configuration.datetime_format))
                 )
             else:
                 _query_params.append(("added", _params["added"]))
 
         if _params.get("content") is not None:  # noqa: E501
-            _query_params.append(("content", _params["content"]))
+            _query_params.append(("content", _params["content"].value))
 
         if _params.get("external") is not None:  # noqa: E501
             _query_params.append(("external", _params["external"]))
 
         if _params.get("feed_type") is not None:  # noqa: E501
-            _query_params.append(("feedType", _params["feed_type"]))
+            _query_params.append(("feedType", _params["feed_type"].value))
 
         if _params.get("fields") is not None:  # noqa: E501
             _query_params.append(("fields", _params["fields"]))
 
         if _params.get("hide_null") is not None:  # noqa: E501
             _query_params.append(("hideNull", _params["hide_null"]))
 
@@ -601,28 +605,28 @@
         :type to_time_utc: datetime
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param venue_id: The unique identifier of the venue
         :type venue_id: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: VideoStreamOutputsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the video_stream_outputs_org_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.video_stream_outputs_org_list_with_http_info(
                 organization_id,
                 sport,
                 added,
                 competition_id,
                 content,
@@ -727,15 +731,15 @@
             Optional[datetime], Field(description="Where fixture start time (in UTC) <= this value")
         ] = None,
         updated: Annotated[
             Optional[datetime], Field(description="Record was modified after this date/time. In UTC.")
         ] = None,
         venue_id: Annotated[Optional[StrictStr], Field(description="The unique identifier of the venue")] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """List available video streams for an organization  # noqa: E501
 
         Display the list of video streams for an organization. Streams for completed fixtures and those older than 12 hours, will not be displayed.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.video_stream_outputs_org_list_with_http_info(organization_id, sport, added, competition_id, content, external, feed_type, fields, from_time_utc, hide_null, include, limit, locale, master_venue_id, offset, provider, season_id, source_number, to_time_utc, updated, venue_id, async_req=True)
@@ -781,21 +785,22 @@
         :type to_time_utc: datetime
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param venue_id: The unique identifier of the venue
         :type venue_id: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -873,21 +878,21 @@
             else:
                 _query_params.append(("added", _params["added"]))
 
         if _params.get("competition_id") is not None:  # noqa: E501
             _query_params.append(("competitionId", _params["competition_id"]))
 
         if _params.get("content") is not None:  # noqa: E501
-            _query_params.append(("content", _params["content"]))
+            _query_params.append(("content", _params["content"].value))
 
         if _params.get("external") is not None:  # noqa: E501
             _query_params.append(("external", _params["external"]))
 
         if _params.get("feed_type") is not None:  # noqa: E501
-            _query_params.append(("feedType", _params["feed_type"]))
+            _query_params.append(("feedType", _params["feed_type"].value))
 
         if _params.get("fields") is not None:  # noqa: E501
             _query_params.append(("fields", _params["fields"]))
 
         if _params.get("from_time_utc") is not None:  # noqa: E501
             if isinstance(_params["from_time_utc"], datetime):
                 _query_params.append(
@@ -1111,28 +1116,28 @@
         :type to_time_utc: datetime
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param venue_id: The unique identifier of the venue
         :type venue_id: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
-        :type _preload_content: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :return: Returns the result object.
                  If the method is called asynchronously,
                  returns the request thread.
         :rtype: VideoStreamOutputsResponse
         """
         kwargs["_return_http_data_only"] = True
+        if "_preload_content" in kwargs:
+            raise ValueError(
+                "Error! Please call the video_stream_outputs_orggroup_list_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data"
+            )
         try:
             return self.video_stream_outputs_orggroup_list_with_http_info(
                 organization_group_code,
                 sport,
                 added,
                 competition_id,
                 content,
@@ -1239,15 +1244,15 @@
             Optional[datetime], Field(description="Where fixture start time (in UTC) <= this value")
         ] = None,
         updated: Annotated[
             Optional[datetime], Field(description="Record was modified after this date/time. In UTC.")
         ] = None,
         venue_id: Annotated[Optional[StrictStr], Field(description="The unique identifier of the venue")] = None,
         **kwargs
-    ):  # noqa: E501
+    ) -> ApiResponse:  # noqa: E501
         """List available video streams for the ~organization group~  # noqa: E501
 
         Display the list of video streams for the organization group. Streams for completed fixtures and those older than 12 hours, will not be displayed.  # noqa: E501
         This method makes a synchronous HTTP request by default. To make an
         asynchronous HTTP request, please pass async_req=True
 
         >>> thread = api.video_stream_outputs_orggroup_list_with_http_info(organization_group_code, sport, added, competition_id, content, external, feed_type, fields, from_time_utc, hide_null, include, limit, locale, master_venue_id, offset, provider, season_id, source_number, to_time_utc, updated, venue_id, async_req=True)
@@ -1293,21 +1298,22 @@
         :type to_time_utc: datetime
         :param updated: Record was modified after this date/time. In UTC.
         :type updated: datetime
         :param venue_id: The unique identifier of the venue
         :type venue_id: str
         :param async_req: Whether to execute the request asynchronously.
         :type async_req: bool, optional
-        :param _return_http_data_only: response data without head status code
-                                       and headers
-        :type _return_http_data_only: bool, optional
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :type _preload_content: bool, optional
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :type _return_http_data_only: bool, optional
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
@@ -1385,21 +1391,21 @@
             else:
                 _query_params.append(("added", _params["added"]))
 
         if _params.get("competition_id") is not None:  # noqa: E501
             _query_params.append(("competitionId", _params["competition_id"]))
 
         if _params.get("content") is not None:  # noqa: E501
-            _query_params.append(("content", _params["content"]))
+            _query_params.append(("content", _params["content"].value))
 
         if _params.get("external") is not None:  # noqa: E501
             _query_params.append(("external", _params["external"]))
 
         if _params.get("feed_type") is not None:  # noqa: E501
-            _query_params.append(("feedType", _params["feed_type"]))
+            _query_params.append(("feedType", _params["feed_type"].value))
 
         if _params.get("fields") is not None:  # noqa: E501
             _query_params.append(("fields", _params["fields"]))
 
         if _params.get("from_time_utc") is not None:  # noqa: E501
             if isinstance(_params["from_time_utc"], datetime):
                 _query_params.append(
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/api_client.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/api_client.py`

 * *Files 2% similar despite different names*

```diff
@@ -21,14 +21,15 @@
 from multiprocessing.pool import ThreadPool
 from urllib.parse import quote
 
 from dateutil.parser import parse
 
 import atriumsports.datacore.openapi.models
 from atriumsports.datacore.openapi import rest
+from atriumsports.datacore.openapi.api_response import ApiResponse
 from atriumsports.datacore.openapi.configuration import Configuration
 from atriumsports.datacore.openapi.exceptions import ApiException, ApiValueError
 
 
 class ApiClient(object):
     """Generic API client for OpenAPI client library builds.
 
@@ -69,15 +70,15 @@
 
         self.rest_client = rest.RESTClientObject(configuration)
         self.default_headers = {}
         if header_name is not None:
             self.default_headers[header_name] = header_value
         self.cookie = cookie
         # Set default User-Agent.
-        self.user_agent = "OpenAPI-Generator/1.1.0/python"
+        self.user_agent = "AtriumSportsSDK/1.2.0"
         self.client_side_validation = configuration.client_side_validation
 
     def __enter__(self):
         return self
 
     def __exit__(self, exc_type, exc_value, traceback):
         self.close()
@@ -153,14 +154,15 @@
         _return_http_data_only=None,
         collection_formats=None,
         _preload_content=True,
         _request_timeout=None,
         _host=None,
         _request_auth=None,
     ):
+
         config = self.configuration
 
         # header parameters
         header_params = header_params or {}
         header_params.update(self.default_headers)
         if self.cookie:
             header_params["Cookie"] = self.cookie
@@ -220,43 +222,46 @@
         except ApiException as e:
             if e.body:
                 e.body = e.body.decode("utf-8")
             raise e
 
         self.last_response = response_data
 
-        return_data = response_data
-
-        if not _preload_content:
-            return return_data
+        return_data = None  # assuming deserialization is not needed
+        # data needs deserialization or returns HTTP data (deserialized) only
+        if _preload_content or _return_http_data_only:
+            response_type = response_types_map.get(str(response_data.status), None)
 
-        response_type = response_types_map.get(str(response_data.status), None)
-
-        if response_type == "bytearray":
-            response_data.data = response_data.data
-        else:
-            match = None
-            content_type = response_data.getheader("content-type")
-            if content_type is not None:
-                match = re.search(r"charset=([a-zA-Z\-\d]+)[\s;]?", content_type)
-            encoding = match.group(1) if match else "utf-8"
-            response_data.data = response_data.data.decode(encoding)
-
-        # deserialize response data
-        if response_type == "bytearray":
-            return_data = response_data.data
-        elif response_type:
-            return_data = self.deserialize(response_data, response_type)
-        else:
-            return_data = None
+            if response_type == "bytearray":
+                response_data.data = response_data.data
+            else:
+                match = None
+                content_type = response_data.getheader("content-type")
+                if content_type is not None:
+                    match = re.search(r"charset=([a-zA-Z\-\d]+)[\s;]?", content_type)
+                encoding = match.group(1) if match else "utf-8"
+                response_data.data = response_data.data.decode(encoding)
+
+            # deserialize response data
+            if response_type == "bytearray":
+                return_data = response_data.data
+            elif response_type:
+                return_data = self.deserialize(response_data, response_type)
+            else:
+                return_data = None
 
         if _return_http_data_only:
             return return_data
         else:
-            return (return_data, response_data.status, response_data.getheaders())
+            return ApiResponse(
+                status_code=response_data.status,
+                data=return_data,
+                headers=response_data.getheaders(),
+                raw_data=response_data.data,
+            )
 
     def sanitize_for_serialization(self, obj):
         """Builds a JSON POST object.
 
         If obj is None, return None.
         If obj is str, int, long, float, bool, return directly.
         If obj is datetime.datetime, datetime.date
@@ -384,21 +389,22 @@
         :param post_params dict: Request post form parameters,
             for `application/x-www-form-urlencoded`, `multipart/form-data`.
         :param auth_settings list: Auth Settings names for the request.
         :param response: Response data type.
         :param files dict: key -> filename, value -> filepath,
             for `multipart/form-data`.
         :param async_req bool: execute request asynchronously
-        :param _return_http_data_only: response data without head status code
-                                       and headers
+        :param _return_http_data_only: response data instead of ApiResponse
+                                       object with status code, headers, etc
+        :param _preload_content: if False, the ApiResponse.data will
+                                 be set to none and raw_data will store the
+                                 HTTP response body without reading/decoding.
+                                 Default is True.
         :param collection_formats: dict of collection formats for path, query,
             header, and post parameters.
-        :param _preload_content: if False, the urllib3.HTTPResponse object will
-                                 be returned without reading/decoding response
-                                 data. Default is True.
         :param _request_timeout: timeout setting for this request. If one
                                  number provided, it will be total request
                                  timeout. It can also be a pair (tuple) of
                                  (connection, read) timeouts.
         :param _request_auth: set to override the auth_settings for an a single
                               request; this effectively ignores the authentication
                               in the spec for a single request.
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/configuration.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/configuration.py`

 * *Files 2% similar despite different names*

```diff
@@ -156,14 +156,18 @@
         """
         self.key_file = None
         """client key file
         """
         self.assert_hostname = None
         """Set this to True/False to enable/disable SSL hostname verification.
         """
+        self.tls_server_name = None
+        """SSL/TLS Server Name Indication (SNI)
+           Set this to the SNI value expected by the server.
+        """
 
         self.connection_pool_maxsize = multiprocessing.cpu_count() * 5
         """urllib3 connection pool's maximum number of connections saved
            per pool. urllib3 uses 1 connection as default value, but this is
            not the best value when you are making a lot of possibly parallel
            requests to the same host, which is often the case here.
            cpu_count * 5 is used as default value to increase performance.
@@ -384,15 +388,15 @@
         :return: The report for debugging.
         """
         return (
             "Python SDK Debug Report:\n"
             "OS: {env}\n"
             "Python Version: {pyversion}\n"
             "Version of the API: v1\n"
-            "SDK Package Version: 1.1.0".format(env=sys.platform, pyversion=sys.version)
+            "SDK Package Version: 1.2.0".format(env=sys.platform, pyversion=sys.version)
         )
 
     def get_host_settings(self):
         """Gets an array of host settings
 
         :return: An array of host settings
         """
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/exceptions.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/exceptions.py`

 * *Files identical despite different names*

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/__init__.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/__init__.py`

 * *Files identical despite different names*

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/award_post_body.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/award_post_body.py`

 * *Files 2% similar despite different names*

```diff
@@ -14,15 +14,14 @@
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
 from datetime import date
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictInt, StrictStr, constr, validator
 
 
 class AwardPostBody(BaseModel):
     """
@@ -71,22 +70,26 @@
         "award",
         "awardSubType",
         "notes",
         "externalId",
     ]
 
     @validator("external_id")
-    def external_id_validate_regular_expression(cls, v):
-        if v is None:
-            return v
-        if not re.match(r"^[0-9A-Za-z\/_-]+$", v):
+    def external_id_validate_regular_expression(cls, value):
+        """Validates the regular expression"""
+        if value is None:
+            return value
+
+        if not re.match(r"^[0-9A-Za-z\/_-]+$", value):
             raise ValueError(r"must validate the regular expression /^[0-9A-Za-z\/_-]+$/")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -136,15 +139,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> AwardPostBody:
         """Create an instance of AwardPostBody from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return AwardPostBody.parse_obj(obj)
 
         _obj = AwardPostBody.parse_obj(
             {
                 "award_id": obj.get("awardId"),
                 "person_id": obj.get("personId"),
                 "entity_group_id": obj.get("entityGroupId"),
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/award_put_body.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/award_put_body.py`

 * *Files 6% similar despite different names*

```diff
@@ -14,15 +14,14 @@
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
 from datetime import date
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictInt, StrictStr, constr, validator
 
 
 class AwardPutBody(BaseModel):
     """
@@ -69,22 +68,26 @@
         "award",
         "awardSubType",
         "notes",
         "externalId",
     ]
 
     @validator("external_id")
-    def external_id_validate_regular_expression(cls, v):
-        if v is None:
-            return v
-        if not re.match(r"^[0-9A-Za-z\/_-]+$", v):
+    def external_id_validate_regular_expression(cls, value):
+        """Validates the regular expression"""
+        if value is None:
+            return value
+
+        if not re.match(r"^[0-9A-Za-z\/_-]+$", value):
             raise ValueError(r"must validate the regular expression /^[0-9A-Za-z\/_-]+$/")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -134,15 +137,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> AwardPutBody:
         """Create an instance of AwardPutBody from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return AwardPutBody.parse_obj(obj)
 
         _obj = AwardPutBody.parse_obj(
             {
                 "person_id": obj.get("personId"),
                 "entity_group_id": obj.get("entityGroupId"),
                 "entity_id": obj.get("entityId"),
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/awards_model.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/awards_model.py`

 * *Files 2% similar despite different names*

```diff
@@ -14,15 +14,14 @@
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
 from datetime import date, datetime
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictInt, StrictStr, constr, validator
 
 from atriumsports.datacore.openapi.models.awards_model_organization import AwardsModelOrganization
 from atriumsports.datacore.openapi.models.entities_model_entity_group import EntitiesModelEntityGroup
 from atriumsports.datacore.openapi.models.fixture_entities_model_entity import FixtureEntitiesModelEntity
@@ -101,22 +100,26 @@
         "notes",
         "externalId",
         "updated",
         "added",
     ]
 
     @validator("external_id")
-    def external_id_validate_regular_expression(cls, v):
-        if v is None:
-            return v
-        if not re.match(r"^[0-9A-Za-z\/_-]+$", v):
+    def external_id_validate_regular_expression(cls, value):
+        """Validates the regular expression"""
+        if value is None:
+            return value
+
+        if not re.match(r"^[0-9A-Za-z\/_-]+$", value):
             raise ValueError(r"must validate the regular expression /^[0-9A-Za-z\/_-]+$/")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -195,15 +198,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> AwardsModel:
         """Create an instance of AwardsModel from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return AwardsModel.parse_obj(obj)
 
         _obj = AwardsModel.parse_obj(
             {
                 "award_id": obj.get("awardId"),
                 "organization_id": obj.get("organizationId"),
                 "organization": AwardsModelOrganization.from_dict(obj.get("organization"))
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/awards_model_organization.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/awards_model_organization.py`

 * *Files 6% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr, validator
 
 
 class AwardsModelOrganization(BaseModel):
     """
@@ -29,22 +28,26 @@
     """
 
     resource_type: Optional[StrictStr] = Field(None, alias="resourceType")
     id: Optional[StrictStr] = Field(None, description="Unique identifier for this resource")
     __properties = ["resourceType", "id"]
 
     @validator("resource_type")
-    def resource_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("organizations"):
+    def resource_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("organizations"):
             raise ValueError("must be one of enum values ('organizations')")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -64,12 +67,12 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> AwardsModelOrganization:
         """Create an instance of AwardsModelOrganization from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return AwardsModelOrganization.parse_obj(obj)
 
         _obj = AwardsModelOrganization.parse_obj({"resource_type": obj.get("resourceType"), "id": obj.get("id")})
         return _obj
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/awards_response.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/awards_response.py`

 * *Files 3% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import List, Optional
 
 from pydantic import BaseModel, conlist
 
 from atriumsports.datacore.openapi.models.awards_model import AwardsModel
 from atriumsports.datacore.openapi.models.included_data import IncludedData
 from atriumsports.datacore.openapi.models.response_links import ResponseLinks
@@ -36,14 +35,16 @@
     meta: Optional[ResponseMetaData] = None
     links: Optional[ResponseLinks] = None
     included: Optional[IncludedData] = None
     data: Optional[conlist(AwardsModel)] = None
     __properties = ["meta", "links", "included", "data"]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -79,15 +80,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> AwardsResponse:
         """Create an instance of AwardsResponse from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return AwardsResponse.parse_obj(obj)
 
         _obj = AwardsResponse.parse_obj(
             {
                 "meta": ResponseMetaData.from_dict(obj.get("meta")) if obj.get("meta") is not None else None,
                 "links": ResponseLinks.from_dict(obj.get("links")) if obj.get("links") is not None else None,
                 "included": IncludedData.from_dict(obj.get("included")) if obj.get("included") is not None else None,
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/blank_model_response.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/blank_model_response.py`

 * *Files 3% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Any, Dict, List, Optional
 
 from pydantic import BaseModel, conlist
 
 from atriumsports.datacore.openapi.models.included_data import IncludedData
 from atriumsports.datacore.openapi.models.response_links import ResponseLinks
 from atriumsports.datacore.openapi.models.response_meta_data import ResponseMetaData
@@ -35,14 +34,16 @@
     meta: Optional[ResponseMetaData] = None
     links: Optional[ResponseLinks] = None
     included: Optional[IncludedData] = None
     data: Optional[conlist(Dict[str, Any])] = None
     __properties = ["meta", "links", "included", "data"]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -71,15 +72,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> BlankModelResponse:
         """Create an instance of BlankModelResponse from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return BlankModelResponse.parse_obj(obj)
 
         _obj = BlankModelResponse.parse_obj(
             {
                 "meta": ResponseMetaData.from_dict(obj.get("meta")) if obj.get("meta") is not None else None,
                 "links": ResponseLinks.from_dict(obj.get("links")) if obj.get("links") is not None else None,
                 "included": IncludedData.from_dict(obj.get("included")) if obj.get("included") is not None else None,
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/career_person_statistics_model.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/career_person_statistics_model.py`

 * *Files 6% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Any, Dict, Optional
 
 from pydantic import BaseModel, Field, StrictStr
 
 from atriumsports.datacore.openapi.models.career_person_statistics_model_organization import (
     CareerPersonStatisticsModelOrganization,
 )
@@ -39,14 +38,16 @@
         None, alias="organizationId", description="The unique identifier of the organization"
     )
     organization: Optional[CareerPersonStatisticsModelOrganization] = None
     statistics: Optional[Dict[str, Any]] = None
     __properties = ["personId", "person", "organizationId", "organization", "statistics"]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -78,15 +79,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> CareerPersonStatisticsModel:
         """Create an instance of CareerPersonStatisticsModel from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return CareerPersonStatisticsModel.parse_obj(obj)
 
         _obj = CareerPersonStatisticsModel.parse_obj(
             {
                 "person_id": obj.get("personId"),
                 "person": FixturePersonsModelPerson.from_dict(obj.get("person"))
                 if obj.get("person") is not None
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/career_person_statistics_model_organization.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/career_person_statistics_model_organization.py`

 * *Files 8% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr, validator
 
 
 class CareerPersonStatisticsModelOrganization(BaseModel):
     """
@@ -29,22 +28,26 @@
     """
 
     resource_type: Optional[StrictStr] = Field(None, alias="resourceType")
     id: Optional[StrictStr] = Field(None, description="Unique identifier for this resource")
     __properties = ["resourceType", "id"]
 
     @validator("resource_type")
-    def resource_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("organizations"):
+    def resource_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("organizations"):
             raise ValueError("must be one of enum values ('organizations')")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -64,14 +67,14 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> CareerPersonStatisticsModelOrganization:
         """Create an instance of CareerPersonStatisticsModelOrganization from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return CareerPersonStatisticsModelOrganization.parse_obj(obj)
 
         _obj = CareerPersonStatisticsModelOrganization.parse_obj(
             {"resource_type": obj.get("resourceType"), "id": obj.get("id")}
         )
         return _obj
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/career_person_statistics_response.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/career_person_statistics_response.py`

 * *Files 4% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import List, Optional
 
 from pydantic import BaseModel, conlist
 
 from atriumsports.datacore.openapi.models.career_person_statistics_model import CareerPersonStatisticsModel
 from atriumsports.datacore.openapi.models.included_data import IncludedData
 from atriumsports.datacore.openapi.models.response_links import ResponseLinks
@@ -36,14 +35,16 @@
     meta: Optional[ResponseMetaData] = None
     links: Optional[ResponseLinks] = None
     included: Optional[IncludedData] = None
     data: Optional[conlist(CareerPersonStatisticsModel)] = None
     __properties = ["meta", "links", "included", "data"]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -79,15 +80,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> CareerPersonStatisticsResponse:
         """Create an instance of CareerPersonStatisticsResponse from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return CareerPersonStatisticsResponse.parse_obj(obj)
 
         _obj = CareerPersonStatisticsResponse.parse_obj(
             {
                 "meta": ResponseMetaData.from_dict(obj.get("meta")) if obj.get("meta") is not None else None,
                 "links": ResponseLinks.from_dict(obj.get("links")) if obj.get("links") is not None else None,
                 "included": IncludedData.from_dict(obj.get("included")) if obj.get("included") is not None else None,
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/change_log_model.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/change_log_model.py`

 * *Files 7% similar despite different names*

```diff
@@ -14,15 +14,14 @@
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
 from datetime import datetime
-from inspect import getfullargspec
 from typing import Any, Optional
 
 from pydantic import BaseModel, Field, StrictStr, constr, validator
 
 from atriumsports.datacore.openapi.models.change_log_model_organization import ChangeLogModelOrganization
 
 
@@ -59,22 +58,26 @@
         "primaryId",
         "childType",
         "changeMessage",
         "added",
     ]
 
     @validator("change_type")
-    def change_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("delete", "update"):
+    def change_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("delete", "update"):
             raise ValueError("must be one of enum values ('delete', 'update')")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -109,15 +112,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> ChangeLogModel:
         """Create an instance of ChangeLogModel from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return ChangeLogModel.parse_obj(obj)
 
         _obj = ChangeLogModel.parse_obj(
             {
                 "organization_id": obj.get("organizationId"),
                 "organization": ChangeLogModelOrganization.from_dict(obj.get("organization"))
                 if obj.get("organization") is not None
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/change_log_model_organization.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/change_log_model_organization.py`

 * *Files 8% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr, validator
 
 
 class ChangeLogModelOrganization(BaseModel):
     """
@@ -29,22 +28,26 @@
     """
 
     resource_type: Optional[StrictStr] = Field(None, alias="resourceType")
     id: Optional[StrictStr] = Field(None, description="Unique identifier for this resource")
     __properties = ["resourceType", "id"]
 
     @validator("resource_type")
-    def resource_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("organizations"):
+    def resource_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("organizations"):
             raise ValueError("must be one of enum values ('organizations')")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -64,12 +67,12 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> ChangeLogModelOrganization:
         """Create an instance of ChangeLogModelOrganization from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return ChangeLogModelOrganization.parse_obj(obj)
 
         _obj = ChangeLogModelOrganization.parse_obj({"resource_type": obj.get("resourceType"), "id": obj.get("id")})
         return _obj
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/change_log_response.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/change_log_response.py`

 * *Files 6% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import List, Optional
 
 from pydantic import BaseModel, conlist
 
 from atriumsports.datacore.openapi.models.change_log_model import ChangeLogModel
 from atriumsports.datacore.openapi.models.included_data import IncludedData
 from atriumsports.datacore.openapi.models.response_links import ResponseLinks
@@ -36,14 +35,16 @@
     meta: Optional[ResponseMetaData] = None
     links: Optional[ResponseLinks] = None
     included: Optional[IncludedData] = None
     data: Optional[conlist(ChangeLogModel)] = None
     __properties = ["meta", "links", "included", "data"]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -79,15 +80,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> ChangeLogResponse:
         """Create an instance of ChangeLogResponse from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return ChangeLogResponse.parse_obj(obj)
 
         _obj = ChangeLogResponse.parse_obj(
             {
                 "meta": ResponseMetaData.from_dict(obj.get("meta")) if obj.get("meta") is not None else None,
                 "links": ResponseLinks.from_dict(obj.get("links")) if obj.get("links") is not None else None,
                 "included": IncludedData.from_dict(obj.get("included")) if obj.get("included") is not None else None,
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/competition_entity_statistics_model.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/competition_entity_statistics_model.py`

 * *Files 2% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Any, Dict, Optional
 
 from pydantic import BaseModel, Field, StrictStr
 
 from atriumsports.datacore.openapi.models.competition_entity_statistics_model_organization import (
     CompetitionEntityStatisticsModelOrganization,
 )
@@ -52,14 +51,16 @@
         "organization",
         "competitionId",
         "competition",
         "statistics",
     ]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -94,15 +95,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> CompetitionEntityStatisticsModel:
         """Create an instance of CompetitionEntityStatisticsModel from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return CompetitionEntityStatisticsModel.parse_obj(obj)
 
         _obj = CompetitionEntityStatisticsModel.parse_obj(
             {
                 "entity_id": obj.get("entityId"),
                 "entity": FixtureEntitiesModelEntity.from_dict(obj.get("entity"))
                 if obj.get("entity") is not None
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/competition_entity_statistics_model_organization.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/competition_entity_statistics_model_organization.py`

 * *Files 11% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr, validator
 
 
 class CompetitionEntityStatisticsModelOrganization(BaseModel):
     """
@@ -29,22 +28,26 @@
     """
 
     resource_type: Optional[StrictStr] = Field(None, alias="resourceType")
     id: Optional[StrictStr] = Field(None, description="Unique identifier for this resource")
     __properties = ["resourceType", "id"]
 
     @validator("resource_type")
-    def resource_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("organizations"):
+    def resource_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("organizations"):
             raise ValueError("must be one of enum values ('organizations')")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -64,14 +67,14 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> CompetitionEntityStatisticsModelOrganization:
         """Create an instance of CompetitionEntityStatisticsModelOrganization from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return CompetitionEntityStatisticsModelOrganization.parse_obj(obj)
 
         _obj = CompetitionEntityStatisticsModelOrganization.parse_obj(
             {"resource_type": obj.get("resourceType"), "id": obj.get("id")}
         )
         return _obj
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/competition_entity_statistics_response.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/competition_entity_statistics_response.py`

 * *Files 5% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import List, Optional
 
 from pydantic import BaseModel, conlist
 
 from atriumsports.datacore.openapi.models.competition_entity_statistics_model import CompetitionEntityStatisticsModel
 from atriumsports.datacore.openapi.models.included_data import IncludedData
 from atriumsports.datacore.openapi.models.response_links import ResponseLinks
@@ -36,14 +35,16 @@
     meta: Optional[ResponseMetaData] = None
     links: Optional[ResponseLinks] = None
     included: Optional[IncludedData] = None
     data: Optional[conlist(CompetitionEntityStatisticsModel)] = None
     __properties = ["meta", "links", "included", "data"]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -79,15 +80,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> CompetitionEntityStatisticsResponse:
         """Create an instance of CompetitionEntityStatisticsResponse from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return CompetitionEntityStatisticsResponse.parse_obj(obj)
 
         _obj = CompetitionEntityStatisticsResponse.parse_obj(
             {
                 "meta": ResponseMetaData.from_dict(obj.get("meta")) if obj.get("meta") is not None else None,
                 "links": ResponseLinks.from_dict(obj.get("links")) if obj.get("links") is not None else None,
                 "included": IncludedData.from_dict(obj.get("included")) if obj.get("included") is not None else None,
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/competition_historical_name.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/competition_historical_name.py`

 * *Files 8% similar despite different names*

```diff
@@ -14,15 +14,14 @@
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
 from datetime import date
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr
 
 
 class CompetitionHistoricalName(BaseModel):
     """
@@ -38,14 +37,16 @@
     )
     abbreviation_latin: Optional[StrictStr] = Field(
         None, alias="abbreviationLatin", description="Abbreviation in latin characters"
     )
     __properties = ["dateStart", "dateEnd", "nameLocal", "nameLatin", "abbreviationLocal", "abbreviationLatin"]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -95,15 +96,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> CompetitionHistoricalName:
         """Create an instance of CompetitionHistoricalName from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return CompetitionHistoricalName.parse_obj(obj)
 
         _obj = CompetitionHistoricalName.parse_obj(
             {
                 "date_start": obj.get("dateStart"),
                 "date_end": obj.get("dateEnd"),
                 "name_local": obj.get("nameLocal"),
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/competition_person_statistics_model.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/competition_person_statistics_model.py`

 * *Files 5% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Any, Dict, Optional
 
 from pydantic import BaseModel, Field, StrictStr
 
 from atriumsports.datacore.openapi.models.competition_person_statistics_model_organization import (
     CompetitionPersonStatisticsModelOrganization,
 )
@@ -52,14 +51,16 @@
         "organization",
         "competitionId",
         "competition",
         "statistics",
     ]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -94,15 +95,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> CompetitionPersonStatisticsModel:
         """Create an instance of CompetitionPersonStatisticsModel from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return CompetitionPersonStatisticsModel.parse_obj(obj)
 
         _obj = CompetitionPersonStatisticsModel.parse_obj(
             {
                 "person_id": obj.get("personId"),
                 "person": FixturePersonsModelPerson.from_dict(obj.get("person"))
                 if obj.get("person") is not None
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/competition_person_statistics_model_organization.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/competition_person_statistics_model_organization.py`

 * *Files 8% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr, validator
 
 
 class CompetitionPersonStatisticsModelOrganization(BaseModel):
     """
@@ -29,22 +28,26 @@
     """
 
     resource_type: Optional[StrictStr] = Field(None, alias="resourceType")
     id: Optional[StrictStr] = Field(None, description="Unique identifier for this resource")
     __properties = ["resourceType", "id"]
 
     @validator("resource_type")
-    def resource_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("organizations"):
+    def resource_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("organizations"):
             raise ValueError("must be one of enum values ('organizations')")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -64,14 +67,14 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> CompetitionPersonStatisticsModelOrganization:
         """Create an instance of CompetitionPersonStatisticsModelOrganization from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return CompetitionPersonStatisticsModelOrganization.parse_obj(obj)
 
         _obj = CompetitionPersonStatisticsModelOrganization.parse_obj(
             {"resource_type": obj.get("resourceType"), "id": obj.get("id")}
         )
         return _obj
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/competition_person_statistics_response.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/competition_person_statistics_response.py`

 * *Files 1% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import List, Optional
 
 from pydantic import BaseModel, conlist
 
 from atriumsports.datacore.openapi.models.competition_person_statistics_model import CompetitionPersonStatisticsModel
 from atriumsports.datacore.openapi.models.included_data import IncludedData
 from atriumsports.datacore.openapi.models.response_links import ResponseLinks
@@ -36,14 +35,16 @@
     meta: Optional[ResponseMetaData] = None
     links: Optional[ResponseLinks] = None
     included: Optional[IncludedData] = None
     data: Optional[conlist(CompetitionPersonStatisticsModel)] = None
     __properties = ["meta", "links", "included", "data"]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -79,15 +80,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> CompetitionPersonStatisticsResponse:
         """Create an instance of CompetitionPersonStatisticsResponse from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return CompetitionPersonStatisticsResponse.parse_obj(obj)
 
         _obj = CompetitionPersonStatisticsResponse.parse_obj(
             {
                 "meta": ResponseMetaData.from_dict(obj.get("meta")) if obj.get("meta") is not None else None,
                 "links": ResponseLinks.from_dict(obj.get("links")) if obj.get("links") is not None else None,
                 "included": IncludedData.from_dict(obj.get("included")) if obj.get("included") is not None else None,
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/competition_post_body.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/competition_post_body.py`

 * *Files 7% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import List, Optional
 
 from pydantic import BaseModel, Field, StrictStr, conlist, constr, validator
 
 from atriumsports.datacore.openapi.models.competition_historical_name import CompetitionHistoricalName
 from atriumsports.datacore.openapi.models.social_media import SocialMedia
 
@@ -89,34 +88,40 @@
         "social",
         "externalId",
         "historicalNames",
         "ageGroup",
     ]
 
     @validator("event_type")
-    def event_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("FIXTURE", "PRACTICE"):
+    def event_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("FIXTURE", "PRACTICE"):
             raise ValueError("must be one of enum values ('FIXTURE', 'PRACTICE')")
-        return v
+        return value
 
     @validator("external_id")
-    def external_id_validate_regular_expression(cls, v):
-        if v is None:
-            return v
-        if not re.match(r"^[0-9A-Za-z\/_-]+$", v):
+    def external_id_validate_regular_expression(cls, value):
+        """Validates the regular expression"""
+        if value is None:
+            return value
+
+        if not re.match(r"^[0-9A-Za-z\/_-]+$", value):
             raise ValueError(r"must validate the regular expression /^[0-9A-Za-z\/_-]+$/")
-        return v
+        return value
 
     @validator("age_group")
-    def age_group_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in (
+    def age_group_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in (
             "JUNIOR",
             "YOUTH",
             "UNDER_15",
             "UNDER_16",
             "UNDER_17",
             "UNDER_18",
             "UNDER_19",
@@ -126,17 +131,19 @@
             "UNDER_23",
             "SENIOR",
             "MASTERS",
         ):
             raise ValueError(
                 "must be one of enum values ('JUNIOR', 'YOUTH', 'UNDER_15', 'UNDER_16', 'UNDER_17', 'UNDER_18', 'UNDER_19', 'UNDER_20', 'UNDER_21', 'UNDER_22', 'UNDER_23', 'SENIOR', 'MASTERS')"
             )
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -201,15 +208,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> CompetitionPostBody:
         """Create an instance of CompetitionPostBody from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return CompetitionPostBody.parse_obj(obj)
 
         _obj = CompetitionPostBody.parse_obj(
             {
                 "competition_id": obj.get("competitionId"),
                 "league_id": obj.get("leagueId"),
                 "international_reference": obj.get("internationalReference"),
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/competition_put_body.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/competition_put_body.py`

 * *Files 10% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import List, Optional
 
 from pydantic import BaseModel, Field, StrictStr, conlist, constr, validator
 
 from atriumsports.datacore.openapi.models.competition_historical_name import CompetitionHistoricalName
 from atriumsports.datacore.openapi.models.social_media import SocialMedia
 
@@ -85,34 +84,40 @@
         "social",
         "externalId",
         "historicalNames",
         "ageGroup",
     ]
 
     @validator("event_type")
-    def event_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("FIXTURE", "PRACTICE"):
+    def event_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("FIXTURE", "PRACTICE"):
             raise ValueError("must be one of enum values ('FIXTURE', 'PRACTICE')")
-        return v
+        return value
 
     @validator("external_id")
-    def external_id_validate_regular_expression(cls, v):
-        if v is None:
-            return v
-        if not re.match(r"^[0-9A-Za-z\/_-]+$", v):
+    def external_id_validate_regular_expression(cls, value):
+        """Validates the regular expression"""
+        if value is None:
+            return value
+
+        if not re.match(r"^[0-9A-Za-z\/_-]+$", value):
             raise ValueError(r"must validate the regular expression /^[0-9A-Za-z\/_-]+$/")
-        return v
+        return value
 
     @validator("age_group")
-    def age_group_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in (
+    def age_group_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in (
             "JUNIOR",
             "YOUTH",
             "UNDER_15",
             "UNDER_16",
             "UNDER_17",
             "UNDER_18",
             "UNDER_19",
@@ -122,17 +127,19 @@
             "UNDER_23",
             "SENIOR",
             "MASTERS",
         ):
             raise ValueError(
                 "must be one of enum values ('JUNIOR', 'YOUTH', 'UNDER_15', 'UNDER_16', 'UNDER_17', 'UNDER_18', 'UNDER_19', 'UNDER_20', 'UNDER_21', 'UNDER_22', 'UNDER_23', 'SENIOR', 'MASTERS')"
             )
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -197,15 +204,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> CompetitionPutBody:
         """Create an instance of CompetitionPutBody from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return CompetitionPutBody.parse_obj(obj)
 
         _obj = CompetitionPutBody.parse_obj(
             {
                 "league_id": obj.get("leagueId"),
                 "international_reference": obj.get("internationalReference"),
                 "abbreviation_local": obj.get("abbreviationLocal"),
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/competitions_model.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/competitions_model.py`

 * *Files 3% similar despite different names*

```diff
@@ -14,15 +14,14 @@
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
 from datetime import datetime
-from inspect import getfullargspec
 from typing import List, Optional
 
 from pydantic import BaseModel, Field, StrictStr, conlist, constr, validator
 
 from atriumsports.datacore.openapi.models.competition_historical_name import CompetitionHistoricalName
 from atriumsports.datacore.openapi.models.competitions_model_league import CompetitionsModelLeague
 from atriumsports.datacore.openapi.models.competitions_model_organization import CompetitionsModelOrganization
@@ -107,34 +106,40 @@
         "updated",
         "added",
         "ageGroup",
         "images",
     ]
 
     @validator("event_type")
-    def event_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("FIXTURE", "PRACTICE"):
+    def event_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("FIXTURE", "PRACTICE"):
             raise ValueError("must be one of enum values ('FIXTURE', 'PRACTICE')")
-        return v
+        return value
 
     @validator("external_id")
-    def external_id_validate_regular_expression(cls, v):
-        if v is None:
-            return v
-        if not re.match(r"^[0-9A-Za-z\/_-]+$", v):
+    def external_id_validate_regular_expression(cls, value):
+        """Validates the regular expression"""
+        if value is None:
+            return value
+
+        if not re.match(r"^[0-9A-Za-z\/_-]+$", value):
             raise ValueError(r"must validate the regular expression /^[0-9A-Za-z\/_-]+$/")
-        return v
+        return value
 
     @validator("age_group")
-    def age_group_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in (
+    def age_group_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in (
             "JUNIOR",
             "YOUTH",
             "UNDER_15",
             "UNDER_16",
             "UNDER_17",
             "UNDER_18",
             "UNDER_19",
@@ -144,17 +149,19 @@
             "UNDER_23",
             "SENIOR",
             "MASTERS",
         ):
             raise ValueError(
                 "must be one of enum values ('JUNIOR', 'YOUTH', 'UNDER_15', 'UNDER_16', 'UNDER_17', 'UNDER_18', 'UNDER_19', 'UNDER_20', 'UNDER_21', 'UNDER_22', 'UNDER_23', 'SENIOR', 'MASTERS')"
             )
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -240,15 +247,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> CompetitionsModel:
         """Create an instance of CompetitionsModel from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return CompetitionsModel.parse_obj(obj)
 
         _obj = CompetitionsModel.parse_obj(
             {
                 "competition_id": obj.get("competitionId"),
                 "organization_id": obj.get("organizationId"),
                 "organization": CompetitionsModelOrganization.from_dict(obj.get("organization"))
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/competitions_model_league.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/competitions_model_league.py`

 * *Files 7% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr, validator
 
 
 class CompetitionsModelLeague(BaseModel):
     """
@@ -29,22 +28,26 @@
     """
 
     resource_type: Optional[StrictStr] = Field(None, alias="resourceType")
     id: Optional[StrictStr] = Field(None, description="Unique identifier for this resource")
     __properties = ["resourceType", "id"]
 
     @validator("resource_type")
-    def resource_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("leagues"):
+    def resource_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("leagues"):
             raise ValueError("must be one of enum values ('leagues')")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -64,12 +67,12 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> CompetitionsModelLeague:
         """Create an instance of CompetitionsModelLeague from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return CompetitionsModelLeague.parse_obj(obj)
 
         _obj = CompetitionsModelLeague.parse_obj({"resource_type": obj.get("resourceType"), "id": obj.get("id")})
         return _obj
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/competitions_model_organization.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixture_progressions_model_organization.py`

 * *Files 12% similar despite different names*

```diff
@@ -13,63 +13,68 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr, validator
 
 
-class CompetitionsModelOrganization(BaseModel):
+class FixtureProgressionsModelOrganization(BaseModel):
     """
-    The organization that this competition belongs to
+    The organization that this ~fixture_progression~ belongs to
     """
 
     resource_type: Optional[StrictStr] = Field(None, alias="resourceType")
     id: Optional[StrictStr] = Field(None, description="Unique identifier for this resource")
     __properties = ["resourceType", "id"]
 
     @validator("resource_type")
-    def resource_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("organizations"):
+    def resource_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("organizations"):
             raise ValueError("must be one of enum values ('organizations')")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> CompetitionsModelOrganization:
-        """Create an instance of CompetitionsModelOrganization from a JSON string"""
+    def from_json(cls, json_str: str) -> FixtureProgressionsModelOrganization:
+        """Create an instance of FixtureProgressionsModelOrganization from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
     def to_dict(self):
         """Returns the dictionary representation of the model using alias"""
         _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> CompetitionsModelOrganization:
-        """Create an instance of CompetitionsModelOrganization from a dict"""
+    def from_dict(cls, obj: dict) -> FixtureProgressionsModelOrganization:
+        """Create an instance of FixtureProgressionsModelOrganization from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
-            return CompetitionsModelOrganization.parse_obj(obj)
+        if not isinstance(obj, dict):
+            return FixtureProgressionsModelOrganization.parse_obj(obj)
 
-        _obj = CompetitionsModelOrganization.parse_obj({"resource_type": obj.get("resourceType"), "id": obj.get("id")})
+        _obj = FixtureProgressionsModelOrganization.parse_obj(
+            {"resource_type": obj.get("resourceType"), "id": obj.get("id")}
+        )
         return _obj
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/competitions_response.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/competitions_response.py`

 * *Files 2% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import List, Optional
 
 from pydantic import BaseModel, conlist
 
 from atriumsports.datacore.openapi.models.competitions_model import CompetitionsModel
 from atriumsports.datacore.openapi.models.included_data import IncludedData
 from atriumsports.datacore.openapi.models.response_links import ResponseLinks
@@ -36,14 +35,16 @@
     meta: Optional[ResponseMetaData] = None
     links: Optional[ResponseLinks] = None
     included: Optional[IncludedData] = None
     data: Optional[conlist(CompetitionsModel)] = None
     __properties = ["meta", "links", "included", "data"]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -79,15 +80,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> CompetitionsResponse:
         """Create an instance of CompetitionsResponse from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return CompetitionsResponse.parse_obj(obj)
 
         _obj = CompetitionsResponse.parse_obj(
             {
                 "meta": ResponseMetaData.from_dict(obj.get("meta")) if obj.get("meta") is not None else None,
                 "links": ResponseLinks.from_dict(obj.get("links")) if obj.get("links") is not None else None,
                 "included": IncludedData.from_dict(obj.get("included")) if obj.get("included") is not None else None,
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/competitions_season_status_model.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/competitions_season_status_model.py`

 * *Files 7% similar despite different names*

```diff
@@ -14,15 +14,14 @@
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
 from datetime import datetime
-from inspect import getfullargspec
 from typing import List, Optional
 
 from pydantic import BaseModel, Field, StrictStr, conlist, constr, validator
 
 from atriumsports.datacore.openapi.models.competition_historical_name import CompetitionHistoricalName
 from atriumsports.datacore.openapi.models.competitions_season_status_model_league import (
     CompetitionsSeasonStatusModelLeague,
@@ -111,34 +110,40 @@
         "updated",
         "added",
         "ageGroup",
         "images",
     ]
 
     @validator("event_type")
-    def event_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("FIXTURE", "PRACTICE"):
+    def event_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("FIXTURE", "PRACTICE"):
             raise ValueError("must be one of enum values ('FIXTURE', 'PRACTICE')")
-        return v
+        return value
 
     @validator("external_id")
-    def external_id_validate_regular_expression(cls, v):
-        if v is None:
-            return v
-        if not re.match(r"^[0-9A-Za-z\/_-]+$", v):
+    def external_id_validate_regular_expression(cls, value):
+        """Validates the regular expression"""
+        if value is None:
+            return value
+
+        if not re.match(r"^[0-9A-Za-z\/_-]+$", value):
             raise ValueError(r"must validate the regular expression /^[0-9A-Za-z\/_-]+$/")
-        return v
+        return value
 
     @validator("age_group")
-    def age_group_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in (
+    def age_group_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in (
             "JUNIOR",
             "YOUTH",
             "UNDER_15",
             "UNDER_16",
             "UNDER_17",
             "UNDER_18",
             "UNDER_19",
@@ -148,17 +153,19 @@
             "UNDER_23",
             "SENIOR",
             "MASTERS",
         ):
             raise ValueError(
                 "must be one of enum values ('JUNIOR', 'YOUTH', 'UNDER_15', 'UNDER_16', 'UNDER_17', 'UNDER_18', 'UNDER_19', 'UNDER_20', 'UNDER_21', 'UNDER_22', 'UNDER_23', 'SENIOR', 'MASTERS')"
             )
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -244,15 +251,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> CompetitionsSeasonStatusModel:
         """Create an instance of CompetitionsSeasonStatusModel from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return CompetitionsSeasonStatusModel.parse_obj(obj)
 
         _obj = CompetitionsSeasonStatusModel.parse_obj(
             {
                 "competition_id": obj.get("competitionId"),
                 "organization_id": obj.get("organizationId"),
                 "organization": CompetitionsSeasonStatusModelOrganization.from_dict(obj.get("organization"))
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/competitions_season_status_model_league.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/competitions_season_status_model_league.py`

 * *Files 6% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr, validator
 
 
 class CompetitionsSeasonStatusModelLeague(BaseModel):
     """
@@ -29,22 +28,26 @@
     """
 
     resource_type: Optional[StrictStr] = Field(None, alias="resourceType")
     id: Optional[StrictStr] = Field(None, description="Unique identifier for this resource")
     __properties = ["resourceType", "id"]
 
     @validator("resource_type")
-    def resource_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("leagues"):
+    def resource_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("leagues"):
             raise ValueError("must be one of enum values ('leagues')")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -64,14 +67,14 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> CompetitionsSeasonStatusModelLeague:
         """Create an instance of CompetitionsSeasonStatusModelLeague from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return CompetitionsSeasonStatusModelLeague.parse_obj(obj)
 
         _obj = CompetitionsSeasonStatusModelLeague.parse_obj(
             {"resource_type": obj.get("resourceType"), "id": obj.get("id")}
         )
         return _obj
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/competitions_season_status_model_organization.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/competitions_season_status_model_organization.py`

 * *Files 5% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr, validator
 
 
 class CompetitionsSeasonStatusModelOrganization(BaseModel):
     """
@@ -29,22 +28,26 @@
     """
 
     resource_type: Optional[StrictStr] = Field(None, alias="resourceType")
     id: Optional[StrictStr] = Field(None, description="Unique identifier for this resource")
     __properties = ["resourceType", "id"]
 
     @validator("resource_type")
-    def resource_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("organizations"):
+    def resource_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("organizations"):
             raise ValueError("must be one of enum values ('organizations')")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -64,14 +67,14 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> CompetitionsSeasonStatusModelOrganization:
         """Create an instance of CompetitionsSeasonStatusModelOrganization from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return CompetitionsSeasonStatusModelOrganization.parse_obj(obj)
 
         _obj = CompetitionsSeasonStatusModelOrganization.parse_obj(
             {"resource_type": obj.get("resourceType"), "id": obj.get("id")}
         )
         return _obj
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/competitions_season_status_response.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/competitions_season_status_response.py`

 * *Files 2% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import List, Optional
 
 from pydantic import BaseModel, conlist
 
 from atriumsports.datacore.openapi.models.competitions_season_status_model import CompetitionsSeasonStatusModel
 from atriumsports.datacore.openapi.models.included_data import IncludedData
 from atriumsports.datacore.openapi.models.response_links import ResponseLinks
@@ -36,14 +35,16 @@
     meta: Optional[ResponseMetaData] = None
     links: Optional[ResponseLinks] = None
     included: Optional[IncludedData] = None
     data: Optional[conlist(CompetitionsSeasonStatusModel)] = None
     __properties = ["meta", "links", "included", "data"]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -79,15 +80,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> CompetitionsSeasonStatusResponse:
         """Create an instance of CompetitionsSeasonStatusResponse from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return CompetitionsSeasonStatusResponse.parse_obj(obj)
 
         _obj = CompetitionsSeasonStatusResponse.parse_obj(
             {
                 "meta": ResponseMetaData.from_dict(obj.get("meta")) if obj.get("meta") is not None else None,
                 "links": ResponseLinks.from_dict(obj.get("links")) if obj.get("links") is not None else None,
                 "included": IncludedData.from_dict(obj.get("included")) if obj.get("included") is not None else None,
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/conduct_model.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/conduct_model.py`

 * *Files 4% similar despite different names*

```diff
@@ -14,16 +14,15 @@
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
 from datetime import date, datetime
-from inspect import getfullargspec
-from typing import List, Optional
+from typing import List, Optional, Union
 
 from pydantic import BaseModel, Field, StrictBool, StrictFloat, StrictInt, StrictStr, conlist, constr, validator
 
 from atriumsports.datacore.openapi.models.conduct_model_organization import ConductModelOrganization
 from atriumsports.datacore.openapi.models.conduct_penalty_result import ConductPenaltyResult
 from atriumsports.datacore.openapi.models.entities_model_entity_group import EntitiesModelEntityGroup
 from atriumsports.datacore.openapi.models.fixture_entities_model_entity import FixtureEntitiesModelEntity
@@ -94,15 +93,17 @@
     hearing_status: Optional[StrictStr] = Field(
         None, alias="hearingStatus", description="Conduct hearing status >- `FINALIZED` Finalized >- `PENDING` Pending "
     )
     life_sentence: Optional[StrictBool] = Field(
         None, alias="lifeSentence", description="Was the result of the conduct hearing a life sentence?"
     )
     penalty_results: Optional[conlist(ConductPenaltyResult)] = Field(None, alias="penaltyResults")
-    fine_amount: Optional[StrictFloat] = Field(None, alias="fineAmount", description="Conduct fine amount")
+    fine_amount: Optional[Union[StrictFloat, StrictInt]] = Field(
+        None, alias="fineAmount", description="Conduct fine amount"
+    )
     fine_currency: Optional[constr(strict=True, max_length=20)] = Field(
         None, alias="fineCurrency", description="Fine currency"
     )
     fine_status: Optional[StrictStr] = Field(
         None,
         alias="fineStatus",
         description="Conduct fine due status >- `CANCELLED` Cancelled >- `ISSUED` Issued >- `OTHER` Other >- `PAID` Paid >- `UNPAID` Unpaid ",
@@ -163,18 +164,20 @@
         "status",
         "externalId",
         "updated",
         "added",
     ]
 
     @validator("role")
-    def role_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in (
+    def role_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in (
             "COACH",
             "COACH_HEAD",
             "COACH_HEAD_INTERIM",
             "COACH_ASSISTANT",
             "COACH_ASSISTANT_HEAD",
             "COACH_ASSOCIATE_HEAD",
             "COACH_SC",
@@ -223,69 +226,81 @@
             "VIDEO_TECHNICIAN",
             "TRANSLATOR",
             "MEDIA_OFFICER",
         ):
             raise ValueError(
                 "must be one of enum values ('COACH', 'COACH_HEAD', 'COACH_HEAD_INTERIM', 'COACH_ASSISTANT', 'COACH_ASSISTANT_HEAD', 'COACH_ASSOCIATE_HEAD', 'COACH_SC', 'COACH_SENIOR', 'COACH_DEVELOPMENT', 'COACH_SPECIALIST', 'COACH_OTHER', 'CAPTAIN', 'CAPTAIN_VICE', 'DOCTOR', 'PHYSIOTHERAPIST', 'MEDICAL_STAFF', 'TRAINER', 'TRAINER_ASSISTANT', 'MATCH_OFFICIAL', 'COMMISSIONER', 'STATISTICIAN', 'SCOREKEEPER', 'SCOREKEEPER_ASSISTANT', 'TIMEKEEPER', 'SCORER', 'SCORER_ASSISTANT', 'TIMER', 'GROUNDSKEEPER', 'CEO', 'COMMITTEE', 'PRESIDENT', 'DIRECTOR', 'PRESIDENT_VICE', 'SECRETARY', 'TREASURER', 'MANAGER', 'GENERAL', 'OTHER', 'REFEREE', 'UMPIRE', 'REFEREE_ASSISTANT', 'REFEREE_RESERVE', 'REFEREE_ASSISTANT_RESERVE', 'CREW_CHIEF', 'UMPIRE_RESERVE', 'UMPIRE_VIDEO', 'JUDGE_SCORING', 'JUDGE_TIMING', 'TECHNICAL_OFFICIAL', 'VIDEO_TECHNICIAN', 'TRANSLATOR', 'MEDIA_OFFICER')"
             )
-        return v
+        return value
 
     @validator("conduct_type")
-    def conduct_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        for i in v:
+    def conduct_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        for i in value:
             if i not in (
                 "SWEARING",
                 "CORRUPTION",
                 "VIOLENT_CONDUCT",
                 "MATCH_FIXING",
                 "CITATION",
                 "UNSPORTSMANLIKE_CONDUCT",
                 "DOPING",
                 "CONCUSSION",
             ):
                 raise ValueError(
                     "each list item must be one of ('SWEARING', 'CORRUPTION', 'VIOLENT_CONDUCT', 'MATCH_FIXING', 'CITATION', 'UNSPORTSMANLIKE_CONDUCT', 'DOPING', 'CONCUSSION')"
                 )
-        return v
+        return value
 
     @validator("hearing_status")
-    def hearing_status_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("PENDING", "FINALIZED"):
+    def hearing_status_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("PENDING", "FINALIZED"):
             raise ValueError("must be one of enum values ('PENDING', 'FINALIZED')")
-        return v
+        return value
 
     @validator("fine_status")
-    def fine_status_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("ISSUED", "PAID", "UNPAID", "CANCELLED", "OTHER"):
+    def fine_status_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("ISSUED", "PAID", "UNPAID", "CANCELLED", "OTHER"):
             raise ValueError("must be one of enum values ('ISSUED', 'PAID', 'UNPAID', 'CANCELLED', 'OTHER')")
-        return v
+        return value
 
     @validator("status")
-    def status_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("ACTIVE", "INACTIVE", "PENDING", "COMPLETE", "CLOSED"):
+    def status_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("ACTIVE", "INACTIVE", "PENDING", "COMPLETE", "CLOSED"):
             raise ValueError("must be one of enum values ('ACTIVE', 'INACTIVE', 'PENDING', 'COMPLETE', 'CLOSED')")
-        return v
+        return value
 
     @validator("external_id")
-    def external_id_validate_regular_expression(cls, v):
-        if v is None:
-            return v
-        if not re.match(r"^[0-9A-Za-z\/_-]+$", v):
+    def external_id_validate_regular_expression(cls, value):
+        """Validates the regular expression"""
+        if value is None:
+            return value
+
+        if not re.match(r"^[0-9A-Za-z\/_-]+$", value):
             raise ValueError(r"must validate the regular expression /^[0-9A-Za-z\/_-]+$/")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -419,15 +434,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> ConductModel:
         """Create an instance of ConductModel from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return ConductModel.parse_obj(obj)
 
         _obj = ConductModel.parse_obj(
             {
                 "conduct_id": obj.get("conductId"),
                 "organization_id": obj.get("organizationId"),
                 "organization": ConductModelOrganization.from_dict(obj.get("organization"))
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/conduct_model_organization.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/conduct_model_organization.py`

 * *Files 5% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr, validator
 
 
 class ConductModelOrganization(BaseModel):
     """
@@ -29,22 +28,26 @@
     """
 
     resource_type: Optional[StrictStr] = Field(None, alias="resourceType")
     id: Optional[StrictStr] = Field(None, description="Unique identifier for this resource")
     __properties = ["resourceType", "id"]
 
     @validator("resource_type")
-    def resource_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("organizations"):
+    def resource_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("organizations"):
             raise ValueError("must be one of enum values ('organizations')")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -64,12 +67,12 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> ConductModelOrganization:
         """Create an instance of ConductModelOrganization from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return ConductModelOrganization.parse_obj(obj)
 
         _obj = ConductModelOrganization.parse_obj({"resource_type": obj.get("resourceType"), "id": obj.get("id")})
         return _obj
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/conduct_penalty_result.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/conduct_penalty_result.py`

 * *Files 7% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictInt, constr, validator
 
 
 class ConductPenaltyResult(BaseModel):
     """
@@ -31,22 +30,26 @@
     penalty_type: Optional[constr(strict=True, max_length=30)] = Field(
         None, alias="penaltyType", description="Penalty type"
     )
     penalty_value: Optional[StrictInt] = Field(None, alias="penaltyValue", description="Penalty value")
     __properties = ["penaltyType", "penaltyValue"]
 
     @validator("penalty_type")
-    def penalty_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("FINANCIAL", "WEEKS", "GAMES", "MONTHS", "YEARS"):
+    def penalty_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("FINANCIAL", "WEEKS", "GAMES", "MONTHS", "YEARS"):
             raise ValueError("must be one of enum values ('FINANCIAL', 'WEEKS', 'GAMES', 'MONTHS', 'YEARS')")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -76,14 +79,14 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> ConductPenaltyResult:
         """Create an instance of ConductPenaltyResult from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return ConductPenaltyResult.parse_obj(obj)
 
         _obj = ConductPenaltyResult.parse_obj(
             {"penalty_type": obj.get("penaltyType"), "penalty_value": obj.get("penaltyValue")}
         )
         return _obj
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/conduct_post_body.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/conduct_post_body.py`

 * *Files 7% similar despite different names*

```diff
@@ -14,16 +14,15 @@
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
 from datetime import date, datetime
-from inspect import getfullargspec
-from typing import List, Optional
+from typing import List, Optional, Union
 
 from pydantic import BaseModel, Field, StrictBool, StrictFloat, StrictInt, StrictStr, conlist, constr, validator
 
 from atriumsports.datacore.openapi.models.conduct_penalty_result import ConductPenaltyResult
 
 
 class ConductPostBody(BaseModel):
@@ -75,15 +74,17 @@
     hearing_status: Optional[StrictStr] = Field(
         None, alias="hearingStatus", description="Conduct hearing status >- `FINALIZED` Finalized >- `PENDING` Pending "
     )
     life_sentence: Optional[StrictBool] = Field(
         None, alias="lifeSentence", description="Was the result of the conduct hearing a life sentence?"
     )
     penalty_results: Optional[conlist(ConductPenaltyResult)] = Field(None, alias="penaltyResults")
-    fine_amount: Optional[StrictFloat] = Field(None, alias="fineAmount", description="Conduct fine amount")
+    fine_amount: Optional[Union[StrictFloat, StrictInt]] = Field(
+        None, alias="fineAmount", description="Conduct fine amount"
+    )
     fine_currency: Optional[constr(strict=True, max_length=20)] = Field(
         None, alias="fineCurrency", description="Fine currency"
     )
     fine_status: Optional[StrictStr] = Field(
         None,
         alias="fineStatus",
         description="Conduct fine due status >- `CANCELLED` Cancelled >- `ISSUED` Issued >- `OTHER` Other >- `PAID` Paid >- `UNPAID` Unpaid ",
@@ -131,18 +132,20 @@
         "dateSuspendedFrom",
         "dateFinePaidLocal",
         "status",
         "externalId",
     ]
 
     @validator("role")
-    def role_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in (
+    def role_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in (
             "COACH",
             "COACH_HEAD",
             "COACH_HEAD_INTERIM",
             "COACH_ASSISTANT",
             "COACH_ASSISTANT_HEAD",
             "COACH_ASSOCIATE_HEAD",
             "COACH_SC",
@@ -191,67 +194,78 @@
             "VIDEO_TECHNICIAN",
             "TRANSLATOR",
             "MEDIA_OFFICER",
         ):
             raise ValueError(
                 "must be one of enum values ('COACH', 'COACH_HEAD', 'COACH_HEAD_INTERIM', 'COACH_ASSISTANT', 'COACH_ASSISTANT_HEAD', 'COACH_ASSOCIATE_HEAD', 'COACH_SC', 'COACH_SENIOR', 'COACH_DEVELOPMENT', 'COACH_SPECIALIST', 'COACH_OTHER', 'CAPTAIN', 'CAPTAIN_VICE', 'DOCTOR', 'PHYSIOTHERAPIST', 'MEDICAL_STAFF', 'TRAINER', 'TRAINER_ASSISTANT', 'MATCH_OFFICIAL', 'COMMISSIONER', 'STATISTICIAN', 'SCOREKEEPER', 'SCOREKEEPER_ASSISTANT', 'TIMEKEEPER', 'SCORER', 'SCORER_ASSISTANT', 'TIMER', 'GROUNDSKEEPER', 'CEO', 'COMMITTEE', 'PRESIDENT', 'DIRECTOR', 'PRESIDENT_VICE', 'SECRETARY', 'TREASURER', 'MANAGER', 'GENERAL', 'OTHER', 'REFEREE', 'UMPIRE', 'REFEREE_ASSISTANT', 'REFEREE_RESERVE', 'REFEREE_ASSISTANT_RESERVE', 'CREW_CHIEF', 'UMPIRE_RESERVE', 'UMPIRE_VIDEO', 'JUDGE_SCORING', 'JUDGE_TIMING', 'TECHNICAL_OFFICIAL', 'VIDEO_TECHNICIAN', 'TRANSLATOR', 'MEDIA_OFFICER')"
             )
-        return v
+        return value
 
     @validator("conduct_type")
-    def conduct_type_validate_enum(cls, v):
-        for i in v:
+    def conduct_type_validate_enum(cls, value):
+        """Validates the enum"""
+        for i in value:
             if i not in (
                 "SWEARING",
                 "CORRUPTION",
                 "VIOLENT_CONDUCT",
                 "MATCH_FIXING",
                 "CITATION",
                 "UNSPORTSMANLIKE_CONDUCT",
                 "DOPING",
                 "CONCUSSION",
             ):
                 raise ValueError(
                     "each list item must be one of ('SWEARING', 'CORRUPTION', 'VIOLENT_CONDUCT', 'MATCH_FIXING', 'CITATION', 'UNSPORTSMANLIKE_CONDUCT', 'DOPING', 'CONCUSSION')"
                 )
-        return v
+        return value
 
     @validator("hearing_status")
-    def hearing_status_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("PENDING", "FINALIZED"):
+    def hearing_status_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("PENDING", "FINALIZED"):
             raise ValueError("must be one of enum values ('PENDING', 'FINALIZED')")
-        return v
+        return value
 
     @validator("fine_status")
-    def fine_status_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("ISSUED", "PAID", "UNPAID", "CANCELLED", "OTHER"):
+    def fine_status_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("ISSUED", "PAID", "UNPAID", "CANCELLED", "OTHER"):
             raise ValueError("must be one of enum values ('ISSUED', 'PAID', 'UNPAID', 'CANCELLED', 'OTHER')")
-        return v
+        return value
 
     @validator("status")
-    def status_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("ACTIVE", "INACTIVE", "PENDING", "COMPLETE", "CLOSED"):
+    def status_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("ACTIVE", "INACTIVE", "PENDING", "COMPLETE", "CLOSED"):
             raise ValueError("must be one of enum values ('ACTIVE', 'INACTIVE', 'PENDING', 'COMPLETE', 'CLOSED')")
-        return v
+        return value
 
     @validator("external_id")
-    def external_id_validate_regular_expression(cls, v):
-        if v is None:
-            return v
-        if not re.match(r"^[0-9A-Za-z\/_-]+$", v):
+    def external_id_validate_regular_expression(cls, value):
+        """Validates the regular expression"""
+        if value is None:
+            return value
+
+        if not re.match(r"^[0-9A-Za-z\/_-]+$", value):
             raise ValueError(r"must validate the regular expression /^[0-9A-Za-z\/_-]+$/")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -353,15 +367,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> ConductPostBody:
         """Create an instance of ConductPostBody from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return ConductPostBody.parse_obj(obj)
 
         _obj = ConductPostBody.parse_obj(
             {
                 "conduct_id": obj.get("conductId"),
                 "person_id": obj.get("personId"),
                 "entity_group_id": obj.get("entityGroupId"),
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/conduct_put_body.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/conduct_put_body.py`

 * *Files 6% similar despite different names*

```diff
@@ -14,16 +14,15 @@
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
 from datetime import date, datetime
-from inspect import getfullargspec
-from typing import List, Optional
+from typing import List, Optional, Union
 
 from pydantic import BaseModel, Field, StrictBool, StrictFloat, StrictInt, StrictStr, conlist, constr, validator
 
 from atriumsports.datacore.openapi.models.conduct_penalty_result import ConductPenaltyResult
 
 
 class ConductPutBody(BaseModel):
@@ -74,15 +73,17 @@
     hearing_status: Optional[StrictStr] = Field(
         None, alias="hearingStatus", description="Conduct hearing status >- `FINALIZED` Finalized >- `PENDING` Pending "
     )
     life_sentence: Optional[StrictBool] = Field(
         None, alias="lifeSentence", description="Was the result of the conduct hearing a life sentence?"
     )
     penalty_results: Optional[conlist(ConductPenaltyResult)] = Field(None, alias="penaltyResults")
-    fine_amount: Optional[StrictFloat] = Field(None, alias="fineAmount", description="Conduct fine amount")
+    fine_amount: Optional[Union[StrictFloat, StrictInt]] = Field(
+        None, alias="fineAmount", description="Conduct fine amount"
+    )
     fine_currency: Optional[constr(strict=True, max_length=20)] = Field(
         None, alias="fineCurrency", description="Fine currency"
     )
     fine_status: Optional[StrictStr] = Field(
         None,
         alias="fineStatus",
         description="Conduct fine due status >- `CANCELLED` Cancelled >- `ISSUED` Issued >- `OTHER` Other >- `PAID` Paid >- `UNPAID` Unpaid ",
@@ -129,18 +130,20 @@
         "dateSuspendedFrom",
         "dateFinePaidLocal",
         "status",
         "externalId",
     ]
 
     @validator("role")
-    def role_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in (
+    def role_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in (
             "COACH",
             "COACH_HEAD",
             "COACH_HEAD_INTERIM",
             "COACH_ASSISTANT",
             "COACH_ASSISTANT_HEAD",
             "COACH_ASSOCIATE_HEAD",
             "COACH_SC",
@@ -189,69 +192,81 @@
             "VIDEO_TECHNICIAN",
             "TRANSLATOR",
             "MEDIA_OFFICER",
         ):
             raise ValueError(
                 "must be one of enum values ('COACH', 'COACH_HEAD', 'COACH_HEAD_INTERIM', 'COACH_ASSISTANT', 'COACH_ASSISTANT_HEAD', 'COACH_ASSOCIATE_HEAD', 'COACH_SC', 'COACH_SENIOR', 'COACH_DEVELOPMENT', 'COACH_SPECIALIST', 'COACH_OTHER', 'CAPTAIN', 'CAPTAIN_VICE', 'DOCTOR', 'PHYSIOTHERAPIST', 'MEDICAL_STAFF', 'TRAINER', 'TRAINER_ASSISTANT', 'MATCH_OFFICIAL', 'COMMISSIONER', 'STATISTICIAN', 'SCOREKEEPER', 'SCOREKEEPER_ASSISTANT', 'TIMEKEEPER', 'SCORER', 'SCORER_ASSISTANT', 'TIMER', 'GROUNDSKEEPER', 'CEO', 'COMMITTEE', 'PRESIDENT', 'DIRECTOR', 'PRESIDENT_VICE', 'SECRETARY', 'TREASURER', 'MANAGER', 'GENERAL', 'OTHER', 'REFEREE', 'UMPIRE', 'REFEREE_ASSISTANT', 'REFEREE_RESERVE', 'REFEREE_ASSISTANT_RESERVE', 'CREW_CHIEF', 'UMPIRE_RESERVE', 'UMPIRE_VIDEO', 'JUDGE_SCORING', 'JUDGE_TIMING', 'TECHNICAL_OFFICIAL', 'VIDEO_TECHNICIAN', 'TRANSLATOR', 'MEDIA_OFFICER')"
             )
-        return v
+        return value
 
     @validator("conduct_type")
-    def conduct_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        for i in v:
+    def conduct_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        for i in value:
             if i not in (
                 "SWEARING",
                 "CORRUPTION",
                 "VIOLENT_CONDUCT",
                 "MATCH_FIXING",
                 "CITATION",
                 "UNSPORTSMANLIKE_CONDUCT",
                 "DOPING",
                 "CONCUSSION",
             ):
                 raise ValueError(
                     "each list item must be one of ('SWEARING', 'CORRUPTION', 'VIOLENT_CONDUCT', 'MATCH_FIXING', 'CITATION', 'UNSPORTSMANLIKE_CONDUCT', 'DOPING', 'CONCUSSION')"
                 )
-        return v
+        return value
 
     @validator("hearing_status")
-    def hearing_status_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("PENDING", "FINALIZED"):
+    def hearing_status_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("PENDING", "FINALIZED"):
             raise ValueError("must be one of enum values ('PENDING', 'FINALIZED')")
-        return v
+        return value
 
     @validator("fine_status")
-    def fine_status_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("ISSUED", "PAID", "UNPAID", "CANCELLED", "OTHER"):
+    def fine_status_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("ISSUED", "PAID", "UNPAID", "CANCELLED", "OTHER"):
             raise ValueError("must be one of enum values ('ISSUED', 'PAID', 'UNPAID', 'CANCELLED', 'OTHER')")
-        return v
+        return value
 
     @validator("status")
-    def status_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("ACTIVE", "INACTIVE", "PENDING", "COMPLETE", "CLOSED"):
+    def status_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("ACTIVE", "INACTIVE", "PENDING", "COMPLETE", "CLOSED"):
             raise ValueError("must be one of enum values ('ACTIVE', 'INACTIVE', 'PENDING', 'COMPLETE', 'CLOSED')")
-        return v
+        return value
 
     @validator("external_id")
-    def external_id_validate_regular_expression(cls, v):
-        if v is None:
-            return v
-        if not re.match(r"^[0-9A-Za-z\/_-]+$", v):
+    def external_id_validate_regular_expression(cls, value):
+        """Validates the regular expression"""
+        if value is None:
+            return value
+
+        if not re.match(r"^[0-9A-Za-z\/_-]+$", value):
             raise ValueError(r"must validate the regular expression /^[0-9A-Za-z\/_-]+$/")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -353,15 +368,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> ConductPutBody:
         """Create an instance of ConductPutBody from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return ConductPutBody.parse_obj(obj)
 
         _obj = ConductPutBody.parse_obj(
             {
                 "person_id": obj.get("personId"),
                 "entity_group_id": obj.get("entityGroupId"),
                 "entity_id": obj.get("entityId"),
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/conduct_response.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/conduct_response.py`

 * *Files 4% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import List, Optional
 
 from pydantic import BaseModel, conlist
 
 from atriumsports.datacore.openapi.models.conduct_model import ConductModel
 from atriumsports.datacore.openapi.models.included_data import IncludedData
 from atriumsports.datacore.openapi.models.response_links import ResponseLinks
@@ -36,14 +35,16 @@
     meta: Optional[ResponseMetaData] = None
     links: Optional[ResponseLinks] = None
     included: Optional[IncludedData] = None
     data: Optional[conlist(ConductModel)] = None
     __properties = ["meta", "links", "included", "data"]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -79,15 +80,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> ConductResponse:
         """Create an instance of ConductResponse from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return ConductResponse.parse_obj(obj)
 
         _obj = ConductResponse.parse_obj(
             {
                 "meta": ResponseMetaData.from_dict(obj.get("meta")) if obj.get("meta") is not None else None,
                 "links": ResponseLinks.from_dict(obj.get("links")) if obj.get("links") is not None else None,
                 "included": IncludedData.from_dict(obj.get("included")) if obj.get("included") is not None else None,
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/conference_post_body.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/conference_post_body.py`

 * *Files 2% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr, constr, validator
 
 from atriumsports.datacore.openapi.models.social_media import SocialMedia
 
 
@@ -64,22 +63,26 @@
         "abbreviationLatin",
         "nameLatin",
         "social",
         "externalId",
     ]
 
     @validator("external_id")
-    def external_id_validate_regular_expression(cls, v):
-        if v is None:
-            return v
-        if not re.match(r"^[0-9A-Za-z\/_-]+$", v):
+    def external_id_validate_regular_expression(cls, value):
+        """Validates the regular expression"""
+        if value is None:
+            return value
+
+        if not re.match(r"^[0-9A-Za-z\/_-]+$", value):
             raise ValueError(r"must validate the regular expression /^[0-9A-Za-z\/_-]+$/")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -132,15 +135,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> ConferencePostBody:
         """Create an instance of ConferencePostBody from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return ConferencePostBody.parse_obj(obj)
 
         _obj = ConferencePostBody.parse_obj(
             {
                 "conference_id": obj.get("conferenceId"),
                 "abbreviation_local": obj.get("abbreviationLocal"),
                 "name_local": obj.get("nameLocal"),
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/conference_put_body.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/conference_put_body.py`

 * *Files 6% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, constr, validator
 
 from atriumsports.datacore.openapi.models.social_media import SocialMedia
 
 
@@ -53,22 +52,26 @@
     social: Optional[SocialMedia] = None
     external_id: Optional[constr(strict=True, max_length=150)] = Field(
         None, alias="externalId", description="The Id of the data as set by the provider of the data"
     )
     __properties = ["abbreviationLocal", "nameLocal", "abbreviationLatin", "nameLatin", "social", "externalId"]
 
     @validator("external_id")
-    def external_id_validate_regular_expression(cls, v):
-        if v is None:
-            return v
-        if not re.match(r"^[0-9A-Za-z\/_-]+$", v):
+    def external_id_validate_regular_expression(cls, value):
+        """Validates the regular expression"""
+        if value is None:
+            return value
+
+        if not re.match(r"^[0-9A-Za-z\/_-]+$", value):
             raise ValueError(r"must validate the regular expression /^[0-9A-Za-z\/_-]+$/")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -116,15 +119,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> ConferencePutBody:
         """Create an instance of ConferencePutBody from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return ConferencePutBody.parse_obj(obj)
 
         _obj = ConferencePutBody.parse_obj(
             {
                 "abbreviation_local": obj.get("abbreviationLocal"),
                 "name_local": obj.get("nameLocal"),
                 "abbreviation_latin": obj.get("abbreviationLatin"),
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/conferences_model.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/conferences_model.py`

 * *Files 2% similar despite different names*

```diff
@@ -14,15 +14,14 @@
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
 from datetime import datetime
-from inspect import getfullargspec
 from typing import List, Optional
 
 from pydantic import BaseModel, Field, StrictStr, conlist, constr, validator
 
 from atriumsports.datacore.openapi.models.conferences_model_organization import ConferencesModelOrganization
 from atriumsports.datacore.openapi.models.images_model import ImagesModel
 from atriumsports.datacore.openapi.models.social_media import SocialMedia
@@ -79,22 +78,26 @@
         "externalId",
         "updated",
         "added",
         "images",
     ]
 
     @validator("external_id")
-    def external_id_validate_regular_expression(cls, v):
-        if v is None:
-            return v
-        if not re.match(r"^[0-9A-Za-z\/_-]+$", v):
+    def external_id_validate_regular_expression(cls, value):
+        """Validates the regular expression"""
+        if value is None:
+            return value
+
+        if not re.match(r"^[0-9A-Za-z\/_-]+$", value):
             raise ValueError(r"must validate the regular expression /^[0-9A-Za-z\/_-]+$/")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -165,15 +168,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> ConferencesModel:
         """Create an instance of ConferencesModel from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return ConferencesModel.parse_obj(obj)
 
         _obj = ConferencesModel.parse_obj(
             {
                 "conference_id": obj.get("conferenceId"),
                 "organization_id": obj.get("organizationId"),
                 "organization": ConferencesModelOrganization.from_dict(obj.get("organization"))
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/conferences_model_organization.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/conferences_model_organization.py`

 * *Files 8% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr, validator
 
 
 class ConferencesModelOrganization(BaseModel):
     """
@@ -29,22 +28,26 @@
     """
 
     resource_type: Optional[StrictStr] = Field(None, alias="resourceType")
     id: Optional[StrictStr] = Field(None, description="Unique identifier for this resource")
     __properties = ["resourceType", "id"]
 
     @validator("resource_type")
-    def resource_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("organizations"):
+    def resource_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("organizations"):
             raise ValueError("must be one of enum values ('organizations')")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -64,12 +67,12 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> ConferencesModelOrganization:
         """Create an instance of ConferencesModelOrganization from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return ConferencesModelOrganization.parse_obj(obj)
 
         _obj = ConferencesModelOrganization.parse_obj({"resource_type": obj.get("resourceType"), "id": obj.get("id")})
         return _obj
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/conferences_response.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/venues_response.py`

 * *Files 6% similar despite different names*

```diff
@@ -13,51 +13,52 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import List, Optional
 
 from pydantic import BaseModel, conlist
 
-from atriumsports.datacore.openapi.models.conferences_model import ConferencesModel
 from atriumsports.datacore.openapi.models.included_data import IncludedData
 from atriumsports.datacore.openapi.models.response_links import ResponseLinks
 from atriumsports.datacore.openapi.models.response_meta_data import ResponseMetaData
+from atriumsports.datacore.openapi.models.venues_model import VenuesModel
 
 
-class ConferencesResponse(BaseModel):
+class VenuesResponse(BaseModel):
     """
-    ConferencesResponse
+    VenuesResponse
     """
 
     meta: Optional[ResponseMetaData] = None
     links: Optional[ResponseLinks] = None
     included: Optional[IncludedData] = None
-    data: Optional[conlist(ConferencesModel)] = None
+    data: Optional[conlist(VenuesModel)] = None
     __properties = ["meta", "links", "included", "data"]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> ConferencesResponse:
-        """Create an instance of ConferencesResponse from a JSON string"""
+    def from_json(cls, json_str: str) -> VenuesResponse:
+        """Create an instance of VenuesResponse from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
     def to_dict(self):
         """Returns the dictionary representation of the model using alias"""
         _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)
         # override the default output from pydantic by calling `to_dict()` of meta
         if self.meta:
@@ -74,26 +75,26 @@
             for _item in self.data:
                 if _item:
                     _items.append(_item.to_dict())
             _dict["data"] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> ConferencesResponse:
-        """Create an instance of ConferencesResponse from a dict"""
+    def from_dict(cls, obj: dict) -> VenuesResponse:
+        """Create an instance of VenuesResponse from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
-            return ConferencesResponse.parse_obj(obj)
+        if not isinstance(obj, dict):
+            return VenuesResponse.parse_obj(obj)
 
-        _obj = ConferencesResponse.parse_obj(
+        _obj = VenuesResponse.parse_obj(
             {
                 "meta": ResponseMetaData.from_dict(obj.get("meta")) if obj.get("meta") is not None else None,
                 "links": ResponseLinks.from_dict(obj.get("links")) if obj.get("links") is not None else None,
                 "included": IncludedData.from_dict(obj.get("included")) if obj.get("included") is not None else None,
-                "data": [ConferencesModel.from_dict(_item) for _item in obj.get("data")]
+                "data": [VenuesModel.from_dict(_item) for _item in obj.get("data")]
                 if obj.get("data") is not None
                 else None,
             }
         )
         return _obj
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/contact_details.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/contact_details.py`

 * *Files 8% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr
 
 
 class ContactDetails(BaseModel):
     """
@@ -31,14 +30,16 @@
     fax: Optional[StrictStr] = Field(None, description="Fax number")
     phone: Optional[StrictStr] = Field(None, description="Primary phone number")
     phone_secondary: Optional[StrictStr] = Field(None, alias="phoneSecondary", description="Secondary phone number")
     email: Optional[StrictStr] = Field(None, description="Primary email address")
     __properties = ["fax", "phone", "phoneSecondary", "email"]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -78,15 +79,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> ContactDetails:
         """Create an instance of ContactDetails from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return ContactDetails.parse_obj(obj)
 
         _obj = ContactDetails.parse_obj(
             {
                 "fax": obj.get("fax"),
                 "phone": obj.get("phone"),
                 "phone_secondary": obj.get("phoneSecondary"),
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/division_post_body.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/division_post_body.py`

 * *Files 3% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr, constr, validator
 
 from atriumsports.datacore.openapi.models.social_media import SocialMedia
 
 
@@ -68,22 +67,26 @@
         "abbreviationLatin",
         "nameLatin",
         "social",
         "externalId",
     ]
 
     @validator("external_id")
-    def external_id_validate_regular_expression(cls, v):
-        if v is None:
-            return v
-        if not re.match(r"^[0-9A-Za-z\/_-]+$", v):
+    def external_id_validate_regular_expression(cls, value):
+        """Validates the regular expression"""
+        if value is None:
+            return value
+
+        if not re.match(r"^[0-9A-Za-z\/_-]+$", value):
             raise ValueError(r"must validate the regular expression /^[0-9A-Za-z\/_-]+$/")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -141,15 +144,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> DivisionPostBody:
         """Create an instance of DivisionPostBody from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return DivisionPostBody.parse_obj(obj)
 
         _obj = DivisionPostBody.parse_obj(
             {
                 "division_id": obj.get("divisionId"),
                 "conference_id": obj.get("conferenceId"),
                 "abbreviation_local": obj.get("abbreviationLocal"),
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/division_put_body.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/division_put_body.py`

 * *Files 3% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr, constr, validator
 
 from atriumsports.datacore.openapi.models.social_media import SocialMedia
 
 
@@ -64,22 +63,26 @@
         "abbreviationLatin",
         "nameLatin",
         "social",
         "externalId",
     ]
 
     @validator("external_id")
-    def external_id_validate_regular_expression(cls, v):
-        if v is None:
-            return v
-        if not re.match(r"^[0-9A-Za-z\/_-]+$", v):
+    def external_id_validate_regular_expression(cls, value):
+        """Validates the regular expression"""
+        if value is None:
+            return value
+
+        if not re.match(r"^[0-9A-Za-z\/_-]+$", value):
             raise ValueError(r"must validate the regular expression /^[0-9A-Za-z\/_-]+$/")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -132,15 +135,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> DivisionPutBody:
         """Create an instance of DivisionPutBody from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return DivisionPutBody.parse_obj(obj)
 
         _obj = DivisionPutBody.parse_obj(
             {
                 "conference_id": obj.get("conferenceId"),
                 "abbreviation_local": obj.get("abbreviationLocal"),
                 "name_local": obj.get("nameLocal"),
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/divisions_model.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/divisions_model.py`

 * *Files 2% similar despite different names*

```diff
@@ -14,15 +14,14 @@
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
 from datetime import datetime
-from inspect import getfullargspec
 from typing import List, Optional
 
 from pydantic import BaseModel, Field, StrictStr, conlist, constr, validator
 
 from atriumsports.datacore.openapi.models.divisions_model_organization import DivisionsModelOrganization
 from atriumsports.datacore.openapi.models.fixture_entities_model_conference import FixtureEntitiesModelConference
 from atriumsports.datacore.openapi.models.images_model import ImagesModel
@@ -86,22 +85,26 @@
         "externalId",
         "updated",
         "added",
         "images",
     ]
 
     @validator("external_id")
-    def external_id_validate_regular_expression(cls, v):
-        if v is None:
-            return v
-        if not re.match(r"^[0-9A-Za-z\/_-]+$", v):
+    def external_id_validate_regular_expression(cls, value):
+        """Validates the regular expression"""
+        if value is None:
+            return value
+
+        if not re.match(r"^[0-9A-Za-z\/_-]+$", value):
             raise ValueError(r"must validate the regular expression /^[0-9A-Za-z\/_-]+$/")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -180,15 +183,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> DivisionsModel:
         """Create an instance of DivisionsModel from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return DivisionsModel.parse_obj(obj)
 
         _obj = DivisionsModel.parse_obj(
             {
                 "division_id": obj.get("divisionId"),
                 "organization_id": obj.get("organizationId"),
                 "organization": DivisionsModelOrganization.from_dict(obj.get("organization"))
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/divisions_model_organization.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/divisions_model_organization.py`

 * *Files 7% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr, validator
 
 
 class DivisionsModelOrganization(BaseModel):
     """
@@ -29,22 +28,26 @@
     """
 
     resource_type: Optional[StrictStr] = Field(None, alias="resourceType")
     id: Optional[StrictStr] = Field(None, description="Unique identifier for this resource")
     __properties = ["resourceType", "id"]
 
     @validator("resource_type")
-    def resource_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("organizations"):
+    def resource_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("organizations"):
             raise ValueError("must be one of enum values ('organizations')")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -64,12 +67,12 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> DivisionsModelOrganization:
         """Create an instance of DivisionsModelOrganization from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return DivisionsModelOrganization.parse_obj(obj)
 
         _obj = DivisionsModelOrganization.parse_obj({"resource_type": obj.get("resourceType"), "id": obj.get("id")})
         return _obj
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/divisions_response.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/divisions_response.py`

 * *Files 2% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import List, Optional
 
 from pydantic import BaseModel, conlist
 
 from atriumsports.datacore.openapi.models.divisions_model import DivisionsModel
 from atriumsports.datacore.openapi.models.included_data import IncludedData
 from atriumsports.datacore.openapi.models.response_links import ResponseLinks
@@ -36,14 +35,16 @@
     meta: Optional[ResponseMetaData] = None
     links: Optional[ResponseLinks] = None
     included: Optional[IncludedData] = None
     data: Optional[conlist(DivisionsModel)] = None
     __properties = ["meta", "links", "included", "data"]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -79,15 +80,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> DivisionsResponse:
         """Create an instance of DivisionsResponse from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return DivisionsResponse.parse_obj(obj)
 
         _obj = DivisionsResponse.parse_obj(
             {
                 "meta": ResponseMetaData.from_dict(obj.get("meta")) if obj.get("meta") is not None else None,
                 "links": ResponseLinks.from_dict(obj.get("links")) if obj.get("links") is not None else None,
                 "included": IncludedData.from_dict(obj.get("included")) if obj.get("included") is not None else None,
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/entities_model.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/entities_model.py`

 * *Files 3% similar despite different names*

```diff
@@ -14,15 +14,14 @@
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
 from datetime import datetime
-from inspect import getfullargspec
 from typing import List, Optional
 
 from pydantic import BaseModel, Field, StrictStr, conlist, constr, validator
 
 from atriumsports.datacore.openapi.models.contact_details import ContactDetails
 from atriumsports.datacore.openapi.models.entities_model_entity_group import EntitiesModelEntityGroup
 from atriumsports.datacore.openapi.models.entities_model_organization import EntitiesModelOrganization
@@ -138,34 +137,40 @@
         "updated",
         "added",
         "defaultVenueId",
         "images",
     ]
 
     @validator("status")
-    def status_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("ACTIVE", "INACTIVE", "PENDING"):
+    def status_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("ACTIVE", "INACTIVE", "PENDING"):
             raise ValueError("must be one of enum values ('ACTIVE', 'INACTIVE', 'PENDING')")
-        return v
+        return value
 
     @validator("external_id")
-    def external_id_validate_regular_expression(cls, v):
-        if v is None:
-            return v
-        if not re.match(r"^[0-9A-Za-z\/_-]+$", v):
+    def external_id_validate_regular_expression(cls, value):
+        """Validates the regular expression"""
+        if value is None:
+            return value
+
+        if not re.match(r"^[0-9A-Za-z\/_-]+$", value):
             raise ValueError(r"must validate the regular expression /^[0-9A-Za-z\/_-]+$/")
-        return v
+        return value
 
     @validator("age_group")
-    def age_group_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in (
+    def age_group_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in (
             "JUNIOR",
             "YOUTH",
             "UNDER_10",
             "UNDER_11",
             "UNDER_12",
             "UNDER_13",
             "UNDER_14",
@@ -180,29 +185,33 @@
             "UNDER_23",
             "SENIOR",
             "MASTERS",
         ):
             raise ValueError(
                 "must be one of enum values ('JUNIOR', 'YOUTH', 'UNDER_10', 'UNDER_11', 'UNDER_12', 'UNDER_13', 'UNDER_14', 'UNDER_15', 'UNDER_16', 'UNDER_17', 'UNDER_18', 'UNDER_19', 'UNDER_20', 'UNDER_21', 'UNDER_22', 'UNDER_23', 'SENIOR', 'MASTERS')"
             )
-        return v
+        return value
 
     @validator("gender")
-    def gender_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("FEMALE", "MALE", "MIXED", "UNKNOWN"):
+    def gender_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("FEMALE", "MALE", "MIXED", "UNKNOWN"):
             raise ValueError("must be one of enum values ('FEMALE', 'MALE', 'MIXED', 'UNKNOWN')")
-        return v
+        return value
 
     @validator("standard")
-    def standard_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in (
+    def standard_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in (
             "ELITE",
             "FRIENDLY",
             "GRASS_ROOT",
             "INTERNATIONAL",
             "NONCONTINENTAL_CHAMPIONSHIP",
             "OLYMPIC",
             "REGION",
@@ -210,17 +219,19 @@
             "TIER3",
             "WORLD_CHAMPIONSHIP",
             "ZONE_CHAMPIONSHIP",
         ):
             raise ValueError(
                 "must be one of enum values ('ELITE', 'FRIENDLY', 'GRASS_ROOT', 'INTERNATIONAL', 'NONCONTINENTAL_CHAMPIONSHIP', 'OLYMPIC', 'REGION', 'TIER2', 'TIER3', 'WORLD_CHAMPIONSHIP', 'ZONE_CHAMPIONSHIP')"
             )
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -351,15 +362,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> EntitiesModel:
         """Create an instance of EntitiesModel from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return EntitiesModel.parse_obj(obj)
 
         _obj = EntitiesModel.parse_obj(
             {
                 "entity_id": obj.get("entityId"),
                 "organization_id": obj.get("organizationId"),
                 "organization": EntitiesModelOrganization.from_dict(obj.get("organization"))
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/entities_model_entity_group.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/entities_model_entity_group.py`

 * *Files 8% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr, validator
 
 
 class EntitiesModelEntityGroup(BaseModel):
     """
@@ -29,22 +28,26 @@
     """
 
     resource_type: Optional[StrictStr] = Field(None, alias="resourceType")
     id: Optional[StrictStr] = Field(None, description="Unique identifier for this resource")
     __properties = ["resourceType", "id"]
 
     @validator("resource_type")
-    def resource_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("entity_groups"):
+    def resource_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("entity_groups"):
             raise ValueError("must be one of enum values ('entity_groups')")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -64,12 +67,12 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> EntitiesModelEntityGroup:
         """Create an instance of EntitiesModelEntityGroup from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return EntitiesModelEntityGroup.parse_obj(obj)
 
         _obj = EntitiesModelEntityGroup.parse_obj({"resource_type": obj.get("resourceType"), "id": obj.get("id")})
         return _obj
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/entities_model_organization.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/entities_model_organization.py`

 * *Files 8% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr, validator
 
 
 class EntitiesModelOrganization(BaseModel):
     """
@@ -29,22 +28,26 @@
     """
 
     resource_type: Optional[StrictStr] = Field(None, alias="resourceType")
     id: Optional[StrictStr] = Field(None, description="Unique identifier for this resource")
     __properties = ["resourceType", "id"]
 
     @validator("resource_type")
-    def resource_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("organizations"):
+    def resource_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("organizations"):
             raise ValueError("must be one of enum values ('organizations')")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -64,12 +67,12 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> EntitiesModelOrganization:
         """Create an instance of EntitiesModelOrganization from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return EntitiesModelOrganization.parse_obj(obj)
 
         _obj = EntitiesModelOrganization.parse_obj({"resource_type": obj.get("resourceType"), "id": obj.get("id")})
         return _obj
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/entities_response.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/entities_response.py`

 * *Files 3% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import List, Optional
 
 from pydantic import BaseModel, conlist
 
 from atriumsports.datacore.openapi.models.entities_model import EntitiesModel
 from atriumsports.datacore.openapi.models.included_data import IncludedData
 from atriumsports.datacore.openapi.models.response_links import ResponseLinks
@@ -36,14 +35,16 @@
     meta: Optional[ResponseMetaData] = None
     links: Optional[ResponseLinks] = None
     included: Optional[IncludedData] = None
     data: Optional[conlist(EntitiesModel)] = None
     __properties = ["meta", "links", "included", "data"]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -79,15 +80,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> EntitiesResponse:
         """Create an instance of EntitiesResponse from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return EntitiesResponse.parse_obj(obj)
 
         _obj = EntitiesResponse.parse_obj(
             {
                 "meta": ResponseMetaData.from_dict(obj.get("meta")) if obj.get("meta") is not None else None,
                 "links": ResponseLinks.from_dict(obj.get("links")) if obj.get("links") is not None else None,
                 "included": IncludedData.from_dict(obj.get("included")) if obj.get("included") is not None else None,
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/entity_additional_details.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/entity_additional_details.py`

 * *Files 8% similar despite different names*

```diff
@@ -13,30 +13,31 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
-from typing import Optional
+from typing import Optional, Union
 
-from pydantic import BaseModel, Field, StrictFloat
+from pydantic import BaseModel, Field, StrictFloat, StrictInt
 
 
 class EntityAdditionalDetails(BaseModel):
     """
     Additional detail fields
     """
 
-    founded: Optional[StrictFloat] = Field(None, description="Year Founded")
-    squad_value: Optional[StrictFloat] = Field(None, alias="squadValue", description="Value of Squad")
+    founded: Optional[Union[StrictFloat, StrictInt]] = Field(None, description="Year Founded")
+    squad_value: Optional[Union[StrictFloat, StrictInt]] = Field(None, alias="squadValue", description="Value of Squad")
     __properties = ["founded", "squadValue"]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -66,12 +67,12 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> EntityAdditionalDetails:
         """Create an instance of EntityAdditionalDetails from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return EntityAdditionalDetails.parse_obj(obj)
 
         _obj = EntityAdditionalDetails.parse_obj({"founded": obj.get("founded"), "squad_value": obj.get("squadValue")})
         return _obj
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/entity_address.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/entity_address.py`

 * *Files 3% similar despite different names*

```diff
@@ -13,18 +13,17 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
-from typing import Optional
+from typing import Optional, Union
 
-from pydantic import BaseModel, Field, StrictFloat, StrictStr, constr
+from pydantic import BaseModel, Field, StrictFloat, StrictInt, StrictStr, constr
 
 
 class EntityAddress(BaseModel):
     """
     Street Address for the entity
     """
 
@@ -35,29 +34,31 @@
     state: Optional[StrictStr] = Field(None, description="The state of the address")
     postal_code: Optional[StrictStr] = Field(None, alias="postalCode", description="The postal code for the address")
     country_code: Optional[constr(strict=True, max_length=3, min_length=3)] = Field(
         None,
         alias="countryCode",
         description="ISO Country code of the address.  We recommend you use ISO-3166-1:alpha3 (upper case) values where available.",
     )
-    longitude: Optional[StrictFloat] = None
-    latitude: Optional[StrictFloat] = None
+    longitude: Optional[Union[StrictFloat, StrictInt]] = None
+    latitude: Optional[Union[StrictFloat, StrictInt]] = None
     __properties = [
         "address1",
         "address2",
         "address3",
         "city",
         "state",
         "postalCode",
         "countryCode",
         "longitude",
         "latitude",
     ]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -122,15 +123,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> EntityAddress:
         """Create an instance of EntityAddress from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return EntityAddress.parse_obj(obj)
 
         _obj = EntityAddress.parse_obj(
             {
                 "address1": obj.get("address1"),
                 "address2": obj.get("address2"),
                 "address3": obj.get("address3"),
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/entity_group_address.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/entity_group_address.py`

 * *Files 2% similar despite different names*

```diff
@@ -13,18 +13,17 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
-from typing import Optional
+from typing import Optional, Union
 
-from pydantic import BaseModel, Field, StrictFloat, StrictStr, constr
+from pydantic import BaseModel, Field, StrictFloat, StrictInt, StrictStr, constr
 
 
 class EntityGroupAddress(BaseModel):
     """
     Street Address for the entity group
     """
 
@@ -35,29 +34,31 @@
     state: Optional[StrictStr] = Field(None, description="The state of the address")
     postal_code: Optional[StrictStr] = Field(None, alias="postalCode", description="The postal code for the address")
     country_code: Optional[constr(strict=True, max_length=3, min_length=3)] = Field(
         None,
         alias="countryCode",
         description="ISO Country code of the address.  We recommend you use ISO-3166-1:alpha3 (upper case) values where available.",
     )
-    longitude: Optional[StrictFloat] = None
-    latitude: Optional[StrictFloat] = None
+    longitude: Optional[Union[StrictFloat, StrictInt]] = None
+    latitude: Optional[Union[StrictFloat, StrictInt]] = None
     __properties = [
         "address1",
         "address2",
         "address3",
         "city",
         "state",
         "postalCode",
         "countryCode",
         "longitude",
         "latitude",
     ]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -122,15 +123,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> EntityGroupAddress:
         """Create an instance of EntityGroupAddress from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return EntityGroupAddress.parse_obj(obj)
 
         _obj = EntityGroupAddress.parse_obj(
             {
                 "address1": obj.get("address1"),
                 "address2": obj.get("address2"),
                 "address3": obj.get("address3"),
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/entity_group_historical_name.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/entity_group_historical_name.py`

 * *Files 2% similar despite different names*

```diff
@@ -14,15 +14,14 @@
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
 from datetime import date
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr
 
 
 class EntityGroupHistoricalName(BaseModel):
     """
@@ -51,14 +50,16 @@
         "nameFullLatin",
         "nameShortLocal",
         "nameShortLatin",
         "namePlaceLocal",
     ]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -113,15 +114,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> EntityGroupHistoricalName:
         """Create an instance of EntityGroupHistoricalName from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return EntityGroupHistoricalName.parse_obj(obj)
 
         _obj = EntityGroupHistoricalName.parse_obj(
             {
                 "date_start": obj.get("dateStart"),
                 "date_end": obj.get("dateEnd"),
                 "name_full_local": obj.get("nameFullLocal"),
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/entity_group_post_body.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/entity_group_post_body.py`

 * *Files 2% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import List, Optional
 
 from pydantic import BaseModel, Field, StrictStr, conlist, constr, validator
 
 from atriumsports.datacore.openapi.models.contact_details import ContactDetails
 from atriumsports.datacore.openapi.models.entity_additional_details import EntityAdditionalDetails
 from atriumsports.datacore.openapi.models.entity_group_address import EntityGroupAddress
@@ -100,28 +99,33 @@
         "colors",
         "historicalNames",
         "externalId",
         "defaultVenueId",
     ]
 
     @validator("status")
-    def status_validate_enum(cls, v):
-        if v not in ("ACTIVE", "INACTIVE", "PENDING"):
+    def status_validate_enum(cls, value):
+        """Validates the enum"""
+        if value not in ("ACTIVE", "INACTIVE", "PENDING"):
             raise ValueError("must be one of enum values ('ACTIVE', 'INACTIVE', 'PENDING')")
-        return v
+        return value
 
     @validator("external_id")
-    def external_id_validate_regular_expression(cls, v):
-        if v is None:
-            return v
-        if not re.match(r"^[0-9A-Za-z\/_-]+$", v):
+    def external_id_validate_regular_expression(cls, value):
+        """Validates the regular expression"""
+        if value is None:
+            return value
+
+        if not re.match(r"^[0-9A-Za-z\/_-]+$", value):
             raise ValueError(r"must validate the regular expression /^[0-9A-Za-z\/_-]+$/")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -221,15 +225,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> EntityGroupPostBody:
         """Create an instance of EntityGroupPostBody from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return EntityGroupPostBody.parse_obj(obj)
 
         _obj = EntityGroupPostBody.parse_obj(
             {
                 "entity_group_id": obj.get("entityGroupId"),
                 "international_reference": obj.get("internationalReference"),
                 "status": obj.get("status"),
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/entity_group_post_body_additional_names.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/entity_group_post_body_additional_names.py`

 * *Files 5% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, constr
 
 
 class EntityGroupPostBodyAdditionalNames(BaseModel):
     """
@@ -47,14 +46,16 @@
         None,
         alias="namePlaceLatin",
         description="The name of the place associated with the entity group using [latin](#section/Introduction/Character-Sets-and-Names) characters",
     )
     __properties = ["nameShortLocal", "namePlaceLocal", "nameShortLatin", "namePlaceLatin"]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -94,15 +95,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> EntityGroupPostBodyAdditionalNames:
         """Create an instance of EntityGroupPostBodyAdditionalNames from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return EntityGroupPostBodyAdditionalNames.parse_obj(obj)
 
         _obj = EntityGroupPostBodyAdditionalNames.parse_obj(
             {
                 "name_short_local": obj.get("nameShortLocal"),
                 "name_place_local": obj.get("namePlaceLocal"),
                 "name_short_latin": obj.get("nameShortLatin"),
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/entity_group_post_body_colors.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/entity_group_post_body_colors.py`

 * *Files 3% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, constr
 
 
 class EntityGroupPostBodyColors(BaseModel):
     """
@@ -39,14 +38,16 @@
     tertiary: Optional[constr(strict=True, max_length=6, min_length=6)] = Field(
         None,
         description="Tertiary color of the entity group.  Colors are a hexadecimal string `RRGGBB` with `RR`(red), `GG`(green) and `BB`(blue) representing the components of the colour. ",
     )
     __properties = ["primary", "secondary", "tertiary"]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -81,14 +82,14 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> EntityGroupPostBodyColors:
         """Create an instance of EntityGroupPostBodyColors from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return EntityGroupPostBodyColors.parse_obj(obj)
 
         _obj = EntityGroupPostBodyColors.parse_obj(
             {"primary": obj.get("primary"), "secondary": obj.get("secondary"), "tertiary": obj.get("tertiary")}
         )
         return _obj
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/entity_group_put_body.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/entity_group_put_body.py`

 * *Files 2% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import List, Optional
 
 from pydantic import BaseModel, Field, StrictStr, conlist, constr, validator
 
 from atriumsports.datacore.openapi.models.contact_details import ContactDetails
 from atriumsports.datacore.openapi.models.entity_additional_details import EntityAdditionalDetails
 from atriumsports.datacore.openapi.models.entity_group_address import EntityGroupAddress
@@ -96,30 +95,36 @@
         "colors",
         "historicalNames",
         "externalId",
         "defaultVenueId",
     ]
 
     @validator("status")
-    def status_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("ACTIVE", "INACTIVE", "PENDING"):
+    def status_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("ACTIVE", "INACTIVE", "PENDING"):
             raise ValueError("must be one of enum values ('ACTIVE', 'INACTIVE', 'PENDING')")
-        return v
+        return value
 
     @validator("external_id")
-    def external_id_validate_regular_expression(cls, v):
-        if v is None:
-            return v
-        if not re.match(r"^[0-9A-Za-z\/_-]+$", v):
+    def external_id_validate_regular_expression(cls, value):
+        """Validates the regular expression"""
+        if value is None:
+            return value
+
+        if not re.match(r"^[0-9A-Za-z\/_-]+$", value):
             raise ValueError(r"must validate the regular expression /^[0-9A-Za-z\/_-]+$/")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -219,15 +224,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> EntityGroupPutBody:
         """Create an instance of EntityGroupPutBody from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return EntityGroupPutBody.parse_obj(obj)
 
         _obj = EntityGroupPutBody.parse_obj(
             {
                 "international_reference": obj.get("internationalReference"),
                 "status": obj.get("status"),
                 "name_full_local": obj.get("nameFullLocal"),
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/entity_groups_model.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/entity_groups_model.py`

 * *Files 2% similar despite different names*

```diff
@@ -14,15 +14,14 @@
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
 from datetime import datetime
-from inspect import getfullargspec
 from typing import List, Optional
 
 from pydantic import BaseModel, Field, StrictStr, conlist, constr, validator
 
 from atriumsports.datacore.openapi.models.contact_details import ContactDetails
 from atriumsports.datacore.openapi.models.entity_additional_details import EntityAdditionalDetails
 from atriumsports.datacore.openapi.models.entity_group_address import EntityGroupAddress
@@ -115,30 +114,36 @@
         "updated",
         "added",
         "defaultVenueId",
         "images",
     ]
 
     @validator("status")
-    def status_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("ACTIVE", "INACTIVE", "PENDING"):
+    def status_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("ACTIVE", "INACTIVE", "PENDING"):
             raise ValueError("must be one of enum values ('ACTIVE', 'INACTIVE', 'PENDING')")
-        return v
+        return value
 
     @validator("external_id")
-    def external_id_validate_regular_expression(cls, v):
-        if v is None:
-            return v
-        if not re.match(r"^[0-9A-Za-z\/_-]+$", v):
+    def external_id_validate_regular_expression(cls, value):
+        """Validates the regular expression"""
+        if value is None:
+            return value
+
+        if not re.match(r"^[0-9A-Za-z\/_-]+$", value):
             raise ValueError(r"must validate the regular expression /^[0-9A-Za-z\/_-]+$/")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -256,15 +261,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> EntityGroupsModel:
         """Create an instance of EntityGroupsModel from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return EntityGroupsModel.parse_obj(obj)
 
         _obj = EntityGroupsModel.parse_obj(
             {
                 "entity_group_id": obj.get("entityGroupId"),
                 "organization_id": obj.get("organizationId"),
                 "organization": EntityGroupsModelOrganization.from_dict(obj.get("organization"))
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/entity_groups_model_organization.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/entity_groups_model_organization.py`

 * *Files 8% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr, validator
 
 
 class EntityGroupsModelOrganization(BaseModel):
     """
@@ -29,22 +28,26 @@
     """
 
     resource_type: Optional[StrictStr] = Field(None, alias="resourceType")
     id: Optional[StrictStr] = Field(None, description="Unique identifier for this resource")
     __properties = ["resourceType", "id"]
 
     @validator("resource_type")
-    def resource_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("organizations"):
+    def resource_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("organizations"):
             raise ValueError("must be one of enum values ('organizations')")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -64,12 +67,12 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> EntityGroupsModelOrganization:
         """Create an instance of EntityGroupsModelOrganization from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return EntityGroupsModelOrganization.parse_obj(obj)
 
         _obj = EntityGroupsModelOrganization.parse_obj({"resource_type": obj.get("resourceType"), "id": obj.get("id")})
         return _obj
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/entity_groups_response.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/entity_groups_response.py`

 * *Files 1% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import List, Optional
 
 from pydantic import BaseModel, conlist
 
 from atriumsports.datacore.openapi.models.entity_groups_model import EntityGroupsModel
 from atriumsports.datacore.openapi.models.included_data import IncludedData
 from atriumsports.datacore.openapi.models.response_links import ResponseLinks
@@ -36,14 +35,16 @@
     meta: Optional[ResponseMetaData] = None
     links: Optional[ResponseLinks] = None
     included: Optional[IncludedData] = None
     data: Optional[conlist(EntityGroupsModel)] = None
     __properties = ["meta", "links", "included", "data"]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -79,15 +80,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> EntityGroupsResponse:
         """Create an instance of EntityGroupsResponse from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return EntityGroupsResponse.parse_obj(obj)
 
         _obj = EntityGroupsResponse.parse_obj(
             {
                 "meta": ResponseMetaData.from_dict(obj.get("meta")) if obj.get("meta") is not None else None,
                 "links": ResponseLinks.from_dict(obj.get("links")) if obj.get("links") is not None else None,
                 "included": IncludedData.from_dict(obj.get("included")) if obj.get("included") is not None else None,
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/entity_historical_name.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/entity_historical_name.py`

 * *Files 6% similar despite different names*

```diff
@@ -14,15 +14,14 @@
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
 from datetime import date
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr
 
 
 class EntityHistoricalName(BaseModel):
     """
@@ -51,14 +50,16 @@
         "nameFullLatin",
         "nameShortLocal",
         "nameShortLatin",
         "namePlaceLocal",
     ]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -113,15 +114,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> EntityHistoricalName:
         """Create an instance of EntityHistoricalName from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return EntityHistoricalName.parse_obj(obj)
 
         _obj = EntityHistoricalName.parse_obj(
             {
                 "date_start": obj.get("dateStart"),
                 "date_end": obj.get("dateEnd"),
                 "name_full_local": obj.get("nameFullLocal"),
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/entity_post_body.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/entity_post_body.py`

 * *Files 4% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import List, Optional
 
 from pydantic import BaseModel, Field, StrictStr, conlist, constr, validator
 
 from atriumsports.datacore.openapi.models.contact_details import ContactDetails
 from atriumsports.datacore.openapi.models.entity_additional_details import EntityAdditionalDetails
 from atriumsports.datacore.openapi.models.entity_address import EntityAddress
@@ -120,32 +119,37 @@
         "gender",
         "standard",
         "grade",
         "defaultVenueId",
     ]
 
     @validator("status")
-    def status_validate_enum(cls, v):
-        if v not in ("ACTIVE", "INACTIVE", "PENDING"):
+    def status_validate_enum(cls, value):
+        """Validates the enum"""
+        if value not in ("ACTIVE", "INACTIVE", "PENDING"):
             raise ValueError("must be one of enum values ('ACTIVE', 'INACTIVE', 'PENDING')")
-        return v
+        return value
 
     @validator("external_id")
-    def external_id_validate_regular_expression(cls, v):
-        if v is None:
-            return v
-        if not re.match(r"^[0-9A-Za-z\/_-]+$", v):
+    def external_id_validate_regular_expression(cls, value):
+        """Validates the regular expression"""
+        if value is None:
+            return value
+
+        if not re.match(r"^[0-9A-Za-z\/_-]+$", value):
             raise ValueError(r"must validate the regular expression /^[0-9A-Za-z\/_-]+$/")
-        return v
+        return value
 
     @validator("age_group")
-    def age_group_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in (
+    def age_group_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in (
             "JUNIOR",
             "YOUTH",
             "UNDER_10",
             "UNDER_11",
             "UNDER_12",
             "UNDER_13",
             "UNDER_14",
@@ -160,29 +164,33 @@
             "UNDER_23",
             "SENIOR",
             "MASTERS",
         ):
             raise ValueError(
                 "must be one of enum values ('JUNIOR', 'YOUTH', 'UNDER_10', 'UNDER_11', 'UNDER_12', 'UNDER_13', 'UNDER_14', 'UNDER_15', 'UNDER_16', 'UNDER_17', 'UNDER_18', 'UNDER_19', 'UNDER_20', 'UNDER_21', 'UNDER_22', 'UNDER_23', 'SENIOR', 'MASTERS')"
             )
-        return v
+        return value
 
     @validator("gender")
-    def gender_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("FEMALE", "MALE", "MIXED", "UNKNOWN"):
+    def gender_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("FEMALE", "MALE", "MIXED", "UNKNOWN"):
             raise ValueError("must be one of enum values ('FEMALE', 'MALE', 'MIXED', 'UNKNOWN')")
-        return v
+        return value
 
     @validator("standard")
-    def standard_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in (
+    def standard_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in (
             "ELITE",
             "FRIENDLY",
             "GRASS_ROOT",
             "INTERNATIONAL",
             "NONCONTINENTAL_CHAMPIONSHIP",
             "OLYMPIC",
             "REGION",
@@ -190,17 +198,19 @@
             "TIER3",
             "WORLD_CHAMPIONSHIP",
             "ZONE_CHAMPIONSHIP",
         ):
             raise ValueError(
                 "must be one of enum values ('ELITE', 'FRIENDLY', 'GRASS_ROOT', 'INTERNATIONAL', 'NONCONTINENTAL_CHAMPIONSHIP', 'OLYMPIC', 'REGION', 'TIER2', 'TIER3', 'WORLD_CHAMPIONSHIP', 'ZONE_CHAMPIONSHIP')"
             )
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -310,15 +320,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> EntityPostBody:
         """Create an instance of EntityPostBody from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return EntityPostBody.parse_obj(obj)
 
         _obj = EntityPostBody.parse_obj(
             {
                 "entity_id": obj.get("entityId"),
                 "entity_group_id": obj.get("entityGroupId"),
                 "international_reference": obj.get("internationalReference"),
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/entity_post_body_additional_names.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/entity_post_body_additional_names.py`

 * *Files 2% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, constr
 
 
 class EntityPostBodyAdditionalNames(BaseModel):
     """
@@ -47,14 +46,16 @@
         None,
         alias="namePlaceLatin",
         description="The name of the place associated with the entity using [latin](#section/Introduction/Character-Sets-and-Names) characters",
     )
     __properties = ["nameShortLocal", "namePlaceLocal", "nameShortLatin", "namePlaceLatin"]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -94,15 +95,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> EntityPostBodyAdditionalNames:
         """Create an instance of EntityPostBodyAdditionalNames from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return EntityPostBodyAdditionalNames.parse_obj(obj)
 
         _obj = EntityPostBodyAdditionalNames.parse_obj(
             {
                 "name_short_local": obj.get("nameShortLocal"),
                 "name_place_local": obj.get("namePlaceLocal"),
                 "name_short_latin": obj.get("nameShortLatin"),
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/entity_post_body_colors.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/entity_post_body_colors.py`

 * *Files 9% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, constr
 
 
 class EntityPostBodyColors(BaseModel):
     """
@@ -39,14 +38,16 @@
     tertiary: Optional[constr(strict=True, max_length=6, min_length=6)] = Field(
         None,
         description="Tertiary color of the entity.  Colors are a hexadecimal string `RRGGBB` with `RR`(red), `GG`(green) and `BB`(blue) representing the components of the colour. ",
     )
     __properties = ["primary", "secondary", "tertiary"]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -81,14 +82,14 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> EntityPostBodyColors:
         """Create an instance of EntityPostBodyColors from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return EntityPostBodyColors.parse_obj(obj)
 
         _obj = EntityPostBodyColors.parse_obj(
             {"primary": obj.get("primary"), "secondary": obj.get("secondary"), "tertiary": obj.get("tertiary")}
         )
         return _obj
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/entity_put_body.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/entity_put_body.py`

 * *Files 4% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import List, Optional
 
 from pydantic import BaseModel, Field, StrictStr, conlist, constr, validator
 
 from atriumsports.datacore.openapi.models.contact_details import ContactDetails
 from atriumsports.datacore.openapi.models.entity_additional_details import EntityAdditionalDetails
 from atriumsports.datacore.openapi.models.entity_address import EntityAddress
@@ -118,34 +117,40 @@
         "gender",
         "standard",
         "grade",
         "defaultVenueId",
     ]
 
     @validator("status")
-    def status_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("ACTIVE", "INACTIVE", "PENDING"):
+    def status_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("ACTIVE", "INACTIVE", "PENDING"):
             raise ValueError("must be one of enum values ('ACTIVE', 'INACTIVE', 'PENDING')")
-        return v
+        return value
 
     @validator("external_id")
-    def external_id_validate_regular_expression(cls, v):
-        if v is None:
-            return v
-        if not re.match(r"^[0-9A-Za-z\/_-]+$", v):
+    def external_id_validate_regular_expression(cls, value):
+        """Validates the regular expression"""
+        if value is None:
+            return value
+
+        if not re.match(r"^[0-9A-Za-z\/_-]+$", value):
             raise ValueError(r"must validate the regular expression /^[0-9A-Za-z\/_-]+$/")
-        return v
+        return value
 
     @validator("age_group")
-    def age_group_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in (
+    def age_group_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in (
             "JUNIOR",
             "YOUTH",
             "UNDER_10",
             "UNDER_11",
             "UNDER_12",
             "UNDER_13",
             "UNDER_14",
@@ -160,29 +165,33 @@
             "UNDER_23",
             "SENIOR",
             "MASTERS",
         ):
             raise ValueError(
                 "must be one of enum values ('JUNIOR', 'YOUTH', 'UNDER_10', 'UNDER_11', 'UNDER_12', 'UNDER_13', 'UNDER_14', 'UNDER_15', 'UNDER_16', 'UNDER_17', 'UNDER_18', 'UNDER_19', 'UNDER_20', 'UNDER_21', 'UNDER_22', 'UNDER_23', 'SENIOR', 'MASTERS')"
             )
-        return v
+        return value
 
     @validator("gender")
-    def gender_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("FEMALE", "MALE", "MIXED", "UNKNOWN"):
+    def gender_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("FEMALE", "MALE", "MIXED", "UNKNOWN"):
             raise ValueError("must be one of enum values ('FEMALE', 'MALE', 'MIXED', 'UNKNOWN')")
-        return v
+        return value
 
     @validator("standard")
-    def standard_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in (
+    def standard_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in (
             "ELITE",
             "FRIENDLY",
             "GRASS_ROOT",
             "INTERNATIONAL",
             "NONCONTINENTAL_CHAMPIONSHIP",
             "OLYMPIC",
             "REGION",
@@ -190,17 +199,19 @@
             "TIER3",
             "WORLD_CHAMPIONSHIP",
             "ZONE_CHAMPIONSHIP",
         ):
             raise ValueError(
                 "must be one of enum values ('ELITE', 'FRIENDLY', 'GRASS_ROOT', 'INTERNATIONAL', 'NONCONTINENTAL_CHAMPIONSHIP', 'OLYMPIC', 'REGION', 'TIER2', 'TIER3', 'WORLD_CHAMPIONSHIP', 'ZONE_CHAMPIONSHIP')"
             )
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -310,15 +321,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> EntityPutBody:
         """Create an instance of EntityPutBody from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return EntityPutBody.parse_obj(obj)
 
         _obj = EntityPutBody.parse_obj(
             {
                 "entity_group_id": obj.get("entityGroupId"),
                 "international_reference": obj.get("internationalReference"),
                 "status": obj.get("status"),
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/environmental_details.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/environmental_details.py`

 * *Files 6% similar despite different names*

```diff
@@ -13,29 +13,30 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr
 
 
 class EnvironmentalDetails(BaseModel):
     """
     Details about the environment during the fixture
     """
 
     surface_condition: Optional[StrictStr] = Field(None, alias="surfaceCondition", description="Condition of surface")
     __properties = ["surfaceCondition"]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -55,12 +56,12 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> EnvironmentalDetails:
         """Create an instance of EnvironmentalDetails from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return EnvironmentalDetails.parse_obj(obj)
 
         _obj = EnvironmentalDetails.parse_obj({"surface_condition": obj.get("surfaceCondition")})
         return _obj
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/error_list_model.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/error_list_model.py`

 * *Files 3% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictInt, StrictStr, validator
 
 
 class ErrorListModel(BaseModel):
     """
@@ -33,24 +32,28 @@
     message: Optional[StrictStr] = Field(None, description="A message indicating the reason for the error")
     row_number: Optional[StrictInt] = Field(
         None, alias="rowNumber", description="The row number of the payload that cause the error"
     )
     __properties = ["code", "reason", "message", "rowNumber"]
 
     @validator("reason")
-    def reason_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("INVALID_DATA", "NOT_FOUND", "NOT_AUTHORISED", "ERROR", "DELETE_ERROR"):
+    def reason_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("INVALID_DATA", "NOT_FOUND", "NOT_AUTHORISED", "ERROR", "DELETE_ERROR"):
             raise ValueError(
                 "must be one of enum values ('INVALID_DATA', 'NOT_FOUND', 'NOT_AUTHORISED', 'ERROR', 'DELETE_ERROR')"
             )
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -70,15 +73,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> ErrorListModel:
         """Create an instance of ErrorListModel from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return ErrorListModel.parse_obj(obj)
 
         _obj = ErrorListModel.parse_obj(
             {
                 "code": obj.get("code"),
                 "reason": obj.get("reason"),
                 "message": obj.get("message"),
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/error_model.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/error_model.py`

 * *Files 6% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import List, Optional
 
 from pydantic import BaseModel, Field, StrictInt, StrictStr, conlist
 
 from atriumsports.datacore.openapi.models.error_list_model import ErrorListModel
 
 
@@ -38,14 +37,16 @@
         None,
         description="A message indicating the reason for the error. If there are multiple errors, then this is the message for the first one.",
     )
     errors: Optional[conlist(ErrorListModel)] = None
     __properties = ["code", "message", "errors"]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -72,15 +73,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> ErrorModel:
         """Create an instance of ErrorModel from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return ErrorModel.parse_obj(obj)
 
         _obj = ErrorModel.parse_obj(
             {
                 "code": obj.get("code"),
                 "message": obj.get("message"),
                 "errors": [ErrorListModel.from_dict(_item) for _item in obj.get("errors")]
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixture_competitor.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixture_competitor.py`

 * *Files 7% similar despite different names*

```diff
@@ -13,18 +13,17 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
-from typing import Optional
+from typing import Optional, Union
 
-from pydantic import BaseModel, Field, StrictBool, StrictFloat, StrictStr, validator
+from pydantic import BaseModel, Field, StrictBool, StrictFloat, StrictInt, StrictStr, validator
 
 
 class FixtureCompetitor(BaseModel):
     """
     FixtureCompetitor
     """
 
@@ -35,16 +34,20 @@
         None,
         alias="includeInConferenceStatistics",
         description="Include the statistics for this competitors in the conference statistics?",
     )
     is_home: Optional[StrictBool] = Field(None, alias="isHome", description="Is competitor the home entity ?")
     draw: Optional[StrictBool] = Field(None, description="Result for this competitor was a draw ?")
     result_status: Optional[StrictStr] = Field(None, alias="resultStatus", description="Result status")
-    result_place: Optional[StrictFloat] = Field(None, alias="resultPlace", description="Result placing (1=Won, 2=Lost)")
-    starting_number: Optional[StrictFloat] = Field(None, alias="startingNumber", description="Starting number")
+    result_place: Optional[Union[StrictFloat, StrictInt]] = Field(
+        None, alias="resultPlace", description="Result placing (1=Won, 2=Lost)"
+    )
+    starting_number: Optional[Union[StrictFloat, StrictInt]] = Field(
+        None, alias="startingNumber", description="Starting number"
+    )
     score: Optional[StrictStr] = Field(None, description="Score for competitor in fixture")
     secondary_score: Optional[StrictStr] = Field(None, alias="secondaryScore", description="Secondary score")
     is_neutral_venue: Optional[StrictBool] = Field(
         None, alias="isNeutralVenue", description="Competitor is playing at a neutral venue ?"
     )
     external_id: Optional[StrictStr] = Field(None, alias="externalId", description="externalId")
     __properties = [
@@ -60,34 +63,38 @@
         "score",
         "secondaryScore",
         "isNeutralVenue",
         "externalId",
     ]
 
     @validator("result_status")
-    def result_status_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in (
+    def result_status_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in (
             "SCHEDULED",
             "IN_PROGRESS",
             "CONFIRMED",
             "DISQUALIFIED",
             "FORFEITED",
             "WON_BY_FORFEIT",
             "DID_NOT_FINISH",
             "WITHDRAWN",
             "DID_NOT_START",
         ):
             raise ValueError(
                 "must be one of enum values ('SCHEDULED', 'IN_PROGRESS', 'CONFIRMED', 'DISQUALIFIED', 'FORFEITED', 'WON_BY_FORFEIT', 'DID_NOT_FINISH', 'WITHDRAWN', 'DID_NOT_START')"
             )
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -127,15 +134,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> FixtureCompetitor:
         """Create an instance of FixtureCompetitor from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return FixtureCompetitor.parse_obj(obj)
 
         _obj = FixtureCompetitor.parse_obj(
             {
                 "entity_id": obj.get("entityId"),
                 "conference_id": obj.get("conferenceId"),
                 "division_id": obj.get("divisionId"),
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixture_entities_model.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixture_entities_model.py`

 * *Files 2% similar despite different names*

```diff
@@ -14,15 +14,14 @@
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
 from datetime import datetime
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictBool, StrictStr, conint, constr, validator
 
 from atriumsports.datacore.openapi.models.fixture_entities_model_conference import FixtureEntitiesModelConference
 from atriumsports.datacore.openapi.models.fixture_entities_model_division import FixtureEntitiesModelDivision
 from atriumsports.datacore.openapi.models.fixture_entities_model_entity import FixtureEntitiesModelEntity
@@ -111,50 +110,58 @@
         "rosterStatus",
         "externalId",
         "updated",
         "added",
     ]
 
     @validator("result_status")
-    def result_status_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in (
+    def result_status_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in (
             "SCHEDULED",
             "IN_PROGRESS",
             "CONFIRMED",
             "DISQUALIFIED",
             "FORFEITED",
             "WON_BY_FORFEIT",
             "DID_NOT_FINISH",
             "WITHDRAWN",
             "DID_NOT_START",
         ):
             raise ValueError(
                 "must be one of enum values ('SCHEDULED', 'IN_PROGRESS', 'CONFIRMED', 'DISQUALIFIED', 'FORFEITED', 'WON_BY_FORFEIT', 'DID_NOT_FINISH', 'WITHDRAWN', 'DID_NOT_START')"
             )
-        return v
+        return value
 
     @validator("roster_status")
-    def roster_status_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("UNKNOWN", "SUBMITTED", "PENDING", "APPROVED", "REJECTED"):
+    def roster_status_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("UNKNOWN", "SUBMITTED", "PENDING", "APPROVED", "REJECTED"):
             raise ValueError("must be one of enum values ('UNKNOWN', 'SUBMITTED', 'PENDING', 'APPROVED', 'REJECTED')")
-        return v
+        return value
 
     @validator("external_id")
-    def external_id_validate_regular_expression(cls, v):
-        if v is None:
-            return v
-        if not re.match(r"^[0-9A-Za-z\/_-]+$", v):
+    def external_id_validate_regular_expression(cls, value):
+        """Validates the regular expression"""
+        if value is None:
+            return value
+
+        if not re.match(r"^[0-9A-Za-z\/_-]+$", value):
             raise ValueError(r"must validate the regular expression /^[0-9A-Za-z\/_-]+$/")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -237,15 +244,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> FixtureEntitiesModel:
         """Create an instance of FixtureEntitiesModel from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return FixtureEntitiesModel.parse_obj(obj)
 
         _obj = FixtureEntitiesModel.parse_obj(
             {
                 "fixture_id": obj.get("fixtureId"),
                 "fixture": FixtureProgressionsModelFixture.from_dict(obj.get("fixture"))
                 if obj.get("fixture") is not None
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixture_entities_model_conference.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixture_entities_model_conference.py`

 * *Files 10% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr, validator
 
 
 class FixtureEntitiesModelConference(BaseModel):
     """
@@ -29,22 +28,26 @@
     """
 
     resource_type: Optional[StrictStr] = Field(None, alias="resourceType")
     id: Optional[StrictStr] = Field(None, description="Unique identifier for this resource")
     __properties = ["resourceType", "id"]
 
     @validator("resource_type")
-    def resource_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("conferences"):
+    def resource_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("conferences"):
             raise ValueError("must be one of enum values ('conferences')")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -64,12 +67,12 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> FixtureEntitiesModelConference:
         """Create an instance of FixtureEntitiesModelConference from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return FixtureEntitiesModelConference.parse_obj(obj)
 
         _obj = FixtureEntitiesModelConference.parse_obj({"resource_type": obj.get("resourceType"), "id": obj.get("id")})
         return _obj
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixture_entities_model_division.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixture_entities_model_division.py`

 * *Files 4% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr, validator
 
 
 class FixtureEntitiesModelDivision(BaseModel):
     """
@@ -29,22 +28,26 @@
     """
 
     resource_type: Optional[StrictStr] = Field(None, alias="resourceType")
     id: Optional[StrictStr] = Field(None, description="Unique identifier for this resource")
     __properties = ["resourceType", "id"]
 
     @validator("resource_type")
-    def resource_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("divisions"):
+    def resource_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("divisions"):
             raise ValueError("must be one of enum values ('divisions')")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -64,12 +67,12 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> FixtureEntitiesModelDivision:
         """Create an instance of FixtureEntitiesModelDivision from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return FixtureEntitiesModelDivision.parse_obj(obj)
 
         _obj = FixtureEntitiesModelDivision.parse_obj({"resource_type": obj.get("resourceType"), "id": obj.get("id")})
         return _obj
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixture_entities_model_entity.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixture_entities_model_entity.py`

 * *Files 5% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr, validator
 
 
 class FixtureEntitiesModelEntity(BaseModel):
     """
@@ -29,22 +28,26 @@
     """
 
     resource_type: Optional[StrictStr] = Field(None, alias="resourceType")
     id: Optional[StrictStr] = Field(None, description="Unique identifier for this resource")
     __properties = ["resourceType", "id"]
 
     @validator("resource_type")
-    def resource_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("entities"):
+    def resource_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("entities"):
             raise ValueError("must be one of enum values ('entities')")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -64,12 +67,12 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> FixtureEntitiesModelEntity:
         """Create an instance of FixtureEntitiesModelEntity from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return FixtureEntitiesModelEntity.parse_obj(obj)
 
         _obj = FixtureEntitiesModelEntity.parse_obj({"resource_type": obj.get("resourceType"), "id": obj.get("id")})
         return _obj
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixture_entities_model_organization.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixture_roster_model_organization.py`

 * *Files 9% similar despite different names*

```diff
@@ -13,65 +13,66 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr, validator
 
 
-class FixtureEntitiesModelOrganization(BaseModel):
+class FixtureRosterModelOrganization(BaseModel):
     """
-    The organization that this fixture entities belongs to
+    The organization that this fixture roster belongs to
     """
 
     resource_type: Optional[StrictStr] = Field(None, alias="resourceType")
     id: Optional[StrictStr] = Field(None, description="Unique identifier for this resource")
     __properties = ["resourceType", "id"]
 
     @validator("resource_type")
-    def resource_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("organizations"):
+    def resource_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("organizations"):
             raise ValueError("must be one of enum values ('organizations')")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> FixtureEntitiesModelOrganization:
-        """Create an instance of FixtureEntitiesModelOrganization from a JSON string"""
+    def from_json(cls, json_str: str) -> FixtureRosterModelOrganization:
+        """Create an instance of FixtureRosterModelOrganization from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
     def to_dict(self):
         """Returns the dictionary representation of the model using alias"""
         _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> FixtureEntitiesModelOrganization:
-        """Create an instance of FixtureEntitiesModelOrganization from a dict"""
+    def from_dict(cls, obj: dict) -> FixtureRosterModelOrganization:
+        """Create an instance of FixtureRosterModelOrganization from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
-            return FixtureEntitiesModelOrganization.parse_obj(obj)
+        if not isinstance(obj, dict):
+            return FixtureRosterModelOrganization.parse_obj(obj)
 
-        _obj = FixtureEntitiesModelOrganization.parse_obj(
-            {"resource_type": obj.get("resourceType"), "id": obj.get("id")}
-        )
+        _obj = FixtureRosterModelOrganization.parse_obj({"resource_type": obj.get("resourceType"), "id": obj.get("id")})
         return _obj
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixture_entities_post_body.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixture_entities_post_body.py`

 * *Files 6% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictBool, StrictStr, conint, constr, validator
 
 
 class FixtureEntitiesPostBody(BaseModel):
     """
@@ -86,48 +85,55 @@
         "shootOutAttempts",
         "isNeutralVenue",
         "rosterStatus",
         "externalId",
     ]
 
     @validator("result_status")
-    def result_status_validate_enum(cls, v):
-        if v not in (
+    def result_status_validate_enum(cls, value):
+        """Validates the enum"""
+        if value not in (
             "SCHEDULED",
             "IN_PROGRESS",
             "CONFIRMED",
             "DISQUALIFIED",
             "FORFEITED",
             "WON_BY_FORFEIT",
             "DID_NOT_FINISH",
             "WITHDRAWN",
             "DID_NOT_START",
         ):
             raise ValueError(
                 "must be one of enum values ('SCHEDULED', 'IN_PROGRESS', 'CONFIRMED', 'DISQUALIFIED', 'FORFEITED', 'WON_BY_FORFEIT', 'DID_NOT_FINISH', 'WITHDRAWN', 'DID_NOT_START')"
             )
-        return v
+        return value
 
     @validator("roster_status")
-    def roster_status_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("UNKNOWN", "SUBMITTED", "PENDING", "APPROVED", "REJECTED"):
+    def roster_status_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("UNKNOWN", "SUBMITTED", "PENDING", "APPROVED", "REJECTED"):
             raise ValueError("must be one of enum values ('UNKNOWN', 'SUBMITTED', 'PENDING', 'APPROVED', 'REJECTED')")
-        return v
+        return value
 
     @validator("external_id")
-    def external_id_validate_regular_expression(cls, v):
-        if v is None:
-            return v
-        if not re.match(r"^[0-9A-Za-z\/_-]+$", v):
+    def external_id_validate_regular_expression(cls, value):
+        """Validates the regular expression"""
+        if value is None:
+            return value
+
+        if not re.match(r"^[0-9A-Za-z\/_-]+$", value):
             raise ValueError(r"must validate the regular expression /^[0-9A-Za-z\/_-]+$/")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -187,15 +193,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> FixtureEntitiesPostBody:
         """Create an instance of FixtureEntitiesPostBody from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return FixtureEntitiesPostBody.parse_obj(obj)
 
         _obj = FixtureEntitiesPostBody.parse_obj(
             {
                 "fixture_id": obj.get("fixtureId"),
                 "entity_id": obj.get("entityId"),
                 "conference_id": obj.get("conferenceId"),
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixture_entities_response.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixture_entities_response.py`

 * *Files 3% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import List, Optional
 
 from pydantic import BaseModel, conlist
 
 from atriumsports.datacore.openapi.models.fixture_entities_model import FixtureEntitiesModel
 from atriumsports.datacore.openapi.models.included_data import IncludedData
 from atriumsports.datacore.openapi.models.response_links import ResponseLinks
@@ -36,14 +35,16 @@
     meta: Optional[ResponseMetaData] = None
     links: Optional[ResponseLinks] = None
     included: Optional[IncludedData] = None
     data: Optional[conlist(FixtureEntitiesModel)] = None
     __properties = ["meta", "links", "included", "data"]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -79,15 +80,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> FixtureEntitiesResponse:
         """Create an instance of FixtureEntitiesResponse from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return FixtureEntitiesResponse.parse_obj(obj)
 
         _obj = FixtureEntitiesResponse.parse_obj(
             {
                 "meta": ResponseMetaData.from_dict(obj.get("meta")) if obj.get("meta") is not None else None,
                 "links": ResponseLinks.from_dict(obj.get("links")) if obj.get("links") is not None else None,
                 "included": IncludedData.from_dict(obj.get("included")) if obj.get("included") is not None else None,
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixture_entity_period_statistics_post_body.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixture_entity_period_statistics_post_body.py`

 * *Files 3% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Any, Dict, Optional
 
 from pydantic import BaseModel, Field, StrictInt, StrictStr, constr
 
 
 class FixtureEntityPeriodStatisticsPostBody(BaseModel):
     """
@@ -34,14 +33,16 @@
     period_id: Optional[StrictInt] = Field(None, alias="periodId", description="The identifier for the period")
     section: Optional[constr(strict=True, max_length=100)] = Field(
         None, description="The section of the period (sub-period)"
     )
     __properties = ["entityId", "fixtureId", "statistics", "periodId", "section"]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -61,15 +62,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> FixtureEntityPeriodStatisticsPostBody:
         """Create an instance of FixtureEntityPeriodStatisticsPostBody from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return FixtureEntityPeriodStatisticsPostBody.parse_obj(obj)
 
         _obj = FixtureEntityPeriodStatisticsPostBody.parse_obj(
             {
                 "entity_id": obj.get("entityId"),
                 "fixture_id": obj.get("fixtureId"),
                 "statistics": obj.get("statistics"),
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixture_entity_statistics_model.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixture_entity_statistics_model.py`

 * *Files 2% similar despite different names*

```diff
@@ -14,15 +14,14 @@
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
 from datetime import datetime
-from inspect import getfullargspec
 from typing import Any, Dict, Optional
 
 from pydantic import BaseModel, Field, StrictStr
 
 from atriumsports.datacore.openapi.models.fixture_entities_model_entity import FixtureEntitiesModelEntity
 from atriumsports.datacore.openapi.models.fixture_entity_statistics_model_organization import (
     FixtureEntityStatisticsModelOrganization,
@@ -55,14 +54,16 @@
         "organization",
         "statistics",
         "updated",
         "added",
     ]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -99,15 +100,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> FixtureEntityStatisticsModel:
         """Create an instance of FixtureEntityStatisticsModel from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return FixtureEntityStatisticsModel.parse_obj(obj)
 
         _obj = FixtureEntityStatisticsModel.parse_obj(
             {
                 "entity_id": obj.get("entityId"),
                 "entity": FixtureEntitiesModelEntity.from_dict(obj.get("entity"))
                 if obj.get("entity") is not None
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixture_entity_statistics_model_organization.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixture_entity_statistics_model_organization.py`

 * *Files 6% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr, validator
 
 
 class FixtureEntityStatisticsModelOrganization(BaseModel):
     """
@@ -29,22 +28,26 @@
     """
 
     resource_type: Optional[StrictStr] = Field(None, alias="resourceType")
     id: Optional[StrictStr] = Field(None, description="Unique identifier for this resource")
     __properties = ["resourceType", "id"]
 
     @validator("resource_type")
-    def resource_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("organizations"):
+    def resource_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("organizations"):
             raise ValueError("must be one of enum values ('organizations')")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -64,14 +67,14 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> FixtureEntityStatisticsModelOrganization:
         """Create an instance of FixtureEntityStatisticsModelOrganization from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return FixtureEntityStatisticsModelOrganization.parse_obj(obj)
 
         _obj = FixtureEntityStatisticsModelOrganization.parse_obj(
             {"resource_type": obj.get("resourceType"), "id": obj.get("id")}
         )
         return _obj
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixture_entity_statistics_periods_model.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixture_entity_statistics_periods_model.py`

 * *Files 2% similar despite different names*

```diff
@@ -14,15 +14,14 @@
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
 from datetime import datetime
-from inspect import getfullargspec
 from typing import Any, Dict, Optional
 
 from pydantic import BaseModel, Field, StrictInt, StrictStr, constr
 
 from atriumsports.datacore.openapi.models.fixture_entities_model_entity import FixtureEntitiesModelEntity
 from atriumsports.datacore.openapi.models.fixture_entity_statistics_periods_model_organization import (
     FixtureEntityStatisticsPeriodsModelOrganization,
@@ -61,14 +60,16 @@
         "periodId",
         "section",
         "updated",
         "added",
     ]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -105,15 +106,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> FixtureEntityStatisticsPeriodsModel:
         """Create an instance of FixtureEntityStatisticsPeriodsModel from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return FixtureEntityStatisticsPeriodsModel.parse_obj(obj)
 
         _obj = FixtureEntityStatisticsPeriodsModel.parse_obj(
             {
                 "entity_id": obj.get("entityId"),
                 "entity": FixtureEntitiesModelEntity.from_dict(obj.get("entity"))
                 if obj.get("entity") is not None
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixture_entity_statistics_periods_model_organization.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixture_entity_statistics_periods_model_organization.py`

 * *Files 6% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr, validator
 
 
 class FixtureEntityStatisticsPeriodsModelOrganization(BaseModel):
     """
@@ -29,22 +28,26 @@
     """
 
     resource_type: Optional[StrictStr] = Field(None, alias="resourceType")
     id: Optional[StrictStr] = Field(None, description="Unique identifier for this resource")
     __properties = ["resourceType", "id"]
 
     @validator("resource_type")
-    def resource_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("organizations"):
+    def resource_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("organizations"):
             raise ValueError("must be one of enum values ('organizations')")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -64,14 +67,14 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> FixtureEntityStatisticsPeriodsModelOrganization:
         """Create an instance of FixtureEntityStatisticsPeriodsModelOrganization from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return FixtureEntityStatisticsPeriodsModelOrganization.parse_obj(obj)
 
         _obj = FixtureEntityStatisticsPeriodsModelOrganization.parse_obj(
             {"resource_type": obj.get("resourceType"), "id": obj.get("id")}
         )
         return _obj
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixture_entity_statistics_periods_response.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixture_entity_statistics_periods_response.py`

 * *Files 2% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import List, Optional
 
 from pydantic import BaseModel, conlist
 
 from atriumsports.datacore.openapi.models.fixture_entity_statistics_periods_model import (
     FixtureEntityStatisticsPeriodsModel,
 )
@@ -38,14 +37,16 @@
     meta: Optional[ResponseMetaData] = None
     links: Optional[ResponseLinks] = None
     included: Optional[IncludedData] = None
     data: Optional[conlist(FixtureEntityStatisticsPeriodsModel)] = None
     __properties = ["meta", "links", "included", "data"]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -81,15 +82,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> FixtureEntityStatisticsPeriodsResponse:
         """Create an instance of FixtureEntityStatisticsPeriodsResponse from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return FixtureEntityStatisticsPeriodsResponse.parse_obj(obj)
 
         _obj = FixtureEntityStatisticsPeriodsResponse.parse_obj(
             {
                 "meta": ResponseMetaData.from_dict(obj.get("meta")) if obj.get("meta") is not None else None,
                 "links": ResponseLinks.from_dict(obj.get("links")) if obj.get("links") is not None else None,
                 "included": IncludedData.from_dict(obj.get("included")) if obj.get("included") is not None else None,
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixture_entity_statistics_post_body.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixture_entity_statistics_post_body.py`

 * *Files 6% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Any, Dict, Optional
 
 from pydantic import BaseModel, Field, StrictStr
 
 
 class FixtureEntityStatisticsPostBody(BaseModel):
     """
@@ -30,14 +29,16 @@
 
     entity_id: StrictStr = Field(..., alias="entityId", description="The unique identifier of the entity")
     fixture_id: StrictStr = Field(..., alias="fixtureId", description="The unique identifier of the fixture")
     statistics: Optional[Dict[str, Any]] = None
     __properties = ["entityId", "fixtureId", "statistics"]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -57,14 +58,14 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> FixtureEntityStatisticsPostBody:
         """Create an instance of FixtureEntityStatisticsPostBody from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return FixtureEntityStatisticsPostBody.parse_obj(obj)
 
         _obj = FixtureEntityStatisticsPostBody.parse_obj(
             {"entity_id": obj.get("entityId"), "fixture_id": obj.get("fixtureId"), "statistics": obj.get("statistics")}
         )
         return _obj
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixture_entity_statistics_response.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixture_entity_statistics_response.py`

 * *Files 4% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import List, Optional
 
 from pydantic import BaseModel, conlist
 
 from atriumsports.datacore.openapi.models.fixture_entity_statistics_model import FixtureEntityStatisticsModel
 from atriumsports.datacore.openapi.models.included_data import IncludedData
 from atriumsports.datacore.openapi.models.response_links import ResponseLinks
@@ -36,14 +35,16 @@
     meta: Optional[ResponseMetaData] = None
     links: Optional[ResponseLinks] = None
     included: Optional[IncludedData] = None
     data: Optional[conlist(FixtureEntityStatisticsModel)] = None
     __properties = ["meta", "links", "included", "data"]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -79,15 +80,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> FixtureEntityStatisticsResponse:
         """Create an instance of FixtureEntityStatisticsResponse from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return FixtureEntityStatisticsResponse.parse_obj(obj)
 
         _obj = FixtureEntityStatisticsResponse.parse_obj(
             {
                 "meta": ResponseMetaData.from_dict(obj.get("meta")) if obj.get("meta") is not None else None,
                 "links": ResponseLinks.from_dict(obj.get("links")) if obj.get("links") is not None else None,
                 "included": IncludedData.from_dict(obj.get("included")) if obj.get("included") is not None else None,
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixture_live_summary_model.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixture_live_summary_model.py`

 * *Files 9% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Any, Dict, Optional
 
 from pydantic import BaseModel, Field, StrictStr, constr
 
 
 class FixtureLiveSummaryModel(BaseModel):
     """
@@ -34,14 +33,16 @@
     fixture_id: Optional[StrictStr] = Field(None, alias="fixtureId", description="The unique identifier of the fixture")
     entities: Optional[Dict[str, Any]] = Field(None, description="Entity information: scores, person information, etc.")
     clock: Optional[Dict[str, Any]] = Field(None, description="Clock information")
     status: Optional[Dict[str, Any]] = Field(None, description="Status information")
     __properties = ["organizationId", "fixtureId", "entities", "clock", "status"]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -61,15 +62,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> FixtureLiveSummaryModel:
         """Create an instance of FixtureLiveSummaryModel from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return FixtureLiveSummaryModel.parse_obj(obj)
 
         _obj = FixtureLiveSummaryModel.parse_obj(
             {
                 "organization_id": obj.get("organizationId"),
                 "fixture_id": obj.get("fixtureId"),
                 "entities": obj.get("entities"),
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixture_live_summary_response.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixture_live_summary_response.py`

 * *Files 2% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import List, Optional
 
 from pydantic import BaseModel, conlist
 
 from atriumsports.datacore.openapi.models.fixture_live_summary_model import FixtureLiveSummaryModel
 from atriumsports.datacore.openapi.models.included_data import IncludedData
 from atriumsports.datacore.openapi.models.response_links import ResponseLinks
@@ -36,14 +35,16 @@
     meta: Optional[ResponseMetaData] = None
     links: Optional[ResponseLinks] = None
     included: Optional[IncludedData] = None
     data: Optional[conlist(FixtureLiveSummaryModel)] = None
     __properties = ["meta", "links", "included", "data"]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -79,15 +80,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> FixtureLiveSummaryResponse:
         """Create an instance of FixtureLiveSummaryResponse from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return FixtureLiveSummaryResponse.parse_obj(obj)
 
         _obj = FixtureLiveSummaryResponse.parse_obj(
             {
                 "meta": ResponseMetaData.from_dict(obj.get("meta")) if obj.get("meta") is not None else None,
                 "links": ResponseLinks.from_dict(obj.get("links")) if obj.get("links") is not None else None,
                 "included": IncludedData.from_dict(obj.get("included")) if obj.get("included") is not None else None,
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixture_participant.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixture_participant.py`

 * *Files 4% similar despite different names*

```diff
@@ -13,34 +13,37 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
-from typing import Optional
+from typing import Optional, Union
 
-from pydantic import BaseModel, Field, StrictBool, StrictFloat, StrictStr, validator
+from pydantic import BaseModel, Field, StrictBool, StrictFloat, StrictInt, StrictStr, validator
 
 
 class FixtureParticipant(BaseModel):
     """
     FixtureParticipant
     """
 
     person_id: StrictStr = Field(..., alias="personId", description="The uuid of the person")
     entity_group_id: Optional[StrictStr] = Field(
         None, alias="entityGroupId", description="The uuid of the entity group"
     )
     is_home: Optional[StrictBool] = Field(None, alias="isHome", description="Is participant the home person ?")
     draw: Optional[StrictBool] = Field(None, description="Result for this participant was a draw ?")
     result_status: Optional[StrictStr] = Field(None, alias="resultStatus", description="Result status")
-    result_place: Optional[StrictFloat] = Field(None, alias="resultPlace", description="Result placing (1=Won, 2=Lost)")
-    starting_number: Optional[StrictFloat] = Field(None, alias="startingNumber", description="Starting number")
+    result_place: Optional[Union[StrictFloat, StrictInt]] = Field(
+        None, alias="resultPlace", description="Result placing (1=Won, 2=Lost)"
+    )
+    starting_number: Optional[Union[StrictFloat, StrictInt]] = Field(
+        None, alias="startingNumber", description="Starting number"
+    )
     score: Optional[StrictStr] = Field(None, description="Score for participant in fixture")
     secondary_score: Optional[StrictStr] = Field(None, alias="secondaryScore", description="Secondary score")
     is_neutral_venue: Optional[StrictBool] = Field(
         None, alias="isNeutralVenue", description="Participant is playing at a neutral venue ?"
     )
     external_id: Optional[StrictStr] = Field(None, alias="externalId", description="externalId")
     __properties = [
@@ -54,34 +57,38 @@
         "score",
         "secondaryScore",
         "isNeutralVenue",
         "externalId",
     ]
 
     @validator("result_status")
-    def result_status_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in (
+    def result_status_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in (
             "SCHEDULED",
             "IN_PROGRESS",
             "CONFIRMED",
             "DISQUALIFIED",
             "FORFEITED",
             "WON_BY_FORFEIT",
             "DID_NOT_FINISH",
             "WITHDRAWN",
             "DID_NOT_START",
         ):
             raise ValueError(
                 "must be one of enum values ('SCHEDULED', 'IN_PROGRESS', 'CONFIRMED', 'DISQUALIFIED', 'FORFEITED', 'WON_BY_FORFEIT', 'DID_NOT_FINISH', 'WITHDRAWN', 'DID_NOT_START')"
             )
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -121,15 +128,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> FixtureParticipant:
         """Create an instance of FixtureParticipant from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return FixtureParticipant.parse_obj(obj)
 
         _obj = FixtureParticipant.parse_obj(
             {
                 "person_id": obj.get("personId"),
                 "entity_group_id": obj.get("entityGroupId"),
                 "is_home": obj.get("isHome"),
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixture_pbp_event_model.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixture_pbp_event_model.py`

 * *Files 2% similar despite different names*

```diff
@@ -14,16 +14,15 @@
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
 from datetime import datetime
-from inspect import getfullargspec
-from typing import Any, Dict, Optional
+from typing import Any, Dict, Optional, Union
 
 from pydantic import BaseModel, Field, StrictBool, StrictFloat, StrictInt, StrictStr, constr, validator
 
 from atriumsports.datacore.openapi.models.fixture_entities_model_entity import FixtureEntitiesModelEntity
 from atriumsports.datacore.openapi.models.fixture_pbp_event_model_organization import FixturePbpEventModelOrganization
 from atriumsports.datacore.openapi.models.fixture_persons_model_person import FixturePersonsModelPerson
 from atriumsports.datacore.openapi.models.fixture_progressions_model_fixture import FixtureProgressionsModelFixture
@@ -68,21 +67,21 @@
         alias="subType",
         description="The Sub Type of event. See <b>Streaming API</b> documenation for more information.",
     )
     options: Optional[Dict[str, Any]] = Field(
         None, description="The options for the event. See <b>Streaming API</b> documenation for more information."
     )
     success: Optional[StrictBool] = Field(None, description="Whether the action was successful")
-    x: Optional[StrictFloat] = Field(
+    x: Optional[Union[StrictFloat, StrictInt]] = Field(
         None, description="The x co-ordinate of the event. Represented as percentage from left (0) to right (100)."
     )
-    y: Optional[StrictFloat] = Field(
+    y: Optional[Union[StrictFloat, StrictInt]] = Field(
         None, description="The y co-ordinate of the event. Represented as precentage from top (0) to bottom (100)."
     )
-    z: Optional[StrictFloat] = Field(
+    z: Optional[Union[StrictFloat, StrictInt]] = Field(
         None, description="The z co-ordinate of the event. Represented as precentage from ground (0) to ceiling (100)."
     )
     clock: Optional[StrictStr] = Field(
         None, description="The time on the clock when the event occurred. ISO 8601 format. PTmmMss.ccS"
     )
     shot_clock: Optional[StrictStr] = Field(
         None,
@@ -130,22 +129,26 @@
         "officialId",
         "zone",
         "scores",
         "timestamp",
     ]
 
     @validator("var_class")
-    def var_class_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("sport"):
+    def var_class_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("sport"):
             raise ValueError("must be one of enum values ('sport')")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -193,15 +196,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> FixturePbpEventModel:
         """Create an instance of FixturePbpEventModel from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return FixturePbpEventModel.parse_obj(obj)
 
         _obj = FixturePbpEventModel.parse_obj(
             {
                 "organization_id": obj.get("organizationId"),
                 "organization": FixturePbpEventModelOrganization.from_dict(obj.get("organization"))
                 if obj.get("organization") is not None
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixture_pbp_event_model_organization.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixture_pbp_event_model_organization.py`

 * *Files 11% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr, validator
 
 
 class FixturePbpEventModelOrganization(BaseModel):
     """
@@ -29,22 +28,26 @@
     """
 
     resource_type: Optional[StrictStr] = Field(None, alias="resourceType")
     id: Optional[StrictStr] = Field(None, description="Unique identifier for this resource")
     __properties = ["resourceType", "id"]
 
     @validator("resource_type")
-    def resource_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("organizations"):
+    def resource_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("organizations"):
             raise ValueError("must be one of enum values ('organizations')")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -64,14 +67,14 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> FixturePbpEventModelOrganization:
         """Create an instance of FixturePbpEventModelOrganization from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return FixturePbpEventModelOrganization.parse_obj(obj)
 
         _obj = FixturePbpEventModelOrganization.parse_obj(
             {"resource_type": obj.get("resourceType"), "id": obj.get("id")}
         )
         return _obj
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixture_pbp_event_response.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixture_pbp_event_response.py`

 * *Files 5% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import List, Optional
 
 from pydantic import BaseModel, conlist
 
 from atriumsports.datacore.openapi.models.fixture_pbp_event_model import FixturePbpEventModel
 from atriumsports.datacore.openapi.models.included_data import IncludedData
 from atriumsports.datacore.openapi.models.response_links import ResponseLinks
@@ -36,14 +35,16 @@
     meta: Optional[ResponseMetaData] = None
     links: Optional[ResponseLinks] = None
     included: Optional[IncludedData] = None
     data: Optional[conlist(FixturePbpEventModel)] = None
     __properties = ["meta", "links", "included", "data"]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -79,15 +80,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> FixturePbpEventResponse:
         """Create an instance of FixturePbpEventResponse from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return FixturePbpEventResponse.parse_obj(obj)
 
         _obj = FixturePbpEventResponse.parse_obj(
             {
                 "meta": ResponseMetaData.from_dict(obj.get("meta")) if obj.get("meta") is not None else None,
                 "links": ResponseLinks.from_dict(obj.get("links")) if obj.get("links") is not None else None,
                 "included": IncludedData.from_dict(obj.get("included")) if obj.get("included") is not None else None,
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixture_pbp_model.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixture_pbp_model.py`

 * *Files 5% similar despite different names*

```diff
@@ -14,15 +14,14 @@
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
 from datetime import datetime
-from inspect import getfullargspec
 from typing import Any, Dict, Optional
 
 from pydantic import BaseModel, Field, StrictInt, StrictStr, constr
 
 from atriumsports.datacore.openapi.models.fixture_pbp_model_organization import FixturePbpModelOrganization
 from atriumsports.datacore.openapi.models.fixture_progressions_model_fixture import FixtureProgressionsModelFixture
 
@@ -54,14 +53,16 @@
         "section",
         "events",
         "updated",
         "added",
     ]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -100,15 +101,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> FixturePbpModel:
         """Create an instance of FixturePbpModel from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return FixturePbpModel.parse_obj(obj)
 
         _obj = FixturePbpModel.parse_obj(
             {
                 "organization_id": obj.get("organizationId"),
                 "organization": FixturePbpModelOrganization.from_dict(obj.get("organization"))
                 if obj.get("organization") is not None
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixture_pbp_model_organization.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixture_person_statistics_model_organization.py`

 * *Files 13% similar despite different names*

```diff
@@ -13,63 +13,68 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr, validator
 
 
-class FixturePbpModelOrganization(BaseModel):
+class FixturePersonStatisticsModelOrganization(BaseModel):
     """
-    The organization that this fixture_pbp belongs to
+    The organization that this fixture person statistics belongs to
     """
 
     resource_type: Optional[StrictStr] = Field(None, alias="resourceType")
     id: Optional[StrictStr] = Field(None, description="Unique identifier for this resource")
     __properties = ["resourceType", "id"]
 
     @validator("resource_type")
-    def resource_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("organizations"):
+    def resource_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("organizations"):
             raise ValueError("must be one of enum values ('organizations')")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> FixturePbpModelOrganization:
-        """Create an instance of FixturePbpModelOrganization from a JSON string"""
+    def from_json(cls, json_str: str) -> FixturePersonStatisticsModelOrganization:
+        """Create an instance of FixturePersonStatisticsModelOrganization from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
     def to_dict(self):
         """Returns the dictionary representation of the model using alias"""
         _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> FixturePbpModelOrganization:
-        """Create an instance of FixturePbpModelOrganization from a dict"""
+    def from_dict(cls, obj: dict) -> FixturePersonStatisticsModelOrganization:
+        """Create an instance of FixturePersonStatisticsModelOrganization from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
-            return FixturePbpModelOrganization.parse_obj(obj)
+        if not isinstance(obj, dict):
+            return FixturePersonStatisticsModelOrganization.parse_obj(obj)
 
-        _obj = FixturePbpModelOrganization.parse_obj({"resource_type": obj.get("resourceType"), "id": obj.get("id")})
+        _obj = FixturePersonStatisticsModelOrganization.parse_obj(
+            {"resource_type": obj.get("resourceType"), "id": obj.get("id")}
+        )
         return _obj
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixture_pbp_post_body.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixture_pbp_post_body.py`

 * *Files 3% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Any, Dict, Optional
 
 from pydantic import BaseModel, Field, StrictInt, StrictStr, constr
 
 
 class FixturePbpPostBody(BaseModel):
     """
@@ -33,14 +32,16 @@
     section: Optional[constr(strict=True, max_length=100)] = Field(
         None, description="The section of the period (sub-period)"
     )
     events: Optional[Dict[str, Any]] = Field(None, description="Event details")
     __properties = ["fixtureId", "periodId", "section", "events"]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -65,15 +66,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> FixturePbpPostBody:
         """Create an instance of FixturePbpPostBody from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return FixturePbpPostBody.parse_obj(obj)
 
         _obj = FixturePbpPostBody.parse_obj(
             {
                 "fixture_id": obj.get("fixtureId"),
                 "period_id": obj.get("periodId"),
                 "section": obj.get("section"),
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixture_pbp_response.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixture_pbp_response.py`

 * *Files 3% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import List, Optional
 
 from pydantic import BaseModel, conlist
 
 from atriumsports.datacore.openapi.models.fixture_pbp_model import FixturePbpModel
 from atriumsports.datacore.openapi.models.included_data import IncludedData
 from atriumsports.datacore.openapi.models.response_links import ResponseLinks
@@ -36,14 +35,16 @@
     meta: Optional[ResponseMetaData] = None
     links: Optional[ResponseLinks] = None
     included: Optional[IncludedData] = None
     data: Optional[conlist(FixturePbpModel)] = None
     __properties = ["meta", "links", "included", "data"]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -79,15 +80,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> FixturePbpResponse:
         """Create an instance of FixturePbpResponse from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return FixturePbpResponse.parse_obj(obj)
 
         _obj = FixturePbpResponse.parse_obj(
             {
                 "meta": ResponseMetaData.from_dict(obj.get("meta")) if obj.get("meta") is not None else None,
                 "links": ResponseLinks.from_dict(obj.get("links")) if obj.get("links") is not None else None,
                 "included": IncludedData.from_dict(obj.get("included")) if obj.get("included") is not None else None,
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixture_person_statistics_model.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixture_person_statistics_model.py`

 * *Files 1% similar despite different names*

```diff
@@ -14,15 +14,14 @@
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
 from datetime import datetime
-from inspect import getfullargspec
 from typing import Any, Dict, Optional
 
 from pydantic import BaseModel, Field, StrictBool, StrictStr, constr
 
 from atriumsports.datacore.openapi.models.fixture_entities_model_entity import FixtureEntitiesModelEntity
 from atriumsports.datacore.openapi.models.fixture_person_statistics_model_organization import (
     FixturePersonStatisticsModelOrganization,
@@ -80,14 +79,16 @@
         "isPlayer",
         "isTeamOfficial",
         "updated",
         "added",
     ]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -147,15 +148,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> FixturePersonStatisticsModel:
         """Create an instance of FixturePersonStatisticsModel from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return FixturePersonStatisticsModel.parse_obj(obj)
 
         _obj = FixturePersonStatisticsModel.parse_obj(
             {
                 "person_id": obj.get("personId"),
                 "person": FixturePersonsModelPerson.from_dict(obj.get("person"))
                 if obj.get("person") is not None
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixture_person_statistics_model_organization.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixture_profiles_model_organization.py`

 * *Files 11% similar despite different names*

```diff
@@ -13,65 +13,68 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr, validator
 
 
-class FixturePersonStatisticsModelOrganization(BaseModel):
+class FixtureProfilesModelOrganization(BaseModel):
     """
-    The organization that this fixture person statistics belongs to
+    The organization that this fixture profiles belongs to
     """
 
     resource_type: Optional[StrictStr] = Field(None, alias="resourceType")
     id: Optional[StrictStr] = Field(None, description="Unique identifier for this resource")
     __properties = ["resourceType", "id"]
 
     @validator("resource_type")
-    def resource_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("organizations"):
+    def resource_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("organizations"):
             raise ValueError("must be one of enum values ('organizations')")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> FixturePersonStatisticsModelOrganization:
-        """Create an instance of FixturePersonStatisticsModelOrganization from a JSON string"""
+    def from_json(cls, json_str: str) -> FixtureProfilesModelOrganization:
+        """Create an instance of FixtureProfilesModelOrganization from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
     def to_dict(self):
         """Returns the dictionary representation of the model using alias"""
         _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> FixturePersonStatisticsModelOrganization:
-        """Create an instance of FixturePersonStatisticsModelOrganization from a dict"""
+    def from_dict(cls, obj: dict) -> FixtureProfilesModelOrganization:
+        """Create an instance of FixtureProfilesModelOrganization from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
-            return FixturePersonStatisticsModelOrganization.parse_obj(obj)
+        if not isinstance(obj, dict):
+            return FixtureProfilesModelOrganization.parse_obj(obj)
 
-        _obj = FixturePersonStatisticsModelOrganization.parse_obj(
+        _obj = FixtureProfilesModelOrganization.parse_obj(
             {"resource_type": obj.get("resourceType"), "id": obj.get("id")}
         )
         return _obj
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixture_person_statistics_periods_model.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixture_person_statistics_periods_model.py`

 * *Files 2% similar despite different names*

```diff
@@ -14,15 +14,14 @@
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
 from datetime import datetime
-from inspect import getfullargspec
 from typing import Any, Dict, Optional
 
 from pydantic import BaseModel, Field, StrictInt, StrictStr, constr
 
 from atriumsports.datacore.openapi.models.fixture_entities_model_entity import FixtureEntitiesModelEntity
 from atriumsports.datacore.openapi.models.fixture_person_statistics_periods_model_organization import (
     FixturePersonStatisticsPeriodsModelOrganization,
@@ -66,14 +65,16 @@
         "periodId",
         "section",
         "updated",
         "added",
     ]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -118,15 +119,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> FixturePersonStatisticsPeriodsModel:
         """Create an instance of FixturePersonStatisticsPeriodsModel from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return FixturePersonStatisticsPeriodsModel.parse_obj(obj)
 
         _obj = FixturePersonStatisticsPeriodsModel.parse_obj(
             {
                 "person_id": obj.get("personId"),
                 "person": FixturePersonsModelPerson.from_dict(obj.get("person"))
                 if obj.get("person") is not None
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixture_person_statistics_periods_model_organization.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixture_person_statistics_periods_model_organization.py`

 * *Files 8% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr, validator
 
 
 class FixturePersonStatisticsPeriodsModelOrganization(BaseModel):
     """
@@ -29,22 +28,26 @@
     """
 
     resource_type: Optional[StrictStr] = Field(None, alias="resourceType")
     id: Optional[StrictStr] = Field(None, description="Unique identifier for this resource")
     __properties = ["resourceType", "id"]
 
     @validator("resource_type")
-    def resource_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("organizations"):
+    def resource_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("organizations"):
             raise ValueError("must be one of enum values ('organizations')")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -64,14 +67,14 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> FixturePersonStatisticsPeriodsModelOrganization:
         """Create an instance of FixturePersonStatisticsPeriodsModelOrganization from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return FixturePersonStatisticsPeriodsModelOrganization.parse_obj(obj)
 
         _obj = FixturePersonStatisticsPeriodsModelOrganization.parse_obj(
             {"resource_type": obj.get("resourceType"), "id": obj.get("id")}
         )
         return _obj
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixture_person_statistics_periods_post_body.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixture_person_statistics_periods_post_body.py`

 * *Files 4% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Any, Dict, Optional
 
 from pydantic import BaseModel, Field, StrictInt, StrictStr, constr
 
 
 class FixturePersonStatisticsPeriodsPostBody(BaseModel):
     """
@@ -35,14 +34,16 @@
     period_id: StrictInt = Field(..., alias="periodId", description="The identifier for the period")
     section: Optional[constr(strict=True, max_length=100)] = Field(
         None, description="The section of the period (sub-period)"
     )
     __properties = ["personId", "entityId", "fixtureId", "statistics", "periodId", "section"]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -67,15 +68,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> FixturePersonStatisticsPeriodsPostBody:
         """Create an instance of FixturePersonStatisticsPeriodsPostBody from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return FixturePersonStatisticsPeriodsPostBody.parse_obj(obj)
 
         _obj = FixturePersonStatisticsPeriodsPostBody.parse_obj(
             {
                 "person_id": obj.get("personId"),
                 "entity_id": obj.get("entityId"),
                 "fixture_id": obj.get("fixtureId"),
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixture_person_statistics_periods_response.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixture_person_statistics_periods_response.py`

 * *Files 2% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import List, Optional
 
 from pydantic import BaseModel, conlist
 
 from atriumsports.datacore.openapi.models.fixture_person_statistics_periods_model import (
     FixturePersonStatisticsPeriodsModel,
 )
@@ -38,14 +37,16 @@
     meta: Optional[ResponseMetaData] = None
     links: Optional[ResponseLinks] = None
     included: Optional[IncludedData] = None
     data: Optional[conlist(FixturePersonStatisticsPeriodsModel)] = None
     __properties = ["meta", "links", "included", "data"]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -81,15 +82,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> FixturePersonStatisticsPeriodsResponse:
         """Create an instance of FixturePersonStatisticsPeriodsResponse from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return FixturePersonStatisticsPeriodsResponse.parse_obj(obj)
 
         _obj = FixturePersonStatisticsPeriodsResponse.parse_obj(
             {
                 "meta": ResponseMetaData.from_dict(obj.get("meta")) if obj.get("meta") is not None else None,
                 "links": ResponseLinks.from_dict(obj.get("links")) if obj.get("links") is not None else None,
                 "included": IncludedData.from_dict(obj.get("included")) if obj.get("included") is not None else None,
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixture_person_statistics_post_body.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixture_person_statistics_post_body.py`

 * *Files 9% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Any, Dict, Optional
 
 from pydantic import BaseModel, Field, StrictBool, StrictStr, constr
 
 
 class FixturePersonStatisticsPostBody(BaseModel):
     """
@@ -56,14 +55,16 @@
         "starter",
         "participated",
         "isPlayer",
         "isTeamOfficial",
     ]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -103,15 +104,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> FixturePersonStatisticsPostBody:
         """Create an instance of FixturePersonStatisticsPostBody from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return FixturePersonStatisticsPostBody.parse_obj(obj)
 
         _obj = FixturePersonStatisticsPostBody.parse_obj(
             {
                 "person_id": obj.get("personId"),
                 "entity_id": obj.get("entityId"),
                 "fixture_id": obj.get("fixtureId"),
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixture_person_statistics_response.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixture_person_statistics_response.py`

 * *Files 2% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import List, Optional
 
 from pydantic import BaseModel, conlist
 
 from atriumsports.datacore.openapi.models.fixture_person_statistics_model import FixturePersonStatisticsModel
 from atriumsports.datacore.openapi.models.included_data import IncludedData
 from atriumsports.datacore.openapi.models.response_links import ResponseLinks
@@ -36,14 +35,16 @@
     meta: Optional[ResponseMetaData] = None
     links: Optional[ResponseLinks] = None
     included: Optional[IncludedData] = None
     data: Optional[conlist(FixturePersonStatisticsModel)] = None
     __properties = ["meta", "links", "included", "data"]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -79,15 +80,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> FixturePersonStatisticsResponse:
         """Create an instance of FixturePersonStatisticsResponse from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return FixturePersonStatisticsResponse.parse_obj(obj)
 
         _obj = FixturePersonStatisticsResponse.parse_obj(
             {
                 "meta": ResponseMetaData.from_dict(obj.get("meta")) if obj.get("meta") is not None else None,
                 "links": ResponseLinks.from_dict(obj.get("links")) if obj.get("links") is not None else None,
                 "included": IncludedData.from_dict(obj.get("included")) if obj.get("included") is not None else None,
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixture_persons_model.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixture_persons_model.py`

 * *Files 1% similar despite different names*

```diff
@@ -14,15 +14,14 @@
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
 from datetime import datetime
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictBool, StrictStr, conint, constr, validator
 
 from atriumsports.datacore.openapi.models.entities_model_entity_group import EntitiesModelEntityGroup
 from atriumsports.datacore.openapi.models.fixture_persons_model_organization import FixturePersonsModelOrganization
 from atriumsports.datacore.openapi.models.fixture_persons_model_person import FixturePersonsModelPerson
@@ -88,42 +87,48 @@
         "isNeutralVenue",
         "externalId",
         "updated",
         "added",
     ]
 
     @validator("result_status")
-    def result_status_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in (
+    def result_status_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in (
             "SCHEDULED",
             "IN_PROGRESS",
             "CONFIRMED",
             "DISQUALIFIED",
             "FORFEITED",
             "WON_BY_FORFEIT",
             "DID_NOT_FINISH",
             "WITHDRAWN",
             "DID_NOT_START",
         ):
             raise ValueError(
                 "must be one of enum values ('SCHEDULED', 'IN_PROGRESS', 'CONFIRMED', 'DISQUALIFIED', 'FORFEITED', 'WON_BY_FORFEIT', 'DID_NOT_FINISH', 'WITHDRAWN', 'DID_NOT_START')"
             )
-        return v
+        return value
 
     @validator("external_id")
-    def external_id_validate_regular_expression(cls, v):
-        if v is None:
-            return v
-        if not re.match(r"^[0-9A-Za-z\/_-]+$", v):
+    def external_id_validate_regular_expression(cls, value):
+        """Validates the regular expression"""
+        if value is None:
+            return value
+
+        if not re.match(r"^[0-9A-Za-z\/_-]+$", value):
             raise ValueError(r"must validate the regular expression /^[0-9A-Za-z\/_-]+$/")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -193,15 +198,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> FixturePersonsModel:
         """Create an instance of FixturePersonsModel from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return FixturePersonsModel.parse_obj(obj)
 
         _obj = FixturePersonsModel.parse_obj(
             {
                 "fixture_id": obj.get("fixtureId"),
                 "fixture": FixtureProgressionsModelFixture.from_dict(obj.get("fixture"))
                 if obj.get("fixture") is not None
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixture_persons_model_organization.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixture_persons_model_organization.py`

 * *Files 7% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr, validator
 
 
 class FixturePersonsModelOrganization(BaseModel):
     """
@@ -29,22 +28,26 @@
     """
 
     resource_type: Optional[StrictStr] = Field(None, alias="resourceType")
     id: Optional[StrictStr] = Field(None, description="Unique identifier for this resource")
     __properties = ["resourceType", "id"]
 
     @validator("resource_type")
-    def resource_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("organizations"):
+    def resource_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("organizations"):
             raise ValueError("must be one of enum values ('organizations')")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -64,14 +67,14 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> FixturePersonsModelOrganization:
         """Create an instance of FixturePersonsModelOrganization from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return FixturePersonsModelOrganization.parse_obj(obj)
 
         _obj = FixturePersonsModelOrganization.parse_obj(
             {"resource_type": obj.get("resourceType"), "id": obj.get("id")}
         )
         return _obj
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixture_persons_model_person.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixture_persons_model_person.py`

 * *Files 4% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr, validator
 
 
 class FixturePersonsModelPerson(BaseModel):
     """
@@ -29,22 +28,26 @@
     """
 
     resource_type: Optional[StrictStr] = Field(None, alias="resourceType")
     id: Optional[StrictStr] = Field(None, description="Unique identifier for this resource")
     __properties = ["resourceType", "id"]
 
     @validator("resource_type")
-    def resource_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("persons"):
+    def resource_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("persons"):
             raise ValueError("must be one of enum values ('persons')")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -64,12 +67,12 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> FixturePersonsModelPerson:
         """Create an instance of FixturePersonsModelPerson from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return FixturePersonsModelPerson.parse_obj(obj)
 
         _obj = FixturePersonsModelPerson.parse_obj({"resource_type": obj.get("resourceType"), "id": obj.get("id")})
         return _obj
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixture_persons_post_body.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixture_persons_post_body.py`

 * *Files 7% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictBool, StrictStr, conint, constr, validator
 
 
 class FixturePersonsPostBody(BaseModel):
     """
@@ -66,40 +65,45 @@
         "score",
         "secondaryScore",
         "isNeutralVenue",
         "externalId",
     ]
 
     @validator("result_status")
-    def result_status_validate_enum(cls, v):
-        if v not in (
+    def result_status_validate_enum(cls, value):
+        """Validates the enum"""
+        if value not in (
             "SCHEDULED",
             "IN_PROGRESS",
             "CONFIRMED",
             "DISQUALIFIED",
             "FORFEITED",
             "WON_BY_FORFEIT",
             "DID_NOT_FINISH",
             "WITHDRAWN",
             "DID_NOT_START",
         ):
             raise ValueError(
                 "must be one of enum values ('SCHEDULED', 'IN_PROGRESS', 'CONFIRMED', 'DISQUALIFIED', 'FORFEITED', 'WON_BY_FORFEIT', 'DID_NOT_FINISH', 'WITHDRAWN', 'DID_NOT_START')"
             )
-        return v
+        return value
 
     @validator("external_id")
-    def external_id_validate_regular_expression(cls, v):
-        if v is None:
-            return v
-        if not re.match(r"^[0-9A-Za-z\/_-]+$", v):
+    def external_id_validate_regular_expression(cls, value):
+        """Validates the regular expression"""
+        if value is None:
+            return value
+
+        if not re.match(r"^[0-9A-Za-z\/_-]+$", value):
             raise ValueError(r"must validate the regular expression /^[0-9A-Za-z\/_-]+$/")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -149,15 +153,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> FixturePersonsPostBody:
         """Create an instance of FixturePersonsPostBody from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return FixturePersonsPostBody.parse_obj(obj)
 
         _obj = FixturePersonsPostBody.parse_obj(
             {
                 "fixture_id": obj.get("fixtureId"),
                 "person_id": obj.get("personId"),
                 "entity_group_id": obj.get("entityGroupId"),
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixture_persons_response.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixture_persons_response.py`

 * *Files 3% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import List, Optional
 
 from pydantic import BaseModel, conlist
 
 from atriumsports.datacore.openapi.models.fixture_persons_model import FixturePersonsModel
 from atriumsports.datacore.openapi.models.included_data import IncludedData
 from atriumsports.datacore.openapi.models.response_links import ResponseLinks
@@ -36,14 +35,16 @@
     meta: Optional[ResponseMetaData] = None
     links: Optional[ResponseLinks] = None
     included: Optional[IncludedData] = None
     data: Optional[conlist(FixturePersonsModel)] = None
     __properties = ["meta", "links", "included", "data"]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -79,15 +80,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> FixturePersonsResponse:
         """Create an instance of FixturePersonsResponse from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return FixturePersonsResponse.parse_obj(obj)
 
         _obj = FixturePersonsResponse.parse_obj(
             {
                 "meta": ResponseMetaData.from_dict(obj.get("meta")) if obj.get("meta") is not None else None,
                 "links": ResponseLinks.from_dict(obj.get("links")) if obj.get("links") is not None else None,
                 "included": IncludedData.from_dict(obj.get("included")) if obj.get("included") is not None else None,
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixture_post_body.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixture_post_body.py`

 * *Files 2% similar despite different names*

```diff
@@ -14,15 +14,14 @@
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
 from datetime import datetime
-from inspect import getfullargspec
 from typing import List, Optional
 
 from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr, conlist, constr, validator
 
 from atriumsports.datacore.openapi.models.environmental_details import EnvironmentalDetails
 from atriumsports.datacore.openapi.models.fixture_competitor import FixtureCompetitor
 from atriumsports.datacore.openapi.models.fixture_participant import FixtureParticipant
@@ -173,75 +172,88 @@
         "profileId",
         "includeInStandings",
         "featureMatch",
         "seriesFixtureNumber",
     ]
 
     @validator("practice_drill_type")
-    def practice_drill_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("DRILL", "GAME", "FITNESS", "OTHER"):
+    def practice_drill_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("DRILL", "GAME", "FITNESS", "OTHER"):
             raise ValueError("must be one of enum values ('DRILL', 'GAME', 'FITNESS', 'OTHER')")
-        return v
+        return value
 
     @validator("status")
-    def status_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in (
+    def status_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in (
             "IF_NEEDED",
             "SCHEDULED",
             "BYE",
             "PENDING",
             "IN_PROGRESS",
             "FINISHED",
             "CONFIRMED",
             "POSTPONED",
             "CANCELLED",
             "ABANDONED",
         ):
             raise ValueError(
                 "must be one of enum values ('IF_NEEDED', 'SCHEDULED', 'BYE', 'PENDING', 'IN_PROGRESS', 'FINISHED', 'CONFIRMED', 'POSTPONED', 'CANCELLED', 'ABANDONED')"
             )
-        return v
+        return value
 
     @validator("fixture_type")
-    def fixture_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("ALL_STAR", "PRESEASON", "REGULAR", "FINAL", "PLAYOFF", "FRIENDLY", "DEMONSTRATION"):
+    def fixture_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("ALL_STAR", "PRESEASON", "REGULAR", "FINAL", "PLAYOFF", "FRIENDLY", "DEMONSTRATION"):
             raise ValueError(
                 "must be one of enum values ('ALL_STAR', 'PRESEASON', 'REGULAR', 'FINAL', 'PLAYOFF', 'FRIENDLY', 'DEMONSTRATION')"
             )
-        return v
+        return value
 
     @validator("maximum_period_type_used")
-    def maximum_period_type_used_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("REGULAR", "EXTRA_TIME", "OVERTIME", "SHOOTOUT"):
+    def maximum_period_type_used_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("REGULAR", "EXTRA_TIME", "OVERTIME", "SHOOTOUT"):
             raise ValueError("must be one of enum values ('REGULAR', 'EXTRA_TIME', 'OVERTIME', 'SHOOTOUT')")
-        return v
+        return value
 
     @validator("competitor_type")
-    def competitor_type_validate_enum(cls, v):
-        if v not in ("PERSON", "ENTITY"):
+    def competitor_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value not in ("PERSON", "ENTITY"):
             raise ValueError("must be one of enum values ('PERSON', 'ENTITY')")
-        return v
+        return value
 
     @validator("external_id")
-    def external_id_validate_regular_expression(cls, v):
-        if v is None:
-            return v
-        if not re.match(r"^[0-9A-Za-z\/_-]+$", v):
+    def external_id_validate_regular_expression(cls, value):
+        """Validates the regular expression"""
+        if value is None:
+            return value
+
+        if not re.match(r"^[0-9A-Za-z\/_-]+$", value):
             raise ValueError(r"must validate the regular expression /^[0-9A-Za-z\/_-]+$/")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -416,15 +428,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> FixturePostBody:
         """Create an instance of FixturePostBody from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return FixturePostBody.parse_obj(obj)
 
         _obj = FixturePostBody.parse_obj(
             {
                 "fixture_id": obj.get("fixtureId"),
                 "season_id": obj.get("seasonId"),
                 "practice_drill_type": obj.get("practiceDrillType"),
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixture_profiles_model.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixture_profiles_model.py`

 * *Files 3% similar despite different names*

```diff
@@ -14,15 +14,14 @@
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
 from datetime import datetime
-from inspect import getfullargspec
 from typing import Any, Optional
 
 from pydantic import BaseModel, Field, StrictBool, StrictStr
 
 from atriumsports.datacore.openapi.models.fixture_profiles_model_organization import FixtureProfilesModelOrganization
 
 
@@ -51,14 +50,16 @@
         "profile",
         "updated",
         "added",
         "defaultProfile",
     ]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -94,15 +95,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> FixtureProfilesModel:
         """Create an instance of FixtureProfilesModel from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return FixtureProfilesModel.parse_obj(obj)
 
         _obj = FixtureProfilesModel.parse_obj(
             {
                 "profile_id": obj.get("profileId"),
                 "organization_id": obj.get("organizationId"),
                 "organization": FixtureProfilesModelOrganization.from_dict(obj.get("organization"))
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixture_profiles_model_organization.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/video_stream_local_model_organization.py`

 * *Files 15% similar despite different names*

```diff
@@ -13,65 +13,68 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr, validator
 
 
-class FixtureProfilesModelOrganization(BaseModel):
+class VideoStreamLocalModelOrganization(BaseModel):
     """
-    The organization that this fixture profiles belongs to
+    The organization that this Video Stream Local belongs to
     """
 
     resource_type: Optional[StrictStr] = Field(None, alias="resourceType")
     id: Optional[StrictStr] = Field(None, description="Unique identifier for this resource")
     __properties = ["resourceType", "id"]
 
     @validator("resource_type")
-    def resource_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("organizations"):
+    def resource_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("organizations"):
             raise ValueError("must be one of enum values ('organizations')")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> FixtureProfilesModelOrganization:
-        """Create an instance of FixtureProfilesModelOrganization from a JSON string"""
+    def from_json(cls, json_str: str) -> VideoStreamLocalModelOrganization:
+        """Create an instance of VideoStreamLocalModelOrganization from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
     def to_dict(self):
         """Returns the dictionary representation of the model using alias"""
         _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> FixtureProfilesModelOrganization:
-        """Create an instance of FixtureProfilesModelOrganization from a dict"""
+    def from_dict(cls, obj: dict) -> VideoStreamLocalModelOrganization:
+        """Create an instance of VideoStreamLocalModelOrganization from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
-            return FixtureProfilesModelOrganization.parse_obj(obj)
+        if not isinstance(obj, dict):
+            return VideoStreamLocalModelOrganization.parse_obj(obj)
 
-        _obj = FixtureProfilesModelOrganization.parse_obj(
+        _obj = VideoStreamLocalModelOrganization.parse_obj(
             {"resource_type": obj.get("resourceType"), "id": obj.get("id")}
         )
         return _obj
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixture_profiles_post_body.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixture_profiles_post_body.py`

 * *Files 7% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Any, Optional
 
 from pydantic import BaseModel, Field, StrictBool, StrictStr
 
 
 class FixtureProfilesPostBody(BaseModel):
     """
@@ -33,14 +32,16 @@
     profile: Optional[Any] = None
     default_profile: Optional[StrictBool] = Field(
         None, alias="defaultProfile", description="Is this the default profile for the organization?"
     )
     __properties = ["profileId", "name", "profile", "defaultProfile"]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -65,15 +66,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> FixtureProfilesPostBody:
         """Create an instance of FixtureProfilesPostBody from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return FixtureProfilesPostBody.parse_obj(obj)
 
         _obj = FixtureProfilesPostBody.parse_obj(
             {
                 "profile_id": obj.get("profileId"),
                 "name": obj.get("name"),
                 "profile": obj.get("profile"),
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixture_profiles_put_body.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixture_profiles_put_body.py`

 * *Files 6% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Any, Optional
 
 from pydantic import BaseModel, Field, StrictBool, StrictStr
 
 
 class FixtureProfilesPutBody(BaseModel):
     """
@@ -32,14 +31,16 @@
     profile: Optional[Any] = None
     default_profile: Optional[StrictBool] = Field(
         None, alias="defaultProfile", description="Is this the default profile for the organization?"
     )
     __properties = ["name", "profile", "defaultProfile"]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -64,14 +65,14 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> FixtureProfilesPutBody:
         """Create an instance of FixtureProfilesPutBody from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return FixtureProfilesPutBody.parse_obj(obj)
 
         _obj = FixtureProfilesPutBody.parse_obj(
             {"name": obj.get("name"), "profile": obj.get("profile"), "default_profile": obj.get("defaultProfile")}
         )
         return _obj
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixture_profiles_response.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixture_profiles_response.py`

 * *Files 3% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import List, Optional
 
 from pydantic import BaseModel, conlist
 
 from atriumsports.datacore.openapi.models.fixture_profiles_model import FixtureProfilesModel
 from atriumsports.datacore.openapi.models.included_data import IncludedData
 from atriumsports.datacore.openapi.models.response_links import ResponseLinks
@@ -36,14 +35,16 @@
     meta: Optional[ResponseMetaData] = None
     links: Optional[ResponseLinks] = None
     included: Optional[IncludedData] = None
     data: Optional[conlist(FixtureProfilesModel)] = None
     __properties = ["meta", "links", "included", "data"]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -79,15 +80,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> FixtureProfilesResponse:
         """Create an instance of FixtureProfilesResponse from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return FixtureProfilesResponse.parse_obj(obj)
 
         _obj = FixtureProfilesResponse.parse_obj(
             {
                 "meta": ResponseMetaData.from_dict(obj.get("meta")) if obj.get("meta") is not None else None,
                 "links": ResponseLinks.from_dict(obj.get("links")) if obj.get("links") is not None else None,
                 "included": IncludedData.from_dict(obj.get("included")) if obj.get("included") is not None else None,
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixture_progression_post_body.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixture_progression_post_body.py`

 * *Files 8% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr, constr, validator
 
 
 class FixtureProgressionPostBody(BaseModel):
     """
@@ -37,22 +36,26 @@
     )
     external_id: Optional[constr(strict=True, max_length=150)] = Field(
         None, alias="externalId", description="The Id of the data as set by the provider of the data"
     )
     __properties = ["fixtureId", "toFixtureId", "seasonId", "placing", "isHome", "externalId"]
 
     @validator("external_id")
-    def external_id_validate_regular_expression(cls, v):
-        if v is None:
-            return v
-        if not re.match(r"^[0-9A-Za-z\/_-]+$", v):
+    def external_id_validate_regular_expression(cls, value):
+        """Validates the regular expression"""
+        if value is None:
+            return value
+
+        if not re.match(r"^[0-9A-Za-z\/_-]+$", value):
             raise ValueError(r"must validate the regular expression /^[0-9A-Za-z\/_-]+$/")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -77,15 +80,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> FixtureProgressionPostBody:
         """Create an instance of FixtureProgressionPostBody from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return FixtureProgressionPostBody.parse_obj(obj)
 
         _obj = FixtureProgressionPostBody.parse_obj(
             {
                 "fixture_id": obj.get("fixtureId"),
                 "to_fixture_id": obj.get("toFixtureId"),
                 "season_id": obj.get("seasonId"),
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixture_progression_put_body.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixture_progression_put_body.py`

 * *Files 4% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictBool, StrictStr, constr, validator
 
 
 class FixtureProgressionPutBody(BaseModel):
     """
@@ -35,22 +34,26 @@
     )
     external_id: Optional[constr(strict=True, max_length=150)] = Field(
         None, alias="externalId", description="The Id of the data as set by the provider of the data"
     )
     __properties = ["toFixtureId", "seasonId", "isHome", "externalId"]
 
     @validator("external_id")
-    def external_id_validate_regular_expression(cls, v):
-        if v is None:
-            return v
-        if not re.match(r"^[0-9A-Za-z\/_-]+$", v):
+    def external_id_validate_regular_expression(cls, value):
+        """Validates the regular expression"""
+        if value is None:
+            return value
+
+        if not re.match(r"^[0-9A-Za-z\/_-]+$", value):
             raise ValueError(r"must validate the regular expression /^[0-9A-Za-z\/_-]+$/")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -75,15 +78,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> FixtureProgressionPutBody:
         """Create an instance of FixtureProgressionPutBody from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return FixtureProgressionPutBody.parse_obj(obj)
 
         _obj = FixtureProgressionPutBody.parse_obj(
             {
                 "to_fixture_id": obj.get("toFixtureId"),
                 "season_id": obj.get("seasonId"),
                 "is_home": obj.get("isHome"),
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixture_progressions_model.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixture_progressions_model.py`

 * *Files 4% similar despite different names*

```diff
@@ -14,15 +14,14 @@
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
 from datetime import datetime
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr, constr, validator
 
 from atriumsports.datacore.openapi.models.fixture_progressions_model_fixture import FixtureProgressionsModelFixture
 from atriumsports.datacore.openapi.models.fixture_progressions_model_organization import (
     FixtureProgressionsModelOrganization,
@@ -65,22 +64,26 @@
         "isHome",
         "updated",
         "added",
         "externalId",
     ]
 
     @validator("external_id")
-    def external_id_validate_regular_expression(cls, v):
-        if v is None:
-            return v
-        if not re.match(r"^[0-9A-Za-z\/_-]+$", v):
+    def external_id_validate_regular_expression(cls, value):
+        """Validates the regular expression"""
+        if value is None:
+            return value
+
+        if not re.match(r"^[0-9A-Za-z\/_-]+$", value):
             raise ValueError(r"must validate the regular expression /^[0-9A-Za-z\/_-]+$/")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -122,15 +125,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> FixtureProgressionsModel:
         """Create an instance of FixtureProgressionsModel from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return FixtureProgressionsModel.parse_obj(obj)
 
         _obj = FixtureProgressionsModel.parse_obj(
             {
                 "fixture_id": obj.get("fixtureId"),
                 "fixture": FixtureProgressionsModelFixture.from_dict(obj.get("fixture"))
                 if obj.get("fixture") is not None
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixture_progressions_model_fixture.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixture_progressions_model_fixture.py`

 * *Files 6% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr, validator
 
 
 class FixtureProgressionsModelFixture(BaseModel):
     """
@@ -29,22 +28,26 @@
     """
 
     resource_type: Optional[StrictStr] = Field(None, alias="resourceType")
     id: Optional[StrictStr] = Field(None, description="Unique identifier for this resource")
     __properties = ["resourceType", "id"]
 
     @validator("resource_type")
-    def resource_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("fixtures"):
+    def resource_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("fixtures"):
             raise ValueError("must be one of enum values ('fixtures')")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -64,14 +67,14 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> FixtureProgressionsModelFixture:
         """Create an instance of FixtureProgressionsModelFixture from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return FixtureProgressionsModelFixture.parse_obj(obj)
 
         _obj = FixtureProgressionsModelFixture.parse_obj(
             {"resource_type": obj.get("resourceType"), "id": obj.get("id")}
         )
         return _obj
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixture_progressions_model_organization.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/video_stream_inputs_model_organization.py`

 * *Files 14% similar despite different names*

```diff
@@ -13,65 +13,68 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr, validator
 
 
-class FixtureProgressionsModelOrganization(BaseModel):
+class VideoStreamInputsModelOrganization(BaseModel):
     """
-    The organization that this ~fixture_progression~ belongs to
+    The organization that this Video Stream Inputs belongs to
     """
 
     resource_type: Optional[StrictStr] = Field(None, alias="resourceType")
     id: Optional[StrictStr] = Field(None, description="Unique identifier for this resource")
     __properties = ["resourceType", "id"]
 
     @validator("resource_type")
-    def resource_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("organizations"):
+    def resource_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("organizations"):
             raise ValueError("must be one of enum values ('organizations')")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> FixtureProgressionsModelOrganization:
-        """Create an instance of FixtureProgressionsModelOrganization from a JSON string"""
+    def from_json(cls, json_str: str) -> VideoStreamInputsModelOrganization:
+        """Create an instance of VideoStreamInputsModelOrganization from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
     def to_dict(self):
         """Returns the dictionary representation of the model using alias"""
         _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> FixtureProgressionsModelOrganization:
-        """Create an instance of FixtureProgressionsModelOrganization from a dict"""
+    def from_dict(cls, obj: dict) -> VideoStreamInputsModelOrganization:
+        """Create an instance of VideoStreamInputsModelOrganization from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
-            return FixtureProgressionsModelOrganization.parse_obj(obj)
+        if not isinstance(obj, dict):
+            return VideoStreamInputsModelOrganization.parse_obj(obj)
 
-        _obj = FixtureProgressionsModelOrganization.parse_obj(
+        _obj = VideoStreamInputsModelOrganization.parse_obj(
             {"resource_type": obj.get("resourceType"), "id": obj.get("id")}
         )
         return _obj
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixture_progressions_model_season.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixture_progressions_model_season.py`

 * *Files 4% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr, validator
 
 
 class FixtureProgressionsModelSeason(BaseModel):
     """
@@ -29,22 +28,26 @@
     """
 
     resource_type: Optional[StrictStr] = Field(None, alias="resourceType")
     id: Optional[StrictStr] = Field(None, description="Unique identifier for this resource")
     __properties = ["resourceType", "id"]
 
     @validator("resource_type")
-    def resource_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("seasons"):
+    def resource_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("seasons"):
             raise ValueError("must be one of enum values ('seasons')")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -64,12 +67,12 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> FixtureProgressionsModelSeason:
         """Create an instance of FixtureProgressionsModelSeason from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return FixtureProgressionsModelSeason.parse_obj(obj)
 
         _obj = FixtureProgressionsModelSeason.parse_obj({"resource_type": obj.get("resourceType"), "id": obj.get("id")})
         return _obj
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixture_progressions_response.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixture_progressions_response.py`

 * *Files 8% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import List, Optional
 
 from pydantic import BaseModel, conlist
 
 from atriumsports.datacore.openapi.models.fixture_progressions_model import FixtureProgressionsModel
 from atriumsports.datacore.openapi.models.included_data import IncludedData
 from atriumsports.datacore.openapi.models.response_links import ResponseLinks
@@ -36,14 +35,16 @@
     meta: Optional[ResponseMetaData] = None
     links: Optional[ResponseLinks] = None
     included: Optional[IncludedData] = None
     data: Optional[conlist(FixtureProgressionsModel)] = None
     __properties = ["meta", "links", "included", "data"]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -79,15 +80,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> FixtureProgressionsResponse:
         """Create an instance of FixtureProgressionsResponse from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return FixtureProgressionsResponse.parse_obj(obj)
 
         _obj = FixtureProgressionsResponse.parse_obj(
             {
                 "meta": ResponseMetaData.from_dict(obj.get("meta")) if obj.get("meta") is not None else None,
                 "links": ResponseLinks.from_dict(obj.get("links")) if obj.get("links") is not None else None,
                 "included": IncludedData.from_dict(obj.get("included")) if obj.get("included") is not None else None,
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixture_put_body.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixture_put_body.py`

 * *Files 2% similar despite different names*

```diff
@@ -14,15 +14,14 @@
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
 from datetime import datetime
-from inspect import getfullargspec
 from typing import List, Optional
 
 from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr, conlist, constr, validator
 
 from atriumsports.datacore.openapi.models.environmental_details import EnvironmentalDetails
 from atriumsports.datacore.openapi.models.fixture_competitor import FixtureCompetitor
 from atriumsports.datacore.openapi.models.fixture_participant import FixtureParticipant
@@ -171,77 +170,91 @@
         "profileId",
         "includeInStandings",
         "featureMatch",
         "seriesFixtureNumber",
     ]
 
     @validator("practice_drill_type")
-    def practice_drill_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("DRILL", "GAME", "FITNESS", "OTHER"):
+    def practice_drill_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("DRILL", "GAME", "FITNESS", "OTHER"):
             raise ValueError("must be one of enum values ('DRILL', 'GAME', 'FITNESS', 'OTHER')")
-        return v
+        return value
 
     @validator("status")
-    def status_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in (
+    def status_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in (
             "IF_NEEDED",
             "SCHEDULED",
             "BYE",
             "PENDING",
             "IN_PROGRESS",
             "FINISHED",
             "CONFIRMED",
             "POSTPONED",
             "CANCELLED",
             "ABANDONED",
         ):
             raise ValueError(
                 "must be one of enum values ('IF_NEEDED', 'SCHEDULED', 'BYE', 'PENDING', 'IN_PROGRESS', 'FINISHED', 'CONFIRMED', 'POSTPONED', 'CANCELLED', 'ABANDONED')"
             )
-        return v
+        return value
 
     @validator("fixture_type")
-    def fixture_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("ALL_STAR", "PRESEASON", "REGULAR", "FINAL", "PLAYOFF", "FRIENDLY", "DEMONSTRATION"):
+    def fixture_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("ALL_STAR", "PRESEASON", "REGULAR", "FINAL", "PLAYOFF", "FRIENDLY", "DEMONSTRATION"):
             raise ValueError(
                 "must be one of enum values ('ALL_STAR', 'PRESEASON', 'REGULAR', 'FINAL', 'PLAYOFF', 'FRIENDLY', 'DEMONSTRATION')"
             )
-        return v
+        return value
 
     @validator("maximum_period_type_used")
-    def maximum_period_type_used_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("REGULAR", "EXTRA_TIME", "OVERTIME", "SHOOTOUT"):
+    def maximum_period_type_used_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("REGULAR", "EXTRA_TIME", "OVERTIME", "SHOOTOUT"):
             raise ValueError("must be one of enum values ('REGULAR', 'EXTRA_TIME', 'OVERTIME', 'SHOOTOUT')")
-        return v
+        return value
 
     @validator("competitor_type")
-    def competitor_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("PERSON", "ENTITY"):
+    def competitor_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("PERSON", "ENTITY"):
             raise ValueError("must be one of enum values ('PERSON', 'ENTITY')")
-        return v
+        return value
 
     @validator("external_id")
-    def external_id_validate_regular_expression(cls, v):
-        if v is None:
-            return v
-        if not re.match(r"^[0-9A-Za-z\/_-]+$", v):
+    def external_id_validate_regular_expression(cls, value):
+        """Validates the regular expression"""
+        if value is None:
+            return value
+
+        if not re.match(r"^[0-9A-Za-z\/_-]+$", value):
             raise ValueError(r"must validate the regular expression /^[0-9A-Za-z\/_-]+$/")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -416,15 +429,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> FixturePutBody:
         """Create an instance of FixturePutBody from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return FixturePutBody.parse_obj(obj)
 
         _obj = FixturePutBody.parse_obj(
             {
                 "season_id": obj.get("seasonId"),
                 "practice_drill_type": obj.get("practiceDrillType"),
                 "international_reference": obj.get("internationalReference"),
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixture_roster_model.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixture_roster_model.py`

 * *Files 2% similar despite different names*

```diff
@@ -14,15 +14,14 @@
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
 from datetime import datetime
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr, constr, validator
 
 from atriumsports.datacore.openapi.models.fixture_entities_model_entity import FixtureEntitiesModelEntity
 from atriumsports.datacore.openapi.models.fixture_persons_model_person import FixturePersonsModelPerson
 from atriumsports.datacore.openapi.models.fixture_progressions_model_fixture import FixtureProgressionsModelFixture
@@ -64,22 +63,26 @@
         "position",
         "externalId",
         "updated",
         "added",
     ]
 
     @validator("external_id")
-    def external_id_validate_regular_expression(cls, v):
-        if v is None:
-            return v
-        if not re.match(r"^[0-9A-Za-z\/_-]+$", v):
+    def external_id_validate_regular_expression(cls, value):
+        """Validates the regular expression"""
+        if value is None:
+            return value
+
+        if not re.match(r"^[0-9A-Za-z\/_-]+$", value):
             raise ValueError(r"must validate the regular expression /^[0-9A-Za-z\/_-]+$/")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -134,15 +137,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> FixtureRosterModel:
         """Create an instance of FixtureRosterModel from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return FixtureRosterModel.parse_obj(obj)
 
         _obj = FixtureRosterModel.parse_obj(
             {
                 "fixture_id": obj.get("fixtureId"),
                 "fixture": FixtureProgressionsModelFixture.from_dict(obj.get("fixture"))
                 if obj.get("fixture") is not None
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixture_roster_model_organization.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixture_pbp_model_organization.py`

 * *Files 10% similar despite different names*

```diff
@@ -13,63 +13,66 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr, validator
 
 
-class FixtureRosterModelOrganization(BaseModel):
+class FixturePbpModelOrganization(BaseModel):
     """
-    The organization that this fixture roster belongs to
+    The organization that this fixture_pbp belongs to
     """
 
     resource_type: Optional[StrictStr] = Field(None, alias="resourceType")
     id: Optional[StrictStr] = Field(None, description="Unique identifier for this resource")
     __properties = ["resourceType", "id"]
 
     @validator("resource_type")
-    def resource_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("organizations"):
+    def resource_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("organizations"):
             raise ValueError("must be one of enum values ('organizations')")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> FixtureRosterModelOrganization:
-        """Create an instance of FixtureRosterModelOrganization from a JSON string"""
+    def from_json(cls, json_str: str) -> FixturePbpModelOrganization:
+        """Create an instance of FixturePbpModelOrganization from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
     def to_dict(self):
         """Returns the dictionary representation of the model using alias"""
         _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> FixtureRosterModelOrganization:
-        """Create an instance of FixtureRosterModelOrganization from a dict"""
+    def from_dict(cls, obj: dict) -> FixturePbpModelOrganization:
+        """Create an instance of FixturePbpModelOrganization from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
-            return FixtureRosterModelOrganization.parse_obj(obj)
+        if not isinstance(obj, dict):
+            return FixturePbpModelOrganization.parse_obj(obj)
 
-        _obj = FixtureRosterModelOrganization.parse_obj({"resource_type": obj.get("resourceType"), "id": obj.get("id")})
+        _obj = FixturePbpModelOrganization.parse_obj({"resource_type": obj.get("resourceType"), "id": obj.get("id")})
         return _obj
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixture_roster_post_body.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixture_roster_post_body.py`

 * *Files 2% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr, constr, validator
 
 
 class FixtureRosterPostBody(BaseModel):
     """
@@ -35,22 +34,26 @@
     position: Optional[constr(strict=True, max_length=100)] = Field(None, description="Playing position")
     external_id: Optional[constr(strict=True, max_length=150)] = Field(
         None, alias="externalId", description="The Id of the data as set by the provider of the data"
     )
     __properties = ["fixtureId", "entityId", "personId", "bib", "position", "externalId"]
 
     @validator("external_id")
-    def external_id_validate_regular_expression(cls, v):
-        if v is None:
-            return v
-        if not re.match(r"^[0-9A-Za-z\/_-]+$", v):
+    def external_id_validate_regular_expression(cls, value):
+        """Validates the regular expression"""
+        if value is None:
+            return value
+
+        if not re.match(r"^[0-9A-Za-z\/_-]+$", value):
             raise ValueError(r"must validate the regular expression /^[0-9A-Za-z\/_-]+$/")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -85,15 +88,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> FixtureRosterPostBody:
         """Create an instance of FixtureRosterPostBody from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return FixtureRosterPostBody.parse_obj(obj)
 
         _obj = FixtureRosterPostBody.parse_obj(
             {
                 "fixture_id": obj.get("fixtureId"),
                 "entity_id": obj.get("entityId"),
                 "person_id": obj.get("personId"),
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixture_roster_response.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixture_roster_response.py`

 * *Files 2% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import List, Optional
 
 from pydantic import BaseModel, conlist
 
 from atriumsports.datacore.openapi.models.fixture_roster_model import FixtureRosterModel
 from atriumsports.datacore.openapi.models.included_data import IncludedData
 from atriumsports.datacore.openapi.models.response_links import ResponseLinks
@@ -36,14 +35,16 @@
     meta: Optional[ResponseMetaData] = None
     links: Optional[ResponseLinks] = None
     included: Optional[IncludedData] = None
     data: Optional[conlist(FixtureRosterModel)] = None
     __properties = ["meta", "links", "included", "data"]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -79,15 +80,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> FixtureRosterResponse:
         """Create an instance of FixtureRosterResponse from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return FixtureRosterResponse.parse_obj(obj)
 
         _obj = FixtureRosterResponse.parse_obj(
             {
                 "meta": ResponseMetaData.from_dict(obj.get("meta")) if obj.get("meta") is not None else None,
                 "links": ResponseLinks.from_dict(obj.get("links")) if obj.get("links") is not None else None,
                 "included": IncludedData.from_dict(obj.get("included")) if obj.get("included") is not None else None,
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixture_videosteam_post_body.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixture_videosteam_post_body.py`

 * *Files 10% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr, constr, validator
 
 
 class FixtureVideosteamPostBody(BaseModel):
     """
@@ -34,30 +33,36 @@
     )
     platform_provider: Optional[constr(strict=True, max_length=30)] = Field(
         "5STREAM", alias="platformProvider", description="Video Provider platform >- `5STREAM` 5Stream "
     )
     __properties = ["fixtureId", "locale", "platformProvider"]
 
     @validator("locale")
-    def locale_validate_regular_expression(cls, v):
-        if v is None:
-            return v
-        if not re.match(r"^[a-z]{2,2}-[A-Z]{2,2}$", v):
+    def locale_validate_regular_expression(cls, value):
+        """Validates the regular expression"""
+        if value is None:
+            return value
+
+        if not re.match(r"^[a-z]{2,2}-[A-Z]{2,2}$", value):
             raise ValueError(r"must validate the regular expression /^[a-z]{2,2}-[A-Z]{2,2}$/")
-        return v
+        return value
 
     @validator("platform_provider")
-    def platform_provider_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("5STREAM"):
+    def platform_provider_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("5STREAM"):
             raise ValueError("must be one of enum values ('5STREAM')")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -77,15 +82,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> FixtureVideosteamPostBody:
         """Create an instance of FixtureVideosteamPostBody from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return FixtureVideosteamPostBody.parse_obj(obj)
 
         _obj = FixtureVideosteamPostBody.parse_obj(
             {
                 "fixture_id": obj.get("fixtureId"),
                 "locale": obj.get("locale"),
                 "platform_provider": obj.get("platformProvider")
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixtures_by_entity_model.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixtures_by_entity_model.py`

 * *Files 3% similar despite different names*

```diff
@@ -14,15 +14,14 @@
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
 from datetime import datetime
-from inspect import getfullargspec
 from typing import List, Optional
 
 from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr, conlist, constr, validator
 
 from atriumsports.datacore.openapi.models.environmental_details import EnvironmentalDetails
 from atriumsports.datacore.openapi.models.fixture_competitor import FixtureCompetitor
 from atriumsports.datacore.openapi.models.fixture_participant import FixtureParticipant
@@ -227,77 +226,91 @@
         "added",
         "estimatedFinishTimeUTC",
         "featureMatch",
         "seriesFixtureNumber",
     ]
 
     @validator("practice_drill_type")
-    def practice_drill_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("DRILL", "GAME", "FITNESS", "OTHER"):
+    def practice_drill_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("DRILL", "GAME", "FITNESS", "OTHER"):
             raise ValueError("must be one of enum values ('DRILL', 'GAME', 'FITNESS', 'OTHER')")
-        return v
+        return value
 
     @validator("status")
-    def status_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in (
+    def status_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in (
             "IF_NEEDED",
             "SCHEDULED",
             "BYE",
             "PENDING",
             "IN_PROGRESS",
             "FINISHED",
             "CONFIRMED",
             "POSTPONED",
             "CANCELLED",
             "ABANDONED",
         ):
             raise ValueError(
                 "must be one of enum values ('IF_NEEDED', 'SCHEDULED', 'BYE', 'PENDING', 'IN_PROGRESS', 'FINISHED', 'CONFIRMED', 'POSTPONED', 'CANCELLED', 'ABANDONED')"
             )
-        return v
+        return value
 
     @validator("fixture_type")
-    def fixture_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("ALL_STAR", "PRESEASON", "REGULAR", "FINAL", "PLAYOFF", "FRIENDLY", "DEMONSTRATION"):
+    def fixture_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("ALL_STAR", "PRESEASON", "REGULAR", "FINAL", "PLAYOFF", "FRIENDLY", "DEMONSTRATION"):
             raise ValueError(
                 "must be one of enum values ('ALL_STAR', 'PRESEASON', 'REGULAR', 'FINAL', 'PLAYOFF', 'FRIENDLY', 'DEMONSTRATION')"
             )
-        return v
+        return value
 
     @validator("maximum_period_type_used")
-    def maximum_period_type_used_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("REGULAR", "EXTRA_TIME", "OVERTIME", "SHOOTOUT"):
+    def maximum_period_type_used_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("REGULAR", "EXTRA_TIME", "OVERTIME", "SHOOTOUT"):
             raise ValueError("must be one of enum values ('REGULAR', 'EXTRA_TIME', 'OVERTIME', 'SHOOTOUT')")
-        return v
+        return value
 
     @validator("competitor_type")
-    def competitor_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("PERSON", "ENTITY"):
+    def competitor_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("PERSON", "ENTITY"):
             raise ValueError("must be one of enum values ('PERSON', 'ENTITY')")
-        return v
+        return value
 
     @validator("external_id")
-    def external_id_validate_regular_expression(cls, v):
-        if v is None:
-            return v
-        if not re.match(r"^[0-9A-Za-z\/_-]+$", v):
+    def external_id_validate_regular_expression(cls, value):
+        """Validates the regular expression"""
+        if value is None:
+            return value
+
+        if not re.match(r"^[0-9A-Za-z\/_-]+$", value):
             raise ValueError(r"must validate the regular expression /^[0-9A-Za-z\/_-]+$/")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -513,15 +526,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> FixturesByEntityModel:
         """Create an instance of FixturesByEntityModel from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return FixturesByEntityModel.parse_obj(obj)
 
         _obj = FixturesByEntityModel.parse_obj(
             {
                 "fixture_id": obj.get("fixtureId"),
                 "organization_id": obj.get("organizationId"),
                 "organization": FixturesModelOrganization.from_dict(obj.get("organization"))
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixtures_by_entity_response.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixtures_by_entity_response.py`

 * *Files 2% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import List, Optional
 
 from pydantic import BaseModel, conlist
 
 from atriumsports.datacore.openapi.models.fixtures_by_entity_model import FixturesByEntityModel
 from atriumsports.datacore.openapi.models.included_data import IncludedData
 from atriumsports.datacore.openapi.models.response_links import ResponseLinks
@@ -36,14 +35,16 @@
     meta: Optional[ResponseMetaData] = None
     links: Optional[ResponseLinks] = None
     included: Optional[IncludedData] = None
     data: Optional[conlist(FixturesByEntityModel)] = None
     __properties = ["meta", "links", "included", "data"]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -79,15 +80,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> FixturesByEntityResponse:
         """Create an instance of FixturesByEntityResponse from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return FixturesByEntityResponse.parse_obj(obj)
 
         _obj = FixturesByEntityResponse.parse_obj(
             {
                 "meta": ResponseMetaData.from_dict(obj.get("meta")) if obj.get("meta") is not None else None,
                 "links": ResponseLinks.from_dict(obj.get("links")) if obj.get("links") is not None else None,
                 "included": IncludedData.from_dict(obj.get("included")) if obj.get("included") is not None else None,
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixtures_model.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixtures_model.py`

 * *Files 2% similar despite different names*

```diff
@@ -14,15 +14,14 @@
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
 from datetime import datetime
-from inspect import getfullargspec
 from typing import List, Optional
 
 from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr, conlist, constr, validator
 
 from atriumsports.datacore.openapi.models.environmental_details import EnvironmentalDetails
 from atriumsports.datacore.openapi.models.fixture_competitor import FixtureCompetitor
 from atriumsports.datacore.openapi.models.fixture_participant import FixtureParticipant
@@ -227,77 +226,91 @@
         "added",
         "estimatedFinishTimeUTC",
         "featureMatch",
         "seriesFixtureNumber",
     ]
 
     @validator("practice_drill_type")
-    def practice_drill_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("DRILL", "GAME", "FITNESS", "OTHER"):
+    def practice_drill_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("DRILL", "GAME", "FITNESS", "OTHER"):
             raise ValueError("must be one of enum values ('DRILL', 'GAME', 'FITNESS', 'OTHER')")
-        return v
+        return value
 
     @validator("status")
-    def status_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in (
+    def status_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in (
             "IF_NEEDED",
             "SCHEDULED",
             "BYE",
             "PENDING",
             "IN_PROGRESS",
             "FINISHED",
             "CONFIRMED",
             "POSTPONED",
             "CANCELLED",
             "ABANDONED",
         ):
             raise ValueError(
                 "must be one of enum values ('IF_NEEDED', 'SCHEDULED', 'BYE', 'PENDING', 'IN_PROGRESS', 'FINISHED', 'CONFIRMED', 'POSTPONED', 'CANCELLED', 'ABANDONED')"
             )
-        return v
+        return value
 
     @validator("fixture_type")
-    def fixture_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("ALL_STAR", "PRESEASON", "REGULAR", "FINAL", "PLAYOFF", "FRIENDLY", "DEMONSTRATION"):
+    def fixture_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("ALL_STAR", "PRESEASON", "REGULAR", "FINAL", "PLAYOFF", "FRIENDLY", "DEMONSTRATION"):
             raise ValueError(
                 "must be one of enum values ('ALL_STAR', 'PRESEASON', 'REGULAR', 'FINAL', 'PLAYOFF', 'FRIENDLY', 'DEMONSTRATION')"
             )
-        return v
+        return value
 
     @validator("maximum_period_type_used")
-    def maximum_period_type_used_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("REGULAR", "EXTRA_TIME", "OVERTIME", "SHOOTOUT"):
+    def maximum_period_type_used_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("REGULAR", "EXTRA_TIME", "OVERTIME", "SHOOTOUT"):
             raise ValueError("must be one of enum values ('REGULAR', 'EXTRA_TIME', 'OVERTIME', 'SHOOTOUT')")
-        return v
+        return value
 
     @validator("competitor_type")
-    def competitor_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("PERSON", "ENTITY"):
+    def competitor_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("PERSON", "ENTITY"):
             raise ValueError("must be one of enum values ('PERSON', 'ENTITY')")
-        return v
+        return value
 
     @validator("external_id")
-    def external_id_validate_regular_expression(cls, v):
-        if v is None:
-            return v
-        if not re.match(r"^[0-9A-Za-z\/_-]+$", v):
+    def external_id_validate_regular_expression(cls, value):
+        """Validates the regular expression"""
+        if value is None:
+            return value
+
+        if not re.match(r"^[0-9A-Za-z\/_-]+$", value):
             raise ValueError(r"must validate the regular expression /^[0-9A-Za-z\/_-]+$/")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -513,15 +526,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> FixturesModel:
         """Create an instance of FixturesModel from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return FixturesModel.parse_obj(obj)
 
         _obj = FixturesModel.parse_obj(
             {
                 "fixture_id": obj.get("fixtureId"),
                 "organization_id": obj.get("organizationId"),
                 "organization": FixturesModelOrganization.from_dict(obj.get("organization"))
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixtures_model_fixture_profile.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixtures_model_fixture_profile.py`

 * *Files 8% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr, validator
 
 
 class FixturesModelFixtureProfile(BaseModel):
     """
@@ -29,22 +28,26 @@
     """
 
     resource_type: Optional[StrictStr] = Field(None, alias="resourceType")
     id: Optional[StrictStr] = Field(None, description="Unique identifier for this resource")
     __properties = ["resourceType", "id"]
 
     @validator("resource_type")
-    def resource_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("fixture_profiles"):
+    def resource_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("fixture_profiles"):
             raise ValueError("must be one of enum values ('fixture_profiles')")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -64,12 +67,12 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> FixturesModelFixtureProfile:
         """Create an instance of FixturesModelFixtureProfile from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return FixturesModelFixtureProfile.parse_obj(obj)
 
         _obj = FixturesModelFixtureProfile.parse_obj({"resource_type": obj.get("resourceType"), "id": obj.get("id")})
         return _obj
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixtures_model_organization.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixtures_model_organization.py`

 * *Files 8% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr, validator
 
 
 class FixturesModelOrganization(BaseModel):
     """
@@ -29,22 +28,26 @@
     """
 
     resource_type: Optional[StrictStr] = Field(None, alias="resourceType")
     id: Optional[StrictStr] = Field(None, description="Unique identifier for this resource")
     __properties = ["resourceType", "id"]
 
     @validator("resource_type")
-    def resource_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("organizations"):
+    def resource_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("organizations"):
             raise ValueError("must be one of enum values ('organizations')")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -64,12 +67,12 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> FixturesModelOrganization:
         """Create an instance of FixturesModelOrganization from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return FixturesModelOrganization.parse_obj(obj)
 
         _obj = FixturesModelOrganization.parse_obj({"resource_type": obj.get("resourceType"), "id": obj.get("id")})
         return _obj
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixtures_model_round.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixtures_model_round.py`

 * *Files 5% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr, validator
 
 
 class FixturesModelRound(BaseModel):
     """
@@ -29,22 +28,26 @@
     """
 
     resource_type: Optional[StrictStr] = Field(None, alias="resourceType")
     id: Optional[StrictStr] = Field(None, description="Unique identifier for this resource")
     __properties = ["resourceType", "id"]
 
     @validator("resource_type")
-    def resource_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("season_rounds"):
+    def resource_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("season_rounds"):
             raise ValueError("must be one of enum values ('season_rounds')")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -64,12 +67,12 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> FixturesModelRound:
         """Create an instance of FixturesModelRound from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return FixturesModelRound.parse_obj(obj)
 
         _obj = FixturesModelRound.parse_obj({"resource_type": obj.get("resourceType"), "id": obj.get("id")})
         return _obj
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixtures_model_series.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixtures_model_series.py`

 * *Files 5% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr, validator
 
 
 class FixturesModelSeries(BaseModel):
     """
@@ -29,22 +28,26 @@
     """
 
     resource_type: Optional[StrictStr] = Field(None, alias="resourceType")
     id: Optional[StrictStr] = Field(None, description="Unique identifier for this resource")
     __properties = ["resourceType", "id"]
 
     @validator("resource_type")
-    def resource_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("season_series"):
+    def resource_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("season_series"):
             raise ValueError("must be one of enum values ('season_series')")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -64,12 +67,12 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> FixturesModelSeries:
         """Create an instance of FixturesModelSeries from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return FixturesModelSeries.parse_obj(obj)
 
         _obj = FixturesModelSeries.parse_obj({"resource_type": obj.get("resourceType"), "id": obj.get("id")})
         return _obj
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixtures_model_venue.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixtures_model_venue.py`

 * *Files 8% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr, validator
 
 
 class FixturesModelVenue(BaseModel):
     """
@@ -29,22 +28,26 @@
     """
 
     resource_type: Optional[StrictStr] = Field(None, alias="resourceType")
     id: Optional[StrictStr] = Field(None, description="Unique identifier for this resource")
     __properties = ["resourceType", "id"]
 
     @validator("resource_type")
-    def resource_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("venues"):
+    def resource_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("venues"):
             raise ValueError("must be one of enum values ('venues')")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -64,12 +67,12 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> FixturesModelVenue:
         """Create an instance of FixturesModelVenue from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return FixturesModelVenue.parse_obj(obj)
 
         _obj = FixturesModelVenue.parse_obj({"resource_type": obj.get("resourceType"), "id": obj.get("id")})
         return _obj
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/fixtures_response.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/fixtures_response.py`

 * *Files 2% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import List, Optional
 
 from pydantic import BaseModel, conlist
 
 from atriumsports.datacore.openapi.models.fixtures_model import FixturesModel
 from atriumsports.datacore.openapi.models.included_data import IncludedData
 from atriumsports.datacore.openapi.models.response_links import ResponseLinks
@@ -36,14 +35,16 @@
     meta: Optional[ResponseMetaData] = None
     links: Optional[ResponseLinks] = None
     included: Optional[IncludedData] = None
     data: Optional[conlist(FixturesModel)] = None
     __properties = ["meta", "links", "included", "data"]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -79,15 +80,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> FixturesResponse:
         """Create an instance of FixturesResponse from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return FixturesResponse.parse_obj(obj)
 
         _obj = FixturesResponse.parse_obj(
             {
                 "meta": ResponseMetaData.from_dict(obj.get("meta")) if obj.get("meta") is not None else None,
                 "links": ResponseLinks.from_dict(obj.get("links")) if obj.get("links") is not None else None,
                 "included": IncludedData.from_dict(obj.get("included")) if obj.get("included") is not None else None,
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/game_log_entity_model.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/game_log_entity_model.py`

 * *Files 2% similar despite different names*

```diff
@@ -14,15 +14,14 @@
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
 from datetime import datetime
-from inspect import getfullargspec
 from typing import Any, Dict, Optional
 
 from pydantic import BaseModel, Field, StrictInt, StrictStr, constr
 
 from atriumsports.datacore.openapi.models.fixture_entities_model_entity import FixtureEntitiesModelEntity
 from atriumsports.datacore.openapi.models.fixture_progressions_model_fixture import FixtureProgressionsModelFixture
 from atriumsports.datacore.openapi.models.game_log_entity_model_organization import GameLogEntityModelOrganization
@@ -59,14 +58,16 @@
         "periodId",
         "section",
         "updated",
         "added",
     ]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -103,15 +104,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> GameLogEntityModel:
         """Create an instance of GameLogEntityModel from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return GameLogEntityModel.parse_obj(obj)
 
         _obj = GameLogEntityModel.parse_obj(
             {
                 "organization_id": obj.get("organizationId"),
                 "organization": GameLogEntityModelOrganization.from_dict(obj.get("organization"))
                 if obj.get("organization") is not None
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/game_log_entity_model_organization.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/game_log_entity_model_organization.py`

 * *Files 10% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr, validator
 
 
 class GameLogEntityModelOrganization(BaseModel):
     """
@@ -29,22 +28,26 @@
     """
 
     resource_type: Optional[StrictStr] = Field(None, alias="resourceType")
     id: Optional[StrictStr] = Field(None, description="Unique identifier for this resource")
     __properties = ["resourceType", "id"]
 
     @validator("resource_type")
-    def resource_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("organizations"):
+    def resource_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("organizations"):
             raise ValueError("must be one of enum values ('organizations')")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -64,12 +67,12 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> GameLogEntityModelOrganization:
         """Create an instance of GameLogEntityModelOrganization from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return GameLogEntityModelOrganization.parse_obj(obj)
 
         _obj = GameLogEntityModelOrganization.parse_obj({"resource_type": obj.get("resourceType"), "id": obj.get("id")})
         return _obj
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/game_log_entity_response.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/game_log_entity_response.py`

 * *Files 2% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import List, Optional
 
 from pydantic import BaseModel, conlist
 
 from atriumsports.datacore.openapi.models.game_log_entity_model import GameLogEntityModel
 from atriumsports.datacore.openapi.models.included_data import IncludedData
 from atriumsports.datacore.openapi.models.response_links import ResponseLinks
@@ -36,14 +35,16 @@
     meta: Optional[ResponseMetaData] = None
     links: Optional[ResponseLinks] = None
     included: Optional[IncludedData] = None
     data: Optional[conlist(GameLogEntityModel)] = None
     __properties = ["meta", "links", "included", "data"]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -79,15 +80,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> GameLogEntityResponse:
         """Create an instance of GameLogEntityResponse from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return GameLogEntityResponse.parse_obj(obj)
 
         _obj = GameLogEntityResponse.parse_obj(
             {
                 "meta": ResponseMetaData.from_dict(obj.get("meta")) if obj.get("meta") is not None else None,
                 "links": ResponseLinks.from_dict(obj.get("links")) if obj.get("links") is not None else None,
                 "included": IncludedData.from_dict(obj.get("included")) if obj.get("included") is not None else None,
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/game_log_person_model.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/game_log_person_model.py`

 * *Files 1% similar despite different names*

```diff
@@ -14,15 +14,14 @@
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
 from datetime import datetime
-from inspect import getfullargspec
 from typing import Any, Dict, Optional
 
 from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr, constr
 
 from atriumsports.datacore.openapi.models.fixture_entities_model_entity import FixtureEntitiesModelEntity
 from atriumsports.datacore.openapi.models.fixture_persons_model_person import FixturePersonsModelPerson
 from atriumsports.datacore.openapi.models.fixture_progressions_model_fixture import FixtureProgressionsModelFixture
@@ -84,14 +83,16 @@
         "isPlayer",
         "isTeamOfficial",
         "updated",
         "added",
     ]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -146,15 +147,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> GameLogPersonModel:
         """Create an instance of GameLogPersonModel from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return GameLogPersonModel.parse_obj(obj)
 
         _obj = GameLogPersonModel.parse_obj(
             {
                 "person_id": obj.get("personId"),
                 "person": FixturePersonsModelPerson.from_dict(obj.get("person"))
                 if obj.get("person") is not None
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/game_log_person_model_organization.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/game_log_person_model_organization.py`

 * *Files 10% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr, validator
 
 
 class GameLogPersonModelOrganization(BaseModel):
     """
@@ -29,22 +28,26 @@
     """
 
     resource_type: Optional[StrictStr] = Field(None, alias="resourceType")
     id: Optional[StrictStr] = Field(None, description="Unique identifier for this resource")
     __properties = ["resourceType", "id"]
 
     @validator("resource_type")
-    def resource_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("organizations"):
+    def resource_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("organizations"):
             raise ValueError("must be one of enum values ('organizations')")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -64,12 +67,12 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> GameLogPersonModelOrganization:
         """Create an instance of GameLogPersonModelOrganization from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return GameLogPersonModelOrganization.parse_obj(obj)
 
         _obj = GameLogPersonModelOrganization.parse_obj({"resource_type": obj.get("resourceType"), "id": obj.get("id")})
         return _obj
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/game_log_person_response.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/game_log_person_response.py`

 * *Files 2% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import List, Optional
 
 from pydantic import BaseModel, conlist
 
 from atriumsports.datacore.openapi.models.game_log_person_model import GameLogPersonModel
 from atriumsports.datacore.openapi.models.included_data import IncludedData
 from atriumsports.datacore.openapi.models.response_links import ResponseLinks
@@ -36,14 +35,16 @@
     meta: Optional[ResponseMetaData] = None
     links: Optional[ResponseLinks] = None
     included: Optional[IncludedData] = None
     data: Optional[conlist(GameLogPersonModel)] = None
     __properties = ["meta", "links", "included", "data"]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -79,15 +80,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> GameLogPersonResponse:
         """Create an instance of GameLogPersonResponse from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return GameLogPersonResponse.parse_obj(obj)
 
         _obj = GameLogPersonResponse.parse_obj(
             {
                 "meta": ResponseMetaData.from_dict(obj.get("meta")) if obj.get("meta") is not None else None,
                 "links": ResponseLinks.from_dict(obj.get("links")) if obj.get("links") is not None else None,
                 "included": IncludedData.from_dict(obj.get("included")) if obj.get("included") is not None else None,
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/head_to_head_identification.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/head_to_head_identification.py`

 * *Files 4% similar despite different names*

```diff
@@ -13,29 +13,30 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr
 
 
 class HeadToHeadIdentification(BaseModel):
     """
     HeadToHeadIdentification
     """
 
     check_field: Optional[StrictStr] = Field(None, alias="checkField", description="Field to check")
     __properties = ["checkField"]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -55,12 +56,12 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> HeadToHeadIdentification:
         """Create an instance of HeadToHeadIdentification from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return HeadToHeadIdentification.parse_obj(obj)
 
         _obj = HeadToHeadIdentification.parse_obj({"check_field": obj.get("checkField")})
         return _obj
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/head_to_head_identification_for_subsequent_checks.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/head_to_head_identification_for_subsequent_checks.py`

 * *Files 8% similar despite different names*

```diff
@@ -13,29 +13,30 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr
 
 
 class HeadToHeadIdentificationForSubsequentChecks(BaseModel):
     """
     HeadToHeadIdentificationForSubsequentChecks
     """
 
     check_field: Optional[StrictStr] = Field(None, alias="checkField", description="Field to check")
     __properties = ["checkField"]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -55,12 +56,12 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> HeadToHeadIdentificationForSubsequentChecks:
         """Create an instance of HeadToHeadIdentificationForSubsequentChecks from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return HeadToHeadIdentificationForSubsequentChecks.parse_obj(obj)
 
         _obj = HeadToHeadIdentificationForSubsequentChecks.parse_obj({"check_field": obj.get("checkField")})
         return _obj
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/head_to_head_resolution.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/head_to_head_resolution.py`

 * *Files 14% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr, validator
 
 
 class HeadToHeadResolution(BaseModel):
     """
@@ -29,22 +28,26 @@
     """
 
     sort_field: Optional[StrictStr] = Field(None, alias="sortField", description="Sort Field")
     sort_direction: Optional[StrictStr] = Field(None, alias="sortDirection", description="Sort direction")
     __properties = ["sortField", "sortDirection"]
 
     @validator("sort_direction")
-    def sort_direction_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("ASC", "DESC"):
+    def sort_direction_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("ASC", "DESC"):
             raise ValueError("must be one of enum values ('ASC', 'DESC')")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -64,14 +67,14 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> HeadToHeadResolution:
         """Create an instance of HeadToHeadResolution from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return HeadToHeadResolution.parse_obj(obj)
 
         _obj = HeadToHeadResolution.parse_obj(
             {"sort_field": obj.get("sortField"), "sort_direction": obj.get("sortDirection")}
         )
         return _obj
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/head_to_head_resolution_for_extra_depth_h2h_s.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/head_to_head_resolution_for_extra_depth_h2h_s.py`

 * *Files 4% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr, validator
 
 
 class HeadToHeadResolutionForExtraDepthH2hS(BaseModel):
     """
@@ -29,22 +28,26 @@
     """
 
     sort_field: Optional[StrictStr] = Field(None, alias="sortField", description="Sort Field")
     sort_direction: Optional[StrictStr] = Field(None, alias="sortDirection", description="Sort direction")
     __properties = ["sortField", "sortDirection"]
 
     @validator("sort_direction")
-    def sort_direction_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("ASC", "DESC"):
+    def sort_direction_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("ASC", "DESC"):
             raise ValueError("must be one of enum values ('ASC', 'DESC')")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -64,14 +67,14 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> HeadToHeadResolutionForExtraDepthH2hS:
         """Create an instance of HeadToHeadResolutionForExtraDepthH2hS from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return HeadToHeadResolutionForExtraDepthH2hS.parse_obj(obj)
 
         _obj = HeadToHeadResolutionForExtraDepthH2hS.parse_obj(
             {"sort_field": obj.get("sortField"), "sort_direction": obj.get("sortDirection")}
         )
         return _obj
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/images_model.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/images_model.py`

 * *Files 11% similar despite different names*

```diff
@@ -14,15 +14,14 @@
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
 from datetime import datetime
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictInt, StrictStr, constr, validator
 
 from atriumsports.datacore.openapi.models.images_model_organization import ImagesModelOrganization
 
 
@@ -94,78 +93,90 @@
         "maximumHeight",
         "maximumWidth",
         "updated",
         "added",
     ]
 
     @validator("base_type")
-    def base_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in (
+    def base_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in (
             "PERSON",
             "ENTITY",
             "ENTITYGROUP",
             "COMPETITION",
             "SEASON",
             "LEAGUE",
             "ORGANIZATION",
             "DIVISION",
             "CONFERENCE",
         ):
             raise ValueError(
                 "must be one of enum values ('PERSON', 'ENTITY', 'ENTITYGROUP', 'COMPETITION', 'SEASON', 'LEAGUE', 'ORGANIZATION', 'DIVISION', 'CONFERENCE')"
             )
-        return v
+        return value
 
     @validator("file_type")
-    def file_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("JPG", "PNG", "SVG"):
+    def file_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("JPG", "PNG", "SVG"):
             raise ValueError("must be one of enum values ('JPG', 'PNG', 'SVG')")
-        return v
+        return value
 
     @validator("image_type")
-    def image_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in (
+    def image_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in (
             "LOGO",
             "LOGO_ALTERNATE",
             "LOGO_BACKGROUND",
             "PERSON_HEAD",
             "PERSON_WAIST",
             "PERSON_POSE",
             "TEAM_PHOTO",
         ):
             raise ValueError(
                 "must be one of enum values ('LOGO', 'LOGO_ALTERNATE', 'LOGO_BACKGROUND', 'PERSON_HEAD', 'PERSON_WAIST', 'PERSON_POSE', 'TEAM_PHOTO')"
             )
-        return v
+        return value
 
     @validator("secondary_type")
-    def secondary_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("ENTITY", "ENTITYGROUP", "COMPETITION", "SEASON", "LEAGUE", "DIVISION", "CONFERENCE"):
+    def secondary_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("ENTITY", "ENTITYGROUP", "COMPETITION", "SEASON", "LEAGUE", "DIVISION", "CONFERENCE"):
             raise ValueError(
                 "must be one of enum values ('ENTITY', 'ENTITYGROUP', 'COMPETITION', 'SEASON', 'LEAGUE', 'DIVISION', 'CONFERENCE')"
             )
-        return v
+        return value
 
     @validator("rating")
-    def rating_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("LOW", "MEDIUM", "HIGH"):
+    def rating_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("LOW", "MEDIUM", "HIGH"):
             raise ValueError("must be one of enum values ('LOW', 'MEDIUM', 'HIGH')")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -202,15 +213,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> ImagesModel:
         """Create an instance of ImagesModel from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return ImagesModel.parse_obj(obj)
 
         _obj = ImagesModel.parse_obj(
             {
                 "image_id": obj.get("imageId"),
                 "organization_id": obj.get("organizationId"),
                 "organization": ImagesModelOrganization.from_dict(obj.get("organization"))
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/images_model_organization.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_pools_model_organization.py`

 * *Files 11% similar despite different names*

```diff
@@ -13,63 +13,66 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr, validator
 
 
-class ImagesModelOrganization(BaseModel):
+class SeasonPoolsModelOrganization(BaseModel):
     """
-    The organization that this images belongs to
+    The organization that this pool belongs to
     """
 
     resource_type: Optional[StrictStr] = Field(None, alias="resourceType")
     id: Optional[StrictStr] = Field(None, description="Unique identifier for this resource")
     __properties = ["resourceType", "id"]
 
     @validator("resource_type")
-    def resource_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("organizations"):
+    def resource_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("organizations"):
             raise ValueError("must be one of enum values ('organizations')")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> ImagesModelOrganization:
-        """Create an instance of ImagesModelOrganization from a JSON string"""
+    def from_json(cls, json_str: str) -> SeasonPoolsModelOrganization:
+        """Create an instance of SeasonPoolsModelOrganization from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
     def to_dict(self):
         """Returns the dictionary representation of the model using alias"""
         _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> ImagesModelOrganization:
-        """Create an instance of ImagesModelOrganization from a dict"""
+    def from_dict(cls, obj: dict) -> SeasonPoolsModelOrganization:
+        """Create an instance of SeasonPoolsModelOrganization from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
-            return ImagesModelOrganization.parse_obj(obj)
+        if not isinstance(obj, dict):
+            return SeasonPoolsModelOrganization.parse_obj(obj)
 
-        _obj = ImagesModelOrganization.parse_obj({"resource_type": obj.get("resourceType"), "id": obj.get("id")})
+        _obj = SeasonPoolsModelOrganization.parse_obj({"resource_type": obj.get("resourceType"), "id": obj.get("id")})
         return _obj
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/images_post_body.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/images_post_body.py`

 * *Files 7% similar despite different names*

```diff
@@ -13,28 +13,29 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 
 from pydantic import BaseModel, Field, constr
 
 
 class ImagesPostBody(BaseModel):
     """
     ImagesPostBody
     """
 
     url: constr(strict=True, max_length=250) = Field(..., description="The URL of the image")
     __properties = ["url"]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -54,12 +55,12 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> ImagesPostBody:
         """Create an instance of ImagesPostBody from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return ImagesPostBody.parse_obj(obj)
 
         _obj = ImagesPostBody.parse_obj({"url": obj.get("url")})
         return _obj
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/images_put_body.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/images_put_body.py`

 * *Files 16% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, constr, validator
 
 
 class ImagesPutBody(BaseModel):
     """
@@ -31,22 +30,26 @@
     rating: Optional[constr(strict=True, max_length=100)] = Field(
         None,
         description="The rating given to the quality of the image.  All images are LOW by default but are set ad MEDIUM if they are large enough and have transparency.  Images are only marked as HIGH if they have been manually reviewed.  You should take your use-case into account when you go to use the image. >- `HIGH` High >- `LOW` Low >- `MEDIUM` Medium ",
     )
     __properties = ["rating"]
 
     @validator("rating")
-    def rating_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("LOW", "MEDIUM", "HIGH"):
+    def rating_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("LOW", "MEDIUM", "HIGH"):
             raise ValueError("must be one of enum values ('LOW', 'MEDIUM', 'HIGH')")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -66,12 +69,12 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> ImagesPutBody:
         """Create an instance of ImagesPutBody from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return ImagesPutBody.parse_obj(obj)
 
         _obj = ImagesPutBody.parse_obj({"rating": obj.get("rating")})
         return _obj
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/images_response.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/images_response.py`

 * *Files 3% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import List, Optional
 
 from pydantic import BaseModel, conlist
 
 from atriumsports.datacore.openapi.models.images_model import ImagesModel
 from atriumsports.datacore.openapi.models.included_data import IncludedData
 from atriumsports.datacore.openapi.models.response_links import ResponseLinks
@@ -36,14 +35,16 @@
     meta: Optional[ResponseMetaData] = None
     links: Optional[ResponseLinks] = None
     included: Optional[IncludedData] = None
     data: Optional[conlist(ImagesModel)] = None
     __properties = ["meta", "links", "included", "data"]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -79,15 +80,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> ImagesResponse:
         """Create an instance of ImagesResponse from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return ImagesResponse.parse_obj(obj)
 
         _obj = ImagesResponse.parse_obj(
             {
                 "meta": ResponseMetaData.from_dict(obj.get("meta")) if obj.get("meta") is not None else None,
                 "links": ResponseLinks.from_dict(obj.get("links")) if obj.get("links") is not None else None,
                 "included": IncludedData.from_dict(obj.get("included")) if obj.get("included") is not None else None,
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/included_data.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/included_data.py`

 * *Files 6% similar despite different names*

```diff
@@ -13,29 +13,30 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Any, Dict, Optional
 
 from pydantic import BaseModel, validator
 
 
 class IncludedData(BaseModel):
     """
     Available if the request used the 'include' parameter.  It contains extra data about resources found in the data block.
     """
 
     resources: Optional[Dict[str, Dict[str, Dict[str, Any]]]] = None
     __properties = ["resources"]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -55,12 +56,12 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> IncludedData:
         """Create an instance of IncludedData from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return IncludedData.parse_obj(obj)
 
         _obj = IncludedData.parse_obj({"resources": obj.get("resources")})
         return _obj
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/leader_criteria_model.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/leader_criteria_model.py`

 * *Files 4% similar despite different names*

```diff
@@ -14,15 +14,14 @@
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
 from datetime import datetime
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr
 
 from atriumsports.datacore.openapi.models.leader_criteria_model_organization import LeaderCriteriaModelOrganization
 
 
@@ -39,14 +38,16 @@
     leader_criteria_id: Optional[StrictStr] = Field(
         None, alias="leaderCriteriaId", description="The unique identifier of the leader criteria"
     )
     name: Optional[StrictStr] = Field(None, description="The name of the criteria")
     __properties = ["added", "organizationId", "organization", "leaderCriteriaId", "name"]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -76,15 +77,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> LeaderCriteriaModel:
         """Create an instance of LeaderCriteriaModel from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return LeaderCriteriaModel.parse_obj(obj)
 
         _obj = LeaderCriteriaModel.parse_obj(
             {
                 "added": obj.get("added"),
                 "organization_id": obj.get("organizationId"),
                 "organization": LeaderCriteriaModelOrganization.from_dict(obj.get("organization"))
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/leader_criteria_model_organization.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/leader_criteria_model_organization.py`

 * *Files 5% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr, validator
 
 
 class LeaderCriteriaModelOrganization(BaseModel):
     """
@@ -29,22 +28,26 @@
     """
 
     resource_type: Optional[StrictStr] = Field(None, alias="resourceType")
     id: Optional[StrictStr] = Field(None, description="Unique identifier for this resource")
     __properties = ["resourceType", "id"]
 
     @validator("resource_type")
-    def resource_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("organizations"):
+    def resource_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("organizations"):
             raise ValueError("must be one of enum values ('organizations')")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -64,14 +67,14 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> LeaderCriteriaModelOrganization:
         """Create an instance of LeaderCriteriaModelOrganization from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return LeaderCriteriaModelOrganization.parse_obj(obj)
 
         _obj = LeaderCriteriaModelOrganization.parse_obj(
             {"resource_type": obj.get("resourceType"), "id": obj.get("id")}
         )
         return _obj
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/leader_criteria_post_body.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/leader_criteria_post_body.py`

 * *Files 5% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr
 
 
 class LeaderCriteriaPostBody(BaseModel):
     """
@@ -31,14 +30,16 @@
     leader_criteria_id: Optional[StrictStr] = Field(
         None, alias="leaderCriteriaId", description="The unique identifier of the leader criteria"
     )
     name: StrictStr = Field(..., description="The name of the criteria")
     __properties = ["leaderCriteriaId", "name"]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -58,14 +59,14 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> LeaderCriteriaPostBody:
         """Create an instance of LeaderCriteriaPostBody from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return LeaderCriteriaPostBody.parse_obj(obj)
 
         _obj = LeaderCriteriaPostBody.parse_obj(
             {"leader_criteria_id": obj.get("leaderCriteriaId"), "name": obj.get("name")}
         )
         return _obj
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/leader_criteria_put_body.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/leader_criteria_put_body.py`

 * *Files 15% similar despite different names*

```diff
@@ -13,29 +13,30 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr
 
 
 class LeaderCriteriaPutBody(BaseModel):
     """
     LeaderCriteriaPutBody
     """
 
     name: Optional[StrictStr] = Field(None, description="The name of the criteria")
     __properties = ["name"]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -55,12 +56,12 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> LeaderCriteriaPutBody:
         """Create an instance of LeaderCriteriaPutBody from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return LeaderCriteriaPutBody.parse_obj(obj)
 
         _obj = LeaderCriteriaPutBody.parse_obj({"name": obj.get("name")})
         return _obj
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/leader_criteria_response.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/leader_criteria_response.py`

 * *Files 2% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import List, Optional
 
 from pydantic import BaseModel, conlist
 
 from atriumsports.datacore.openapi.models.included_data import IncludedData
 from atriumsports.datacore.openapi.models.leader_criteria_model import LeaderCriteriaModel
 from atriumsports.datacore.openapi.models.response_links import ResponseLinks
@@ -36,14 +35,16 @@
     meta: Optional[ResponseMetaData] = None
     links: Optional[ResponseLinks] = None
     included: Optional[IncludedData] = None
     data: Optional[conlist(LeaderCriteriaModel)] = None
     __properties = ["meta", "links", "included", "data"]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -79,15 +80,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> LeaderCriteriaResponse:
         """Create an instance of LeaderCriteriaResponse from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return LeaderCriteriaResponse.parse_obj(obj)
 
         _obj = LeaderCriteriaResponse.parse_obj(
             {
                 "meta": ResponseMetaData.from_dict(obj.get("meta")) if obj.get("meta") is not None else None,
                 "links": ResponseLinks.from_dict(obj.get("links")) if obj.get("links") is not None else None,
                 "included": IncludedData.from_dict(obj.get("included")) if obj.get("included") is not None else None,
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/leader_qualifier_post_body.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/leader_qualifier_post_body.py`

 * *Files 3% similar despite different names*

```diff
@@ -13,18 +13,17 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
-from typing import Optional
+from typing import Optional, Union
 
-from pydantic import BaseModel, Field, StrictFloat, StrictStr, validator
+from pydantic import BaseModel, Field, StrictFloat, StrictInt, StrictStr, validator
 
 
 class LeaderQualifierPostBody(BaseModel):
     """
     LeaderQualifierPostBody
     """
 
@@ -41,35 +40,38 @@
         ..., alias="comparisonField", description="The statistic field to compare against."
     )
     comparison_type: StrictStr = Field(
         ...,
         alias="comparisonType",
         description="Comparison type for the qualifier >- `EQUAL` Equal >- `GREATER_THAN` Greater than >- `GREATER_THAN_EQUAL` Greater than or equal >- `LESS_THAN` Less than >- `LESS_THAN_EQUAL` Less than or equal ",
     )
-    comparison_value: StrictFloat = Field(
+    comparison_value: Union[StrictFloat, StrictInt] = Field(
         ..., alias="comparisonValue", description="Comparison value for the qualifier"
     )
     __properties = [
         "qualifierId",
         "leaderCriteriaId",
         "statisticField",
         "comparisonField",
         "comparisonType",
         "comparisonValue",
     ]
 
     @validator("comparison_type")
-    def comparison_type_validate_enum(cls, v):
-        if v not in ("GREATER_THAN", "LESS_THAN", "EQUAL", "GREATER_THAN_EQUAL", "LESS_THAN_EQUAL"):
+    def comparison_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value not in ("GREATER_THAN", "LESS_THAN", "EQUAL", "GREATER_THAN_EQUAL", "LESS_THAN_EQUAL"):
             raise ValueError(
                 "must be one of enum values ('GREATER_THAN', 'LESS_THAN', 'EQUAL', 'GREATER_THAN_EQUAL', 'LESS_THAN_EQUAL')"
             )
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -89,15 +91,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> LeaderQualifierPostBody:
         """Create an instance of LeaderQualifierPostBody from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return LeaderQualifierPostBody.parse_obj(obj)
 
         _obj = LeaderQualifierPostBody.parse_obj(
             {
                 "qualifier_id": obj.get("qualifierId"),
                 "leader_criteria_id": obj.get("leaderCriteriaId"),
                 "statistic_field": obj.get("statisticField"),
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/leader_qualifier_put_body.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/leader_qualifier_put_body.py`

 * *Files 4% similar despite different names*

```diff
@@ -13,18 +13,17 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
-from typing import Optional
+from typing import Optional, Union
 
-from pydantic import BaseModel, Field, StrictFloat, StrictStr, validator
+from pydantic import BaseModel, Field, StrictFloat, StrictInt, StrictStr, validator
 
 
 class LeaderQualifierPutBody(BaseModel):
     """
     LeaderQualifierPutBody
     """
 
@@ -38,30 +37,34 @@
         None, alias="comparisonField", description="The statistic field to compare against."
     )
     comparison_type: Optional[StrictStr] = Field(
         None,
         alias="comparisonType",
         description="Comparison type for the qualifier >- `EQUAL` Equal >- `GREATER_THAN` Greater than >- `GREATER_THAN_EQUAL` Greater than or equal >- `LESS_THAN` Less than >- `LESS_THAN_EQUAL` Less than or equal ",
     )
-    comparison_value: Optional[StrictFloat] = Field(
+    comparison_value: Optional[Union[StrictFloat, StrictInt]] = Field(
         None, alias="comparisonValue", description="Comparison value for the qualifier"
     )
     __properties = ["leaderCriteriaId", "statisticField", "comparisonField", "comparisonType", "comparisonValue"]
 
     @validator("comparison_type")
-    def comparison_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("GREATER_THAN", "LESS_THAN", "EQUAL", "GREATER_THAN_EQUAL", "LESS_THAN_EQUAL"):
+    def comparison_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("GREATER_THAN", "LESS_THAN", "EQUAL", "GREATER_THAN_EQUAL", "LESS_THAN_EQUAL"):
             raise ValueError(
                 "must be one of enum values ('GREATER_THAN', 'LESS_THAN', 'EQUAL', 'GREATER_THAN_EQUAL', 'LESS_THAN_EQUAL')"
             )
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -81,15 +84,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> LeaderQualifierPutBody:
         """Create an instance of LeaderQualifierPutBody from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return LeaderQualifierPutBody.parse_obj(obj)
 
         _obj = LeaderQualifierPutBody.parse_obj(
             {
                 "leader_criteria_id": obj.get("leaderCriteriaId"),
                 "statistic_field": obj.get("statisticField"),
                 "comparison_field": obj.get("comparisonField"),
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/leader_qualifiers_model.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/leader_qualifiers_model.py`

 * *Files 3% similar despite different names*

```diff
@@ -14,18 +14,17 @@
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
 from datetime import datetime
-from inspect import getfullargspec
-from typing import Optional
+from typing import Optional, Union
 
-from pydantic import BaseModel, Field, StrictFloat, StrictStr, validator
+from pydantic import BaseModel, Field, StrictFloat, StrictInt, StrictStr, validator
 
 from atriumsports.datacore.openapi.models.leader_qualifiers_model_leaders_criteria import (
     LeaderQualifiersModelLeadersCriteria,
 )
 from atriumsports.datacore.openapi.models.leader_qualifiers_model_organization import LeaderQualifiersModelOrganization
 
 
@@ -54,15 +53,15 @@
         None, alias="comparisonField", description="The statistic field to compare against."
     )
     comparison_type: Optional[StrictStr] = Field(
         None,
         alias="comparisonType",
         description="Comparison type for the qualifier >- `EQUAL` Equal >- `GREATER_THAN` Greater than >- `GREATER_THAN_EQUAL` Greater than or equal >- `LESS_THAN` Less than >- `LESS_THAN_EQUAL` Less than or equal ",
     )
-    comparison_value: Optional[StrictFloat] = Field(
+    comparison_value: Optional[Union[StrictFloat, StrictInt]] = Field(
         None, alias="comparisonValue", description="Comparison value for the qualifier"
     )
     __properties = [
         "updated",
         "added",
         "qualifierId",
         "organizationId",
@@ -72,24 +71,28 @@
         "statisticField",
         "comparisonField",
         "comparisonType",
         "comparisonValue",
     ]
 
     @validator("comparison_type")
-    def comparison_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("GREATER_THAN", "LESS_THAN", "EQUAL", "GREATER_THAN_EQUAL", "LESS_THAN_EQUAL"):
+    def comparison_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("GREATER_THAN", "LESS_THAN", "EQUAL", "GREATER_THAN_EQUAL", "LESS_THAN_EQUAL"):
             raise ValueError(
                 "must be one of enum values ('GREATER_THAN', 'LESS_THAN', 'EQUAL', 'GREATER_THAN_EQUAL', 'LESS_THAN_EQUAL')"
             )
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -123,15 +126,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> LeaderQualifiersModel:
         """Create an instance of LeaderQualifiersModel from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return LeaderQualifiersModel.parse_obj(obj)
 
         _obj = LeaderQualifiersModel.parse_obj(
             {
                 "updated": obj.get("updated"),
                 "added": obj.get("added"),
                 "qualifier_id": obj.get("qualifierId"),
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/leader_qualifiers_model_leaders_criteria.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/leader_qualifiers_model_leaders_criteria.py`

 * *Files 14% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr, validator
 
 
 class LeaderQualifiersModelLeadersCriteria(BaseModel):
     """
@@ -29,22 +28,26 @@
     """
 
     resource_type: Optional[StrictStr] = Field(None, alias="resourceType")
     id: Optional[StrictStr] = Field(None, description="Unique identifier for this resource")
     __properties = ["resourceType", "id"]
 
     @validator("resource_type")
-    def resource_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("leader_criteria"):
+    def resource_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("leader_criteria"):
             raise ValueError("must be one of enum values ('leader_criteria')")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -64,14 +67,14 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> LeaderQualifiersModelLeadersCriteria:
         """Create an instance of LeaderQualifiersModelLeadersCriteria from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return LeaderQualifiersModelLeadersCriteria.parse_obj(obj)
 
         _obj = LeaderQualifiersModelLeadersCriteria.parse_obj(
             {"resource_type": obj.get("resourceType"), "id": obj.get("id")}
         )
         return _obj
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/leader_qualifiers_model_organization.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/leader_qualifiers_model_organization.py`

 * *Files 4% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr, validator
 
 
 class LeaderQualifiersModelOrganization(BaseModel):
     """
@@ -29,22 +28,26 @@
     """
 
     resource_type: Optional[StrictStr] = Field(None, alias="resourceType")
     id: Optional[StrictStr] = Field(None, description="Unique identifier for this resource")
     __properties = ["resourceType", "id"]
 
     @validator("resource_type")
-    def resource_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("organizations"):
+    def resource_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("organizations"):
             raise ValueError("must be one of enum values ('organizations')")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -64,14 +67,14 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> LeaderQualifiersModelOrganization:
         """Create an instance of LeaderQualifiersModelOrganization from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return LeaderQualifiersModelOrganization.parse_obj(obj)
 
         _obj = LeaderQualifiersModelOrganization.parse_obj(
             {"resource_type": obj.get("resourceType"), "id": obj.get("id")}
         )
         return _obj
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/leader_qualifiers_response.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/leader_qualifiers_response.py`

 * *Files 2% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import List, Optional
 
 from pydantic import BaseModel, conlist
 
 from atriumsports.datacore.openapi.models.included_data import IncludedData
 from atriumsports.datacore.openapi.models.leader_qualifiers_model import LeaderQualifiersModel
 from atriumsports.datacore.openapi.models.response_links import ResponseLinks
@@ -36,14 +35,16 @@
     meta: Optional[ResponseMetaData] = None
     links: Optional[ResponseLinks] = None
     included: Optional[IncludedData] = None
     data: Optional[conlist(LeaderQualifiersModel)] = None
     __properties = ["meta", "links", "included", "data"]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -79,15 +80,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> LeaderQualifiersResponse:
         """Create an instance of LeaderQualifiersResponse from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return LeaderQualifiersResponse.parse_obj(obj)
 
         _obj = LeaderQualifiersResponse.parse_obj(
             {
                 "meta": ResponseMetaData.from_dict(obj.get("meta")) if obj.get("meta") is not None else None,
                 "links": ResponseLinks.from_dict(obj.get("links")) if obj.get("links") is not None else None,
                 "included": IncludedData.from_dict(obj.get("included")) if obj.get("included") is not None else None,
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/leader_summary_model.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/leader_summary_model.py`

 * *Files 2% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import List, Optional
 
 from pydantic import BaseModel, Field, conlist
 
 from atriumsports.datacore.openapi.models.season_person_statistics_model import SeasonPersonStatisticsModel
 
 
@@ -34,14 +33,16 @@
         None,
         alias="statName",
         description="There will be an element/object here for each statistic you have requested. The 'statName' key will be the name of the statistics. eg `points`",
     )
     __properties = ["statName"]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -74,15 +75,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> LeaderSummaryModel:
         """Create an instance of LeaderSummaryModel from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return LeaderSummaryModel.parse_obj(obj)
 
         _obj = LeaderSummaryModel.parse_obj(
             {
                 "stat_name": [SeasonPersonStatisticsModel.from_dict(_item) for _item in obj.get("statName")]
                 if obj.get("statName") is not None
                 else None
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/leader_summary_response.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/leader_summary_response.py`

 * *Files 2% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import List, Optional
 
 from pydantic import BaseModel, conlist
 
 from atriumsports.datacore.openapi.models.included_data import IncludedData
 from atriumsports.datacore.openapi.models.leader_summary_model import LeaderSummaryModel
 from atriumsports.datacore.openapi.models.response_links import ResponseLinks
@@ -36,14 +35,16 @@
     meta: Optional[ResponseMetaData] = None
     links: Optional[ResponseLinks] = None
     included: Optional[IncludedData] = None
     data: Optional[conlist(LeaderSummaryModel)] = None
     __properties = ["meta", "links", "included", "data"]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -79,15 +80,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> LeaderSummaryResponse:
         """Create an instance of LeaderSummaryResponse from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return LeaderSummaryResponse.parse_obj(obj)
 
         _obj = LeaderSummaryResponse.parse_obj(
             {
                 "meta": ResponseMetaData.from_dict(obj.get("meta")) if obj.get("meta") is not None else None,
                 "links": ResponseLinks.from_dict(obj.get("links")) if obj.get("links") is not None else None,
                 "included": IncludedData.from_dict(obj.get("included")) if obj.get("included") is not None else None,
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/league_post_body.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/league_post_body.py`

 * *Files 2% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr, constr, validator
 
 from atriumsports.datacore.openapi.models.social_media import SocialMedia
 
 
@@ -74,28 +73,33 @@
         "countryCode",
         "regionType",
         "social",
         "externalId",
     ]
 
     @validator("region_type")
-    def region_type_validate_enum(cls, v):
-        if v not in ("LOCAL", "STATE", "INTERSTATE", "NATIONAL", "INTERNATIONAL"):
+    def region_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value not in ("LOCAL", "STATE", "INTERSTATE", "NATIONAL", "INTERNATIONAL"):
             raise ValueError("must be one of enum values ('LOCAL', 'STATE', 'INTERSTATE', 'NATIONAL', 'INTERNATIONAL')")
-        return v
+        return value
 
     @validator("external_id")
-    def external_id_validate_regular_expression(cls, v):
-        if v is None:
-            return v
-        if not re.match(r"^[0-9A-Za-z\/_-]+$", v):
+    def external_id_validate_regular_expression(cls, value):
+        """Validates the regular expression"""
+        if value is None:
+            return value
+
+        if not re.match(r"^[0-9A-Za-z\/_-]+$", value):
             raise ValueError(r"must validate the regular expression /^[0-9A-Za-z\/_-]+$/")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -148,15 +152,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> LeaguePostBody:
         """Create an instance of LeaguePostBody from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return LeaguePostBody.parse_obj(obj)
 
         _obj = LeaguePostBody.parse_obj(
             {
                 "league_id": obj.get("leagueId"),
                 "abbreviation_local": obj.get("abbreviationLocal"),
                 "name_local": obj.get("nameLocal"),
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/league_put_body.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/league_put_body.py`

 * *Files 5% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr, constr, validator
 
 from atriumsports.datacore.openapi.models.social_media import SocialMedia
 
 
@@ -72,30 +71,36 @@
         "countryCode",
         "regionType",
         "social",
         "externalId",
     ]
 
     @validator("region_type")
-    def region_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("LOCAL", "STATE", "INTERSTATE", "NATIONAL", "INTERNATIONAL"):
+    def region_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("LOCAL", "STATE", "INTERSTATE", "NATIONAL", "INTERNATIONAL"):
             raise ValueError("must be one of enum values ('LOCAL', 'STATE', 'INTERSTATE', 'NATIONAL', 'INTERNATIONAL')")
-        return v
+        return value
 
     @validator("external_id")
-    def external_id_validate_regular_expression(cls, v):
-        if v is None:
-            return v
-        if not re.match(r"^[0-9A-Za-z\/_-]+$", v):
+    def external_id_validate_regular_expression(cls, value):
+        """Validates the regular expression"""
+        if value is None:
+            return value
+
+        if not re.match(r"^[0-9A-Za-z\/_-]+$", value):
             raise ValueError(r"must validate the regular expression /^[0-9A-Za-z\/_-]+$/")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -148,15 +153,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> LeaguePutBody:
         """Create an instance of LeaguePutBody from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return LeaguePutBody.parse_obj(obj)
 
         _obj = LeaguePutBody.parse_obj(
             {
                 "abbreviation_local": obj.get("abbreviationLocal"),
                 "name_local": obj.get("nameLocal"),
                 "abbreviation_latin": obj.get("abbreviationLatin"),
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/leagues_model.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/leagues_model.py`

 * *Files 2% similar despite different names*

```diff
@@ -14,15 +14,14 @@
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
 from datetime import datetime
-from inspect import getfullargspec
 from typing import List, Optional
 
 from pydantic import BaseModel, Field, StrictStr, conlist, constr, validator
 
 from atriumsports.datacore.openapi.models.images_model import ImagesModel
 from atriumsports.datacore.openapi.models.leagues_model_organization import LeaguesModelOrganization
 from atriumsports.datacore.openapi.models.social_media import SocialMedia
@@ -89,30 +88,36 @@
         "externalId",
         "updated",
         "added",
         "images",
     ]
 
     @validator("region_type")
-    def region_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("LOCAL", "STATE", "INTERSTATE", "NATIONAL", "INTERNATIONAL"):
+    def region_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("LOCAL", "STATE", "INTERSTATE", "NATIONAL", "INTERNATIONAL"):
             raise ValueError("must be one of enum values ('LOCAL', 'STATE', 'INTERSTATE', 'NATIONAL', 'INTERNATIONAL')")
-        return v
+        return value
 
     @validator("external_id")
-    def external_id_validate_regular_expression(cls, v):
-        if v is None:
-            return v
-        if not re.match(r"^[0-9A-Za-z\/_-]+$", v):
+    def external_id_validate_regular_expression(cls, value):
+        """Validates the regular expression"""
+        if value is None:
+            return value
+
+        if not re.match(r"^[0-9A-Za-z\/_-]+$", value):
             raise ValueError(r"must validate the regular expression /^[0-9A-Za-z\/_-]+$/")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -183,15 +188,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> LeaguesModel:
         """Create an instance of LeaguesModel from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return LeaguesModel.parse_obj(obj)
 
         _obj = LeaguesModel.parse_obj(
             {
                 "league_id": obj.get("leagueId"),
                 "organization_id": obj.get("organizationId"),
                 "organization": LeaguesModelOrganization.from_dict(obj.get("organization"))
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/leagues_model_organization.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/leagues_model_organization.py`

 * *Files 8% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr, validator
 
 
 class LeaguesModelOrganization(BaseModel):
     """
@@ -29,22 +28,26 @@
     """
 
     resource_type: Optional[StrictStr] = Field(None, alias="resourceType")
     id: Optional[StrictStr] = Field(None, description="Unique identifier for this resource")
     __properties = ["resourceType", "id"]
 
     @validator("resource_type")
-    def resource_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("organizations"):
+    def resource_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("organizations"):
             raise ValueError("must be one of enum values ('organizations')")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -64,12 +67,12 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> LeaguesModelOrganization:
         """Create an instance of LeaguesModelOrganization from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return LeaguesModelOrganization.parse_obj(obj)
 
         _obj = LeaguesModelOrganization.parse_obj({"resource_type": obj.get("resourceType"), "id": obj.get("id")})
         return _obj
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/leagues_response.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/roles_response.py`

 * *Files 4% similar despite different names*

```diff
@@ -13,51 +13,52 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import List, Optional
 
 from pydantic import BaseModel, conlist
 
 from atriumsports.datacore.openapi.models.included_data import IncludedData
-from atriumsports.datacore.openapi.models.leagues_model import LeaguesModel
 from atriumsports.datacore.openapi.models.response_links import ResponseLinks
 from atriumsports.datacore.openapi.models.response_meta_data import ResponseMetaData
+from atriumsports.datacore.openapi.models.roles_model import RolesModel
 
 
-class LeaguesResponse(BaseModel):
+class RolesResponse(BaseModel):
     """
-    LeaguesResponse
+    RolesResponse
     """
 
     meta: Optional[ResponseMetaData] = None
     links: Optional[ResponseLinks] = None
     included: Optional[IncludedData] = None
-    data: Optional[conlist(LeaguesModel)] = None
+    data: Optional[conlist(RolesModel)] = None
     __properties = ["meta", "links", "included", "data"]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> LeaguesResponse:
-        """Create an instance of LeaguesResponse from a JSON string"""
+    def from_json(cls, json_str: str) -> RolesResponse:
+        """Create an instance of RolesResponse from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
     def to_dict(self):
         """Returns the dictionary representation of the model using alias"""
         _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)
         # override the default output from pydantic by calling `to_dict()` of meta
         if self.meta:
@@ -74,26 +75,26 @@
             for _item in self.data:
                 if _item:
                     _items.append(_item.to_dict())
             _dict["data"] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> LeaguesResponse:
-        """Create an instance of LeaguesResponse from a dict"""
+    def from_dict(cls, obj: dict) -> RolesResponse:
+        """Create an instance of RolesResponse from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
-            return LeaguesResponse.parse_obj(obj)
+        if not isinstance(obj, dict):
+            return RolesResponse.parse_obj(obj)
 
-        _obj = LeaguesResponse.parse_obj(
+        _obj = RolesResponse.parse_obj(
             {
                 "meta": ResponseMetaData.from_dict(obj.get("meta")) if obj.get("meta") is not None else None,
                 "links": ResponseLinks.from_dict(obj.get("links")) if obj.get("links") is not None else None,
                 "included": IncludedData.from_dict(obj.get("included")) if obj.get("included") is not None else None,
-                "data": [LeaguesModel.from_dict(_item) for _item in obj.get("data")]
+                "data": [RolesModel.from_dict(_item) for _item in obj.get("data")]
                 if obj.get("data") is not None
                 else None,
             }
         )
         return _obj
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/organization_post_body.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/organization_post_body.py`

 * *Files 3% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr, constr, validator
 
 
 class OrganizationPostBody(BaseModel):
     """
@@ -72,28 +71,33 @@
         "nameLatin",
         "countryCode",
         "regionType",
         "defaultLocale",
     ]
 
     @validator("region_type")
-    def region_type_validate_enum(cls, v):
-        if v not in ("LOCAL", "STATE", "INTERSTATE", "NATIONAL", "INTERNATIONAL"):
+    def region_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value not in ("LOCAL", "STATE", "INTERSTATE", "NATIONAL", "INTERNATIONAL"):
             raise ValueError("must be one of enum values ('LOCAL', 'STATE', 'INTERSTATE', 'NATIONAL', 'INTERNATIONAL')")
-        return v
+        return value
 
     @validator("default_locale")
-    def default_locale_validate_regular_expression(cls, v):
-        if v is None:
-            return v
-        if not re.match(r"^[a-z]{2,2}-[A-Z]{2,2}$", v):
+    def default_locale_validate_regular_expression(cls, value):
+        """Validates the regular expression"""
+        if value is None:
+            return value
+
+        if not re.match(r"^[a-z]{2,2}-[A-Z]{2,2}$", value):
             raise ValueError(r"must validate the regular expression /^[a-z]{2,2}-[A-Z]{2,2}$/")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -133,15 +137,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> OrganizationPostBody:
         """Create an instance of OrganizationPostBody from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return OrganizationPostBody.parse_obj(obj)
 
         _obj = OrganizationPostBody.parse_obj(
             {
                 "organization_id": obj.get("organizationId"),
                 "abbreviation_local": obj.get("abbreviationLocal"),
                 "name_local": obj.get("nameLocal"),
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/organization_put_body.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/organization_put_body.py`

 * *Files 2% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr, constr, validator
 
 
 class OrganizationPutBody(BaseModel):
     """
@@ -68,30 +67,36 @@
         "nameLatin",
         "countryCode",
         "regionType",
         "defaultLocale",
     ]
 
     @validator("region_type")
-    def region_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("LOCAL", "STATE", "INTERSTATE", "NATIONAL", "INTERNATIONAL"):
+    def region_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("LOCAL", "STATE", "INTERSTATE", "NATIONAL", "INTERNATIONAL"):
             raise ValueError("must be one of enum values ('LOCAL', 'STATE', 'INTERSTATE', 'NATIONAL', 'INTERNATIONAL')")
-        return v
+        return value
 
     @validator("default_locale")
-    def default_locale_validate_regular_expression(cls, v):
-        if v is None:
-            return v
-        if not re.match(r"^[a-z]{2,2}-[A-Z]{2,2}$", v):
+    def default_locale_validate_regular_expression(cls, value):
+        """Validates the regular expression"""
+        if value is None:
+            return value
+
+        if not re.match(r"^[a-z]{2,2}-[A-Z]{2,2}$", value):
             raise ValueError(r"must validate the regular expression /^[a-z]{2,2}-[A-Z]{2,2}$/")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -131,15 +136,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> OrganizationPutBody:
         """Create an instance of OrganizationPutBody from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return OrganizationPutBody.parse_obj(obj)
 
         _obj = OrganizationPutBody.parse_obj(
             {
                 "abbreviation_local": obj.get("abbreviationLocal"),
                 "name_local": obj.get("nameLocal"),
                 "abbreviation_latin": obj.get("abbreviationLatin"),
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/organizations_model.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/organizations_model.py`

 * *Files 4% similar despite different names*

```diff
@@ -14,15 +14,14 @@
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
 from datetime import datetime
-from inspect import getfullargspec
 from typing import List, Optional
 
 from pydantic import BaseModel, Field, StrictStr, conlist, constr, validator
 
 from atriumsports.datacore.openapi.models.images_model import ImagesModel
 
 
@@ -81,30 +80,36 @@
         "defaultLocale",
         "updated",
         "added",
         "images",
     ]
 
     @validator("region_type")
-    def region_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("LOCAL", "STATE", "INTERSTATE", "NATIONAL", "INTERNATIONAL"):
+    def region_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("LOCAL", "STATE", "INTERSTATE", "NATIONAL", "INTERNATIONAL"):
             raise ValueError("must be one of enum values ('LOCAL', 'STATE', 'INTERSTATE', 'NATIONAL', 'INTERNATIONAL')")
-        return v
+        return value
 
     @validator("default_locale")
-    def default_locale_validate_regular_expression(cls, v):
-        if v is None:
-            return v
-        if not re.match(r"^[a-z]{2,2}-[A-Z]{2,2}$", v):
+    def default_locale_validate_regular_expression(cls, value):
+        """Validates the regular expression"""
+        if value is None:
+            return value
+
+        if not re.match(r"^[a-z]{2,2}-[A-Z]{2,2}$", value):
             raise ValueError(r"must validate the regular expression /^[a-z]{2,2}-[A-Z]{2,2}$/")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -158,15 +163,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> OrganizationsModel:
         """Create an instance of OrganizationsModel from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return OrganizationsModel.parse_obj(obj)
 
         _obj = OrganizationsModel.parse_obj(
             {
                 "organization_id": obj.get("organizationId"),
                 "abbreviation_local": obj.get("abbreviationLocal"),
                 "name_local": obj.get("nameLocal"),
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/organizations_response.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/organizations_response.py`

 * *Files 2% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import List, Optional
 
 from pydantic import BaseModel, conlist
 
 from atriumsports.datacore.openapi.models.included_data import IncludedData
 from atriumsports.datacore.openapi.models.organizations_model import OrganizationsModel
 from atriumsports.datacore.openapi.models.response_links import ResponseLinks
@@ -36,14 +35,16 @@
     meta: Optional[ResponseMetaData] = None
     links: Optional[ResponseLinks] = None
     included: Optional[IncludedData] = None
     data: Optional[conlist(OrganizationsModel)] = None
     __properties = ["meta", "links", "included", "data"]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -79,15 +80,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> OrganizationsResponse:
         """Create an instance of OrganizationsResponse from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return OrganizationsResponse.parse_obj(obj)
 
         _obj = OrganizationsResponse.parse_obj(
             {
                 "meta": ResponseMetaData.from_dict(obj.get("meta")) if obj.get("meta") is not None else None,
                 "links": ResponseLinks.from_dict(obj.get("links")) if obj.get("links") is not None else None,
                 "included": IncludedData.from_dict(obj.get("included")) if obj.get("included") is not None else None,
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/person_additional_details.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/person_additional_details.py`

 * *Files 4% similar despite different names*

```diff
@@ -13,27 +13,26 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
-from typing import Optional
+from typing import Optional, Union
 
-from pydantic import BaseModel, Field, StrictFloat, StrictStr, validator
+from pydantic import BaseModel, Field, StrictFloat, StrictInt, StrictStr, validator
 
 
 class PersonAdditionalDetails(BaseModel):
     """
     Additional person detail fields
     """
 
-    height: Optional[StrictFloat] = Field(None, description="Height in cms")
-    weight: Optional[StrictFloat] = Field(None, description="Weight in kgs")
+    height: Optional[Union[StrictFloat, StrictInt]] = Field(None, description="Height in cms")
+    weight: Optional[Union[StrictFloat, StrictInt]] = Field(None, description="Weight in kgs")
     dominant_hand: Optional[StrictStr] = Field(None, alias="dominantHand", description="Dominant hand")
     dominant_foot: Optional[StrictStr] = Field(None, alias="dominantFoot", description="Dominant foot")
     home_town: Optional[StrictStr] = Field(None, alias="homeTown", description="Hometown")
     college: Optional[StrictStr] = Field(None, description="College")
     representation: Optional[StrictStr] = Field(None, description="Representation")
     junior_association_league: Optional[StrictStr] = Field(
         None, alias="juniorAssociationLeague", description="Junior Association / League"
@@ -46,30 +45,36 @@
         "homeTown",
         "college",
         "representation",
         "juniorAssociationLeague",
     ]
 
     @validator("dominant_hand")
-    def dominant_hand_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("LEFT", "RIGHT"):
+    def dominant_hand_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("LEFT", "RIGHT"):
             raise ValueError("must be one of enum values ('LEFT', 'RIGHT')")
-        return v
+        return value
 
     @validator("dominant_foot")
-    def dominant_foot_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("LEFT", "RIGHT"):
+    def dominant_foot_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("LEFT", "RIGHT"):
             raise ValueError("must be one of enum values ('LEFT', 'RIGHT')")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -129,15 +134,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> PersonAdditionalDetails:
         """Create an instance of PersonAdditionalDetails from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return PersonAdditionalDetails.parse_obj(obj)
 
         _obj = PersonAdditionalDetails.parse_obj(
             {
                 "height": obj.get("height"),
                 "weight": obj.get("weight"),
                 "dominant_hand": obj.get("dominantHand"),
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/person_historical_name.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/person_historical_name.py`

 * *Files 2% similar despite different names*

```diff
@@ -14,15 +14,14 @@
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
 from datetime import date
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr
 
 
 class PersonHistoricalName(BaseModel):
     """
@@ -69,14 +68,16 @@
         "nameFamilyLocal",
         "nameFullLatin",
         "nameGivenLatin",
         "nameFamilyLatin",
     ]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -136,15 +137,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> PersonHistoricalName:
         """Create an instance of PersonHistoricalName from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return PersonHistoricalName.parse_obj(obj)
 
         _obj = PersonHistoricalName.parse_obj(
             {
                 "date_start": obj.get("dateStart"),
                 "date_end": obj.get("dateEnd"),
                 "name_full_local": obj.get("nameFullLocal"),
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/person_list_default_response.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/person_list_default_response.py`

 * *Files 6% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel
 
 from atriumsports.datacore.openapi.models.error_model import ErrorModel
 from atriumsports.datacore.openapi.models.response_meta_data import ResponseMetaData
 
@@ -32,14 +31,16 @@
     """
 
     meta: Optional[ResponseMetaData] = None
     error: Optional[ErrorModel] = None
     __properties = ["meta", "error"]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -65,15 +66,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> PersonListDefaultResponse:
         """Create an instance of PersonListDefaultResponse from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return PersonListDefaultResponse.parse_obj(obj)
 
         _obj = PersonListDefaultResponse.parse_obj(
             {
                 "meta": ResponseMetaData.from_dict(obj.get("meta")) if obj.get("meta") is not None else None,
                 "error": ErrorModel.from_dict(obj.get("error")) if obj.get("error") is not None else None,
             }
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/person_post_body.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/person_post_body.py`

 * *Files 4% similar despite different names*

```diff
@@ -14,15 +14,14 @@
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
 from datetime import date
-from inspect import getfullargspec
 from typing import Dict, List, Optional
 
 from pydantic import BaseModel, Field, StrictStr, conlist, constr, validator
 
 from atriumsports.datacore.openapi.models.person_additional_details import PersonAdditionalDetails
 from atriumsports.datacore.openapi.models.person_historical_name import PersonHistoricalName
 from atriumsports.datacore.openapi.models.person_post_body_additional_names_value import (
@@ -45,14 +44,17 @@
         ..., description="The gender of the person >- `FEMALE` Female >- `MALE` Male >- `UNKNOWN` Unknown "
     )
     name_full_local: constr(strict=True, max_length=200) = Field(
         ...,
         alias="nameFullLocal",
         description="The full name of the person in [local](#section/Introduction/Character-Sets-and-Names) language",
     )
+    name_abbreviated: Optional[constr(strict=True, max_length=100)] = Field(
+        None, alias="nameAbbreviated", description="An abbreviated name for a person"
+    )
     language_local: Optional[constr(strict=True, max_length=2)] = Field(
         None,
         alias="languageLocal",
         description="The language code of the full name in [local](#section/Introduction/Character-Sets-and-Names) language. This code is a two letter (lower-case) ISO 639-1 language code.",
     )
     name_given_local: Optional[constr(strict=True, max_length=200)] = Field(
         None,
@@ -98,14 +100,15 @@
         None, alias="externalId", description="The Id of the data as set by the provider of the data"
     )
     __properties = [
         "personId",
         "status",
         "gender",
         "nameFullLocal",
+        "nameAbbreviated",
         "languageLocal",
         "nameGivenLocal",
         "nameFamilyLocal",
         "nameFullLatin",
         "nameGivenLatin",
         "nameFamilyLatin",
         "dob",
@@ -115,34 +118,40 @@
         "additionalDetails",
         "social",
         "historicalNames",
         "externalId",
     ]
 
     @validator("status")
-    def status_validate_enum(cls, v):
-        if v not in ("ACTIVE", "UNREGISTERED", "PENDING", "DECEASED", "INACTIVE"):
+    def status_validate_enum(cls, value):
+        """Validates the enum"""
+        if value not in ("ACTIVE", "UNREGISTERED", "PENDING", "DECEASED", "INACTIVE"):
             raise ValueError("must be one of enum values ('ACTIVE', 'UNREGISTERED', 'PENDING', 'DECEASED', 'INACTIVE')")
-        return v
+        return value
 
     @validator("gender")
-    def gender_validate_enum(cls, v):
-        if v not in ("MALE", "FEMALE", "UNKNOWN"):
+    def gender_validate_enum(cls, value):
+        """Validates the enum"""
+        if value not in ("MALE", "FEMALE", "UNKNOWN"):
             raise ValueError("must be one of enum values ('MALE', 'FEMALE', 'UNKNOWN')")
-        return v
+        return value
 
     @validator("external_id")
-    def external_id_validate_regular_expression(cls, v):
-        if v is None:
-            return v
-        if not re.match(r"^[0-9A-Za-z\/_-]+$", v):
+    def external_id_validate_regular_expression(cls, value):
+        """Validates the regular expression"""
+        if value is None:
+            return value
+
+        if not re.match(r"^[0-9A-Za-z\/_-]+$", value):
             raise ValueError(r"must validate the regular expression /^[0-9A-Za-z\/_-]+$/")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -174,14 +183,19 @@
         # override the default output from pydantic by calling `to_dict()` of each item in historical_names (list)
         _items = []
         if self.historical_names:
             for _item in self.historical_names:
                 if _item:
                     _items.append(_item.to_dict())
             _dict["historicalNames"] = _items
+        # set to None if name_abbreviated (nullable) is None
+        # and __fields_set__ contains the field
+        if self.name_abbreviated is None and "name_abbreviated" in self.__fields_set__:
+            _dict["nameAbbreviated"] = None
+
         # set to None if language_local (nullable) is None
         # and __fields_set__ contains the field
         if self.language_local is None and "language_local" in self.__fields_set__:
             _dict["languageLocal"] = None
 
         # set to None if name_given_local (nullable) is None
         # and __fields_set__ contains the field
@@ -252,23 +266,24 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> PersonPostBody:
         """Create an instance of PersonPostBody from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return PersonPostBody.parse_obj(obj)
 
         _obj = PersonPostBody.parse_obj(
             {
                 "person_id": obj.get("personId"),
                 "status": obj.get("status") if obj.get("status") is not None else "ACTIVE",
                 "gender": obj.get("gender"),
                 "name_full_local": obj.get("nameFullLocal"),
+                "name_abbreviated": obj.get("nameAbbreviated"),
                 "language_local": obj.get("languageLocal"),
                 "name_given_local": obj.get("nameGivenLocal"),
                 "name_family_local": obj.get("nameFamilyLocal"),
                 "name_full_latin": obj.get("nameFullLatin"),
                 "name_given_latin": obj.get("nameGivenLatin"),
                 "name_family_latin": obj.get("nameFamilyLatin"),
                 "dob": obj.get("dob"),
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/person_post_body_additional_names_value.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/person_post_body_additional_names_value.py`

 * *Files 2% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr
 
 
 class PersonPostBodyAdditionalNamesValue(BaseModel):
     """
@@ -50,14 +49,16 @@
         "given",
         "family",
         "full",
         "knownAs",
     ]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -132,15 +133,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> PersonPostBodyAdditionalNamesValue:
         """Create an instance of PersonPostBodyAdditionalNamesValue from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return PersonPostBodyAdditionalNamesValue.parse_obj(obj)
 
         _obj = PersonPostBodyAdditionalNamesValue.parse_obj(
             {
                 "display": obj.get("display"),
                 "television": obj.get("television"),
                 "scoreboard": obj.get("scoreboard"),
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/person_put_body.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/person_put_body.py`

 * *Files 6% similar despite different names*

```diff
@@ -14,15 +14,14 @@
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
 from datetime import date
-from inspect import getfullargspec
 from typing import Dict, List, Optional
 
 from pydantic import BaseModel, Field, StrictStr, conlist, constr, validator
 
 from atriumsports.datacore.openapi.models.person_additional_details import PersonAdditionalDetails
 from atriumsports.datacore.openapi.models.person_historical_name import PersonHistoricalName
 from atriumsports.datacore.openapi.models.person_post_body_additional_names_value import (
@@ -44,14 +43,17 @@
         None, description="The gender of the person >- `FEMALE` Female >- `MALE` Male >- `UNKNOWN` Unknown "
     )
     name_full_local: Optional[constr(strict=True, max_length=200)] = Field(
         None,
         alias="nameFullLocal",
         description="The full name of the person in [local](#section/Introduction/Character-Sets-and-Names) language",
     )
+    name_abbreviated: Optional[constr(strict=True, max_length=100)] = Field(
+        None, alias="nameAbbreviated", description="An abbreviated name for a person"
+    )
     language_local: Optional[constr(strict=True, max_length=2)] = Field(
         None,
         alias="languageLocal",
         description="The language code of the full name in [local](#section/Introduction/Character-Sets-and-Names) language. This code is a two letter (lower-case) ISO 639-1 language code.",
     )
     name_given_local: Optional[constr(strict=True, max_length=200)] = Field(
         None,
@@ -96,14 +98,15 @@
     external_id: Optional[constr(strict=True, max_length=150)] = Field(
         None, alias="externalId", description="The Id of the data as set by the provider of the data"
     )
     __properties = [
         "status",
         "gender",
         "nameFullLocal",
+        "nameAbbreviated",
         "languageLocal",
         "nameGivenLocal",
         "nameFamilyLocal",
         "nameFullLatin",
         "nameGivenLatin",
         "nameFamilyLatin",
         "dob",
@@ -113,38 +116,46 @@
         "additionalDetails",
         "social",
         "historicalNames",
         "externalId",
     ]
 
     @validator("status")
-    def status_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("ACTIVE", "UNREGISTERED", "PENDING", "DECEASED", "INACTIVE"):
+    def status_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("ACTIVE", "UNREGISTERED", "PENDING", "DECEASED", "INACTIVE"):
             raise ValueError("must be one of enum values ('ACTIVE', 'UNREGISTERED', 'PENDING', 'DECEASED', 'INACTIVE')")
-        return v
+        return value
 
     @validator("gender")
-    def gender_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("MALE", "FEMALE", "UNKNOWN"):
+    def gender_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("MALE", "FEMALE", "UNKNOWN"):
             raise ValueError("must be one of enum values ('MALE', 'FEMALE', 'UNKNOWN')")
-        return v
+        return value
 
     @validator("external_id")
-    def external_id_validate_regular_expression(cls, v):
-        if v is None:
-            return v
-        if not re.match(r"^[0-9A-Za-z\/_-]+$", v):
+    def external_id_validate_regular_expression(cls, value):
+        """Validates the regular expression"""
+        if value is None:
+            return value
+
+        if not re.match(r"^[0-9A-Za-z\/_-]+$", value):
             raise ValueError(r"must validate the regular expression /^[0-9A-Za-z\/_-]+$/")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -176,14 +187,19 @@
         # override the default output from pydantic by calling `to_dict()` of each item in historical_names (list)
         _items = []
         if self.historical_names:
             for _item in self.historical_names:
                 if _item:
                     _items.append(_item.to_dict())
             _dict["historicalNames"] = _items
+        # set to None if name_abbreviated (nullable) is None
+        # and __fields_set__ contains the field
+        if self.name_abbreviated is None and "name_abbreviated" in self.__fields_set__:
+            _dict["nameAbbreviated"] = None
+
         # set to None if language_local (nullable) is None
         # and __fields_set__ contains the field
         if self.language_local is None and "language_local" in self.__fields_set__:
             _dict["languageLocal"] = None
 
         # set to None if name_given_local (nullable) is None
         # and __fields_set__ contains the field
@@ -254,22 +270,23 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> PersonPutBody:
         """Create an instance of PersonPutBody from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return PersonPutBody.parse_obj(obj)
 
         _obj = PersonPutBody.parse_obj(
             {
                 "status": obj.get("status") if obj.get("status") is not None else "ACTIVE",
                 "gender": obj.get("gender"),
                 "name_full_local": obj.get("nameFullLocal"),
+                "name_abbreviated": obj.get("nameAbbreviated"),
                 "language_local": obj.get("languageLocal"),
                 "name_given_local": obj.get("nameGivenLocal"),
                 "name_family_local": obj.get("nameFamilyLocal"),
                 "name_full_latin": obj.get("nameFullLatin"),
                 "name_given_latin": obj.get("nameGivenLatin"),
                 "name_family_latin": obj.get("nameFamilyLatin"),
                 "dob": obj.get("dob"),
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/persons_model.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/persons_model.py`

 * *Files 4% similar despite different names*

```diff
@@ -14,15 +14,14 @@
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
 from datetime import date, datetime
-from inspect import getfullargspec
 from typing import Dict, List, Optional
 
 from pydantic import BaseModel, Field, StrictStr, conlist, constr, validator
 
 from atriumsports.datacore.openapi.models.images_model import ImagesModel
 from atriumsports.datacore.openapi.models.person_additional_details import PersonAdditionalDetails
 from atriumsports.datacore.openapi.models.person_historical_name import PersonHistoricalName
@@ -51,14 +50,17 @@
         None, description="The gender of the person >- `FEMALE` Female >- `MALE` Male >- `UNKNOWN` Unknown "
     )
     name_full_local: Optional[constr(strict=True, max_length=200)] = Field(
         None,
         alias="nameFullLocal",
         description="The full name of the person in [local](#section/Introduction/Character-Sets-and-Names) language",
     )
+    name_abbreviated: Optional[constr(strict=True, max_length=100)] = Field(
+        None, alias="nameAbbreviated", description="An abbreviated name for a person"
+    )
     language_local: Optional[constr(strict=True, max_length=2)] = Field(
         None,
         alias="languageLocal",
         description="The language code of the full name in [local](#section/Introduction/Character-Sets-and-Names) language. This code is a two letter (lower-case) ISO 639-1 language code.",
     )
     name_given_local: Optional[constr(strict=True, max_length=200)] = Field(
         None,
@@ -109,14 +111,15 @@
     __properties = [
         "personId",
         "organizationId",
         "organization",
         "status",
         "gender",
         "nameFullLocal",
+        "nameAbbreviated",
         "languageLocal",
         "nameGivenLocal",
         "nameFamilyLocal",
         "nameFullLatin",
         "nameGivenLatin",
         "nameFamilyLatin",
         "dob",
@@ -129,38 +132,46 @@
         "externalId",
         "updated",
         "added",
         "images",
     ]
 
     @validator("status")
-    def status_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("ACTIVE", "UNREGISTERED", "PENDING", "DECEASED", "INACTIVE"):
+    def status_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("ACTIVE", "UNREGISTERED", "PENDING", "DECEASED", "INACTIVE"):
             raise ValueError("must be one of enum values ('ACTIVE', 'UNREGISTERED', 'PENDING', 'DECEASED', 'INACTIVE')")
-        return v
+        return value
 
     @validator("gender")
-    def gender_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("MALE", "FEMALE", "UNKNOWN"):
+    def gender_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("MALE", "FEMALE", "UNKNOWN"):
             raise ValueError("must be one of enum values ('MALE', 'FEMALE', 'UNKNOWN')")
-        return v
+        return value
 
     @validator("external_id")
-    def external_id_validate_regular_expression(cls, v):
-        if v is None:
-            return v
-        if not re.match(r"^[0-9A-Za-z\/_-]+$", v):
+    def external_id_validate_regular_expression(cls, value):
+        """Validates the regular expression"""
+        if value is None:
+            return value
+
+        if not re.match(r"^[0-9A-Za-z\/_-]+$", value):
             raise ValueError(r"must validate the regular expression /^[0-9A-Za-z\/_-]+$/")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -210,14 +221,19 @@
         # override the default output from pydantic by calling `to_dict()` of each item in images (list)
         _items = []
         if self.images:
             for _item in self.images:
                 if _item:
                     _items.append(_item.to_dict())
             _dict["images"] = _items
+        # set to None if name_abbreviated (nullable) is None
+        # and __fields_set__ contains the field
+        if self.name_abbreviated is None and "name_abbreviated" in self.__fields_set__:
+            _dict["nameAbbreviated"] = None
+
         # set to None if language_local (nullable) is None
         # and __fields_set__ contains the field
         if self.language_local is None and "language_local" in self.__fields_set__:
             _dict["languageLocal"] = None
 
         # set to None if name_given_local (nullable) is None
         # and __fields_set__ contains the field
@@ -288,27 +304,28 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> PersonsModel:
         """Create an instance of PersonsModel from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return PersonsModel.parse_obj(obj)
 
         _obj = PersonsModel.parse_obj(
             {
                 "person_id": obj.get("personId"),
                 "organization_id": obj.get("organizationId"),
                 "organization": PersonsModelOrganization.from_dict(obj.get("organization"))
                 if obj.get("organization") is not None
                 else None,
                 "status": obj.get("status") if obj.get("status") is not None else "ACTIVE",
                 "gender": obj.get("gender"),
                 "name_full_local": obj.get("nameFullLocal"),
+                "name_abbreviated": obj.get("nameAbbreviated"),
                 "language_local": obj.get("languageLocal"),
                 "name_given_local": obj.get("nameGivenLocal"),
                 "name_family_local": obj.get("nameFamilyLocal"),
                 "name_full_latin": obj.get("nameFullLatin"),
                 "name_given_latin": obj.get("nameGivenLatin"),
                 "name_family_latin": obj.get("nameFamilyLatin"),
                 "dob": obj.get("dob"),
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/persons_model_organization.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_rounds_model_organization.py`

 * *Files 10% similar despite different names*

```diff
@@ -13,63 +13,66 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr, validator
 
 
-class PersonsModelOrganization(BaseModel):
+class SeasonRoundsModelOrganization(BaseModel):
     """
-    The organization that this person belongs to
+    The organization that this round belongs to
     """
 
     resource_type: Optional[StrictStr] = Field(None, alias="resourceType")
     id: Optional[StrictStr] = Field(None, description="Unique identifier for this resource")
     __properties = ["resourceType", "id"]
 
     @validator("resource_type")
-    def resource_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("organizations"):
+    def resource_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("organizations"):
             raise ValueError("must be one of enum values ('organizations')")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> PersonsModelOrganization:
-        """Create an instance of PersonsModelOrganization from a JSON string"""
+    def from_json(cls, json_str: str) -> SeasonRoundsModelOrganization:
+        """Create an instance of SeasonRoundsModelOrganization from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
     def to_dict(self):
         """Returns the dictionary representation of the model using alias"""
         _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> PersonsModelOrganization:
-        """Create an instance of PersonsModelOrganization from a dict"""
+    def from_dict(cls, obj: dict) -> SeasonRoundsModelOrganization:
+        """Create an instance of SeasonRoundsModelOrganization from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
-            return PersonsModelOrganization.parse_obj(obj)
+        if not isinstance(obj, dict):
+            return SeasonRoundsModelOrganization.parse_obj(obj)
 
-        _obj = PersonsModelOrganization.parse_obj({"resource_type": obj.get("resourceType"), "id": obj.get("id")})
+        _obj = SeasonRoundsModelOrganization.parse_obj({"resource_type": obj.get("resourceType"), "id": obj.get("id")})
         return _obj
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/persons_response.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/persons_response.py`

 * *Files 2% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import List, Optional
 
 from pydantic import BaseModel, conlist
 
 from atriumsports.datacore.openapi.models.included_data import IncludedData
 from atriumsports.datacore.openapi.models.persons_model import PersonsModel
 from atriumsports.datacore.openapi.models.response_links import ResponseLinks
@@ -36,14 +35,16 @@
     meta: Optional[ResponseMetaData] = None
     links: Optional[ResponseLinks] = None
     included: Optional[IncludedData] = None
     data: Optional[conlist(PersonsModel)] = None
     __properties = ["meta", "links", "included", "data"]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -79,15 +80,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> PersonsResponse:
         """Create an instance of PersonsResponse from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return PersonsResponse.parse_obj(obj)
 
         _obj = PersonsResponse.parse_obj(
             {
                 "meta": ResponseMetaData.from_dict(obj.get("meta")) if obj.get("meta") is not None else None,
                 "links": ResponseLinks.from_dict(obj.get("links")) if obj.get("links") is not None else None,
                 "included": IncludedData.from_dict(obj.get("included")) if obj.get("included") is not None else None,
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/pool_post_body.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/pool_post_body.py`

 * *Files 6% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictInt, StrictStr, constr, validator
 
 
 class PoolPostBody(BaseModel):
     """
@@ -70,22 +69,26 @@
         "nameLatin",
         "abbreviationLatin",
         "poolOrder",
         "externalId",
     ]
 
     @validator("external_id")
-    def external_id_validate_regular_expression(cls, v):
-        if v is None:
-            return v
-        if not re.match(r"^[0-9A-Za-z\/_-]+$", v):
+    def external_id_validate_regular_expression(cls, value):
+        """Validates the regular expression"""
+        if value is None:
+            return value
+
+        if not re.match(r"^[0-9A-Za-z\/_-]+$", value):
             raise ValueError(r"must validate the regular expression /^[0-9A-Za-z\/_-]+$/")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -140,15 +143,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> PoolPostBody:
         """Create an instance of PoolPostBody from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return PoolPostBody.parse_obj(obj)
 
         _obj = PoolPostBody.parse_obj(
             {
                 "season_id": obj.get("seasonId"),
                 "pool_code": obj.get("poolCode"),
                 "stage_code": obj.get("stageCode"),
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/pool_put_body.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/pool_put_body.py`

 * *Files 4% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictInt, constr, validator
 
 
 class PoolPutBody(BaseModel):
     """
@@ -64,22 +63,26 @@
         "nameLatin",
         "abbreviationLatin",
         "poolOrder",
         "externalId",
     ]
 
     @validator("external_id")
-    def external_id_validate_regular_expression(cls, v):
-        if v is None:
-            return v
-        if not re.match(r"^[0-9A-Za-z\/_-]+$", v):
+    def external_id_validate_regular_expression(cls, value):
+        """Validates the regular expression"""
+        if value is None:
+            return value
+
+        if not re.match(r"^[0-9A-Za-z\/_-]+$", value):
             raise ValueError(r"must validate the regular expression /^[0-9A-Za-z\/_-]+$/")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -134,15 +137,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> PoolPutBody:
         """Create an instance of PoolPutBody from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return PoolPutBody.parse_obj(obj)
 
         _obj = PoolPutBody.parse_obj(
             {
                 "stage_code": obj.get("stageCode"),
                 "name_local": obj.get("nameLocal"),
                 "abbreviation_local": obj.get("abbreviationLocal"),
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/ranking_rows_model.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/ranking_rows_model.py`

 * *Files 8% similar despite different names*

```diff
@@ -14,15 +14,14 @@
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
 from datetime import datetime
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictInt, StrictStr, constr
 
 from atriumsports.datacore.openapi.models.fixture_entities_model_entity import FixtureEntitiesModelEntity
 
 
@@ -63,14 +62,16 @@
         "points",
         "pointsString",
         "updated",
         "added",
     ]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -125,15 +126,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> RankingRowsModel:
         """Create an instance of RankingRowsModel from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return RankingRowsModel.parse_obj(obj)
 
         _obj = RankingRowsModel.parse_obj(
             {
                 "row_id": obj.get("rowId"),
                 "organization_id": obj.get("organizationId"),
                 "ranking_id": obj.get("rankingId"),
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/ranking_rows_post_body.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/ranking_rows_post_body.py`

 * *Files 2% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictInt, StrictStr, constr
 
 
 class RankingRowsPostBody(BaseModel):
     """
@@ -52,14 +51,16 @@
         "position",
         "forceOrder",
         "points",
         "pointsString",
     ]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -104,15 +105,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> RankingRowsPostBody:
         """Create an instance of RankingRowsPostBody from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return RankingRowsPostBody.parse_obj(obj)
 
         _obj = RankingRowsPostBody.parse_obj(
             {
                 "row_id": obj.get("rowId"),
                 "organization_id": obj.get("organizationId"),
                 "ranking_id": obj.get("rankingId"),
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/ranking_rows_put_body.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/ranking_rows_put_body.py`

 * *Files 2% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictInt, StrictStr, constr
 
 
 class RankingRowsPutBody(BaseModel):
     """
@@ -52,14 +51,16 @@
         "position",
         "forceOrder",
         "points",
         "pointsString",
     ]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -104,15 +105,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> RankingRowsPutBody:
         """Create an instance of RankingRowsPutBody from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return RankingRowsPutBody.parse_obj(obj)
 
         _obj = RankingRowsPutBody.parse_obj(
             {
                 "organization_id": obj.get("organizationId"),
                 "ranking_id": obj.get("rankingId"),
                 "ranking_run_id": obj.get("rankingRunId"),
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/ranking_rows_response.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/success_response.py`

 * *Files 10% similar despite different names*

```diff
@@ -13,51 +13,52 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import List, Optional
 
 from pydantic import BaseModel, conlist
 
 from atriumsports.datacore.openapi.models.included_data import IncludedData
-from atriumsports.datacore.openapi.models.ranking_rows_model import RankingRowsModel
 from atriumsports.datacore.openapi.models.response_links import ResponseLinks
 from atriumsports.datacore.openapi.models.response_meta_data import ResponseMetaData
+from atriumsports.datacore.openapi.models.success_model import SuccessModel
 
 
-class RankingRowsResponse(BaseModel):
+class SuccessResponse(BaseModel):
     """
-    RankingRowsResponse
+    SuccessResponse
     """
 
     meta: Optional[ResponseMetaData] = None
     links: Optional[ResponseLinks] = None
     included: Optional[IncludedData] = None
-    data: Optional[conlist(RankingRowsModel)] = None
+    data: Optional[conlist(SuccessModel)] = None
     __properties = ["meta", "links", "included", "data"]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> RankingRowsResponse:
-        """Create an instance of RankingRowsResponse from a JSON string"""
+    def from_json(cls, json_str: str) -> SuccessResponse:
+        """Create an instance of SuccessResponse from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
     def to_dict(self):
         """Returns the dictionary representation of the model using alias"""
         _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)
         # override the default output from pydantic by calling `to_dict()` of meta
         if self.meta:
@@ -74,26 +75,26 @@
             for _item in self.data:
                 if _item:
                     _items.append(_item.to_dict())
             _dict["data"] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> RankingRowsResponse:
-        """Create an instance of RankingRowsResponse from a dict"""
+    def from_dict(cls, obj: dict) -> SuccessResponse:
+        """Create an instance of SuccessResponse from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
-            return RankingRowsResponse.parse_obj(obj)
+        if not isinstance(obj, dict):
+            return SuccessResponse.parse_obj(obj)
 
-        _obj = RankingRowsResponse.parse_obj(
+        _obj = SuccessResponse.parse_obj(
             {
                 "meta": ResponseMetaData.from_dict(obj.get("meta")) if obj.get("meta") is not None else None,
                 "links": ResponseLinks.from_dict(obj.get("links")) if obj.get("links") is not None else None,
                 "included": IncludedData.from_dict(obj.get("included")) if obj.get("included") is not None else None,
-                "data": [RankingRowsModel.from_dict(_item) for _item in obj.get("data")]
+                "data": [SuccessModel.from_dict(_item) for _item in obj.get("data")]
                 if obj.get("data") is not None
                 else None,
             }
         )
         return _obj
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/response_links.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/response_links.py`

 * *Files 7% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr
 
 
 class ResponseLinks(BaseModel):
     """
@@ -34,14 +33,16 @@
     )
     previous: Optional[StrictStr] = Field(
         None, description="The URI referencing the 'previous' page, if the request is not on the first page."
     )
     __properties = ["self", "next", "previous"]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -61,14 +62,14 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> ResponseLinks:
         """Create an instance of ResponseLinks from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return ResponseLinks.parse_obj(obj)
 
         _obj = ResponseLinks.parse_obj(
             {"var_self": obj.get("self"), "next": obj.get("next"), "previous": obj.get("previous")}
         )
         return _obj
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/response_meta_data.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/response_meta_data.py`

 * *Files 2% similar despite different names*

```diff
@@ -14,16 +14,15 @@
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
 from datetime import datetime
-from inspect import getfullargspec
-from typing import Optional
+from typing import Optional, Union
 
 from pydantic import BaseModel, Field, StrictBool, StrictFloat, StrictInt, StrictStr
 
 
 class ResponseMetaData(BaseModel):
     """
     ResponseMetaData
@@ -37,20 +36,22 @@
     time: Optional[datetime] = Field(None, description="The date/time this request was made (in UTC).")
     from_cache: Optional[StrictBool] = Field(
         None, alias="fromCache", description="Was this request served directly from the cache?"
     )
     count: Optional[StrictInt] = Field(None, description="The number of records being returned")
     limit: Optional[StrictInt] = Field(None, description="The record limit in place for this request")
     offset: Optional[StrictInt] = Field(None, description="The record offset in place for this request")
-    generation_time: Optional[StrictFloat] = Field(
+    generation_time: Optional[Union[StrictFloat, StrictInt]] = Field(
         None, alias="generationTime", description="The number of seconds taken to generate this request."
     )
     __properties = ["version", "codeVersion", "code", "time", "fromCache", "count", "limit", "offset", "generationTime"]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -70,15 +71,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> ResponseMetaData:
         """Create an instance of ResponseMetaData from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return ResponseMetaData.parse_obj(obj)
 
         _obj = ResponseMetaData.parse_obj(
             {
                 "version": obj.get("version"),
                 "code_version": obj.get("codeVersion"),
                 "code": obj.get("code"),
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/role_post_body.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/role_post_body.py`

 * *Files 2% similar despite different names*

```diff
@@ -14,15 +14,14 @@
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
 from datetime import date
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictInt, StrictStr, constr, validator
 
 
 class RolePostBody(BaseModel):
     """
@@ -74,24 +73,27 @@
         "roleNumber",
         "role",
         "roleSubType",
         "externalId",
     ]
 
     @validator("status")
-    def status_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("ACTIVE", "INACTIVE", "PENDING"):
+    def status_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("ACTIVE", "INACTIVE", "PENDING"):
             raise ValueError("must be one of enum values ('ACTIVE', 'INACTIVE', 'PENDING')")
-        return v
+        return value
 
     @validator("role")
-    def role_validate_enum(cls, v):
-        if v not in (
+    def role_validate_enum(cls, value):
+        """Validates the enum"""
+        if value not in (
             "COACH",
             "COACH_HEAD",
             "COACH_HEAD_INTERIM",
             "COACH_ASSISTANT",
             "COACH_ASSISTANT_HEAD",
             "COACH_ASSOCIATE_HEAD",
             "COACH_SC",
@@ -140,25 +142,29 @@
             "VIDEO_TECHNICIAN",
             "TRANSLATOR",
             "MEDIA_OFFICER",
         ):
             raise ValueError(
                 "must be one of enum values ('COACH', 'COACH_HEAD', 'COACH_HEAD_INTERIM', 'COACH_ASSISTANT', 'COACH_ASSISTANT_HEAD', 'COACH_ASSOCIATE_HEAD', 'COACH_SC', 'COACH_SENIOR', 'COACH_DEVELOPMENT', 'COACH_SPECIALIST', 'COACH_OTHER', 'CAPTAIN', 'CAPTAIN_VICE', 'DOCTOR', 'PHYSIOTHERAPIST', 'MEDICAL_STAFF', 'TRAINER', 'TRAINER_ASSISTANT', 'MATCH_OFFICIAL', 'COMMISSIONER', 'STATISTICIAN', 'SCOREKEEPER', 'SCOREKEEPER_ASSISTANT', 'TIMEKEEPER', 'SCORER', 'SCORER_ASSISTANT', 'TIMER', 'GROUNDSKEEPER', 'CEO', 'COMMITTEE', 'PRESIDENT', 'DIRECTOR', 'PRESIDENT_VICE', 'SECRETARY', 'TREASURER', 'MANAGER', 'GENERAL', 'OTHER', 'REFEREE', 'UMPIRE', 'REFEREE_ASSISTANT', 'REFEREE_RESERVE', 'REFEREE_ASSISTANT_RESERVE', 'CREW_CHIEF', 'UMPIRE_RESERVE', 'UMPIRE_VIDEO', 'JUDGE_SCORING', 'JUDGE_TIMING', 'TECHNICAL_OFFICIAL', 'VIDEO_TECHNICIAN', 'TRANSLATOR', 'MEDIA_OFFICER')"
             )
-        return v
+        return value
 
     @validator("external_id")
-    def external_id_validate_regular_expression(cls, v):
-        if v is None:
-            return v
-        if not re.match(r"^[0-9A-Za-z\/_-]+$", v):
+    def external_id_validate_regular_expression(cls, value):
+        """Validates the regular expression"""
+        if value is None:
+            return value
+
+        if not re.match(r"^[0-9A-Za-z\/_-]+$", value):
             raise ValueError(r"must validate the regular expression /^[0-9A-Za-z\/_-]+$/")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -228,15 +234,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> RolePostBody:
         """Create an instance of RolePostBody from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return RolePostBody.parse_obj(obj)
 
         _obj = RolePostBody.parse_obj(
             {
                 "role_id": obj.get("roleId"),
                 "entity_group_id": obj.get("entityGroupId"),
                 "entity_id": obj.get("entityId"),
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/role_put_body.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/role_put_body.py`

 * *Files 5% similar despite different names*

```diff
@@ -14,15 +14,14 @@
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
 from datetime import date
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictInt, StrictStr, constr, validator
 
 
 class RolePutBody(BaseModel):
     """
@@ -72,26 +71,30 @@
         "roleNumber",
         "role",
         "roleSubType",
         "externalId",
     ]
 
     @validator("status")
-    def status_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("ACTIVE", "INACTIVE", "PENDING"):
+    def status_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("ACTIVE", "INACTIVE", "PENDING"):
             raise ValueError("must be one of enum values ('ACTIVE', 'INACTIVE', 'PENDING')")
-        return v
+        return value
 
     @validator("role")
-    def role_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in (
+    def role_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in (
             "COACH",
             "COACH_HEAD",
             "COACH_HEAD_INTERIM",
             "COACH_ASSISTANT",
             "COACH_ASSISTANT_HEAD",
             "COACH_ASSOCIATE_HEAD",
             "COACH_SC",
@@ -140,25 +143,29 @@
             "VIDEO_TECHNICIAN",
             "TRANSLATOR",
             "MEDIA_OFFICER",
         ):
             raise ValueError(
                 "must be one of enum values ('COACH', 'COACH_HEAD', 'COACH_HEAD_INTERIM', 'COACH_ASSISTANT', 'COACH_ASSISTANT_HEAD', 'COACH_ASSOCIATE_HEAD', 'COACH_SC', 'COACH_SENIOR', 'COACH_DEVELOPMENT', 'COACH_SPECIALIST', 'COACH_OTHER', 'CAPTAIN', 'CAPTAIN_VICE', 'DOCTOR', 'PHYSIOTHERAPIST', 'MEDICAL_STAFF', 'TRAINER', 'TRAINER_ASSISTANT', 'MATCH_OFFICIAL', 'COMMISSIONER', 'STATISTICIAN', 'SCOREKEEPER', 'SCOREKEEPER_ASSISTANT', 'TIMEKEEPER', 'SCORER', 'SCORER_ASSISTANT', 'TIMER', 'GROUNDSKEEPER', 'CEO', 'COMMITTEE', 'PRESIDENT', 'DIRECTOR', 'PRESIDENT_VICE', 'SECRETARY', 'TREASURER', 'MANAGER', 'GENERAL', 'OTHER', 'REFEREE', 'UMPIRE', 'REFEREE_ASSISTANT', 'REFEREE_RESERVE', 'REFEREE_ASSISTANT_RESERVE', 'CREW_CHIEF', 'UMPIRE_RESERVE', 'UMPIRE_VIDEO', 'JUDGE_SCORING', 'JUDGE_TIMING', 'TECHNICAL_OFFICIAL', 'VIDEO_TECHNICIAN', 'TRANSLATOR', 'MEDIA_OFFICER')"
             )
-        return v
+        return value
 
     @validator("external_id")
-    def external_id_validate_regular_expression(cls, v):
-        if v is None:
-            return v
-        if not re.match(r"^[0-9A-Za-z\/_-]+$", v):
+    def external_id_validate_regular_expression(cls, value):
+        """Validates the regular expression"""
+        if value is None:
+            return value
+
+        if not re.match(r"^[0-9A-Za-z\/_-]+$", value):
             raise ValueError(r"must validate the regular expression /^[0-9A-Za-z\/_-]+$/")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -228,15 +235,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> RolePutBody:
         """Create an instance of RolePutBody from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return RolePutBody.parse_obj(obj)
 
         _obj = RolePutBody.parse_obj(
             {
                 "entity_group_id": obj.get("entityGroupId"),
                 "entity_id": obj.get("entityId"),
                 "season_id": obj.get("seasonId"),
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/roles_model.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/roles_model.py`

 * *Files 2% similar despite different names*

```diff
@@ -14,15 +14,14 @@
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
 from datetime import date, datetime
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictInt, StrictStr, constr, validator
 
 from atriumsports.datacore.openapi.models.entities_model_entity_group import EntitiesModelEntityGroup
 from atriumsports.datacore.openapi.models.fixture_entities_model_entity import FixtureEntitiesModelEntity
 from atriumsports.datacore.openapi.models.fixture_persons_model_person import FixturePersonsModelPerson
@@ -101,26 +100,30 @@
         "roleSubType",
         "externalId",
         "updated",
         "added",
     ]
 
     @validator("status")
-    def status_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("ACTIVE", "INACTIVE", "PENDING"):
+    def status_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("ACTIVE", "INACTIVE", "PENDING"):
             raise ValueError("must be one of enum values ('ACTIVE', 'INACTIVE', 'PENDING')")
-        return v
+        return value
 
     @validator("role")
-    def role_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in (
+    def role_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in (
             "COACH",
             "COACH_HEAD",
             "COACH_HEAD_INTERIM",
             "COACH_ASSISTANT",
             "COACH_ASSISTANT_HEAD",
             "COACH_ASSOCIATE_HEAD",
             "COACH_SC",
@@ -169,25 +172,29 @@
             "VIDEO_TECHNICIAN",
             "TRANSLATOR",
             "MEDIA_OFFICER",
         ):
             raise ValueError(
                 "must be one of enum values ('COACH', 'COACH_HEAD', 'COACH_HEAD_INTERIM', 'COACH_ASSISTANT', 'COACH_ASSISTANT_HEAD', 'COACH_ASSOCIATE_HEAD', 'COACH_SC', 'COACH_SENIOR', 'COACH_DEVELOPMENT', 'COACH_SPECIALIST', 'COACH_OTHER', 'CAPTAIN', 'CAPTAIN_VICE', 'DOCTOR', 'PHYSIOTHERAPIST', 'MEDICAL_STAFF', 'TRAINER', 'TRAINER_ASSISTANT', 'MATCH_OFFICIAL', 'COMMISSIONER', 'STATISTICIAN', 'SCOREKEEPER', 'SCOREKEEPER_ASSISTANT', 'TIMEKEEPER', 'SCORER', 'SCORER_ASSISTANT', 'TIMER', 'GROUNDSKEEPER', 'CEO', 'COMMITTEE', 'PRESIDENT', 'DIRECTOR', 'PRESIDENT_VICE', 'SECRETARY', 'TREASURER', 'MANAGER', 'GENERAL', 'OTHER', 'REFEREE', 'UMPIRE', 'REFEREE_ASSISTANT', 'REFEREE_RESERVE', 'REFEREE_ASSISTANT_RESERVE', 'CREW_CHIEF', 'UMPIRE_RESERVE', 'UMPIRE_VIDEO', 'JUDGE_SCORING', 'JUDGE_TIMING', 'TECHNICAL_OFFICIAL', 'VIDEO_TECHNICIAN', 'TRANSLATOR', 'MEDIA_OFFICER')"
             )
-        return v
+        return value
 
     @validator("external_id")
-    def external_id_validate_regular_expression(cls, v):
-        if v is None:
-            return v
-        if not re.match(r"^[0-9A-Za-z\/_-]+$", v):
+    def external_id_validate_regular_expression(cls, value):
+        """Validates the regular expression"""
+        if value is None:
+            return value
+
+        if not re.match(r"^[0-9A-Za-z\/_-]+$", value):
             raise ValueError(r"must validate the regular expression /^[0-9A-Za-z\/_-]+$/")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -283,15 +290,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> RolesModel:
         """Create an instance of RolesModel from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return RolesModel.parse_obj(obj)
 
         _obj = RolesModel.parse_obj(
             {
                 "role_id": obj.get("roleId"),
                 "organization_id": obj.get("organizationId"),
                 "organization": RolesModelOrganization.from_dict(obj.get("organization"))
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/roles_model_organization.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/roles_model_organization.py`

 * *Files 6% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr, validator
 
 
 class RolesModelOrganization(BaseModel):
     """
@@ -29,22 +28,26 @@
     """
 
     resource_type: Optional[StrictStr] = Field(None, alias="resourceType")
     id: Optional[StrictStr] = Field(None, description="Unique identifier for this resource")
     __properties = ["resourceType", "id"]
 
     @validator("resource_type")
-    def resource_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("organizations"):
+    def resource_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("organizations"):
             raise ValueError("must be one of enum values ('organizations')")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -64,12 +67,12 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> RolesModelOrganization:
         """Create an instance of RolesModelOrganization from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return RolesModelOrganization.parse_obj(obj)
 
         _obj = RolesModelOrganization.parse_obj({"resource_type": obj.get("resourceType"), "id": obj.get("id")})
         return _obj
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/roles_response.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/sites_response.py`

 * *Files 10% similar despite different names*

```diff
@@ -13,51 +13,52 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import List, Optional
 
 from pydantic import BaseModel, conlist
 
 from atriumsports.datacore.openapi.models.included_data import IncludedData
 from atriumsports.datacore.openapi.models.response_links import ResponseLinks
 from atriumsports.datacore.openapi.models.response_meta_data import ResponseMetaData
-from atriumsports.datacore.openapi.models.roles_model import RolesModel
+from atriumsports.datacore.openapi.models.sites_model import SitesModel
 
 
-class RolesResponse(BaseModel):
+class SitesResponse(BaseModel):
     """
-    RolesResponse
+    SitesResponse
     """
 
     meta: Optional[ResponseMetaData] = None
     links: Optional[ResponseLinks] = None
     included: Optional[IncludedData] = None
-    data: Optional[conlist(RolesModel)] = None
+    data: Optional[conlist(SitesModel)] = None
     __properties = ["meta", "links", "included", "data"]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> RolesResponse:
-        """Create an instance of RolesResponse from a JSON string"""
+    def from_json(cls, json_str: str) -> SitesResponse:
+        """Create an instance of SitesResponse from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
     def to_dict(self):
         """Returns the dictionary representation of the model using alias"""
         _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)
         # override the default output from pydantic by calling `to_dict()` of meta
         if self.meta:
@@ -74,26 +75,26 @@
             for _item in self.data:
                 if _item:
                     _items.append(_item.to_dict())
             _dict["data"] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> RolesResponse:
-        """Create an instance of RolesResponse from a dict"""
+    def from_dict(cls, obj: dict) -> SitesResponse:
+        """Create an instance of SitesResponse from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
-            return RolesResponse.parse_obj(obj)
+        if not isinstance(obj, dict):
+            return SitesResponse.parse_obj(obj)
 
-        _obj = RolesResponse.parse_obj(
+        _obj = SitesResponse.parse_obj(
             {
                 "meta": ResponseMetaData.from_dict(obj.get("meta")) if obj.get("meta") is not None else None,
                 "links": ResponseLinks.from_dict(obj.get("links")) if obj.get("links") is not None else None,
                 "included": IncludedData.from_dict(obj.get("included")) if obj.get("included") is not None else None,
-                "data": [RolesModel.from_dict(_item) for _item in obj.get("data")]
+                "data": [SitesModel.from_dict(_item) for _item in obj.get("data")]
                 if obj.get("data") is not None
                 else None,
             }
         )
         return _obj
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/round_post_body.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/round_post_body.py`

 * *Files 4% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr, conint, constr, validator
 
 
 class RoundPostBody(BaseModel):
     """
@@ -78,22 +77,26 @@
         "abbreviationLocal",
         "abbreviationLatin",
         "roundOrder",
         "externalId",
     ]
 
     @validator("external_id")
-    def external_id_validate_regular_expression(cls, v):
-        if v is None:
-            return v
-        if not re.match(r"^[0-9A-Za-z\/_-]+$", v):
+    def external_id_validate_regular_expression(cls, value):
+        """Validates the regular expression"""
+        if value is None:
+            return value
+
+        if not re.match(r"^[0-9A-Za-z\/_-]+$", value):
             raise ValueError(r"must validate the regular expression /^[0-9A-Za-z\/_-]+$/")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -158,15 +161,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> RoundPostBody:
         """Create an instance of RoundPostBody from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return RoundPostBody.parse_obj(obj)
 
         _obj = RoundPostBody.parse_obj(
             {
                 "season_id": obj.get("seasonId"),
                 "round_code": obj.get("roundCode"),
                 "pool_code": obj.get("poolCode"),
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/round_put_body.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/round_put_body.py`

 * *Files 3% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, conint, constr, validator
 
 
 class RoundPutBody(BaseModel):
     """
@@ -72,22 +71,26 @@
         "abbreviationLocal",
         "abbreviationLatin",
         "roundOrder",
         "externalId",
     ]
 
     @validator("external_id")
-    def external_id_validate_regular_expression(cls, v):
-        if v is None:
-            return v
-        if not re.match(r"^[0-9A-Za-z\/_-]+$", v):
+    def external_id_validate_regular_expression(cls, value):
+        """Validates the regular expression"""
+        if value is None:
+            return value
+
+        if not re.match(r"^[0-9A-Za-z\/_-]+$", value):
             raise ValueError(r"must validate the regular expression /^[0-9A-Za-z\/_-]+$/")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -152,15 +155,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> RoundPutBody:
         """Create an instance of RoundPutBody from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return RoundPutBody.parse_obj(obj)
 
         _obj = RoundPutBody.parse_obj(
             {
                 "pool_code": obj.get("poolCode"),
                 "stage_code": obj.get("stageCode"),
                 "round_number": obj.get("roundNumber"),
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_entities_list_model.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_entities_list_model.py`

 * *Files 3% similar despite different names*

```diff
@@ -14,15 +14,14 @@
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
 from datetime import datetime
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictInt, StrictStr, constr, validator
 
 from atriumsports.datacore.openapi.models.fixture_entities_model_conference import FixtureEntitiesModelConference
 from atriumsports.datacore.openapi.models.fixture_entities_model_division import FixtureEntitiesModelDivision
 from atriumsports.datacore.openapi.models.fixture_entities_model_entity import FixtureEntitiesModelEntity
@@ -83,38 +82,46 @@
         "externalId",
         "updated",
         "added",
         "rosterStatus",
     ]
 
     @validator("status")
-    def status_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("ACTIVE", "INACTIVE", "PENDING"):
+    def status_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("ACTIVE", "INACTIVE", "PENDING"):
             raise ValueError("must be one of enum values ('ACTIVE', 'INACTIVE', 'PENDING')")
-        return v
+        return value
 
     @validator("external_id")
-    def external_id_validate_regular_expression(cls, v):
-        if v is None:
-            return v
-        if not re.match(r"^[0-9A-Za-z\/_-]+$", v):
+    def external_id_validate_regular_expression(cls, value):
+        """Validates the regular expression"""
+        if value is None:
+            return value
+
+        if not re.match(r"^[0-9A-Za-z\/_-]+$", value):
             raise ValueError(r"must validate the regular expression /^[0-9A-Za-z\/_-]+$/")
-        return v
+        return value
 
     @validator("roster_status")
-    def roster_status_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("UNKNOWN", "SUBMITTED", "PENDING", "APPROVED", "REJECTED"):
+    def roster_status_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("UNKNOWN", "SUBMITTED", "PENDING", "APPROVED", "REJECTED"):
             raise ValueError("must be one of enum values ('UNKNOWN', 'SUBMITTED', 'PENDING', 'APPROVED', 'REJECTED')")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -172,15 +179,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> SeasonEntitiesListModel:
         """Create an instance of SeasonEntitiesListModel from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return SeasonEntitiesListModel.parse_obj(obj)
 
         _obj = SeasonEntitiesListModel.parse_obj(
             {
                 "season_id": obj.get("seasonId"),
                 "season": FixtureProgressionsModelSeason.from_dict(obj.get("season"))
                 if obj.get("season") is not None
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_entities_list_model_organization.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_persons_list_model_organization.py`

 * *Files 9% similar despite different names*

```diff
@@ -13,65 +13,68 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr, validator
 
 
-class SeasonEntitiesListModelOrganization(BaseModel):
+class SeasonPersonsListModelOrganization(BaseModel):
     """
-    The organization that this season entities belongs to
+    The organization that this season persons belongs to
     """
 
     resource_type: Optional[StrictStr] = Field(None, alias="resourceType")
     id: Optional[StrictStr] = Field(None, description="Unique identifier for this resource")
     __properties = ["resourceType", "id"]
 
     @validator("resource_type")
-    def resource_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("organizations"):
+    def resource_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("organizations"):
             raise ValueError("must be one of enum values ('organizations')")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> SeasonEntitiesListModelOrganization:
-        """Create an instance of SeasonEntitiesListModelOrganization from a JSON string"""
+    def from_json(cls, json_str: str) -> SeasonPersonsListModelOrganization:
+        """Create an instance of SeasonPersonsListModelOrganization from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
     def to_dict(self):
         """Returns the dictionary representation of the model using alias"""
         _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> SeasonEntitiesListModelOrganization:
-        """Create an instance of SeasonEntitiesListModelOrganization from a dict"""
+    def from_dict(cls, obj: dict) -> SeasonPersonsListModelOrganization:
+        """Create an instance of SeasonPersonsListModelOrganization from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
-            return SeasonEntitiesListModelOrganization.parse_obj(obj)
+        if not isinstance(obj, dict):
+            return SeasonPersonsListModelOrganization.parse_obj(obj)
 
-        _obj = SeasonEntitiesListModelOrganization.parse_obj(
+        _obj = SeasonPersonsListModelOrganization.parse_obj(
             {"resource_type": obj.get("resourceType"), "id": obj.get("id")}
         )
         return _obj
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_entities_list_response.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_entities_list_response.py`

 * *Files 4% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import List, Optional
 
 from pydantic import BaseModel, conlist
 
 from atriumsports.datacore.openapi.models.included_data import IncludedData
 from atriumsports.datacore.openapi.models.response_links import ResponseLinks
 from atriumsports.datacore.openapi.models.response_meta_data import ResponseMetaData
@@ -36,14 +35,16 @@
     meta: Optional[ResponseMetaData] = None
     links: Optional[ResponseLinks] = None
     included: Optional[IncludedData] = None
     data: Optional[conlist(SeasonEntitiesListModel)] = None
     __properties = ["meta", "links", "included", "data"]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -79,15 +80,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> SeasonEntitiesListResponse:
         """Create an instance of SeasonEntitiesListResponse from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return SeasonEntitiesListResponse.parse_obj(obj)
 
         _obj = SeasonEntitiesListResponse.parse_obj(
             {
                 "meta": ResponseMetaData.from_dict(obj.get("meta")) if obj.get("meta") is not None else None,
                 "links": ResponseLinks.from_dict(obj.get("links")) if obj.get("links") is not None else None,
                 "included": IncludedData.from_dict(obj.get("included")) if obj.get("included") is not None else None,
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_entities_model.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_entities_model.py`

 * *Files 4% similar despite different names*

```diff
@@ -14,15 +14,14 @@
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
 from datetime import datetime
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr, conint, constr, validator
 
 from atriumsports.datacore.openapi.models.fixture_entities_model_conference import FixtureEntitiesModelConference
 from atriumsports.datacore.openapi.models.fixture_entities_model_division import FixtureEntitiesModelDivision
 from atriumsports.datacore.openapi.models.fixture_entities_model_entity import FixtureEntitiesModelEntity
@@ -83,38 +82,46 @@
         "seed",
         "externalId",
         "updated",
         "added",
     ]
 
     @validator("roster_status")
-    def roster_status_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("UNKNOWN", "SUBMITTED", "PENDING", "APPROVED", "REJECTED"):
+    def roster_status_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("UNKNOWN", "SUBMITTED", "PENDING", "APPROVED", "REJECTED"):
             raise ValueError("must be one of enum values ('UNKNOWN', 'SUBMITTED', 'PENDING', 'APPROVED', 'REJECTED')")
-        return v
+        return value
 
     @validator("status")
-    def status_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("ACTIVE", "INACTIVE", "PENDING"):
+    def status_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("ACTIVE", "INACTIVE", "PENDING"):
             raise ValueError("must be one of enum values ('ACTIVE', 'INACTIVE', 'PENDING')")
-        return v
+        return value
 
     @validator("external_id")
-    def external_id_validate_regular_expression(cls, v):
-        if v is None:
-            return v
-        if not re.match(r"^[0-9A-Za-z\/_-]+$", v):
+    def external_id_validate_regular_expression(cls, value):
+        """Validates the regular expression"""
+        if value is None:
+            return value
+
+        if not re.match(r"^[0-9A-Za-z\/_-]+$", value):
             raise ValueError(r"must validate the regular expression /^[0-9A-Za-z\/_-]+$/")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -177,15 +184,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> SeasonEntitiesModel:
         """Create an instance of SeasonEntitiesModel from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return SeasonEntitiesModel.parse_obj(obj)
 
         _obj = SeasonEntitiesModel.parse_obj(
             {
                 "season_id": obj.get("seasonId"),
                 "season": FixtureProgressionsModelSeason.from_dict(obj.get("season"))
                 if obj.get("season") is not None
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_entities_post_body.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_entities_post_body.py`

 * *Files 8% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr, conint, constr, validator
 
 
 class SeasonEntitiesPostBody(BaseModel):
     """
@@ -56,38 +55,46 @@
         "rosterStatus",
         "status",
         "seed",
         "externalId",
     ]
 
     @validator("roster_status")
-    def roster_status_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("UNKNOWN", "SUBMITTED", "PENDING", "APPROVED", "REJECTED"):
+    def roster_status_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("UNKNOWN", "SUBMITTED", "PENDING", "APPROVED", "REJECTED"):
             raise ValueError("must be one of enum values ('UNKNOWN', 'SUBMITTED', 'PENDING', 'APPROVED', 'REJECTED')")
-        return v
+        return value
 
     @validator("status")
-    def status_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("ACTIVE", "INACTIVE", "PENDING"):
+    def status_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("ACTIVE", "INACTIVE", "PENDING"):
             raise ValueError("must be one of enum values ('ACTIVE', 'INACTIVE', 'PENDING')")
-        return v
+        return value
 
     @validator("external_id")
-    def external_id_validate_regular_expression(cls, v):
-        if v is None:
-            return v
-        if not re.match(r"^[0-9A-Za-z\/_-]+$", v):
+    def external_id_validate_regular_expression(cls, value):
+        """Validates the regular expression"""
+        if value is None:
+            return value
+
+        if not re.match(r"^[0-9A-Za-z\/_-]+$", value):
             raise ValueError(r"must validate the regular expression /^[0-9A-Za-z\/_-]+$/")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -127,15 +134,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> SeasonEntitiesPostBody:
         """Create an instance of SeasonEntitiesPostBody from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return SeasonEntitiesPostBody.parse_obj(obj)
 
         _obj = SeasonEntitiesPostBody.parse_obj(
             {
                 "season_id": obj.get("seasonId"),
                 "entity_id": obj.get("entityId"),
                 "conference_id": obj.get("conferenceId"),
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_entities_response.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_entities_response.py`

 * *Files 3% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import List, Optional
 
 from pydantic import BaseModel, conlist
 
 from atriumsports.datacore.openapi.models.included_data import IncludedData
 from atriumsports.datacore.openapi.models.response_links import ResponseLinks
 from atriumsports.datacore.openapi.models.response_meta_data import ResponseMetaData
@@ -36,14 +35,16 @@
     meta: Optional[ResponseMetaData] = None
     links: Optional[ResponseLinks] = None
     included: Optional[IncludedData] = None
     data: Optional[conlist(SeasonEntitiesModel)] = None
     __properties = ["meta", "links", "included", "data"]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -79,15 +80,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> SeasonEntitiesResponse:
         """Create an instance of SeasonEntitiesResponse from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return SeasonEntitiesResponse.parse_obj(obj)
 
         _obj = SeasonEntitiesResponse.parse_obj(
             {
                 "meta": ResponseMetaData.from_dict(obj.get("meta")) if obj.get("meta") is not None else None,
                 "links": ResponseLinks.from_dict(obj.get("links")) if obj.get("links") is not None else None,
                 "included": IncludedData.from_dict(obj.get("included")) if obj.get("included") is not None else None,
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_entity_base_statistics_model.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_entity_base_statistics_model.py`

 * *Files 4% similar despite different names*

```diff
@@ -14,15 +14,14 @@
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
 from datetime import datetime
-from inspect import getfullargspec
 from typing import Any, Dict, Optional
 
 from pydantic import BaseModel, Field, StrictStr, constr, validator
 
 from atriumsports.datacore.openapi.models.fixture_entities_model_entity import FixtureEntitiesModelEntity
 from atriumsports.datacore.openapi.models.fixture_progressions_model_season import FixtureProgressionsModelSeason
 from atriumsports.datacore.openapi.models.season_entity_base_statistics_model_organization import (
@@ -67,32 +66,38 @@
         "competitorType",
         "statistics",
         "updated",
         "added",
     ]
 
     @validator("fixture_type")
-    def fixture_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("ALL_STAR", "PRESEASON", "REGULAR", "FINAL", "PLAYOFF", "FRIENDLY", "DEMONSTRATION"):
+    def fixture_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("ALL_STAR", "PRESEASON", "REGULAR", "FINAL", "PLAYOFF", "FRIENDLY", "DEMONSTRATION"):
             raise ValueError(
                 "must be one of enum values ('ALL_STAR', 'PRESEASON', 'REGULAR', 'FINAL', 'PLAYOFF', 'FRIENDLY', 'DEMONSTRATION')"
             )
-        return v
+        return value
 
     @validator("competitor_type")
-    def competitor_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("PERSON", "ENTITY"):
+    def competitor_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("PERSON", "ENTITY"):
             raise ValueError("must be one of enum values ('PERSON', 'ENTITY')")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -129,15 +134,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> SeasonEntityBaseStatisticsModel:
         """Create an instance of SeasonEntityBaseStatisticsModel from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return SeasonEntityBaseStatisticsModel.parse_obj(obj)
 
         _obj = SeasonEntityBaseStatisticsModel.parse_obj(
             {
                 "season_id": obj.get("seasonId"),
                 "season": FixtureProgressionsModelSeason.from_dict(obj.get("season"))
                 if obj.get("season") is not None
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_entity_base_statistics_model_organization.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_entity_statistics_model_organization.py`

 * *Files 8% similar despite different names*

```diff
@@ -13,65 +13,68 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr, validator
 
 
-class SeasonEntityBaseStatisticsModelOrganization(BaseModel):
+class SeasonEntityStatisticsModelOrganization(BaseModel):
     """
-    The organization that this season entity base statistics belongs to
+    The organization that this season entity statistics belongs to
     """
 
     resource_type: Optional[StrictStr] = Field(None, alias="resourceType")
     id: Optional[StrictStr] = Field(None, description="Unique identifier for this resource")
     __properties = ["resourceType", "id"]
 
     @validator("resource_type")
-    def resource_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("organizations"):
+    def resource_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("organizations"):
             raise ValueError("must be one of enum values ('organizations')")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> SeasonEntityBaseStatisticsModelOrganization:
-        """Create an instance of SeasonEntityBaseStatisticsModelOrganization from a JSON string"""
+    def from_json(cls, json_str: str) -> SeasonEntityStatisticsModelOrganization:
+        """Create an instance of SeasonEntityStatisticsModelOrganization from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
     def to_dict(self):
         """Returns the dictionary representation of the model using alias"""
         _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> SeasonEntityBaseStatisticsModelOrganization:
-        """Create an instance of SeasonEntityBaseStatisticsModelOrganization from a dict"""
+    def from_dict(cls, obj: dict) -> SeasonEntityStatisticsModelOrganization:
+        """Create an instance of SeasonEntityStatisticsModelOrganization from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
-            return SeasonEntityBaseStatisticsModelOrganization.parse_obj(obj)
+        if not isinstance(obj, dict):
+            return SeasonEntityStatisticsModelOrganization.parse_obj(obj)
 
-        _obj = SeasonEntityBaseStatisticsModelOrganization.parse_obj(
+        _obj = SeasonEntityStatisticsModelOrganization.parse_obj(
             {"resource_type": obj.get("resourceType"), "id": obj.get("id")}
         )
         return _obj
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_entity_base_statistics_post_body.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_entity_base_statistics_post_body.py`

 * *Files 8% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Any, Dict, Optional
 
 from pydantic import BaseModel, Field, StrictStr, constr, validator
 
 
 class SeasonEntityBaseStatisticsPostBody(BaseModel):
     """
@@ -40,28 +39,32 @@
         alias="competitorType",
         description="The type of competitors in this fixture >- `ENTITY` Entity >- `PERSON` Person ",
     )
     statistics: Optional[Dict[str, Any]] = None
     __properties = ["seasonId", "entityId", "fixtureType", "competitorType", "statistics"]
 
     @validator("fixture_type")
-    def fixture_type_validate_enum(cls, v):
-        if v not in ("ALL_STAR", "PRESEASON", "REGULAR", "FINAL", "PLAYOFF", "FRIENDLY", "DEMONSTRATION"):
+    def fixture_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value not in ("ALL_STAR", "PRESEASON", "REGULAR", "FINAL", "PLAYOFF", "FRIENDLY", "DEMONSTRATION"):
             raise ValueError(
                 "must be one of enum values ('ALL_STAR', 'PRESEASON', 'REGULAR', 'FINAL', 'PLAYOFF', 'FRIENDLY', 'DEMONSTRATION')"
             )
-        return v
+        return value
 
     @validator("competitor_type")
-    def competitor_type_validate_enum(cls, v):
-        if v not in ("PERSON", "ENTITY"):
+    def competitor_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value not in ("PERSON", "ENTITY"):
             raise ValueError("must be one of enum values ('PERSON', 'ENTITY')")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -81,15 +84,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> SeasonEntityBaseStatisticsPostBody:
         """Create an instance of SeasonEntityBaseStatisticsPostBody from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return SeasonEntityBaseStatisticsPostBody.parse_obj(obj)
 
         _obj = SeasonEntityBaseStatisticsPostBody.parse_obj(
             {
                 "season_id": obj.get("seasonId"),
                 "entity_id": obj.get("entityId"),
                 "fixture_type": obj.get("fixtureType"),
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_entity_base_statistics_response.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_person_base_statistics_response.py`

 * *Files 6% similar despite different names*

```diff
@@ -13,51 +13,52 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import List, Optional
 
 from pydantic import BaseModel, conlist
 
 from atriumsports.datacore.openapi.models.included_data import IncludedData
 from atriumsports.datacore.openapi.models.response_links import ResponseLinks
 from atriumsports.datacore.openapi.models.response_meta_data import ResponseMetaData
-from atriumsports.datacore.openapi.models.season_entity_base_statistics_model import SeasonEntityBaseStatisticsModel
+from atriumsports.datacore.openapi.models.season_person_base_statistics_model import SeasonPersonBaseStatisticsModel
 
 
-class SeasonEntityBaseStatisticsResponse(BaseModel):
+class SeasonPersonBaseStatisticsResponse(BaseModel):
     """
-    SeasonEntityBaseStatisticsResponse
+    SeasonPersonBaseStatisticsResponse
     """
 
     meta: Optional[ResponseMetaData] = None
     links: Optional[ResponseLinks] = None
     included: Optional[IncludedData] = None
-    data: Optional[conlist(SeasonEntityBaseStatisticsModel)] = None
+    data: Optional[conlist(SeasonPersonBaseStatisticsModel)] = None
     __properties = ["meta", "links", "included", "data"]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> SeasonEntityBaseStatisticsResponse:
-        """Create an instance of SeasonEntityBaseStatisticsResponse from a JSON string"""
+    def from_json(cls, json_str: str) -> SeasonPersonBaseStatisticsResponse:
+        """Create an instance of SeasonPersonBaseStatisticsResponse from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
     def to_dict(self):
         """Returns the dictionary representation of the model using alias"""
         _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)
         # override the default output from pydantic by calling `to_dict()` of meta
         if self.meta:
@@ -74,26 +75,26 @@
             for _item in self.data:
                 if _item:
                     _items.append(_item.to_dict())
             _dict["data"] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> SeasonEntityBaseStatisticsResponse:
-        """Create an instance of SeasonEntityBaseStatisticsResponse from a dict"""
+    def from_dict(cls, obj: dict) -> SeasonPersonBaseStatisticsResponse:
+        """Create an instance of SeasonPersonBaseStatisticsResponse from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
-            return SeasonEntityBaseStatisticsResponse.parse_obj(obj)
+        if not isinstance(obj, dict):
+            return SeasonPersonBaseStatisticsResponse.parse_obj(obj)
 
-        _obj = SeasonEntityBaseStatisticsResponse.parse_obj(
+        _obj = SeasonPersonBaseStatisticsResponse.parse_obj(
             {
                 "meta": ResponseMetaData.from_dict(obj.get("meta")) if obj.get("meta") is not None else None,
                 "links": ResponseLinks.from_dict(obj.get("links")) if obj.get("links") is not None else None,
                 "included": IncludedData.from_dict(obj.get("included")) if obj.get("included") is not None else None,
-                "data": [SeasonEntityBaseStatisticsModel.from_dict(_item) for _item in obj.get("data")]
+                "data": [SeasonPersonBaseStatisticsModel.from_dict(_item) for _item in obj.get("data")]
                 if obj.get("data") is not None
                 else None,
             }
         )
         return _obj
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_entity_placings_model.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_entity_placings_model.py`

 * *Files 4% similar despite different names*

```diff
@@ -14,15 +14,14 @@
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
 from datetime import datetime
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictInt, StrictStr, constr
 
 
 class SeasonEntityPlacingsModel(BaseModel):
     """
@@ -51,14 +50,16 @@
         "points",
         "prizeMoney",
         "updated",
         "added",
     ]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -95,15 +96,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> SeasonEntityPlacingsModel:
         """Create an instance of SeasonEntityPlacingsModel from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return SeasonEntityPlacingsModel.parse_obj(obj)
 
         _obj = SeasonEntityPlacingsModel.parse_obj(
             {
                 "placing_id": obj.get("placingId"),
                 "organization_id": obj.get("organizationId"),
                 "season_id": obj.get("seasonId"),
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_entity_placings_response.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_entity_placings_response.py`

 * *Files 8% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import List, Optional
 
 from pydantic import BaseModel, conlist
 
 from atriumsports.datacore.openapi.models.included_data import IncludedData
 from atriumsports.datacore.openapi.models.response_links import ResponseLinks
 from atriumsports.datacore.openapi.models.response_meta_data import ResponseMetaData
@@ -36,14 +35,16 @@
     meta: Optional[ResponseMetaData] = None
     links: Optional[ResponseLinks] = None
     included: Optional[IncludedData] = None
     data: Optional[conlist(SeasonEntityPlacingsModel)] = None
     __properties = ["meta", "links", "included", "data"]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -79,15 +80,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> SeasonEntityPlacingsResponse:
         """Create an instance of SeasonEntityPlacingsResponse from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return SeasonEntityPlacingsResponse.parse_obj(obj)
 
         _obj = SeasonEntityPlacingsResponse.parse_obj(
             {
                 "meta": ResponseMetaData.from_dict(obj.get("meta")) if obj.get("meta") is not None else None,
                 "links": ResponseLinks.from_dict(obj.get("links")) if obj.get("links") is not None else None,
                 "included": IncludedData.from_dict(obj.get("included")) if obj.get("included") is not None else None,
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_entity_statistics_model.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_entity_statistics_model.py`

 * *Files 2% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Any, Dict, Optional
 
 from pydantic import BaseModel, Field, StrictInt, StrictStr
 
 from atriumsports.datacore.openapi.models.fixture_entities_model_entity import FixtureEntitiesModelEntity
 from atriumsports.datacore.openapi.models.fixture_progressions_model_season import FixtureProgressionsModelSeason
 from atriumsports.datacore.openapi.models.season_entity_statistics_model_organization import (
@@ -59,14 +58,16 @@
         "competitionId",
         "competition",
         "periodId",
         "statistics",
     ]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -104,15 +105,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> SeasonEntityStatisticsModel:
         """Create an instance of SeasonEntityStatisticsModel from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return SeasonEntityStatisticsModel.parse_obj(obj)
 
         _obj = SeasonEntityStatisticsModel.parse_obj(
             {
                 "entity_id": obj.get("entityId"),
                 "entity": FixtureEntitiesModelEntity.from_dict(obj.get("entity"))
                 if obj.get("entity") is not None
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_entity_statistics_model_organization.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_series_model_organization.py`

 * *Files 11% similar despite different names*

```diff
@@ -13,65 +13,66 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr, validator
 
 
-class SeasonEntityStatisticsModelOrganization(BaseModel):
+class SeasonSeriesModelOrganization(BaseModel):
     """
-    The organization that this season entity statistics belongs to
+    The organization that this series belongs to
     """
 
     resource_type: Optional[StrictStr] = Field(None, alias="resourceType")
     id: Optional[StrictStr] = Field(None, description="Unique identifier for this resource")
     __properties = ["resourceType", "id"]
 
     @validator("resource_type")
-    def resource_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("organizations"):
+    def resource_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("organizations"):
             raise ValueError("must be one of enum values ('organizations')")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> SeasonEntityStatisticsModelOrganization:
-        """Create an instance of SeasonEntityStatisticsModelOrganization from a JSON string"""
+    def from_json(cls, json_str: str) -> SeasonSeriesModelOrganization:
+        """Create an instance of SeasonSeriesModelOrganization from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
     def to_dict(self):
         """Returns the dictionary representation of the model using alias"""
         _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> SeasonEntityStatisticsModelOrganization:
-        """Create an instance of SeasonEntityStatisticsModelOrganization from a dict"""
+    def from_dict(cls, obj: dict) -> SeasonSeriesModelOrganization:
+        """Create an instance of SeasonSeriesModelOrganization from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
-            return SeasonEntityStatisticsModelOrganization.parse_obj(obj)
+        if not isinstance(obj, dict):
+            return SeasonSeriesModelOrganization.parse_obj(obj)
 
-        _obj = SeasonEntityStatisticsModelOrganization.parse_obj(
-            {"resource_type": obj.get("resourceType"), "id": obj.get("id")}
-        )
+        _obj = SeasonSeriesModelOrganization.parse_obj({"resource_type": obj.get("resourceType"), "id": obj.get("id")})
         return _obj
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_entity_statistics_response.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_entity_statistics_response.py`

 * *Files 2% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import List, Optional
 
 from pydantic import BaseModel, conlist
 
 from atriumsports.datacore.openapi.models.included_data import IncludedData
 from atriumsports.datacore.openapi.models.response_links import ResponseLinks
 from atriumsports.datacore.openapi.models.response_meta_data import ResponseMetaData
@@ -36,14 +35,16 @@
     meta: Optional[ResponseMetaData] = None
     links: Optional[ResponseLinks] = None
     included: Optional[IncludedData] = None
     data: Optional[conlist(SeasonEntityStatisticsModel)] = None
     __properties = ["meta", "links", "included", "data"]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -79,15 +80,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> SeasonEntityStatisticsResponse:
         """Create an instance of SeasonEntityStatisticsResponse from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return SeasonEntityStatisticsResponse.parse_obj(obj)
 
         _obj = SeasonEntityStatisticsResponse.parse_obj(
             {
                 "meta": ResponseMetaData.from_dict(obj.get("meta")) if obj.get("meta") is not None else None,
                 "links": ResponseLinks.from_dict(obj.get("links")) if obj.get("links") is not None else None,
                 "included": IncludedData.from_dict(obj.get("included")) if obj.get("included") is not None else None,
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_fixture_stages_pools_list_model.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_fixture_stages_pools_list_model.py`

 * *Files 2% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr, constr, validator
 
 from atriumsports.datacore.openapi.models.fixture_progressions_model_season import FixtureProgressionsModelSeason
 from atriumsports.datacore.openapi.models.season_fixture_stages_pools_list_model_organization import (
     SeasonFixtureStagesPoolsListModelOrganization,
@@ -67,24 +66,28 @@
         "stage",
         "poolCode",
         "pool",
         "fixtureType",
     ]
 
     @validator("fixture_type")
-    def fixture_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("ALL_STAR", "PRESEASON", "REGULAR", "FINAL", "PLAYOFF", "FRIENDLY", "DEMONSTRATION"):
+    def fixture_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("ALL_STAR", "PRESEASON", "REGULAR", "FINAL", "PLAYOFF", "FRIENDLY", "DEMONSTRATION"):
             raise ValueError(
                 "must be one of enum values ('ALL_STAR', 'PRESEASON', 'REGULAR', 'FINAL', 'PLAYOFF', 'FRIENDLY', 'DEMONSTRATION')"
             )
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -127,15 +130,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> SeasonFixtureStagesPoolsListModel:
         """Create an instance of SeasonFixtureStagesPoolsListModel from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return SeasonFixtureStagesPoolsListModel.parse_obj(obj)
 
         _obj = SeasonFixtureStagesPoolsListModel.parse_obj(
             {
                 "season_id": obj.get("seasonId"),
                 "season": FixtureProgressionsModelSeason.from_dict(obj.get("season"))
                 if obj.get("season") is not None
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_fixture_stages_pools_list_model_organization.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_fixture_stages_pools_list_model_organization.py`

 * *Files 12% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr, validator
 
 
 class SeasonFixtureStagesPoolsListModelOrganization(BaseModel):
     """
@@ -29,22 +28,26 @@
     """
 
     resource_type: Optional[StrictStr] = Field(None, alias="resourceType")
     id: Optional[StrictStr] = Field(None, description="Unique identifier for this resource")
     __properties = ["resourceType", "id"]
 
     @validator("resource_type")
-    def resource_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("organizations"):
+    def resource_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("organizations"):
             raise ValueError("must be one of enum values ('organizations')")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -64,14 +67,14 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> SeasonFixtureStagesPoolsListModelOrganization:
         """Create an instance of SeasonFixtureStagesPoolsListModelOrganization from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return SeasonFixtureStagesPoolsListModelOrganization.parse_obj(obj)
 
         _obj = SeasonFixtureStagesPoolsListModelOrganization.parse_obj(
             {"resource_type": obj.get("resourceType"), "id": obj.get("id")}
         )
         return _obj
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_fixture_stages_pools_list_model_pool.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_fixture_stages_pools_list_model_stage.py`

 * *Files 11% similar despite different names*

```diff
@@ -13,65 +13,68 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr, validator
 
 
-class SeasonFixtureStagesPoolsListModelPool(BaseModel):
+class SeasonFixtureStagesPoolsListModelStage(BaseModel):
     """
-    The pool that is related to this record
+    The stage that is related to this record
     """
 
     resource_type: Optional[StrictStr] = Field(None, alias="resourceType")
     id: Optional[StrictStr] = Field(None, description="Unique identifier for this resource")
     __properties = ["resourceType", "id"]
 
     @validator("resource_type")
-    def resource_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("season_pools"):
-            raise ValueError("must be one of enum values ('season_pools')")
-        return v
+    def resource_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("season_stages"):
+            raise ValueError("must be one of enum values ('season_stages')")
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> SeasonFixtureStagesPoolsListModelPool:
-        """Create an instance of SeasonFixtureStagesPoolsListModelPool from a JSON string"""
+    def from_json(cls, json_str: str) -> SeasonFixtureStagesPoolsListModelStage:
+        """Create an instance of SeasonFixtureStagesPoolsListModelStage from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
     def to_dict(self):
         """Returns the dictionary representation of the model using alias"""
         _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> SeasonFixtureStagesPoolsListModelPool:
-        """Create an instance of SeasonFixtureStagesPoolsListModelPool from a dict"""
+    def from_dict(cls, obj: dict) -> SeasonFixtureStagesPoolsListModelStage:
+        """Create an instance of SeasonFixtureStagesPoolsListModelStage from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
-            return SeasonFixtureStagesPoolsListModelPool.parse_obj(obj)
+        if not isinstance(obj, dict):
+            return SeasonFixtureStagesPoolsListModelStage.parse_obj(obj)
 
-        _obj = SeasonFixtureStagesPoolsListModelPool.parse_obj(
+        _obj = SeasonFixtureStagesPoolsListModelStage.parse_obj(
             {"resource_type": obj.get("resourceType"), "id": obj.get("id")}
         )
         return _obj
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_fixture_stages_pools_list_model_stage.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/seasons_model_fixture_profile.py`

 * *Files 16% similar despite different names*

```diff
@@ -13,65 +13,66 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr, validator
 
 
-class SeasonFixtureStagesPoolsListModelStage(BaseModel):
+class SeasonsModelFixtureProfile(BaseModel):
     """
-    The stage that is related to this record
+    The profile that this season belongs to
     """
 
     resource_type: Optional[StrictStr] = Field(None, alias="resourceType")
     id: Optional[StrictStr] = Field(None, description="Unique identifier for this resource")
     __properties = ["resourceType", "id"]
 
     @validator("resource_type")
-    def resource_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("season_stages"):
-            raise ValueError("must be one of enum values ('season_stages')")
-        return v
+    def resource_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("fixture_profiles"):
+            raise ValueError("must be one of enum values ('fixture_profiles')")
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> SeasonFixtureStagesPoolsListModelStage:
-        """Create an instance of SeasonFixtureStagesPoolsListModelStage from a JSON string"""
+    def from_json(cls, json_str: str) -> SeasonsModelFixtureProfile:
+        """Create an instance of SeasonsModelFixtureProfile from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
     def to_dict(self):
         """Returns the dictionary representation of the model using alias"""
         _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> SeasonFixtureStagesPoolsListModelStage:
-        """Create an instance of SeasonFixtureStagesPoolsListModelStage from a dict"""
+    def from_dict(cls, obj: dict) -> SeasonsModelFixtureProfile:
+        """Create an instance of SeasonsModelFixtureProfile from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
-            return SeasonFixtureStagesPoolsListModelStage.parse_obj(obj)
+        if not isinstance(obj, dict):
+            return SeasonsModelFixtureProfile.parse_obj(obj)
 
-        _obj = SeasonFixtureStagesPoolsListModelStage.parse_obj(
-            {"resource_type": obj.get("resourceType"), "id": obj.get("id")}
-        )
+        _obj = SeasonsModelFixtureProfile.parse_obj({"resource_type": obj.get("resourceType"), "id": obj.get("id")})
         return _obj
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_fixture_stages_pools_list_response.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_fixture_stages_pools_list_response.py`

 * *Files 3% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import List, Optional
 
 from pydantic import BaseModel, conlist
 
 from atriumsports.datacore.openapi.models.included_data import IncludedData
 from atriumsports.datacore.openapi.models.response_links import ResponseLinks
 from atriumsports.datacore.openapi.models.response_meta_data import ResponseMetaData
@@ -38,14 +37,16 @@
     meta: Optional[ResponseMetaData] = None
     links: Optional[ResponseLinks] = None
     included: Optional[IncludedData] = None
     data: Optional[conlist(SeasonFixtureStagesPoolsListModel)] = None
     __properties = ["meta", "links", "included", "data"]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -81,15 +82,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> SeasonFixtureStagesPoolsListResponse:
         """Create an instance of SeasonFixtureStagesPoolsListResponse from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return SeasonFixtureStagesPoolsListResponse.parse_obj(obj)
 
         _obj = SeasonFixtureStagesPoolsListResponse.parse_obj(
             {
                 "meta": ResponseMetaData.from_dict(obj.get("meta")) if obj.get("meta") is not None else None,
                 "links": ResponseLinks.from_dict(obj.get("links")) if obj.get("links") is not None else None,
                 "included": IncludedData.from_dict(obj.get("included")) if obj.get("included") is not None else None,
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_person_base_statistics_model.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_person_base_statistics_model.py`

 * *Files 6% similar despite different names*

```diff
@@ -14,15 +14,14 @@
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
 from datetime import datetime
-from inspect import getfullargspec
 from typing import Any, Dict, Optional
 
 from pydantic import BaseModel, Field, StrictStr, constr, validator
 
 from atriumsports.datacore.openapi.models.fixture_entities_model_entity import FixtureEntitiesModelEntity
 from atriumsports.datacore.openapi.models.fixture_persons_model_person import FixturePersonsModelPerson
 from atriumsports.datacore.openapi.models.fixture_progressions_model_season import FixtureProgressionsModelSeason
@@ -72,32 +71,38 @@
         "competitorType",
         "statistics",
         "updated",
         "added",
     ]
 
     @validator("fixture_type")
-    def fixture_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("ALL_STAR", "PRESEASON", "REGULAR", "FINAL", "PLAYOFF", "FRIENDLY", "DEMONSTRATION"):
+    def fixture_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("ALL_STAR", "PRESEASON", "REGULAR", "FINAL", "PLAYOFF", "FRIENDLY", "DEMONSTRATION"):
             raise ValueError(
                 "must be one of enum values ('ALL_STAR', 'PRESEASON', 'REGULAR', 'FINAL', 'PLAYOFF', 'FRIENDLY', 'DEMONSTRATION')"
             )
-        return v
+        return value
 
     @validator("competitor_type")
-    def competitor_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("PERSON", "ENTITY"):
+    def competitor_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("PERSON", "ENTITY"):
             raise ValueError("must be one of enum values ('PERSON', 'ENTITY')")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -137,15 +142,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> SeasonPersonBaseStatisticsModel:
         """Create an instance of SeasonPersonBaseStatisticsModel from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return SeasonPersonBaseStatisticsModel.parse_obj(obj)
 
         _obj = SeasonPersonBaseStatisticsModel.parse_obj(
             {
                 "season_id": obj.get("seasonId"),
                 "season": FixtureProgressionsModelSeason.from_dict(obj.get("season"))
                 if obj.get("season") is not None
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_person_base_statistics_model_organization.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_person_base_statistics_model_organization.py`

 * *Files 6% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr, validator
 
 
 class SeasonPersonBaseStatisticsModelOrganization(BaseModel):
     """
@@ -29,22 +28,26 @@
     """
 
     resource_type: Optional[StrictStr] = Field(None, alias="resourceType")
     id: Optional[StrictStr] = Field(None, description="Unique identifier for this resource")
     __properties = ["resourceType", "id"]
 
     @validator("resource_type")
-    def resource_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("organizations"):
+    def resource_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("organizations"):
             raise ValueError("must be one of enum values ('organizations')")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -64,14 +67,14 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> SeasonPersonBaseStatisticsModelOrganization:
         """Create an instance of SeasonPersonBaseStatisticsModelOrganization from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return SeasonPersonBaseStatisticsModelOrganization.parse_obj(obj)
 
         _obj = SeasonPersonBaseStatisticsModelOrganization.parse_obj(
             {"resource_type": obj.get("resourceType"), "id": obj.get("id")}
         )
         return _obj
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_person_base_statistics_post_body.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_person_base_statistics_post_body.py`

 * *Files 4% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Any, Dict, Optional
 
 from pydantic import BaseModel, Field, StrictStr, constr, validator
 
 
 class SeasonPersonBaseStatisticsPostBody(BaseModel):
     """
@@ -41,28 +40,32 @@
         alias="competitorType",
         description="The type of competitors in this fixture >- `ENTITY` Entity >- `PERSON` Person ",
     )
     statistics: Optional[Dict[str, Any]] = None
     __properties = ["seasonId", "personId", "entityId", "fixtureType", "competitorType", "statistics"]
 
     @validator("fixture_type")
-    def fixture_type_validate_enum(cls, v):
-        if v not in ("ALL_STAR", "PRESEASON", "REGULAR", "FINAL", "PLAYOFF", "FRIENDLY", "DEMONSTRATION"):
+    def fixture_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value not in ("ALL_STAR", "PRESEASON", "REGULAR", "FINAL", "PLAYOFF", "FRIENDLY", "DEMONSTRATION"):
             raise ValueError(
                 "must be one of enum values ('ALL_STAR', 'PRESEASON', 'REGULAR', 'FINAL', 'PLAYOFF', 'FRIENDLY', 'DEMONSTRATION')"
             )
-        return v
+        return value
 
     @validator("competitor_type")
-    def competitor_type_validate_enum(cls, v):
-        if v not in ("PERSON", "ENTITY"):
+    def competitor_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value not in ("PERSON", "ENTITY"):
             raise ValueError("must be one of enum values ('PERSON', 'ENTITY')")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -82,15 +85,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> SeasonPersonBaseStatisticsPostBody:
         """Create an instance of SeasonPersonBaseStatisticsPostBody from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return SeasonPersonBaseStatisticsPostBody.parse_obj(obj)
 
         _obj = SeasonPersonBaseStatisticsPostBody.parse_obj(
             {
                 "season_id": obj.get("seasonId"),
                 "person_id": obj.get("personId"),
                 "entity_id": obj.get("entityId"),
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_person_base_statistics_response.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_entity_base_statistics_response.py`

 * *Files 8% similar despite different names*

```diff
@@ -13,51 +13,52 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import List, Optional
 
 from pydantic import BaseModel, conlist
 
 from atriumsports.datacore.openapi.models.included_data import IncludedData
 from atriumsports.datacore.openapi.models.response_links import ResponseLinks
 from atriumsports.datacore.openapi.models.response_meta_data import ResponseMetaData
-from atriumsports.datacore.openapi.models.season_person_base_statistics_model import SeasonPersonBaseStatisticsModel
+from atriumsports.datacore.openapi.models.season_entity_base_statistics_model import SeasonEntityBaseStatisticsModel
 
 
-class SeasonPersonBaseStatisticsResponse(BaseModel):
+class SeasonEntityBaseStatisticsResponse(BaseModel):
     """
-    SeasonPersonBaseStatisticsResponse
+    SeasonEntityBaseStatisticsResponse
     """
 
     meta: Optional[ResponseMetaData] = None
     links: Optional[ResponseLinks] = None
     included: Optional[IncludedData] = None
-    data: Optional[conlist(SeasonPersonBaseStatisticsModel)] = None
+    data: Optional[conlist(SeasonEntityBaseStatisticsModel)] = None
     __properties = ["meta", "links", "included", "data"]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> SeasonPersonBaseStatisticsResponse:
-        """Create an instance of SeasonPersonBaseStatisticsResponse from a JSON string"""
+    def from_json(cls, json_str: str) -> SeasonEntityBaseStatisticsResponse:
+        """Create an instance of SeasonEntityBaseStatisticsResponse from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
     def to_dict(self):
         """Returns the dictionary representation of the model using alias"""
         _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)
         # override the default output from pydantic by calling `to_dict()` of meta
         if self.meta:
@@ -74,26 +75,26 @@
             for _item in self.data:
                 if _item:
                     _items.append(_item.to_dict())
             _dict["data"] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> SeasonPersonBaseStatisticsResponse:
-        """Create an instance of SeasonPersonBaseStatisticsResponse from a dict"""
+    def from_dict(cls, obj: dict) -> SeasonEntityBaseStatisticsResponse:
+        """Create an instance of SeasonEntityBaseStatisticsResponse from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
-            return SeasonPersonBaseStatisticsResponse.parse_obj(obj)
+        if not isinstance(obj, dict):
+            return SeasonEntityBaseStatisticsResponse.parse_obj(obj)
 
-        _obj = SeasonPersonBaseStatisticsResponse.parse_obj(
+        _obj = SeasonEntityBaseStatisticsResponse.parse_obj(
             {
                 "meta": ResponseMetaData.from_dict(obj.get("meta")) if obj.get("meta") is not None else None,
                 "links": ResponseLinks.from_dict(obj.get("links")) if obj.get("links") is not None else None,
                 "included": IncludedData.from_dict(obj.get("included")) if obj.get("included") is not None else None,
-                "data": [SeasonPersonBaseStatisticsModel.from_dict(_item) for _item in obj.get("data")]
+                "data": [SeasonEntityBaseStatisticsModel.from_dict(_item) for _item in obj.get("data")]
                 if obj.get("data") is not None
                 else None,
             }
         )
         return _obj
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_person_placings_model.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_person_placings_model.py`

 * *Files 6% similar despite different names*

```diff
@@ -14,15 +14,14 @@
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
 from datetime import datetime
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictInt, StrictStr, constr
 
 
 class SeasonPersonPlacingsModel(BaseModel):
     """
@@ -51,14 +50,16 @@
         "points",
         "prizeMoney",
         "updated",
         "added",
     ]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -95,15 +96,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> SeasonPersonPlacingsModel:
         """Create an instance of SeasonPersonPlacingsModel from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return SeasonPersonPlacingsModel.parse_obj(obj)
 
         _obj = SeasonPersonPlacingsModel.parse_obj(
             {
                 "placing_id": obj.get("placingId"),
                 "organization_id": obj.get("organizationId"),
                 "season_id": obj.get("seasonId"),
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_person_placings_response.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_persons_response.py`

 * *Files 7% similar despite different names*

```diff
@@ -13,51 +13,52 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import List, Optional
 
 from pydantic import BaseModel, conlist
 
 from atriumsports.datacore.openapi.models.included_data import IncludedData
 from atriumsports.datacore.openapi.models.response_links import ResponseLinks
 from atriumsports.datacore.openapi.models.response_meta_data import ResponseMetaData
-from atriumsports.datacore.openapi.models.season_person_placings_model import SeasonPersonPlacingsModel
+from atriumsports.datacore.openapi.models.season_persons_model import SeasonPersonsModel
 
 
-class SeasonPersonPlacingsResponse(BaseModel):
+class SeasonPersonsResponse(BaseModel):
     """
-    SeasonPersonPlacingsResponse
+    SeasonPersonsResponse
     """
 
     meta: Optional[ResponseMetaData] = None
     links: Optional[ResponseLinks] = None
     included: Optional[IncludedData] = None
-    data: Optional[conlist(SeasonPersonPlacingsModel)] = None
+    data: Optional[conlist(SeasonPersonsModel)] = None
     __properties = ["meta", "links", "included", "data"]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> SeasonPersonPlacingsResponse:
-        """Create an instance of SeasonPersonPlacingsResponse from a JSON string"""
+    def from_json(cls, json_str: str) -> SeasonPersonsResponse:
+        """Create an instance of SeasonPersonsResponse from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
     def to_dict(self):
         """Returns the dictionary representation of the model using alias"""
         _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)
         # override the default output from pydantic by calling `to_dict()` of meta
         if self.meta:
@@ -74,26 +75,26 @@
             for _item in self.data:
                 if _item:
                     _items.append(_item.to_dict())
             _dict["data"] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> SeasonPersonPlacingsResponse:
-        """Create an instance of SeasonPersonPlacingsResponse from a dict"""
+    def from_dict(cls, obj: dict) -> SeasonPersonsResponse:
+        """Create an instance of SeasonPersonsResponse from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
-            return SeasonPersonPlacingsResponse.parse_obj(obj)
+        if not isinstance(obj, dict):
+            return SeasonPersonsResponse.parse_obj(obj)
 
-        _obj = SeasonPersonPlacingsResponse.parse_obj(
+        _obj = SeasonPersonsResponse.parse_obj(
             {
                 "meta": ResponseMetaData.from_dict(obj.get("meta")) if obj.get("meta") is not None else None,
                 "links": ResponseLinks.from_dict(obj.get("links")) if obj.get("links") is not None else None,
                 "included": IncludedData.from_dict(obj.get("included")) if obj.get("included") is not None else None,
-                "data": [SeasonPersonPlacingsModel.from_dict(_item) for _item in obj.get("data")]
+                "data": [SeasonPersonsModel.from_dict(_item) for _item in obj.get("data")]
                 if obj.get("data") is not None
                 else None,
             }
         )
         return _obj
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_person_statistics_model.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_person_statistics_model.py`

 * *Files 3% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Any, Dict, Optional
 
 from pydantic import BaseModel, Field, StrictStr
 
 from atriumsports.datacore.openapi.models.fixture_entities_model_entity import FixtureEntitiesModelEntity
 from atriumsports.datacore.openapi.models.fixture_persons_model_person import FixturePersonsModelPerson
 from atriumsports.datacore.openapi.models.fixture_progressions_model_season import FixtureProgressionsModelSeason
@@ -62,14 +61,16 @@
         "season",
         "competitionId",
         "competition",
         "statistics",
     ]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -110,15 +111,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> SeasonPersonStatisticsModel:
         """Create an instance of SeasonPersonStatisticsModel from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return SeasonPersonStatisticsModel.parse_obj(obj)
 
         _obj = SeasonPersonStatisticsModel.parse_obj(
             {
                 "person_id": obj.get("personId"),
                 "person": FixturePersonsModelPerson.from_dict(obj.get("person"))
                 if obj.get("person") is not None
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_person_statistics_model_organization.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/persons_model_organization.py`

 * *Files 15% similar despite different names*

```diff
@@ -13,65 +13,66 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr, validator
 
 
-class SeasonPersonStatisticsModelOrganization(BaseModel):
+class PersonsModelOrganization(BaseModel):
     """
-    The organization that this season person statistics belongs to
+    The organization that this person belongs to
     """
 
     resource_type: Optional[StrictStr] = Field(None, alias="resourceType")
     id: Optional[StrictStr] = Field(None, description="Unique identifier for this resource")
     __properties = ["resourceType", "id"]
 
     @validator("resource_type")
-    def resource_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("organizations"):
+    def resource_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("organizations"):
             raise ValueError("must be one of enum values ('organizations')")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> SeasonPersonStatisticsModelOrganization:
-        """Create an instance of SeasonPersonStatisticsModelOrganization from a JSON string"""
+    def from_json(cls, json_str: str) -> PersonsModelOrganization:
+        """Create an instance of PersonsModelOrganization from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
     def to_dict(self):
         """Returns the dictionary representation of the model using alias"""
         _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> SeasonPersonStatisticsModelOrganization:
-        """Create an instance of SeasonPersonStatisticsModelOrganization from a dict"""
+    def from_dict(cls, obj: dict) -> PersonsModelOrganization:
+        """Create an instance of PersonsModelOrganization from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
-            return SeasonPersonStatisticsModelOrganization.parse_obj(obj)
+        if not isinstance(obj, dict):
+            return PersonsModelOrganization.parse_obj(obj)
 
-        _obj = SeasonPersonStatisticsModelOrganization.parse_obj(
-            {"resource_type": obj.get("resourceType"), "id": obj.get("id")}
-        )
+        _obj = PersonsModelOrganization.parse_obj({"resource_type": obj.get("resourceType"), "id": obj.get("id")})
         return _obj
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_person_statistics_periods_model.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_person_statistics_periods_model.py`

 * *Files 2% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Any, Dict, Optional
 
 from pydantic import BaseModel, Field, StrictInt, StrictStr, constr
 
 from atriumsports.datacore.openapi.models.fixture_entities_model_entity import FixtureEntitiesModelEntity
 from atriumsports.datacore.openapi.models.fixture_persons_model_person import FixturePersonsModelPerson
 from atriumsports.datacore.openapi.models.fixture_progressions_model_season import FixtureProgressionsModelSeason
@@ -68,14 +67,16 @@
         "competition",
         "periodId",
         "section",
         "statistics",
     ]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -116,15 +117,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> SeasonPersonStatisticsPeriodsModel:
         """Create an instance of SeasonPersonStatisticsPeriodsModel from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return SeasonPersonStatisticsPeriodsModel.parse_obj(obj)
 
         _obj = SeasonPersonStatisticsPeriodsModel.parse_obj(
             {
                 "person_id": obj.get("personId"),
                 "person": FixturePersonsModelPerson.from_dict(obj.get("person"))
                 if obj.get("person") is not None
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_person_statistics_periods_response.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_person_statistics_periods_response.py`

 * *Files 5% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import List, Optional
 
 from pydantic import BaseModel, conlist
 
 from atriumsports.datacore.openapi.models.included_data import IncludedData
 from atriumsports.datacore.openapi.models.response_links import ResponseLinks
 from atriumsports.datacore.openapi.models.response_meta_data import ResponseMetaData
@@ -38,14 +37,16 @@
     meta: Optional[ResponseMetaData] = None
     links: Optional[ResponseLinks] = None
     included: Optional[IncludedData] = None
     data: Optional[conlist(SeasonPersonStatisticsPeriodsModel)] = None
     __properties = ["meta", "links", "included", "data"]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -81,15 +82,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> SeasonPersonStatisticsPeriodsResponse:
         """Create an instance of SeasonPersonStatisticsPeriodsResponse from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return SeasonPersonStatisticsPeriodsResponse.parse_obj(obj)
 
         _obj = SeasonPersonStatisticsPeriodsResponse.parse_obj(
             {
                 "meta": ResponseMetaData.from_dict(obj.get("meta")) if obj.get("meta") is not None else None,
                 "links": ResponseLinks.from_dict(obj.get("links")) if obj.get("links") is not None else None,
                 "included": IncludedData.from_dict(obj.get("included")) if obj.get("included") is not None else None,
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_person_statistics_response.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_person_statistics_response.py`

 * *Files 4% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import List, Optional
 
 from pydantic import BaseModel, conlist
 
 from atriumsports.datacore.openapi.models.included_data import IncludedData
 from atriumsports.datacore.openapi.models.response_links import ResponseLinks
 from atriumsports.datacore.openapi.models.response_meta_data import ResponseMetaData
@@ -36,14 +35,16 @@
     meta: Optional[ResponseMetaData] = None
     links: Optional[ResponseLinks] = None
     included: Optional[IncludedData] = None
     data: Optional[conlist(SeasonPersonStatisticsModel)] = None
     __properties = ["meta", "links", "included", "data"]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -79,15 +80,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> SeasonPersonStatisticsResponse:
         """Create an instance of SeasonPersonStatisticsResponse from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return SeasonPersonStatisticsResponse.parse_obj(obj)
 
         _obj = SeasonPersonStatisticsResponse.parse_obj(
             {
                 "meta": ResponseMetaData.from_dict(obj.get("meta")) if obj.get("meta") is not None else None,
                 "links": ResponseLinks.from_dict(obj.get("links")) if obj.get("links") is not None else None,
                 "included": IncludedData.from_dict(obj.get("included")) if obj.get("included") is not None else None,
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_person_total_statistics_model.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_person_total_statistics_model.py`

 * *Files 2% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Any, Dict, Optional
 
 from pydantic import BaseModel, Field, StrictStr
 
 from atriumsports.datacore.openapi.models.fixture_persons_model_person import FixturePersonsModelPerson
 from atriumsports.datacore.openapi.models.fixture_progressions_model_season import FixtureProgressionsModelSeason
 from atriumsports.datacore.openapi.models.season_person_total_statistics_model_organization import (
@@ -57,14 +56,16 @@
         "season",
         "competitionId",
         "competition",
         "statistics",
     ]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -102,15 +103,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> SeasonPersonTotalStatisticsModel:
         """Create an instance of SeasonPersonTotalStatisticsModel from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return SeasonPersonTotalStatisticsModel.parse_obj(obj)
 
         _obj = SeasonPersonTotalStatisticsModel.parse_obj(
             {
                 "person_id": obj.get("personId"),
                 "person": FixturePersonsModelPerson.from_dict(obj.get("person"))
                 if obj.get("person") is not None
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_person_total_statistics_model_organization.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/video_stream_outputs_model_organization.py`

 * *Files 17% similar despite different names*

```diff
@@ -13,65 +13,68 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr, validator
 
 
-class SeasonPersonTotalStatisticsModelOrganization(BaseModel):
+class VideoStreamOutputsModelOrganization(BaseModel):
     """
-    The organization that this season person total statistics belongs to
+    The organization that this Video Stream Outputs belongs to
     """
 
     resource_type: Optional[StrictStr] = Field(None, alias="resourceType")
     id: Optional[StrictStr] = Field(None, description="Unique identifier for this resource")
     __properties = ["resourceType", "id"]
 
     @validator("resource_type")
-    def resource_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("organizations"):
+    def resource_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("organizations"):
             raise ValueError("must be one of enum values ('organizations')")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> SeasonPersonTotalStatisticsModelOrganization:
-        """Create an instance of SeasonPersonTotalStatisticsModelOrganization from a JSON string"""
+    def from_json(cls, json_str: str) -> VideoStreamOutputsModelOrganization:
+        """Create an instance of VideoStreamOutputsModelOrganization from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
     def to_dict(self):
         """Returns the dictionary representation of the model using alias"""
         _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> SeasonPersonTotalStatisticsModelOrganization:
-        """Create an instance of SeasonPersonTotalStatisticsModelOrganization from a dict"""
+    def from_dict(cls, obj: dict) -> VideoStreamOutputsModelOrganization:
+        """Create an instance of VideoStreamOutputsModelOrganization from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
-            return SeasonPersonTotalStatisticsModelOrganization.parse_obj(obj)
+        if not isinstance(obj, dict):
+            return VideoStreamOutputsModelOrganization.parse_obj(obj)
 
-        _obj = SeasonPersonTotalStatisticsModelOrganization.parse_obj(
+        _obj = VideoStreamOutputsModelOrganization.parse_obj(
             {"resource_type": obj.get("resourceType"), "id": obj.get("id")}
         )
         return _obj
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_person_total_statistics_response.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_person_total_statistics_response.py`

 * *Files 4% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import List, Optional
 
 from pydantic import BaseModel, conlist
 
 from atriumsports.datacore.openapi.models.included_data import IncludedData
 from atriumsports.datacore.openapi.models.response_links import ResponseLinks
 from atriumsports.datacore.openapi.models.response_meta_data import ResponseMetaData
@@ -36,14 +35,16 @@
     meta: Optional[ResponseMetaData] = None
     links: Optional[ResponseLinks] = None
     included: Optional[IncludedData] = None
     data: Optional[conlist(SeasonPersonTotalStatisticsModel)] = None
     __properties = ["meta", "links", "included", "data"]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -79,15 +80,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> SeasonPersonTotalStatisticsResponse:
         """Create an instance of SeasonPersonTotalStatisticsResponse from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return SeasonPersonTotalStatisticsResponse.parse_obj(obj)
 
         _obj = SeasonPersonTotalStatisticsResponse.parse_obj(
             {
                 "meta": ResponseMetaData.from_dict(obj.get("meta")) if obj.get("meta") is not None else None,
                 "links": ResponseLinks.from_dict(obj.get("links")) if obj.get("links") is not None else None,
                 "included": IncludedData.from_dict(obj.get("included")) if obj.get("included") is not None else None,
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_persons_list_model.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_persons_list_model.py`

 * *Files 4% similar despite different names*

```diff
@@ -14,15 +14,14 @@
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
 from datetime import datetime
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictInt, StrictStr, constr, validator
 
 from atriumsports.datacore.openapi.models.entities_model_entity_group import EntitiesModelEntityGroup
 from atriumsports.datacore.openapi.models.fixture_persons_model_person import FixturePersonsModelPerson
 from atriumsports.datacore.openapi.models.fixture_progressions_model_season import FixtureProgressionsModelSeason
@@ -70,30 +69,36 @@
         "seed",
         "externalId",
         "updated",
         "added",
     ]
 
     @validator("status")
-    def status_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("ACTIVE", "INACTIVE", "PENDING"):
+    def status_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("ACTIVE", "INACTIVE", "PENDING"):
             raise ValueError("must be one of enum values ('ACTIVE', 'INACTIVE', 'PENDING')")
-        return v
+        return value
 
     @validator("external_id")
-    def external_id_validate_regular_expression(cls, v):
-        if v is None:
-            return v
-        if not re.match(r"^[0-9A-Za-z\/_-]+$", v):
+    def external_id_validate_regular_expression(cls, value):
+        """Validates the regular expression"""
+        if value is None:
+            return value
+
+        if not re.match(r"^[0-9A-Za-z\/_-]+$", value):
             raise ValueError(r"must validate the regular expression /^[0-9A-Za-z\/_-]+$/")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -138,15 +143,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> SeasonPersonsListModel:
         """Create an instance of SeasonPersonsListModel from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return SeasonPersonsListModel.parse_obj(obj)
 
         _obj = SeasonPersonsListModel.parse_obj(
             {
                 "season_id": obj.get("seasonId"),
                 "season": FixtureProgressionsModelSeason.from_dict(obj.get("season"))
                 if obj.get("season") is not None
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_persons_list_model_organization.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/transfers_model_organization.py`

 * *Files 14% similar despite different names*

```diff
@@ -13,65 +13,66 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr, validator
 
 
-class SeasonPersonsListModelOrganization(BaseModel):
+class TransfersModelOrganization(BaseModel):
     """
-    The organization that this season persons belongs to
+    The organization that this ~transfer~ belongs to
     """
 
     resource_type: Optional[StrictStr] = Field(None, alias="resourceType")
     id: Optional[StrictStr] = Field(None, description="Unique identifier for this resource")
     __properties = ["resourceType", "id"]
 
     @validator("resource_type")
-    def resource_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("organizations"):
+    def resource_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("organizations"):
             raise ValueError("must be one of enum values ('organizations')")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> SeasonPersonsListModelOrganization:
-        """Create an instance of SeasonPersonsListModelOrganization from a JSON string"""
+    def from_json(cls, json_str: str) -> TransfersModelOrganization:
+        """Create an instance of TransfersModelOrganization from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
     def to_dict(self):
         """Returns the dictionary representation of the model using alias"""
         _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> SeasonPersonsListModelOrganization:
-        """Create an instance of SeasonPersonsListModelOrganization from a dict"""
+    def from_dict(cls, obj: dict) -> TransfersModelOrganization:
+        """Create an instance of TransfersModelOrganization from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
-            return SeasonPersonsListModelOrganization.parse_obj(obj)
+        if not isinstance(obj, dict):
+            return TransfersModelOrganization.parse_obj(obj)
 
-        _obj = SeasonPersonsListModelOrganization.parse_obj(
-            {"resource_type": obj.get("resourceType"), "id": obj.get("id")}
-        )
+        _obj = TransfersModelOrganization.parse_obj({"resource_type": obj.get("resourceType"), "id": obj.get("id")})
         return _obj
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_persons_list_response.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_persons_list_response.py`

 * *Files 2% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import List, Optional
 
 from pydantic import BaseModel, conlist
 
 from atriumsports.datacore.openapi.models.included_data import IncludedData
 from atriumsports.datacore.openapi.models.response_links import ResponseLinks
 from atriumsports.datacore.openapi.models.response_meta_data import ResponseMetaData
@@ -36,14 +35,16 @@
     meta: Optional[ResponseMetaData] = None
     links: Optional[ResponseLinks] = None
     included: Optional[IncludedData] = None
     data: Optional[conlist(SeasonPersonsListModel)] = None
     __properties = ["meta", "links", "included", "data"]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -79,15 +80,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> SeasonPersonsListResponse:
         """Create an instance of SeasonPersonsListResponse from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return SeasonPersonsListResponse.parse_obj(obj)
 
         _obj = SeasonPersonsListResponse.parse_obj(
             {
                 "meta": ResponseMetaData.from_dict(obj.get("meta")) if obj.get("meta") is not None else None,
                 "links": ResponseLinks.from_dict(obj.get("links")) if obj.get("links") is not None else None,
                 "included": IncludedData.from_dict(obj.get("included")) if obj.get("included") is not None else None,
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_persons_model.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_persons_model.py`

 * *Files 4% similar despite different names*

```diff
@@ -14,15 +14,14 @@
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
 from datetime import datetime
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr, conint, constr, validator
 
 from atriumsports.datacore.openapi.models.entities_model_entity_group import EntitiesModelEntityGroup
 from atriumsports.datacore.openapi.models.fixture_persons_model_person import FixturePersonsModelPerson
 from atriumsports.datacore.openapi.models.fixture_progressions_model_season import FixtureProgressionsModelSeason
@@ -70,30 +69,36 @@
         "seed",
         "externalId",
         "updated",
         "added",
     ]
 
     @validator("status")
-    def status_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("ACTIVE", "INACTIVE", "PENDING"):
+    def status_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("ACTIVE", "INACTIVE", "PENDING"):
             raise ValueError("must be one of enum values ('ACTIVE', 'INACTIVE', 'PENDING')")
-        return v
+        return value
 
     @validator("external_id")
-    def external_id_validate_regular_expression(cls, v):
-        if v is None:
-            return v
-        if not re.match(r"^[0-9A-Za-z\/_-]+$", v):
+    def external_id_validate_regular_expression(cls, value):
+        """Validates the regular expression"""
+        if value is None:
+            return value
+
+        if not re.match(r"^[0-9A-Za-z\/_-]+$", value):
             raise ValueError(r"must validate the regular expression /^[0-9A-Za-z\/_-]+$/")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -143,15 +148,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> SeasonPersonsModel:
         """Create an instance of SeasonPersonsModel from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return SeasonPersonsModel.parse_obj(obj)
 
         _obj = SeasonPersonsModel.parse_obj(
             {
                 "season_id": obj.get("seasonId"),
                 "season": FixtureProgressionsModelSeason.from_dict(obj.get("season"))
                 if obj.get("season") is not None
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_persons_post_body.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_persons_post_body.py`

 * *Files 5% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr, conint, constr, validator
 
 
 class SeasonPersonsPostBody(BaseModel):
     """
@@ -39,30 +38,36 @@
     seed: Optional[conint(strict=True)] = Field(None, description="Initial seeding")
     external_id: Optional[constr(strict=True, max_length=150)] = Field(
         None, alias="externalId", description="The Id of the data as set by the provider of the data"
     )
     __properties = ["seasonId", "personId", "entityGroupId", "status", "seed", "externalId"]
 
     @validator("status")
-    def status_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("ACTIVE", "INACTIVE", "PENDING"):
+    def status_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("ACTIVE", "INACTIVE", "PENDING"):
             raise ValueError("must be one of enum values ('ACTIVE', 'INACTIVE', 'PENDING')")
-        return v
+        return value
 
     @validator("external_id")
-    def external_id_validate_regular_expression(cls, v):
-        if v is None:
-            return v
-        if not re.match(r"^[0-9A-Za-z\/_-]+$", v):
+    def external_id_validate_regular_expression(cls, value):
+        """Validates the regular expression"""
+        if value is None:
+            return value
+
+        if not re.match(r"^[0-9A-Za-z\/_-]+$", value):
             raise ValueError(r"must validate the regular expression /^[0-9A-Za-z\/_-]+$/")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -92,15 +97,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> SeasonPersonsPostBody:
         """Create an instance of SeasonPersonsPostBody from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return SeasonPersonsPostBody.parse_obj(obj)
 
         _obj = SeasonPersonsPostBody.parse_obj(
             {
                 "season_id": obj.get("seasonId"),
                 "person_id": obj.get("personId"),
                 "entity_group_id": obj.get("entityGroupId"),
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_persons_response.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_roster_response.py`

 * *Files 7% similar despite different names*

```diff
@@ -13,51 +13,52 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import List, Optional
 
 from pydantic import BaseModel, conlist
 
 from atriumsports.datacore.openapi.models.included_data import IncludedData
 from atriumsports.datacore.openapi.models.response_links import ResponseLinks
 from atriumsports.datacore.openapi.models.response_meta_data import ResponseMetaData
-from atriumsports.datacore.openapi.models.season_persons_model import SeasonPersonsModel
+from atriumsports.datacore.openapi.models.season_roster_model import SeasonRosterModel
 
 
-class SeasonPersonsResponse(BaseModel):
+class SeasonRosterResponse(BaseModel):
     """
-    SeasonPersonsResponse
+    SeasonRosterResponse
     """
 
     meta: Optional[ResponseMetaData] = None
     links: Optional[ResponseLinks] = None
     included: Optional[IncludedData] = None
-    data: Optional[conlist(SeasonPersonsModel)] = None
+    data: Optional[conlist(SeasonRosterModel)] = None
     __properties = ["meta", "links", "included", "data"]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> SeasonPersonsResponse:
-        """Create an instance of SeasonPersonsResponse from a JSON string"""
+    def from_json(cls, json_str: str) -> SeasonRosterResponse:
+        """Create an instance of SeasonRosterResponse from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
     def to_dict(self):
         """Returns the dictionary representation of the model using alias"""
         _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)
         # override the default output from pydantic by calling `to_dict()` of meta
         if self.meta:
@@ -74,26 +75,26 @@
             for _item in self.data:
                 if _item:
                     _items.append(_item.to_dict())
             _dict["data"] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> SeasonPersonsResponse:
-        """Create an instance of SeasonPersonsResponse from a dict"""
+    def from_dict(cls, obj: dict) -> SeasonRosterResponse:
+        """Create an instance of SeasonRosterResponse from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
-            return SeasonPersonsResponse.parse_obj(obj)
+        if not isinstance(obj, dict):
+            return SeasonRosterResponse.parse_obj(obj)
 
-        _obj = SeasonPersonsResponse.parse_obj(
+        _obj = SeasonRosterResponse.parse_obj(
             {
                 "meta": ResponseMetaData.from_dict(obj.get("meta")) if obj.get("meta") is not None else None,
                 "links": ResponseLinks.from_dict(obj.get("links")) if obj.get("links") is not None else None,
                 "included": IncludedData.from_dict(obj.get("included")) if obj.get("included") is not None else None,
-                "data": [SeasonPersonsModel.from_dict(_item) for _item in obj.get("data")]
+                "data": [SeasonRosterModel.from_dict(_item) for _item in obj.get("data")]
                 if obj.get("data") is not None
                 else None,
             }
         )
         return _obj
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_pools_model.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_pools_model.py`

 * *Files 2% similar despite different names*

```diff
@@ -14,15 +14,14 @@
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
 from datetime import datetime
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictInt, StrictStr, constr, validator
 
 from atriumsports.datacore.openapi.models.fixture_progressions_model_season import FixtureProgressionsModelSeason
 from atriumsports.datacore.openapi.models.season_fixture_stages_pools_list_model_stage import (
     SeasonFixtureStagesPoolsListModelStage,
@@ -91,22 +90,26 @@
         "poolOrder",
         "externalId",
         "updated",
         "added",
     ]
 
     @validator("external_id")
-    def external_id_validate_regular_expression(cls, v):
-        if v is None:
-            return v
-        if not re.match(r"^[0-9A-Za-z\/_-]+$", v):
+    def external_id_validate_regular_expression(cls, value):
+        """Validates the regular expression"""
+        if value is None:
+            return value
+
+        if not re.match(r"^[0-9A-Za-z\/_-]+$", value):
             raise ValueError(r"must validate the regular expression /^[0-9A-Za-z\/_-]+$/")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -178,15 +181,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> SeasonPoolsModel:
         """Create an instance of SeasonPoolsModel from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return SeasonPoolsModel.parse_obj(obj)
 
         _obj = SeasonPoolsModel.parse_obj(
             {
                 "organization_id": obj.get("organizationId"),
                 "organization": SeasonPoolsModelOrganization.from_dict(obj.get("organization"))
                 if obj.get("organization") is not None
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_pools_model_organization.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/seasons_model_competition.py`

 * *Files 15% similar despite different names*

```diff
@@ -13,63 +13,66 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr, validator
 
 
-class SeasonPoolsModelOrganization(BaseModel):
+class SeasonsModelCompetition(BaseModel):
     """
-    The organization that this pool belongs to
+    The competition that this season belongs to
     """
 
     resource_type: Optional[StrictStr] = Field(None, alias="resourceType")
     id: Optional[StrictStr] = Field(None, description="Unique identifier for this resource")
     __properties = ["resourceType", "id"]
 
     @validator("resource_type")
-    def resource_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("organizations"):
-            raise ValueError("must be one of enum values ('organizations')")
-        return v
+    def resource_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("competitions"):
+            raise ValueError("must be one of enum values ('competitions')")
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> SeasonPoolsModelOrganization:
-        """Create an instance of SeasonPoolsModelOrganization from a JSON string"""
+    def from_json(cls, json_str: str) -> SeasonsModelCompetition:
+        """Create an instance of SeasonsModelCompetition from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
     def to_dict(self):
         """Returns the dictionary representation of the model using alias"""
         _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> SeasonPoolsModelOrganization:
-        """Create an instance of SeasonPoolsModelOrganization from a dict"""
+    def from_dict(cls, obj: dict) -> SeasonsModelCompetition:
+        """Create an instance of SeasonsModelCompetition from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
-            return SeasonPoolsModelOrganization.parse_obj(obj)
+        if not isinstance(obj, dict):
+            return SeasonsModelCompetition.parse_obj(obj)
 
-        _obj = SeasonPoolsModelOrganization.parse_obj({"resource_type": obj.get("resourceType"), "id": obj.get("id")})
+        _obj = SeasonsModelCompetition.parse_obj({"resource_type": obj.get("resourceType"), "id": obj.get("id")})
         return _obj
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_pools_response.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_pools_response.py`

 * *Files 3% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import List, Optional
 
 from pydantic import BaseModel, conlist
 
 from atriumsports.datacore.openapi.models.included_data import IncludedData
 from atriumsports.datacore.openapi.models.response_links import ResponseLinks
 from atriumsports.datacore.openapi.models.response_meta_data import ResponseMetaData
@@ -36,14 +35,16 @@
     meta: Optional[ResponseMetaData] = None
     links: Optional[ResponseLinks] = None
     included: Optional[IncludedData] = None
     data: Optional[conlist(SeasonPoolsModel)] = None
     __properties = ["meta", "links", "included", "data"]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -79,15 +80,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> SeasonPoolsResponse:
         """Create an instance of SeasonPoolsResponse from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return SeasonPoolsResponse.parse_obj(obj)
 
         _obj = SeasonPoolsResponse.parse_obj(
             {
                 "meta": ResponseMetaData.from_dict(obj.get("meta")) if obj.get("meta") is not None else None,
                 "links": ResponseLinks.from_dict(obj.get("links")) if obj.get("links") is not None else None,
                 "included": IncludedData.from_dict(obj.get("included")) if obj.get("included") is not None else None,
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_post_body.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_post_body.py`

 * *Files 4% similar despite different names*

```diff
@@ -14,15 +14,14 @@
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
 from datetime import date
-from inspect import getfullargspec
 from typing import Any, Dict, Optional
 
 from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr, conint, constr, validator
 
 from atriumsports.datacore.openapi.models.seasonroster_configuration import SEASONROSTERConfiguration
 from atriumsports.datacore.openapi.models.social_media import SocialMedia
 
@@ -167,42 +166,48 @@
         "configuration",
         "profileId",
         "videoProduction",
         "rosterConfiguration",
     ]
 
     @validator("event_type")
-    def event_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("FIXTURE", "PRACTICE"):
+    def event_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("FIXTURE", "PRACTICE"):
             raise ValueError("must be one of enum values ('FIXTURE', 'PRACTICE')")
-        return v
+        return value
 
     @validator("season_type")
-    def season_type_validate_enum(cls, v):
-        if v not in ("SEASON", "TOURNAMENT", "ONE_OFF"):
+    def season_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value not in ("SEASON", "TOURNAMENT", "ONE_OFF"):
             raise ValueError("must be one of enum values ('SEASON', 'TOURNAMENT', 'ONE_OFF')")
-        return v
+        return value
 
     @validator("status")
-    def status_validate_enum(cls, v):
-        if v not in ("ACTIVE", "INACTIVE", "PENDING"):
+    def status_validate_enum(cls, value):
+        """Validates the enum"""
+        if value not in ("ACTIVE", "INACTIVE", "PENDING"):
             raise ValueError("must be one of enum values ('ACTIVE', 'INACTIVE', 'PENDING')")
-        return v
+        return value
 
     @validator("gender")
-    def gender_validate_enum(cls, v):
-        if v not in ("FEMALE", "MALE", "MIXED", "UNKNOWN"):
+    def gender_validate_enum(cls, value):
+        """Validates the enum"""
+        if value not in ("FEMALE", "MALE", "MIXED", "UNKNOWN"):
             raise ValueError("must be one of enum values ('FEMALE', 'MALE', 'MIXED', 'UNKNOWN')")
-        return v
+        return value
 
     @validator("age_group")
-    def age_group_validate_enum(cls, v):
-        if v not in (
+    def age_group_validate_enum(cls, value):
+        """Validates the enum"""
+        if value not in (
             "JUNIOR",
             "YOUTH",
             "UNDER_15",
             "UNDER_16",
             "UNDER_17",
             "UNDER_18",
             "UNDER_19",
@@ -212,19 +217,20 @@
             "UNDER_23",
             "SENIOR",
             "MASTERS",
         ):
             raise ValueError(
                 "must be one of enum values ('JUNIOR', 'YOUTH', 'UNDER_15', 'UNDER_16', 'UNDER_17', 'UNDER_18', 'UNDER_19', 'UNDER_20', 'UNDER_21', 'UNDER_22', 'UNDER_23', 'SENIOR', 'MASTERS')"
             )
-        return v
+        return value
 
     @validator("standard")
-    def standard_validate_enum(cls, v):
-        if v not in (
+    def standard_validate_enum(cls, value):
+        """Validates the enum"""
+        if value not in (
             "ELITE",
             "FRIENDLY",
             "GRASS_ROOT",
             "INTERNATIONAL",
             "NONCONTINENTAL_CHAMPIONSHIP",
             "OLYMPIC",
             "REGION",
@@ -232,39 +238,46 @@
             "TIER3",
             "WORLD_CHAMPIONSHIP",
             "ZONE_CHAMPIONSHIP",
         ):
             raise ValueError(
                 "must be one of enum values ('ELITE', 'FRIENDLY', 'GRASS_ROOT', 'INTERNATIONAL', 'NONCONTINENTAL_CHAMPIONSHIP', 'OLYMPIC', 'REGION', 'TIER2', 'TIER3', 'WORLD_CHAMPIONSHIP', 'ZONE_CHAMPIONSHIP')"
             )
-        return v
+        return value
 
     @validator("representation")
-    def representation_validate_enum(cls, v):
-        if v not in ("CLUB", "STATE", "REGION", "COUNTRY", "PERSON"):
+    def representation_validate_enum(cls, value):
+        """Validates the enum"""
+        if value not in ("CLUB", "STATE", "REGION", "COUNTRY", "PERSON"):
             raise ValueError("must be one of enum values ('CLUB', 'STATE', 'REGION', 'COUNTRY', 'PERSON')")
-        return v
+        return value
 
     @validator("external_id")
-    def external_id_validate_regular_expression(cls, v):
-        if v is None:
-            return v
-        if not re.match(r"^[0-9A-Za-z\/_-]+$", v):
+    def external_id_validate_regular_expression(cls, value):
+        """Validates the regular expression"""
+        if value is None:
+            return value
+
+        if not re.match(r"^[0-9A-Za-z\/_-]+$", value):
             raise ValueError(r"must validate the regular expression /^[0-9A-Za-z\/_-]+$/")
-        return v
+        return value
 
     @validator("video_production")
-    def video_production_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("NONE", "AUTOMATED", "MANUAL"):
+    def video_production_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("NONE", "AUTOMATED", "MANUAL"):
             raise ValueError("must be one of enum values ('NONE', 'AUTOMATED', 'MANUAL')")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -360,15 +373,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> SeasonPostBody:
         """Create an instance of SeasonPostBody from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return SeasonPostBody.parse_obj(obj)
 
         _obj = SeasonPostBody.parse_obj(
             {
                 "season_id": obj.get("seasonId"),
                 "competition_id": obj.get("competitionId"),
                 "leader_criteria_id": obj.get("leaderCriteriaId"),
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_put_body.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_put_body.py`

 * *Files 4% similar despite different names*

```diff
@@ -14,15 +14,14 @@
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
 from datetime import date
-from inspect import getfullargspec
 from typing import Any, Dict, Optional
 
 from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr, conint, constr, validator
 
 from atriumsports.datacore.openapi.models.seasonroster_configuration import SEASONROSTERConfiguration
 from atriumsports.datacore.openapi.models.social_media import SocialMedia
 
@@ -165,50 +164,60 @@
         "configuration",
         "profileId",
         "videoProduction",
         "rosterConfiguration",
     ]
 
     @validator("event_type")
-    def event_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("FIXTURE", "PRACTICE"):
+    def event_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("FIXTURE", "PRACTICE"):
             raise ValueError("must be one of enum values ('FIXTURE', 'PRACTICE')")
-        return v
+        return value
 
     @validator("season_type")
-    def season_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("SEASON", "TOURNAMENT", "ONE_OFF"):
+    def season_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("SEASON", "TOURNAMENT", "ONE_OFF"):
             raise ValueError("must be one of enum values ('SEASON', 'TOURNAMENT', 'ONE_OFF')")
-        return v
+        return value
 
     @validator("status")
-    def status_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("ACTIVE", "INACTIVE", "PENDING"):
+    def status_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("ACTIVE", "INACTIVE", "PENDING"):
             raise ValueError("must be one of enum values ('ACTIVE', 'INACTIVE', 'PENDING')")
-        return v
+        return value
 
     @validator("gender")
-    def gender_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("FEMALE", "MALE", "MIXED", "UNKNOWN"):
+    def gender_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("FEMALE", "MALE", "MIXED", "UNKNOWN"):
             raise ValueError("must be one of enum values ('FEMALE', 'MALE', 'MIXED', 'UNKNOWN')")
-        return v
+        return value
 
     @validator("age_group")
-    def age_group_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in (
+    def age_group_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in (
             "JUNIOR",
             "YOUTH",
             "UNDER_15",
             "UNDER_16",
             "UNDER_17",
             "UNDER_18",
             "UNDER_19",
@@ -218,21 +227,23 @@
             "UNDER_23",
             "SENIOR",
             "MASTERS",
         ):
             raise ValueError(
                 "must be one of enum values ('JUNIOR', 'YOUTH', 'UNDER_15', 'UNDER_16', 'UNDER_17', 'UNDER_18', 'UNDER_19', 'UNDER_20', 'UNDER_21', 'UNDER_22', 'UNDER_23', 'SENIOR', 'MASTERS')"
             )
-        return v
+        return value
 
     @validator("standard")
-    def standard_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in (
+    def standard_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in (
             "ELITE",
             "FRIENDLY",
             "GRASS_ROOT",
             "INTERNATIONAL",
             "NONCONTINENTAL_CHAMPIONSHIP",
             "OLYMPIC",
             "REGION",
@@ -240,41 +251,49 @@
             "TIER3",
             "WORLD_CHAMPIONSHIP",
             "ZONE_CHAMPIONSHIP",
         ):
             raise ValueError(
                 "must be one of enum values ('ELITE', 'FRIENDLY', 'GRASS_ROOT', 'INTERNATIONAL', 'NONCONTINENTAL_CHAMPIONSHIP', 'OLYMPIC', 'REGION', 'TIER2', 'TIER3', 'WORLD_CHAMPIONSHIP', 'ZONE_CHAMPIONSHIP')"
             )
-        return v
+        return value
 
     @validator("representation")
-    def representation_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("CLUB", "STATE", "REGION", "COUNTRY", "PERSON"):
+    def representation_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("CLUB", "STATE", "REGION", "COUNTRY", "PERSON"):
             raise ValueError("must be one of enum values ('CLUB', 'STATE', 'REGION', 'COUNTRY', 'PERSON')")
-        return v
+        return value
 
     @validator("external_id")
-    def external_id_validate_regular_expression(cls, v):
-        if v is None:
-            return v
-        if not re.match(r"^[0-9A-Za-z\/_-]+$", v):
+    def external_id_validate_regular_expression(cls, value):
+        """Validates the regular expression"""
+        if value is None:
+            return value
+
+        if not re.match(r"^[0-9A-Za-z\/_-]+$", value):
             raise ValueError(r"must validate the regular expression /^[0-9A-Za-z\/_-]+$/")
-        return v
+        return value
 
     @validator("video_production")
-    def video_production_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("NONE", "AUTOMATED", "MANUAL"):
+    def video_production_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("NONE", "AUTOMATED", "MANUAL"):
             raise ValueError("must be one of enum values ('NONE', 'AUTOMATED', 'MANUAL')")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -370,15 +389,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> SeasonPutBody:
         """Create an instance of SeasonPutBody from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return SeasonPutBody.parse_obj(obj)
 
         _obj = SeasonPutBody.parse_obj(
             {
                 "competition_id": obj.get("competitionId"),
                 "leader_criteria_id": obj.get("leaderCriteriaId"),
                 "international_reference": obj.get("internationalReference"),
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_roster_model.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_roster_model.py`

 * *Files 2% similar despite different names*

```diff
@@ -14,15 +14,14 @@
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
 from datetime import datetime
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr, constr, validator
 
 from atriumsports.datacore.openapi.models.entities_model_entity_group import EntitiesModelEntityGroup
 from atriumsports.datacore.openapi.models.fixture_entities_model_conference import FixtureEntitiesModelConference
 from atriumsports.datacore.openapi.models.fixture_entities_model_division import FixtureEntitiesModelDivision
@@ -90,32 +89,38 @@
         "status",
         "externalId",
         "updated",
         "added",
     ]
 
     @validator("status")
-    def status_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("ACTIVE", "INJURED", "OUT", "SUSPENDED", "OTHER_NOT_PARTICIPATING"):
+    def status_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("ACTIVE", "INJURED", "OUT", "SUSPENDED", "OTHER_NOT_PARTICIPATING"):
             raise ValueError(
                 "must be one of enum values ('ACTIVE', 'INJURED', 'OUT', 'SUSPENDED', 'OTHER_NOT_PARTICIPATING')"
             )
-        return v
+        return value
 
     @validator("external_id")
-    def external_id_validate_regular_expression(cls, v):
-        if v is None:
-            return v
-        if not re.match(r"^[0-9A-Za-z\/_-]+$", v):
+    def external_id_validate_regular_expression(cls, value):
+        """Validates the regular expression"""
+        if value is None:
+            return value
+
+        if not re.match(r"^[0-9A-Za-z\/_-]+$", value):
             raise ValueError(r"must validate the regular expression /^[0-9A-Za-z\/_-]+$/")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -194,15 +199,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> SeasonRosterModel:
         """Create an instance of SeasonRosterModel from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return SeasonRosterModel.parse_obj(obj)
 
         _obj = SeasonRosterModel.parse_obj(
             {
                 "season_id": obj.get("seasonId"),
                 "season": FixtureProgressionsModelSeason.from_dict(obj.get("season"))
                 if obj.get("season") is not None
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_roster_model_organization.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_roster_model_organization.py`

 * *Files 10% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr, validator
 
 
 class SeasonRosterModelOrganization(BaseModel):
     """
@@ -29,22 +28,26 @@
     """
 
     resource_type: Optional[StrictStr] = Field(None, alias="resourceType")
     id: Optional[StrictStr] = Field(None, description="Unique identifier for this resource")
     __properties = ["resourceType", "id"]
 
     @validator("resource_type")
-    def resource_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("organizations"):
+    def resource_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("organizations"):
             raise ValueError("must be one of enum values ('organizations')")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -64,12 +67,12 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> SeasonRosterModelOrganization:
         """Create an instance of SeasonRosterModelOrganization from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return SeasonRosterModelOrganization.parse_obj(obj)
 
         _obj = SeasonRosterModelOrganization.parse_obj({"resource_type": obj.get("resourceType"), "id": obj.get("id")})
         return _obj
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_roster_post_body.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_roster_post_body.py`

 * *Files 2% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr, constr, validator
 
 
 class SeasonRosterPostBody(BaseModel):
     """
@@ -59,30 +58,35 @@
         "bib",
         "position",
         "status",
         "externalId",
     ]
 
     @validator("status")
-    def status_validate_enum(cls, v):
-        if v not in ("ACTIVE", "INJURED", "OUT", "SUSPENDED", "OTHER_NOT_PARTICIPATING"):
+    def status_validate_enum(cls, value):
+        """Validates the enum"""
+        if value not in ("ACTIVE", "INJURED", "OUT", "SUSPENDED", "OTHER_NOT_PARTICIPATING"):
             raise ValueError(
                 "must be one of enum values ('ACTIVE', 'INJURED', 'OUT', 'SUSPENDED', 'OTHER_NOT_PARTICIPATING')"
             )
-        return v
+        return value
 
     @validator("external_id")
-    def external_id_validate_regular_expression(cls, v):
-        if v is None:
-            return v
-        if not re.match(r"^[0-9A-Za-z\/_-]+$", v):
+    def external_id_validate_regular_expression(cls, value):
+        """Validates the regular expression"""
+        if value is None:
+            return value
+
+        if not re.match(r"^[0-9A-Za-z\/_-]+$", value):
             raise ValueError(r"must validate the regular expression /^[0-9A-Za-z\/_-]+$/")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -132,15 +136,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> SeasonRosterPostBody:
         """Create an instance of SeasonRosterPostBody from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return SeasonRosterPostBody.parse_obj(obj)
 
         _obj = SeasonRosterPostBody.parse_obj(
             {
                 "season_id": obj.get("seasonId"),
                 "entity_id": obj.get("entityId"),
                 "entity_group_id": obj.get("entityGroupId"),
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_roster_response.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/video_stream_inputs_response.py`

 * *Files 8% similar despite different names*

```diff
@@ -13,51 +13,52 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import List, Optional
 
 from pydantic import BaseModel, conlist
 
 from atriumsports.datacore.openapi.models.included_data import IncludedData
 from atriumsports.datacore.openapi.models.response_links import ResponseLinks
 from atriumsports.datacore.openapi.models.response_meta_data import ResponseMetaData
-from atriumsports.datacore.openapi.models.season_roster_model import SeasonRosterModel
+from atriumsports.datacore.openapi.models.video_stream_inputs_model import VideoStreamInputsModel
 
 
-class SeasonRosterResponse(BaseModel):
+class VideoStreamInputsResponse(BaseModel):
     """
-    SeasonRosterResponse
+    VideoStreamInputsResponse
     """
 
     meta: Optional[ResponseMetaData] = None
     links: Optional[ResponseLinks] = None
     included: Optional[IncludedData] = None
-    data: Optional[conlist(SeasonRosterModel)] = None
+    data: Optional[conlist(VideoStreamInputsModel)] = None
     __properties = ["meta", "links", "included", "data"]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> SeasonRosterResponse:
-        """Create an instance of SeasonRosterResponse from a JSON string"""
+    def from_json(cls, json_str: str) -> VideoStreamInputsResponse:
+        """Create an instance of VideoStreamInputsResponse from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
     def to_dict(self):
         """Returns the dictionary representation of the model using alias"""
         _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)
         # override the default output from pydantic by calling `to_dict()` of meta
         if self.meta:
@@ -74,26 +75,26 @@
             for _item in self.data:
                 if _item:
                     _items.append(_item.to_dict())
             _dict["data"] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> SeasonRosterResponse:
-        """Create an instance of SeasonRosterResponse from a dict"""
+    def from_dict(cls, obj: dict) -> VideoStreamInputsResponse:
+        """Create an instance of VideoStreamInputsResponse from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
-            return SeasonRosterResponse.parse_obj(obj)
+        if not isinstance(obj, dict):
+            return VideoStreamInputsResponse.parse_obj(obj)
 
-        _obj = SeasonRosterResponse.parse_obj(
+        _obj = VideoStreamInputsResponse.parse_obj(
             {
                 "meta": ResponseMetaData.from_dict(obj.get("meta")) if obj.get("meta") is not None else None,
                 "links": ResponseLinks.from_dict(obj.get("links")) if obj.get("links") is not None else None,
                 "included": IncludedData.from_dict(obj.get("included")) if obj.get("included") is not None else None,
-                "data": [SeasonRosterModel.from_dict(_item) for _item in obj.get("data")]
+                "data": [VideoStreamInputsModel.from_dict(_item) for _item in obj.get("data")]
                 if obj.get("data") is not None
                 else None,
             }
         )
         return _obj
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_rounds_model.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_rounds_model.py`

 * *Files 2% similar despite different names*

```diff
@@ -14,15 +14,14 @@
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
 from datetime import datetime
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr, conint, constr, validator
 
 from atriumsports.datacore.openapi.models.fixture_progressions_model_season import FixtureProgressionsModelSeason
 from atriumsports.datacore.openapi.models.season_fixture_stages_pools_list_model_pool import (
     SeasonFixtureStagesPoolsListModelPool,
@@ -104,22 +103,26 @@
         "roundOrder",
         "externalId",
         "updated",
         "added",
     ]
 
     @validator("external_id")
-    def external_id_validate_regular_expression(cls, v):
-        if v is None:
-            return v
-        if not re.match(r"^[0-9A-Za-z\/_-]+$", v):
+    def external_id_validate_regular_expression(cls, value):
+        """Validates the regular expression"""
+        if value is None:
+            return value
+
+        if not re.match(r"^[0-9A-Za-z\/_-]+$", value):
             raise ValueError(r"must validate the regular expression /^[0-9A-Za-z\/_-]+$/")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -204,15 +207,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> SeasonRoundsModel:
         """Create an instance of SeasonRoundsModel from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return SeasonRoundsModel.parse_obj(obj)
 
         _obj = SeasonRoundsModel.parse_obj(
             {
                 "season_id": obj.get("seasonId"),
                 "season": FixtureProgressionsModelSeason.from_dict(obj.get("season"))
                 if obj.get("season") is not None
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_rounds_model_organization.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_person_statistics_model_organization.py`

 * *Files 12% similar despite different names*

```diff
@@ -13,63 +13,68 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr, validator
 
 
-class SeasonRoundsModelOrganization(BaseModel):
+class SeasonPersonStatisticsModelOrganization(BaseModel):
     """
-    The organization that this round belongs to
+    The organization that this season person statistics belongs to
     """
 
     resource_type: Optional[StrictStr] = Field(None, alias="resourceType")
     id: Optional[StrictStr] = Field(None, description="Unique identifier for this resource")
     __properties = ["resourceType", "id"]
 
     @validator("resource_type")
-    def resource_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("organizations"):
+    def resource_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("organizations"):
             raise ValueError("must be one of enum values ('organizations')")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> SeasonRoundsModelOrganization:
-        """Create an instance of SeasonRoundsModelOrganization from a JSON string"""
+    def from_json(cls, json_str: str) -> SeasonPersonStatisticsModelOrganization:
+        """Create an instance of SeasonPersonStatisticsModelOrganization from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
     def to_dict(self):
         """Returns the dictionary representation of the model using alias"""
         _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> SeasonRoundsModelOrganization:
-        """Create an instance of SeasonRoundsModelOrganization from a dict"""
+    def from_dict(cls, obj: dict) -> SeasonPersonStatisticsModelOrganization:
+        """Create an instance of SeasonPersonStatisticsModelOrganization from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
-            return SeasonRoundsModelOrganization.parse_obj(obj)
+        if not isinstance(obj, dict):
+            return SeasonPersonStatisticsModelOrganization.parse_obj(obj)
 
-        _obj = SeasonRoundsModelOrganization.parse_obj({"resource_type": obj.get("resourceType"), "id": obj.get("id")})
+        _obj = SeasonPersonStatisticsModelOrganization.parse_obj(
+            {"resource_type": obj.get("resourceType"), "id": obj.get("id")}
+        )
         return _obj
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_rounds_response.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_rounds_response.py`

 * *Files 8% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import List, Optional
 
 from pydantic import BaseModel, conlist
 
 from atriumsports.datacore.openapi.models.included_data import IncludedData
 from atriumsports.datacore.openapi.models.response_links import ResponseLinks
 from atriumsports.datacore.openapi.models.response_meta_data import ResponseMetaData
@@ -36,14 +35,16 @@
     meta: Optional[ResponseMetaData] = None
     links: Optional[ResponseLinks] = None
     included: Optional[IncludedData] = None
     data: Optional[conlist(SeasonRoundsModel)] = None
     __properties = ["meta", "links", "included", "data"]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -79,15 +80,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> SeasonRoundsResponse:
         """Create an instance of SeasonRoundsResponse from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return SeasonRoundsResponse.parse_obj(obj)
 
         _obj = SeasonRoundsResponse.parse_obj(
             {
                 "meta": ResponseMetaData.from_dict(obj.get("meta")) if obj.get("meta") is not None else None,
                 "links": ResponseLinks.from_dict(obj.get("links")) if obj.get("links") is not None else None,
                 "included": IncludedData.from_dict(obj.get("included")) if obj.get("included") is not None else None,
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_series_competitor.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_series_competitor.py`

 * *Files 7% similar despite different names*

```diff
@@ -13,18 +13,17 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
-from typing import Optional
+from typing import Optional, Union
 
-from pydantic import BaseModel, Field, StrictFloat, StrictStr, validator
+from pydantic import BaseModel, Field, StrictFloat, StrictInt, StrictStr, validator
 
 
 class SeasonSeriesCompetitor(BaseModel):
     """
     SeasonSeriesCompetitor
     """
 
@@ -32,27 +31,27 @@
     person_id: Optional[StrictStr] = Field(None, alias="personId", description="The uuid of the person")
     conference_id: Optional[StrictStr] = Field(
         None, alias="conferenceId", description="The uuid of the conference the competitor represents"
     )
     division_id: Optional[StrictStr] = Field(
         None, alias="divisionId", description="The uuid of the conference the competitor represents"
     )
-    pre_series_ranking: Optional[StrictFloat] = Field(
+    pre_series_ranking: Optional[Union[StrictFloat, StrictInt]] = Field(
         None, alias="preSeriesRanking", description="The rank of the competitor coming into the series"
     )
-    string_record: Optional[StrictFloat] = Field(
+    string_record: Optional[Union[StrictFloat, StrictInt]] = Field(
         None, alias="stringRecord", description="String record of the competitor"
     )
-    series_wins: Optional[StrictFloat] = Field(
+    series_wins: Optional[Union[StrictFloat, StrictInt]] = Field(
         None, alias="seriesWins", description="Number of wins in the series for the competitor"
     )
-    series_losses: Optional[StrictFloat] = Field(
+    series_losses: Optional[Union[StrictFloat, StrictInt]] = Field(
         None, alias="seriesLosses", description="Number of losses in the series for the competitor"
     )
-    series_draws: Optional[StrictFloat] = Field(
+    series_draws: Optional[Union[StrictFloat, StrictInt]] = Field(
         None, alias="seriesDraws", description="Number of draws in the series for the competitor"
     )
     series_result: Optional[StrictStr] = Field(
         None, alias="seriesResult", description="Result for the competitor in the series"
     )
     __properties = [
         "entityId",
@@ -64,22 +63,26 @@
         "seriesWins",
         "seriesLosses",
         "seriesDraws",
         "seriesResult",
     ]
 
     @validator("series_result")
-    def series_result_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("PENDING", "WON", "LOST", "DRAW"):
+    def series_result_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("PENDING", "WON", "LOST", "DRAW"):
             raise ValueError("must be one of enum values ('PENDING', 'WON', 'LOST', 'DRAW')")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -99,15 +102,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> SeasonSeriesCompetitor:
         """Create an instance of SeasonSeriesCompetitor from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return SeasonSeriesCompetitor.parse_obj(obj)
 
         _obj = SeasonSeriesCompetitor.parse_obj(
             {
                 "entity_id": obj.get("entityId"),
                 "person_id": obj.get("personId"),
                 "conference_id": obj.get("conferenceId"),
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_series_model.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/series_post_body.py`

 * *Files 15% similar despite different names*

```diff
@@ -13,51 +13,39 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from datetime import date, datetime
-from inspect import getfullargspec
+from datetime import date
 from typing import List, Optional
 
-from pydantic import BaseModel, Field, StrictInt, StrictStr, conint, conlist, constr, validator
+from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr, conint, conlist, constr, validator
 
-from atriumsports.datacore.openapi.models.fixture_entities_model_conference import FixtureEntitiesModelConference
-from atriumsports.datacore.openapi.models.fixture_entities_model_division import FixtureEntitiesModelDivision
-from atriumsports.datacore.openapi.models.fixture_progressions_model_season import FixtureProgressionsModelSeason
 from atriumsports.datacore.openapi.models.season_series_competitor import SeasonSeriesCompetitor
-from atriumsports.datacore.openapi.models.season_series_model_organization import SeasonSeriesModelOrganization
 
 
-class SeasonSeriesModel(BaseModel):
+class SeriesPostBody(BaseModel):
     """
-    SeasonSeriesModel
+    SeriesPostBody
     """
 
-    series_code: Optional[constr(strict=True, max_length=30)] = Field(
-        None, alias="seriesCode", description="A unique code for the season series. (Unique for season)"
+    series_code: constr(strict=True, max_length=30) = Field(
+        ..., alias="seriesCode", description="A unique code for the season series. (Unique for season)"
     )
-    season_id: Optional[StrictStr] = Field(None, alias="seasonId", description="The unique identifier of the season")
-    season: Optional[FixtureProgressionsModelSeason] = None
-    organization_id: Optional[StrictStr] = Field(
-        None, alias="organizationId", description="The unique identifier of the organization"
-    )
-    organization: Optional[SeasonSeriesModelOrganization] = None
+    season_id: StrictStr = Field(..., alias="seasonId", description="The unique identifier of the season")
     conference_id: Optional[StrictStr] = Field(
         None, alias="conferenceId", description="The unique identifier of the conference"
     )
-    conference: Optional[FixtureEntitiesModelConference] = None
     division_id: Optional[StrictStr] = Field(
         None, alias="divisionId", description="The unique identifier of the division"
     )
-    division: Optional[FixtureEntitiesModelDivision] = None
-    name_local: Optional[constr(strict=True, max_length=150)] = Field(
-        None,
+    name_local: constr(strict=True, max_length=150) = Field(
+        ...,
         alias="nameLocal",
         description="The name of the series in the [local](#section/Introduction/Character-Sets-and-Names) language",
     )
     abbreviation_local: Optional[constr(strict=True, max_length=50)] = Field(
         None,
         alias="abbreviationLocal",
         description="An abbreviation/short name in the [local](#section/Introduction/Character-Sets-and-Names) language",
@@ -68,134 +56,121 @@
         description="The name of the series in [latin](#section/Introduction/Character-Sets-and-Names) characters",
     )
     abbreviation_latin: Optional[constr(strict=True, max_length=50)] = Field(
         None,
         alias="abbreviationLatin",
         description="An abbreviation/short name in [latin](#section/Introduction/Character-Sets-and-Names) characters",
     )
-    status: Optional[constr(strict=True, max_length=30)] = Field(
-        None, description="Status >- `ACTIVE` Active >- `COMPLETE` Complete >- `NOT_STARTED` Not Started "
+    status: constr(strict=True, max_length=30) = Field(
+        ..., description="Status >- `ACTIVE` Active >- `COMPLETE` Complete >- `NOT_STARTED` Not Started "
     )
-    series_type: Optional[constr(strict=True, max_length=50)] = Field(
-        None,
+    series_type: constr(strict=True, max_length=50) = Field(
+        ...,
         alias="seriesType",
         description="The type of series >- `BEST_OF` Best of >- `HOME_AND_AWAY` Home and Away >- `KNOCKOUT` Knockout ",
     )
+    auto_calculated: Optional[StrictBool] = Field(
+        None, alias="autoCalculated", description="Is the winner auto calculated?"
+    )
     best_of: Optional[conint(strict=True)] = Field(None, alias="bestOf", description="Best of number")
     series_number: Optional[conint(strict=True)] = Field(
         None, alias="seriesNumber", description="User defined series number"
     )
     max_fixtures_number: Optional[StrictInt] = Field(
         None, alias="maxFixturesNumber", description="The maximum number of games within a playoff series"
     )
+    winner: Optional[StrictStr] = Field(None, description="The unique identifier of the winner, person or entity")
     series_order: Optional[conint(strict=True)] = Field(
         None, alias="seriesOrder", description="User defined sort order of the series"
     )
+    stage_code: Optional[constr(strict=True, max_length=30)] = Field(
+        None, alias="stageCode", description="A unique code for the stage. (Unique for season)"
+    )
+    pool_code: Optional[constr(strict=True, max_length=30)] = Field(
+        None, alias="poolCode", description="A unique code for the pool. (Unique for season)"
+    )
     start_date: Optional[date] = Field(None, alias="startDate", description="Series start date")
     end_date: Optional[date] = Field(None, alias="endDate", description="Series end date")
     external_id: Optional[constr(strict=True, max_length=150)] = Field(
         None, alias="externalId", description="The Id of the data as set by the provider of the data"
     )
-    updated: Optional[datetime] = Field(None, description="Date/time last modified. In UTC")
-    added: Optional[datetime] = Field(None, description="Date/time added. In UTC")
     competitors: Optional[conlist(SeasonSeriesCompetitor)] = Field(
         None, description="Array of competitors in the series. A competitor may have a results and a ranking"
     )
     __properties = [
         "seriesCode",
         "seasonId",
-        "season",
-        "organizationId",
-        "organization",
         "conferenceId",
-        "conference",
         "divisionId",
-        "division",
         "nameLocal",
         "abbreviationLocal",
         "nameLatin",
         "abbreviationLatin",
         "status",
         "seriesType",
+        "autoCalculated",
         "bestOf",
         "seriesNumber",
         "maxFixturesNumber",
+        "winner",
         "seriesOrder",
+        "stageCode",
+        "poolCode",
         "startDate",
         "endDate",
         "externalId",
-        "updated",
-        "added",
         "competitors",
     ]
 
     @validator("status")
-    def status_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("NOT_STARTED", "ACTIVE", "COMPLETE"):
+    def status_validate_enum(cls, value):
+        """Validates the enum"""
+        if value not in ("NOT_STARTED", "ACTIVE", "COMPLETE"):
             raise ValueError("must be one of enum values ('NOT_STARTED', 'ACTIVE', 'COMPLETE')")
-        return v
+        return value
 
     @validator("series_type")
-    def series_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("BEST_OF", "HOME_AND_AWAY", "KNOCKOUT"):
+    def series_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value not in ("BEST_OF", "HOME_AND_AWAY", "KNOCKOUT"):
             raise ValueError("must be one of enum values ('BEST_OF', 'HOME_AND_AWAY', 'KNOCKOUT')")
-        return v
+        return value
 
     @validator("external_id")
-    def external_id_validate_regular_expression(cls, v):
-        if v is None:
-            return v
-        if not re.match(r"^[0-9A-Za-z\/_-]+$", v):
+    def external_id_validate_regular_expression(cls, value):
+        """Validates the regular expression"""
+        if value is None:
+            return value
+
+        if not re.match(r"^[0-9A-Za-z\/_-]+$", value):
             raise ValueError(r"must validate the regular expression /^[0-9A-Za-z\/_-]+$/")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> SeasonSeriesModel:
-        """Create an instance of SeasonSeriesModel from a JSON string"""
+    def from_json(cls, json_str: str) -> SeriesPostBody:
+        """Create an instance of SeriesPostBody from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
     def to_dict(self):
         """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(
-            by_alias=True,
-            exclude={
-                "organization_id",
-                "updated",
-                "added",
-            },
-            exclude_none=True,
-        )
-        # override the default output from pydantic by calling `to_dict()` of season
-        if self.season:
-            _dict["season"] = self.season.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of organization
-        if self.organization:
-            _dict["organization"] = self.organization.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of conference
-        if self.conference:
-            _dict["conference"] = self.conference.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of division
-        if self.division:
-            _dict["division"] = self.division.to_dict()
+        _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)
         # override the default output from pydantic by calling `to_dict()` of each item in competitors (list)
         _items = []
         if self.competitors:
             for _item in self.competitors:
                 if _item:
                     _items.append(_item.to_dict())
             _dict["competitors"] = _items
@@ -235,19 +210,34 @@
             _dict["seriesNumber"] = None
 
         # set to None if max_fixtures_number (nullable) is None
         # and __fields_set__ contains the field
         if self.max_fixtures_number is None and "max_fixtures_number" in self.__fields_set__:
             _dict["maxFixturesNumber"] = None
 
+        # set to None if winner (nullable) is None
+        # and __fields_set__ contains the field
+        if self.winner is None and "winner" in self.__fields_set__:
+            _dict["winner"] = None
+
         # set to None if series_order (nullable) is None
         # and __fields_set__ contains the field
         if self.series_order is None and "series_order" in self.__fields_set__:
             _dict["seriesOrder"] = None
 
+        # set to None if stage_code (nullable) is None
+        # and __fields_set__ contains the field
+        if self.stage_code is None and "stage_code" in self.__fields_set__:
+            _dict["stageCode"] = None
+
+        # set to None if pool_code (nullable) is None
+        # and __fields_set__ contains the field
+        if self.pool_code is None and "pool_code" in self.__fields_set__:
+            _dict["poolCode"] = None
+
         # set to None if start_date (nullable) is None
         # and __fields_set__ contains the field
         if self.start_date is None and "start_date" in self.__fields_set__:
             _dict["startDate"] = None
 
         # set to None if end_date (nullable) is None
         # and __fields_set__ contains the field
@@ -263,55 +253,44 @@
         # and __fields_set__ contains the field
         if self.competitors is None and "competitors" in self.__fields_set__:
             _dict["competitors"] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> SeasonSeriesModel:
-        """Create an instance of SeasonSeriesModel from a dict"""
+    def from_dict(cls, obj: dict) -> SeriesPostBody:
+        """Create an instance of SeriesPostBody from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
-            return SeasonSeriesModel.parse_obj(obj)
+        if not isinstance(obj, dict):
+            return SeriesPostBody.parse_obj(obj)
 
-        _obj = SeasonSeriesModel.parse_obj(
+        _obj = SeriesPostBody.parse_obj(
             {
                 "series_code": obj.get("seriesCode"),
                 "season_id": obj.get("seasonId"),
-                "season": FixtureProgressionsModelSeason.from_dict(obj.get("season"))
-                if obj.get("season") is not None
-                else None,
-                "organization_id": obj.get("organizationId"),
-                "organization": SeasonSeriesModelOrganization.from_dict(obj.get("organization"))
-                if obj.get("organization") is not None
-                else None,
                 "conference_id": obj.get("conferenceId"),
-                "conference": FixtureEntitiesModelConference.from_dict(obj.get("conference"))
-                if obj.get("conference") is not None
-                else None,
                 "division_id": obj.get("divisionId"),
-                "division": FixtureEntitiesModelDivision.from_dict(obj.get("division"))
-                if obj.get("division") is not None
-                else None,
                 "name_local": obj.get("nameLocal"),
                 "abbreviation_local": obj.get("abbreviationLocal"),
                 "name_latin": obj.get("nameLatin"),
                 "abbreviation_latin": obj.get("abbreviationLatin"),
                 "status": obj.get("status"),
                 "series_type": obj.get("seriesType"),
+                "auto_calculated": obj.get("autoCalculated"),
                 "best_of": obj.get("bestOf"),
                 "series_number": obj.get("seriesNumber"),
                 "max_fixtures_number": obj.get("maxFixturesNumber"),
+                "winner": obj.get("winner"),
                 "series_order": obj.get("seriesOrder"),
+                "stage_code": obj.get("stageCode"),
+                "pool_code": obj.get("poolCode"),
                 "start_date": obj.get("startDate"),
                 "end_date": obj.get("endDate"),
                 "external_id": obj.get("externalId"),
-                "updated": obj.get("updated"),
-                "added": obj.get("added"),
                 "competitors": [SeasonSeriesCompetitor.from_dict(_item) for _item in obj.get("competitors")]
                 if obj.get("competitors") is not None
                 else None,
             }
         )
         return _obj
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_series_model_organization.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/video_files_model_organization.py`

 * *Files 12% similar despite different names*

```diff
@@ -13,63 +13,66 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr, validator
 
 
-class SeasonSeriesModelOrganization(BaseModel):
+class VideoFilesModelOrganization(BaseModel):
     """
-    The organization that this series belongs to
+    The organization that this video file belongs to
     """
 
     resource_type: Optional[StrictStr] = Field(None, alias="resourceType")
     id: Optional[StrictStr] = Field(None, description="Unique identifier for this resource")
     __properties = ["resourceType", "id"]
 
     @validator("resource_type")
-    def resource_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("organizations"):
+    def resource_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("organizations"):
             raise ValueError("must be one of enum values ('organizations')")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> SeasonSeriesModelOrganization:
-        """Create an instance of SeasonSeriesModelOrganization from a JSON string"""
+    def from_json(cls, json_str: str) -> VideoFilesModelOrganization:
+        """Create an instance of VideoFilesModelOrganization from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
     def to_dict(self):
         """Returns the dictionary representation of the model using alias"""
         _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> SeasonSeriesModelOrganization:
-        """Create an instance of SeasonSeriesModelOrganization from a dict"""
+    def from_dict(cls, obj: dict) -> VideoFilesModelOrganization:
+        """Create an instance of VideoFilesModelOrganization from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
-            return SeasonSeriesModelOrganization.parse_obj(obj)
+        if not isinstance(obj, dict):
+            return VideoFilesModelOrganization.parse_obj(obj)
 
-        _obj = SeasonSeriesModelOrganization.parse_obj({"resource_type": obj.get("resourceType"), "id": obj.get("id")})
+        _obj = VideoFilesModelOrganization.parse_obj({"resource_type": obj.get("resourceType"), "id": obj.get("id")})
         return _obj
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_series_response.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_series_response.py`

 * *Files 2% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import List, Optional
 
 from pydantic import BaseModel, conlist
 
 from atriumsports.datacore.openapi.models.included_data import IncludedData
 from atriumsports.datacore.openapi.models.response_links import ResponseLinks
 from atriumsports.datacore.openapi.models.response_meta_data import ResponseMetaData
@@ -36,14 +35,16 @@
     meta: Optional[ResponseMetaData] = None
     links: Optional[ResponseLinks] = None
     included: Optional[IncludedData] = None
     data: Optional[conlist(SeasonSeriesModel)] = None
     __properties = ["meta", "links", "included", "data"]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -79,15 +80,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> SeasonSeriesResponse:
         """Create an instance of SeasonSeriesResponse from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return SeasonSeriesResponse.parse_obj(obj)
 
         _obj = SeasonSeriesResponse.parse_obj(
             {
                 "meta": ResponseMetaData.from_dict(obj.get("meta")) if obj.get("meta") is not None else None,
                 "links": ResponseLinks.from_dict(obj.get("links")) if obj.get("links") is not None else None,
                 "included": IncludedData.from_dict(obj.get("included")) if obj.get("included") is not None else None,
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_stage_post_body.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_stage_post_body.py`

 * *Files 3% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr, conint, constr, validator
 
 
 class SeasonStagePostBody(BaseModel):
     """
@@ -66,22 +65,26 @@
         "nameLatin",
         "abbreviationLatin",
         "stageOrder",
         "externalId",
     ]
 
     @validator("external_id")
-    def external_id_validate_regular_expression(cls, v):
-        if v is None:
-            return v
-        if not re.match(r"^[0-9A-Za-z\/_-]+$", v):
+    def external_id_validate_regular_expression(cls, value):
+        """Validates the regular expression"""
+        if value is None:
+            return value
+
+        if not re.match(r"^[0-9A-Za-z\/_-]+$", value):
             raise ValueError(r"must validate the regular expression /^[0-9A-Za-z\/_-]+$/")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -131,15 +134,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> SeasonStagePostBody:
         """Create an instance of SeasonStagePostBody from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return SeasonStagePostBody.parse_obj(obj)
 
         _obj = SeasonStagePostBody.parse_obj(
             {
                 "season_id": obj.get("seasonId"),
                 "stage_code": obj.get("stageCode"),
                 "name_local": obj.get("nameLocal"),
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_stage_put_body.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_stage_put_body.py`

 * *Files 6% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, conint, constr, validator
 
 
 class SeasonStagePutBody(BaseModel):
     """
@@ -53,22 +52,26 @@
     )
     external_id: Optional[constr(strict=True, max_length=150)] = Field(
         None, alias="externalId", description="The Id of the data as set by the provider of the data"
     )
     __properties = ["nameLocal", "abbreviationLocal", "nameLatin", "abbreviationLatin", "stageOrder", "externalId"]
 
     @validator("external_id")
-    def external_id_validate_regular_expression(cls, v):
-        if v is None:
-            return v
-        if not re.match(r"^[0-9A-Za-z\/_-]+$", v):
+    def external_id_validate_regular_expression(cls, value):
+        """Validates the regular expression"""
+        if value is None:
+            return value
+
+        if not re.match(r"^[0-9A-Za-z\/_-]+$", value):
             raise ValueError(r"must validate the regular expression /^[0-9A-Za-z\/_-]+$/")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -118,15 +121,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> SeasonStagePutBody:
         """Create an instance of SeasonStagePutBody from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return SeasonStagePutBody.parse_obj(obj)
 
         _obj = SeasonStagePutBody.parse_obj(
             {
                 "name_local": obj.get("nameLocal"),
                 "abbreviation_local": obj.get("abbreviationLocal"),
                 "name_latin": obj.get("nameLatin"),
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_stages_model.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_stages_model.py`

 * *Files 2% similar despite different names*

```diff
@@ -14,15 +14,14 @@
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
 from datetime import datetime
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr, conint, constr, validator
 
 from atriumsports.datacore.openapi.models.fixture_progressions_model_season import FixtureProgressionsModelSeason
 from atriumsports.datacore.openapi.models.season_stages_model_organization import SeasonStagesModelOrganization
 
@@ -82,22 +81,26 @@
         "stageOrder",
         "externalId",
         "updated",
         "added",
     ]
 
     @validator("external_id")
-    def external_id_validate_regular_expression(cls, v):
-        if v is None:
-            return v
-        if not re.match(r"^[0-9A-Za-z\/_-]+$", v):
+    def external_id_validate_regular_expression(cls, value):
+        """Validates the regular expression"""
+        if value is None:
+            return value
+
+        if not re.match(r"^[0-9A-Za-z\/_-]+$", value):
             raise ValueError(r"must validate the regular expression /^[0-9A-Za-z\/_-]+$/")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -161,15 +164,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> SeasonStagesModel:
         """Create an instance of SeasonStagesModel from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return SeasonStagesModel.parse_obj(obj)
 
         _obj = SeasonStagesModel.parse_obj(
             {
                 "season_id": obj.get("seasonId"),
                 "season": FixtureProgressionsModelSeason.from_dict(obj.get("season"))
                 if obj.get("season") is not None
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_stages_model_organization.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/standing_adjustments_model_organization.py`

 * *Files 15% similar despite different names*

```diff
@@ -13,63 +13,68 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr, validator
 
 
-class SeasonStagesModelOrganization(BaseModel):
+class StandingAdjustmentsModelOrganization(BaseModel):
     """
-    The organization that this season stage belongs to
+    The organization that this ~standing_adjustment~ belongs to
     """
 
     resource_type: Optional[StrictStr] = Field(None, alias="resourceType")
     id: Optional[StrictStr] = Field(None, description="Unique identifier for this resource")
     __properties = ["resourceType", "id"]
 
     @validator("resource_type")
-    def resource_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("organizations"):
+    def resource_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("organizations"):
             raise ValueError("must be one of enum values ('organizations')")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> SeasonStagesModelOrganization:
-        """Create an instance of SeasonStagesModelOrganization from a JSON string"""
+    def from_json(cls, json_str: str) -> StandingAdjustmentsModelOrganization:
+        """Create an instance of StandingAdjustmentsModelOrganization from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
     def to_dict(self):
         """Returns the dictionary representation of the model using alias"""
         _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> SeasonStagesModelOrganization:
-        """Create an instance of SeasonStagesModelOrganization from a dict"""
+    def from_dict(cls, obj: dict) -> StandingAdjustmentsModelOrganization:
+        """Create an instance of StandingAdjustmentsModelOrganization from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
-            return SeasonStagesModelOrganization.parse_obj(obj)
+        if not isinstance(obj, dict):
+            return StandingAdjustmentsModelOrganization.parse_obj(obj)
 
-        _obj = SeasonStagesModelOrganization.parse_obj({"resource_type": obj.get("resourceType"), "id": obj.get("id")})
+        _obj = StandingAdjustmentsModelOrganization.parse_obj(
+            {"resource_type": obj.get("resourceType"), "id": obj.get("id")}
+        )
         return _obj
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_stages_response.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_stages_response.py`

 * *Files 2% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import List, Optional
 
 from pydantic import BaseModel, conlist
 
 from atriumsports.datacore.openapi.models.included_data import IncludedData
 from atriumsports.datacore.openapi.models.response_links import ResponseLinks
 from atriumsports.datacore.openapi.models.response_meta_data import ResponseMetaData
@@ -36,14 +35,16 @@
     meta: Optional[ResponseMetaData] = None
     links: Optional[ResponseLinks] = None
     included: Optional[IncludedData] = None
     data: Optional[conlist(SeasonStagesModel)] = None
     __properties = ["meta", "links", "included", "data"]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -79,15 +80,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> SeasonStagesResponse:
         """Create an instance of SeasonStagesResponse from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return SeasonStagesResponse.parse_obj(obj)
 
         _obj = SeasonStagesResponse.parse_obj(
             {
                 "meta": ResponseMetaData.from_dict(obj.get("meta")) if obj.get("meta") is not None else None,
                 "links": ResponseLinks.from_dict(obj.get("links")) if obj.get("links") is not None else None,
                 "included": IncludedData.from_dict(obj.get("included")) if obj.get("included") is not None else None,
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_standings_stages_pools_list_model.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_standings_stages_pools_list_model.py`

 * *Files 3% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr, constr
 
 from atriumsports.datacore.openapi.models.fixture_progressions_model_season import FixtureProgressionsModelSeason
 from atriumsports.datacore.openapi.models.season_fixture_stages_pools_list_model_pool import (
     SeasonFixtureStagesPoolsListModelPool,
@@ -52,14 +51,16 @@
     pool_code: Optional[constr(strict=True, max_length=30)] = Field(
         None, alias="poolCode", description="A unique code for the pool. (Unique for season)"
     )
     pool: Optional[SeasonFixtureStagesPoolsListModelPool] = None
     __properties = ["seasonId", "season", "organizationId", "organization", "stageCode", "stage", "poolCode", "pool"]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -102,15 +103,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> SeasonStandingsStagesPoolsListModel:
         """Create an instance of SeasonStandingsStagesPoolsListModel from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return SeasonStandingsStagesPoolsListModel.parse_obj(obj)
 
         _obj = SeasonStandingsStagesPoolsListModel.parse_obj(
             {
                 "season_id": obj.get("seasonId"),
                 "season": FixtureProgressionsModelSeason.from_dict(obj.get("season"))
                 if obj.get("season") is not None
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_standings_stages_pools_list_model_organization.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_standings_stages_pools_list_model_organization.py`

 * *Files 6% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr, validator
 
 
 class SeasonStandingsStagesPoolsListModelOrganization(BaseModel):
     """
@@ -29,22 +28,26 @@
     """
 
     resource_type: Optional[StrictStr] = Field(None, alias="resourceType")
     id: Optional[StrictStr] = Field(None, description="Unique identifier for this resource")
     __properties = ["resourceType", "id"]
 
     @validator("resource_type")
-    def resource_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("organizations"):
+    def resource_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("organizations"):
             raise ValueError("must be one of enum values ('organizations')")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -64,14 +67,14 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> SeasonStandingsStagesPoolsListModelOrganization:
         """Create an instance of SeasonStandingsStagesPoolsListModelOrganization from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return SeasonStandingsStagesPoolsListModelOrganization.parse_obj(obj)
 
         _obj = SeasonStandingsStagesPoolsListModelOrganization.parse_obj(
             {"resource_type": obj.get("resourceType"), "id": obj.get("id")}
         )
         return _obj
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_standings_stages_pools_list_response.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_standings_stages_pools_list_response.py`

 * *Files 3% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import List, Optional
 
 from pydantic import BaseModel, conlist
 
 from atriumsports.datacore.openapi.models.included_data import IncludedData
 from atriumsports.datacore.openapi.models.response_links import ResponseLinks
 from atriumsports.datacore.openapi.models.response_meta_data import ResponseMetaData
@@ -38,14 +37,16 @@
     meta: Optional[ResponseMetaData] = None
     links: Optional[ResponseLinks] = None
     included: Optional[IncludedData] = None
     data: Optional[conlist(SeasonStandingsStagesPoolsListModel)] = None
     __properties = ["meta", "links", "included", "data"]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -81,15 +82,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> SeasonStandingsStagesPoolsListResponse:
         """Create an instance of SeasonStandingsStagesPoolsListResponse from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return SeasonStandingsStagesPoolsListResponse.parse_obj(obj)
 
         _obj = SeasonStandingsStagesPoolsListResponse.parse_obj(
             {
                 "meta": ResponseMetaData.from_dict(obj.get("meta")) if obj.get("meta") is not None else None,
                 "links": ResponseLinks.from_dict(obj.get("links")) if obj.get("links") is not None else None,
                 "included": IncludedData.from_dict(obj.get("included")) if obj.get("included") is not None else None,
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_venues_address.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/venue_address.py`

 * *Files 4% similar despite different names*

```diff
@@ -13,65 +13,66 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
-from typing import Optional
+from typing import Optional, Union
 
-from pydantic import BaseModel, Field, StrictFloat, StrictStr, constr
+from pydantic import BaseModel, Field, StrictFloat, StrictInt, StrictStr, constr
 
 
-class SeasonVenuesAddress(BaseModel):
+class VenueAddress(BaseModel):
     """
-    Street Address for the season venues
+    Street Address for the venue
     """
 
     address1: Optional[StrictStr] = Field(None, description="First line of the address")
     address2: Optional[StrictStr] = Field(None, description="Second line of the address")
     address3: Optional[StrictStr] = Field(None, description="Third line of the address")
     city: Optional[StrictStr] = Field(None, description="The city/suburb of the address")
     state: Optional[StrictStr] = Field(None, description="The state of the address")
     postal_code: Optional[StrictStr] = Field(None, alias="postalCode", description="The postal code for the address")
     country_code: Optional[constr(strict=True, max_length=3, min_length=3)] = Field(
         None,
         alias="countryCode",
         description="ISO Country code of the address.  We recommend you use ISO-3166-1:alpha3 (upper case) values where available.",
     )
-    longitude: Optional[StrictFloat] = None
-    latitude: Optional[StrictFloat] = None
+    longitude: Optional[Union[StrictFloat, StrictInt]] = None
+    latitude: Optional[Union[StrictFloat, StrictInt]] = None
     __properties = [
         "address1",
         "address2",
         "address3",
         "city",
         "state",
         "postalCode",
         "countryCode",
         "longitude",
         "latitude",
     ]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> SeasonVenuesAddress:
-        """Create an instance of SeasonVenuesAddress from a JSON string"""
+    def from_json(cls, json_str: str) -> VenueAddress:
+        """Create an instance of VenueAddress from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
     def to_dict(self):
         """Returns the dictionary representation of the model using alias"""
         _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)
         # set to None if address1 (nullable) is None
         # and __fields_set__ contains the field
@@ -117,23 +118,23 @@
         # and __fields_set__ contains the field
         if self.latitude is None and "latitude" in self.__fields_set__:
             _dict["latitude"] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> SeasonVenuesAddress:
-        """Create an instance of SeasonVenuesAddress from a dict"""
+    def from_dict(cls, obj: dict) -> VenueAddress:
+        """Create an instance of VenueAddress from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
-            return SeasonVenuesAddress.parse_obj(obj)
+        if not isinstance(obj, dict):
+            return VenueAddress.parse_obj(obj)
 
-        _obj = SeasonVenuesAddress.parse_obj(
+        _obj = VenueAddress.parse_obj(
             {
                 "address1": obj.get("address1"),
                 "address2": obj.get("address2"),
                 "address3": obj.get("address3"),
                 "city": obj.get("city"),
                 "state": obj.get("state"),
                 "postal_code": obj.get("postalCode"),
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_venues_list_model.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_venues_list_model.py`

 * *Files 2% similar despite different names*

```diff
@@ -14,15 +14,14 @@
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
 from datetime import datetime
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr, constr, validator
 
 from atriumsports.datacore.openapi.models.fixture_progressions_model_season import FixtureProgressionsModelSeason
 from atriumsports.datacore.openapi.models.season_venues_address import SeasonVenuesAddress
 from atriumsports.datacore.openapi.models.season_venues_list_model_organization import SeasonVenuesListModelOrganization
@@ -108,22 +107,26 @@
         "social",
         "externalId",
         "updated",
         "added",
     ]
 
     @validator("external_id")
-    def external_id_validate_regular_expression(cls, v):
-        if v is None:
-            return v
-        if not re.match(r"^[0-9A-Za-z\/_-]+$", v):
+    def external_id_validate_regular_expression(cls, value):
+        """Validates the regular expression"""
+        if value is None:
+            return value
+
+        if not re.match(r"^[0-9A-Za-z\/_-]+$", value):
             raise ValueError(r"must validate the regular expression /^[0-9A-Za-z\/_-]+$/")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -216,15 +219,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> SeasonVenuesListModel:
         """Create an instance of SeasonVenuesListModel from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return SeasonVenuesListModel.parse_obj(obj)
 
         _obj = SeasonVenuesListModel.parse_obj(
             {
                 "season_id": obj.get("seasonId"),
                 "season": FixtureProgressionsModelSeason.from_dict(obj.get("season"))
                 if obj.get("season") is not None
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_venues_list_model_organization.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_venues_list_model_organization.py`

 * *Files 8% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr, validator
 
 
 class SeasonVenuesListModelOrganization(BaseModel):
     """
@@ -29,22 +28,26 @@
     """
 
     resource_type: Optional[StrictStr] = Field(None, alias="resourceType")
     id: Optional[StrictStr] = Field(None, description="Unique identifier for this resource")
     __properties = ["resourceType", "id"]
 
     @validator("resource_type")
-    def resource_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("organizations"):
+    def resource_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("organizations"):
             raise ValueError("must be one of enum values ('organizations')")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -64,14 +67,14 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> SeasonVenuesListModelOrganization:
         """Create an instance of SeasonVenuesListModelOrganization from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return SeasonVenuesListModelOrganization.parse_obj(obj)
 
         _obj = SeasonVenuesListModelOrganization.parse_obj(
             {"resource_type": obj.get("resourceType"), "id": obj.get("id")}
         )
         return _obj
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_venues_list_model_site.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_venues_list_model_site.py`

 * *Files 16% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr, validator
 
 
 class SeasonVenuesListModelSite(BaseModel):
     """
@@ -29,22 +28,26 @@
     """
 
     resource_type: Optional[StrictStr] = Field(None, alias="resourceType")
     id: Optional[StrictStr] = Field(None, description="Unique identifier for this resource")
     __properties = ["resourceType", "id"]
 
     @validator("resource_type")
-    def resource_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("sites"):
+    def resource_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("sites"):
             raise ValueError("must be one of enum values ('sites')")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -64,12 +67,12 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> SeasonVenuesListModelSite:
         """Create an instance of SeasonVenuesListModelSite from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return SeasonVenuesListModelSite.parse_obj(obj)
 
         _obj = SeasonVenuesListModelSite.parse_obj({"resource_type": obj.get("resourceType"), "id": obj.get("id")})
         return _obj
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/season_venues_list_response.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_venues_list_response.py`

 * *Files 2% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import List, Optional
 
 from pydantic import BaseModel, conlist
 
 from atriumsports.datacore.openapi.models.included_data import IncludedData
 from atriumsports.datacore.openapi.models.response_links import ResponseLinks
 from atriumsports.datacore.openapi.models.response_meta_data import ResponseMetaData
@@ -36,14 +35,16 @@
     meta: Optional[ResponseMetaData] = None
     links: Optional[ResponseLinks] = None
     included: Optional[IncludedData] = None
     data: Optional[conlist(SeasonVenuesListModel)] = None
     __properties = ["meta", "links", "included", "data"]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -79,15 +80,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> SeasonVenuesListResponse:
         """Create an instance of SeasonVenuesListResponse from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return SeasonVenuesListResponse.parse_obj(obj)
 
         _obj = SeasonVenuesListResponse.parse_obj(
             {
                 "meta": ResponseMetaData.from_dict(obj.get("meta")) if obj.get("meta") is not None else None,
                 "links": ResponseLinks.from_dict(obj.get("links")) if obj.get("links") is not None else None,
                 "included": IncludedData.from_dict(obj.get("included")) if obj.get("included") is not None else None,
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/seasonentity_placings_post_body.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/seasonentity_placings_post_body.py`

 * *Files 4% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictInt, StrictStr, constr
 
 
 class SEASONENTITYPlacingsPostBody(BaseModel):
     """
@@ -38,14 +37,16 @@
     entity_id: StrictStr = Field(..., alias="entityId", description="The unique identifier of the entity")
     result_place: Optional[StrictInt] = Field(None, alias="resultPlace", description="Result place")
     points: Optional[StrictInt] = Field(None, description="Points awarded")
     prize_money: Optional[StrictInt] = Field(None, alias="prizeMoney", description="Prize money awarded")
     __properties = ["placingId", "organizationId", "seasonId", "entityId", "resultPlace", "points", "prizeMoney"]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -75,15 +76,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> SEASONENTITYPlacingsPostBody:
         """Create an instance of SEASONENTITYPlacingsPostBody from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return SEASONENTITYPlacingsPostBody.parse_obj(obj)
 
         _obj = SEASONENTITYPlacingsPostBody.parse_obj(
             {
                 "placing_id": obj.get("placingId"),
                 "organization_id": obj.get("organizationId"),
                 "season_id": obj.get("seasonId"),
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/seasonentity_placings_put_body.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/seasonentity_placings_put_body.py`

 * *Files 4% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictInt, StrictStr, constr
 
 
 class SEASONENTITYPlacingsPutBody(BaseModel):
     """
@@ -35,14 +34,16 @@
     entity_id: Optional[StrictStr] = Field(None, alias="entityId", description="The unique identifier of the entity")
     result_place: Optional[StrictInt] = Field(None, alias="resultPlace", description="Result place")
     points: Optional[StrictInt] = Field(None, description="Points awarded")
     prize_money: Optional[StrictInt] = Field(None, alias="prizeMoney", description="Prize money awarded")
     __properties = ["organizationId", "seasonId", "entityId", "resultPlace", "points", "prizeMoney"]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -72,15 +73,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> SEASONENTITYPlacingsPutBody:
         """Create an instance of SEASONENTITYPlacingsPutBody from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return SEASONENTITYPlacingsPutBody.parse_obj(obj)
 
         _obj = SEASONENTITYPlacingsPutBody.parse_obj(
             {
                 "organization_id": obj.get("organizationId"),
                 "season_id": obj.get("seasonId"),
                 "entity_id": obj.get("entityId"),
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/seasonperson_placings_post_body.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/seasonperson_placings_post_body.py`

 * *Files 2% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictInt, StrictStr, constr
 
 
 class SEASONPERSONPlacingsPostBody(BaseModel):
     """
@@ -38,14 +37,16 @@
     person_id: StrictStr = Field(..., alias="personId", description="The unique identifier of the person")
     result_place: Optional[StrictInt] = Field(None, alias="resultPlace", description="Result place")
     points: Optional[StrictInt] = Field(None, description="Points awarded")
     prize_money: Optional[StrictInt] = Field(None, alias="prizeMoney", description="Prize money awarded")
     __properties = ["placingId", "organizationId", "seasonId", "personId", "resultPlace", "points", "prizeMoney"]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -75,15 +76,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> SEASONPERSONPlacingsPostBody:
         """Create an instance of SEASONPERSONPlacingsPostBody from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return SEASONPERSONPlacingsPostBody.parse_obj(obj)
 
         _obj = SEASONPERSONPlacingsPostBody.parse_obj(
             {
                 "placing_id": obj.get("placingId"),
                 "organization_id": obj.get("organizationId"),
                 "season_id": obj.get("seasonId"),
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/seasonperson_placings_put_body.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/seasonperson_placings_put_body.py`

 * *Files 2% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictInt, StrictStr, constr
 
 
 class SEASONPERSONPlacingsPutBody(BaseModel):
     """
@@ -35,14 +34,16 @@
     person_id: Optional[StrictStr] = Field(None, alias="personId", description="The unique identifier of the person")
     result_place: Optional[StrictInt] = Field(None, alias="resultPlace", description="Result place")
     points: Optional[StrictInt] = Field(None, description="Points awarded")
     prize_money: Optional[StrictInt] = Field(None, alias="prizeMoney", description="Prize money awarded")
     __properties = ["organizationId", "seasonId", "personId", "resultPlace", "points", "prizeMoney"]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -72,15 +73,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> SEASONPERSONPlacingsPutBody:
         """Create an instance of SEASONPERSONPlacingsPutBody from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return SEASONPERSONPlacingsPutBody.parse_obj(obj)
 
         _obj = SEASONPERSONPlacingsPutBody.parse_obj(
             {
                 "organization_id": obj.get("organizationId"),
                 "season_id": obj.get("seasonId"),
                 "person_id": obj.get("personId"),
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/seasonroster_configuration.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/seasonroster_configuration.py`

 * *Files 3% similar despite different names*

```diff
@@ -14,15 +14,14 @@
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
 from datetime import date
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictBool
 
 
 class SEASONROSTERConfiguration(BaseModel):
     """
@@ -46,14 +45,16 @@
         None,
         alias="fixtureRosterLock",
         description="Make FIXTURE ROSTERS un-editable when FIXTURE Status is set to Scheduled",
     )
     __properties = ["windowOpenDate", "windowCloseDate", "seasonRosterLock", "fixtureRosterLock"]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -93,15 +94,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> SEASONROSTERConfiguration:
         """Create an instance of SEASONROSTERConfiguration from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return SEASONROSTERConfiguration.parse_obj(obj)
 
         _obj = SEASONROSTERConfiguration.parse_obj(
             {
                 "window_open_date": obj.get("windowOpenDate"),
                 "window_close_date": obj.get("windowCloseDate"),
                 "season_roster_lock": obj.get("seasonRosterLock"),
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/seasons_model.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/seasons_model.py`

 * *Files 4% similar despite different names*

```diff
@@ -14,15 +14,14 @@
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
 from datetime import date, datetime
-from inspect import getfullargspec
 from typing import Any, Dict, List, Optional
 
 from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr, conint, conlist, constr, validator
 
 from atriumsports.datacore.openapi.models.images_model import ImagesModel
 from atriumsports.datacore.openapi.models.seasonroster_configuration import SEASONROSTERConfiguration
 from atriumsports.datacore.openapi.models.seasons_model_competition import SeasonsModelCompetition
@@ -190,50 +189,60 @@
         "added",
         "images",
         "videoProduction",
         "rosterConfiguration",
     ]
 
     @validator("event_type")
-    def event_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("FIXTURE", "PRACTICE"):
+    def event_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("FIXTURE", "PRACTICE"):
             raise ValueError("must be one of enum values ('FIXTURE', 'PRACTICE')")
-        return v
+        return value
 
     @validator("season_type")
-    def season_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("SEASON", "TOURNAMENT", "ONE_OFF"):
+    def season_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("SEASON", "TOURNAMENT", "ONE_OFF"):
             raise ValueError("must be one of enum values ('SEASON', 'TOURNAMENT', 'ONE_OFF')")
-        return v
+        return value
 
     @validator("status")
-    def status_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("ACTIVE", "INACTIVE", "PENDING"):
+    def status_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("ACTIVE", "INACTIVE", "PENDING"):
             raise ValueError("must be one of enum values ('ACTIVE', 'INACTIVE', 'PENDING')")
-        return v
+        return value
 
     @validator("gender")
-    def gender_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("FEMALE", "MALE", "MIXED", "UNKNOWN"):
+    def gender_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("FEMALE", "MALE", "MIXED", "UNKNOWN"):
             raise ValueError("must be one of enum values ('FEMALE', 'MALE', 'MIXED', 'UNKNOWN')")
-        return v
+        return value
 
     @validator("age_group")
-    def age_group_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in (
+    def age_group_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in (
             "JUNIOR",
             "YOUTH",
             "UNDER_15",
             "UNDER_16",
             "UNDER_17",
             "UNDER_18",
             "UNDER_19",
@@ -243,21 +252,23 @@
             "UNDER_23",
             "SENIOR",
             "MASTERS",
         ):
             raise ValueError(
                 "must be one of enum values ('JUNIOR', 'YOUTH', 'UNDER_15', 'UNDER_16', 'UNDER_17', 'UNDER_18', 'UNDER_19', 'UNDER_20', 'UNDER_21', 'UNDER_22', 'UNDER_23', 'SENIOR', 'MASTERS')"
             )
-        return v
+        return value
 
     @validator("standard")
-    def standard_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in (
+    def standard_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in (
             "ELITE",
             "FRIENDLY",
             "GRASS_ROOT",
             "INTERNATIONAL",
             "NONCONTINENTAL_CHAMPIONSHIP",
             "OLYMPIC",
             "REGION",
@@ -265,41 +276,49 @@
             "TIER3",
             "WORLD_CHAMPIONSHIP",
             "ZONE_CHAMPIONSHIP",
         ):
             raise ValueError(
                 "must be one of enum values ('ELITE', 'FRIENDLY', 'GRASS_ROOT', 'INTERNATIONAL', 'NONCONTINENTAL_CHAMPIONSHIP', 'OLYMPIC', 'REGION', 'TIER2', 'TIER3', 'WORLD_CHAMPIONSHIP', 'ZONE_CHAMPIONSHIP')"
             )
-        return v
+        return value
 
     @validator("representation")
-    def representation_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("CLUB", "STATE", "REGION", "COUNTRY", "PERSON"):
+    def representation_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("CLUB", "STATE", "REGION", "COUNTRY", "PERSON"):
             raise ValueError("must be one of enum values ('CLUB', 'STATE', 'REGION', 'COUNTRY', 'PERSON')")
-        return v
+        return value
 
     @validator("external_id")
-    def external_id_validate_regular_expression(cls, v):
-        if v is None:
-            return v
-        if not re.match(r"^[0-9A-Za-z\/_-]+$", v):
+    def external_id_validate_regular_expression(cls, value):
+        """Validates the regular expression"""
+        if value is None:
+            return value
+
+        if not re.match(r"^[0-9A-Za-z\/_-]+$", value):
             raise ValueError(r"must validate the regular expression /^[0-9A-Za-z\/_-]+$/")
-        return v
+        return value
 
     @validator("video_production")
-    def video_production_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("NONE", "AUTOMATED", "MANUAL"):
+    def video_production_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("NONE", "AUTOMATED", "MANUAL"):
             raise ValueError("must be one of enum values ('NONE', 'AUTOMATED', 'MANUAL')")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -422,15 +441,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> SeasonsModel:
         """Create an instance of SeasonsModel from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return SeasonsModel.parse_obj(obj)
 
         _obj = SeasonsModel.parse_obj(
             {
                 "season_id": obj.get("seasonId"),
                 "organization_id": obj.get("organizationId"),
                 "organization": SeasonsModelOrganization.from_dict(obj.get("organization"))
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/seasons_model_competition.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/images_model_organization.py`

 * *Files 17% similar despite different names*

```diff
@@ -13,63 +13,66 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr, validator
 
 
-class SeasonsModelCompetition(BaseModel):
+class ImagesModelOrganization(BaseModel):
     """
-    The competition that this season belongs to
+    The organization that this images belongs to
     """
 
     resource_type: Optional[StrictStr] = Field(None, alias="resourceType")
     id: Optional[StrictStr] = Field(None, description="Unique identifier for this resource")
     __properties = ["resourceType", "id"]
 
     @validator("resource_type")
-    def resource_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("competitions"):
-            raise ValueError("must be one of enum values ('competitions')")
-        return v
+    def resource_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("organizations"):
+            raise ValueError("must be one of enum values ('organizations')")
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> SeasonsModelCompetition:
-        """Create an instance of SeasonsModelCompetition from a JSON string"""
+    def from_json(cls, json_str: str) -> ImagesModelOrganization:
+        """Create an instance of ImagesModelOrganization from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
     def to_dict(self):
         """Returns the dictionary representation of the model using alias"""
         _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> SeasonsModelCompetition:
-        """Create an instance of SeasonsModelCompetition from a dict"""
+    def from_dict(cls, obj: dict) -> ImagesModelOrganization:
+        """Create an instance of ImagesModelOrganization from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
-            return SeasonsModelCompetition.parse_obj(obj)
+        if not isinstance(obj, dict):
+            return ImagesModelOrganization.parse_obj(obj)
 
-        _obj = SeasonsModelCompetition.parse_obj({"resource_type": obj.get("resourceType"), "id": obj.get("id")})
+        _obj = ImagesModelOrganization.parse_obj({"resource_type": obj.get("resourceType"), "id": obj.get("id")})
         return _obj
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/seasons_model_fixture_profile.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_fixture_stages_pools_list_model_pool.py`

 * *Files 24% similar despite different names*

```diff
@@ -13,63 +13,68 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr, validator
 
 
-class SeasonsModelFixtureProfile(BaseModel):
+class SeasonFixtureStagesPoolsListModelPool(BaseModel):
     """
-    The profile that this season belongs to
+    The pool that is related to this record
     """
 
     resource_type: Optional[StrictStr] = Field(None, alias="resourceType")
     id: Optional[StrictStr] = Field(None, description="Unique identifier for this resource")
     __properties = ["resourceType", "id"]
 
     @validator("resource_type")
-    def resource_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("fixture_profiles"):
-            raise ValueError("must be one of enum values ('fixture_profiles')")
-        return v
+    def resource_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("season_pools"):
+            raise ValueError("must be one of enum values ('season_pools')")
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> SeasonsModelFixtureProfile:
-        """Create an instance of SeasonsModelFixtureProfile from a JSON string"""
+    def from_json(cls, json_str: str) -> SeasonFixtureStagesPoolsListModelPool:
+        """Create an instance of SeasonFixtureStagesPoolsListModelPool from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
     def to_dict(self):
         """Returns the dictionary representation of the model using alias"""
         _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> SeasonsModelFixtureProfile:
-        """Create an instance of SeasonsModelFixtureProfile from a dict"""
+    def from_dict(cls, obj: dict) -> SeasonFixtureStagesPoolsListModelPool:
+        """Create an instance of SeasonFixtureStagesPoolsListModelPool from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
-            return SeasonsModelFixtureProfile.parse_obj(obj)
+        if not isinstance(obj, dict):
+            return SeasonFixtureStagesPoolsListModelPool.parse_obj(obj)
 
-        _obj = SeasonsModelFixtureProfile.parse_obj({"resource_type": obj.get("resourceType"), "id": obj.get("id")})
+        _obj = SeasonFixtureStagesPoolsListModelPool.parse_obj(
+            {"resource_type": obj.get("resourceType"), "id": obj.get("id")}
+        )
         return _obj
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/seasons_model_organization.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/seasons_model_organization.py`

 * *Files 14% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr, validator
 
 
 class SeasonsModelOrganization(BaseModel):
     """
@@ -29,22 +28,26 @@
     """
 
     resource_type: Optional[StrictStr] = Field(None, alias="resourceType")
     id: Optional[StrictStr] = Field(None, description="Unique identifier for this resource")
     __properties = ["resourceType", "id"]
 
     @validator("resource_type")
-    def resource_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("organizations"):
+    def resource_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("organizations"):
             raise ValueError("must be one of enum values ('organizations')")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -64,12 +67,12 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> SeasonsModelOrganization:
         """Create an instance of SeasonsModelOrganization from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return SeasonsModelOrganization.parse_obj(obj)
 
         _obj = SeasonsModelOrganization.parse_obj({"resource_type": obj.get("resourceType"), "id": obj.get("id")})
         return _obj
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/seasons_model_standing_configuration.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/seasons_model_standing_configuration.py`

 * *Files 6% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr, validator
 
 
 class SeasonsModelStandingConfiguration(BaseModel):
     """
@@ -29,22 +28,26 @@
     """
 
     resource_type: Optional[StrictStr] = Field(None, alias="resourceType")
     id: Optional[StrictStr] = Field(None, description="Unique identifier for this resource")
     __properties = ["resourceType", "id"]
 
     @validator("resource_type")
-    def resource_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("standing_configurations"):
+    def resource_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("standing_configurations"):
             raise ValueError("must be one of enum values ('standing_configurations')")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -64,14 +67,14 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> SeasonsModelStandingConfiguration:
         """Create an instance of SeasonsModelStandingConfiguration from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return SeasonsModelStandingConfiguration.parse_obj(obj)
 
         _obj = SeasonsModelStandingConfiguration.parse_obj(
             {"resource_type": obj.get("resourceType"), "id": obj.get("id")}
         )
         return _obj
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/seasons_response.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/seasons_response.py`

 * *Files 2% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import List, Optional
 
 from pydantic import BaseModel, conlist
 
 from atriumsports.datacore.openapi.models.included_data import IncludedData
 from atriumsports.datacore.openapi.models.response_links import ResponseLinks
 from atriumsports.datacore.openapi.models.response_meta_data import ResponseMetaData
@@ -36,14 +35,16 @@
     meta: Optional[ResponseMetaData] = None
     links: Optional[ResponseLinks] = None
     included: Optional[IncludedData] = None
     data: Optional[conlist(SeasonsModel)] = None
     __properties = ["meta", "links", "included", "data"]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -79,15 +80,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> SeasonsResponse:
         """Create an instance of SeasonsResponse from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return SeasonsResponse.parse_obj(obj)
 
         _obj = SeasonsResponse.parse_obj(
             {
                 "meta": ResponseMetaData.from_dict(obj.get("meta")) if obj.get("meta") is not None else None,
                 "links": ResponseLinks.from_dict(obj.get("links")) if obj.get("links") is not None else None,
                 "included": IncludedData.from_dict(obj.get("included")) if obj.get("included") is not None else None,
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/series_post_body.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/series_put_body.py`

 * *Files 10% similar despite different names*

```diff
@@ -14,39 +14,34 @@
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
 from datetime import date
-from inspect import getfullargspec
 from typing import List, Optional
 
-from pydantic import BaseModel, Field, StrictInt, StrictStr, conint, conlist, constr, validator
+from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr, conint, conlist, constr, validator
 
 from atriumsports.datacore.openapi.models.season_series_competitor import SeasonSeriesCompetitor
 
 
-class SeriesPostBody(BaseModel):
+class SeriesPutBody(BaseModel):
     """
-    SeriesPostBody
+    SeriesPutBody
     """
 
-    series_code: constr(strict=True, max_length=30) = Field(
-        ..., alias="seriesCode", description="A unique code for the season series. (Unique for season)"
-    )
-    season_id: StrictStr = Field(..., alias="seasonId", description="The unique identifier of the season")
     conference_id: Optional[StrictStr] = Field(
         None, alias="conferenceId", description="The unique identifier of the conference"
     )
     division_id: Optional[StrictStr] = Field(
         None, alias="divisionId", description="The unique identifier of the division"
     )
-    name_local: constr(strict=True, max_length=150) = Field(
-        ...,
+    name_local: Optional[constr(strict=True, max_length=150)] = Field(
+        None,
         alias="nameLocal",
         description="The name of the series in the [local](#section/Introduction/Character-Sets-and-Names) language",
     )
     abbreviation_local: Optional[constr(strict=True, max_length=50)] = Field(
         None,
         alias="abbreviationLocal",
         description="An abbreviation/short name in the [local](#section/Introduction/Character-Sets-and-Names) language",
@@ -57,96 +52,120 @@
         description="The name of the series in [latin](#section/Introduction/Character-Sets-and-Names) characters",
     )
     abbreviation_latin: Optional[constr(strict=True, max_length=50)] = Field(
         None,
         alias="abbreviationLatin",
         description="An abbreviation/short name in [latin](#section/Introduction/Character-Sets-and-Names) characters",
     )
-    status: constr(strict=True, max_length=30) = Field(
-        ..., description="Status >- `ACTIVE` Active >- `COMPLETE` Complete >- `NOT_STARTED` Not Started "
+    status: Optional[constr(strict=True, max_length=30)] = Field(
+        None, description="Status >- `ACTIVE` Active >- `COMPLETE` Complete >- `NOT_STARTED` Not Started "
     )
-    series_type: constr(strict=True, max_length=50) = Field(
-        ...,
+    series_type: Optional[constr(strict=True, max_length=50)] = Field(
+        None,
         alias="seriesType",
         description="The type of series >- `BEST_OF` Best of >- `HOME_AND_AWAY` Home and Away >- `KNOCKOUT` Knockout ",
     )
+    auto_calculated: Optional[StrictBool] = Field(
+        None, alias="autoCalculated", description="Is the winner auto calculated?"
+    )
     best_of: Optional[conint(strict=True)] = Field(None, alias="bestOf", description="Best of number")
     series_number: Optional[conint(strict=True)] = Field(
         None, alias="seriesNumber", description="User defined series number"
     )
     max_fixtures_number: Optional[StrictInt] = Field(
         None, alias="maxFixturesNumber", description="The maximum number of games within a playoff series"
     )
+    winner: Optional[StrictStr] = Field(None, description="The unique identifier of the winner, person or entity")
     series_order: Optional[conint(strict=True)] = Field(
         None, alias="seriesOrder", description="User defined sort order of the series"
     )
+    stage_code: Optional[constr(strict=True, max_length=30)] = Field(
+        None, alias="stageCode", description="A unique code for the stage. (Unique for season)"
+    )
+    pool_code: Optional[constr(strict=True, max_length=30)] = Field(
+        None, alias="poolCode", description="A unique code for the pool. (Unique for season)"
+    )
     start_date: Optional[date] = Field(None, alias="startDate", description="Series start date")
     end_date: Optional[date] = Field(None, alias="endDate", description="Series end date")
     external_id: Optional[constr(strict=True, max_length=150)] = Field(
         None, alias="externalId", description="The Id of the data as set by the provider of the data"
     )
     competitors: Optional[conlist(SeasonSeriesCompetitor)] = Field(
         None, description="Array of competitors in the series. A competitor may have a results and a ranking"
     )
     __properties = [
-        "seriesCode",
-        "seasonId",
         "conferenceId",
         "divisionId",
         "nameLocal",
         "abbreviationLocal",
         "nameLatin",
         "abbreviationLatin",
         "status",
         "seriesType",
+        "autoCalculated",
         "bestOf",
         "seriesNumber",
         "maxFixturesNumber",
+        "winner",
         "seriesOrder",
+        "stageCode",
+        "poolCode",
         "startDate",
         "endDate",
         "externalId",
         "competitors",
     ]
 
     @validator("status")
-    def status_validate_enum(cls, v):
-        if v not in ("NOT_STARTED", "ACTIVE", "COMPLETE"):
+    def status_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("NOT_STARTED", "ACTIVE", "COMPLETE"):
             raise ValueError("must be one of enum values ('NOT_STARTED', 'ACTIVE', 'COMPLETE')")
-        return v
+        return value
 
     @validator("series_type")
-    def series_type_validate_enum(cls, v):
-        if v not in ("BEST_OF", "HOME_AND_AWAY", "KNOCKOUT"):
+    def series_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("BEST_OF", "HOME_AND_AWAY", "KNOCKOUT"):
             raise ValueError("must be one of enum values ('BEST_OF', 'HOME_AND_AWAY', 'KNOCKOUT')")
-        return v
+        return value
 
     @validator("external_id")
-    def external_id_validate_regular_expression(cls, v):
-        if v is None:
-            return v
-        if not re.match(r"^[0-9A-Za-z\/_-]+$", v):
+    def external_id_validate_regular_expression(cls, value):
+        """Validates the regular expression"""
+        if value is None:
+            return value
+
+        if not re.match(r"^[0-9A-Za-z\/_-]+$", value):
             raise ValueError(r"must validate the regular expression /^[0-9A-Za-z\/_-]+$/")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> SeriesPostBody:
-        """Create an instance of SeriesPostBody from a JSON string"""
+    def from_json(cls, json_str: str) -> SeriesPutBody:
+        """Create an instance of SeriesPutBody from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
     def to_dict(self):
         """Returns the dictionary representation of the model using alias"""
         _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)
         # override the default output from pydantic by calling `to_dict()` of each item in competitors (list)
         _items = []
@@ -191,19 +210,34 @@
             _dict["seriesNumber"] = None
 
         # set to None if max_fixtures_number (nullable) is None
         # and __fields_set__ contains the field
         if self.max_fixtures_number is None and "max_fixtures_number" in self.__fields_set__:
             _dict["maxFixturesNumber"] = None
 
+        # set to None if winner (nullable) is None
+        # and __fields_set__ contains the field
+        if self.winner is None and "winner" in self.__fields_set__:
+            _dict["winner"] = None
+
         # set to None if series_order (nullable) is None
         # and __fields_set__ contains the field
         if self.series_order is None and "series_order" in self.__fields_set__:
             _dict["seriesOrder"] = None
 
+        # set to None if stage_code (nullable) is None
+        # and __fields_set__ contains the field
+        if self.stage_code is None and "stage_code" in self.__fields_set__:
+            _dict["stageCode"] = None
+
+        # set to None if pool_code (nullable) is None
+        # and __fields_set__ contains the field
+        if self.pool_code is None and "pool_code" in self.__fields_set__:
+            _dict["poolCode"] = None
+
         # set to None if start_date (nullable) is None
         # and __fields_set__ contains the field
         if self.start_date is None and "start_date" in self.__fields_set__:
             _dict["startDate"] = None
 
         # set to None if end_date (nullable) is None
         # and __fields_set__ contains the field
@@ -219,38 +253,40 @@
         # and __fields_set__ contains the field
         if self.competitors is None and "competitors" in self.__fields_set__:
             _dict["competitors"] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> SeriesPostBody:
-        """Create an instance of SeriesPostBody from a dict"""
+    def from_dict(cls, obj: dict) -> SeriesPutBody:
+        """Create an instance of SeriesPutBody from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
-            return SeriesPostBody.parse_obj(obj)
+        if not isinstance(obj, dict):
+            return SeriesPutBody.parse_obj(obj)
 
-        _obj = SeriesPostBody.parse_obj(
+        _obj = SeriesPutBody.parse_obj(
             {
-                "series_code": obj.get("seriesCode"),
-                "season_id": obj.get("seasonId"),
                 "conference_id": obj.get("conferenceId"),
                 "division_id": obj.get("divisionId"),
                 "name_local": obj.get("nameLocal"),
                 "abbreviation_local": obj.get("abbreviationLocal"),
                 "name_latin": obj.get("nameLatin"),
                 "abbreviation_latin": obj.get("abbreviationLatin"),
                 "status": obj.get("status"),
                 "series_type": obj.get("seriesType"),
+                "auto_calculated": obj.get("autoCalculated"),
                 "best_of": obj.get("bestOf"),
                 "series_number": obj.get("seriesNumber"),
                 "max_fixtures_number": obj.get("maxFixturesNumber"),
+                "winner": obj.get("winner"),
                 "series_order": obj.get("seriesOrder"),
+                "stage_code": obj.get("stageCode"),
+                "pool_code": obj.get("poolCode"),
                 "start_date": obj.get("startDate"),
                 "end_date": obj.get("endDate"),
                 "external_id": obj.get("externalId"),
                 "competitors": [SeasonSeriesCompetitor.from_dict(_item) for _item in obj.get("competitors")]
                 if obj.get("competitors") is not None
                 else None,
             }
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/series_put_body.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/venue_post_body.py`

 * *Files 19% similar despite different names*

```diff
@@ -13,242 +13,241 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from datetime import date
-from inspect import getfullargspec
 from typing import List, Optional
 
-from pydantic import BaseModel, Field, StrictInt, StrictStr, conint, conlist, constr, validator
+from pydantic import BaseModel, Field, StrictInt, StrictStr, conlist, constr, validator
 
-from atriumsports.datacore.openapi.models.season_series_competitor import SeasonSeriesCompetitor
+from atriumsports.datacore.openapi.models.social_media import SocialMedia
+from atriumsports.datacore.openapi.models.venue_address import VenueAddress
+from atriumsports.datacore.openapi.models.venue_historical_name import VenueHistoricalName
 
 
-class SeriesPutBody(BaseModel):
+class VenuePostBody(BaseModel):
     """
-    SeriesPutBody
+    VenuePostBody
     """
 
-    conference_id: Optional[StrictStr] = Field(
-        None, alias="conferenceId", description="The unique identifier of the conference"
-    )
-    division_id: Optional[StrictStr] = Field(
-        None, alias="divisionId", description="The unique identifier of the division"
-    )
-    name_local: Optional[constr(strict=True, max_length=150)] = Field(
-        None,
-        alias="nameLocal",
-        description="The name of the series in the [local](#section/Introduction/Character-Sets-and-Names) language",
-    )
-    abbreviation_local: Optional[constr(strict=True, max_length=50)] = Field(
+    venue_id: Optional[StrictStr] = Field(None, alias="venueId", description="The unique identifier of the venue")
+    site_id: Optional[StrictStr] = Field(None, alias="siteId", description="The site that this venue belongs to")
+    abbreviation_local: Optional[constr(strict=True, max_length=30)] = Field(
         None,
         alias="abbreviationLocal",
         description="An abbreviation/short name in the [local](#section/Introduction/Character-Sets-and-Names) language",
     )
-    name_latin: Optional[constr(strict=True, max_length=150)] = Field(
-        None,
-        alias="nameLatin",
-        description="The name of the series in [latin](#section/Introduction/Character-Sets-and-Names) characters",
+    name_local: constr(strict=True, max_length=150) = Field(
+        ...,
+        alias="nameLocal",
+        description="The name of the venue in the [local](#section/Introduction/Character-Sets-and-Names) language",
+    )
+    status: Optional[constr(strict=True, max_length=30)] = Field(
+        "ACTIVE", description="Status >- `ACTIVE` Active >- `INACTIVE` Inactive >- `PENDING` Pending "
+    )
+    alternate_name_local: Optional[constr(strict=True, max_length=150)] = Field(
+        None, alias="alternateNameLocal", description="The alternate name of the venue, in Local Language"
     )
-    abbreviation_latin: Optional[constr(strict=True, max_length=50)] = Field(
+    abbreviation_latin: Optional[constr(strict=True, max_length=30)] = Field(
         None,
         alias="abbreviationLatin",
         description="An abbreviation/short name in [latin](#section/Introduction/Character-Sets-and-Names) characters",
     )
-    status: Optional[constr(strict=True, max_length=30)] = Field(
-        None, description="Status >- `ACTIVE` Active >- `COMPLETE` Complete >- `NOT_STARTED` Not Started "
-    )
-    series_type: Optional[constr(strict=True, max_length=50)] = Field(
+    name_latin: Optional[constr(strict=True, max_length=150)] = Field(
         None,
-        alias="seriesType",
-        description="The type of series >- `BEST_OF` Best of >- `HOME_AND_AWAY` Home and Away >- `KNOCKOUT` Knockout ",
+        alias="nameLatin",
+        description="The name of the venue in [latin](#section/Introduction/Character-Sets-and-Names) characters",
     )
-    best_of: Optional[conint(strict=True)] = Field(None, alias="bestOf", description="Best of number")
-    series_number: Optional[conint(strict=True)] = Field(
-        None, alias="seriesNumber", description="User defined series number"
+    alternate_name_latin: Optional[constr(strict=True, max_length=150)] = Field(
+        None, alias="alternateNameLatin", description="The alternate name of the venue, in Latin characters"
     )
-    max_fixtures_number: Optional[StrictInt] = Field(
-        None, alias="maxFixturesNumber", description="The maximum number of games within a playoff series"
+    country_code: Optional[constr(strict=True, max_length=3, min_length=3)] = Field(
+        None,
+        alias="countryCode",
+        description="Country code of the venue. We recommend you use ISO-3166-1:alpha3 (upper case) values where available.",
     )
-    series_order: Optional[conint(strict=True)] = Field(
-        None, alias="seriesOrder", description="User defined sort order of the series"
+    timezone: constr(strict=True, max_length=150) = Field(
+        ...,
+        description="Timezone of the venue.  The name of the zone as defined by the IANA TZ database. https://en.wikipedia.org/wiki/List_of_tz_database_time_zones",
+    )
+    address: Optional[VenueAddress] = None
+    social: Optional[SocialMedia] = None
+    capacity: Optional[StrictInt] = Field(
+        None,
+        description="This is the maximum number of people allowed for the venue in normal use. Certain events/configurations of the venue may cause this capacity to be increased/decreased - this is not reflected in this value.",
+    )
+    historical_names: Optional[conlist(VenueHistoricalName)] = Field(
+        None, alias="historicalNames", description="Array of venue historical names"
     )
-    start_date: Optional[date] = Field(None, alias="startDate", description="Series start date")
-    end_date: Optional[date] = Field(None, alias="endDate", description="Series end date")
     external_id: Optional[constr(strict=True, max_length=150)] = Field(
         None, alias="externalId", description="The Id of the data as set by the provider of the data"
     )
-    competitors: Optional[conlist(SeasonSeriesCompetitor)] = Field(
-        None, description="Array of competitors in the series. A competitor may have a results and a ranking"
-    )
     __properties = [
-        "conferenceId",
-        "divisionId",
-        "nameLocal",
+        "venueId",
+        "siteId",
         "abbreviationLocal",
-        "nameLatin",
-        "abbreviationLatin",
+        "nameLocal",
         "status",
-        "seriesType",
-        "bestOf",
-        "seriesNumber",
-        "maxFixturesNumber",
-        "seriesOrder",
-        "startDate",
-        "endDate",
+        "alternateNameLocal",
+        "abbreviationLatin",
+        "nameLatin",
+        "alternateNameLatin",
+        "countryCode",
+        "timezone",
+        "address",
+        "social",
+        "capacity",
+        "historicalNames",
         "externalId",
-        "competitors",
     ]
 
     @validator("status")
-    def status_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("NOT_STARTED", "ACTIVE", "COMPLETE"):
-            raise ValueError("must be one of enum values ('NOT_STARTED', 'ACTIVE', 'COMPLETE')")
-        return v
-
-    @validator("series_type")
-    def series_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("BEST_OF", "HOME_AND_AWAY", "KNOCKOUT"):
-            raise ValueError("must be one of enum values ('BEST_OF', 'HOME_AND_AWAY', 'KNOCKOUT')")
-        return v
+    def status_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("ACTIVE", "INACTIVE", "PENDING"):
+            raise ValueError("must be one of enum values ('ACTIVE', 'INACTIVE', 'PENDING')")
+        return value
 
     @validator("external_id")
-    def external_id_validate_regular_expression(cls, v):
-        if v is None:
-            return v
-        if not re.match(r"^[0-9A-Za-z\/_-]+$", v):
+    def external_id_validate_regular_expression(cls, value):
+        """Validates the regular expression"""
+        if value is None:
+            return value
+
+        if not re.match(r"^[0-9A-Za-z\/_-]+$", value):
             raise ValueError(r"must validate the regular expression /^[0-9A-Za-z\/_-]+$/")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> SeriesPutBody:
-        """Create an instance of SeriesPutBody from a JSON string"""
+    def from_json(cls, json_str: str) -> VenuePostBody:
+        """Create an instance of VenuePostBody from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
     def to_dict(self):
         """Returns the dictionary representation of the model using alias"""
         _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)
-        # override the default output from pydantic by calling `to_dict()` of each item in competitors (list)
+        # override the default output from pydantic by calling `to_dict()` of address
+        if self.address:
+            _dict["address"] = self.address.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of social
+        if self.social:
+            _dict["social"] = self.social.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of each item in historical_names (list)
         _items = []
-        if self.competitors:
-            for _item in self.competitors:
+        if self.historical_names:
+            for _item in self.historical_names:
                 if _item:
                     _items.append(_item.to_dict())
-            _dict["competitors"] = _items
-        # set to None if conference_id (nullable) is None
-        # and __fields_set__ contains the field
-        if self.conference_id is None and "conference_id" in self.__fields_set__:
-            _dict["conferenceId"] = None
-
-        # set to None if division_id (nullable) is None
+            _dict["historicalNames"] = _items
+        # set to None if site_id (nullable) is None
         # and __fields_set__ contains the field
-        if self.division_id is None and "division_id" in self.__fields_set__:
-            _dict["divisionId"] = None
+        if self.site_id is None and "site_id" in self.__fields_set__:
+            _dict["siteId"] = None
 
         # set to None if abbreviation_local (nullable) is None
         # and __fields_set__ contains the field
         if self.abbreviation_local is None and "abbreviation_local" in self.__fields_set__:
             _dict["abbreviationLocal"] = None
 
-        # set to None if name_latin (nullable) is None
+        # set to None if alternate_name_local (nullable) is None
         # and __fields_set__ contains the field
-        if self.name_latin is None and "name_latin" in self.__fields_set__:
-            _dict["nameLatin"] = None
+        if self.alternate_name_local is None and "alternate_name_local" in self.__fields_set__:
+            _dict["alternateNameLocal"] = None
 
         # set to None if abbreviation_latin (nullable) is None
         # and __fields_set__ contains the field
         if self.abbreviation_latin is None and "abbreviation_latin" in self.__fields_set__:
             _dict["abbreviationLatin"] = None
 
-        # set to None if best_of (nullable) is None
+        # set to None if name_latin (nullable) is None
         # and __fields_set__ contains the field
-        if self.best_of is None and "best_of" in self.__fields_set__:
-            _dict["bestOf"] = None
+        if self.name_latin is None and "name_latin" in self.__fields_set__:
+            _dict["nameLatin"] = None
+
+        # set to None if alternate_name_latin (nullable) is None
+        # and __fields_set__ contains the field
+        if self.alternate_name_latin is None and "alternate_name_latin" in self.__fields_set__:
+            _dict["alternateNameLatin"] = None
 
-        # set to None if series_number (nullable) is None
+        # set to None if country_code (nullable) is None
         # and __fields_set__ contains the field
-        if self.series_number is None and "series_number" in self.__fields_set__:
-            _dict["seriesNumber"] = None
+        if self.country_code is None and "country_code" in self.__fields_set__:
+            _dict["countryCode"] = None
 
-        # set to None if max_fixtures_number (nullable) is None
+        # set to None if address (nullable) is None
         # and __fields_set__ contains the field
-        if self.max_fixtures_number is None and "max_fixtures_number" in self.__fields_set__:
-            _dict["maxFixturesNumber"] = None
+        if self.address is None and "address" in self.__fields_set__:
+            _dict["address"] = None
 
-        # set to None if series_order (nullable) is None
+        # set to None if social (nullable) is None
         # and __fields_set__ contains the field
-        if self.series_order is None and "series_order" in self.__fields_set__:
-            _dict["seriesOrder"] = None
+        if self.social is None and "social" in self.__fields_set__:
+            _dict["social"] = None
 
-        # set to None if start_date (nullable) is None
+        # set to None if capacity (nullable) is None
         # and __fields_set__ contains the field
-        if self.start_date is None and "start_date" in self.__fields_set__:
-            _dict["startDate"] = None
+        if self.capacity is None and "capacity" in self.__fields_set__:
+            _dict["capacity"] = None
 
-        # set to None if end_date (nullable) is None
+        # set to None if historical_names (nullable) is None
         # and __fields_set__ contains the field
-        if self.end_date is None and "end_date" in self.__fields_set__:
-            _dict["endDate"] = None
+        if self.historical_names is None and "historical_names" in self.__fields_set__:
+            _dict["historicalNames"] = None
 
         # set to None if external_id (nullable) is None
         # and __fields_set__ contains the field
         if self.external_id is None and "external_id" in self.__fields_set__:
             _dict["externalId"] = None
 
-        # set to None if competitors (nullable) is None
-        # and __fields_set__ contains the field
-        if self.competitors is None and "competitors" in self.__fields_set__:
-            _dict["competitors"] = None
-
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> SeriesPutBody:
-        """Create an instance of SeriesPutBody from a dict"""
+    def from_dict(cls, obj: dict) -> VenuePostBody:
+        """Create an instance of VenuePostBody from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
-            return SeriesPutBody.parse_obj(obj)
+        if not isinstance(obj, dict):
+            return VenuePostBody.parse_obj(obj)
 
-        _obj = SeriesPutBody.parse_obj(
+        _obj = VenuePostBody.parse_obj(
             {
-                "conference_id": obj.get("conferenceId"),
-                "division_id": obj.get("divisionId"),
-                "name_local": obj.get("nameLocal"),
+                "venue_id": obj.get("venueId"),
+                "site_id": obj.get("siteId"),
                 "abbreviation_local": obj.get("abbreviationLocal"),
-                "name_latin": obj.get("nameLatin"),
+                "name_local": obj.get("nameLocal"),
+                "status": obj.get("status") if obj.get("status") is not None else "ACTIVE",
+                "alternate_name_local": obj.get("alternateNameLocal"),
                 "abbreviation_latin": obj.get("abbreviationLatin"),
-                "status": obj.get("status"),
-                "series_type": obj.get("seriesType"),
-                "best_of": obj.get("bestOf"),
-                "series_number": obj.get("seriesNumber"),
-                "max_fixtures_number": obj.get("maxFixturesNumber"),
-                "series_order": obj.get("seriesOrder"),
-                "start_date": obj.get("startDate"),
-                "end_date": obj.get("endDate"),
-                "external_id": obj.get("externalId"),
-                "competitors": [SeasonSeriesCompetitor.from_dict(_item) for _item in obj.get("competitors")]
-                if obj.get("competitors") is not None
+                "name_latin": obj.get("nameLatin"),
+                "alternate_name_latin": obj.get("alternateNameLatin"),
+                "country_code": obj.get("countryCode"),
+                "timezone": obj.get("timezone"),
+                "address": VenueAddress.from_dict(obj.get("address")) if obj.get("address") is not None else None,
+                "social": SocialMedia.from_dict(obj.get("social")) if obj.get("social") is not None else None,
+                "capacity": obj.get("capacity"),
+                "historical_names": [VenueHistoricalName.from_dict(_item) for _item in obj.get("historicalNames")]
+                if obj.get("historicalNames") is not None
                 else None,
+                "external_id": obj.get("externalId"),
             }
         )
         return _obj
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/site_address.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/site_address.py`

 * *Files 9% similar despite different names*

```diff
@@ -13,18 +13,17 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
-from typing import Optional
+from typing import Optional, Union
 
-from pydantic import BaseModel, Field, StrictFloat, StrictStr, constr
+from pydantic import BaseModel, Field, StrictFloat, StrictInt, StrictStr, constr
 
 
 class SiteAddress(BaseModel):
     """
     Street Address for the site
     """
 
@@ -35,29 +34,31 @@
     state: Optional[StrictStr] = Field(None, description="The state of the address")
     postal_code: Optional[StrictStr] = Field(None, alias="postalCode", description="The postal code for the address")
     country_code: Optional[constr(strict=True, max_length=3, min_length=3)] = Field(
         None,
         alias="countryCode",
         description="ISO Country code of the address.  We recommend you use ISO-3166-1:alpha3 (upper case) values where available.",
     )
-    longitude: Optional[StrictFloat] = None
-    latitude: Optional[StrictFloat] = None
+    longitude: Optional[Union[StrictFloat, StrictInt]] = None
+    latitude: Optional[Union[StrictFloat, StrictInt]] = None
     __properties = [
         "address1",
         "address2",
         "address3",
         "city",
         "state",
         "postalCode",
         "countryCode",
         "longitude",
         "latitude",
     ]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -122,15 +123,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> SiteAddress:
         """Create an instance of SiteAddress from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return SiteAddress.parse_obj(obj)
 
         _obj = SiteAddress.parse_obj(
             {
                 "address1": obj.get("address1"),
                 "address2": obj.get("address2"),
                 "address3": obj.get("address3"),
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/site_post_body.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/site_post_body.py`

 * *Files 2% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr, constr, validator
 
 from atriumsports.datacore.openapi.models.site_address import SiteAddress
 from atriumsports.datacore.openapi.models.social_media import SocialMedia
 
@@ -71,22 +70,26 @@
         "countryCode",
         "address",
         "social",
         "externalId",
     ]
 
     @validator("external_id")
-    def external_id_validate_regular_expression(cls, v):
-        if v is None:
-            return v
-        if not re.match(r"^[0-9A-Za-z\/_-]+$", v):
+    def external_id_validate_regular_expression(cls, value):
+        """Validates the regular expression"""
+        if value is None:
+            return value
+
+        if not re.match(r"^[0-9A-Za-z\/_-]+$", value):
             raise ValueError(r"must validate the regular expression /^[0-9A-Za-z\/_-]+$/")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -147,15 +150,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> SitePostBody:
         """Create an instance of SitePostBody from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return SitePostBody.parse_obj(obj)
 
         _obj = SitePostBody.parse_obj(
             {
                 "site_id": obj.get("siteId"),
                 "abbreviation_local": obj.get("abbreviationLocal"),
                 "name_local": obj.get("nameLocal"),
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/site_put_body.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/site_put_body.py`

 * *Files 2% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, constr, validator
 
 from atriumsports.datacore.openapi.models.site_address import SiteAddress
 from atriumsports.datacore.openapi.models.social_media import SocialMedia
 
@@ -69,22 +68,26 @@
         "countryCode",
         "address",
         "social",
         "externalId",
     ]
 
     @validator("external_id")
-    def external_id_validate_regular_expression(cls, v):
-        if v is None:
-            return v
-        if not re.match(r"^[0-9A-Za-z\/_-]+$", v):
+    def external_id_validate_regular_expression(cls, value):
+        """Validates the regular expression"""
+        if value is None:
+            return value
+
+        if not re.match(r"^[0-9A-Za-z\/_-]+$", value):
             raise ValueError(r"must validate the regular expression /^[0-9A-Za-z\/_-]+$/")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -145,15 +148,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> SitePutBody:
         """Create an instance of SitePutBody from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return SitePutBody.parse_obj(obj)
 
         _obj = SitePutBody.parse_obj(
             {
                 "abbreviation_local": obj.get("abbreviationLocal"),
                 "name_local": obj.get("nameLocal"),
                 "abbreviation_latin": obj.get("abbreviationLatin"),
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/sites_model.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/sites_model.py`

 * *Files 2% similar despite different names*

```diff
@@ -14,15 +14,14 @@
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
 from datetime import datetime
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr, constr, validator
 
 from atriumsports.datacore.openapi.models.site_address import SiteAddress
 from atriumsports.datacore.openapi.models.sites_model_organization import SitesModelOrganization
 from atriumsports.datacore.openapi.models.social_media import SocialMedia
@@ -83,22 +82,26 @@
         "social",
         "externalId",
         "updated",
         "added",
     ]
 
     @validator("external_id")
-    def external_id_validate_regular_expression(cls, v):
-        if v is None:
-            return v
-        if not re.match(r"^[0-9A-Za-z\/_-]+$", v):
+    def external_id_validate_regular_expression(cls, value):
+        """Validates the regular expression"""
+        if value is None:
+            return value
+
+        if not re.match(r"^[0-9A-Za-z\/_-]+$", value):
             raise ValueError(r"must validate the regular expression /^[0-9A-Za-z\/_-]+$/")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -170,15 +173,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> SitesModel:
         """Create an instance of SitesModel from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return SitesModel.parse_obj(obj)
 
         _obj = SitesModel.parse_obj(
             {
                 "site_id": obj.get("siteId"),
                 "organization_id": obj.get("organizationId"),
                 "organization": SitesModelOrganization.from_dict(obj.get("organization"))
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/sites_model_organization.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/sites_model_organization.py`

 * *Files 5% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr, validator
 
 
 class SitesModelOrganization(BaseModel):
     """
@@ -29,22 +28,26 @@
     """
 
     resource_type: Optional[StrictStr] = Field(None, alias="resourceType")
     id: Optional[StrictStr] = Field(None, description="Unique identifier for this resource")
     __properties = ["resourceType", "id"]
 
     @validator("resource_type")
-    def resource_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("organizations"):
+    def resource_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("organizations"):
             raise ValueError("must be one of enum values ('organizations')")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -64,12 +67,12 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> SitesModelOrganization:
         """Create an instance of SitesModelOrganization from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return SitesModelOrganization.parse_obj(obj)
 
         _obj = SitesModelOrganization.parse_obj({"resource_type": obj.get("resourceType"), "id": obj.get("id")})
         return _obj
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/sites_response.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/video_stream_outputs_response.py`

 * *Files 11% similar despite different names*

```diff
@@ -13,51 +13,52 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import List, Optional
 
 from pydantic import BaseModel, conlist
 
 from atriumsports.datacore.openapi.models.included_data import IncludedData
 from atriumsports.datacore.openapi.models.response_links import ResponseLinks
 from atriumsports.datacore.openapi.models.response_meta_data import ResponseMetaData
-from atriumsports.datacore.openapi.models.sites_model import SitesModel
+from atriumsports.datacore.openapi.models.video_stream_outputs_model import VideoStreamOutputsModel
 
 
-class SitesResponse(BaseModel):
+class VideoStreamOutputsResponse(BaseModel):
     """
-    SitesResponse
+    VideoStreamOutputsResponse
     """
 
     meta: Optional[ResponseMetaData] = None
     links: Optional[ResponseLinks] = None
     included: Optional[IncludedData] = None
-    data: Optional[conlist(SitesModel)] = None
+    data: Optional[conlist(VideoStreamOutputsModel)] = None
     __properties = ["meta", "links", "included", "data"]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> SitesResponse:
-        """Create an instance of SitesResponse from a JSON string"""
+    def from_json(cls, json_str: str) -> VideoStreamOutputsResponse:
+        """Create an instance of VideoStreamOutputsResponse from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
     def to_dict(self):
         """Returns the dictionary representation of the model using alias"""
         _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)
         # override the default output from pydantic by calling `to_dict()` of meta
         if self.meta:
@@ -74,26 +75,26 @@
             for _item in self.data:
                 if _item:
                     _items.append(_item.to_dict())
             _dict["data"] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> SitesResponse:
-        """Create an instance of SitesResponse from a dict"""
+    def from_dict(cls, obj: dict) -> VideoStreamOutputsResponse:
+        """Create an instance of VideoStreamOutputsResponse from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
-            return SitesResponse.parse_obj(obj)
+        if not isinstance(obj, dict):
+            return VideoStreamOutputsResponse.parse_obj(obj)
 
-        _obj = SitesResponse.parse_obj(
+        _obj = VideoStreamOutputsResponse.parse_obj(
             {
                 "meta": ResponseMetaData.from_dict(obj.get("meta")) if obj.get("meta") is not None else None,
                 "links": ResponseLinks.from_dict(obj.get("links")) if obj.get("links") is not None else None,
                 "included": IncludedData.from_dict(obj.get("included")) if obj.get("included") is not None else None,
-                "data": [SitesModel.from_dict(_item) for _item in obj.get("data")]
+                "data": [VideoStreamOutputsModel.from_dict(_item) for _item in obj.get("data")]
                 if obj.get("data") is not None
                 else None,
             }
         )
         return _obj
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/social_media.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/social_media.py`

 * *Files 6% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, StrictStr
 
 
 class SocialMedia(BaseModel):
     """
@@ -32,14 +31,16 @@
     facebook: Optional[StrictStr] = None
     twitter: Optional[StrictStr] = None
     wikipedia: Optional[StrictStr] = None
     instagram: Optional[StrictStr] = None
     __properties = ["website", "facebook", "twitter", "wikipedia", "instagram"]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -84,15 +85,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> SocialMedia:
         """Create an instance of SocialMedia from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return SocialMedia.parse_obj(obj)
 
         _obj = SocialMedia.parse_obj(
             {
                 "website": obj.get("website"),
                 "facebook": obj.get("facebook"),
                 "twitter": obj.get("twitter"),
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/sorting.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/sorting.py`

 * *Files 11% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr, validator
 
 
 class Sorting(BaseModel):
     """
@@ -29,22 +28,26 @@
     """
 
     sort_field: Optional[StrictStr] = Field(None, alias="sortField", description="Sort Field")
     sort_direction: Optional[StrictStr] = Field(None, alias="sortDirection", description="Sort direction")
     __properties = ["sortField", "sortDirection"]
 
     @validator("sort_direction")
-    def sort_direction_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("ASC", "DESC"):
+    def sort_direction_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("ASC", "DESC"):
             raise ValueError("must be one of enum values ('ASC', 'DESC')")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -64,12 +67,12 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> Sorting:
         """Create an instance of Sorting from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return Sorting.parse_obj(obj)
 
         _obj = Sorting.parse_obj({"sort_field": obj.get("sortField"), "sort_direction": obj.get("sortDirection")})
         return _obj
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/standing_adjustment_post_body.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/standing_adjustment_post_body.py`

 * *Files 3% similar despite different names*

```diff
@@ -13,18 +13,17 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
-from typing import Optional
+from typing import Optional, Union
 
-from pydantic import BaseModel, Field, StrictBool, StrictFloat, StrictStr, constr, validator
+from pydantic import BaseModel, Field, StrictBool, StrictFloat, StrictInt, StrictStr, constr, validator
 
 
 class StandingAdjustmentPostBody(BaseModel):
     """
     StandingAdjustmentPostBody
     """
 
@@ -63,15 +62,17 @@
         ..., alias="adjustmentType", description="Adjustment Type >- `ADD_MINUS` Add/Subtract Value >- `SET` Set Value "
     )
     adjustment_field: StrictStr = Field(
         ...,
         alias="adjustmentField",
         description="Adjustment field to calculate standings >- `byes` Byes >- `draws` Games Drawn >- `drawsAway` Games Drawn (Away) >- `drawsHome` Games Drawn (Home) >- `forfeitsGiven` Forfeits Given >- `forfeitsWonBy` Forfeits Won >- `highestScoreAgainst` Highest Score Against >- `highestScoreAgainstAway` Highest Score Against (Away) >- `highestScoreAgainstHome` Highest Score Against (Home) >- `highestScoreFor` Highest Score For >- `highestScoreForAway` Highest Score For (Away) >- `highestScoreForHome` Highest Score For (Home) >- `losses` Games Lost >- `lossesAway` Games Lost (Away) >- `lossesHome` Games Lost (Home) >- `lowestScoreAgainst` Lowest Score Against >- `lowestScoreAgainstAway` Lowest Score Against (Away) >- `lowestScoreAgainstHome` Lowest Score Against (Home) >- `lowestScoreFor` Lowest Score For >- `lowestScoreForAway` Lowest Score For (Away) >- `lowestScoreForHome` Lowest Score For (Home) >- `percentage` For versus Against Percentage >- `percentageAway` For versus Against Percentage (Away) >- `percentageHome` For versus Against Percentage (Home) >- `played` Games Played >- `playedAway` Games Played (Away) >- `playedHome` Games Played (Home) >- `pointDifference` Point Difference >- `pointDifferenceAway` Point Difference (Away) >- `pointDifferenceHome` Point Difference (Home) >- `position` Standings Position >- `scoredAgainst` Score Against >- `scoredAgainstAway` Score Against (Away) >- `scoredAgainstHome` Score Against (Home) >- `scoredFor` Score For >- `scoredForAway` Score For (Away) >- `scoredForHome` Score For (Home) >- `streak` Winning Streak for competitor >- `streakAway` Winning Streak for competitor (Away) >- `streakHome` Winning Streak for competitor (Home) >- `washouts` Washouts >- `winPercentage` Win Percentage >- `winPercentageAway` Win Percentage (Away) >- `winPercentageHome` Win Percentage (Home) >- `wins` Games Won >- `winsAway` Games Won (Away) >- `winsHome` Games Won (Home) ",
     )
-    adjustment_value: StrictFloat = Field(..., alias="adjustmentValue", description="Value of the adjustment field")
+    adjustment_value: Union[StrictFloat, StrictInt] = Field(
+        ..., alias="adjustmentValue", description="Value of the adjustment field"
+    )
     reason_type: StrictStr = Field(..., alias="reasonType", description="Reason type of the adjustment")
     reason_description: Optional[StrictStr] = Field(
         None, alias="reasonDescription", description="Reason for the adjustment"
     )
     __properties = [
         "standingAdjustmentId",
         "seasonId",
@@ -88,32 +89,36 @@
         "adjustmentField",
         "adjustmentValue",
         "reasonType",
         "reasonDescription",
     ]
 
     @validator("adjustment_group")
-    def adjustment_group_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("OVERALL", "IN_CONFERENCE", "OUT_CONFERENCE", "IN_DIVISION", "OUT_DIVISION"):
+    def adjustment_group_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("OVERALL", "IN_CONFERENCE", "OUT_CONFERENCE", "IN_DIVISION", "OUT_DIVISION"):
             raise ValueError(
                 "must be one of enum values ('OVERALL', 'IN_CONFERENCE', 'OUT_CONFERENCE', 'IN_DIVISION', 'OUT_DIVISION')"
             )
-        return v
+        return value
 
     @validator("adjustment_type")
-    def adjustment_type_validate_enum(cls, v):
-        if v not in ("SET", "ADD_MINUS"):
+    def adjustment_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value not in ("SET", "ADD_MINUS"):
             raise ValueError("must be one of enum values ('SET', 'ADD_MINUS')")
-        return v
+        return value
 
     @validator("adjustment_field")
-    def adjustment_field_validate_enum(cls, v):
-        if v not in (
+    def adjustment_field_validate_enum(cls, value):
+        """Validates the enum"""
+        if value not in (
             "position",
             "played",
             "playedHome",
             "playedAway",
             "wins",
             "winsHome",
             "winsAway",
@@ -157,17 +162,19 @@
             "streak",
             "streakHome",
             "streakAway",
         ):
             raise ValueError(
                 "must be one of enum values ('position', 'played', 'playedHome', 'playedAway', 'wins', 'winsHome', 'winsAway', 'losses', 'lossesHome', 'lossesAway', 'draws', 'drawsHome', 'drawsAway', 'washouts', 'byes', 'forfeitsGiven', 'forfeitsWonBy', 'winPercentage', 'winPercentageHome', 'winPercentageAway', 'scoredFor', 'scoredForHome', 'scoredForAway', 'scoredAgainst', 'scoredAgainstHome', 'scoredAgainstAway', 'percentage', 'percentageHome', 'percentageAway', 'pointDifference', 'pointDifferenceHome', 'pointDifferenceAway', 'lowestScoreFor', 'lowestScoreForHome', 'lowestScoreForAway', 'highestScoreFor', 'highestScoreForHome', 'highestScoreForAway', 'lowestScoreAgainst', 'lowestScoreAgainstHome', 'lowestScoreAgainstAway', 'highestScoreAgainst', 'highestScoreAgainstHome', 'highestScoreAgainstAway', 'streak', 'streakHome', 'streakAway')"
             )
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -222,15 +229,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> StandingAdjustmentPostBody:
         """Create an instance of StandingAdjustmentPostBody from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return StandingAdjustmentPostBody.parse_obj(obj)
 
         _obj = StandingAdjustmentPostBody.parse_obj(
             {
                 "standing_adjustment_id": obj.get("standingAdjustmentId"),
                 "season_id": obj.get("seasonId"),
                 "entity_id": obj.get("entityId"),
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/standing_adjustment_put_body.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/standing_adjustment_put_body.py`

 * *Files 3% similar despite different names*

```diff
@@ -13,18 +13,17 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
-from typing import Optional
+from typing import Optional, Union
 
-from pydantic import BaseModel, Field, StrictBool, StrictFloat, StrictStr, constr, validator
+from pydantic import BaseModel, Field, StrictBool, StrictFloat, StrictInt, StrictStr, constr, validator
 
 
 class StandingAdjustmentPutBody(BaseModel):
     """
     StandingAdjustmentPutBody
     """
 
@@ -62,15 +61,15 @@
         description="Adjustment Type >- `ADD_MINUS` Add/Subtract Value >- `SET` Set Value ",
     )
     adjustment_field: Optional[StrictStr] = Field(
         None,
         alias="adjustmentField",
         description="Adjustment field to calculate standings >- `byes` Byes >- `draws` Games Drawn >- `drawsAway` Games Drawn (Away) >- `drawsHome` Games Drawn (Home) >- `forfeitsGiven` Forfeits Given >- `forfeitsWonBy` Forfeits Won >- `highestScoreAgainst` Highest Score Against >- `highestScoreAgainstAway` Highest Score Against (Away) >- `highestScoreAgainstHome` Highest Score Against (Home) >- `highestScoreFor` Highest Score For >- `highestScoreForAway` Highest Score For (Away) >- `highestScoreForHome` Highest Score For (Home) >- `losses` Games Lost >- `lossesAway` Games Lost (Away) >- `lossesHome` Games Lost (Home) >- `lowestScoreAgainst` Lowest Score Against >- `lowestScoreAgainstAway` Lowest Score Against (Away) >- `lowestScoreAgainstHome` Lowest Score Against (Home) >- `lowestScoreFor` Lowest Score For >- `lowestScoreForAway` Lowest Score For (Away) >- `lowestScoreForHome` Lowest Score For (Home) >- `percentage` For versus Against Percentage >- `percentageAway` For versus Against Percentage (Away) >- `percentageHome` For versus Against Percentage (Home) >- `played` Games Played >- `playedAway` Games Played (Away) >- `playedHome` Games Played (Home) >- `pointDifference` Point Difference >- `pointDifferenceAway` Point Difference (Away) >- `pointDifferenceHome` Point Difference (Home) >- `position` Standings Position >- `scoredAgainst` Score Against >- `scoredAgainstAway` Score Against (Away) >- `scoredAgainstHome` Score Against (Home) >- `scoredFor` Score For >- `scoredForAway` Score For (Away) >- `scoredForHome` Score For (Home) >- `streak` Winning Streak for competitor >- `streakAway` Winning Streak for competitor (Away) >- `streakHome` Winning Streak for competitor (Home) >- `washouts` Washouts >- `winPercentage` Win Percentage >- `winPercentageAway` Win Percentage (Away) >- `winPercentageHome` Win Percentage (Home) >- `wins` Games Won >- `winsAway` Games Won (Away) >- `winsHome` Games Won (Home) ",
     )
-    adjustment_value: Optional[StrictFloat] = Field(
+    adjustment_value: Optional[Union[StrictFloat, StrictInt]] = Field(
         None, alias="adjustmentValue", description="Value of the adjustment field"
     )
     reason_type: Optional[StrictStr] = Field(None, alias="reasonType", description="Reason type of the adjustment")
     reason_description: Optional[StrictStr] = Field(
         None, alias="reasonDescription", description="Reason for the adjustment"
     )
     __properties = [
@@ -88,36 +87,42 @@
         "adjustmentField",
         "adjustmentValue",
         "reasonType",
         "reasonDescription",
     ]
 
     @validator("adjustment_group")
-    def adjustment_group_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("OVERALL", "IN_CONFERENCE", "OUT_CONFERENCE", "IN_DIVISION", "OUT_DIVISION"):
+    def adjustment_group_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("OVERALL", "IN_CONFERENCE", "OUT_CONFERENCE", "IN_DIVISION", "OUT_DIVISION"):
             raise ValueError(
                 "must be one of enum values ('OVERALL', 'IN_CONFERENCE', 'OUT_CONFERENCE', 'IN_DIVISION', 'OUT_DIVISION')"
             )
-        return v
+        return value
 
     @validator("adjustment_type")
-    def adjustment_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("SET", "ADD_MINUS"):
+    def adjustment_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("SET", "ADD_MINUS"):
             raise ValueError("must be one of enum values ('SET', 'ADD_MINUS')")
-        return v
+        return value
 
     @validator("adjustment_field")
-    def adjustment_field_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in (
+    def adjustment_field_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in (
             "position",
             "played",
             "playedHome",
             "playedAway",
             "wins",
             "winsHome",
             "winsAway",
@@ -161,17 +166,19 @@
             "streak",
             "streakHome",
             "streakAway",
         ):
             raise ValueError(
                 "must be one of enum values ('position', 'played', 'playedHome', 'playedAway', 'wins', 'winsHome', 'winsAway', 'losses', 'lossesHome', 'lossesAway', 'draws', 'drawsHome', 'drawsAway', 'washouts', 'byes', 'forfeitsGiven', 'forfeitsWonBy', 'winPercentage', 'winPercentageHome', 'winPercentageAway', 'scoredFor', 'scoredForHome', 'scoredForAway', 'scoredAgainst', 'scoredAgainstHome', 'scoredAgainstAway', 'percentage', 'percentageHome', 'percentageAway', 'pointDifference', 'pointDifferenceHome', 'pointDifferenceAway', 'lowestScoreFor', 'lowestScoreForHome', 'lowestScoreForAway', 'highestScoreFor', 'highestScoreForHome', 'highestScoreForAway', 'lowestScoreAgainst', 'lowestScoreAgainstHome', 'lowestScoreAgainstAway', 'highestScoreAgainst', 'highestScoreAgainstHome', 'highestScoreAgainstAway', 'streak', 'streakHome', 'streakAway')"
             )
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -226,15 +233,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> StandingAdjustmentPutBody:
         """Create an instance of StandingAdjustmentPutBody from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return StandingAdjustmentPutBody.parse_obj(obj)
 
         _obj = StandingAdjustmentPutBody.parse_obj(
             {
                 "season_id": obj.get("seasonId"),
                 "entity_id": obj.get("entityId"),
                 "round_code": obj.get("roundCode"),
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/standing_adjustments_model.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/standing_adjustments_model.py`

 * *Files 2% similar despite different names*

```diff
@@ -14,18 +14,17 @@
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
 from datetime import datetime
-from inspect import getfullargspec
-from typing import Optional
+from typing import Optional, Union
 
-from pydantic import BaseModel, Field, StrictBool, StrictFloat, StrictStr, constr, validator
+from pydantic import BaseModel, Field, StrictBool, StrictFloat, StrictInt, StrictStr, constr, validator
 
 from atriumsports.datacore.openapi.models.fixture_entities_model_conference import FixtureEntitiesModelConference
 from atriumsports.datacore.openapi.models.fixture_entities_model_division import FixtureEntitiesModelDivision
 from atriumsports.datacore.openapi.models.fixture_entities_model_entity import FixtureEntitiesModelEntity
 from atriumsports.datacore.openapi.models.fixture_progressions_model_season import FixtureProgressionsModelSeason
 from atriumsports.datacore.openapi.models.fixtures_model_round import FixturesModelRound
 from atriumsports.datacore.openapi.models.season_fixture_stages_pools_list_model_pool import (
@@ -92,15 +91,15 @@
         description="Adjustment Type >- `ADD_MINUS` Add/Subtract Value >- `SET` Set Value ",
     )
     adjustment_field: Optional[StrictStr] = Field(
         None,
         alias="adjustmentField",
         description="Adjustment field to calculate standings >- `byes` Byes >- `draws` Games Drawn >- `drawsAway` Games Drawn (Away) >- `drawsHome` Games Drawn (Home) >- `forfeitsGiven` Forfeits Given >- `forfeitsWonBy` Forfeits Won >- `highestScoreAgainst` Highest Score Against >- `highestScoreAgainstAway` Highest Score Against (Away) >- `highestScoreAgainstHome` Highest Score Against (Home) >- `highestScoreFor` Highest Score For >- `highestScoreForAway` Highest Score For (Away) >- `highestScoreForHome` Highest Score For (Home) >- `losses` Games Lost >- `lossesAway` Games Lost (Away) >- `lossesHome` Games Lost (Home) >- `lowestScoreAgainst` Lowest Score Against >- `lowestScoreAgainstAway` Lowest Score Against (Away) >- `lowestScoreAgainstHome` Lowest Score Against (Home) >- `lowestScoreFor` Lowest Score For >- `lowestScoreForAway` Lowest Score For (Away) >- `lowestScoreForHome` Lowest Score For (Home) >- `percentage` For versus Against Percentage >- `percentageAway` For versus Against Percentage (Away) >- `percentageHome` For versus Against Percentage (Home) >- `played` Games Played >- `playedAway` Games Played (Away) >- `playedHome` Games Played (Home) >- `pointDifference` Point Difference >- `pointDifferenceAway` Point Difference (Away) >- `pointDifferenceHome` Point Difference (Home) >- `position` Standings Position >- `scoredAgainst` Score Against >- `scoredAgainstAway` Score Against (Away) >- `scoredAgainstHome` Score Against (Home) >- `scoredFor` Score For >- `scoredForAway` Score For (Away) >- `scoredForHome` Score For (Home) >- `streak` Winning Streak for competitor >- `streakAway` Winning Streak for competitor (Away) >- `streakHome` Winning Streak for competitor (Home) >- `washouts` Washouts >- `winPercentage` Win Percentage >- `winPercentageAway` Win Percentage (Away) >- `winPercentageHome` Win Percentage (Home) >- `wins` Games Won >- `winsAway` Games Won (Away) >- `winsHome` Games Won (Home) ",
     )
-    adjustment_value: Optional[StrictFloat] = Field(
+    adjustment_value: Optional[Union[StrictFloat, StrictInt]] = Field(
         None, alias="adjustmentValue", description="Value of the adjustment field"
     )
     reason_type: Optional[StrictStr] = Field(None, alias="reasonType", description="Reason type of the adjustment")
     reason_description: Optional[StrictStr] = Field(
         None, alias="reasonDescription", description="Reason for the adjustment"
     )
     updated: Optional[datetime] = Field(None, description="Date/time last modified. In UTC")
@@ -132,36 +131,42 @@
         "reasonType",
         "reasonDescription",
         "updated",
         "added",
     ]
 
     @validator("adjustment_group")
-    def adjustment_group_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("OVERALL", "IN_CONFERENCE", "OUT_CONFERENCE", "IN_DIVISION", "OUT_DIVISION"):
+    def adjustment_group_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("OVERALL", "IN_CONFERENCE", "OUT_CONFERENCE", "IN_DIVISION", "OUT_DIVISION"):
             raise ValueError(
                 "must be one of enum values ('OVERALL', 'IN_CONFERENCE', 'OUT_CONFERENCE', 'IN_DIVISION', 'OUT_DIVISION')"
             )
-        return v
+        return value
 
     @validator("adjustment_type")
-    def adjustment_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("SET", "ADD_MINUS"):
+    def adjustment_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("SET", "ADD_MINUS"):
             raise ValueError("must be one of enum values ('SET', 'ADD_MINUS')")
-        return v
+        return value
 
     @validator("adjustment_field")
-    def adjustment_field_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in (
+    def adjustment_field_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in (
             "position",
             "played",
             "playedHome",
             "playedAway",
             "wins",
             "winsHome",
             "winsAway",
@@ -205,17 +210,19 @@
             "streak",
             "streakHome",
             "streakAway",
         ):
             raise ValueError(
                 "must be one of enum values ('position', 'played', 'playedHome', 'playedAway', 'wins', 'winsHome', 'winsAway', 'losses', 'lossesHome', 'lossesAway', 'draws', 'drawsHome', 'drawsAway', 'washouts', 'byes', 'forfeitsGiven', 'forfeitsWonBy', 'winPercentage', 'winPercentageHome', 'winPercentageAway', 'scoredFor', 'scoredForHome', 'scoredForAway', 'scoredAgainst', 'scoredAgainstHome', 'scoredAgainstAway', 'percentage', 'percentageHome', 'percentageAway', 'pointDifference', 'pointDifferenceHome', 'pointDifferenceAway', 'lowestScoreFor', 'lowestScoreForHome', 'lowestScoreForAway', 'highestScoreFor', 'highestScoreForHome', 'highestScoreForAway', 'lowestScoreAgainst', 'lowestScoreAgainstHome', 'lowestScoreAgainstAway', 'highestScoreAgainst', 'highestScoreAgainstHome', 'highestScoreAgainstAway', 'streak', 'streakHome', 'streakAway')"
             )
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -302,15 +309,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> StandingAdjustmentsModel:
         """Create an instance of StandingAdjustmentsModel from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return StandingAdjustmentsModel.parse_obj(obj)
 
         _obj = StandingAdjustmentsModel.parse_obj(
             {
                 "standing_adjustment_id": obj.get("standingAdjustmentId"),
                 "season_id": obj.get("seasonId"),
                 "season": FixtureProgressionsModelSeason.from_dict(obj.get("season"))
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/standing_adjustments_model_organization.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/venues_model_site.py`

 * *Files 19% similar despite different names*

```diff
@@ -13,65 +13,66 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr, validator
 
 
-class StandingAdjustmentsModelOrganization(BaseModel):
+class VenuesModelSite(BaseModel):
     """
-    The organization that this ~standing_adjustment~ belongs to
+    The site that this venue belongs to
     """
 
     resource_type: Optional[StrictStr] = Field(None, alias="resourceType")
     id: Optional[StrictStr] = Field(None, description="Unique identifier for this resource")
     __properties = ["resourceType", "id"]
 
     @validator("resource_type")
-    def resource_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("organizations"):
-            raise ValueError("must be one of enum values ('organizations')")
-        return v
+    def resource_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("sites"):
+            raise ValueError("must be one of enum values ('sites')")
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> StandingAdjustmentsModelOrganization:
-        """Create an instance of StandingAdjustmentsModelOrganization from a JSON string"""
+    def from_json(cls, json_str: str) -> VenuesModelSite:
+        """Create an instance of VenuesModelSite from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
     def to_dict(self):
         """Returns the dictionary representation of the model using alias"""
         _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> StandingAdjustmentsModelOrganization:
-        """Create an instance of StandingAdjustmentsModelOrganization from a dict"""
+    def from_dict(cls, obj: dict) -> VenuesModelSite:
+        """Create an instance of VenuesModelSite from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
-            return StandingAdjustmentsModelOrganization.parse_obj(obj)
+        if not isinstance(obj, dict):
+            return VenuesModelSite.parse_obj(obj)
 
-        _obj = StandingAdjustmentsModelOrganization.parse_obj(
-            {"resource_type": obj.get("resourceType"), "id": obj.get("id")}
-        )
+        _obj = VenuesModelSite.parse_obj({"resource_type": obj.get("resourceType"), "id": obj.get("id")})
         return _obj
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/standing_adjustments_response.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/standing_adjustments_response.py`

 * *Files 2% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import List, Optional
 
 from pydantic import BaseModel, conlist
 
 from atriumsports.datacore.openapi.models.included_data import IncludedData
 from atriumsports.datacore.openapi.models.response_links import ResponseLinks
 from atriumsports.datacore.openapi.models.response_meta_data import ResponseMetaData
@@ -36,14 +35,16 @@
     meta: Optional[ResponseMetaData] = None
     links: Optional[ResponseLinks] = None
     included: Optional[IncludedData] = None
     data: Optional[conlist(StandingAdjustmentsModel)] = None
     __properties = ["meta", "links", "included", "data"]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -79,15 +80,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> StandingAdjustmentsResponse:
         """Create an instance of StandingAdjustmentsResponse from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return StandingAdjustmentsResponse.parse_obj(obj)
 
         _obj = StandingAdjustmentsResponse.parse_obj(
             {
                 "meta": ResponseMetaData.from_dict(obj.get("meta")) if obj.get("meta") is not None else None,
                 "links": ResponseLinks.from_dict(obj.get("links")) if obj.get("links") is not None else None,
                 "included": IncludedData.from_dict(obj.get("included")) if obj.get("included") is not None else None,
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/standing_building.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/standing_building.py`

 * *Files 9% similar despite different names*

```diff
@@ -13,18 +13,17 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
-from typing import List, Optional
+from typing import List, Optional, Union
 
-from pydantic import BaseModel, Field, StrictBool, StrictFloat, StrictStr, conlist, validator
+from pydantic import BaseModel, Field, StrictBool, StrictFloat, StrictInt, StrictStr, conlist, validator
 
 
 class StandingBuilding(BaseModel):
     """
     Suilding definitions
     """
 
@@ -45,15 +44,15 @@
     include_live_fixtures: Optional[StrictBool] = Field(
         None, alias="includeLiveFixtures", description="Include live fixtures"
     )
     generate_live_standings: Optional[StrictBool] = Field(
         None, alias="generateLiveStandings", description="Generate only live fixtures"
     )
     fixture_types: conlist(StrictStr) = Field(..., alias="fixtureTypes")
-    decimal_places: Optional[StrictFloat] = Field(
+    decimal_places: Optional[Union[StrictFloat, StrictInt]] = Field(
         4, alias="decimalPlaces", description="Number of decimal places for percentage calculations"
     )
     __properties = [
         "buildType",
         "buildOverall",
         "buildConferences",
         "buildDivisions",
@@ -62,35 +61,40 @@
         "includeLiveFixtures",
         "generateLiveStandings",
         "fixtureTypes",
         "decimalPlaces",
     ]
 
     @validator("build_type")
-    def build_type_validate_enum(cls, v):
-        if v not in ("ROUND", "OVERALL"):
+    def build_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value not in ("ROUND", "OVERALL"):
             raise ValueError("must be one of enum values ('ROUND', 'OVERALL')")
-        return v
+        return value
 
     @validator("grouping")
-    def grouping_validate_enum(cls, v):
-        if v not in ("STAGE", "STAGEPOOL", "NONE"):
+    def grouping_validate_enum(cls, value):
+        """Validates the enum"""
+        if value not in ("STAGE", "STAGEPOOL", "NONE"):
             raise ValueError("must be one of enum values ('STAGE', 'STAGEPOOL', 'NONE')")
-        return v
+        return value
 
     @validator("fixture_types")
-    def fixture_types_validate_enum(cls, v):
-        for i in v:
+    def fixture_types_validate_enum(cls, value):
+        """Validates the enum"""
+        for i in value:
             if i not in ("ALL_STAR", "PRESEASON", "REGULAR", "FINAL", "PLAYOFF", "FRIENDLY", "DEMONSTRATION"):
                 raise ValueError(
                     "each list item must be one of ('ALL_STAR', 'PRESEASON', 'REGULAR', 'FINAL', 'PLAYOFF', 'FRIENDLY', 'DEMONSTRATION')"
                 )
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -110,15 +114,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> StandingBuilding:
         """Create an instance of StandingBuilding from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return StandingBuilding.parse_obj(obj)
 
         _obj = StandingBuilding.parse_obj(
             {
                 "build_type": obj.get("buildType"),
                 "build_overall": obj.get("buildOverall"),
                 "build_conferences": obj.get("buildConferences"),
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/standing_configuration.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/standing_configuration.py`

 * *Files 6% similar despite different names*

```diff
@@ -13,18 +13,17 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
-from typing import List, Optional
+from typing import List, Optional, Union
 
-from pydantic import BaseModel, Field, StrictBool, StrictFloat, StrictStr, conlist, validator
+from pydantic import BaseModel, Field, StrictBool, StrictFloat, StrictInt, StrictStr, conlist, validator
 
 from atriumsports.datacore.openapi.models.head_to_head_identification import HeadToHeadIdentification
 from atriumsports.datacore.openapi.models.head_to_head_identification_for_subsequent_checks import (
     HeadToHeadIdentificationForSubsequentChecks,
 )
 from atriumsports.datacore.openapi.models.head_to_head_resolution import HeadToHeadResolution
 from atriumsports.datacore.openapi.models.head_to_head_resolution_for_extra_depth_h2h_s import (
@@ -34,50 +33,54 @@
 
 
 class StandingConfiguration(BaseModel):
     """
     Configuration definitions
     """
 
-    wins_home_points: Optional[StrictFloat] = Field(None, alias="winsHomePoints", description="Points for Home Win")
-    losses_home_points: Optional[StrictFloat] = Field(
+    wins_home_points: Optional[Union[StrictFloat, StrictInt]] = Field(
+        None, alias="winsHomePoints", description="Points for Home Win"
+    )
+    losses_home_points: Optional[Union[StrictFloat, StrictInt]] = Field(
         None, alias="lossesHomePoints", description="Points for Home Loss"
     )
-    draws_home_scored_points: Optional[StrictFloat] = Field(
+    draws_home_scored_points: Optional[Union[StrictFloat, StrictInt]] = Field(
         None, alias="drawsHomeScoredPoints", description="Points for Home Draw where entity scored"
     )
-    draws_home_zero_points: Optional[StrictFloat] = Field(
+    draws_home_zero_points: Optional[Union[StrictFloat, StrictInt]] = Field(
         None, alias="drawsHomeZeroPoints", description="Points for Home Draw with zero score"
     )
-    forfeit_won_by_home_points: Optional[StrictFloat] = Field(
+    forfeit_won_by_home_points: Optional[Union[StrictFloat, StrictInt]] = Field(
         None, alias="forfeitWonByHomePoints", description="Points for won by Forfeit at home"
     )
-    forfeits_won_by_home_points: Optional[StrictFloat] = Field(
+    forfeits_won_by_home_points: Optional[Union[StrictFloat, StrictInt]] = Field(
         None, alias="forfeitsWonByHomePoints", description="Points for won by Forfeit at home"
     )
-    forfeit_given_home_points: Optional[StrictFloat] = Field(
+    forfeit_given_home_points: Optional[Union[StrictFloat, StrictInt]] = Field(
         None, alias="forfeitGivenHomePoints", description="Points for giving a forfeit at home"
     )
-    wins_away_points: Optional[StrictFloat] = Field(None, alias="winsAwayPoints", description="Points for Away Win")
-    losses_away_points: Optional[StrictFloat] = Field(
+    wins_away_points: Optional[Union[StrictFloat, StrictInt]] = Field(
+        None, alias="winsAwayPoints", description="Points for Away Win"
+    )
+    losses_away_points: Optional[Union[StrictFloat, StrictInt]] = Field(
         None, alias="lossesAwayPoints", description="Points for Away Loss"
     )
-    draws_away_scored_points: Optional[StrictFloat] = Field(
+    draws_away_scored_points: Optional[Union[StrictFloat, StrictInt]] = Field(
         None, alias="drawsAwayScoredPoints", description="Points for Away Draw where entity scored"
     )
-    draws_away_zero_points: Optional[StrictFloat] = Field(
+    draws_away_zero_points: Optional[Union[StrictFloat, StrictInt]] = Field(
         None, alias="drawsAwayZeroPoints", description="Points for Away Draw with zero score"
     )
-    forfeit_won_by_away_points: Optional[StrictFloat] = Field(
+    forfeit_won_by_away_points: Optional[Union[StrictFloat, StrictInt]] = Field(
         None, alias="forfeitWonByAwayPoints", description="Points for won by Forfeit at away"
     )
-    forfeit_given_away_points: Optional[StrictFloat] = Field(
+    forfeit_given_away_points: Optional[Union[StrictFloat, StrictInt]] = Field(
         None, alias="forfeitGivenAwayPoints", description="Points for giving a forfeit at away"
     )
-    bye_points: Optional[StrictFloat] = Field(None, alias="byePoints", description="Points for bye")
+    bye_points: Optional[Union[StrictFloat, StrictInt]] = Field(None, alias="byePoints", description="Points for bye")
     bye_is_played: Optional[StrictBool] = Field(None, alias="byeIsPlayed", description="Is a Bye added to played ?")
     bye_added_wins: Optional[StrictBool] = Field(None, alias="byeAddedWins", description="Is a Bye added to won count?")
     forfeit_won_by_added_wins: Optional[StrictBool] = Field(
         None, alias="forfeitWonByAddedWins", description="Is a forfeit won by (received) included in won count ?"
     )
     forfeit_won_by_added_played: Optional[StrictBool] = Field(
         None, alias="forfeitWonByAddedPlayed", description="Is a forfeit won by (received) included in played count ?"
@@ -140,22 +143,26 @@
         "headToHeadUseAdjustments",
         "headToHeadSingleRound",
         "headToHeadResolutions",
         "headToHeadResolutionsSubsequent",
     ]
 
     @validator("streak")
-    def streak_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("WON", "NONLOST"):
+    def streak_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("WON", "NONLOST"):
             raise ValueError("must be one of enum values ('WON', 'NONLOST')")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -210,15 +217,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> StandingConfiguration:
         """Create an instance of StandingConfiguration from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return StandingConfiguration.parse_obj(obj)
 
         _obj = StandingConfiguration.parse_obj(
             {
                 "wins_home_points": obj.get("winsHomePoints"),
                 "losses_home_points": obj.get("lossesHomePoints"),
                 "draws_home_scored_points": obj.get("drawsHomeScoredPoints"),
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/standing_configurations_model.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/standing_configurations_model.py`

 * *Files 6% similar despite different names*

```diff
@@ -14,15 +14,14 @@
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
 from datetime import datetime
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr, constr, validator
 
 from atriumsports.datacore.openapi.models.standing_building import StandingBuilding
 from atriumsports.datacore.openapi.models.standing_configuration import StandingConfiguration
 from atriumsports.datacore.openapi.models.standing_configurations_model_organization import (
@@ -69,22 +68,26 @@
         "configuration",
         "externalId",
         "updated",
         "added",
     ]
 
     @validator("external_id")
-    def external_id_validate_regular_expression(cls, v):
-        if v is None:
-            return v
-        if not re.match(r"^[0-9A-Za-z\/_-]+$", v):
+    def external_id_validate_regular_expression(cls, value):
+        """Validates the regular expression"""
+        if value is None:
+            return value
+
+        if not re.match(r"^[0-9A-Za-z\/_-]+$", value):
             raise ValueError(r"must validate the regular expression /^[0-9A-Za-z\/_-]+$/")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -131,15 +134,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> StandingConfigurationsModel:
         """Create an instance of StandingConfigurationsModel from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return StandingConfigurationsModel.parse_obj(obj)
 
         _obj = StandingConfigurationsModel.parse_obj(
             {
                 "standing_configuration_id": obj.get("standingConfigurationId"),
                 "organization_id": obj.get("organizationId"),
                 "organization": StandingConfigurationsModelOrganization.from_dict(obj.get("organization"))
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/standing_configurations_model_organization.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/standing_configurations_model_organization.py`

 * *Files 10% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr, validator
 
 
 class StandingConfigurationsModelOrganization(BaseModel):
     """
@@ -29,22 +28,26 @@
     """
 
     resource_type: Optional[StrictStr] = Field(None, alias="resourceType")
     id: Optional[StrictStr] = Field(None, description="Unique identifier for this resource")
     __properties = ["resourceType", "id"]
 
     @validator("resource_type")
-    def resource_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("organizations"):
+    def resource_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("organizations"):
             raise ValueError("must be one of enum values ('organizations')")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -64,14 +67,14 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> StandingConfigurationsModelOrganization:
         """Create an instance of StandingConfigurationsModelOrganization from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return StandingConfigurationsModelOrganization.parse_obj(obj)
 
         _obj = StandingConfigurationsModelOrganization.parse_obj(
             {"resource_type": obj.get("resourceType"), "id": obj.get("id")}
         )
         return _obj
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/standing_configurations_post_body.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/standing_configurations_post_body.py`

 * *Files 8% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr, constr, validator
 
 from atriumsports.datacore.openapi.models.standing_building import StandingBuilding
 from atriumsports.datacore.openapi.models.standing_configuration import StandingConfiguration
 
@@ -48,22 +47,26 @@
     configuration: Optional[StandingConfiguration] = None
     external_id: Optional[constr(strict=True, max_length=150)] = Field(
         None, alias="externalId", description="The Id of the data as set by the provider of the data"
     )
     __properties = ["standingConfigurationId", "nameLocal", "nameLatin", "buildRules", "configuration", "externalId"]
 
     @validator("external_id")
-    def external_id_validate_regular_expression(cls, v):
-        if v is None:
-            return v
-        if not re.match(r"^[0-9A-Za-z\/_-]+$", v):
+    def external_id_validate_regular_expression(cls, value):
+        """Validates the regular expression"""
+        if value is None:
+            return value
+
+        if not re.match(r"^[0-9A-Za-z\/_-]+$", value):
             raise ValueError(r"must validate the regular expression /^[0-9A-Za-z\/_-]+$/")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -99,15 +102,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> StandingConfigurationsPostBody:
         """Create an instance of StandingConfigurationsPostBody from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return StandingConfigurationsPostBody.parse_obj(obj)
 
         _obj = StandingConfigurationsPostBody.parse_obj(
             {
                 "standing_configuration_id": obj.get("standingConfigurationId"),
                 "name_local": obj.get("nameLocal"),
                 "name_latin": obj.get("nameLatin"),
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/standing_configurations_put_body.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/standing_configurations_put_body.py`

 * *Files 4% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, constr, validator
 
 from atriumsports.datacore.openapi.models.standing_building import StandingBuilding
 from atriumsports.datacore.openapi.models.standing_configuration import StandingConfiguration
 
@@ -45,22 +44,26 @@
     configuration: Optional[StandingConfiguration] = None
     external_id: Optional[constr(strict=True, max_length=150)] = Field(
         None, alias="externalId", description="The Id of the data as set by the provider of the data"
     )
     __properties = ["nameLocal", "nameLatin", "buildRules", "configuration", "externalId"]
 
     @validator("external_id")
-    def external_id_validate_regular_expression(cls, v):
-        if v is None:
-            return v
-        if not re.match(r"^[0-9A-Za-z\/_-]+$", v):
+    def external_id_validate_regular_expression(cls, value):
+        """Validates the regular expression"""
+        if value is None:
+            return value
+
+        if not re.match(r"^[0-9A-Za-z\/_-]+$", value):
             raise ValueError(r"must validate the regular expression /^[0-9A-Za-z\/_-]+$/")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -96,15 +99,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> StandingConfigurationsPutBody:
         """Create an instance of StandingConfigurationsPutBody from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return StandingConfigurationsPutBody.parse_obj(obj)
 
         _obj = StandingConfigurationsPutBody.parse_obj(
             {
                 "name_local": obj.get("nameLocal"),
                 "name_latin": obj.get("nameLatin"),
                 "build_rules": StandingBuilding.from_dict(obj.get("buildRules"))
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/standing_configurations_response.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/standing_configurations_response.py`

 * *Files 4% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import List, Optional
 
 from pydantic import BaseModel, conlist
 
 from atriumsports.datacore.openapi.models.included_data import IncludedData
 from atriumsports.datacore.openapi.models.response_links import ResponseLinks
 from atriumsports.datacore.openapi.models.response_meta_data import ResponseMetaData
@@ -36,14 +35,16 @@
     meta: Optional[ResponseMetaData] = None
     links: Optional[ResponseLinks] = None
     included: Optional[IncludedData] = None
     data: Optional[conlist(StandingConfigurationsModel)] = None
     __properties = ["meta", "links", "included", "data"]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -79,15 +80,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> StandingConfigurationsResponse:
         """Create an instance of StandingConfigurationsResponse from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return StandingConfigurationsResponse.parse_obj(obj)
 
         _obj = StandingConfigurationsResponse.parse_obj(
             {
                 "meta": ResponseMetaData.from_dict(obj.get("meta")) if obj.get("meta") is not None else None,
                 "links": ResponseLinks.from_dict(obj.get("links")) if obj.get("links") is not None else None,
                 "included": IncludedData.from_dict(obj.get("included")) if obj.get("included") is not None else None,
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/standing_post_body.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/standing_post_body.py`

 * *Files 5% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Dict, Optional
 
 from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr, constr, validator
 
 from atriumsports.datacore.openapi.models.standing_post_body_calculated_value import StandingPostBodyCalculatedValue
 from atriumsports.datacore.openapi.models.standing_post_body_points_value import StandingPostBodyPointsValue
 
@@ -113,50 +112,59 @@
         "securedFinals",
         "points",
         "calculated",
         "externalId",
     ]
 
     @validator("grouping_base")
-    def grouping_base_validate_enum(cls, v):
-        if v not in ("OVERALL", "ROUND"):
+    def grouping_base_validate_enum(cls, value):
+        """Validates the enum"""
+        if value not in ("OVERALL", "ROUND"):
             raise ValueError("must be one of enum values ('OVERALL', 'ROUND')")
-        return v
+        return value
 
     @validator("grouping_conference_division")
-    def grouping_conference_division_validate_enum(cls, v):
-        if v not in ("OVERALL", "CONFERENCE", "DIVISION"):
+    def grouping_conference_division_validate_enum(cls, value):
+        """Validates the enum"""
+        if value not in ("OVERALL", "CONFERENCE", "DIVISION"):
             raise ValueError("must be one of enum values ('OVERALL', 'CONFERENCE', 'DIVISION')")
-        return v
+        return value
 
     @validator("grouping_stage_pool")
-    def grouping_stage_pool_validate_enum(cls, v):
-        if v not in ("OVERALL", "STAGE", "STAGEPOOL"):
+    def grouping_stage_pool_validate_enum(cls, value):
+        """Validates the enum"""
+        if value not in ("OVERALL", "STAGE", "STAGEPOOL"):
             raise ValueError("must be one of enum values ('OVERALL', 'STAGE', 'STAGEPOOL')")
-        return v
+        return value
 
     @validator("fixture_type")
-    def fixture_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("ALL_STAR", "PRESEASON", "REGULAR", "FINAL", "PLAYOFF", "FRIENDLY", "DEMONSTRATION"):
+    def fixture_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("ALL_STAR", "PRESEASON", "REGULAR", "FINAL", "PLAYOFF", "FRIENDLY", "DEMONSTRATION"):
             raise ValueError(
                 "must be one of enum values ('ALL_STAR', 'PRESEASON', 'REGULAR', 'FINAL', 'PLAYOFF', 'FRIENDLY', 'DEMONSTRATION')"
             )
-        return v
+        return value
 
     @validator("external_id")
-    def external_id_validate_regular_expression(cls, v):
-        if v is None:
-            return v
-        if not re.match(r"^[0-9A-Za-z\/_-]+$", v):
+    def external_id_validate_regular_expression(cls, value):
+        """Validates the regular expression"""
+        if value is None:
+            return value
+
+        if not re.match(r"^[0-9A-Za-z\/_-]+$", value):
             raise ValueError(r"must validate the regular expression /^[0-9A-Za-z\/_-]+$/")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -235,15 +243,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> StandingPostBody:
         """Create an instance of StandingPostBody from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return StandingPostBody.parse_obj(obj)
 
         _obj = StandingPostBody.parse_obj(
             {
                 "standing_id": obj.get("standingId"),
                 "season_id": obj.get("seasonId"),
                 "entity_id": obj.get("entityId"),
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/standing_post_body_calculated_value.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/standing_post_body_calculated_value.py`

 * *Files 22% similar despite different names*

```diff
@@ -13,133 +13,158 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
-from typing import Optional
+from typing import Optional, Union
 
-from pydantic import BaseModel, Field, StrictFloat, StrictStr
+from pydantic import BaseModel, Field, StrictFloat, StrictInt, StrictStr
 
 
 class StandingPostBodyCalculatedValue(BaseModel):
     """
     Type of points
     """
 
-    played: Optional[StrictFloat] = Field(None, description="Fixtures played")
-    played_home: Optional[StrictFloat] = Field(None, alias="playedHome", description="Fixtures played at home")
-    played_away: Optional[StrictFloat] = Field(None, alias="playedAway", description="Fixtures played away")
-    washouts: Optional[StrictFloat] = Field(None, description="Number of washed out fixtures")
-    wins: Optional[StrictFloat] = Field(None, description="Fixtures Won")
-    wins_home: Optional[StrictFloat] = Field(None, alias="winsHome", description="Fixtures Won at home")
-    wins_away: Optional[StrictFloat] = Field(None, alias="winsAway", description="Fixtures Won away")
-    losses: Optional[StrictFloat] = Field(None, description="Fixtures Lost")
-    losses_home: Optional[StrictFloat] = Field(None, alias="lossesHome", description="Fixtures Lost at home")
-    losses_away: Optional[StrictFloat] = Field(None, alias="lossesAway", description="Fixtures Lost away")
-    draws: Optional[StrictFloat] = Field(None, description="Fixtures Drawn")
-    draws_home: Optional[StrictFloat] = Field(None, alias="drawsHome", description="Fixtures Drawn at home")
-    draws_away: Optional[StrictFloat] = Field(None, alias="drawsAway", description="Fixtures Drawn away")
-    byes: Optional[StrictFloat] = Field(None, description="Fixtures Byes")
-    forfeits_given: Optional[StrictFloat] = Field(None, alias="forfeitsGiven", description="Fixtures Forfeits Given")
-    forfeits_won_by: Optional[StrictFloat] = Field(None, alias="forfeitsWonBy", description="Fixtures Forfeits Won")
-    win_percentage_display: Optional[StrictFloat] = Field(
+    played: Optional[Union[StrictFloat, StrictInt]] = Field(None, description="Fixtures played")
+    played_home: Optional[Union[StrictFloat, StrictInt]] = Field(
+        None, alias="playedHome", description="Fixtures played at home"
+    )
+    played_away: Optional[Union[StrictFloat, StrictInt]] = Field(
+        None, alias="playedAway", description="Fixtures played away"
+    )
+    washouts: Optional[Union[StrictFloat, StrictInt]] = Field(None, description="Number of washed out fixtures")
+    wins: Optional[Union[StrictFloat, StrictInt]] = Field(None, description="Fixtures Won")
+    wins_home: Optional[Union[StrictFloat, StrictInt]] = Field(
+        None, alias="winsHome", description="Fixtures Won at home"
+    )
+    wins_away: Optional[Union[StrictFloat, StrictInt]] = Field(None, alias="winsAway", description="Fixtures Won away")
+    losses: Optional[Union[StrictFloat, StrictInt]] = Field(None, description="Fixtures Lost")
+    losses_home: Optional[Union[StrictFloat, StrictInt]] = Field(
+        None, alias="lossesHome", description="Fixtures Lost at home"
+    )
+    losses_away: Optional[Union[StrictFloat, StrictInt]] = Field(
+        None, alias="lossesAway", description="Fixtures Lost away"
+    )
+    draws: Optional[Union[StrictFloat, StrictInt]] = Field(None, description="Fixtures Drawn")
+    draws_home: Optional[Union[StrictFloat, StrictInt]] = Field(
+        None, alias="drawsHome", description="Fixtures Drawn at home"
+    )
+    draws_away: Optional[Union[StrictFloat, StrictInt]] = Field(
+        None, alias="drawsAway", description="Fixtures Drawn away"
+    )
+    byes: Optional[Union[StrictFloat, StrictInt]] = Field(None, description="Fixtures Byes")
+    forfeits_given: Optional[Union[StrictFloat, StrictInt]] = Field(
+        None, alias="forfeitsGiven", description="Fixtures Forfeits Given"
+    )
+    forfeits_won_by: Optional[Union[StrictFloat, StrictInt]] = Field(
+        None, alias="forfeitsWonBy", description="Fixtures Forfeits Won"
+    )
+    win_percentage_display: Optional[Union[StrictFloat, StrictInt]] = Field(
         None, alias="winPercentageDisplay", description="Win Percentage (wins/played) (Display Value)"
     )
-    win_percentage_home_display: Optional[StrictFloat] = Field(
+    win_percentage_home_display: Optional[Union[StrictFloat, StrictInt]] = Field(
         None, alias="winPercentageHomeDisplay", description="Win Percentage Home (wins/played) (Display Value)"
     )
-    win_percentage_away_display: Optional[StrictFloat] = Field(
+    win_percentage_away_display: Optional[Union[StrictFloat, StrictInt]] = Field(
         None, alias="winPercentageAwayDisplay", description="Win Percentage Away (wins/played) (Display Value)"
     )
-    win_percentage: Optional[StrictFloat] = Field(
+    win_percentage: Optional[Union[StrictFloat, StrictInt]] = Field(
         None, alias="winPercentage", description="Win Percentage (wins/played)"
     )
-    win_percentage_home: Optional[StrictFloat] = Field(
+    win_percentage_home: Optional[Union[StrictFloat, StrictInt]] = Field(
         None, alias="winPercentageHome", description="Win Percentage Home (wins/played)"
     )
-    win_percentage_away: Optional[StrictFloat] = Field(
+    win_percentage_away: Optional[Union[StrictFloat, StrictInt]] = Field(
         None, alias="winPercentageAway", description="Win Percentage Away (wins/played)"
     )
-    scored_for: Optional[StrictFloat] = Field(None, alias="scoredFor", description="Scored For")
-    scored_for_home: Optional[StrictFloat] = Field(None, alias="scoredForHome", description="Scored For at home")
-    scored_for_away: Optional[StrictFloat] = Field(None, alias="scoredForAway", description="Scored For away")
-    scored_against: Optional[StrictFloat] = Field(None, alias="scoredAgainst", description="Scored For")
-    scored_against_home: Optional[StrictFloat] = Field(
+    scored_for: Optional[Union[StrictFloat, StrictInt]] = Field(None, alias="scoredFor", description="Scored For")
+    scored_for_home: Optional[Union[StrictFloat, StrictInt]] = Field(
+        None, alias="scoredForHome", description="Scored For at home"
+    )
+    scored_for_away: Optional[Union[StrictFloat, StrictInt]] = Field(
+        None, alias="scoredForAway", description="Scored For away"
+    )
+    scored_against: Optional[Union[StrictFloat, StrictInt]] = Field(
+        None, alias="scoredAgainst", description="Scored For"
+    )
+    scored_against_home: Optional[Union[StrictFloat, StrictInt]] = Field(
         None, alias="scoredAgainstHome", description="Scored Against at home"
     )
-    scored_against_away: Optional[StrictFloat] = Field(
+    scored_against_away: Optional[Union[StrictFloat, StrictInt]] = Field(
         None, alias="scoredAgainstAway", description="Scored Against away"
     )
-    percentage_display: Optional[StrictFloat] = Field(
+    percentage_display: Optional[Union[StrictFloat, StrictInt]] = Field(
         None, alias="percentageDisplay", description="For versus Against (Display Value)"
     )
-    percentage_home_display: Optional[StrictFloat] = Field(
+    percentage_home_display: Optional[Union[StrictFloat, StrictInt]] = Field(
         None, alias="percentageHomeDisplay", description="For versus Against at home (Display Value)"
     )
-    percentage_away_display: Optional[StrictFloat] = Field(
+    percentage_away_display: Optional[Union[StrictFloat, StrictInt]] = Field(
         None, alias="percentageAwayDisplay", description="For versus Against away (Display Value)"
     )
-    percentage: Optional[StrictFloat] = Field(None, description="For versus Against")
-    percentage_home: Optional[StrictFloat] = Field(
+    percentage: Optional[Union[StrictFloat, StrictInt]] = Field(None, description="For versus Against")
+    percentage_home: Optional[Union[StrictFloat, StrictInt]] = Field(
         None, alias="percentageHome", description="For versus Against at home"
     )
-    percentage_away: Optional[StrictFloat] = Field(None, alias="percentageAway", description="For versus Against away")
-    point_difference: Optional[StrictFloat] = Field(
+    percentage_away: Optional[Union[StrictFloat, StrictInt]] = Field(
+        None, alias="percentageAway", description="For versus Against away"
+    )
+    point_difference: Optional[Union[StrictFloat, StrictInt]] = Field(
         None, alias="pointDifference", description="Point Difference for competitor"
     )
-    point_difference_home: Optional[StrictFloat] = Field(
+    point_difference_home: Optional[Union[StrictFloat, StrictInt]] = Field(
         None, alias="pointDifferenceHome", description="Point Difference for competitor at Home"
     )
-    point_difference_away: Optional[StrictFloat] = Field(
+    point_difference_away: Optional[Union[StrictFloat, StrictInt]] = Field(
         None, alias="pointDifferenceAway", description="Point Difference for competitor away"
     )
-    lowest_score_for: Optional[StrictFloat] = Field(
+    lowest_score_for: Optional[Union[StrictFloat, StrictInt]] = Field(
         None, alias="lowestScoreFor", description="Lowest Score for competitor"
     )
-    lowest_score_for_home: Optional[StrictFloat] = Field(
+    lowest_score_for_home: Optional[Union[StrictFloat, StrictInt]] = Field(
         None, alias="lowestScoreForHome", description="Lowest Score for competitor at Home"
     )
-    lowest_score_for_away: Optional[StrictFloat] = Field(
+    lowest_score_for_away: Optional[Union[StrictFloat, StrictInt]] = Field(
         None, alias="lowestScoreForAway", description="Lowest Score for competitor away"
     )
-    highest_score_for: Optional[StrictFloat] = Field(
+    highest_score_for: Optional[Union[StrictFloat, StrictInt]] = Field(
         None, alias="highestScoreFor", description="Highest Score for competitor"
     )
-    highest_score_for_home: Optional[StrictFloat] = Field(
+    highest_score_for_home: Optional[Union[StrictFloat, StrictInt]] = Field(
         None, alias="highestScoreForHome", description="Highest Score for competitor at Home"
     )
-    highest_score_for_away: Optional[StrictFloat] = Field(
+    highest_score_for_away: Optional[Union[StrictFloat, StrictInt]] = Field(
         None, alias="highestScoreForAway", description="Highest Score for competitor away"
     )
-    lowest_score_against: Optional[StrictFloat] = Field(
+    lowest_score_against: Optional[Union[StrictFloat, StrictInt]] = Field(
         None, alias="lowestScoreAgainst", description="Lowest Score against competitor"
     )
-    lowest_score_against_home: Optional[StrictFloat] = Field(
+    lowest_score_against_home: Optional[Union[StrictFloat, StrictInt]] = Field(
         None, alias="lowestScoreAgainstHome", description="Lowest Score against competitor at Home"
     )
-    lowest_score_against_away: Optional[StrictFloat] = Field(
+    lowest_score_against_away: Optional[Union[StrictFloat, StrictInt]] = Field(
         None, alias="lowestScoreAgainstAway", description="Lowest Score against competitor away"
     )
-    highest_score_against: Optional[StrictFloat] = Field(
+    highest_score_against: Optional[Union[StrictFloat, StrictInt]] = Field(
         None, alias="highestScoreAgainst", description="Highest Score against competitor"
     )
-    highest_score_against_home: Optional[StrictFloat] = Field(
+    highest_score_against_home: Optional[Union[StrictFloat, StrictInt]] = Field(
         None, alias="highestScoreAgainstHome", description="Highest Score against competitor at Home"
     )
-    highest_score_against_away: Optional[StrictFloat] = Field(
+    highest_score_against_away: Optional[Union[StrictFloat, StrictInt]] = Field(
         None, alias="highestScoreAgainstAway", description="Highest Score against competitor away"
     )
-    streak: Optional[StrictFloat] = Field(None, description="Winning streak for competitor")
-    streak_home: Optional[StrictFloat] = Field(
+    streak: Optional[Union[StrictFloat, StrictInt]] = Field(None, description="Winning streak for competitor")
+    streak_home: Optional[Union[StrictFloat, StrictInt]] = Field(
         None, alias="streakHome", description="Winning streak for competitor at Home"
     )
-    streak_away: Optional[StrictFloat] = Field(
+    streak_away: Optional[Union[StrictFloat, StrictInt]] = Field(
         None, alias="streakAway", description="Winning streak for competitor away"
     )
     result_string: Optional[StrictStr] = Field(
         None, alias="resultString", description="Result string for competitor (W,L,D per match)"
     )
     result_string_home: Optional[StrictStr] = Field(
         None, alias="resultStringHome", description="Result string for competitor at Home (W,L,D per match)"
@@ -202,14 +227,16 @@
         "streakAway",
         "resultString",
         "resultStringHome",
         "resultStringAway",
     ]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -289,15 +316,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> StandingPostBodyCalculatedValue:
         """Create an instance of StandingPostBodyCalculatedValue from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return StandingPostBodyCalculatedValue.parse_obj(obj)
 
         _obj = StandingPostBodyCalculatedValue.parse_obj(
             {
                 "played": obj.get("played"),
                 "played_home": obj.get("playedHome"),
                 "played_away": obj.get("playedAway"),
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/standing_post_body_points_value.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/standing_post_body_points_value.py`

 * *Files 20% similar despite different names*

```diff
@@ -13,53 +13,52 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
-from typing import Optional
+from typing import Optional, Union
 
-from pydantic import BaseModel, Field, StrictFloat
+from pydantic import BaseModel, Field, StrictFloat, StrictInt
 
 
 class StandingPostBodyPointsValue(BaseModel):
     """
     Type of points
     """
 
-    bonus_standing_points: Optional[StrictFloat] = Field(
+    bonus_standing_points: Optional[Union[StrictFloat, StrictInt]] = Field(
         None, alias="bonusStandingPoints", description="Bonus Standing points"
     )
-    penalty_standing_points: Optional[StrictFloat] = Field(
+    penalty_standing_points: Optional[Union[StrictFloat, StrictInt]] = Field(
         None, alias="penaltyStandingPoints", description="Penalty Standing points"
     )
-    bye_standing_points: Optional[StrictFloat] = Field(
+    bye_standing_points: Optional[Union[StrictFloat, StrictInt]] = Field(
         None, alias="byeStandingPoints", description="Bye Standing points"
     )
-    team_differential: Optional[StrictFloat] = Field(
+    team_differential: Optional[Union[StrictFloat, StrictInt]] = Field(
         None, alias="teamDifferential", description="Differential of Won-Lost"
     )
-    team_differential_home: Optional[StrictFloat] = Field(
+    team_differential_home: Optional[Union[StrictFloat, StrictInt]] = Field(
         None, alias="teamDifferentialHome", description="Differential of Won-Lost"
     )
-    team_differential_away: Optional[StrictFloat] = Field(
+    team_differential_away: Optional[Union[StrictFloat, StrictInt]] = Field(
         None, alias="teamDifferentialAway", description="Differential of Won-Lost"
     )
-    games_behind: Optional[StrictFloat] = Field(
+    games_behind: Optional[Union[StrictFloat, StrictInt]] = Field(
         None, alias="gamesBehind", description="Games behind leading competitor"
     )
-    standing_points: Optional[StrictFloat] = Field(
+    standing_points: Optional[Union[StrictFloat, StrictInt]] = Field(
         None, alias="standingPoints", description="Standing Points for competitor"
     )
-    standing_points_home: Optional[StrictFloat] = Field(
+    standing_points_home: Optional[Union[StrictFloat, StrictInt]] = Field(
         None, alias="standingPointsHome", description="Standing Points for competitor at Home"
     )
-    standing_points_away: Optional[StrictFloat] = Field(
+    standing_points_away: Optional[Union[StrictFloat, StrictInt]] = Field(
         None, alias="standingPointsAway", description="Standing Points for competitor away"
     )
     __properties = [
         "bonusStandingPoints",
         "penaltyStandingPoints",
         "byeStandingPoints",
         "teamDifferential",
@@ -68,14 +67,16 @@
         "gamesBehind",
         "standingPoints",
         "standingPointsHome",
         "standingPointsAway",
     ]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -95,15 +96,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> StandingPostBodyPointsValue:
         """Create an instance of StandingPostBodyPointsValue from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return StandingPostBodyPointsValue.parse_obj(obj)
 
         _obj = StandingPostBodyPointsValue.parse_obj(
             {
                 "bonus_standing_points": obj.get("bonusStandingPoints"),
                 "penalty_standing_points": obj.get("penaltyStandingPoints"),
                 "bye_standing_points": obj.get("byeStandingPoints"),
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/standing_put_body.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/standing_put_body.py`

 * *Files 8% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Dict, Optional
 
 from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr, constr, validator
 
 from atriumsports.datacore.openapi.models.standing_post_body_calculated_value import StandingPostBodyCalculatedValue
 from atriumsports.datacore.openapi.models.standing_post_body_points_value import StandingPostBodyPointsValue
 
@@ -109,56 +108,68 @@
         "securedFinals",
         "points",
         "calculated",
         "externalId",
     ]
 
     @validator("grouping_base")
-    def grouping_base_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("OVERALL", "ROUND"):
+    def grouping_base_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("OVERALL", "ROUND"):
             raise ValueError("must be one of enum values ('OVERALL', 'ROUND')")
-        return v
+        return value
 
     @validator("grouping_conference_division")
-    def grouping_conference_division_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("OVERALL", "CONFERENCE", "DIVISION"):
+    def grouping_conference_division_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("OVERALL", "CONFERENCE", "DIVISION"):
             raise ValueError("must be one of enum values ('OVERALL', 'CONFERENCE', 'DIVISION')")
-        return v
+        return value
 
     @validator("grouping_stage_pool")
-    def grouping_stage_pool_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("OVERALL", "STAGE", "STAGEPOOL"):
+    def grouping_stage_pool_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("OVERALL", "STAGE", "STAGEPOOL"):
             raise ValueError("must be one of enum values ('OVERALL', 'STAGE', 'STAGEPOOL')")
-        return v
+        return value
 
     @validator("fixture_type")
-    def fixture_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("ALL_STAR", "PRESEASON", "REGULAR", "FINAL", "PLAYOFF", "FRIENDLY", "DEMONSTRATION"):
+    def fixture_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("ALL_STAR", "PRESEASON", "REGULAR", "FINAL", "PLAYOFF", "FRIENDLY", "DEMONSTRATION"):
             raise ValueError(
                 "must be one of enum values ('ALL_STAR', 'PRESEASON', 'REGULAR', 'FINAL', 'PLAYOFF', 'FRIENDLY', 'DEMONSTRATION')"
             )
-        return v
+        return value
 
     @validator("external_id")
-    def external_id_validate_regular_expression(cls, v):
-        if v is None:
-            return v
-        if not re.match(r"^[0-9A-Za-z\/_-]+$", v):
+    def external_id_validate_regular_expression(cls, value):
+        """Validates the regular expression"""
+        if value is None:
+            return value
+
+        if not re.match(r"^[0-9A-Za-z\/_-]+$", value):
             raise ValueError(r"must validate the regular expression /^[0-9A-Za-z\/_-]+$/")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -237,15 +248,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> StandingPutBody:
         """Create an instance of StandingPutBody from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return StandingPutBody.parse_obj(obj)
 
         _obj = StandingPutBody.parse_obj(
             {
                 "season_id": obj.get("seasonId"),
                 "entity_id": obj.get("entityId"),
                 "division_id": obj.get("divisionId"),
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/standings_model.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/standings_model.py`

 * *Files 3% similar despite different names*

```diff
@@ -14,15 +14,14 @@
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
 from datetime import datetime
-from inspect import getfullargspec
 from typing import Dict, Optional
 
 from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr, constr, validator
 
 from atriumsports.datacore.openapi.models.fixture_entities_model_conference import FixtureEntitiesModelConference
 from atriumsports.datacore.openapi.models.fixture_entities_model_division import FixtureEntitiesModelDivision
 from atriumsports.datacore.openapi.models.fixture_entities_model_entity import FixtureEntitiesModelEntity
@@ -157,56 +156,68 @@
         "externalId",
         "autoGenerated",
         "updated",
         "added",
     ]
 
     @validator("grouping_base")
-    def grouping_base_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("OVERALL", "ROUND"):
+    def grouping_base_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("OVERALL", "ROUND"):
             raise ValueError("must be one of enum values ('OVERALL', 'ROUND')")
-        return v
+        return value
 
     @validator("grouping_conference_division")
-    def grouping_conference_division_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("OVERALL", "CONFERENCE", "DIVISION"):
+    def grouping_conference_division_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("OVERALL", "CONFERENCE", "DIVISION"):
             raise ValueError("must be one of enum values ('OVERALL', 'CONFERENCE', 'DIVISION')")
-        return v
+        return value
 
     @validator("grouping_stage_pool")
-    def grouping_stage_pool_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("OVERALL", "STAGE", "STAGEPOOL"):
+    def grouping_stage_pool_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("OVERALL", "STAGE", "STAGEPOOL"):
             raise ValueError("must be one of enum values ('OVERALL', 'STAGE', 'STAGEPOOL')")
-        return v
+        return value
 
     @validator("fixture_type")
-    def fixture_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("ALL_STAR", "PRESEASON", "REGULAR", "FINAL", "PLAYOFF", "FRIENDLY", "DEMONSTRATION"):
+    def fixture_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("ALL_STAR", "PRESEASON", "REGULAR", "FINAL", "PLAYOFF", "FRIENDLY", "DEMONSTRATION"):
             raise ValueError(
                 "must be one of enum values ('ALL_STAR', 'PRESEASON', 'REGULAR', 'FINAL', 'PLAYOFF', 'FRIENDLY', 'DEMONSTRATION')"
             )
-        return v
+        return value
 
     @validator("external_id")
-    def external_id_validate_regular_expression(cls, v):
-        if v is None:
-            return v
-        if not re.match(r"^[0-9A-Za-z\/_-]+$", v):
+    def external_id_validate_regular_expression(cls, value):
+        """Validates the regular expression"""
+        if value is None:
+            return value
+
+        if not re.match(r"^[0-9A-Za-z\/_-]+$", value):
             raise ValueError(r"must validate the regular expression /^[0-9A-Za-z\/_-]+$/")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -321,15 +332,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> StandingsModel:
         """Create an instance of StandingsModel from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return StandingsModel.parse_obj(obj)
 
         _obj = StandingsModel.parse_obj(
             {
                 "standing_id": obj.get("standingId"),
                 "organization_id": obj.get("organizationId"),
                 "organization": StandingsModelOrganization.from_dict(obj.get("organization"))
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/standings_model_organization.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/standings_model_organization.py`

 * *Files 6% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr, validator
 
 
 class StandingsModelOrganization(BaseModel):
     """
@@ -29,22 +28,26 @@
     """
 
     resource_type: Optional[StrictStr] = Field(None, alias="resourceType")
     id: Optional[StrictStr] = Field(None, description="Unique identifier for this resource")
     __properties = ["resourceType", "id"]
 
     @validator("resource_type")
-    def resource_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("organizations"):
+    def resource_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("organizations"):
             raise ValueError("must be one of enum values ('organizations')")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -64,12 +67,12 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> StandingsModelOrganization:
         """Create an instance of StandingsModelOrganization from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return StandingsModelOrganization.parse_obj(obj)
 
         _obj = StandingsModelOrganization.parse_obj({"resource_type": obj.get("resourceType"), "id": obj.get("id")})
         return _obj
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/standings_response.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/standings_response.py`

 * *Files 3% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import List, Optional
 
 from pydantic import BaseModel, conlist
 
 from atriumsports.datacore.openapi.models.included_data import IncludedData
 from atriumsports.datacore.openapi.models.response_links import ResponseLinks
 from atriumsports.datacore.openapi.models.response_meta_data import ResponseMetaData
@@ -36,14 +35,16 @@
     meta: Optional[ResponseMetaData] = None
     links: Optional[ResponseLinks] = None
     included: Optional[IncludedData] = None
     data: Optional[conlist(StandingsModel)] = None
     __properties = ["meta", "links", "included", "data"]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -79,15 +80,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> StandingsResponse:
         """Create an instance of StandingsResponse from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return StandingsResponse.parse_obj(obj)
 
         _obj = StandingsResponse.parse_obj(
             {
                 "meta": ResponseMetaData.from_dict(obj.get("meta")) if obj.get("meta") is not None else None,
                 "links": ResponseLinks.from_dict(obj.get("links")) if obj.get("links") is not None else None,
                 "included": IncludedData.from_dict(obj.get("included")) if obj.get("included") is not None else None,
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/success_model.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/success_model.py`

 * *Files 7% similar despite different names*

```diff
@@ -13,29 +13,30 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictBool
 
 
 class SuccessModel(BaseModel):
     """
     SuccessModel
     """
 
     success: Optional[StrictBool] = Field(None, description="Was the call a success?")
     __properties = ["success"]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -55,12 +56,12 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> SuccessModel:
         """Create an instance of SuccessModel from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return SuccessModel.parse_obj(obj)
 
         _obj = SuccessModel.parse_obj({"success": obj.get("success")})
         return _obj
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/success_response.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/conferences_response.py`

 * *Files 10% similar despite different names*

```diff
@@ -13,51 +13,52 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import List, Optional
 
 from pydantic import BaseModel, conlist
 
+from atriumsports.datacore.openapi.models.conferences_model import ConferencesModel
 from atriumsports.datacore.openapi.models.included_data import IncludedData
 from atriumsports.datacore.openapi.models.response_links import ResponseLinks
 from atriumsports.datacore.openapi.models.response_meta_data import ResponseMetaData
-from atriumsports.datacore.openapi.models.success_model import SuccessModel
 
 
-class SuccessResponse(BaseModel):
+class ConferencesResponse(BaseModel):
     """
-    SuccessResponse
+    ConferencesResponse
     """
 
     meta: Optional[ResponseMetaData] = None
     links: Optional[ResponseLinks] = None
     included: Optional[IncludedData] = None
-    data: Optional[conlist(SuccessModel)] = None
+    data: Optional[conlist(ConferencesModel)] = None
     __properties = ["meta", "links", "included", "data"]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> SuccessResponse:
-        """Create an instance of SuccessResponse from a JSON string"""
+    def from_json(cls, json_str: str) -> ConferencesResponse:
+        """Create an instance of ConferencesResponse from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
     def to_dict(self):
         """Returns the dictionary representation of the model using alias"""
         _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)
         # override the default output from pydantic by calling `to_dict()` of meta
         if self.meta:
@@ -74,26 +75,26 @@
             for _item in self.data:
                 if _item:
                     _items.append(_item.to_dict())
             _dict["data"] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> SuccessResponse:
-        """Create an instance of SuccessResponse from a dict"""
+    def from_dict(cls, obj: dict) -> ConferencesResponse:
+        """Create an instance of ConferencesResponse from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
-            return SuccessResponse.parse_obj(obj)
+        if not isinstance(obj, dict):
+            return ConferencesResponse.parse_obj(obj)
 
-        _obj = SuccessResponse.parse_obj(
+        _obj = ConferencesResponse.parse_obj(
             {
                 "meta": ResponseMetaData.from_dict(obj.get("meta")) if obj.get("meta") is not None else None,
                 "links": ResponseLinks.from_dict(obj.get("links")) if obj.get("links") is not None else None,
                 "included": IncludedData.from_dict(obj.get("included")) if obj.get("included") is not None else None,
-                "data": [SuccessModel.from_dict(_item) for _item in obj.get("data")]
+                "data": [ConferencesModel.from_dict(_item) for _item in obj.get("data")]
                 if obj.get("data") is not None
                 else None,
             }
         )
         return _obj
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/transfer_component.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/transfer_component.py`

 * *Files 2% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr
 
 
 class TransferComponent(BaseModel):
     """
@@ -37,14 +36,16 @@
     )
     extra_allowances: Optional[StrictStr] = Field(
         None, alias="extraAllowances", description="Details of additional allowances included in the transfer"
     )
     __properties = ["personId", "fromEntityGroupId", "toEntityGroupId", "extraAllowances"]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -64,15 +65,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> TransferComponent:
         """Create an instance of TransferComponent from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return TransferComponent.parse_obj(obj)
 
         _obj = TransferComponent.parse_obj(
             {
                 "person_id": obj.get("personId"),
                 "from_entity_group_id": obj.get("fromEntityGroupId"),
                 "to_entity_group_id": obj.get("toEntityGroupId"),
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/transfer_post_body.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/transfer_put_body.py`

 * *Files 4% similar despite different names*

```diff
@@ -14,103 +14,108 @@
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
 from datetime import date
-from inspect import getfullargspec
 from typing import List, Optional
 
 from pydantic import BaseModel, Field, StrictStr, conlist, constr, validator
 
 from atriumsports.datacore.openapi.models.transfer_component import TransferComponent
 
 
-class TransferPostBody(BaseModel):
+class TransferPutBody(BaseModel):
     """
-    TransferPostBody
+    TransferPutBody
     """
 
-    transfer_id: Optional[StrictStr] = Field(
-        None, alias="transferId", description="The unique identifier of the transfer"
-    )
     competition_id: Optional[StrictStr] = Field(
         None, alias="competitionId", description="The unique identifier of the competition"
     )
     season_id: Optional[StrictStr] = Field(None, alias="seasonId", description="The unique identifier of the season")
     components: Optional[conlist(TransferComponent)] = Field(None, description="List of transfer components")
     status: Optional[constr(strict=True, max_length=30)] = Field(
         None, description="Transfer Status >- `APPROVED` Approved >- `DECLINED` Decline >- `PENDING` Pending "
     )
     reference: Optional[constr(strict=True, max_length=100)] = Field(None, description="Transfer reference number")
-    transfer_type: constr(strict=True, max_length=100) = Field(
-        ...,
+    transfer_type: Optional[constr(strict=True, max_length=100)] = Field(
+        None,
         alias="transferType",
         description="Type of transfer >- `DROPPED` Dropped >- `OTHER` Other >- `PERMIT` Permit >- `TRADE` Trade >- `TRANSFER` Transfer ",
     )
     date_transfer: Optional[date] = Field(None, alias="dateTransfer", description="Date of transfer")
     date_permit_from: Optional[date] = Field(None, alias="datePermitFrom", description="Date the permit started")
     date_permit_to: Optional[date] = Field(None, alias="datePermitTo", description="Date the permit ended")
     notes: Optional[constr(strict=True, max_length=1000)] = Field(None, description="Notes")
     external_id: Optional[constr(strict=True, max_length=150)] = Field(
         None, alias="externalId", description="The Id of the data as set by the provider of the data"
     )
     __properties = [
-        "transferId",
         "competitionId",
         "seasonId",
         "components",
         "status",
         "reference",
         "transferType",
         "dateTransfer",
         "datePermitFrom",
         "datePermitTo",
         "notes",
         "externalId",
     ]
 
     @validator("status")
-    def status_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("APPROVED", "PENDING", "DECLINED"):
+    def status_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("APPROVED", "PENDING", "DECLINED"):
             raise ValueError("must be one of enum values ('APPROVED', 'PENDING', 'DECLINED')")
-        return v
+        return value
 
     @validator("transfer_type")
-    def transfer_type_validate_enum(cls, v):
-        if v not in ("TRADE", "TRANSFER", "DROPPED", "PERMIT", "OTHER"):
+    def transfer_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("TRADE", "TRANSFER", "DROPPED", "PERMIT", "OTHER"):
             raise ValueError("must be one of enum values ('TRADE', 'TRANSFER', 'DROPPED', 'PERMIT', 'OTHER')")
-        return v
+        return value
 
     @validator("external_id")
-    def external_id_validate_regular_expression(cls, v):
-        if v is None:
-            return v
-        if not re.match(r"^[0-9A-Za-z\/_-]+$", v):
+    def external_id_validate_regular_expression(cls, value):
+        """Validates the regular expression"""
+        if value is None:
+            return value
+
+        if not re.match(r"^[0-9A-Za-z\/_-]+$", value):
             raise ValueError(r"must validate the regular expression /^[0-9A-Za-z\/_-]+$/")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> TransferPostBody:
-        """Create an instance of TransferPostBody from a JSON string"""
+    def from_json(cls, json_str: str) -> TransferPutBody:
+        """Create an instance of TransferPutBody from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
     def to_dict(self):
         """Returns the dictionary representation of the model using alias"""
         _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)
         # override the default output from pydantic by calling `to_dict()` of each item in components (list)
         _items = []
@@ -148,25 +153,24 @@
         # and __fields_set__ contains the field
         if self.external_id is None and "external_id" in self.__fields_set__:
             _dict["externalId"] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> TransferPostBody:
-        """Create an instance of TransferPostBody from a dict"""
+    def from_dict(cls, obj: dict) -> TransferPutBody:
+        """Create an instance of TransferPutBody from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
-            return TransferPostBody.parse_obj(obj)
+        if not isinstance(obj, dict):
+            return TransferPutBody.parse_obj(obj)
 
-        _obj = TransferPostBody.parse_obj(
+        _obj = TransferPutBody.parse_obj(
             {
-                "transfer_id": obj.get("transferId"),
                 "competition_id": obj.get("competitionId"),
                 "season_id": obj.get("seasonId"),
                 "components": [TransferComponent.from_dict(_item) for _item in obj.get("components")]
                 if obj.get("components") is not None
                 else None,
                 "status": obj.get("status"),
                 "reference": obj.get("reference"),
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/transfer_put_body.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/transfer_post_body.py`

 * *Files 12% similar despite different names*

```diff
@@ -14,101 +14,109 @@
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
 from datetime import date
-from inspect import getfullargspec
 from typing import List, Optional
 
 from pydantic import BaseModel, Field, StrictStr, conlist, constr, validator
 
 from atriumsports.datacore.openapi.models.transfer_component import TransferComponent
 
 
-class TransferPutBody(BaseModel):
+class TransferPostBody(BaseModel):
     """
-    TransferPutBody
+    TransferPostBody
     """
 
+    transfer_id: Optional[StrictStr] = Field(
+        None, alias="transferId", description="The unique identifier of the transfer"
+    )
     competition_id: Optional[StrictStr] = Field(
         None, alias="competitionId", description="The unique identifier of the competition"
     )
     season_id: Optional[StrictStr] = Field(None, alias="seasonId", description="The unique identifier of the season")
     components: Optional[conlist(TransferComponent)] = Field(None, description="List of transfer components")
     status: Optional[constr(strict=True, max_length=30)] = Field(
         None, description="Transfer Status >- `APPROVED` Approved >- `DECLINED` Decline >- `PENDING` Pending "
     )
     reference: Optional[constr(strict=True, max_length=100)] = Field(None, description="Transfer reference number")
-    transfer_type: Optional[constr(strict=True, max_length=100)] = Field(
-        None,
+    transfer_type: constr(strict=True, max_length=100) = Field(
+        ...,
         alias="transferType",
         description="Type of transfer >- `DROPPED` Dropped >- `OTHER` Other >- `PERMIT` Permit >- `TRADE` Trade >- `TRANSFER` Transfer ",
     )
     date_transfer: Optional[date] = Field(None, alias="dateTransfer", description="Date of transfer")
     date_permit_from: Optional[date] = Field(None, alias="datePermitFrom", description="Date the permit started")
     date_permit_to: Optional[date] = Field(None, alias="datePermitTo", description="Date the permit ended")
     notes: Optional[constr(strict=True, max_length=1000)] = Field(None, description="Notes")
     external_id: Optional[constr(strict=True, max_length=150)] = Field(
         None, alias="externalId", description="The Id of the data as set by the provider of the data"
     )
     __properties = [
+        "transferId",
         "competitionId",
         "seasonId",
         "components",
         "status",
         "reference",
         "transferType",
         "dateTransfer",
         "datePermitFrom",
         "datePermitTo",
         "notes",
         "externalId",
     ]
 
     @validator("status")
-    def status_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("APPROVED", "PENDING", "DECLINED"):
+    def status_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("APPROVED", "PENDING", "DECLINED"):
             raise ValueError("must be one of enum values ('APPROVED', 'PENDING', 'DECLINED')")
-        return v
+        return value
 
     @validator("transfer_type")
-    def transfer_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("TRADE", "TRANSFER", "DROPPED", "PERMIT", "OTHER"):
+    def transfer_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value not in ("TRADE", "TRANSFER", "DROPPED", "PERMIT", "OTHER"):
             raise ValueError("must be one of enum values ('TRADE', 'TRANSFER', 'DROPPED', 'PERMIT', 'OTHER')")
-        return v
+        return value
 
     @validator("external_id")
-    def external_id_validate_regular_expression(cls, v):
-        if v is None:
-            return v
-        if not re.match(r"^[0-9A-Za-z\/_-]+$", v):
+    def external_id_validate_regular_expression(cls, value):
+        """Validates the regular expression"""
+        if value is None:
+            return value
+
+        if not re.match(r"^[0-9A-Za-z\/_-]+$", value):
             raise ValueError(r"must validate the regular expression /^[0-9A-Za-z\/_-]+$/")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> TransferPutBody:
-        """Create an instance of TransferPutBody from a JSON string"""
+    def from_json(cls, json_str: str) -> TransferPostBody:
+        """Create an instance of TransferPostBody from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
     def to_dict(self):
         """Returns the dictionary representation of the model using alias"""
         _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)
         # override the default output from pydantic by calling `to_dict()` of each item in components (list)
         _items = []
@@ -146,24 +154,25 @@
         # and __fields_set__ contains the field
         if self.external_id is None and "external_id" in self.__fields_set__:
             _dict["externalId"] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> TransferPutBody:
-        """Create an instance of TransferPutBody from a dict"""
+    def from_dict(cls, obj: dict) -> TransferPostBody:
+        """Create an instance of TransferPostBody from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
-            return TransferPutBody.parse_obj(obj)
+        if not isinstance(obj, dict):
+            return TransferPostBody.parse_obj(obj)
 
-        _obj = TransferPutBody.parse_obj(
+        _obj = TransferPostBody.parse_obj(
             {
+                "transfer_id": obj.get("transferId"),
                 "competition_id": obj.get("competitionId"),
                 "season_id": obj.get("seasonId"),
                 "components": [TransferComponent.from_dict(_item) for _item in obj.get("components")]
                 if obj.get("components") is not None
                 else None,
                 "status": obj.get("status"),
                 "reference": obj.get("reference"),
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/transfers_model.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/transfers_model.py`

 * *Files 7% similar despite different names*

```diff
@@ -14,15 +14,14 @@
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
 from datetime import date, datetime
-from inspect import getfullargspec
 from typing import List, Optional
 
 from pydantic import BaseModel, Field, StrictStr, conlist, constr, validator
 
 from atriumsports.datacore.openapi.models.fixture_progressions_model_season import FixtureProgressionsModelSeason
 from atriumsports.datacore.openapi.models.seasons_model_competition import SeasonsModelCompetition
 from atriumsports.datacore.openapi.models.transfer_component import TransferComponent
@@ -84,38 +83,46 @@
         "notes",
         "externalId",
         "updated",
         "added",
     ]
 
     @validator("status")
-    def status_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("APPROVED", "PENDING", "DECLINED"):
+    def status_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("APPROVED", "PENDING", "DECLINED"):
             raise ValueError("must be one of enum values ('APPROVED', 'PENDING', 'DECLINED')")
-        return v
+        return value
 
     @validator("transfer_type")
-    def transfer_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("TRADE", "TRANSFER", "DROPPED", "PERMIT", "OTHER"):
+    def transfer_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("TRADE", "TRANSFER", "DROPPED", "PERMIT", "OTHER"):
             raise ValueError("must be one of enum values ('TRADE', 'TRANSFER', 'DROPPED', 'PERMIT', 'OTHER')")
-        return v
+        return value
 
     @validator("external_id")
-    def external_id_validate_regular_expression(cls, v):
-        if v is None:
-            return v
-        if not re.match(r"^[0-9A-Za-z\/_-]+$", v):
+    def external_id_validate_regular_expression(cls, value):
+        """Validates the regular expression"""
+        if value is None:
+            return value
+
+        if not re.match(r"^[0-9A-Za-z\/_-]+$", value):
             raise ValueError(r"must validate the regular expression /^[0-9A-Za-z\/_-]+$/")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -189,15 +196,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> TransfersModel:
         """Create an instance of TransfersModel from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return TransfersModel.parse_obj(obj)
 
         _obj = TransfersModel.parse_obj(
             {
                 "transfer_id": obj.get("transferId"),
                 "organization_id": obj.get("organizationId"),
                 "organization": TransfersModelOrganization.from_dict(obj.get("organization"))
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/transfers_model_organization.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_person_total_statistics_model_organization.py`

 * *Files 25% similar despite different names*

```diff
@@ -13,63 +13,68 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr, validator
 
 
-class TransfersModelOrganization(BaseModel):
+class SeasonPersonTotalStatisticsModelOrganization(BaseModel):
     """
-    The organization that this ~transfer~ belongs to
+    The organization that this season person total statistics belongs to
     """
 
     resource_type: Optional[StrictStr] = Field(None, alias="resourceType")
     id: Optional[StrictStr] = Field(None, description="Unique identifier for this resource")
     __properties = ["resourceType", "id"]
 
     @validator("resource_type")
-    def resource_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("organizations"):
+    def resource_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("organizations"):
             raise ValueError("must be one of enum values ('organizations')")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> TransfersModelOrganization:
-        """Create an instance of TransfersModelOrganization from a JSON string"""
+    def from_json(cls, json_str: str) -> SeasonPersonTotalStatisticsModelOrganization:
+        """Create an instance of SeasonPersonTotalStatisticsModelOrganization from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
     def to_dict(self):
         """Returns the dictionary representation of the model using alias"""
         _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> TransfersModelOrganization:
-        """Create an instance of TransfersModelOrganization from a dict"""
+    def from_dict(cls, obj: dict) -> SeasonPersonTotalStatisticsModelOrganization:
+        """Create an instance of SeasonPersonTotalStatisticsModelOrganization from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
-            return TransfersModelOrganization.parse_obj(obj)
+        if not isinstance(obj, dict):
+            return SeasonPersonTotalStatisticsModelOrganization.parse_obj(obj)
 
-        _obj = TransfersModelOrganization.parse_obj({"resource_type": obj.get("resourceType"), "id": obj.get("id")})
+        _obj = SeasonPersonTotalStatisticsModelOrganization.parse_obj(
+            {"resource_type": obj.get("resourceType"), "id": obj.get("id")}
+        )
         return _obj
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/transfers_response.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/transfers_response.py`

 * *Files 3% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import List, Optional
 
 from pydantic import BaseModel, conlist
 
 from atriumsports.datacore.openapi.models.included_data import IncludedData
 from atriumsports.datacore.openapi.models.response_links import ResponseLinks
 from atriumsports.datacore.openapi.models.response_meta_data import ResponseMetaData
@@ -36,14 +35,16 @@
     meta: Optional[ResponseMetaData] = None
     links: Optional[ResponseLinks] = None
     included: Optional[IncludedData] = None
     data: Optional[conlist(TransfersModel)] = None
     __properties = ["meta", "links", "included", "data"]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -79,15 +80,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> TransfersResponse:
         """Create an instance of TransfersResponse from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return TransfersResponse.parse_obj(obj)
 
         _obj = TransfersResponse.parse_obj(
             {
                 "meta": ResponseMetaData.from_dict(obj.get("meta")) if obj.get("meta") is not None else None,
                 "links": ResponseLinks.from_dict(obj.get("links")) if obj.get("links") is not None else None,
                 "included": IncludedData.from_dict(obj.get("included")) if obj.get("included") is not None else None,
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/venue_address.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_venues_address.py`

 * *Files 15% similar despite different names*

```diff
@@ -13,65 +13,66 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
-from typing import Optional
+from typing import Optional, Union
 
-from pydantic import BaseModel, Field, StrictFloat, StrictStr, constr
+from pydantic import BaseModel, Field, StrictFloat, StrictInt, StrictStr, constr
 
 
-class VenueAddress(BaseModel):
+class SeasonVenuesAddress(BaseModel):
     """
-    Street Address for the venue
+    Street Address for the season venues
     """
 
     address1: Optional[StrictStr] = Field(None, description="First line of the address")
     address2: Optional[StrictStr] = Field(None, description="Second line of the address")
     address3: Optional[StrictStr] = Field(None, description="Third line of the address")
     city: Optional[StrictStr] = Field(None, description="The city/suburb of the address")
     state: Optional[StrictStr] = Field(None, description="The state of the address")
     postal_code: Optional[StrictStr] = Field(None, alias="postalCode", description="The postal code for the address")
     country_code: Optional[constr(strict=True, max_length=3, min_length=3)] = Field(
         None,
         alias="countryCode",
         description="ISO Country code of the address.  We recommend you use ISO-3166-1:alpha3 (upper case) values where available.",
     )
-    longitude: Optional[StrictFloat] = None
-    latitude: Optional[StrictFloat] = None
+    longitude: Optional[Union[StrictFloat, StrictInt]] = None
+    latitude: Optional[Union[StrictFloat, StrictInt]] = None
     __properties = [
         "address1",
         "address2",
         "address3",
         "city",
         "state",
         "postalCode",
         "countryCode",
         "longitude",
         "latitude",
     ]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> VenueAddress:
-        """Create an instance of VenueAddress from a JSON string"""
+    def from_json(cls, json_str: str) -> SeasonVenuesAddress:
+        """Create an instance of SeasonVenuesAddress from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
     def to_dict(self):
         """Returns the dictionary representation of the model using alias"""
         _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)
         # set to None if address1 (nullable) is None
         # and __fields_set__ contains the field
@@ -117,23 +118,23 @@
         # and __fields_set__ contains the field
         if self.latitude is None and "latitude" in self.__fields_set__:
             _dict["latitude"] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> VenueAddress:
-        """Create an instance of VenueAddress from a dict"""
+    def from_dict(cls, obj: dict) -> SeasonVenuesAddress:
+        """Create an instance of SeasonVenuesAddress from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
-            return VenueAddress.parse_obj(obj)
+        if not isinstance(obj, dict):
+            return SeasonVenuesAddress.parse_obj(obj)
 
-        _obj = VenueAddress.parse_obj(
+        _obj = SeasonVenuesAddress.parse_obj(
             {
                 "address1": obj.get("address1"),
                 "address2": obj.get("address2"),
                 "address3": obj.get("address3"),
                 "city": obj.get("city"),
                 "state": obj.get("state"),
                 "postal_code": obj.get("postalCode"),
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/venue_historical_name.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/venue_historical_name.py`

 * *Files 2% similar despite different names*

```diff
@@ -14,15 +14,14 @@
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
 from datetime import date
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr
 
 
 class VenueHistoricalName(BaseModel):
     """
@@ -53,14 +52,16 @@
         "alternateNameLocal",
         "alternateNameLatin",
         "abbreviationLocal",
         "abbreviationLatin",
     ]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -120,15 +121,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> VenueHistoricalName:
         """Create an instance of VenueHistoricalName from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return VenueHistoricalName.parse_obj(obj)
 
         _obj = VenueHistoricalName.parse_obj(
             {
                 "date_start": obj.get("dateStart"),
                 "date_end": obj.get("dateEnd"),
                 "name_local": obj.get("nameLocal"),
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/venue_post_body.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/venue_put_body.py`

 * *Files 5% similar despite different names*

```diff
@@ -13,38 +13,36 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import List, Optional
 
 from pydantic import BaseModel, Field, StrictInt, StrictStr, conlist, constr, validator
 
 from atriumsports.datacore.openapi.models.social_media import SocialMedia
 from atriumsports.datacore.openapi.models.venue_address import VenueAddress
 from atriumsports.datacore.openapi.models.venue_historical_name import VenueHistoricalName
 
 
-class VenuePostBody(BaseModel):
+class VenuePutBody(BaseModel):
     """
-    VenuePostBody
+    VenuePutBody
     """
 
-    venue_id: Optional[StrictStr] = Field(None, alias="venueId", description="The unique identifier of the venue")
     site_id: Optional[StrictStr] = Field(None, alias="siteId", description="The site that this venue belongs to")
     abbreviation_local: Optional[constr(strict=True, max_length=30)] = Field(
         None,
         alias="abbreviationLocal",
         description="An abbreviation/short name in the [local](#section/Introduction/Character-Sets-and-Names) language",
     )
-    name_local: constr(strict=True, max_length=150) = Field(
-        ...,
+    name_local: Optional[constr(strict=True, max_length=150)] = Field(
+        None,
         alias="nameLocal",
         description="The name of the venue in the [local](#section/Introduction/Character-Sets-and-Names) language",
     )
     status: Optional[constr(strict=True, max_length=30)] = Field(
         "ACTIVE", description="Status >- `ACTIVE` Active >- `INACTIVE` Inactive >- `PENDING` Pending "
     )
     alternate_name_local: Optional[constr(strict=True, max_length=150)] = Field(
@@ -64,16 +62,16 @@
         None, alias="alternateNameLatin", description="The alternate name of the venue, in Latin characters"
     )
     country_code: Optional[constr(strict=True, max_length=3, min_length=3)] = Field(
         None,
         alias="countryCode",
         description="Country code of the venue. We recommend you use ISO-3166-1:alpha3 (upper case) values where available.",
     )
-    timezone: constr(strict=True, max_length=150) = Field(
-        ...,
+    timezone: Optional[constr(strict=True, max_length=150)] = Field(
+        None,
         description="Timezone of the venue.  The name of the zone as defined by the IANA TZ database. https://en.wikipedia.org/wiki/List_of_tz_database_time_zones",
     )
     address: Optional[VenueAddress] = None
     social: Optional[SocialMedia] = None
     capacity: Optional[StrictInt] = Field(
         None,
         description="This is the maximum number of people allowed for the venue in normal use. Certain events/configurations of the venue may cause this capacity to be increased/decreased - this is not reflected in this value.",
@@ -81,15 +79,14 @@
     historical_names: Optional[conlist(VenueHistoricalName)] = Field(
         None, alias="historicalNames", description="Array of venue historical names"
     )
     external_id: Optional[constr(strict=True, max_length=150)] = Field(
         None, alias="externalId", description="The Id of the data as set by the provider of the data"
     )
     __properties = [
-        "venueId",
         "siteId",
         "abbreviationLocal",
         "nameLocal",
         "status",
         "alternateNameLocal",
         "abbreviationLatin",
         "nameLatin",
@@ -100,44 +97,50 @@
         "social",
         "capacity",
         "historicalNames",
         "externalId",
     ]
 
     @validator("status")
-    def status_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("ACTIVE", "INACTIVE", "PENDING"):
+    def status_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("ACTIVE", "INACTIVE", "PENDING"):
             raise ValueError("must be one of enum values ('ACTIVE', 'INACTIVE', 'PENDING')")
-        return v
+        return value
 
     @validator("external_id")
-    def external_id_validate_regular_expression(cls, v):
-        if v is None:
-            return v
-        if not re.match(r"^[0-9A-Za-z\/_-]+$", v):
+    def external_id_validate_regular_expression(cls, value):
+        """Validates the regular expression"""
+        if value is None:
+            return value
+
+        if not re.match(r"^[0-9A-Za-z\/_-]+$", value):
             raise ValueError(r"must validate the regular expression /^[0-9A-Za-z\/_-]+$/")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> VenuePostBody:
-        """Create an instance of VenuePostBody from a JSON string"""
+    def from_json(cls, json_str: str) -> VenuePutBody:
+        """Create an instance of VenuePutBody from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
     def to_dict(self):
         """Returns the dictionary representation of the model using alias"""
         _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)
         # override the default output from pydantic by calling `to_dict()` of address
         if self.address:
@@ -211,25 +214,24 @@
         # and __fields_set__ contains the field
         if self.external_id is None and "external_id" in self.__fields_set__:
             _dict["externalId"] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> VenuePostBody:
-        """Create an instance of VenuePostBody from a dict"""
+    def from_dict(cls, obj: dict) -> VenuePutBody:
+        """Create an instance of VenuePutBody from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
-            return VenuePostBody.parse_obj(obj)
+        if not isinstance(obj, dict):
+            return VenuePutBody.parse_obj(obj)
 
-        _obj = VenuePostBody.parse_obj(
+        _obj = VenuePutBody.parse_obj(
             {
-                "venue_id": obj.get("venueId"),
                 "site_id": obj.get("siteId"),
                 "abbreviation_local": obj.get("abbreviationLocal"),
                 "name_local": obj.get("nameLocal"),
                 "status": obj.get("status") if obj.get("status") is not None else "ACTIVE",
                 "alternate_name_local": obj.get("alternateNameLocal"),
                 "abbreviation_latin": obj.get("abbreviationLatin"),
                 "name_latin": obj.get("nameLatin"),
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/venue_put_body.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/venues_model.py`

 * *Files 14% similar despite different names*

```diff
@@ -13,30 +13,38 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
+from datetime import datetime
 from typing import List, Optional
 
 from pydantic import BaseModel, Field, StrictInt, StrictStr, conlist, constr, validator
 
 from atriumsports.datacore.openapi.models.social_media import SocialMedia
 from atriumsports.datacore.openapi.models.venue_address import VenueAddress
 from atriumsports.datacore.openapi.models.venue_historical_name import VenueHistoricalName
+from atriumsports.datacore.openapi.models.venues_model_organization import VenuesModelOrganization
+from atriumsports.datacore.openapi.models.venues_model_site import VenuesModelSite
 
 
-class VenuePutBody(BaseModel):
+class VenuesModel(BaseModel):
     """
-    VenuePutBody
+    VenuesModel
     """
 
+    venue_id: Optional[StrictStr] = Field(None, alias="venueId", description="The unique identifier of the venue")
     site_id: Optional[StrictStr] = Field(None, alias="siteId", description="The site that this venue belongs to")
+    site: Optional[VenuesModelSite] = None
+    organization_id: Optional[StrictStr] = Field(
+        None, alias="organizationId", description="The unique identifier of the organization"
+    )
+    organization: Optional[VenuesModelOrganization] = None
     abbreviation_local: Optional[constr(strict=True, max_length=30)] = Field(
         None,
         alias="abbreviationLocal",
         description="An abbreviation/short name in the [local](#section/Introduction/Character-Sets-and-Names) language",
     )
     name_local: Optional[constr(strict=True, max_length=150)] = Field(
         None,
@@ -79,68 +87,101 @@
     )
     historical_names: Optional[conlist(VenueHistoricalName)] = Field(
         None, alias="historicalNames", description="Array of venue historical names"
     )
     external_id: Optional[constr(strict=True, max_length=150)] = Field(
         None, alias="externalId", description="The Id of the data as set by the provider of the data"
     )
+    master_venue_id: Optional[StrictStr] = Field(
+        None, alias="masterVenueId", description="The unique identifier of the master venue"
+    )
+    updated: Optional[datetime] = Field(None, description="Date/time last modified. In UTC")
+    added: Optional[datetime] = Field(None, description="Date/time added. In UTC")
     __properties = [
+        "venueId",
         "siteId",
+        "site",
+        "organizationId",
+        "organization",
         "abbreviationLocal",
         "nameLocal",
         "status",
         "alternateNameLocal",
         "abbreviationLatin",
         "nameLatin",
         "alternateNameLatin",
         "countryCode",
         "timezone",
         "address",
         "social",
         "capacity",
         "historicalNames",
         "externalId",
+        "masterVenueId",
+        "updated",
+        "added",
     ]
 
     @validator("status")
-    def status_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("ACTIVE", "INACTIVE", "PENDING"):
+    def status_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("ACTIVE", "INACTIVE", "PENDING"):
             raise ValueError("must be one of enum values ('ACTIVE', 'INACTIVE', 'PENDING')")
-        return v
+        return value
 
     @validator("external_id")
-    def external_id_validate_regular_expression(cls, v):
-        if v is None:
-            return v
-        if not re.match(r"^[0-9A-Za-z\/_-]+$", v):
+    def external_id_validate_regular_expression(cls, value):
+        """Validates the regular expression"""
+        if value is None:
+            return value
+
+        if not re.match(r"^[0-9A-Za-z\/_-]+$", value):
             raise ValueError(r"must validate the regular expression /^[0-9A-Za-z\/_-]+$/")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> VenuePutBody:
-        """Create an instance of VenuePutBody from a JSON string"""
+    def from_json(cls, json_str: str) -> VenuesModel:
+        """Create an instance of VenuesModel from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
     def to_dict(self):
         """Returns the dictionary representation of the model using alias"""
-        _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)
+        _dict = self.dict(
+            by_alias=True,
+            exclude={
+                "organization_id",
+                "master_venue_id",
+                "updated",
+                "added",
+            },
+            exclude_none=True,
+        )
+        # override the default output from pydantic by calling `to_dict()` of site
+        if self.site:
+            _dict["site"] = self.site.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of organization
+        if self.organization:
+            _dict["organization"] = self.organization.to_dict()
         # override the default output from pydantic by calling `to_dict()` of address
         if self.address:
             _dict["address"] = self.address.to_dict()
         # override the default output from pydantic by calling `to_dict()` of social
         if self.social:
             _dict["social"] = self.social.to_dict()
         # override the default output from pydantic by calling `to_dict()` of each item in historical_names (list)
@@ -209,25 +250,31 @@
         # and __fields_set__ contains the field
         if self.external_id is None and "external_id" in self.__fields_set__:
             _dict["externalId"] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> VenuePutBody:
-        """Create an instance of VenuePutBody from a dict"""
+    def from_dict(cls, obj: dict) -> VenuesModel:
+        """Create an instance of VenuesModel from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
-            return VenuePutBody.parse_obj(obj)
+        if not isinstance(obj, dict):
+            return VenuesModel.parse_obj(obj)
 
-        _obj = VenuePutBody.parse_obj(
+        _obj = VenuesModel.parse_obj(
             {
+                "venue_id": obj.get("venueId"),
                 "site_id": obj.get("siteId"),
+                "site": VenuesModelSite.from_dict(obj.get("site")) if obj.get("site") is not None else None,
+                "organization_id": obj.get("organizationId"),
+                "organization": VenuesModelOrganization.from_dict(obj.get("organization"))
+                if obj.get("organization") is not None
+                else None,
                 "abbreviation_local": obj.get("abbreviationLocal"),
                 "name_local": obj.get("nameLocal"),
                 "status": obj.get("status") if obj.get("status") is not None else "ACTIVE",
                 "alternate_name_local": obj.get("alternateNameLocal"),
                 "abbreviation_latin": obj.get("abbreviationLatin"),
                 "name_latin": obj.get("nameLatin"),
                 "alternate_name_latin": obj.get("alternateNameLatin"),
@@ -236,10 +283,13 @@
                 "address": VenueAddress.from_dict(obj.get("address")) if obj.get("address") is not None else None,
                 "social": SocialMedia.from_dict(obj.get("social")) if obj.get("social") is not None else None,
                 "capacity": obj.get("capacity"),
                 "historical_names": [VenueHistoricalName.from_dict(_item) for _item in obj.get("historicalNames")]
                 if obj.get("historicalNames") is not None
                 else None,
                 "external_id": obj.get("externalId"),
+                "master_venue_id": obj.get("masterVenueId"),
+                "updated": obj.get("updated"),
+                "added": obj.get("added"),
             }
         )
         return _obj
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/venues_model.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/video_files_model.py`

 * *Files 19% similar despite different names*

```diff
@@ -14,277 +14,284 @@
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
 from datetime import datetime
-from inspect import getfullargspec
-from typing import List, Optional
+from typing import Optional, Union
 
-from pydantic import BaseModel, Field, StrictInt, StrictStr, conlist, constr, validator
+from pydantic import BaseModel, Field, StrictFloat, StrictInt, StrictStr, constr, validator
 
-from atriumsports.datacore.openapi.models.social_media import SocialMedia
-from atriumsports.datacore.openapi.models.venue_address import VenueAddress
-from atriumsports.datacore.openapi.models.venue_historical_name import VenueHistoricalName
-from atriumsports.datacore.openapi.models.venues_model_organization import VenuesModelOrganization
-from atriumsports.datacore.openapi.models.venues_model_site import VenuesModelSite
+from atriumsports.datacore.openapi.models.fixture_progressions_model_fixture import FixtureProgressionsModelFixture
+from atriumsports.datacore.openapi.models.video_files_model_organization import VideoFilesModelOrganization
 
 
-class VenuesModel(BaseModel):
+class VideoFilesModel(BaseModel):
     """
-    VenuesModel
+    VideoFilesModel
     """
 
-    venue_id: Optional[StrictStr] = Field(None, alias="venueId", description="The unique identifier of the venue")
-    site_id: Optional[StrictStr] = Field(None, alias="siteId", description="The site that this venue belongs to")
-    site: Optional[VenuesModelSite] = None
+    video_id: Optional[StrictStr] = Field(None, alias="videoId", description="The unique identifier of the video")
     organization_id: Optional[StrictStr] = Field(
         None, alias="organizationId", description="The unique identifier of the organization"
     )
-    organization: Optional[VenuesModelOrganization] = None
-    abbreviation_local: Optional[constr(strict=True, max_length=30)] = Field(
+    organization: Optional[VideoFilesModelOrganization] = None
+    provider: Optional[constr(strict=True, max_length=100)] = Field(
+        None, description="The code for the provider of the file"
+    )
+    locale: Optional[constr(strict=True, max_length=5, min_length=5)] = Field(
+        None, description="The locale of the video"
+    )
+    source_number: Optional[StrictInt] = Field(
+        1,
+        alias="sourceNumber",
+        description="Unique identifier for the video source. This is unique for the provider/fixtureId/locale combination.  Unless the provider is supplying multiple sources per fixture/locale then this is normally 1.",
+    )
+    fixture_id: Optional[StrictStr] = Field(None, alias="fixtureId", description="The unique identifier of the fixture")
+    fixture: Optional[FixtureProgressionsModelFixture] = None
+    resolution: Optional[constr(strict=True, max_length=30)] = Field(
         None,
-        alias="abbreviationLocal",
-        description="An abbreviation/short name in the [local](#section/Introduction/Character-Sets-and-Names) language",
+        description="The resolution of the video input >- `1080` 1920 x 1080 >- `288` 512 x 288 >- `720` 1280 x 720 ",
     )
-    name_local: Optional[constr(strict=True, max_length=150)] = Field(
-        None,
-        alias="nameLocal",
-        description="The name of the venue in the [local](#section/Introduction/Character-Sets-and-Names) language",
-    )
-    status: Optional[constr(strict=True, max_length=30)] = Field(
-        "ACTIVE", description="Status >- `ACTIVE` Active >- `INACTIVE` Inactive >- `PENDING` Pending "
-    )
-    alternate_name_local: Optional[constr(strict=True, max_length=150)] = Field(
-        None, alias="alternateNameLocal", description="The alternate name of the venue, in Local Language"
+    name: Optional[constr(strict=True, max_length=200)] = Field(
+        None, description="The name/description of the video file"
     )
-    abbreviation_latin: Optional[constr(strict=True, max_length=30)] = Field(
+    feed_type: Optional[constr(strict=True, max_length=30)] = Field(
         None,
-        alias="abbreviationLatin",
-        description="An abbreviation/short name in [latin](#section/Introduction/Character-Sets-and-Names) characters",
+        alias="feedType",
+        description="Type of video input >- `ADDITIONAL_ANGLE` Additional angle >- `LOW_LATENCY` Low Latency >- `PRIMARY` Primary ",
     )
-    name_latin: Optional[constr(strict=True, max_length=150)] = Field(
+    content: Optional[constr(strict=True, max_length=30)] = Field(
         None,
-        alias="nameLatin",
-        description="The name of the venue in [latin](#section/Introduction/Character-Sets-and-Names) characters",
+        description="Content of the stream >- `CLEAN` Output signal is the same as the input signal >- `PROGRAM` Score overlays and other enhancements have been added to the stream ",
     )
-    alternate_name_latin: Optional[constr(strict=True, max_length=150)] = Field(
-        None, alias="alternateNameLatin", description="The alternate name of the venue, in Latin characters"
-    )
-    country_code: Optional[constr(strict=True, max_length=3, min_length=3)] = Field(
+    fps: Optional[StrictInt] = Field(25, description="fps for the video stream")
+    origin: Optional[constr(strict=True, max_length=30)] = Field(
         None,
-        alias="countryCode",
-        description="Country code of the venue. We recommend you use ISO-3166-1:alpha3 (upper case) values where available.",
+        description="The origin of the video file >- `STREAM` Streamed >- `UPLOAD` Uploaded >- `VENUE` Recorded in venue ",
     )
-    timezone: Optional[constr(strict=True, max_length=150)] = Field(
-        None,
-        description="Timezone of the venue.  The name of the zone as defined by the IANA TZ database. https://en.wikipedia.org/wiki/List_of_tz_database_time_zones",
+    format: Optional[constr(strict=True, max_length=30)] = Field(
+        None, description="The format of the video file >- `HLS` A HLS play list >- `MP4` One MP4 file "
     )
-    address: Optional[VenueAddress] = None
-    social: Optional[SocialMedia] = None
-    capacity: Optional[StrictInt] = Field(
+    storage_provider: Optional[constr(strict=True, max_length=30)] = Field(
         None,
-        description="This is the maximum number of people allowed for the venue in normal use. Certain events/configurations of the venue may cause this capacity to be increased/decreased - this is not reflected in this value.",
+        alias="storageProvider",
+        description="Where the video file is stored? >- `5STREAM` 5stream >- `KEEMOTION` Keemotion >- `SYNERGY` Synergy ",
     )
-    historical_names: Optional[conlist(VenueHistoricalName)] = Field(
-        None, alias="historicalNames", description="Array of venue historical names"
+    size: Optional[Union[StrictFloat, StrictInt]] = Field(
+        None, description="Size (Mb) of the video (only given if a single file)"
     )
-    external_id: Optional[constr(strict=True, max_length=150)] = Field(
-        None, alias="externalId", description="The Id of the data as set by the provider of the data"
+    length: Optional[Union[StrictFloat, StrictInt]] = Field(None, description="Lenth (mins) of the video")
+    encoding: Optional[constr(strict=True, max_length=30)] = Field(
+        None, description="How is the video/audio encoded. codecs etc."
     )
-    master_venue_id: Optional[StrictStr] = Field(
-        None, alias="masterVenueId", description="The unique identifier of the master venue"
+    status: Optional[constr(strict=True, max_length=30)] = Field(
+        None,
+        description="What is the status of the file? >- `AVAILABLE` Available for access >- `BUILDABLE` Not currently available - but can be built on request >- `PENDING` Being added - some parts may be available ",
     )
+    start_time: Optional[datetime] = Field(None, alias="startTime", description="The time this recording started (UTC)")
+    expiry: Optional[datetime] = Field(None, description="When does this file expire? (UTC)")
     updated: Optional[datetime] = Field(None, description="Date/time last modified. In UTC")
     added: Optional[datetime] = Field(None, description="Date/time added. In UTC")
     __properties = [
-        "venueId",
-        "siteId",
-        "site",
+        "videoId",
         "organizationId",
         "organization",
-        "abbreviationLocal",
-        "nameLocal",
+        "provider",
+        "locale",
+        "sourceNumber",
+        "fixtureId",
+        "fixture",
+        "resolution",
+        "name",
+        "feedType",
+        "content",
+        "fps",
+        "origin",
+        "format",
+        "storageProvider",
+        "size",
+        "length",
+        "encoding",
         "status",
-        "alternateNameLocal",
-        "abbreviationLatin",
-        "nameLatin",
-        "alternateNameLatin",
-        "countryCode",
-        "timezone",
-        "address",
-        "social",
-        "capacity",
-        "historicalNames",
-        "externalId",
-        "masterVenueId",
+        "startTime",
+        "expiry",
         "updated",
         "added",
     ]
 
+    @validator("locale")
+    def locale_validate_regular_expression(cls, value):
+        """Validates the regular expression"""
+        if value is None:
+            return value
+
+        if not re.match(r"^[a-z]{2,2}-[A-Z]{2,2}$", value):
+            raise ValueError(r"must validate the regular expression /^[a-z]{2,2}-[A-Z]{2,2}$/")
+        return value
+
+    @validator("resolution")
+    def resolution_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("288", "720", "1080"):
+            raise ValueError("must be one of enum values ('288', '720', '1080')")
+        return value
+
+    @validator("feed_type")
+    def feed_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("PRIMARY", "ADDITIONAL_ANGLE", "LOW_LATENCY"):
+            raise ValueError("must be one of enum values ('PRIMARY', 'ADDITIONAL_ANGLE', 'LOW_LATENCY')")
+        return value
+
+    @validator("content")
+    def content_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("CLEAN", "PROGRAM"):
+            raise ValueError("must be one of enum values ('CLEAN', 'PROGRAM')")
+        return value
+
+    @validator("origin")
+    def origin_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("STREAM", "VENUE", "UPLOAD"):
+            raise ValueError("must be one of enum values ('STREAM', 'VENUE', 'UPLOAD')")
+        return value
+
+    @validator("format")
+    def format_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("HLS", "MP4"):
+            raise ValueError("must be one of enum values ('HLS', 'MP4')")
+        return value
+
+    @validator("storage_provider")
+    def storage_provider_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("5STREAM", "KEEMOTION", "SYNERGY"):
+            raise ValueError("must be one of enum values ('5STREAM', 'KEEMOTION', 'SYNERGY')")
+        return value
+
     @validator("status")
-    def status_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("ACTIVE", "INACTIVE", "PENDING"):
-            raise ValueError("must be one of enum values ('ACTIVE', 'INACTIVE', 'PENDING')")
-        return v
-
-    @validator("external_id")
-    def external_id_validate_regular_expression(cls, v):
-        if v is None:
-            return v
-        if not re.match(r"^[0-9A-Za-z\/_-]+$", v):
-            raise ValueError(r"must validate the regular expression /^[0-9A-Za-z\/_-]+$/")
-        return v
+    def status_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("AVAILABLE", "BUILDABLE", "PENDING"):
+            raise ValueError("must be one of enum values ('AVAILABLE', 'BUILDABLE', 'PENDING')")
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> VenuesModel:
-        """Create an instance of VenuesModel from a JSON string"""
+    def from_json(cls, json_str: str) -> VideoFilesModel:
+        """Create an instance of VideoFilesModel from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
     def to_dict(self):
         """Returns the dictionary representation of the model using alias"""
         _dict = self.dict(
             by_alias=True,
             exclude={
                 "organization_id",
-                "master_venue_id",
                 "updated",
                 "added",
             },
             exclude_none=True,
         )
-        # override the default output from pydantic by calling `to_dict()` of site
-        if self.site:
-            _dict["site"] = self.site.to_dict()
         # override the default output from pydantic by calling `to_dict()` of organization
         if self.organization:
             _dict["organization"] = self.organization.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of address
-        if self.address:
-            _dict["address"] = self.address.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of social
-        if self.social:
-            _dict["social"] = self.social.to_dict()
-        # override the default output from pydantic by calling `to_dict()` of each item in historical_names (list)
-        _items = []
-        if self.historical_names:
-            for _item in self.historical_names:
-                if _item:
-                    _items.append(_item.to_dict())
-            _dict["historicalNames"] = _items
-        # set to None if site_id (nullable) is None
-        # and __fields_set__ contains the field
-        if self.site_id is None and "site_id" in self.__fields_set__:
-            _dict["siteId"] = None
-
-        # set to None if abbreviation_local (nullable) is None
-        # and __fields_set__ contains the field
-        if self.abbreviation_local is None and "abbreviation_local" in self.__fields_set__:
-            _dict["abbreviationLocal"] = None
-
-        # set to None if alternate_name_local (nullable) is None
-        # and __fields_set__ contains the field
-        if self.alternate_name_local is None and "alternate_name_local" in self.__fields_set__:
-            _dict["alternateNameLocal"] = None
-
-        # set to None if abbreviation_latin (nullable) is None
-        # and __fields_set__ contains the field
-        if self.abbreviation_latin is None and "abbreviation_latin" in self.__fields_set__:
-            _dict["abbreviationLatin"] = None
-
-        # set to None if name_latin (nullable) is None
-        # and __fields_set__ contains the field
-        if self.name_latin is None and "name_latin" in self.__fields_set__:
-            _dict["nameLatin"] = None
-
-        # set to None if alternate_name_latin (nullable) is None
-        # and __fields_set__ contains the field
-        if self.alternate_name_latin is None and "alternate_name_latin" in self.__fields_set__:
-            _dict["alternateNameLatin"] = None
-
-        # set to None if country_code (nullable) is None
-        # and __fields_set__ contains the field
-        if self.country_code is None and "country_code" in self.__fields_set__:
-            _dict["countryCode"] = None
-
-        # set to None if address (nullable) is None
-        # and __fields_set__ contains the field
-        if self.address is None and "address" in self.__fields_set__:
-            _dict["address"] = None
-
-        # set to None if social (nullable) is None
-        # and __fields_set__ contains the field
-        if self.social is None and "social" in self.__fields_set__:
-            _dict["social"] = None
-
-        # set to None if capacity (nullable) is None
+        # override the default output from pydantic by calling `to_dict()` of fixture
+        if self.fixture:
+            _dict["fixture"] = self.fixture.to_dict()
+        # set to None if size (nullable) is None
         # and __fields_set__ contains the field
-        if self.capacity is None and "capacity" in self.__fields_set__:
-            _dict["capacity"] = None
+        if self.size is None and "size" in self.__fields_set__:
+            _dict["size"] = None
 
-        # set to None if historical_names (nullable) is None
+        # set to None if length (nullable) is None
         # and __fields_set__ contains the field
-        if self.historical_names is None and "historical_names" in self.__fields_set__:
-            _dict["historicalNames"] = None
+        if self.length is None and "length" in self.__fields_set__:
+            _dict["length"] = None
 
-        # set to None if external_id (nullable) is None
+        # set to None if expiry (nullable) is None
         # and __fields_set__ contains the field
-        if self.external_id is None and "external_id" in self.__fields_set__:
-            _dict["externalId"] = None
+        if self.expiry is None and "expiry" in self.__fields_set__:
+            _dict["expiry"] = None
 
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> VenuesModel:
-        """Create an instance of VenuesModel from a dict"""
+    def from_dict(cls, obj: dict) -> VideoFilesModel:
+        """Create an instance of VideoFilesModel from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
-            return VenuesModel.parse_obj(obj)
+        if not isinstance(obj, dict):
+            return VideoFilesModel.parse_obj(obj)
 
-        _obj = VenuesModel.parse_obj(
+        _obj = VideoFilesModel.parse_obj(
             {
-                "venue_id": obj.get("venueId"),
-                "site_id": obj.get("siteId"),
-                "site": VenuesModelSite.from_dict(obj.get("site")) if obj.get("site") is not None else None,
+                "video_id": obj.get("videoId"),
                 "organization_id": obj.get("organizationId"),
-                "organization": VenuesModelOrganization.from_dict(obj.get("organization"))
+                "organization": VideoFilesModelOrganization.from_dict(obj.get("organization"))
                 if obj.get("organization") is not None
                 else None,
-                "abbreviation_local": obj.get("abbreviationLocal"),
-                "name_local": obj.get("nameLocal"),
-                "status": obj.get("status") if obj.get("status") is not None else "ACTIVE",
-                "alternate_name_local": obj.get("alternateNameLocal"),
-                "abbreviation_latin": obj.get("abbreviationLatin"),
-                "name_latin": obj.get("nameLatin"),
-                "alternate_name_latin": obj.get("alternateNameLatin"),
-                "country_code": obj.get("countryCode"),
-                "timezone": obj.get("timezone"),
-                "address": VenueAddress.from_dict(obj.get("address")) if obj.get("address") is not None else None,
-                "social": SocialMedia.from_dict(obj.get("social")) if obj.get("social") is not None else None,
-                "capacity": obj.get("capacity"),
-                "historical_names": [VenueHistoricalName.from_dict(_item) for _item in obj.get("historicalNames")]
-                if obj.get("historicalNames") is not None
+                "provider": obj.get("provider"),
+                "locale": obj.get("locale"),
+                "source_number": obj.get("sourceNumber") if obj.get("sourceNumber") is not None else 1,
+                "fixture_id": obj.get("fixtureId"),
+                "fixture": FixtureProgressionsModelFixture.from_dict(obj.get("fixture"))
+                if obj.get("fixture") is not None
                 else None,
-                "external_id": obj.get("externalId"),
-                "master_venue_id": obj.get("masterVenueId"),
+                "resolution": obj.get("resolution"),
+                "name": obj.get("name"),
+                "feed_type": obj.get("feedType"),
+                "content": obj.get("content"),
+                "fps": obj.get("fps") if obj.get("fps") is not None else 25,
+                "origin": obj.get("origin"),
+                "format": obj.get("format"),
+                "storage_provider": obj.get("storageProvider"),
+                "size": obj.get("size"),
+                "length": obj.get("length"),
+                "encoding": obj.get("encoding"),
+                "status": obj.get("status"),
+                "start_time": obj.get("startTime"),
+                "expiry": obj.get("expiry"),
                 "updated": obj.get("updated"),
                 "added": obj.get("added"),
             }
         )
         return _obj
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/venues_model_organization.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/venues_model_organization.py`

 * *Files 8% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr, validator
 
 
 class VenuesModelOrganization(BaseModel):
     """
@@ -29,22 +28,26 @@
     """
 
     resource_type: Optional[StrictStr] = Field(None, alias="resourceType")
     id: Optional[StrictStr] = Field(None, description="Unique identifier for this resource")
     __properties = ["resourceType", "id"]
 
     @validator("resource_type")
-    def resource_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("organizations"):
+    def resource_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("organizations"):
             raise ValueError("must be one of enum values ('organizations')")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -64,12 +67,12 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> VenuesModelOrganization:
         """Create an instance of VenuesModelOrganization from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return VenuesModelOrganization.parse_obj(obj)
 
         _obj = VenuesModelOrganization.parse_obj({"resource_type": obj.get("resourceType"), "id": obj.get("id")})
         return _obj
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/venues_model_site.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/video_stream_local_put_body.py`

 * *Files 27% similar despite different names*

```diff
@@ -13,63 +13,85 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
-from pydantic import BaseModel, Field, StrictStr, validator
+from pydantic import BaseModel, Field, StrictInt, StrictStr, constr, validator
 
 
-class VenuesModelSite(BaseModel):
+class VideoStreamLocalPutBody(BaseModel):
     """
-    The site that this venue belongs to
+    VideoStreamLocalPutBody
     """
 
-    resource_type: Optional[StrictStr] = Field(None, alias="resourceType")
-    id: Optional[StrictStr] = Field(None, description="Unique identifier for this resource")
-    __properties = ["resourceType", "id"]
-
-    @validator("resource_type")
-    def resource_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("sites"):
-            raise ValueError("must be one of enum values ('sites')")
-        return v
+    fixture_id: Optional[StrictStr] = Field(None, alias="fixtureId", description="The unique identifier of the fixture")
+    provider: Optional[constr(strict=True, max_length=100)] = Field(
+        None, description="The code for the provider of the file"
+    )
+    source_number: Optional[StrictInt] = Field(
+        1,
+        alias="sourceNumber",
+        description="Unique identifier for the video source. This is unique for the provider/fixtureId/locale combination.  Unless the provider is supplying multiple sources per fixture/locale then this is normally 1.",
+    )
+    format: Optional[constr(strict=True, max_length=30)] = Field(
+        None, description="The format of the video file >- `HLS` A HLS play list >- `MP4` One MP4 file "
+    )
+    url: Optional[constr(strict=True, max_length=200)] = Field(None, description="The URL where the file can be found")
+    __properties = ["fixtureId", "provider", "sourceNumber", "format", "url"]
+
+    @validator("format")
+    def format_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("HLS", "MP4"):
+            raise ValueError("must be one of enum values ('HLS', 'MP4')")
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> VenuesModelSite:
-        """Create an instance of VenuesModelSite from a JSON string"""
+    def from_json(cls, json_str: str) -> VideoStreamLocalPutBody:
+        """Create an instance of VideoStreamLocalPutBody from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
     def to_dict(self):
         """Returns the dictionary representation of the model using alias"""
         _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> VenuesModelSite:
-        """Create an instance of VenuesModelSite from a dict"""
+    def from_dict(cls, obj: dict) -> VideoStreamLocalPutBody:
+        """Create an instance of VideoStreamLocalPutBody from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
-            return VenuesModelSite.parse_obj(obj)
+        if not isinstance(obj, dict):
+            return VideoStreamLocalPutBody.parse_obj(obj)
 
-        _obj = VenuesModelSite.parse_obj({"resource_type": obj.get("resourceType"), "id": obj.get("id")})
+        _obj = VideoStreamLocalPutBody.parse_obj(
+            {
+                "fixture_id": obj.get("fixtureId"),
+                "provider": obj.get("provider"),
+                "source_number": obj.get("sourceNumber") if obj.get("sourceNumber") is not None else 1,
+                "format": obj.get("format"),
+                "url": obj.get("url"),
+            }
+        )
         return _obj
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/venues_response.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/video_files_response.py`

 * *Files 13% similar despite different names*

```diff
@@ -13,51 +13,52 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import List, Optional
 
 from pydantic import BaseModel, conlist
 
 from atriumsports.datacore.openapi.models.included_data import IncludedData
 from atriumsports.datacore.openapi.models.response_links import ResponseLinks
 from atriumsports.datacore.openapi.models.response_meta_data import ResponseMetaData
-from atriumsports.datacore.openapi.models.venues_model import VenuesModel
+from atriumsports.datacore.openapi.models.video_files_model import VideoFilesModel
 
 
-class VenuesResponse(BaseModel):
+class VideoFilesResponse(BaseModel):
     """
-    VenuesResponse
+    VideoFilesResponse
     """
 
     meta: Optional[ResponseMetaData] = None
     links: Optional[ResponseLinks] = None
     included: Optional[IncludedData] = None
-    data: Optional[conlist(VenuesModel)] = None
+    data: Optional[conlist(VideoFilesModel)] = None
     __properties = ["meta", "links", "included", "data"]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> VenuesResponse:
-        """Create an instance of VenuesResponse from a JSON string"""
+    def from_json(cls, json_str: str) -> VideoFilesResponse:
+        """Create an instance of VideoFilesResponse from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
     def to_dict(self):
         """Returns the dictionary representation of the model using alias"""
         _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)
         # override the default output from pydantic by calling `to_dict()` of meta
         if self.meta:
@@ -74,26 +75,26 @@
             for _item in self.data:
                 if _item:
                     _items.append(_item.to_dict())
             _dict["data"] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> VenuesResponse:
-        """Create an instance of VenuesResponse from a dict"""
+    def from_dict(cls, obj: dict) -> VideoFilesResponse:
+        """Create an instance of VideoFilesResponse from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
-            return VenuesResponse.parse_obj(obj)
+        if not isinstance(obj, dict):
+            return VideoFilesResponse.parse_obj(obj)
 
-        _obj = VenuesResponse.parse_obj(
+        _obj = VideoFilesResponse.parse_obj(
             {
                 "meta": ResponseMetaData.from_dict(obj.get("meta")) if obj.get("meta") is not None else None,
                 "links": ResponseLinks.from_dict(obj.get("links")) if obj.get("links") is not None else None,
                 "included": IncludedData.from_dict(obj.get("included")) if obj.get("included") is not None else None,
-                "data": [VenuesModel.from_dict(_item) for _item in obj.get("data")]
+                "data": [VideoFilesModel.from_dict(_item) for _item in obj.get("data")]
                 if obj.get("data") is not None
                 else None,
             }
         )
         return _obj
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/video_file_post_body.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/video_file_post_body.py`

 * *Files 6% similar despite different names*

```diff
@@ -14,16 +14,15 @@
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
 from datetime import datetime
-from inspect import getfullargspec
-from typing import Optional
+from typing import Optional, Union
 
 from pydantic import BaseModel, Field, StrictFloat, StrictInt, StrictStr, constr, validator
 
 
 class VideoFilePostBody(BaseModel):
     """
     VideoFilePostBody
@@ -63,16 +62,18 @@
         None, description="The format of the video file >- `HLS` A HLS play list >- `MP4` One MP4 file "
     )
     storage_provider: Optional[constr(strict=True, max_length=30)] = Field(
         None,
         alias="storageProvider",
         description="Where the video file is stored? >- `5STREAM` 5stream >- `KEEMOTION` Keemotion >- `SYNERGY` Synergy ",
     )
-    size: Optional[StrictFloat] = Field(None, description="Size (Mb) of the video (only given if a single file)")
-    length: Optional[StrictFloat] = Field(None, description="Lenth (mins) of the video")
+    size: Optional[Union[StrictFloat, StrictInt]] = Field(
+        None, description="Size (Mb) of the video (only given if a single file)"
+    )
+    length: Optional[Union[StrictFloat, StrictInt]] = Field(None, description="Lenth (mins) of the video")
     encoding: Optional[constr(strict=True, max_length=30)] = Field(
         None, description="How is the video/audio encoded. codecs etc."
     )
     url: constr(strict=True, max_length=200) = Field(..., description="The URL where the file can be found")
     status: Optional[constr(strict=True, max_length=30)] = Field(
         None,
         description="What is the status of the file? >- `AVAILABLE` Available for access >- `BUILDABLE` Not currently available - but can be built on request >- `PENDING` Being added - some parts may be available ",
@@ -99,72 +100,84 @@
         "url",
         "status",
         "startTime",
         "expiry",
     ]
 
     @validator("locale")
-    def locale_validate_regular_expression(cls, v):
-        if v is None:
-            return v
-        if not re.match(r"^[a-z]{2,2}-[A-Z]{2,2}$", v):
+    def locale_validate_regular_expression(cls, value):
+        """Validates the regular expression"""
+        if not re.match(r"^[a-z]{2,2}-[A-Z]{2,2}$", value):
             raise ValueError(r"must validate the regular expression /^[a-z]{2,2}-[A-Z]{2,2}$/")
-        return v
+        return value
 
     @validator("resolution")
-    def resolution_validate_enum(cls, v):
-        if v not in ("288", "720", "1080"):
+    def resolution_validate_enum(cls, value):
+        """Validates the enum"""
+        if value not in ("288", "720", "1080"):
             raise ValueError("must be one of enum values ('288', '720', '1080')")
-        return v
+        return value
 
     @validator("feed_type")
-    def feed_type_validate_enum(cls, v):
-        if v not in ("PRIMARY", "ADDITIONAL_ANGLE", "LOW_LATENCY"):
+    def feed_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value not in ("PRIMARY", "ADDITIONAL_ANGLE", "LOW_LATENCY"):
             raise ValueError("must be one of enum values ('PRIMARY', 'ADDITIONAL_ANGLE', 'LOW_LATENCY')")
-        return v
+        return value
 
     @validator("content")
-    def content_validate_enum(cls, v):
-        if v not in ("CLEAN", "PROGRAM"):
+    def content_validate_enum(cls, value):
+        """Validates the enum"""
+        if value not in ("CLEAN", "PROGRAM"):
             raise ValueError("must be one of enum values ('CLEAN', 'PROGRAM')")
-        return v
+        return value
 
     @validator("origin")
-    def origin_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("STREAM", "VENUE", "UPLOAD"):
+    def origin_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("STREAM", "VENUE", "UPLOAD"):
             raise ValueError("must be one of enum values ('STREAM', 'VENUE', 'UPLOAD')")
-        return v
+        return value
 
     @validator("format")
-    def format_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("HLS", "MP4"):
+    def format_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("HLS", "MP4"):
             raise ValueError("must be one of enum values ('HLS', 'MP4')")
-        return v
+        return value
 
     @validator("storage_provider")
-    def storage_provider_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("5STREAM", "KEEMOTION", "SYNERGY"):
+    def storage_provider_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("5STREAM", "KEEMOTION", "SYNERGY"):
             raise ValueError("must be one of enum values ('5STREAM', 'KEEMOTION', 'SYNERGY')")
-        return v
+        return value
 
     @validator("status")
-    def status_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("AVAILABLE", "BUILDABLE", "PENDING"):
+    def status_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("AVAILABLE", "BUILDABLE", "PENDING"):
             raise ValueError("must be one of enum values ('AVAILABLE', 'BUILDABLE', 'PENDING')")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -199,15 +212,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> VideoFilePostBody:
         """Create an instance of VideoFilePostBody from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return VideoFilePostBody.parse_obj(obj)
 
         _obj = VideoFilePostBody.parse_obj(
             {
                 "video_id": obj.get("videoId"),
                 "provider": obj.get("provider"),
                 "locale": obj.get("locale"),
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/video_files_download_model.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/video_files_download_model.py`

 * *Files 4% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr, constr
 
 
 class VideoFilesDownloadModel(BaseModel):
     """
@@ -29,14 +28,16 @@
     """
 
     video_id: Optional[StrictStr] = Field(None, alias="videoId", description="The unique identifier of the video")
     url: Optional[constr(strict=True, max_length=200)] = Field(None, description="The URL where the file can be found")
     __properties = ["videoId", "url"]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -63,12 +64,12 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> VideoFilesDownloadModel:
         """Create an instance of VideoFilesDownloadModel from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return VideoFilesDownloadModel.parse_obj(obj)
 
         _obj = VideoFilesDownloadModel.parse_obj({"video_id": obj.get("videoId"), "url": obj.get("url")})
         return _obj
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/video_files_download_response.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/video_files_download_response.py`

 * *Files 2% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import List, Optional
 
 from pydantic import BaseModel, conlist
 
 from atriumsports.datacore.openapi.models.included_data import IncludedData
 from atriumsports.datacore.openapi.models.response_links import ResponseLinks
 from atriumsports.datacore.openapi.models.response_meta_data import ResponseMetaData
@@ -36,14 +35,16 @@
     meta: Optional[ResponseMetaData] = None
     links: Optional[ResponseLinks] = None
     included: Optional[IncludedData] = None
     data: Optional[conlist(VideoFilesDownloadModel)] = None
     __properties = ["meta", "links", "included", "data"]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -79,15 +80,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> VideoFilesDownloadResponse:
         """Create an instance of VideoFilesDownloadResponse from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return VideoFilesDownloadResponse.parse_obj(obj)
 
         _obj = VideoFilesDownloadResponse.parse_obj(
             {
                 "meta": ResponseMetaData.from_dict(obj.get("meta")) if obj.get("meta") is not None else None,
                 "links": ResponseLinks.from_dict(obj.get("links")) if obj.get("links") is not None else None,
                 "included": IncludedData.from_dict(obj.get("included")) if obj.get("included") is not None else None,
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/video_files_model.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/video_stream_outputs_model.py`

 * *Files 22% similar despite different names*

```diff
@@ -14,265 +14,220 @@
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
 from datetime import datetime
-from inspect import getfullargspec
 from typing import Optional
 
-from pydantic import BaseModel, Field, StrictFloat, StrictInt, StrictStr, constr, validator
+from pydantic import BaseModel, Field, StrictBool, StrictInt, StrictStr, constr, validator
 
 from atriumsports.datacore.openapi.models.fixture_progressions_model_fixture import FixtureProgressionsModelFixture
-from atriumsports.datacore.openapi.models.video_files_model_organization import VideoFilesModelOrganization
+from atriumsports.datacore.openapi.models.fixtures_model_venue import FixturesModelVenue
+from atriumsports.datacore.openapi.models.seasons_model_competition import SeasonsModelCompetition
+from atriumsports.datacore.openapi.models.video_stream_outputs_model_organization import (
+    VideoStreamOutputsModelOrganization,
+)
 
 
-class VideoFilesModel(BaseModel):
+class VideoStreamOutputsModel(BaseModel):
     """
-    VideoFilesModel
+    VideoStreamOutputsModel
     """
 
-    video_id: Optional[StrictStr] = Field(None, alias="videoId", description="The unique identifier of the video")
+    video_input_id: Optional[StrictStr] = Field(
+        None, alias="videoInputId", description="The unique identifier of the video input"
+    )
+    master_venue_id: Optional[StrictStr] = Field(
+        None, alias="masterVenueId", description="The unique identifier of the master venue"
+    )
     organization_id: Optional[StrictStr] = Field(
         None, alias="organizationId", description="The unique identifier of the organization"
     )
-    organization: Optional[VideoFilesModelOrganization] = None
+    organization: Optional[VideoStreamOutputsModelOrganization] = None
+    venue_id: Optional[StrictStr] = Field(None, alias="venueId", description="The unique identifier of the venue")
+    venue: Optional[FixturesModelVenue] = None
+    competition_id: Optional[StrictStr] = Field(
+        None, alias="competitionId", description="The unique identifier of the competition"
+    )
+    competition: Optional[SeasonsModelCompetition] = None
+    fixture_id: Optional[StrictStr] = Field(None, alias="fixtureId", description="The unique identifier of the fixture")
+    fixture: Optional[FixtureProgressionsModelFixture] = None
     provider: Optional[constr(strict=True, max_length=100)] = Field(
         None, description="The code for the provider of the file"
     )
     locale: Optional[constr(strict=True, max_length=5, min_length=5)] = Field(
         None, description="The locale of the video"
     )
     source_number: Optional[StrictInt] = Field(
         1,
         alias="sourceNumber",
         description="Unique identifier for the video source. This is unique for the provider/fixtureId/locale combination.  Unless the provider is supplying multiple sources per fixture/locale then this is normally 1.",
     )
-    fixture_id: Optional[StrictStr] = Field(None, alias="fixtureId", description="The unique identifier of the fixture")
-    fixture: Optional[FixtureProgressionsModelFixture] = None
-    resolution: Optional[constr(strict=True, max_length=30)] = Field(
-        None,
-        description="The resolution of the video input >- `1080` 1920 x 1080 >- `288` 512 x 288 >- `720` 1280 x 720 ",
-    )
-    name: Optional[constr(strict=True, max_length=200)] = Field(
-        None, description="The name/description of the video file"
-    )
     feed_type: Optional[constr(strict=True, max_length=30)] = Field(
         None,
         alias="feedType",
         description="Type of video input >- `ADDITIONAL_ANGLE` Additional angle >- `LOW_LATENCY` Low Latency >- `PRIMARY` Primary ",
     )
-    content: Optional[constr(strict=True, max_length=30)] = Field(
+    input_resolution: Optional[constr(strict=True, max_length=30)] = Field(
         None,
-        description="Content of the stream >- `CLEAN` Output signal is the same as the input signal >- `PROGRAM` Score overlays and other enhancements have been added to the stream ",
-    )
-    fps: Optional[StrictInt] = Field(25, description="fps for the video stream")
-    origin: Optional[constr(strict=True, max_length=30)] = Field(
-        None,
-        description="The origin of the video file >- `STREAM` Streamed >- `UPLOAD` Uploaded >- `VENUE` Recorded in venue ",
-    )
-    format: Optional[constr(strict=True, max_length=30)] = Field(
-        None, description="The format of the video file >- `HLS` A HLS play list >- `MP4` One MP4 file "
-    )
-    storage_provider: Optional[constr(strict=True, max_length=30)] = Field(
-        None,
-        alias="storageProvider",
-        description="Where the video file is stored? >- `5STREAM` 5stream >- `KEEMOTION` Keemotion >- `SYNERGY` Synergy ",
-    )
-    size: Optional[StrictFloat] = Field(None, description="Size (Mb) of the video (only given if a single file)")
-    length: Optional[StrictFloat] = Field(None, description="Lenth (mins) of the video")
-    encoding: Optional[constr(strict=True, max_length=30)] = Field(
-        None, description="How is the video/audio encoded. codecs etc."
+        alias="inputResolution",
+        description="The resolution of the video input >- `1080` 1920 x 1080 >- `288` 512 x 288 >- `720` 1280 x 720 ",
     )
-    status: Optional[constr(strict=True, max_length=30)] = Field(
-        None,
-        description="What is the status of the file? >- `AVAILABLE` Available for access >- `BUILDABLE` Not currently available - but can be built on request >- `PENDING` Being added - some parts may be available ",
+    name: Optional[constr(strict=True, max_length=200)] = Field(None, description="The name of the video source")
+    content: Optional[constr(strict=True, max_length=30)] = Field(
+        "CLEAN",
+        description="Content of the stream >- `CLEAN` Output signal is the same as the input signal >- `PROGRAM` Score overlays and other enhancements have been added to the stream ",
     )
-    start_time: Optional[datetime] = Field(None, alias="startTime", description="The time this recording started (UTC)")
-    expiry: Optional[datetime] = Field(None, description="When does this file expire? (UTC)")
     updated: Optional[datetime] = Field(None, description="Date/time last modified. In UTC")
     added: Optional[datetime] = Field(None, description="Date/time added. In UTC")
+    audio_ambience: Optional[StrictBool] = Field(None, alias="audioAmbience", description="Audio Ambience")
+    audio_commentary: Optional[StrictBool] = Field(None, alias="audioCommentary", description="Audio Commentary")
     __properties = [
-        "videoId",
+        "videoInputId",
+        "masterVenueId",
         "organizationId",
         "organization",
+        "venueId",
+        "venue",
+        "competitionId",
+        "competition",
+        "fixtureId",
+        "fixture",
         "provider",
         "locale",
         "sourceNumber",
-        "fixtureId",
-        "fixture",
-        "resolution",
-        "name",
         "feedType",
+        "inputResolution",
+        "name",
         "content",
-        "fps",
-        "origin",
-        "format",
-        "storageProvider",
-        "size",
-        "length",
-        "encoding",
-        "status",
-        "startTime",
-        "expiry",
         "updated",
         "added",
+        "audioAmbience",
+        "audioCommentary",
     ]
 
     @validator("locale")
-    def locale_validate_regular_expression(cls, v):
-        if v is None:
-            return v
-        if not re.match(r"^[a-z]{2,2}-[A-Z]{2,2}$", v):
-            raise ValueError(r"must validate the regular expression /^[a-z]{2,2}-[A-Z]{2,2}$/")
-        return v
+    def locale_validate_regular_expression(cls, value):
+        """Validates the regular expression"""
+        if value is None:
+            return value
 
-    @validator("resolution")
-    def resolution_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("288", "720", "1080"):
-            raise ValueError("must be one of enum values ('288', '720', '1080')")
-        return v
+        if not re.match(r"^[a-z]{2,2}-[A-Z]{2,2}$", value):
+            raise ValueError(r"must validate the regular expression /^[a-z]{2,2}-[A-Z]{2,2}$/")
+        return value
 
     @validator("feed_type")
-    def feed_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("PRIMARY", "ADDITIONAL_ANGLE", "LOW_LATENCY"):
+    def feed_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("PRIMARY", "ADDITIONAL_ANGLE", "LOW_LATENCY"):
             raise ValueError("must be one of enum values ('PRIMARY', 'ADDITIONAL_ANGLE', 'LOW_LATENCY')")
-        return v
+        return value
+
+    @validator("input_resolution")
+    def input_resolution_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("288", "720", "1080"):
+            raise ValueError("must be one of enum values ('288', '720', '1080')")
+        return value
 
     @validator("content")
-    def content_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("CLEAN", "PROGRAM"):
-            raise ValueError("must be one of enum values ('CLEAN', 'PROGRAM')")
-        return v
+    def content_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
 
-    @validator("origin")
-    def origin_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("STREAM", "VENUE", "UPLOAD"):
-            raise ValueError("must be one of enum values ('STREAM', 'VENUE', 'UPLOAD')")
-        return v
-
-    @validator("format")
-    def format_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("HLS", "MP4"):
-            raise ValueError("must be one of enum values ('HLS', 'MP4')")
-        return v
-
-    @validator("storage_provider")
-    def storage_provider_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("5STREAM", "KEEMOTION", "SYNERGY"):
-            raise ValueError("must be one of enum values ('5STREAM', 'KEEMOTION', 'SYNERGY')")
-        return v
-
-    @validator("status")
-    def status_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("AVAILABLE", "BUILDABLE", "PENDING"):
-            raise ValueError("must be one of enum values ('AVAILABLE', 'BUILDABLE', 'PENDING')")
-        return v
+        if value not in ("CLEAN", "PROGRAM"):
+            raise ValueError("must be one of enum values ('CLEAN', 'PROGRAM')")
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> VideoFilesModel:
-        """Create an instance of VideoFilesModel from a JSON string"""
+    def from_json(cls, json_str: str) -> VideoStreamOutputsModel:
+        """Create an instance of VideoStreamOutputsModel from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
     def to_dict(self):
         """Returns the dictionary representation of the model using alias"""
         _dict = self.dict(
             by_alias=True,
             exclude={
-                "organization_id",
                 "updated",
                 "added",
             },
             exclude_none=True,
         )
         # override the default output from pydantic by calling `to_dict()` of organization
         if self.organization:
             _dict["organization"] = self.organization.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of venue
+        if self.venue:
+            _dict["venue"] = self.venue.to_dict()
+        # override the default output from pydantic by calling `to_dict()` of competition
+        if self.competition:
+            _dict["competition"] = self.competition.to_dict()
         # override the default output from pydantic by calling `to_dict()` of fixture
         if self.fixture:
             _dict["fixture"] = self.fixture.to_dict()
-        # set to None if size (nullable) is None
-        # and __fields_set__ contains the field
-        if self.size is None and "size" in self.__fields_set__:
-            _dict["size"] = None
-
-        # set to None if length (nullable) is None
-        # and __fields_set__ contains the field
-        if self.length is None and "length" in self.__fields_set__:
-            _dict["length"] = None
-
-        # set to None if expiry (nullable) is None
-        # and __fields_set__ contains the field
-        if self.expiry is None and "expiry" in self.__fields_set__:
-            _dict["expiry"] = None
-
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> VideoFilesModel:
-        """Create an instance of VideoFilesModel from a dict"""
+    def from_dict(cls, obj: dict) -> VideoStreamOutputsModel:
+        """Create an instance of VideoStreamOutputsModel from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
-            return VideoFilesModel.parse_obj(obj)
+        if not isinstance(obj, dict):
+            return VideoStreamOutputsModel.parse_obj(obj)
 
-        _obj = VideoFilesModel.parse_obj(
+        _obj = VideoStreamOutputsModel.parse_obj(
             {
-                "video_id": obj.get("videoId"),
+                "video_input_id": obj.get("videoInputId"),
+                "master_venue_id": obj.get("masterVenueId"),
                 "organization_id": obj.get("organizationId"),
-                "organization": VideoFilesModelOrganization.from_dict(obj.get("organization"))
+                "organization": VideoStreamOutputsModelOrganization.from_dict(obj.get("organization"))
                 if obj.get("organization") is not None
                 else None,
-                "provider": obj.get("provider"),
-                "locale": obj.get("locale"),
-                "source_number": obj.get("sourceNumber") if obj.get("sourceNumber") is not None else 1,
+                "venue_id": obj.get("venueId"),
+                "venue": FixturesModelVenue.from_dict(obj.get("venue")) if obj.get("venue") is not None else None,
+                "competition_id": obj.get("competitionId"),
+                "competition": SeasonsModelCompetition.from_dict(obj.get("competition"))
+                if obj.get("competition") is not None
+                else None,
                 "fixture_id": obj.get("fixtureId"),
                 "fixture": FixtureProgressionsModelFixture.from_dict(obj.get("fixture"))
                 if obj.get("fixture") is not None
                 else None,
-                "resolution": obj.get("resolution"),
-                "name": obj.get("name"),
+                "provider": obj.get("provider"),
+                "locale": obj.get("locale"),
+                "source_number": obj.get("sourceNumber") if obj.get("sourceNumber") is not None else 1,
                 "feed_type": obj.get("feedType"),
-                "content": obj.get("content"),
-                "fps": obj.get("fps") if obj.get("fps") is not None else 25,
-                "origin": obj.get("origin"),
-                "format": obj.get("format"),
-                "storage_provider": obj.get("storageProvider"),
-                "size": obj.get("size"),
-                "length": obj.get("length"),
-                "encoding": obj.get("encoding"),
-                "status": obj.get("status"),
-                "start_time": obj.get("startTime"),
-                "expiry": obj.get("expiry"),
+                "input_resolution": obj.get("inputResolution"),
+                "name": obj.get("name"),
+                "content": obj.get("content") if obj.get("content") is not None else "CLEAN",
                 "updated": obj.get("updated"),
                 "added": obj.get("added"),
+                "audio_ambience": obj.get("audioAmbience"),
+                "audio_commentary": obj.get("audioCommentary"),
             }
         )
         return _obj
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/video_files_model_organization.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_entities_list_model_organization.py`

 * *Files 16% similar despite different names*

```diff
@@ -13,63 +13,68 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr, validator
 
 
-class VideoFilesModelOrganization(BaseModel):
+class SeasonEntitiesListModelOrganization(BaseModel):
     """
-    The organization that this video file belongs to
+    The organization that this season entities belongs to
     """
 
     resource_type: Optional[StrictStr] = Field(None, alias="resourceType")
     id: Optional[StrictStr] = Field(None, description="Unique identifier for this resource")
     __properties = ["resourceType", "id"]
 
     @validator("resource_type")
-    def resource_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("organizations"):
+    def resource_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("organizations"):
             raise ValueError("must be one of enum values ('organizations')")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> VideoFilesModelOrganization:
-        """Create an instance of VideoFilesModelOrganization from a JSON string"""
+    def from_json(cls, json_str: str) -> SeasonEntitiesListModelOrganization:
+        """Create an instance of SeasonEntitiesListModelOrganization from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
     def to_dict(self):
         """Returns the dictionary representation of the model using alias"""
         _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> VideoFilesModelOrganization:
-        """Create an instance of VideoFilesModelOrganization from a dict"""
+    def from_dict(cls, obj: dict) -> SeasonEntitiesListModelOrganization:
+        """Create an instance of SeasonEntitiesListModelOrganization from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
-            return VideoFilesModelOrganization.parse_obj(obj)
+        if not isinstance(obj, dict):
+            return SeasonEntitiesListModelOrganization.parse_obj(obj)
 
-        _obj = VideoFilesModelOrganization.parse_obj({"resource_type": obj.get("resourceType"), "id": obj.get("id")})
+        _obj = SeasonEntitiesListModelOrganization.parse_obj(
+            {"resource_type": obj.get("resourceType"), "id": obj.get("id")}
+        )
         return _obj
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/video_files_response.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/leagues_response.py`

 * *Files 8% similar despite different names*

```diff
@@ -13,51 +13,52 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import List, Optional
 
 from pydantic import BaseModel, conlist
 
 from atriumsports.datacore.openapi.models.included_data import IncludedData
+from atriumsports.datacore.openapi.models.leagues_model import LeaguesModel
 from atriumsports.datacore.openapi.models.response_links import ResponseLinks
 from atriumsports.datacore.openapi.models.response_meta_data import ResponseMetaData
-from atriumsports.datacore.openapi.models.video_files_model import VideoFilesModel
 
 
-class VideoFilesResponse(BaseModel):
+class LeaguesResponse(BaseModel):
     """
-    VideoFilesResponse
+    LeaguesResponse
     """
 
     meta: Optional[ResponseMetaData] = None
     links: Optional[ResponseLinks] = None
     included: Optional[IncludedData] = None
-    data: Optional[conlist(VideoFilesModel)] = None
+    data: Optional[conlist(LeaguesModel)] = None
     __properties = ["meta", "links", "included", "data"]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> VideoFilesResponse:
-        """Create an instance of VideoFilesResponse from a JSON string"""
+    def from_json(cls, json_str: str) -> LeaguesResponse:
+        """Create an instance of LeaguesResponse from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
     def to_dict(self):
         """Returns the dictionary representation of the model using alias"""
         _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)
         # override the default output from pydantic by calling `to_dict()` of meta
         if self.meta:
@@ -74,26 +75,26 @@
             for _item in self.data:
                 if _item:
                     _items.append(_item.to_dict())
             _dict["data"] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> VideoFilesResponse:
-        """Create an instance of VideoFilesResponse from a dict"""
+    def from_dict(cls, obj: dict) -> LeaguesResponse:
+        """Create an instance of LeaguesResponse from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
-            return VideoFilesResponse.parse_obj(obj)
+        if not isinstance(obj, dict):
+            return LeaguesResponse.parse_obj(obj)
 
-        _obj = VideoFilesResponse.parse_obj(
+        _obj = LeaguesResponse.parse_obj(
             {
                 "meta": ResponseMetaData.from_dict(obj.get("meta")) if obj.get("meta") is not None else None,
                 "links": ResponseLinks.from_dict(obj.get("links")) if obj.get("links") is not None else None,
                 "included": IncludedData.from_dict(obj.get("included")) if obj.get("included") is not None else None,
-                "data": [VideoFilesModel.from_dict(_item) for _item in obj.get("data")]
+                "data": [LeaguesModel.from_dict(_item) for _item in obj.get("data")]
                 if obj.get("data") is not None
                 else None,
             }
         )
         return _obj
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/video_stream_inputs_model.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/video_stream_inputs_model.py`

 * *Files 8% similar despite different names*

```diff
@@ -14,15 +14,14 @@
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
 from datetime import datetime
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictInt, StrictStr, constr, validator
 
 from atriumsports.datacore.openapi.models.fixture_progressions_model_fixture import FixtureProgressionsModelFixture
 from atriumsports.datacore.openapi.models.fixtures_model_venue import FixturesModelVenue
 from atriumsports.datacore.openapi.models.seasons_model_competition import SeasonsModelCompetition
@@ -136,54 +135,66 @@
         "inputURL",
         "streamName",
         "updated",
         "added",
     ]
 
     @validator("locale")
-    def locale_validate_regular_expression(cls, v):
-        if v is None:
-            return v
-        if not re.match(r"^[a-z]{2,2}-[A-Z]{2,2}$", v):
+    def locale_validate_regular_expression(cls, value):
+        """Validates the regular expression"""
+        if value is None:
+            return value
+
+        if not re.match(r"^[a-z]{2,2}-[A-Z]{2,2}$", value):
             raise ValueError(r"must validate the regular expression /^[a-z]{2,2}-[A-Z]{2,2}$/")
-        return v
+        return value
 
     @validator("feed_type")
-    def feed_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("PRIMARY", "ADDITIONAL_ANGLE", "LOW_LATENCY"):
+    def feed_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("PRIMARY", "ADDITIONAL_ANGLE", "LOW_LATENCY"):
             raise ValueError("must be one of enum values ('PRIMARY', 'ADDITIONAL_ANGLE', 'LOW_LATENCY')")
-        return v
+        return value
 
     @validator("input_resolution")
-    def input_resolution_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("288", "720", "1080"):
+    def input_resolution_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("288", "720", "1080"):
             raise ValueError("must be one of enum values ('288', '720', '1080')")
-        return v
+        return value
 
     @validator("audio_ambience_channel")
-    def audio_ambience_channel_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("CHANNEL_LEFT", "CHANNEL_RIGHT", "CHANNEL_BOTH", "NONE"):
+    def audio_ambience_channel_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("CHANNEL_LEFT", "CHANNEL_RIGHT", "CHANNEL_BOTH", "NONE"):
             raise ValueError("must be one of enum values ('CHANNEL_LEFT', 'CHANNEL_RIGHT', 'CHANNEL_BOTH', 'NONE')")
-        return v
+        return value
 
     @validator("audio_commentary_channel")
-    def audio_commentary_channel_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("CHANNEL_LEFT", "CHANNEL_RIGHT", "CHANNEL_BOTH", "NONE"):
+    def audio_commentary_channel_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("CHANNEL_LEFT", "CHANNEL_RIGHT", "CHANNEL_BOTH", "NONE"):
             raise ValueError("must be one of enum values ('CHANNEL_LEFT', 'CHANNEL_RIGHT', 'CHANNEL_BOTH', 'NONE')")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -222,15 +233,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> VideoStreamInputsModel:
         """Create an instance of VideoStreamInputsModel from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return VideoStreamInputsModel.parse_obj(obj)
 
         _obj = VideoStreamInputsModel.parse_obj(
             {
                 "video_input_id": obj.get("videoInputId"),
                 "master_venue_id": obj.get("masterVenueId"),
                 "organization_id": obj.get("organizationId"),
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/video_stream_inputs_model_organization.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_stages_model_organization.py`

 * *Files 18% similar despite different names*

```diff
@@ -13,65 +13,66 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr, validator
 
 
-class VideoStreamInputsModelOrganization(BaseModel):
+class SeasonStagesModelOrganization(BaseModel):
     """
-    The organization that this Video Stream Inputs belongs to
+    The organization that this season stage belongs to
     """
 
     resource_type: Optional[StrictStr] = Field(None, alias="resourceType")
     id: Optional[StrictStr] = Field(None, description="Unique identifier for this resource")
     __properties = ["resourceType", "id"]
 
     @validator("resource_type")
-    def resource_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("organizations"):
+    def resource_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("organizations"):
             raise ValueError("must be one of enum values ('organizations')")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> VideoStreamInputsModelOrganization:
-        """Create an instance of VideoStreamInputsModelOrganization from a JSON string"""
+    def from_json(cls, json_str: str) -> SeasonStagesModelOrganization:
+        """Create an instance of SeasonStagesModelOrganization from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
     def to_dict(self):
         """Returns the dictionary representation of the model using alias"""
         _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> VideoStreamInputsModelOrganization:
-        """Create an instance of VideoStreamInputsModelOrganization from a dict"""
+    def from_dict(cls, obj: dict) -> SeasonStagesModelOrganization:
+        """Create an instance of SeasonStagesModelOrganization from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
-            return VideoStreamInputsModelOrganization.parse_obj(obj)
+        if not isinstance(obj, dict):
+            return SeasonStagesModelOrganization.parse_obj(obj)
 
-        _obj = VideoStreamInputsModelOrganization.parse_obj(
-            {"resource_type": obj.get("resourceType"), "id": obj.get("id")}
-        )
+        _obj = SeasonStagesModelOrganization.parse_obj({"resource_type": obj.get("resourceType"), "id": obj.get("id")})
         return _obj
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/video_stream_inputs_response.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/video_stream_local_response.py`

 * *Files 13% similar despite different names*

```diff
@@ -13,51 +13,52 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import List, Optional
 
 from pydantic import BaseModel, conlist
 
 from atriumsports.datacore.openapi.models.included_data import IncludedData
 from atriumsports.datacore.openapi.models.response_links import ResponseLinks
 from atriumsports.datacore.openapi.models.response_meta_data import ResponseMetaData
-from atriumsports.datacore.openapi.models.video_stream_inputs_model import VideoStreamInputsModel
+from atriumsports.datacore.openapi.models.video_stream_local_model import VideoStreamLocalModel
 
 
-class VideoStreamInputsResponse(BaseModel):
+class VideoStreamLocalResponse(BaseModel):
     """
-    VideoStreamInputsResponse
+    VideoStreamLocalResponse
     """
 
     meta: Optional[ResponseMetaData] = None
     links: Optional[ResponseLinks] = None
     included: Optional[IncludedData] = None
-    data: Optional[conlist(VideoStreamInputsModel)] = None
+    data: Optional[conlist(VideoStreamLocalModel)] = None
     __properties = ["meta", "links", "included", "data"]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> VideoStreamInputsResponse:
-        """Create an instance of VideoStreamInputsResponse from a JSON string"""
+    def from_json(cls, json_str: str) -> VideoStreamLocalResponse:
+        """Create an instance of VideoStreamLocalResponse from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
     def to_dict(self):
         """Returns the dictionary representation of the model using alias"""
         _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)
         # override the default output from pydantic by calling `to_dict()` of meta
         if self.meta:
@@ -74,26 +75,26 @@
             for _item in self.data:
                 if _item:
                     _items.append(_item.to_dict())
             _dict["data"] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> VideoStreamInputsResponse:
-        """Create an instance of VideoStreamInputsResponse from a dict"""
+    def from_dict(cls, obj: dict) -> VideoStreamLocalResponse:
+        """Create an instance of VideoStreamLocalResponse from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
-            return VideoStreamInputsResponse.parse_obj(obj)
+        if not isinstance(obj, dict):
+            return VideoStreamLocalResponse.parse_obj(obj)
 
-        _obj = VideoStreamInputsResponse.parse_obj(
+        _obj = VideoStreamLocalResponse.parse_obj(
             {
                 "meta": ResponseMetaData.from_dict(obj.get("meta")) if obj.get("meta") is not None else None,
                 "links": ResponseLinks.from_dict(obj.get("links")) if obj.get("links") is not None else None,
                 "included": IncludedData.from_dict(obj.get("included")) if obj.get("included") is not None else None,
-                "data": [VideoStreamInputsModel.from_dict(_item) for _item in obj.get("data")]
+                "data": [VideoStreamLocalModel.from_dict(_item) for _item in obj.get("data")]
                 if obj.get("data") is not None
                 else None,
             }
         )
         return _obj
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/video_stream_local_model.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/video_stream_local_model.py`

 * *Files 11% similar despite different names*

```diff
@@ -14,15 +14,14 @@
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
 from datetime import datetime
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictInt, StrictStr, constr, validator
 
 from atriumsports.datacore.openapi.models.fixture_progressions_model_fixture import FixtureProgressionsModelFixture
 from atriumsports.datacore.openapi.models.video_stream_local_model_organization import VideoStreamLocalModelOrganization
 
@@ -64,22 +63,26 @@
         "format",
         "url",
         "updated",
         "added",
     ]
 
     @validator("format")
-    def format_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("HLS", "MP4"):
+    def format_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("HLS", "MP4"):
             raise ValueError("must be one of enum values ('HLS', 'MP4')")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -113,15 +116,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> VideoStreamLocalModel:
         """Create an instance of VideoStreamLocalModel from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return VideoStreamLocalModel.parse_obj(obj)
 
         _obj = VideoStreamLocalModel.parse_obj(
             {
                 "url_id": obj.get("urlId"),
                 "organization_id": obj.get("organizationId"),
                 "organization": VideoStreamLocalModelOrganization.from_dict(obj.get("organization"))
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/video_stream_local_model_organization.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/video_stream_local_post_body.py`

 * *Files 26% similar despite different names*

```diff
@@ -13,65 +13,87 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
-from pydantic import BaseModel, Field, StrictStr, validator
+from pydantic import BaseModel, Field, StrictInt, StrictStr, constr, validator
 
 
-class VideoStreamLocalModelOrganization(BaseModel):
+class VideoStreamLocalPostBody(BaseModel):
     """
-    The organization that this Video Stream Local belongs to
+    VideoStreamLocalPostBody
     """
 
-    resource_type: Optional[StrictStr] = Field(None, alias="resourceType")
-    id: Optional[StrictStr] = Field(None, description="Unique identifier for this resource")
-    __properties = ["resourceType", "id"]
-
-    @validator("resource_type")
-    def resource_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("organizations"):
-            raise ValueError("must be one of enum values ('organizations')")
-        return v
+    url_id: Optional[StrictStr] = Field(None, alias="urlId", description="The unique identifier of the video")
+    fixture_id: Optional[StrictStr] = Field(None, alias="fixtureId", description="The unique identifier of the fixture")
+    provider: Optional[constr(strict=True, max_length=100)] = Field(
+        None, description="The code for the provider of the file"
+    )
+    source_number: Optional[StrictInt] = Field(
+        1,
+        alias="sourceNumber",
+        description="Unique identifier for the video source. This is unique for the provider/fixtureId/locale combination.  Unless the provider is supplying multiple sources per fixture/locale then this is normally 1.",
+    )
+    format: Optional[constr(strict=True, max_length=30)] = Field(
+        None, description="The format of the video file >- `HLS` A HLS play list >- `MP4` One MP4 file "
+    )
+    url: constr(strict=True, max_length=200) = Field(..., description="The URL where the file can be found")
+    __properties = ["urlId", "fixtureId", "provider", "sourceNumber", "format", "url"]
+
+    @validator("format")
+    def format_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("HLS", "MP4"):
+            raise ValueError("must be one of enum values ('HLS', 'MP4')")
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> VideoStreamLocalModelOrganization:
-        """Create an instance of VideoStreamLocalModelOrganization from a JSON string"""
+    def from_json(cls, json_str: str) -> VideoStreamLocalPostBody:
+        """Create an instance of VideoStreamLocalPostBody from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
     def to_dict(self):
         """Returns the dictionary representation of the model using alias"""
         _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> VideoStreamLocalModelOrganization:
-        """Create an instance of VideoStreamLocalModelOrganization from a dict"""
+    def from_dict(cls, obj: dict) -> VideoStreamLocalPostBody:
+        """Create an instance of VideoStreamLocalPostBody from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
-            return VideoStreamLocalModelOrganization.parse_obj(obj)
+        if not isinstance(obj, dict):
+            return VideoStreamLocalPostBody.parse_obj(obj)
 
-        _obj = VideoStreamLocalModelOrganization.parse_obj(
-            {"resource_type": obj.get("resourceType"), "id": obj.get("id")}
+        _obj = VideoStreamLocalPostBody.parse_obj(
+            {
+                "url_id": obj.get("urlId"),
+                "fixture_id": obj.get("fixtureId"),
+                "provider": obj.get("provider"),
+                "source_number": obj.get("sourceNumber") if obj.get("sourceNumber") is not None else 1,
+                "format": obj.get("format"),
+                "url": obj.get("url"),
+            }
         )
         return _obj
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/video_stream_local_response.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/video_subscriptions_response.py`

 * *Files 20% similar despite different names*

```diff
@@ -13,51 +13,52 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import List, Optional
 
 from pydantic import BaseModel, conlist
 
 from atriumsports.datacore.openapi.models.included_data import IncludedData
 from atriumsports.datacore.openapi.models.response_links import ResponseLinks
 from atriumsports.datacore.openapi.models.response_meta_data import ResponseMetaData
-from atriumsports.datacore.openapi.models.video_stream_local_model import VideoStreamLocalModel
+from atriumsports.datacore.openapi.models.video_subscriptions_model import VideoSubscriptionsModel
 
 
-class VideoStreamLocalResponse(BaseModel):
+class VideoSubscriptionsResponse(BaseModel):
     """
-    VideoStreamLocalResponse
+    VideoSubscriptionsResponse
     """
 
     meta: Optional[ResponseMetaData] = None
     links: Optional[ResponseLinks] = None
     included: Optional[IncludedData] = None
-    data: Optional[conlist(VideoStreamLocalModel)] = None
+    data: Optional[conlist(VideoSubscriptionsModel)] = None
     __properties = ["meta", "links", "included", "data"]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> VideoStreamLocalResponse:
-        """Create an instance of VideoStreamLocalResponse from a JSON string"""
+    def from_json(cls, json_str: str) -> VideoSubscriptionsResponse:
+        """Create an instance of VideoSubscriptionsResponse from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
     def to_dict(self):
         """Returns the dictionary representation of the model using alias"""
         _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)
         # override the default output from pydantic by calling `to_dict()` of meta
         if self.meta:
@@ -74,26 +75,26 @@
             for _item in self.data:
                 if _item:
                     _items.append(_item.to_dict())
             _dict["data"] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> VideoStreamLocalResponse:
-        """Create an instance of VideoStreamLocalResponse from a dict"""
+    def from_dict(cls, obj: dict) -> VideoSubscriptionsResponse:
+        """Create an instance of VideoSubscriptionsResponse from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
-            return VideoStreamLocalResponse.parse_obj(obj)
+        if not isinstance(obj, dict):
+            return VideoSubscriptionsResponse.parse_obj(obj)
 
-        _obj = VideoStreamLocalResponse.parse_obj(
+        _obj = VideoSubscriptionsResponse.parse_obj(
             {
                 "meta": ResponseMetaData.from_dict(obj.get("meta")) if obj.get("meta") is not None else None,
                 "links": ResponseLinks.from_dict(obj.get("links")) if obj.get("links") is not None else None,
                 "included": IncludedData.from_dict(obj.get("included")) if obj.get("included") is not None else None,
-                "data": [VideoStreamLocalModel.from_dict(_item) for _item in obj.get("data")]
+                "data": [VideoSubscriptionsModel.from_dict(_item) for _item in obj.get("data")]
                 if obj.get("data") is not None
                 else None,
             }
         )
         return _obj
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/video_stream_outputs_model_organization.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_entity_base_statistics_model_organization.py`

 * *Files 20% similar despite different names*

```diff
@@ -13,65 +13,68 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr, validator
 
 
-class VideoStreamOutputsModelOrganization(BaseModel):
+class SeasonEntityBaseStatisticsModelOrganization(BaseModel):
     """
-    The organization that this Video Stream Outputs belongs to
+    The organization that this season entity base statistics belongs to
     """
 
     resource_type: Optional[StrictStr] = Field(None, alias="resourceType")
     id: Optional[StrictStr] = Field(None, description="Unique identifier for this resource")
     __properties = ["resourceType", "id"]
 
     @validator("resource_type")
-    def resource_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("organizations"):
+    def resource_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("organizations"):
             raise ValueError("must be one of enum values ('organizations')")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> VideoStreamOutputsModelOrganization:
-        """Create an instance of VideoStreamOutputsModelOrganization from a JSON string"""
+    def from_json(cls, json_str: str) -> SeasonEntityBaseStatisticsModelOrganization:
+        """Create an instance of SeasonEntityBaseStatisticsModelOrganization from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
     def to_dict(self):
         """Returns the dictionary representation of the model using alias"""
         _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> VideoStreamOutputsModelOrganization:
-        """Create an instance of VideoStreamOutputsModelOrganization from a dict"""
+    def from_dict(cls, obj: dict) -> SeasonEntityBaseStatisticsModelOrganization:
+        """Create an instance of SeasonEntityBaseStatisticsModelOrganization from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
-            return VideoStreamOutputsModelOrganization.parse_obj(obj)
+        if not isinstance(obj, dict):
+            return SeasonEntityBaseStatisticsModelOrganization.parse_obj(obj)
 
-        _obj = VideoStreamOutputsModelOrganization.parse_obj(
+        _obj = SeasonEntityBaseStatisticsModelOrganization.parse_obj(
             {"resource_type": obj.get("resourceType"), "id": obj.get("id")}
         )
         return _obj
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/video_stream_outputs_response.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/season_person_placings_response.py`

 * *Files 26% similar despite different names*

```diff
@@ -13,51 +13,52 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import List, Optional
 
 from pydantic import BaseModel, conlist
 
 from atriumsports.datacore.openapi.models.included_data import IncludedData
 from atriumsports.datacore.openapi.models.response_links import ResponseLinks
 from atriumsports.datacore.openapi.models.response_meta_data import ResponseMetaData
-from atriumsports.datacore.openapi.models.video_stream_outputs_model import VideoStreamOutputsModel
+from atriumsports.datacore.openapi.models.season_person_placings_model import SeasonPersonPlacingsModel
 
 
-class VideoStreamOutputsResponse(BaseModel):
+class SeasonPersonPlacingsResponse(BaseModel):
     """
-    VideoStreamOutputsResponse
+    SeasonPersonPlacingsResponse
     """
 
     meta: Optional[ResponseMetaData] = None
     links: Optional[ResponseLinks] = None
     included: Optional[IncludedData] = None
-    data: Optional[conlist(VideoStreamOutputsModel)] = None
+    data: Optional[conlist(SeasonPersonPlacingsModel)] = None
     __properties = ["meta", "links", "included", "data"]
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
     def to_json(self) -> str:
         """Returns the JSON representation of the model using alias"""
         return json.dumps(self.to_dict())
 
     @classmethod
-    def from_json(cls, json_str: str) -> VideoStreamOutputsResponse:
-        """Create an instance of VideoStreamOutputsResponse from a JSON string"""
+    def from_json(cls, json_str: str) -> SeasonPersonPlacingsResponse:
+        """Create an instance of SeasonPersonPlacingsResponse from a JSON string"""
         return cls.from_dict(json.loads(json_str))
 
     def to_dict(self):
         """Returns the dictionary representation of the model using alias"""
         _dict = self.dict(by_alias=True, exclude={}, exclude_none=True)
         # override the default output from pydantic by calling `to_dict()` of meta
         if self.meta:
@@ -74,26 +75,26 @@
             for _item in self.data:
                 if _item:
                     _items.append(_item.to_dict())
             _dict["data"] = _items
         return _dict
 
     @classmethod
-    def from_dict(cls, obj: dict) -> VideoStreamOutputsResponse:
-        """Create an instance of VideoStreamOutputsResponse from a dict"""
+    def from_dict(cls, obj: dict) -> SeasonPersonPlacingsResponse:
+        """Create an instance of SeasonPersonPlacingsResponse from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
-            return VideoStreamOutputsResponse.parse_obj(obj)
+        if not isinstance(obj, dict):
+            return SeasonPersonPlacingsResponse.parse_obj(obj)
 
-        _obj = VideoStreamOutputsResponse.parse_obj(
+        _obj = SeasonPersonPlacingsResponse.parse_obj(
             {
                 "meta": ResponseMetaData.from_dict(obj.get("meta")) if obj.get("meta") is not None else None,
                 "links": ResponseLinks.from_dict(obj.get("links")) if obj.get("links") is not None else None,
                 "included": IncludedData.from_dict(obj.get("included")) if obj.get("included") is not None else None,
-                "data": [VideoStreamOutputsModel.from_dict(_item) for _item in obj.get("data")]
+                "data": [SeasonPersonPlacingsModel.from_dict(_item) for _item in obj.get("data")]
                 if obj.get("data") is not None
                 else None,
             }
         )
         return _obj
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/video_subscription_post_body.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/video_subscription_post_body.py`

 * *Files 5% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictInt, StrictStr, constr, validator
 
 
 class VideoSubscriptionPostBody(BaseModel):
     """
@@ -94,30 +93,31 @@
         "outputURL",
         "audio",
         "content",
         "muxRate",
     ]
 
     @validator("locale")
-    def locale_validate_regular_expression(cls, v):
-        if v is None:
-            return v
-        if not re.match(r"^[a-z]{2,2}-[A-Z]{2,2}$", v):
+    def locale_validate_regular_expression(cls, value):
+        """Validates the regular expression"""
+        if not re.match(r"^[a-z]{2,2}-[A-Z]{2,2}$", value):
             raise ValueError(r"must validate the regular expression /^[a-z]{2,2}-[A-Z]{2,2}$/")
-        return v
+        return value
 
     @validator("feed_type")
-    def feed_type_validate_enum(cls, v):
-        if v not in ("PRIMARY", "ADDITIONAL_ANGLE", "LOW_LATENCY"):
+    def feed_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value not in ("PRIMARY", "ADDITIONAL_ANGLE", "LOW_LATENCY"):
             raise ValueError("must be one of enum values ('PRIMARY', 'ADDITIONAL_ANGLE', 'LOW_LATENCY')")
-        return v
+        return value
 
     @validator("output_resolution")
-    def output_resolution_validate_enum(cls, v):
-        if v not in (
+    def output_resolution_validate_enum(cls, value):
+        """Validates the enum"""
+        if value not in (
             "288",
             "720",
             "1080",
             "2000",
             "DESKTOP_768x432@1000k",
             "DESKTOP_512x288@500k",
             "DESKTOP_384x216@280k",
@@ -140,53 +140,63 @@
             "1080i50@10M",
             "1080p25@10M",
             "1080p50@10M",
         ):
             raise ValueError(
                 "must be one of enum values ('288', '720', '1080', '2000', 'DESKTOP_768x432@1000k', 'DESKTOP_512x288@500k', 'DESKTOP_384x216@280k', 'MOBILE_768x432@1000k', 'MOBILE_480x270@464k', 'MOBILE_320x180@232k', 'MOBILE_320x180@102k', '1920x1080@4000k', '1280x720@2000k', '640x320@850k', '1280x720@3000k25fps', '1920x1080@4000k25fps', '1920x1080@4500k', '1280x720@3000k', '1920x1080@5000k30fps', 'MOBILE_768x432@1000k_BUFFERED', 'MOBILE_480x270@464k_BUFFERED', 'MOBILE_320x180@232k_BUFFERED', 'MOBILE_320x180@102k_BUFFERED', '1080i50@10M', '1080p25@10M', '1080p50@10M')"
             )
-        return v
+        return value
 
     @validator("output_format")
-    def output_format_validate_enum(cls, v):
-        if v not in ("RTMP", "RTMP_PULL", "HLS", "SRT"):
+    def output_format_validate_enum(cls, value):
+        """Validates the enum"""
+        if value not in ("RTMP", "RTMP_PULL", "HLS", "SRT"):
             raise ValueError("must be one of enum values ('RTMP', 'RTMP_PULL', 'HLS', 'SRT')")
-        return v
+        return value
 
     @validator("stream_name")
-    def stream_name_validate_regular_expression(cls, v):
-        if v is None:
-            return v
-        if not re.match(r"^[0-9A-Za-z.:\/&_?=\-;@]*$", v):
+    def stream_name_validate_regular_expression(cls, value):
+        """Validates the regular expression"""
+        if value is None:
+            return value
+
+        if not re.match(r"^[0-9A-Za-z.:\/&_?=\-;@]*$", value):
             raise ValueError(r"must validate the regular expression /^[0-9A-Za-z.:\/&_?=\-;@]*$/")
-        return v
+        return value
 
     @validator("output_url")
-    def output_url_validate_regular_expression(cls, v):
-        if v is None:
-            return v
-        if not re.match(r"^[0-9A-Za-z.:\/&_?=\-;@]*$", v):
+    def output_url_validate_regular_expression(cls, value):
+        """Validates the regular expression"""
+        if value is None:
+            return value
+
+        if not re.match(r"^[0-9A-Za-z.:\/&_?=\-;@]*$", value):
             raise ValueError(r"must validate the regular expression /^[0-9A-Za-z.:\/&_?=\-;@]*$/")
-        return v
+        return value
 
     @validator("audio")
-    def audio_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("COMMENTARY", "AMBIENCE", "BOTH", "BOTH_SPLIT_LR"):
+    def audio_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("COMMENTARY", "AMBIENCE", "BOTH", "BOTH_SPLIT_LR"):
             raise ValueError("must be one of enum values ('COMMENTARY', 'AMBIENCE', 'BOTH', 'BOTH_SPLIT_LR')")
-        return v
+        return value
 
     @validator("content")
-    def content_validate_enum(cls, v):
-        if v not in ("CLEAN", "PROGRAM"):
+    def content_validate_enum(cls, value):
+        """Validates the enum"""
+        if value not in ("CLEAN", "PROGRAM"):
             raise ValueError("must be one of enum values ('CLEAN', 'PROGRAM')")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -211,15 +221,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> VideoSubscriptionPostBody:
         """Create an instance of VideoSubscriptionPostBody from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return VideoSubscriptionPostBody.parse_obj(obj)
 
         _obj = VideoSubscriptionPostBody.parse_obj(
             {
                 "subscription_id": obj.get("subscriptionId"),
                 "customer_id": obj.get("customerId"),
                 "fixture_id": obj.get("fixtureId"),
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/video_subscription_put_body.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/video_subscription_put_body.py`

 * *Files 7% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictInt, StrictStr, constr, validator
 
 
 class VideoSubscriptionPutBody(BaseModel):
     """
@@ -94,34 +93,40 @@
         "outputURL",
         "audio",
         "content",
         "muxRate",
     ]
 
     @validator("locale")
-    def locale_validate_regular_expression(cls, v):
-        if v is None:
-            return v
-        if not re.match(r"^[a-z]{2,2}-[A-Z]{2,2}$", v):
+    def locale_validate_regular_expression(cls, value):
+        """Validates the regular expression"""
+        if value is None:
+            return value
+
+        if not re.match(r"^[a-z]{2,2}-[A-Z]{2,2}$", value):
             raise ValueError(r"must validate the regular expression /^[a-z]{2,2}-[A-Z]{2,2}$/")
-        return v
+        return value
 
     @validator("feed_type")
-    def feed_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("PRIMARY", "ADDITIONAL_ANGLE", "LOW_LATENCY"):
+    def feed_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("PRIMARY", "ADDITIONAL_ANGLE", "LOW_LATENCY"):
             raise ValueError("must be one of enum values ('PRIMARY', 'ADDITIONAL_ANGLE', 'LOW_LATENCY')")
-        return v
+        return value
 
     @validator("output_resolution")
-    def output_resolution_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in (
+    def output_resolution_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in (
             "288",
             "720",
             "1080",
             "2000",
             "DESKTOP_768x432@1000k",
             "DESKTOP_512x288@500k",
             "DESKTOP_384x216@280k",
@@ -144,57 +149,69 @@
             "1080i50@10M",
             "1080p25@10M",
             "1080p50@10M",
         ):
             raise ValueError(
                 "must be one of enum values ('288', '720', '1080', '2000', 'DESKTOP_768x432@1000k', 'DESKTOP_512x288@500k', 'DESKTOP_384x216@280k', 'MOBILE_768x432@1000k', 'MOBILE_480x270@464k', 'MOBILE_320x180@232k', 'MOBILE_320x180@102k', '1920x1080@4000k', '1280x720@2000k', '640x320@850k', '1280x720@3000k25fps', '1920x1080@4000k25fps', '1920x1080@4500k', '1280x720@3000k', '1920x1080@5000k30fps', 'MOBILE_768x432@1000k_BUFFERED', 'MOBILE_480x270@464k_BUFFERED', 'MOBILE_320x180@232k_BUFFERED', 'MOBILE_320x180@102k_BUFFERED', '1080i50@10M', '1080p25@10M', '1080p50@10M')"
             )
-        return v
+        return value
 
     @validator("output_format")
-    def output_format_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("RTMP", "RTMP_PULL", "HLS", "SRT"):
+    def output_format_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("RTMP", "RTMP_PULL", "HLS", "SRT"):
             raise ValueError("must be one of enum values ('RTMP', 'RTMP_PULL', 'HLS', 'SRT')")
-        return v
+        return value
 
     @validator("stream_name")
-    def stream_name_validate_regular_expression(cls, v):
-        if v is None:
-            return v
-        if not re.match(r"^[0-9A-Za-z.:\/&_?=\-;@]*$", v):
+    def stream_name_validate_regular_expression(cls, value):
+        """Validates the regular expression"""
+        if value is None:
+            return value
+
+        if not re.match(r"^[0-9A-Za-z.:\/&_?=\-;@]*$", value):
             raise ValueError(r"must validate the regular expression /^[0-9A-Za-z.:\/&_?=\-;@]*$/")
-        return v
+        return value
 
     @validator("output_url")
-    def output_url_validate_regular_expression(cls, v):
-        if v is None:
-            return v
-        if not re.match(r"^[0-9A-Za-z.:\/&_?=\-;@]*$", v):
+    def output_url_validate_regular_expression(cls, value):
+        """Validates the regular expression"""
+        if value is None:
+            return value
+
+        if not re.match(r"^[0-9A-Za-z.:\/&_?=\-;@]*$", value):
             raise ValueError(r"must validate the regular expression /^[0-9A-Za-z.:\/&_?=\-;@]*$/")
-        return v
+        return value
 
     @validator("audio")
-    def audio_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("COMMENTARY", "AMBIENCE", "BOTH", "BOTH_SPLIT_LR"):
+    def audio_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("COMMENTARY", "AMBIENCE", "BOTH", "BOTH_SPLIT_LR"):
             raise ValueError("must be one of enum values ('COMMENTARY', 'AMBIENCE', 'BOTH', 'BOTH_SPLIT_LR')")
-        return v
+        return value
 
     @validator("content")
-    def content_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("CLEAN", "PROGRAM"):
+    def content_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("CLEAN", "PROGRAM"):
             raise ValueError("must be one of enum values ('CLEAN', 'PROGRAM')")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -219,15 +236,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> VideoSubscriptionPutBody:
         """Create an instance of VideoSubscriptionPutBody from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return VideoSubscriptionPutBody.parse_obj(obj)
 
         _obj = VideoSubscriptionPutBody.parse_obj(
             {
                 "customer_id": obj.get("customerId"),
                 "fixture_id": obj.get("fixtureId"),
                 "provider": obj.get("provider"),
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/video_subscriptions_model.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/video_subscriptions_model.py`

 * *Files 9% similar despite different names*

```diff
@@ -14,15 +14,14 @@
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
 from datetime import datetime
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictInt, StrictStr, constr, validator
 
 from atriumsports.datacore.openapi.models.fixture_progressions_model_fixture import FixtureProgressionsModelFixture
 from atriumsports.datacore.openapi.models.video_subscriptions_model_organization import (
     VideoSubscriptionsModelOrganization,
@@ -116,34 +115,40 @@
         "content",
         "muxRate",
         "updated",
         "added",
     ]
 
     @validator("locale")
-    def locale_validate_regular_expression(cls, v):
-        if v is None:
-            return v
-        if not re.match(r"^[a-z]{2,2}-[A-Z]{2,2}$", v):
+    def locale_validate_regular_expression(cls, value):
+        """Validates the regular expression"""
+        if value is None:
+            return value
+
+        if not re.match(r"^[a-z]{2,2}-[A-Z]{2,2}$", value):
             raise ValueError(r"must validate the regular expression /^[a-z]{2,2}-[A-Z]{2,2}$/")
-        return v
+        return value
 
     @validator("feed_type")
-    def feed_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("PRIMARY", "ADDITIONAL_ANGLE", "LOW_LATENCY"):
+    def feed_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("PRIMARY", "ADDITIONAL_ANGLE", "LOW_LATENCY"):
             raise ValueError("must be one of enum values ('PRIMARY', 'ADDITIONAL_ANGLE', 'LOW_LATENCY')")
-        return v
+        return value
 
     @validator("output_resolution")
-    def output_resolution_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in (
+    def output_resolution_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in (
             "288",
             "720",
             "1080",
             "2000",
             "DESKTOP_768x432@1000k",
             "DESKTOP_512x288@500k",
             "DESKTOP_384x216@280k",
@@ -166,57 +171,69 @@
             "1080i50@10M",
             "1080p25@10M",
             "1080p50@10M",
         ):
             raise ValueError(
                 "must be one of enum values ('288', '720', '1080', '2000', 'DESKTOP_768x432@1000k', 'DESKTOP_512x288@500k', 'DESKTOP_384x216@280k', 'MOBILE_768x432@1000k', 'MOBILE_480x270@464k', 'MOBILE_320x180@232k', 'MOBILE_320x180@102k', '1920x1080@4000k', '1280x720@2000k', '640x320@850k', '1280x720@3000k25fps', '1920x1080@4000k25fps', '1920x1080@4500k', '1280x720@3000k', '1920x1080@5000k30fps', 'MOBILE_768x432@1000k_BUFFERED', 'MOBILE_480x270@464k_BUFFERED', 'MOBILE_320x180@232k_BUFFERED', 'MOBILE_320x180@102k_BUFFERED', '1080i50@10M', '1080p25@10M', '1080p50@10M')"
             )
-        return v
+        return value
 
     @validator("output_format")
-    def output_format_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("RTMP", "RTMP_PULL", "HLS", "SRT"):
+    def output_format_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("RTMP", "RTMP_PULL", "HLS", "SRT"):
             raise ValueError("must be one of enum values ('RTMP', 'RTMP_PULL', 'HLS', 'SRT')")
-        return v
+        return value
 
     @validator("stream_name")
-    def stream_name_validate_regular_expression(cls, v):
-        if v is None:
-            return v
-        if not re.match(r"^[0-9A-Za-z.:\/&_?=\-;@]*$", v):
+    def stream_name_validate_regular_expression(cls, value):
+        """Validates the regular expression"""
+        if value is None:
+            return value
+
+        if not re.match(r"^[0-9A-Za-z.:\/&_?=\-;@]*$", value):
             raise ValueError(r"must validate the regular expression /^[0-9A-Za-z.:\/&_?=\-;@]*$/")
-        return v
+        return value
 
     @validator("output_url")
-    def output_url_validate_regular_expression(cls, v):
-        if v is None:
-            return v
-        if not re.match(r"^[0-9A-Za-z.:\/&_?=\-;@]*$", v):
+    def output_url_validate_regular_expression(cls, value):
+        """Validates the regular expression"""
+        if value is None:
+            return value
+
+        if not re.match(r"^[0-9A-Za-z.:\/&_?=\-;@]*$", value):
             raise ValueError(r"must validate the regular expression /^[0-9A-Za-z.:\/&_?=\-;@]*$/")
-        return v
+        return value
 
     @validator("audio")
-    def audio_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("COMMENTARY", "AMBIENCE", "BOTH", "BOTH_SPLIT_LR"):
+    def audio_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("COMMENTARY", "AMBIENCE", "BOTH", "BOTH_SPLIT_LR"):
             raise ValueError("must be one of enum values ('COMMENTARY', 'AMBIENCE', 'BOTH', 'BOTH_SPLIT_LR')")
-        return v
+        return value
 
     @validator("content")
-    def content_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("CLEAN", "PROGRAM"):
+    def content_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("CLEAN", "PROGRAM"):
             raise ValueError("must be one of enum values ('CLEAN', 'PROGRAM')")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -255,15 +272,15 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> VideoSubscriptionsModel:
         """Create an instance of VideoSubscriptionsModel from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return VideoSubscriptionsModel.parse_obj(obj)
 
         _obj = VideoSubscriptionsModel.parse_obj(
             {
                 "subscription_id": obj.get("subscriptionId"),
                 "organization_id": obj.get("organizationId"),
                 "organization": VideoSubscriptionsModelOrganization.from_dict(obj.get("organization"))
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/models/video_subscriptions_model_organization.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/models/video_subscriptions_model_organization.py`

 * *Files 4% similar despite different names*

```diff
@@ -13,15 +13,14 @@
 
 
 from __future__ import annotations
 
 import json
 import pprint
 import re  # noqa: F401
-from inspect import getfullargspec
 from typing import Optional
 
 from pydantic import BaseModel, Field, StrictStr, validator
 
 
 class VideoSubscriptionsModelOrganization(BaseModel):
     """
@@ -29,22 +28,26 @@
     """
 
     resource_type: Optional[StrictStr] = Field(None, alias="resourceType")
     id: Optional[StrictStr] = Field(None, description="Unique identifier for this resource")
     __properties = ["resourceType", "id"]
 
     @validator("resource_type")
-    def resource_type_validate_enum(cls, v):
-        if v is None:
-            return v
-        if v not in ("organizations"):
+    def resource_type_validate_enum(cls, value):
+        """Validates the enum"""
+        if value is None:
+            return value
+
+        if value not in ("organizations"):
             raise ValueError("must be one of enum values ('organizations')")
-        return v
+        return value
 
     class Config:
+        """Pydantic configuration"""
+
         allow_population_by_field_name = True
         validate_assignment = True
 
     def to_str(self) -> str:
         """Returns the string representation of the model using alias"""
         return pprint.pformat(self.dict(by_alias=True))
 
@@ -64,14 +67,14 @@
 
     @classmethod
     def from_dict(cls, obj: dict) -> VideoSubscriptionsModelOrganization:
         """Create an instance of VideoSubscriptionsModelOrganization from a dict"""
         if obj is None:
             return None
 
-        if type(obj) is not dict:
+        if not isinstance(obj, dict):
             return VideoSubscriptionsModelOrganization.parse_obj(obj)
 
         _obj = VideoSubscriptionsModelOrganization.parse_obj(
             {"resource_type": obj.get("resourceType"), "id": obj.get("id")}
         )
         return _obj
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore/openapi/rest.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore/openapi/rest.py`

 * *Files 1% similar despite different names*

```diff
@@ -66,14 +66,17 @@
         addition_pool_args = {}
         if configuration.assert_hostname is not None:
             addition_pool_args["assert_hostname"] = configuration.assert_hostname  # noqa: E501
 
         if configuration.retries is not None:
             addition_pool_args["retries"] = configuration.retries
 
+        if configuration.tls_server_name:
+            addition_pool_args["server_hostname"] = configuration.tls_server_name
+
         if configuration.socket_options is not None:
             addition_pool_args["socket_options"] = configuration.socket_options
 
         if maxsize is None:
             if configuration.connection_pool_maxsize is not None:
                 maxsize = configuration.connection_pool_maxsize
             else:
@@ -150,14 +153,15 @@
                 timeout = urllib3.Timeout(total=_request_timeout)
             elif isinstance(_request_timeout, tuple) and len(_request_timeout) == 2:
                 timeout = urllib3.Timeout(connect=_request_timeout[0], read=_request_timeout[1])
 
         try:
             # For `POST`, `PUT`, `PATCH`, `OPTIONS`, `DELETE`
             if method in ["POST", "PUT", "PATCH", "OPTIONS", "DELETE"]:
+
                 # no content type provided or payload is json
                 if not headers.get("Content-Type") or re.search("json", headers["Content-Type"], re.IGNORECASE):
                     request_body = None
                     if body is not None:
                         request_body = json.dumps(body)
                     r = self.pool_manager.request(
                         method,
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports/datacore_stream/datacore_stream.py` & `atriumsports_sdk-1.2.0/atriumsports/datacore_stream/datacore_stream.py`

 * *Files identical despite different names*

### Comparing `atriumsports_sdk-1.1.0/atriumsports/endpoints.py` & `atriumsports_sdk-1.2.0/atriumsports/endpoints.py`

 * *Files identical despite different names*

### Comparing `atriumsports_sdk-1.1.0/atriumsports_sdk.egg-info/PKG-INFO` & `atriumsports_sdk-1.2.0/atriumsports_sdk.egg-info/PKG-INFO`

 * *Files 2% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: atriumsports-sdk
-Version: 1.1.0
+Version: 1.2.0
 Summary: Python module for integration to Atrium Sports APIs
 Author: Atrium Sports
 Author-email: python_dev@atriumsports.com
 Classifier: Programming Language :: Python :: 3
 Classifier: License :: OSI Approved :: MIT License
 Classifier: Operating System :: OS Independent
 Requires-Python: >=3.7
@@ -21,15 +21,15 @@
 from atriumsports import AtriumSports
 
 atrium = AtriumSports(
     {
         "sport": "basketball",
         "credential_id": "XXXXX",
         "credential_secret": "YYYY",
-        "organizations": ["b1e34"],
+        "organizations": ["b1a23"],
     }
 )
 datacore = atrium.client("datacore")
 response = datacore.get("/o/b1a23/competitions", limit=500)
 for data in response.data():
     print(data)
 ```
@@ -45,15 +45,15 @@
 from atriumsports.datacore.openapi import CompetitionsApi
 
 atrium = AtriumSports(
     {
         "sport": "basketball",
         "credential_id": "XXXXX",
         "credential_secret": "YYYY",
-        "organizations": ["b1e34"],
+        "organizations": ["b1a23"],
     }
 )
 datacore = atrium.client("datacore")
 # prepare api client with access token and connection pool
 with datacore as api_client:
     # create api instance object for handling input and output of chosen endpoint
     api_instance = CompetitionsApi(api_client)
@@ -103,15 +103,15 @@
     )
 
     assert response.data[0].status == "ACTIVE"
 ```
 
 ### Response body
 
-Response body is a pydanitc object containing deserialized response data.
+Response body is a pydantic object containing deserialized response data.
 
 Example:
 
 ```python
 from atriumsports import AtriumSports
 from atriumsports.datacore.openapi import LeaguesApi
```

### Comparing `atriumsports_sdk-1.1.0/atriumsports_sdk.egg-info/SOURCES.txt` & `atriumsports_sdk-1.2.0/atriumsports_sdk.egg-info/SOURCES.txt`

 * *Files 0% similar despite different names*

```diff
@@ -5,14 +5,15 @@
 atriumsports/__init__.py
 atriumsports/atrium_response.py
 atriumsports/endpoints.py
 atriumsports/datacore/__init__.py
 atriumsports/datacore/datacore.py
 atriumsports/datacore/openapi/__init__.py
 atriumsports/datacore/openapi/api_client.py
+atriumsports/datacore/openapi/api_response.py
 atriumsports/datacore/openapi/configuration.py
 atriumsports/datacore/openapi/exceptions.py
 atriumsports/datacore/openapi/rest.py
 atriumsports/datacore/openapi/api/__init__.py
 atriumsports/datacore/openapi/api/awards_api.py
 atriumsports/datacore/openapi/api/career_statistics_api.py
 atriumsports/datacore/openapi/api/change_log_api.py
```

### Comparing `atriumsports_sdk-1.1.0/setup.py` & `atriumsports_sdk-1.2.0/setup.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,14 +1,14 @@
 import setuptools
 
 with open("README.md", "r") as fh:
     long_description = fh.read()
     setuptools.setup(
         name="atriumsports_sdk",
-        version="1.1.0",
+        version="1.2.0",
         author="Atrium Sports",
         author_email="python_dev@atriumsports.com",
         description="Python module for integration to Atrium Sports APIs",
         long_description=long_description,
         long_description_content_type="text/markdown",
         packages=setuptools.find_packages(),
         classifiers=[
```

