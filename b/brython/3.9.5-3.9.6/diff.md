# Comparing `tmp/brython-3.9.5.tar.gz` & `tmp/brython-3.9.6.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "brython-3.9.5.tar", last modified: Mon Jul  5 09:15:28 2021, max compression
+gzip compressed data, was "brython-3.9.6.tar", last modified: Mon Sep 27 09:04:21 2021, max compression
```

## Comparing `brython-3.9.5.tar` & `brython-3.9.6.tar`

### file list

```diff
@@ -1,25 +1,25 @@
-drwxrwxrwx   0        0        0        0 2021-07-05 09:15:28.326728 brython-3.9.5/
--rw-rw-rw-   0        0        0     1219 2021-07-05 09:15:28.323721 brython-3.9.5/PKG-INFO
--rw-rw-rw-   0        0        0      516 2021-02-16 15:54:10.000000 brython-3.9.5/README.rst
-drwxrwxrwx   0        0        0        0 2021-07-05 09:15:28.251472 brython-3.9.5/brython/
--rw-rw-rw-   0        0        0       38 2021-07-05 09:13:14.000000 brython-3.9.5/brython/__init__.py
--rw-rw-rw-   0        0        0     7773 2021-02-16 15:54:10.000000 brython-3.9.5/brython/__main__.py
-drwxrwxrwx   0        0        0        0 2021-07-05 09:15:28.318735 brython-3.9.5/brython/data/
--rw-rw-rw-   0        0        0      401 2021-07-05 09:15:28.000000 brython-3.9.5/brython/data/README.txt
--rw-rw-rw-   0        0        0   787360 2021-07-05 09:15:28.000000 brython-3.9.5/brython/data/brython.js
--rw-rw-rw-   0        0        0  3999455 2021-07-05 09:15:27.000000 brython-3.9.5/brython/data/brython_stdlib.js
--rw-rw-rw-   0        0        0    44082 2021-07-05 09:15:28.000000 brython-3.9.5/brython/data/demo.html
--rw-rw-rw-   0        0        0      334 2021-07-05 09:15:28.000000 brython-3.9.5/brython/data/index.html
--rw-rw-rw-   0        0        0  1581486 2021-07-05 09:15:28.000000 brython-3.9.5/brython/data/unicode.txt
--rw-rw-rw-   0        0        0    26915 2021-04-06 08:34:46.000000 brython-3.9.5/brython/list_modules.py
--rw-rw-rw-   0        0        0     2172 2021-02-16 15:54:10.000000 brython-3.9.5/brython/make_file_system.py
--rw-rw-rw-   0        0        0     4372 2021-06-27 06:19:53.000000 brython-3.9.5/brython/make_package.py
--rw-rw-rw-   0        0        0     6060 2021-07-05 09:15:27.000000 brython-3.9.5/brython/python_minifier.py
-drwxrwxrwx   0        0        0        0 2021-07-05 09:15:28.260445 brython-3.9.5/brython.egg-info/
--rw-rw-rw-   0        0        0     1219 2021-07-05 09:15:28.000000 brython-3.9.5/brython.egg-info/PKG-INFO
--rw-rw-rw-   0        0        0      471 2021-07-05 09:15:28.000000 brython-3.9.5/brython.egg-info/SOURCES.txt
--rw-rw-rw-   0        0        0        1 2021-07-05 09:15:28.000000 brython-3.9.5/brython.egg-info/dependency_links.txt
--rw-rw-rw-   0        0        0       55 2021-07-05 09:15:28.000000 brython-3.9.5/brython.egg-info/entry_points.txt
--rw-rw-rw-   0        0        0        8 2021-07-05 09:15:28.000000 brython-3.9.5/brython.egg-info/top_level.txt
--rw-rw-rw-   0        0        0       42 2021-07-05 09:15:28.327724 brython-3.9.5/setup.cfg
--rw-rw-rw-   0        0        0     4734 2021-07-05 09:14:01.000000 brython-3.9.5/setup.py
+drwxrwxrwx   0        0        0        0 2021-09-27 09:04:21.739949 brython-3.9.6/
+-rw-rw-rw-   0        0        0     1219 2021-09-27 09:04:21.739949 brython-3.9.6/PKG-INFO
+-rw-rw-rw-   0        0        0      516 2021-07-10 09:14:19.000000 brython-3.9.6/README.rst
+drwxrwxrwx   0        0        0        0 2021-09-27 09:04:21.670955 brython-3.9.6/brython/
+-rw-rw-rw-   0        0        0       38 2021-09-27 09:00:27.000000 brython-3.9.6/brython/__init__.py
+-rw-rw-rw-   0        0        0     7931 2021-09-23 09:21:53.000000 brython-3.9.6/brython/__main__.py
+drwxrwxrwx   0        0        0        0 2021-09-27 09:04:21.739949 brython-3.9.6/brython/data/
+-rw-rw-rw-   0        0        0      401 2021-09-27 09:04:21.000000 brython-3.9.6/brython/data/README.txt
+-rw-rw-rw-   0        0        0   787725 2021-09-27 09:04:21.000000 brython-3.9.6/brython/data/brython.js
+-rw-rw-rw-   0        0        0  4014152 2021-09-27 09:04:21.000000 brython-3.9.6/brython/data/brython_stdlib.js
+-rw-rw-rw-   0        0        0    44082 2021-09-27 09:04:21.000000 brython-3.9.6/brython/data/demo.html
+-rw-rw-rw-   0        0        0      334 2021-09-27 09:04:21.000000 brython-3.9.6/brython/data/index.html
+-rw-rw-rw-   0        0        0  1581486 2021-09-27 09:04:21.000000 brython-3.9.6/brython/data/unicode.txt
+-rw-rw-rw-   0        0        0    26915 2021-07-10 09:14:19.000000 brython-3.9.6/brython/list_modules.py
+-rw-rw-rw-   0        0        0     2172 2021-07-10 09:14:19.000000 brython-3.9.6/brython/make_file_system.py
+-rw-rw-rw-   0        0        0     4359 2021-09-23 09:21:53.000000 brython-3.9.6/brython/make_package.py
+-rw-rw-rw-   0        0        0     6060 2021-09-27 09:04:21.000000 brython-3.9.6/brython/python_minifier.py
+drwxrwxrwx   0        0        0        0 2021-09-27 09:04:21.686563 brython-3.9.6/brython.egg-info/
+-rw-rw-rw-   0        0        0     1219 2021-09-27 09:04:21.000000 brython-3.9.6/brython.egg-info/PKG-INFO
+-rw-rw-rw-   0        0        0      471 2021-09-27 09:04:21.000000 brython-3.9.6/brython.egg-info/SOURCES.txt
+-rw-rw-rw-   0        0        0        1 2021-09-27 09:04:21.000000 brython-3.9.6/brython.egg-info/dependency_links.txt
+-rw-rw-rw-   0        0        0       55 2021-09-27 09:04:21.000000 brython-3.9.6/brython.egg-info/entry_points.txt
+-rw-rw-rw-   0        0        0        8 2021-09-27 09:04:21.000000 brython-3.9.6/brython.egg-info/top_level.txt
+-rw-rw-rw-   0        0        0       42 2021-09-27 09:04:21.739949 brython-3.9.6/setup.cfg
+-rw-rw-rw-   0        0        0     4734 2021-09-27 09:00:56.000000 brython-3.9.6/setup.py
```

### Comparing `brython-3.9.5/PKG-INFO` & `brython-3.9.6/PKG-INFO`

 * *Files 1% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 1.1
 Name: brython
-Version: 3.9.5
+Version: 3.9.6
 Summary: Brython is an implementation of Python 3 running in the browser
 Home-page: http://brython.info
 Author: Pierre Quentel
 Author-email: quentel.pierre@orange.fr
 License: BSD
 Description: With Brython you can write browser programs in Python instead of Javascript,
         by inserting Python code in an HTML page by::
```

#### html2text {}

```diff
@@ -1,8 +1,8 @@
-Metadata-Version: 1.1 Name: brython Version: 3.9.5 Summary: Brython is an
+Metadata-Version: 1.1 Name: brython Version: 3.9.6 Summary: Brython is an
 implementation of Python 3 running in the browser Home-page: http://
 brython.info Author: Pierre Quentel Author-email: quentel.pierre@orange.fr
 License: BSD Description: With Brython you can write browser programs in Python
 instead of Javascript, by inserting Python code in an HTML page by::
  Usage:: pip install brython Then in an empty folder:: brython-cli --install or
 in a folder with older versions already present:: brython-cli --update The
 package includes a page **demo.html** with examples of use. For more
```

### Comparing `brython-3.9.5/README.rst` & `brython-3.9.6/README.rst`

 * *Files identical despite different names*

### Comparing `brython-3.9.5/brython/__main__.py` & `brython-3.9.6/brython/__main__.py`

 * *Files 4% similar despite different names*

```diff
@@ -35,14 +35,17 @@
 
     parser.add_argument('--server', help='Start development server', nargs="?",
         default="absent")
 
     parser.add_argument('--update', help='Update Brython scripts',
         action="store_true")
 
+    parser.add_argument('--version', help='Brython version number',
+        action="store_true")
+
     args = parser.parse_args()
 
     files = ['README.txt', 'demo.html', 'index.html',
         'brython.js', 'brython_stdlib.js', 'unicode.txt']
 
     if args.add_package:
         print('add package {}...'.format(args.add_package))
@@ -75,34 +78,34 @@
         else:
             print('copy single file', package_file)
             shutil.copyfile(package_file, os.path.join(dest_dir,
                 os.path.basename(package_file)))
 
     if args.install:
         print('Installing Brython {}'.format(implementation))
-    
+
         data_path = os.path.join(os.path.dirname(__file__), 'data')
         current_path_files = os.listdir(os.getcwd())
-    
+
         if current_path_files and 'brython.js' in current_path_files:
             override = input(
                 'brython.js is already present in this directory.'
                 ' Override ? (Y/N)'
             )
             if override.lower() != 'y':
                 import sys
                 print('exiting')
                 sys.exit()
-    
+
         for path in os.listdir(data_path):
             try:
                 shutil.copyfile(os.path.join(data_path, path), path)
             except shutil.SameFileError:
                 print(f'{path} has not been moved. Are the same file.')
-    
+
         print('done')
 
     if args.update:
         print('Update Brython scripts to version {}'.format(implementation))
 
         data_path = os.path.join(os.path.dirname(__file__), 'data')
 
@@ -176,15 +179,15 @@
                 # in case the mimetype associated with .js in the Windows
                 # registery is not correctly set
                 if os.path.splitext(path)[1] == ".js":
                     ctype = "application/javascript"
                 return ctype
 
             def translate_path(self, path):
-                """Map /cpython_site_packages to local CPython site-packages 
+                """Map /cpython_site_packages to local CPython site-packages
                 directory."""
                 elts = path.split('/')
                 if len(elts) > 1 and elts[0] == '':
                     if elts[1] == 'cpython_site_packages':
                         elts[-1] = elts[-1].split("?")[0]
                         return os.path.join(cpython_site_packages, *elts[2:])
                 return super().translate_path(path)
@@ -197,9 +200,12 @@
             "Not meant to be used in production.")
         if args.server is None:
             print("For a different port provide command-line option "
                 '"--server PORT".')
         print("Press CTRL+C to Quit.\n")
         http.server.test(HandlerClass=Handler, port=port)
 
+    if args.version:
+        print('Brython version', implementation)
+
 if __name__ == "__main__":
     main()
```

### Comparing `brython-3.9.5/brython/data/brython.js` & `brython-3.9.6/brython/data/brython.js`

 * *Files 2% similar despite different names*

#### js-beautify {}

```diff
@@ -1,10 +1,10 @@
 // brython.js brython.info
 // version [3, 9, 0, 'final', 0]
-// implementation [3, 9, 5, 'final', 0]
+// implementation [3, 9, 6, 'final', 0]
 // version compiled from commented, indented source files at
 // github.com/brython-dev/brython
 var __BRYTHON__ = __BRYTHON__ || {}
 try {
     eval("async function* f(){}")
 } catch (err) {
     console.warn("Your browser is not fully supported. If you are using " +
@@ -68,15 +68,15 @@
     $B.async_enabled = false
     if ($B.async_enabled) {
         $B.block = {}
     }
     $B.imported = {}
     $B.precompiled = {}
     $B.frames_stack = []
-    $B.builtins = {}
+    $B.builtins = Object.create(null)
     $B.builtins_scope = {
         id: '__builtins__',
         module: '__builtins__',
         binding: {}
     }
     $B.builtin_funcs = {}
     $B.builtin_classes = []
@@ -206,20 +206,20 @@
     _window.py = function(src) {
         var root = $B.py2js(src[0], "script", "script"),
             js = root.to_js()
         $B.set_import_paths()
         new Function("$locals_script", js)({})
     }
 })(__BRYTHON__);
-__BRYTHON__.implementation = [3, 9, 5, 'final', 0]
-__BRYTHON__.__MAGIC__ = "3.9.5"
+__BRYTHON__.implementation = [3, 9, 6, 'final', 0]
+__BRYTHON__.__MAGIC__ = "3.9.6"
 __BRYTHON__.version_info = [3, 9, 0, 'final', 0]
-__BRYTHON__.compiled_date = "2021-07-05 11:12:57.617687"
-__BRYTHON__.timestamp = 1625476377616
-__BRYTHON__.builtin_module_names = ["_aio", "_ajax", "_ajax_nevez", "_base64", "_binascii", "_io_classes", "_json", "_jsre", "_locale", "_multiprocessing", "_posixsubprocess", "_profile", "_sreXXX", "_sre_utils", "_string", "_strptime", "_svg", "_webcomponent", "_webworker", "_zlib_utils", "array", "bry_re", "builtins", "dis", "encoding_cp932", "hashlib", "html_parser", "long_int", "marshal", "math", "modulefinder", "posix", "python_re", "python_re_backtrack_choice", "python_re_v5", "random", "unicodedata"];;
+__BRYTHON__.compiled_date = "2021-09-27 11:00:11.924964"
+__BRYTHON__.timestamp = 1632733211924
+__BRYTHON__.builtin_module_names = ["_aio", "_ajax", "_base64", "_binascii", "_io_classes", "_json", "_jsre", "_locale", "_multiprocessing", "_posixsubprocess", "_profile", "_sre_utils", "_string", "_strptime", "_svg", "_webcomponent", "_webworker", "_zlib_utils", "array", "bry_re", "builtins", "dis", "encoding_cp932", "hashlib", "html_parser", "long_int", "marshal", "math", "modulefinder", "posix", "python_re", "random", "unicodedata"];;
 (function($B) {
     function ord(char) {
         if (char.length == 1) {
             return char.charCodeAt(0)
         }
         var code = 0x10000
         code += (char.charCodeAt(0) & 0x03FF) << 10
@@ -781,21 +781,20 @@
         subset: function() {
             var res = {},
                 keys = []
             if (arguments[0] == "all") {
                 keys = Object.keys($B.op2method)
                 keys.splice(keys.indexOf("subset"), 1)
             } else {
-                for (var i = 0, len = arguments.length; i < len; i++) {
-                    keys.push(arguments[i])
+                for (var arg of arguments) {
+                    keys.push(arg)
                 }
             }
-            for (var i = 0, len = keys.length; i < len; i++) {
-                var key = keys[i],
-                    ops = $B.op2method[key]
+            for (var key of keys) {
+                var ops = $B.op2method[key]
                 if (ops === undefined) {
                     throw Error(key)
                 }
                 for (var attr in ops) {
                     res[attr] = ops[attr]
                 }
             }
@@ -819,60 +818,173 @@
         ['-'],
         ['*', '@', '/', '//', '%'],
         ['unary_neg', 'unary_inv', 'unary_pos'],
         ['**']
     ]
     var $op_weight = {},
         $weight = 1
-    $op_order.forEach(function(_tmp) {
-        _tmp.forEach(function(item) {
+    for (var _tmp of $op_order) {
+        for (var item of _tmp) {
             $op_weight[item] = $weight
-        })
+        }
         $weight++
-    })
+    }
     var $loop_num = 0
+    var ast = {}
+    ast.arg = function(arg) {
+        this.arg = arg
+    }
+    var binary_ops = {
+        '+': 'Add',
+        '-': 'Sub',
+        '*': 'Mult',
+        '/': 'Div',
+        '//': 'FloorDiv',
+        '%': 'Mod',
+        '**': 'Pow',
+        '<<': 'LShift',
+        '>>': 'RShift',
+        '|': 'BitOr',
+        '^': 'BitXor',
+        '&': 'BitAnd',
+        '@': 'MatMult'
+    }
+    for (var key in binary_ops) {
+        eval('ast.' + binary_ops[key] + ' = function(){}')
+    }
+    var boolean_ops = {
+        'and': 'And',
+        'or': 'Or'
+    }
+    for (var key in boolean_ops) {
+        eval('ast.' + boolean_ops[key] + ' = function(){}')
+    }
+    var comparison_ops = {
+        '=': 'Eq',
+        '!=': 'NotEq',
+        '<': 'Lt',
+        '<=': 'LtE',
+        '>': 'Gt',
+        '>=': 'GtE',
+        'is': 'Is',
+        'is_not': 'IsNot',
+        'in': 'In',
+        'not_in': 'NotIn'
+    }
+    for (var key in comparison_ops) {
+        eval('ast.' + comparison_ops[key] + ' = function(){}')
+    }
+    for (var tok of ['UAdd', 'USub', 'Not', 'Invert']) {
+        eval('ast.' + tok + ' = function(){}')
+    }
+    ast.Assign = function(targets, value) {
+        this.targets = targets
+        this.value = value
+    }
+    ast.AsyncFunctionDef = function(name, args, body, decorator_list) {
+        this.name = name
+        this.args = args
+        this.body = body
+        this.decorator_lsit = decorator_list
+    }
+    ast.AugAssign = function(target, op, value) {
+        this.target = target
+        this.op = op
+        this.value = value
+    }
+    ast.BinaryOp = function(left, op, right) {
+        this.left = left
+        this.op = op
+        this.right = right
+    }
+    ast.BooleanOp = function(left, op, right) {
+        this.left = left
+        this.op = op
+        this.right = right
+    }
+    ast.Call = function(func, args, keywords) {
+        this.func = func
+        this.args = args
+        this.keywords = keywords
+    }
+    ast.ClassDef = function(name, bases, keywords, body, decorator_list) {
+        this.name = name
+        this.bases = bases
+        this.keywords = keywords
+        this.body = body
+        this.decorator_list = decorator_list
+    }
+    ast.Constant = function(value) {
+        this.value = value
+    }
+    ast.Del = function() {}
+    ast.Delete = function(targets) {
+        this.targets = targets
+    }
+    ast.Expr = function(value) {
+        this.value = value
+    }
+    ast.FunctionDef = function(name, args, body, decorator_list) {
+        this.name = name
+        this.args = args
+        this.body = body
+        this.decorator_lsit = decorator_list
+    }
+    ast.keyword = function(arg, value) {
+        this.arg = arg
+        this.value = value
+    }
+    ast.Load = function() {}
+    ast.Name = function(id, ctx) {
+        this.id = id
+        this.ctx = ctx || ast.Load
+    }
+    ast.Pass = function() {}
+    ast.Return = function() {}
+    ast.Slice = function() {}
+    ast.Starred = function(value) {
+        this.value = value
+    }
+    ast.Store = function() {}
+    ast.Subscript = function(value, slice) {
+        this.value = value
+        this.slice = slice
+        this.ctx = ast.Load
+    }
+    ast.UnaryOp = function(op, operand) {
+        this.op = op
+        this.operand = operand
+    }
+
+    function ast_or_obj(obj) {
+        return obj.ast ? obj.ast() : obj
+    }
     var create_temp_name = $B.parser.create_temp_name = function(prefix) {
         var _prefix = prefix || '$temp'
-        return _prefix + $loop_num++;
+        return _prefix + $loop_num++
     }
     var replace_node = $B.parser.replace_node = function(replace_what, replace_with) {
         var parent = replace_what.parent
         var pos = replace_what.parent.children.indexOf(replace_what)
         parent.children[pos] = replace_with
         replace_with.parent = parent
         replace_with.bindings = replace_what.bindings
     }
-    var add_identnode = $B.parser.add_identnode = function(parent, insert_at, name, val) {
-        var new_node = new $Node()
-        new_node.parent = parent
-        new_node.locals = parent.locals
-        new_node.module = parent.module
-        var new_ctx = new $NodeCtx(new_node)
-        var expr_ctx = new $ExprCtx(new_ctx, 'id', true)
-        var idctx = new $IdCtx(expr_ctx, name)
-        var assign = new $AssignCtx(expr_ctx)
-        if (insert_at === -1)
-            parent.add(new_node)
-        else
-            parent.insert(insert_at, new_node)
-        assign.tree[1] = val
-        return new_node
-    }
     var chained_comp_num = 0
     var $_SyntaxError = $B.parser.$_SyntaxError = function(C, msg, indent) {
         var ctx_node = C
         while (ctx_node.type !== 'node') {
             ctx_node = ctx_node.parent
         }
         var tree_node = ctx_node.node,
             root = tree_node
         while (root.parent !== undefined) {
             root = root.parent
         }
-        var module = tree_node.module,
+        var module = tree_node.module || $get_module(C).module,
             src = root.src,
             line_num = tree_node.line_num
         if (C.$pos !== undefined) {
             $pos = C.$pos
         }
         if (src) {
             line_num = src.substr(0, $pos).split("\n").length
@@ -893,108 +1005,170 @@
             }
             $B.$SyntaxError(module, message, src, $pos, line_num, root)
         } else {
             throw $B.$IndentationError(module, msg, src, $pos, line_num, root)
         }
     }
 
-    function SyntaxWarning(C, msg) {
-        var node = $get_node(C),
-            module = $get_module(C),
-            src = module.src,
-            lines = src.split("\n"),
-            message = `Module ${module.module} line ${node.line_num}: ${msg}\n` +
-            '    ' + lines[node.line_num - 1]
-        $B.$getattr($B.stderr, "write")(message)
-    }
-
-    function check_assignment(C) {
+    function check_assignment(C, kwargs) {
+        var once, action = 'assign to',
+            augmented = false
+        if (kwargs) {
+            once = kwargs.once
+            action = kwargs.action || action
+            augmented = kwargs.augmented === undefined ? false : kwargs.augmented
+        }
         var ctx = C,
-            forbidden = ['assert', 'del', 'import', 'raise', 'return']
+            forbidden = ['assert', 'import', 'raise', 'return']
+        if (action != 'delete') {
+            forbidden.push('del')
+        }
+
+        function report(wrong_type) {
+            if (augmented) {
+                $_SyntaxError(C, [`'${wrong_type}' is an illegal expression ` +
+                    'for augmented assignment'
+                ])
+            } else {
+                $_SyntaxError(C, [`cannot ${action} ${wrong_type}`])
+            }
+        }
         while (ctx) {
             if (forbidden.indexOf(ctx.type) > -1) {
-                $_SyntaxError(C, 'invalid syntax - assign')
-            } else if (ctx.type == "expr" && ctx.tree[0].type == "op") {
-                if ($B.op2method.comparisons[ctx.tree[0].op] !== undefined) {
-                    $_SyntaxError(C, ["cannot assign to comparison"])
-                } else {
-                    $_SyntaxError(C, ["cannot assign to operator"])
+                $_SyntaxError(C, 'assign to ' + ctx.type)
+            } else if (ctx.type == "expr") {
+                var assigned = ctx.tree[0]
+                if (assigned.type == "op") {
+                    if ($B.op2method.comparisons[ctx.tree[0].op] !== undefined) {
+                        report('comparison')
+                    } else {
+                        report('operator')
+                    }
+                } else if (assigned.type == 'call') {
+                    report('function call')
+                } else if (assigned.type == 'id') {
+                    var name = assigned.value
+                    if (['None', 'True', 'False', '__debug__'].indexOf(name) > -1) {
+                        report(name)
+                    }
+                    if (noassign[name] === true) {
+                        report(keyword)
+                    }
+                } else if (['str', 'int', 'float', 'complex'].indexOf(assigned.type) > -1) {
+                    report('literal')
+                } else if (assigned.type == "ellipsis") {
+                    report('Ellipsis')
+                } else if (assigned.type == 'list_or_tuple' &&
+                    assigned.real == 'gen_expr') {
+                    report('generator expression')
+                } else if (assigned.type == 'packed') {
+                    check_assignment(assigned.tree[0], {
+                        action,
+                        once: true
+                    })
+                }
+            } else if (ctx.type == 'list_or_tuple') {
+                for (var item of ctx.tree) {
+                    check_assignment(item, {
+                        action,
+                        once: true
+                    })
                 }
+            } else if (ctx.type == "comprehension") {
+                report('comprehension')
             } else if (ctx.type == "ternary") {
-                $_SyntaxError(C, ["cannot assign to conditional expression"])
+                report('conditional expression')
+            } else if (ctx.type == 'op') {
+                report('operator')
+            }
+            if (once) {
+                break
             }
             ctx = ctx.parent
         }
     }
     var $Node = $B.parser.$Node = function(type) {
         this.type = type
         this.children = []
     }
     $Node.prototype.add = function(child) {
         this.children[this.children.length] = child
         child.parent = this
         child.module = this.module
     }
+    $Node.prototype.ast = function() {
+        if (this.C) {
+            if (this.C.tree[0].ast) {
+                console.log('ast for node', this, '\n', this.C.tree[0].ast())
+            } else {
+                console.log(this.C.tree[0].type, '(no ast)')
+            }
+        } else {
+            for (var node of this.children) {
+                node.ast()
+            }
+        }
+    }
     $Node.prototype.insert = function(pos, child) {
         this.children.splice(pos, 0, child)
         child.parent = this
         child.module = this.module
     }
     $Node.prototype.toString = function() {
         return "<object 'Node'>"
     }
     $Node.prototype.show = function(indent) {
         var res = ''
         if (this.type === 'module') {
-            this.children.forEach(function(child) {
+            for (var child of this.children) {
                 res += child.show(indent)
-            })
+            }
             return res
         }
         indent = indent || 0
         res += ' '.repeat(indent)
         res += this.C
         if (this.children.length > 0) {
             res += '{'
         }
         res += '\n'
-        this.children.forEach(function(child) {
+        for (var child of this.children) {
             res += child.show(indent + 4)
-        })
+        }
         if (this.children.length > 0) {
             res += ' '.repeat(indent)
             res += '}\n'
         }
         return res
     }
     $Node.prototype.to_js = function(indent) {
         if (this.js !== undefined) {
             return this.js
         }
         this.res = []
         this.unbound = []
         if (this.type === 'module') {
-            this.children.forEach(function(child) {
+            for (var child of this.children) {
                 this.res.push(child.to_js())
-            }, this)
+            }
             this.js = this.res.join('')
             return this.js
         }
         indent = indent || 0
         var ctx_js = this.C.to_js()
         if (ctx_js) {
             this.res.push(' '.repeat(indent))
             this.res.push(ctx_js)
             if (this.children.length > 0) {
                 this.res.push('{')
             }
             this.res.push('\n')
-            this.children.forEach(function(child) {
+            for (var child of this.children) {
                 this.res.push(child.to_js(indent + 4))
-            }, this)
+            }
             if (this.children.length > 0) {
                 this.res.push(' '.repeat(indent))
                 this.res.push('}\n')
             }
         }
         this.js = this.res.join('')
         return this.js
@@ -1185,25 +1359,25 @@
     }
     $Node.prototype.clone_tree = function() {
         var res = new $Node(this.type)
         for (var attr in this) {
             res[attr] = this[attr]
         }
         res.children = []
-        for (var i = 0, len = this.children.length; i < len; i++) {
-            res.add(this.children[i].clone_tree())
+        for (var child of this.children) {
+            res.add(child.clone_tree())
         }
         return res
     }
     var $AbstractExprCtx = $B.parser.$AbstractExprCtx = function(C, with_commas) {
         this.type = 'abstract_expr'
         this.with_commas = with_commas
         this.parent = C
         this.tree = []
-        C.tree[C.tree.length] = this
+        C.tree.push(this)
     }
     $AbstractExprCtx.prototype.toString = function() {
         return '(abstract_expr ' + this.with_commas + ') ' + this.tree
     }
     $AbstractExprCtx.prototype.transition = function(token, value) {
         var C = this
         var packed = C.packed,
@@ -1212,14 +1386,15 @@
         if (!assign) {
             switch (token) {
                 case 'id':
                 case 'imaginary':
                 case 'int':
                 case 'float':
                 case 'str':
+                case 'JoinedStr':
                 case 'bytes':
                 case 'ellipsis':
                 case '[':
                 case '(':
                 case '{':
                 case '.':
                 case 'not':
@@ -1235,14 +1410,16 @@
         switch (token) {
             case 'await':
                 return new $AwaitCtx(C)
             case 'id':
                 return new $IdCtx(new $ExprCtx(C, 'id', commas), value)
             case 'str':
                 return new $StringCtx(new $ExprCtx(C, 'str', commas), value)
+            case 'JoinedStr':
+                return new JoinedStrCtx(new $ExprCtx(C, 'str', commas), value)
             case 'bytes':
                 return new $StringCtx(new $ExprCtx(C, 'bytes', commas), value)
             case 'int':
                 return new $NumberCtx('int', new $ExprCtx(C, 'int', commas), value)
             case 'float':
                 return new $NumberCtx('float', new $ExprCtx(C, 'float', commas), value)
             case 'imaginary':
@@ -1327,25 +1504,37 @@
                 switch (C.parent.type) {
                     case 'list_or_tuple':
                     case 'slice':
                     case 'call_arg':
                     case 'op':
                     case 'yield':
                         break
+                    case 'match':
+                        if (token == ',') {
+                            C.parent.tree.pop()
+                            var tuple = new $ListOrTupleCtx(C.parent, 'tuple')
+                            tuple.implicit = true
+                            tuple.has_comma = true
+                            tuple.tree = [C]
+                            C.parent = tuple
+                            return tuple
+                        }
                     case 'annotation':
                         $_SyntaxError(C, "empty annotation")
                     default:
                         $_SyntaxError(C, token)
                 }
         }
         return $transition(C.parent, token, value)
     }
     $AbstractExprCtx.prototype.to_js = function() {
         this.js_processed = true
-        if (this.type === 'list') return '[' + $to_js(this.tree) + ']'
+        if (this.type === 'list') {
+            return '[' + $to_js(this.tree) + ']'
+        }
         return $to_js(this.tree)
     }
     var $AliasCtx = $B.parser.$AliasCtx = function(C) {
         this.type = 'ctx_manager_alias'
         this.parent = C
         this.tree = []
         C.tree[C.tree.length - 1].alias = this
@@ -1400,14 +1589,18 @@
             $_SyntaxError(C, "augmented assign as annotation")
         } else if (token == "op") {
             $_SyntaxError(C, "operator as annotation")
         }
         return $transition(C.parent, token)
     }
     $AnnotationCtx.prototype.to_js = function() {
+        if (this.tree[0].type == 'expr' &&
+            this.tree[0].tree[0].type == 'id') {
+            return `"${this.tree[0].tree[0].value}"`
+        }
         return $to_js(this.tree)
     }
     var $AssertCtx = $B.parser.$AssertCtx = function(C) {
         this.type = 'assert'
         this.parent = C
         this.tree = []
         C.tree[C.tree.length] = this
@@ -1444,22 +1637,20 @@
             $B.$syntax_err_line(warning, module.filename, module.src, $pos, $get_node(this).line_num)
             $B.imported._warnings.warn(warning)
         }
         var new_ctx = new $ConditionCtx(node.C, 'if')
         var not_ctx = new $NotCtx(new_ctx)
         not_ctx.tree = [condition]
         node.C = new_ctx
-        var new_node = new $Node()
         var js = 'throw _b_.AssertionError.$factory()'
         if (message !== null) {
             js = 'throw _b_.AssertionError.$factory(_b_.str.$factory(' +
                 message.to_js() + '))'
         }
-        new $NodeJSCtx(new_node, js)
-        node.add(new_node)
+        node.add($NodeJS(js))
     }
 
     function make_assign(left, right, module) {
         var node = new $Node()
         node.id = module
         var C = new $NodeCtx(node)
         var expr = new $ExprCtx(C, 'left', true)
@@ -1470,62 +1661,47 @@
     }
     var $AssignCtx = $B.parser.$AssignCtx = function(C, expression) {
         check_assignment(C)
         if (C.type == "expr" && C.tree[0].type == "lambda") {
             $_SyntaxError(C, ["cannot assign to lambda"])
         }
         this.type = 'assign'
-        if (expression == 'expression') {
-            this.expression = true
-            console.log("parent of assign expr", C.parent)
-        }
         C.parent.tree.pop()
-        C.parent.tree[C.parent.tree.length] = this
+        C.parent.tree.push(this)
         this.parent = C.parent
         this.tree = [C]
         var scope = $get_scope(this)
-        if (C.type == 'expr' && C.tree[0].type == 'call') {
-            $_SyntaxError(C, ["cannot assign to function call "])
-        } else if (C.type == 'list_or_tuple' ||
+        if (C.type == 'list_or_tuple' ||
             (C.type == 'expr' && C.tree[0].type == 'list_or_tuple')) {
             if (C.type == 'expr') {
-                if (C.tree[0].real == 'gen_expr') {
-                    $_SyntaxError(C, ['cannot assign to generator expression'])
-                }
                 C = C.tree[0]
             }
             C.bind_ids(scope)
         } else if (C.type == 'assign') {
-            C.tree.forEach(function(elt) {
+            check_assignment(C.tree[1])
+            for (var elt of C.tree) {
                 var assigned = elt.tree[0]
                 if (assigned.type == 'id') {
                     $bind(assigned.value, scope, this)
                 }
-            }, this)
+            }
         } else {
             var assigned = C.tree[0]
             if (assigned && assigned.type == 'id') {
                 var name = assigned.value
-                if (['None', 'True', 'False', '__debug__'].indexOf(name) > -1) {
-                    $_SyntaxError(C, ['cannot assign to ' + name])
-                } else if (noassign[name] === true) {
-                    $_SyntaxError(C, ["cannot assign to keyword"])
-                }
                 assigned.bound = true
                 if (!scope.globals || !scope.globals.has(assigned.value)) {
                     var node = $get_node(this)
                     node.bound_before = Object.keys(scope.binding)
                     $bind(assigned.value, scope, this)
                 } else {
                     var module = $get_module(C)
                     assigned.global_module = module.module
                     $bind(assigned.value, module, this)
                 }
-            } else if (["str", "int", "float", "complex"].indexOf(assigned.type) > -1) {
-                $_SyntaxError(C, ["cannot assign to literal"])
             } else if (assigned.type == "ellipsis") {
                 $_SyntaxError(C, ['cannot assign to Ellipsis'])
             } else if (assigned.type == "unary") {
                 $_SyntaxError(C, ["cannot assign to operator"])
             } else if (assigned.type == "packed") {
                 if (assigned.tree[0].name == 'id') {
                     var id = assigned.tree[0].tree[0].value
@@ -1535,14 +1711,28 @@
                 }
                 if (assigned.parent.in_tuple === undefined) {
                     $_SyntaxError(C, ["starred assignment target must be in a list or tuple"])
                 }
             }
         }
     }
+    $AssignCtx.prototype.ast = function() {
+        var value = ast_or_obj(this.tree[1]),
+            targets = [],
+            target = this.tree[0]
+        while (target.type == 'assign') {
+            targets.splice(0, 0, ast_or_obj(target.tree[1]))
+            target = target.tree[0]
+        }
+        targets.splice(0, 0, ast_or_obj(target.tree[0]))
+        for (var tg of targets) {
+            tg.ctx = ast.Store
+        }
+        return new ast.Assign(targets, value)
+    }
     $AssignCtx.prototype.guess_type = function() {
         return
     }
     $AssignCtx.prototype.toString = function() {
         return '(assign) ' + this.tree[0] + '=' + this.tree[1]
     }
     $AssignCtx.prototype.transition = function(token, value) {
@@ -1570,29 +1760,29 @@
             assigned.push(left)
             var ctx = node.C
             ctx.tree = []
             var nleft = new $RawJSCtx(ctx, 'var $temp' + $loop_num)
             nleft.tree = ctx.tree
             var nassign = new $AssignCtx(nleft)
             nassign.tree[1] = right
-            assigned.forEach(function(elt) {
+            for (var elt of assigned) {
                 if (elt.type == "expr" && elt.tree[0].type == "list_or_tuple" &&
                     elt.tree[0].real == "tuple" &&
                     elt.tree[0].tree.length == 1) {
                     elt = elt.tree[0].tree[0]
                 }
                 var new_node = new $Node(),
                     node_ctx = new $NodeCtx(new_node)
                 new_node.locals = node.locals
                 new_node.line_num = node.line_num
                 node.parent.insert(rank + 1, new_node)
                 elt.parent = node_ctx
                 var assign = new $AssignCtx(elt)
                 new $RawJSCtx(assign, '$temp' + $loop_num)
-            })
+            }
             $loop_num++
             this.tree[0] = left
             return
         }
         var left_items = null
         switch (left.type) {
             case 'expr':
@@ -1642,33 +1832,33 @@
             new $NodeJSCtx(new_node, 'void(0)')
             new_nodes[pos++] = new_node
             var $var = '$temp' + $loop_num
             var new_node = new $Node()
             new_node.line_num = node.line_num
             new $NodeJSCtx(new_node, 'var ' + $var + ' = [], $pos = 0')
             new_nodes[pos++] = new_node
-            right_items.forEach(function(right_item) {
+            for (var right_item of right_items) {
                 var js = $var + '[$pos++] = ' + right_item.to_js()
                 var new_node = new $Node()
                 new_node.line_num = node.line_num
                 new $NodeJSCtx(new_node, js)
                 new_nodes[pos++] = new_node
-            })
+            }
             var this_node = $get_node(this)
-            left_items.forEach(function(left_item) {
+            for (var left_item of left_items) {
                 var new_node = new $Node()
                 new_node.id = this_node.module
                 new_node.locals = this_node.locals
                 new_node.line_num = node.line_num
                 var C = new $NodeCtx(new_node)
                 left_item.parent = C
                 var assign = new $AssignCtx(left_item, false)
                 assign.tree[1] = new $JSCode($var + '[' + i + ']')
                 new_nodes[pos++] = new_node
-            }, this)
+            }
             node.parent.children.splice(rank, 1)
             for (var i = new_nodes.length - 1; i >= 0; i--) {
                 node.parent.insert(rank, new_nodes[i])
             }
             $loop_num++
         } else {
             node.parent.children.splice(rank, 1)
@@ -1887,56 +2077,51 @@
                     var params = scope.C.tree[0].positional_list
                     if (this.value.value == params[0] && parent.C &&
                         parent.C.tree[0].args === undefined) {
                         this.assign_self = true
                         return [js + ".__class__ && " + js + ".__dict__ && !" +
                             js + ".__class__.$has_setattr && ! " + js +
                             ".$is_class ? _b_.dict.$setitem(" + js +
-                            ".__dict__, '" + $B.from_alias(this.name) +
+                            ".__dict__, '" + this.name +
                             "', ", ") : $B.$setattr(" + js +
                             ', "' + this.name + '", '
                         ]
                     }
                 }
             }
         }
         if (this.func == 'setattr') {
             return '$B.$setattr(' + js + ',"' + this.name + '")'
         } else {
             return '$B.$getattr(' + js + ',"' + this.name + '")'
         }
     }
     var $AugmentedAssignCtx = $B.parser.$AugmentedAssignCtx = function(C, op) {
-        check_assignment(C)
+        check_assignment(C, {
+            augmented: true
+        })
         this.type = 'augm_assign'
         this.C = C
         this.parent = C.parent
         C.parent.tree.pop()
         C.parent.tree[C.parent.tree.length] = this
         this.op = op
         this.tree = [C]
         var scope = this.scope = $get_scope(this)
         if (C.type == 'expr') {
             var assigned = C.tree[0]
             if (assigned.type == 'id') {
                 var name = assigned.value
-                if (['None', 'True', 'False', '__debug__'].indexOf(name) > -1) {
-                    $_SyntaxError(C, 'cannot assign to ' + name)
-                }
-                if (noassign[name] === true) {
-                    $_SyntaxError(C, "cannot assign to keyword")
-                } else if ((scope.ntype == 'def' || scope.ntype == 'generator') &&
+                if ((scope.ntype == 'def' || scope.ntype == 'generator') &&
                     (scope.binding[name] === undefined)) {
                     if (scope.globals === undefined ||
                         !scope.globals.has(name)) {
                         assigned.unbound = true
                     }
                 }
-            } else if (['str', 'int', 'float', 'complex'].indexOf(assigned.type) > -1) {
-                $_SyntaxError(C, ["cannot assign to literal"])
             }
         }
         $get_node(this).bound_before = Object.keys(scope.binding)
         this.module = scope.module
     }
     $AugmentedAssignCtx.prototype.toString = function() {
         return '(augm assign) ' + this.tree
@@ -2131,17 +2316,17 @@
         no_iadd_node.add(aa1)
         var ctx1 = new $NodeCtx(aa1)
         var expr1 = new $ExprCtx(ctx1, 'clone', false)
         if (left_id_unbound) {
             new $RawJSCtx(expr1, left)
         } else {
             expr1.tree = C.tree
-            expr1.tree.forEach(function(elt) {
+            for (var elt of expr1.tree) {
                 elt.parent = expr1
-            })
+            }
         }
         var assign1 = new $AssignCtx(expr1)
         var new_op = new $OpCtx(expr1, op.substr(0, op.length - 1))
         new_op.parent = assign1
         new $RawJSCtx(new_op, right)
         assign1.tree.push(new_op)
         expr1.parent.tree.pop()
@@ -2157,17 +2342,17 @@
             var js = left
             if (!binding_scope) {
                 js = '$B.$local_search("' + left_value + '");' + left
             }
             new $RawJSCtx(expr2, js)
         } else {
             expr2.tree = C.tree
-            expr2.tree.forEach(function(elt) {
+            for (var elt of expr2.tree) {
                 elt.parent = expr2
-            })
+            }
         }
         var assign2 = new $AssignCtx(expr2)
         assign2.tree.push($NodeJS('iadd(' + right + ')'))
         expr2.parent.tree.pop()
         expr2.parent.tree.push(assign2)
         if (left_is_id && !was_bound && !this.scope.blurred) {
             this.scope.binding[left_id] = undefined
@@ -2295,14 +2480,15 @@
         switch (token) {
             case 'await':
             case 'id':
             case 'imaginary':
             case 'int':
             case 'float':
             case 'str':
+            case 'JoinedStr':
             case 'bytes':
             case '[':
             case '(':
             case '{':
             case '.':
             case 'ellipsis':
             case 'not':
@@ -2407,14 +2593,41 @@
         }
         if (this.func && this.func.value == 'input') {
             $get_node(this).blocking = {
                 'type': 'input'
             }
         }
     }
+    $CallCtx.prototype.ast = function() {
+        var res = new ast.Call(ast_or_obj(this.func), [], [])
+        console.log('call ast', this.tree)
+        for (var call_arg of this.tree) {
+            if (call_arg.type == 'double_star_arg') {
+                var value = call_arg.tree[0].tree[0].value,
+                    keyword = new ast.keyword(null, value)
+                delete keyword.arg
+                res.keywords.push(keyword)
+                continue
+            }
+            var item = call_arg.tree[0]
+            if (item === undefined) {
+                continue
+            }
+            if (item.type == 'kwarg') {
+                res.keywords.push(new ast.keyword(item.tree[0].value, ast_or_obj(item.tree[1])))
+            } else if (item.type == 'star_arg') {
+                var starred = new ast.Starred(ast_or_obj(item.tree[0]))
+                starred.ctx = ast.Load
+                res.args.push(starred)
+            } else {
+                res.args.push(ast_or_obj(item))
+            }
+        }
+        return res
+    }
     $CallCtx.prototype.toString = function() {
         return '(call) ' + this.func + '(' + this.tree + ')'
     }
     $CallCtx.prototype.transition = function(token, value) {
         var C = this
         switch (token) {
             case ',':
@@ -2425,14 +2638,15 @@
                 return C
             case 'await':
             case 'id':
             case 'imaginary':
             case 'int':
             case 'float':
             case 'str':
+            case 'JoinedStr':
             case 'bytes':
             case '[':
             case '(':
             case '{':
             case '.':
             case 'not':
             case 'lambda':
@@ -2489,15 +2703,15 @@
                     }
             }
             var _block = false
             var positional = [],
                 kw_args = [],
                 star_args = false,
                 dstar_args = []
-            this.tree.forEach(function(arg) {
+            for (var arg of this.tree) {
                 var type
                 switch (arg.type) {
                     case 'star_arg':
                         star_args = true
                         positional.push([arg.tree[0].tree[0].to_js(), '*'])
                         break
                     case 'double_star_arg':
@@ -2529,15 +2743,15 @@
                                 break
                             default:
                                 positional.push([arg.to_js(), 's'])
                                 break
                         }
                         break
                 }
-            })
+            }
             var args_str
             if (star_args) {
                 var p = []
                 for (var i = 0, len = positional.length; i < len; i++) {
                     arg = positional[i]
                     if (arg[1] == '*') {
                         p.push('_b_.list.$factory(' + arg[0] + ')')
@@ -2614,75 +2828,108 @@
         var C = this
         switch (token) {
             case 'as':
                 C.expect = ':'
                 return new $AbstractExprCtx(new $AliasCtx(C))
             case ':':
                 function is_irrefutable(pattern) {
+                    var cause
                     if (pattern.type == "capture_pattern") {
-                        return true
+                        return pattern.tree[0]
                     } else if (pattern.type == "or_pattern") {
                         for (var subpattern of pattern.tree) {
-                            if (is_irrefutable(subpattern)) {
-                                return true
+                            if (cause = is_irrefutable(subpattern)) {
+                                return cause
                             }
                         }
                     } else if (pattern.type == "sequence_pattern" &&
                         pattern.token == '(' &&
                         pattern.tree.length == 1 &&
-                        is_irrefutable(pattern.tree[0])) {
-                        return true
+                        (cause = is_irrefutable(pattern.tree[0]))) {
+                        return cause
                     }
                     return false
                 }
-                if (is_irrefutable(this.tree[0])) {
-                    $get_node(C).parent.irrefutable = C
+                var cause
+                if (cause = is_irrefutable(this.tree[0])) {
+                    $get_node(C).parent.irrefutable = cause
                 }
                 switch (C.expect) {
                     case 'id':
                     case 'as':
                     case ':':
+                        var last = $B.last(C.tree)
+                        if (last && last.type == 'sequence_pattern') {
+                            remove_empty_pattern(last)
+                        }
                         return $BodyCtx(C)
                 }
                 break
             case 'op':
                 if (value == '|') {
                     return new $PatternCtx(new $PatternOrCtx(C))
                 }
                 $_SyntaxError(C, ['expected :'])
             case ',':
                 if (C.expect == ':' || C.expect == 'as') {
-                    console.log('implicit tuple', this)
-                    var first = this.tree[0]
                     return new $PatternCtx(new $PatternSequenceCtx(C))
                 }
+            case 'if':
+                C.has_guard = true
+                return new $AbstractExprCtx(new $ConditionCtx(C, token), false)
             default:
                 $_SyntaxError(C, ['expected :'])
         }
     }
     $CaseCtx.prototype.to_js = function() {
         var node = $get_node(this),
             rank = node.parent.children.indexOf(node),
             prefix = rank == 0 ? 'if' : 'else if'
-        return prefix + '($B.pattern_match(subject, ' + $to_js(this.tree) +
-            (this.alias ? `, {as: "${this.alias.value}"}` : '') + '))'
+        if (this.has_guard) {
+            var guard = this.tree.pop(),
+                guard_js = guard.to_js().substr(3),
+                guard_js = guard_js.substr(0, guard_js.length - 1)
+        }
+        return prefix + '(($locals.$line_info="' + node.line_num + ',' +
+            node.module + '") && $B.pattern_match(subject, ' + $to_js(this.tree) +
+            (this.alias ? `, {as: "${this.alias.value}"}` : '') + ')' +
+            (this.has_guard ? ' && ' + guard_js : '') + ')'
     }
     var $ClassCtx = $B.parser.$ClassCtx = function(C) {
         this.type = 'class'
         this.parent = C
         this.tree = []
         C.tree[C.tree.length] = this
         this.expect = 'id'
         var scope = this.scope = $get_scope(this)
         this.parent.node.parent_block = scope
         this.parent.node.bound = {}
         this.parent.node.binding = {
             __annotations__: true
         }
     }
+    $ClassCtx.prototype.ast = function() {
+        var decorators = get_decorators(this.parent.node),
+            bases = [],
+            keywords = []
+        if (this.args) {
+            for (var arg of this.args.tree) {
+                if (arg.vars.length == 2) {
+                    keywords.push(new ast.keyword(ast_or_obj(arg.vars[0]), ast_or_obj(arg.vars[1])))
+                } else {
+                    bases.push(new ast.arg(ast_or_obj(arg.vars[0])))
+                }
+            }
+        }
+        var res = new ast.ClassDef(this.name, bases, keywords, [], decorators)
+        for (var child of this.parent.node.children) {
+            res.body.push(ast_or_obj(child.C.tree[0]))
+        }
+        return res
+    }
     $ClassCtx.prototype.toString = function() {
         return '(class) ' + this.name + ' ' + this.tree + ' args ' + this.args
     }
     $ClassCtx.prototype.transition = function(token, value) {
         var C = this
         switch (token) {
             case 'id':
@@ -2691,14 +2938,24 @@
                     C.expect = '(:'
                     return C
                 }
                 break
             case '(':
                 return new $CallCtx(C)
             case ':':
+                if (this.args) {
+                    for (var arg of this.args.tree) {
+                        var param = arg.tree[0]
+                        if ((param.type == 'expr' && param.name == 'id') ||
+                            param.type == "kwarg") {
+                            continue
+                        }
+                        $_SyntaxError(C, 'invalid class parameter')
+                    }
+                }
                 return $BodyCtx(C)
         }
         $_SyntaxError(C, 'token ' + token + ' after ' + C)
     }
     $ClassCtx.prototype.set_name = function(name) {
         var C = this.parent
         this.random = $B.UUID()
@@ -2779,35 +3036,35 @@
         var js = [name_ref + ' = $B.$class_constructor("' + this.name],
             pos = 1
         js[pos++] = '", $' + this.name + '_' + this.random
         if (this.args !== undefined) {
             var arg_tree = this.args.tree,
                 args = [],
                 kw = []
-            arg_tree.forEach(function(_tmp) {
+            for (var _tmp of arg_tree) {
                 if (_tmp.tree[0].type == 'kwarg') {
                     kw.push(_tmp.tree[0])
                 } else {
                     args.push(_tmp.to_js())
                 }
-            })
+            }
             js[pos++] = ', _b_.tuple.$factory([' + args.join(',') + ']),['
             var _re = new RegExp('"', 'g'),
                 _r = [],
                 rpos = 0
-            args.forEach(function(arg) {
+            for (var arg of args) {
                 _r[rpos++] = '"' + arg.replace(_re, '\\"') + '"'
-            })
+            }
             js[pos++] = _r.join(',') + ']'
             _r = []
             rpos = 0
-            kw.forEach(function(_tmp) {
+            for (var _tmp of kw) {
                 _r[rpos++] = '["' + _tmp.tree[0].value + '",' +
                     _tmp.tree[1].to_js() + ']'
-            })
+            }
             js[pos++] = ',[' + _r.join(',') + ']'
         } else {
             js[pos++] = ', _b_.tuple.$factory([]),[],[]'
         }
         js[pos++] = ')'
         var cl_cons = new $Node()
         new $NodeJSCtx(cl_cons, js.join(''))
@@ -2866,17 +3123,17 @@
                 return new $TargetListCtx(new $CompForCtx(C))
         }
         return $transition(C.parent, token, value)
     }
     $ComprehensionCtx.prototype.to_js = function() {
         this.js_processed = true
         var intervals = []
-        this.tree.forEach(function(elt) {
+        for (var elt of this.tree) {
             intervals.push(elt.start)
-        })
+        }
         return intervals
     }
     var $CompForCtx = $B.parser.$CompForCtx = function(C) {
         this.type = 'comp_for'
         C.parent.intervals.push($pos)
         this.parent = C
         this.tree = []
@@ -2919,33 +3176,58 @@
         return $to_js(this.tree)
     }
     var $ConditionCtx = $B.parser.$ConditionCtx = function(C, token) {
         this.type = 'condition'
         this.token = token
         this.parent = C
         this.tree = []
+        this.node = $get_node(this)
         this.scope = $get_scope(this)
         if (token == 'while') {
             this.loop_num = $loop_num++
         }
-        C.tree[C.tree.length] = this
+        if (token == 'elif') {
+            var rank = this.node.parent.children.indexOf(this.node),
+                previous = this.node.parent.children[rank - 1]
+            previous.C.tree[0].orelse = this
+        }
+        C.tree.push(this)
+    }
+    $ConditionCtx.prototype.ast = function() {
+        var types = {
+            'if': 'If',
+            'while': 'While',
+            'elif': 'If'
+        }
+        var res = {
+            type: types[this.token],
+            test: ast_or_obj(this.tree[0])
+        }
+        if (this.orelse) {
+            res.orelse = ast_or_obj(this.orelse)
+        }
+        res.body = []
+        for (var node of this.node.children) {
+            res.body.push(ast_or_obj(node.C.tree[0]))
+        }
+        return res
     }
     $ConditionCtx.prototype.toString = function() {
         return this.token + ' ' + this.tree
     }
     $ConditionCtx.prototype.transition = function(token, value) {
         var C = this
         if (token == ':') {
             if (C.tree[0].type == "abstract_expr" &&
                 C.tree[0].tree.length == 0) {
                 $_SyntaxError(C, 'token ' + token + ' after ' + C)
             }
             return $BodyCtx(C)
         }
-        $_SyntaxError(C, 'token ' + token + ' after ' + C)
+        $_SyntaxError(C, ["expected ':'"])
     }
     $ConditionCtx.prototype.transform = function(node, rank) {
         var scope = $get_scope(this)
         if (this.token == "while") {
             node.parent.insert(rank, $NodeJS('$locals["$no_break' + this.loop_num + '"] = true'))
             var module = $get_module(this).module
             if ($B.last(node.children).C.tree[0].type != "return") {
@@ -3055,17 +3337,17 @@
                 children.splice(func_rank, 1)
             } else {
                 break
             }
         }
         this.dec_ids = []
         var pos = 0
-        decorators.forEach(function() {
+        for (var _ of decorators) {
             this.dec_ids.push('$id' + $B.UUID())
-        }, this)
+        }
         var obj = children[func_rank].C.tree[0]
         if (obj.type == 'def') {
             obj.decorated = true
             obj.alias = '$dec' + $B.UUID()
         }
         var tail = '',
             scope = $get_scope(this),
@@ -3090,14 +3372,33 @@
         var res = []
         this.decorators.forEach(function(decorator, i) {
             res.push('var ' + this.dec_ids[i] + ' = ' +
                 $to_js(decorator) + ';')
         }, this)
         return res.join('')
     }
+
+    function get_decorators(node) {
+        var decorators = []
+        var parent_node = node.parent
+        var rank = parent_node.children.indexOf(node)
+        while (true) {
+            rank--
+            if (rank < 0) {
+                break
+            } else if (parent_node.children[rank].C.tree[0].type ==
+                'decorator') {
+                var deco = parent_node.children[rank].C.tree[0].tree[0]
+                decorators.push(ast_or_obj(deco))
+            } else {
+                break
+            }
+        }
+        return decorators
+    }
     var $DefCtx = $B.parser.$DefCtx = function(C) {
         this.type = 'def'
         this.name = null
         this.parent = C
         this.tree = []
         this.async = C.async
         this.locals = []
@@ -3133,22 +3434,84 @@
         $loop_num++
         this.positional_list = []
         this.default_list = []
         this.other_args = null
         this.other_kw = null
         this.after_star = []
     }
+    $DefCtx.prototype.ast = function() {
+        var args = {
+                posonlyargs: [],
+                args: [],
+                kwonlyargs: [],
+                kwdefaults: [],
+                defaults: []
+            },
+            decorators = get_decorators(this.parent.node),
+            func_args = this.tree[1].tree,
+            state = 'arg',
+            default_value, res
+        for (var arg of func_args) {
+            if (arg.type == 'end_positional') {
+                args.posonlyargs = args.args
+                args.args = []
+            } else if (arg.type == 'func_star_arg') {
+                if (arg.op == '*' && arg.name == '*') {
+                    state = 'kwonly'
+                } else if (arg.op == '*') {
+                    args.vararg = new ast.arg(arg.name)
+                } else if (arg.op == '**') {
+                    args.kwarg = new ast.arg(arg.name)
+                }
+            } else {
+                default_value = false
+                if (arg.has_default) {
+                    default_value = ast_or_obj(arg.tree[0])
+                }
+                var argument = new ast.arg(arg.name)
+                if (arg.annotation) {
+                    argument.annotation = ast_or_obj(arg.annotation.tree[0])
+                }
+                if (state == 'kwonly') {
+                    args.kwonlyargs.push(argument)
+                    if (default_value) {
+                        args.kwdefaults.push(default_value)
+                    }
+                } else {
+                    args.args.push(argument)
+                    if (default_value) {
+                        args.defaults.push(default_value)
+                    }
+                }
+            }
+        }
+        if (this.async) {
+            res = new ast.AsyncFunctionDef(this.name, args, [], decorators)
+        } else {
+            res = new ast.FunctionDef(this.name, args, [], decorators)
+        }
+        if (this.annotation) {
+            res.returns = ast_or_obj(this.annotation.tree[0])
+        }
+        for (var child of this.parent.node.children) {
+            res.body.push(ast_or_obj(child.C.tree[0]))
+        }
+        return res
+    }
     $DefCtx.prototype.set_name = function(name) {
         try {
             name = $mangle(name, this.parent.tree[0])
         } catch (err) {
             console.log(err)
             console.log('parent', this.parent)
             throw err
         }
+        if (["None", "True", "False"].indexOf(name) > -1) {
+            $_SyntaxError(this, 'invalid function name')
+        }
         var id_ctx = new $IdCtx(this, name)
         this.name = name
         this.id = this.scope.id + '_' + name
         this.id = this.id.replace(/\./g, '_')
         this.id += '_' + $B.UUID()
         this.parent.node.id = this.id
         this.parent.node.module = this.module
@@ -3242,15 +3605,15 @@
         this.func_name = this.tree[0].to_js()
         var func_name1 = this.func_name
         if (this.decorated) {
             this.func_name = 'var ' + this.alias
             func_name1 = this.alias
         }
         var func_args = this.tree[1].tree
-        func_args.forEach(function(arg) {
+        for (var arg of func_args) {
             if (arg.type == 'end_positional') {
                 this.args.push("/")
                 slot_list.push('"/"')
                 has_end_pos = true
             } else {
                 this.args.push(arg.name)
                 this.varnames[arg.name] = true
@@ -3263,17 +3626,17 @@
                     }
                 } else {
                     this.argcount++
                     if (arg.has_default) {
                         this.otherdefaults.push(arg.name)
                     }
                 }
-                this.slots.push(arg.name + ':null')
+                this.slots.push('"' + arg.name + '":null')
                 slot_list.push('"' + arg.name + '"')
-                slot_init.push(arg.name + ':' + arg.name)
+                slot_init.push('"' + arg.name + '": _' + arg.name)
                 if (arg.tree.length > 0) {
                     defaults.push('"' + arg.name + '"')
                     defs1.push(arg.name + ':' + $to_js(arg.tree))
                     this.__defaults__.push($to_js(arg.tree))
                 }
             } else if (arg.type == 'func_star_arg') {
                 if (arg.op == '*') {
@@ -3282,15 +3645,15 @@
                     this.kw_arg = arg.name
                 }
             }
             if (arg.annotation) {
                 var name = $mangle(arg.name, this)
                 annotations.push(name + ': ' + arg.annotation.to_js())
             }
-        }, this)
+        }
         slot_init = '{' + slot_init.join(", ") + '}'
         var flags = 67
         if (this.star_arg) {
             flags |= 4
         }
         if (this.kw_arg) {
             flags |= 8
@@ -3325,17 +3688,17 @@
             (this.is_comp ? this.name : name) + ']'), $NodeJS('$locals.$f_trace = $B.enter_frame($top_frame)'), $NodeJS('var $stack_length = $B.frames_stack.length;')]
         if (this.type == "generator") {
             enter_frame_nodes.push($NodeJS("$locals.$is_generator = true"))
         }
         if (this.async) {
             enter_frame_nodes.splice(1, 0, $NodeJS(`$locals.$async = "${this.id}"`))
         }
-        enter_frame_nodes.forEach(function(node) {
-            node.enter_frame = true
-        })
+        for (var _node of enter_frame_nodes) {
+            _node.enter_frame = true
+        }
         if (this.is_comp) {
             nodes.push($NodeJS("var $defaults = {}"))
         }
         this.env = []
         var make_args_nodes = []
         var js = local_ns + ' = $locals = $B.args("' + this.name + '", ' +
             this.argcount + ', {' + this.slots.join(', ') + '}, ' +
@@ -3351,17 +3714,17 @@
             nodes.push($NodeJS('var $len = arguments.length;'))
             var new_node = new $Node()
             var js = 'var last_arg;if($len > 0 && ((last_arg = ' +
                 'arguments[$len - 1]) !== undefined) && last_arg.$nat ' +
                 '!== undefined)'
             new $NodeJSCtx(new_node, js)
             nodes.push(new_node)
-            make_args_nodes.forEach(function(item) {
+            for (var item of make_args_nodes) {
                 new_node.add(item)
-            })
+            }
             var else_node = new $Node()
             new $NodeJSCtx(else_node, 'else')
             nodes.push(else_node)
             var pos_len = this.slots.length
             var test_node = $NodeJS('if($len == ' + pos_len + ')')
             else_node.add(test_node)
             test_node.add($NodeJS(local_ns + ' = $locals = $B.conv_undef(' +
@@ -3386,28 +3749,29 @@
             if (make_args_nodes.length > 1) {
                 nodes.push(make_args_nodes[1])
             }
         }
         nodes = nodes.concat(enter_frame_nodes)
         var is_method = scope.ntype == "class"
         if (is_method) {
-            var class_ref = "$locals_" + scope.parent_block.id.replace(/\./g, '_') +
-                '.' + scope.C.tree[0].qualname
+            var scope_ref = '$locals_' + scope.parent_block.id.replace(/\./g, '_'),
+                class_ref = scope.C.tree[0].qualname
             var had_class = this.parent.node.binding["__class__"]
             this.parent.node.binding["__class__"] = true
-            nodes.push($NodeJS("$locals.__class__ = " + class_ref))
+            nodes.push($NodeJS('$locals.__class__ = $B.get_method_class(' +
+                scope_ref + ', "' + class_ref + '")'))
         }
         nodes.push($NodeJS('$B.js_this = this;'))
         for (var i = nodes.length - 1; i >= 0; i--) {
             node.children.splice(0, 0, nodes[i])
         }
         var def_func_node = new $Node()
         this.params = ''
         if (only_positional) {
-            this.params = Object.keys(this.varnames).join(', ')
+            this.params = Object.keys(this.varnames).map(x => '_' + x).join(', ')
         }
         new $NodeJSCtx(def_func_node, '')
         def_func_node.is_def_func = true
         def_func_node.module = this.module
         var last_node = node.children[node.children.length - 1],
             indent = last_node.indent,
             last_instr = last_node.C.tree[0]
@@ -3426,55 +3790,59 @@
         if (this.parent.node.referenced) {
             for (var attr in this.parent.node.referenced) {
                 if (!this.parent.node.binding[attr]) {
                     free_vars.push('"' + attr + '"')
                 }
             }
         }
+        if (this.parent.node.nonlocals) {
+            for (var key of this.parent.node.nonlocals) {
+                var attr = '"' + key + '"'
+                if (free_vars.indexOf(attr) == -1) {
+                    free_vars.push(attr)
+                }
+            }
+        }
         node.add(def_func_node)
         var offset = 1,
             indent = node.indent
         if (!this.is_comp) {
             node.parent.insert(rank + offset++, $NodeJS(name + '.$is_func = true'))
             if (this.$has_yield_in_cm) {
                 node.parent.insert(rank + offset++, $NodeJS(name + '.$has_yield_in_cm = true'))
             }
             node.parent.insert(rank + offset++, $NodeJS(name + '.$infos = {'))
             var __name__ = this.name
-            if (this.name.substr(0, 2) == "$$") {
-                __name__ = __name__.substr(2)
-            }
             if (__name__.substr(0, 15) == 'lambda_' + $B.lambda_magic) {
                 __name__ = "<lambda>"
             }
-            js = '    __name__:"' + $B.from_alias(__name__) + '",'
+            js = '    __name__:"' + __name__ + '",'
             node.parent.insert(rank + offset++, $NodeJS(js))
             var __qualname__ = __name__
             if (this.class_name) {
-                __qualname__ = this.class_name + '.' +
-                    $B.from_alias(__name__)
+                __qualname__ = this.class_name + '.' + __name__
             }
             js = '    __qualname__:"' + __qualname__ + '",'
             node.parent.insert(rank + offset++, $NodeJS(js))
             if (this.otherdefaults.length > 0) {
                 var def_names = []
-                this.otherdefaults.forEach(function(_default) {
+                for (var _default of this.otherdefaults) {
                     def_names.push('$defaults.' + _default)
-                })
+                }
                 node.parent.insert(rank + offset++, $NodeJS('    __defaults__ : ' +
                     '$B.fast_tuple([' + def_names.join(', ') + ']),'))
             } else {
                 node.parent.insert(rank + offset++, $NodeJS('    __defaults__ : ' +
                     '_b_.None,'))
             }
             if (this.kwonlyargsdefaults.lengh > 0) {
                 var def_names = []
-                this.kwonlyargsdefaults.forEach(function(_default) {
+                for (var _default of this.kwonlyargsdefaults) {
                     def_names.push('$defaults.' + _default)
-                })
+                }
                 node.parent.insert(rank + offset++, $NodeJS('    __kwdefaults__ : ' +
                     '$B.fast_tuple([' + def_names.join(', ') + ']),'))
             } else {
                 node.parent.insert(rank + offset++, $NodeJS('    __kwdefaults__ : ' +
                     '_b_.None,'))
             }
             node.parent.insert(rank + offset++, $NodeJS('    __annotations__: {' + annotations.join(',') + '},'))
@@ -3486,15 +3854,15 @@
                 if (attr == "__class__" && is_method && !had_class) {
                     continue
                 }
                 this.varnames[attr] = true
             }
             var co_varnames = []
             for (var attr in this.varnames) {
-                co_varnames.push('"' + $B.from_alias(attr) + '"')
+                co_varnames.push('"' + attr + '"')
             }
             var CODE_MARKER = '___%%%-CODE-%%%___' + this.name + this.num;
             var h = '\n' + ' '.repeat(indent + 8)
             js = '    __code__:{' + h + '    co_argcount:' + this.argcount
             var h1 = ',' + h + ' '.repeat(4)
             var module = $get_module(this).module
             var co_name = this.name
@@ -3543,77 +3911,97 @@
         }
         var parent = node
         for (var pos = 0; pos < parent.children.length &&
             parent.children[pos] !== $B.last(enter_frame_nodes); pos++) {}
         var try_node = $NodeJS('try'),
             children = parent.children.slice(pos + 1)
         parent.insert(pos + 1, try_node)
-        children.forEach(function(child) {
+        for (var child of children) {
             if (child.is_def_func) {
-                child.children.forEach(function(grand_child) {
+                for (var grand_child of child.children) {
                     try_node.add(grand_child)
-                })
+                }
             } else {
                 try_node.add(child)
             }
-        })
+        }
         parent.children.splice(pos + 2, parent.children.length)
         var except_node = $NodeJS('catch(err)')
         except_node.add($NodeJS('$B.set_exc(err)'))
-        except_node.add($NodeJS('if($locals.$f_trace !== _b_.None){' +
+        except_node.add($NodeJS('if((! err.$in_trace_func) && $locals.$f_trace !== _b_.None){' +
             '$locals.$f_trace = $B.trace_exception()}'))
         except_node.add($NodeJS('$B.leave_frame({$locals});throw err'))
         parent.add(except_node)
         this.transformed = true
         return offset
     }
     $DefCtx.prototype.to_js = function(func_name) {
         this.js_processed = true
         if (this.is_comp) {
             return "var " + this.name + " = " +
                 (this.async ? ' async ' : '') +
-                "function* (expr)"
+                "function* (_expr)"
         }
         func_name = func_name || this.tree[0].to_js()
         if (this.decorated) {
             func_name = 'var ' + this.alias
         }
         return "var " + this.name + '$' + this.num +
             ' = function($defaults){' +
             (this.async ? 'async ' : '') + 'function' +
             (this.type == 'generator' ? "* " : " ") +
             this.name + this.num + '(' + this.params + ')'
     }
     var $DelCtx = $B.parser.$DelCtx = function(C) {
         this.type = 'del'
         this.parent = C
-        C.tree[C.tree.length] = this
+        C.tree.push(this)
         this.tree = []
     }
+    $DelCtx.prototype.ast = function() {
+        var targets
+        console.log('ast del', this.tree[0])
+        if (this.tree[0].type == 'list_or_tuple') {
+            targets = this.tree[0].tree.slice()
+        } else if (this.tree[0].type == 'expr' &&
+            this.tree[0].tree[0].type == 'list_or_tuple') {
+            targets = this.tree[0].tree[0]
+        } else {
+            targets = [this.tree[0].tree[0]]
+        }
+        for (var i = 0; i < targets.length; i++) {
+            targets[i] = ast_or_obj(targets[i])
+            targets[i].ctx = ast.Del
+        }
+        return new ast.Delete(targets)
+    }
     $DelCtx.prototype.toString = function() {
         return 'del ' + this.tree
     }
     $DelCtx.prototype.transition = function(token, value) {
         var C = this
         if (token == 'eol') {
+            check_assignment(this.tree[0], {
+                action: 'delete'
+            })
             return $transition(C.parent, token)
         }
         $_SyntaxError(C, 'token ' + token + ' after ' + C)
     }
     $DelCtx.prototype.to_js = function() {
         this.js_processed = true
         var C = this.parent
         if (this.tree[0].type == 'list_or_tuple') {
             var res = []
-            this.tree[0].tree.forEach(function(elt) {
+            for (var elt of this.tree[0].tree) {
                 var subdel = new $DelCtx(C)
                 subdel.tree = [elt]
                 res.push(subdel.to_js())
                 C.tree.pop()
-            })
+            }
             this.tree = []
             return res.join(';')
         } else if (this.tree[0].type == 'expr' &&
             this.tree[0].tree[0].type == 'list_or_tuple') {
             this.tree[0] = this.tree[0].tree[0]
             return this.to_js()
         } else {
@@ -3633,27 +4021,23 @@
                     }
                     var res = '$B.$delete("' + expr.value + '"' +
                         (is_global ? ', "global"' : '') + ');'
                     delete scope.binding[expr.value]
                     return res
                 case 'list_or_tuple':
                     var res = []
-                    expr.tree.forEach(function(elt) {
+                    for (var elt of expr.tree) {
                         res.push('delete ' + elt.to_js())
-                    })
+                    }
                     return res.join(';')
                 case 'sub':
                     expr.func = 'delitem'
                     js = expr.to_js()
                     expr.func = 'getitem'
                     return js
-                case 'op':
-                    $_SyntaxError(this, ["cannot delete operator"])
-                case 'call':
-                    $_SyntaxError(this, ["cannot delete function call"])
                 case 'attribute':
                     return '_b_.delattr(' + expr.value.to_js() + ',"' +
                         expr.name + '")'
                 default:
                     $_SyntaxError(this, ["cannot delete " + expr.type])
             }
         }
@@ -3733,14 +4117,20 @@
                             C.expect = ','
                             return new $AbstractExprCtx(C, false)
                         } else {
                             $_SyntaxError(C, 'token ' + token +
                                 ' after ' + C)
                         }
                     case 'for':
+                        if (C.real == "set" && C.tree.length > 1) {
+                            C.$pos = C.tree[0].$pos
+                            $_SyntaxError(C, ["did you forget " +
+                                "parentheses around the comprehension target?"
+                            ])
+                        }
                         if (C.real == 'dict_or_set') {
                             C.real = 'set_comp'
                         } else {
                             C.real = 'dict_comp'
                         }
                         var lst = new $ListOrTupleCtx(C, 'dict_or_set_comp')
                         lst.intervals = [C.start + 1]
@@ -3770,14 +4160,15 @@
                         C.closed = true
                         return C
                     case 'id':
                     case 'imaginary':
                     case 'int':
                     case 'float':
                     case 'str':
+                    case 'JoinedStr':
                     case 'bytes':
                     case '[':
                     case '(':
                     case '{':
                     case '.':
                     case 'not':
                     case 'lambda':
@@ -3822,21 +4213,21 @@
                 $_SyntaxError(C, 'token ' + token + ' after ' + C)
             }
             return $transition(C.parent, token, value)
         }
     }
     $DictOrSetCtx.prototype.nb_dict_items = function() {
         var nb = 0
-        this.tree.forEach(function(item) {
+        for (var item of this.tree) {
             if (item.packed) {
                 nb += 2
             } else {
                 nb++
             }
-        })
+        }
         return nb
     }
     $DictOrSetCtx.prototype.packed_indices = function() {
         var ixs = []
         this.items.forEach(function(t, i) {
             if (t.type == "expr" && t.packed) {
                 ixs.push(i)
@@ -3924,14 +4315,15 @@
         var C = this
         switch (token) {
             case 'id':
             case 'imaginary':
             case 'int':
             case 'float':
             case 'str':
+            case 'JoinedStr':
             case 'bytes':
             case '[':
             case '(':
             case '{':
             case '.':
             case 'not':
             case 'lambda':
@@ -3999,14 +4391,15 @@
         var C = this
         switch (token) {
             case 'id':
             case 'imaginary':
             case 'int':
             case 'float':
             case 'str':
+            case 'JoinedStr':
             case 'bytes':
             case '[':
             case '(':
             case '{':
             case 'not':
             case 'lambda':
                 if (C.expect == 'id') {
@@ -4046,16 +4439,19 @@
                 }
             case ',':
                 if (C.parenth !== undefined &&
                     C.has_alias === undefined &&
                     (C.expect == 'as' || C.expect == ',')) {
                     C.expect = 'id'
                     return C
+                } else if (C.parenth === undefined) {
+                    $_SyntaxError(C, ["multiple exception types must be parenthesized"])
                 }
         }
+        console.log('error', C, token)
         $_SyntaxError(C, 'token ' + token + ' after ' + C.expect)
     }
     $ExceptCtx.prototype.set_alias = function(alias) {
         this.tree[0].alias = $mangle(alias, this)
         $bind(alias, this.scope, this)
     }
     $ExceptCtx.prototype.transform = function(node, rank) {
@@ -4075,17 +4471,17 @@
                 return 'else'
             case 1:
                 if (this.tree[0].name == 'Exception') {
                     return 'else if(1)'
                 }
         }
         var res = []
-        this.tree.forEach(function(elt) {
+        for (var elt of this.tree) {
             res.push(elt.to_js())
-        })
+        }
         var lnum = ''
         if ($B.debug > 0) {
             var module = $get_module(this)
             lnum = '($locals.$line_info = "' + $get_node(this).line_num +
                 ',' + module.id + '") && '
         }
         return 'else if(' + lnum + '$B.is_exc(' + this.error_name +
@@ -4109,29 +4505,51 @@
         }
         if (C.assign) {
             this.assign = C.assign
         }
         this.tree = []
         C.tree[C.tree.length] = this
     }
+    $ExprCtx.prototype.ast = function() {
+        var res
+        if (['imaginary', 'int', 'float', 'list', 'str', 'operand'].indexOf(this.name) > -1) {
+            var res = ast_or_obj(this.tree[0])
+        } else if (this.name == 'id') {
+            if (['id', 'call', 'sub'].indexOf(this.tree[0].type) > -1) {
+                res = this.tree[0].ast()
+            }
+        }
+        if (res) {
+            if (this.parent.type == 'node') {
+                return new ast.Expr(res)
+            } else {
+                return res
+            }
+        }
+        return this
+    }
     $ExprCtx.prototype.toString = function() {
         return '(expr ' + this.with_commas + ') ' + this.tree
     }
     $ExprCtx.prototype.transition = function(token, value) {
         var C = this
         switch (token) {
             case 'bytes':
             case 'float':
             case 'id':
             case 'imaginary':
             case 'int':
             case 'lambda':
             case 'pass':
             case 'str':
-                console.log("syntax error", C, token, value)
+            case 'JoinedStr':
+                if (C.parent.type == 'dict_or_set' &&
+                    C.parent.expect == ',') {
+                    $_SyntaxError(C, ["invalid syntax. Perhaps you forgot a comma?"])
+                }
                 $_SyntaxError(C, 'token ' + token + ' after ' +
                     C)
                 break
             case '{':
                 if (C.tree[0].type != "id" || ["print", "exec"].indexOf(C.tree[0].value) == -1) {
                     $_SyntaxError(C, 'token ' + token + ' after ' +
                         C)
@@ -4206,21 +4624,17 @@
                         repl = op1
                         op1 = op1.parent
                     } else {
                         break
                     }
                 }
                 if (repl === null) {
-                    while (1) {
-                        if (C.parent !== op1) {
-                            C = C.parent
-                            op_parent = C.parent
-                        } else {
-                            break
-                        }
+                    while (C.parent !== op1) {
+                        C = C.parent
+                        op_parent = C.parent
                     }
                     C.parent.tree.pop()
                     var expr = new $ExprCtx(op_parent, 'operand', C.with_commas)
                     expr.expect = ','
                     C.parent = expr
                     var new_op = new $OpCtx(C, op)
                     return new $AbstractExprCtx(new_op, false)
@@ -4329,14 +4743,15 @@
                         C.parent.parent.type == "sub")) {
                     return new $AbstractExprCtx(new $SliceCtx(C.parent), false)
                 } else if (C.parent.type == "slice") {
                     return $transition(C.parent, token, value)
                 } else if (C.parent.type == "node") {
                     if (C.tree.length == 1) {
                         var child = C.tree[0]
+                        check_assignment(child)
                         if (["id", "sub", "attribute"].indexOf(child.type) > -1) {
                             return new $AbstractExprCtx(new $AnnotationCtx(C), false)
                         } else if (child.real == "tuple" && child.expect == "," &&
                             child.tree.length == 1) {
                             return new $AbstractExprCtx(new $AnnotationCtx(child.tree[0]), false)
                         }
                     }
@@ -4489,14 +4904,17 @@
     }
     $ExprCtx.prototype.to_js = function(arg) {
         var res
         this.js_processed = true
         if (this.type == 'list') {
             res = '[' + $to_js(this.tree) + ']'
         } else if (this.tree.length == 1) {
+            if (this.tree[0].to_js === undefined) {
+                console.log('pas de to_js', this)
+            }
             res = this.tree[0].to_js(arg)
         } else {
             res = '_b_.tuple.$factory([' + $to_js(this.tree) + '])'
         }
         if (this.is_await) {
             res = "await ($B.promise(" + res + "))"
         }
@@ -4507,15 +4925,15 @@
             }
             if (scope.globals && scope.globals.has(this.assign.value)) {
                 while (scope.parent_block &&
                     scope.parent_block.id !== "__builtins__") {
                     scope = scope.parent_block
                 }
             } else if (scope.nonlocals &&
-                scope.nonlocals[this.assign.value]) {
+                scope.nonlocals.has(this.assign.value)) {
                 scope = scope.parent_block
             }
             res = "($locals_" + scope.id.replace(/\./g, '_') + '["' +
                 this.assign.value + '"] = ' + res + ')'
         }
         if (this.name == "call") {
             res += '()'
@@ -4558,14 +4976,15 @@
         return '(for) ' + this.tree
     }
     $ForExpr.prototype.transition = function(token, value) {
         var C = this
         switch (token) {
             case 'in':
                 for (var target_expr of C.tree[0].tree) {
+                    check_assignment(target_expr.tree[0])
                     if (target_expr.tree[0].type == 'id') {
                         var id = target_expr.tree[0]
                         $bind(id.value, this.scope, id)
                     }
                 }
                 if (C.tree[0].tree.length == 0) {
                     $_SyntaxError(C, "missing target between 'for' and 'in'")
@@ -4576,27 +4995,26 @@
                 if (C.tree.length < 2 ||
                     C.tree[1].tree[0].type == "abstract_expr") {
                     $_SyntaxError(C, 'token ' + token + ' after ' +
                         C)
                 }
                 return $BodyCtx(C)
         }
-        console.log('C', C, 'tokan', token, value)
         $_SyntaxError(C, 'token ' + token + ' after ' + C)
     }
     $ForExpr.prototype.transform = function(node, rank) {
         var pnode = this.parent.node.parent
         while (pnode) {
             if (pnode.is_comp) {
                 var module = $get_module(this)
                 if (module.outermost_expr === undefined) {
                     pnode.outermost_expr = this.tree[1]
                     module.outermost_expr = this.tree[1]
                     this.tree.pop()
-                    new $RawJSCtx(this, "expr")
+                    new $RawJSCtx(this, "_expr")
                 }
                 break
             }
             pnode = pnode.parent
         }
         if (this.async) {
             return this.transform_async(node, rank)
@@ -4693,17 +5111,17 @@
                 var assign_node = make_assign(target, '$next' + num, node.parent.module)
                 for_node.add(assign_node)
                 for_node.add($NodeJS('if($safe' + num + '){$next' + num +
                     ' += 1}'))
                 for_node.add($NodeJS('else{$next' + num + ' = $B.add($next' +
                     num + ',1)}'))
             }
-            children.forEach(function(child) {
+            for (var child of children) {
                 for_node.add(child.clone_tree())
-            })
+            }
             if ($B.last(node.children).C.tree[0].type != "return") {
                 var js = '$locals.$line_info = "' + node.line_num +
                     ',' + this.module + '";if($locals.$f_trace !== _b_.None){' +
                     '$B.trace_line()};_b_.None;'
                 for_node.add($NodeJS(js))
             }
             var in_loop = false
@@ -4743,17 +5161,17 @@
             if (range_is_builtin) {
                 node.parent.children.splice(rank, 1)
                 var k = 0
                 if (this.has_break) {
                     node.parent.insert(rank, new_nodes[0])
                     k++
                 }
-                new_nodes[k].children.forEach(function(child) {
+                for (var child of new_nodes[k].children) {
                     node.parent.insert(rank + k, child)
-                })
+                }
                 node.parent.children[rank].line_num = node.line_num
                 node.parent.children[rank].bindings = node.bindings
                 node.children = []
                 return 0
             }
             var else_node = $NodeJS("else")
             new_nodes[pos++] = else_node
@@ -4766,14 +5184,17 @@
         var new_node = new $Node()
         new_node.line_num = $get_node(this).line_num
         var it_js = iterable.to_js(),
             iterable_name = '$iter' + num,
             js = 'var ' + iterable_name + ' = ' + it_js + ';' +
             '$locals["$next' + num + '"]' + ' = $B.$getattr($B.$iter(' +
             iterable_name + '),"__next__")'
+        if (it_js == 'expr') {
+            console.log('it js is expr, iterable', iterable)
+        }
         new $NodeJSCtx(new_node, js)
         new_nodes[pos++] = new_node
         if (this.has_break) {
             new_nodes[pos++] = $NodeJS(local_ns + '["$no_break' + num +
                 '"] = true;')
         }
         var while_node = new $Node()
@@ -4813,17 +5234,17 @@
         }
         var assign = new $AssignCtx(target_expr)
         assign.tree[1] = new $JSCode('$locals["$next' + num + '"]()')
         try_node.add(iter_node)
         while_node.add(
             $NodeJS('catch($err){if($B.is_exc($err, [_b_.StopIteration]))' +
                 '{break;}else{throw($err)}}'))
-        children.forEach(function(child) {
+        for (var child of children) {
             while_node.add(child.clone())
-        })
+        }
         if (node.children.length == 0) {
             console.log("bizarre", this)
         }
         if ($B.last(node.children).C.tree[0].type != "return") {
             var js = '$locals.$line_info = "' + node.line_num +
                 ',' + this.module + '";if($locals.$f_trace !== _b_.None){' +
                 '$B.trace_line()};_b_.None;'
@@ -4877,17 +5298,17 @@
             try_node.add(new_node)
         }
         var catch_node = $NodeJS('catch(err)')
         while_node.add(catch_node)
         var js = 'if(err.__class__ === _b_.StopAsyncIteration)' +
             '{' + running_name + ' = false; continue}else{throw err}'
         catch_node.add($NodeJS(js))
-        node.children.forEach(function(child) {
+        for (var child of node.children) {
             while_node.add(child)
-        })
+        }
         node.parent.children.splice(rank, 1)
         for (var i = new_nodes.length - 1; i >= 0; i--) {
             node.parent.insert(rank, new_nodes[i])
         }
         node.children = []
         return 0
     }
@@ -4909,20 +5330,20 @@
         this.names[this.names.length] = name
         if (name == '*') {
             this.scope.blurred = true
         }
     }
     $FromCtx.prototype.bind_names = function() {
         var scope = $get_scope(this)
-        this.names.forEach(function(name) {
+        for (var name of this.names) {
             if (Array.isArray(name)) {
                 name = name[1]
             }
             $bind(name, scope, this)
-        }, this)
+        }
     }
     $FromCtx.prototype.transition = function(token, value) {
         var C = this
         switch (token) {
             case 'id':
                 if (C.expect == 'id') {
                     C.add_name(value)
@@ -5028,15 +5449,15 @@
                 } else {
                     $package = $B.imported[$package]
                     packages.pop()
                 }
                 if ($package === undefined) {
                     return 'throw _b_.SystemError.$factory("Parent module \'\' ' +
                         'not loaded, cannot perform relative import")'
-                } else if ($package == 'None') {
+                } else if ($package === 'None') {
                     console.log('package is None !')
                 }
                 _mod = _mod.substr(1)
             } else {
                 break
             }
         }
@@ -5062,25 +5483,25 @@
             sep = ','
         }
         res[pos++] = '}, {}, true);'
         if (this.names[0] == '*') {
             scope.blurred = true
             res[pos++] = '\n' + head + '$B.import_all($locals, module);'
         } else {
-            this.names.forEach(function(name) {
+            for (var name of this.names) {
                 var alias = name
                 if (Array.isArray(name)) {
                     alias = name[1]
                     name = name[0]
                 }
                 module.imports[this.module + '.' + name] = true
                 res[pos++] = '\n' + head + '$locals["' +
                     alias + '"] = $B.$getattr($B.imported["' +
                     mod_name + '"], "' + name + '");'
-            }, this)
+            }
         }
         res[pos++] = '\n' + head + '_b_.None;'
         return res.join('');
     }
     var $FuncArgs = $B.parser.$FuncArgs = function(C) {
         this.type = 'func_args'
         this.parent = C
@@ -5093,14 +5514,34 @@
         this.has_kw_arg = false
     }
     $FuncArgs.prototype.toString = function() {
         return 'func args ' + this.tree
     }
     $FuncArgs.prototype.transition = function(token, value) {
         var C = this
+
+        function check() {
+            if (C.tree.length == 0) {
+                return
+            }
+            var last = $B.last(C.tree)
+            if (C.has_default && !last.has_default) {
+                if (last.type == 'func_star_arg' ||
+                    last.type == 'end_positional') {
+                    return
+                }
+                if (C.names.indexOf('*') > -1) {
+                    return
+                }
+                $_SyntaxError(C, ['non-default argument follows default argument'])
+            }
+            if (last.has_default) {
+                C.has_default = true
+            }
+        }
         switch (token) {
             case 'id':
                 if (C.has_kw_arg) {
                     $_SyntaxError(C, 'duplicate keyword argument')
                 }
                 if (C.expect == 'id') {
                     C.expect = ','
@@ -5109,20 +5550,22 @@
                             ' in function definition'
                         ])
                     }
                 }
                 return new $FuncArgIdCtx(C, value)
             case ',':
                 if (C.expect == ',') {
+                    check()
                     C.expect = 'id'
                     return C
                 }
                 $_SyntaxError(C, 'token ' + token + ' after ' +
                     C)
             case ')':
+                check()
                 var last = $B.last(C.tree)
                 if (last && last.type == "func_star_arg") {
                     if (last.name == "*") {
                         if (C.op == '*') {
                             $_SyntaxError(C, ['named arguments must follow bare *'])
                         } else {
                             $_SyntaxError(C, 'invalid syntax')
@@ -5161,14 +5604,17 @@
     }
     $FuncArgs.prototype.to_js = function() {
         this.js_processed = true
         return $to_js(this.tree)
     }
     var $FuncArgIdCtx = $B.parser.$FuncArgIdCtx = function(C, name) {
         this.type = 'func_arg_id'
+        if (["None", "True", "False"].indexOf(name) > -1) {
+            $_SyntaxError(C, 'invalid name')
+        }
         this.name = name
         this.parent = C
         if (C.has_star_arg) {
             C.parent.after_star.push(name)
         } else {
             C.parent.positional_list.push(name)
         }
@@ -5253,14 +5699,17 @@
                 if (C.name === undefined) {
                     if (C.parent.names.indexOf(value) > -1) {
                         $_SyntaxError(C, ['duplicate argument ' + value +
                             ' in function definition'
                         ])
                     }
                 }
+                if (["None", "True", "False"].indexOf(value) > -1) {
+                    $_SyntaxError(C, 'invalid name')
+                }
                 C.set_name(value)
                 C.parent.names.push(value)
                 return C
             case ',':
             case ')':
                 if (C.name === undefined) {
                     C.set_name('*')
@@ -5315,19 +5764,43 @@
         }
         this.module.binding = this.module.binding || {}
         this.$pos = $pos
     }
     $GlobalCtx.prototype.toString = function() {
         return 'global ' + this.tree
     }
+
+    function check_global_nonlocal(C, value, type) {
+        var scope = C.scope
+        if (type == 'nonlocal' && scope.globals && scope.globals.has(value)) {
+            $_SyntaxError(C, [`name '${value}' is nonlocal and global`])
+        }
+        if (type == 'global' && scope.nonlocals && scope.nonlocals.has(value)) {
+            $_SyntaxError(C, [`name '${value}' is nonlocal and global`])
+        }
+        if (['def', 'generator'].indexOf(scope.ntype) > -1) {
+            var params = scope.C.tree[0]
+            if (params.locals && params.locals.indexOf(value) > -1) {
+                $_SyntaxError(C, [`name '${value}' is parameter and ${type}`])
+            }
+            if (scope.binding[value]) {
+                console.log('scope ntype', scope)
+                $_SyntaxError(C, [`name '${value}' is assigned to before ${type} declaration`])
+            }
+            if (scope.referenced && scope.referenced[value]) {
+                $_SyntaxError(C, [`name '${value}' is used prior to ${type} declaration`])
+            }
+        }
+    }
     $GlobalCtx.prototype.transition = function(token, value) {
         var C = this
         switch (token) {
             case 'id':
                 if (C.expect == 'id') {
+                    check_global_nonlocal(C, value, 'global')
                     new $IdCtx(C, value)
                     C.add(value)
                     C.expect = ','
                     return C
                 }
                 break
             case ',':
@@ -5358,16 +5831,16 @@
             $pos = this.$pos - 1
             $_SyntaxError(this, [`name '${name}' is parameter and global`])
         }
         this.scope.globals.add(name)
         var mod = this.scope.parent_block
         if (this.module.module.startsWith("$exec")) {
             while (mod && mod.parent_block !== this.module) {
-                mod._globals = mod._globals || {}
-                mod._globals[name] = this.module.id
+                mod._globals = mod._globals || new Map()
+                mod._globals.set(name, this.module.id)
                 delete mod.binding[name]
                 mod = mod.parent_block
             }
         }
         this.module.binding[name] = true
     }
     $GlobalCtx.prototype.to_js = function() {
@@ -5380,17 +5853,20 @@
         this.parent = C
         this.tree = []
         C.tree[C.tree.length] = this
         var scope = this.scope = $get_scope(this)
         this.blurred_scope = this.scope.blurred
         this.env = clone(this.scope.binding)
         if (["def", "generator"].indexOf(scope.ntype) > -1) {
-            scope.referenced = scope.referenced || {}
-            if (!$B.builtins[this.value]) {
-                scope.referenced[this.value] = true
+            if ((!(C instanceof $GlobalCtx)) &&
+                !(C instanceof $NonlocalCtx)) {
+                scope.referenced = scope.referenced || {}
+                if (!$B.builtins[this.value]) {
+                    scope.referenced[this.value] = true
+                }
             }
         }
         if (C.parent.type == 'call_arg') {
             this.call_arg = true
         }
         var ctx = C
         while (ctx.parent !== undefined) {
@@ -5438,30 +5914,55 @@
                     scope.globals = new Set([value])
                 } else {
                     scope.globals.add(value)
                 }
             }
         }
     }
+    $IdCtx.prototype.ast = function() {
+        if (['True', 'False', 'None'].indexOf(this.value) > -1) {
+            return new ast.Constant(this.value)
+        }
+        return new ast.Name(this.value)
+    }
     $IdCtx.prototype.toString = function() {
         return '(id) ' + this.value + ':' + (this.tree || '')
     }
     $IdCtx.prototype.transition = function(token, value) {
         var C = this
         if (C.value == '$$case' && C.parent.parent.type == "node") {
             var start = C.parent.$pos,
                 src = $get_module(this).src
-            if (line_ends_with_comma(src.substr(start))) {
+            try {
+                var flag = line_ends_with_comma(src.substr(start))
+            } catch (err) {
+                $pos = start + err.offset
+                $_SyntaxError(C, [err.message])
+            }
+            if (flag) {
+                var node = $get_node(C),
+                    parent = node.parent
+                if ((!node.parent) || !(node.parent.is_match)) {
+                    $_SyntaxError(C, '"case" not inside "match"')
+                } else {
+                    if (node.parent.irrefutable) {
+                        var name = node.parent.irrefutable,
+                            msg = name == '_' ? 'wildcard' :
+                            `name capture '${name}'`
+                        $_SyntaxError(C, [`${msg} makes remaining patterns unreachable`])
+                    }
+                }
                 return $transition(new $PatternCtx(
                     new $CaseCtx(C.parent.parent)), token, value)
             }
         } else if (C.value == 'match' && C.parent.parent.type == "node") {
             var start = C.parent.$pos,
-                src = $get_module(this).src
-            if (line_ends_with_comma(src.substr(start))) {
+                src = $get_module(this).src,
+                flag = line_ends_with_comma(src.substr(start))
+            if (flag) {
                 return $transition(new $AbstractExprCtx(
                     new $MatchCtx(C.parent.parent), true), token, value)
             }
         }
         switch (token) {
             case '=':
                 if (C.parent.type == 'expr' &&
@@ -5474,14 +5975,15 @@
             case '.':
                 delete this.bound
                 return $transition(C.parent, token, value)
             case 'op':
                 return $transition(C.parent, token, value)
             case 'id':
             case 'str':
+            case 'JoinedStr':
             case 'int':
             case 'float':
             case 'imaginary':
                 if (["print", "exec"].indexOf(C.value) > -1) {
                     $_SyntaxError(C, ["missing parenthesis in call to '" +
                         C.value + "'"
                     ])
@@ -5609,31 +6111,31 @@
         if (val.startsWith("comp_result_" + $B.lambda_magic)) {
             if (this.bound) {
                 return "var " + val
             }
             return val
         }
         this.js_processed = true
-        if (this.scope._globals && this.scope._globals[val]) {
-            this.global_module = this.scope._globals[val]
+        if (this.scope._globals && this.scope._globals.has(val)) {
+            this.global_module = this.scope._globals.get(val)
         }
         if (this.global_module) {
             if (this.bound) {
                 return '$locals_' + this.global_module.replace(/\./g, "_") +
                     '["' + val + '"]'
             } else {
                 return '$B.$check_def_global("' + val + '", $locals_' +
                     this.global_module.replace(/\./g, "_") + ')'
             }
         }
         var is_local = this.scope.binding[val] !== undefined,
             this_node = $get_node(this),
             bound_before = this_node.bound_before
         this.nonlocal = this.scope.nonlocals &&
-            this.scope.nonlocals[val] !== undefined
+            this.scope.nonlocals.has(val)
         this.unbound = this.unbound || (is_local && !this.bound &&
             bound_before && bound_before.indexOf(val) == -1)
         if ((!this.bound) && this.scope.C &&
             this.scope.ntype == 'class' &&
             this.scope.C.tree[0].name == val) {
             return '$B.$search("' + val + '")'
         }
@@ -5687,16 +6189,15 @@
             } else if (this.bound) {
                 return "$locals_" + innermost.id.replace(/\./g, "_") +
                     '["' + val + '"]'
             }
         }
         var global_ns = '$locals_' + gs.id.replace(/\./g, '_')
         while (1) {
-            if (scope.globals !== undefined &&
-                scope.globals.has(val)) {
+            if (scope.globals !== undefined && scope.globals.has(val)) {
                 if ($test) {
                     console.log("in globals of", scope.id, 'globals', gs)
                 }
                 if (this.boundBefore(gs)) {
                     if ($test) {
                         console.log("bound before in gs", gs, global_ns)
                     }
@@ -5713,15 +6214,15 @@
                     }
                 }
             }
             if ($test) {
                 console.log("scope", scope.id, scope, "innermost", innermost, "scope is innermost", scope === innermost, "bound_before", bound_before, "found", found.slice())
             }
             if (scope === innermost) {
-                if (bound_before) {
+                if (bound_before && bound_before.length > 0) {
                     if (bound_before.indexOf(val) > -1) {
                         found.push(scope)
                     } else if (scope.C &&
                         scope.C.tree[0].type == 'def' &&
                         scope.C.tree[0].env.indexOf(val) > -1) {
                         found.push(scope)
                     }
@@ -5764,17 +6265,17 @@
             } else {
                 break
             }
         }
         this.found = found
         if ($test) {
             console.log(val, "found", found)
-            found.forEach(function(item) {
+            for (var item of found) {
                 console.log(item.id)
-            })
+            }
         }
         if (this.nonlocal && found[0] === innermost) {
             found.shift()
         }
         if (found.length > 0) {
             if (found[0].C && found[0] === innermost &&
                 val.charAt(0) != '$') {
@@ -5953,47 +6454,47 @@
                 }
                 break
         }
         $_SyntaxError(C, 'token ' + token + ' after ' + C)
     }
     $ImportCtx.prototype.bind_names = function() {
         var scope = $get_scope(this)
-        this.tree.forEach(function(item) {
+        for (var item of this.tree) {
             if (item.name == item.alias) {
                 var name = item.name,
                     parts = name.split('.'),
                     bound = name
                 if (parts.length > 1) {
                     bound = parts[0]
                 }
             } else {
                 bound = item.alias
             }
             $bind(bound, scope, this)
-        }, this)
+        }
     }
     $ImportCtx.prototype.to_js = function() {
         this.js_processed = true
         var scope = $get_scope(this),
             res = [],
             module = $get_module(this)
-        this.tree.forEach(function(item) {
+        for (var item of this.tree) {
             var mod_name = item.name,
                 aliases = (item.name == item.alias) ?
                 '{}' : ('{"' + mod_name + '" : "' +
                     item.alias + '"}'),
                 localns = '$locals_' + scope.id.replace(/\./g, '_'),
                 mod_elts = item.name.split(".")
             for (var i = 0; i < mod_elts.length; i++) {
                 module.imports[mod_elts.slice(0, i + 1).join(".")] = true
             }
             var js = '$B.$import("' + mod_name + '", [],' + aliases +
                 ',' + localns + ', true);'
             res.push(js)
-        })
+        }
         return res.join('') + '_b_.None;'
     }
     var $ImportedModuleCtx = $B.parser.$ImportedModuleCtx = function(C, name) {
         this.type = 'imported module'
         this.parent = C
         this.name = name
         this.alias = name
@@ -6005,14 +6506,147 @@
     $ImportedModuleCtx.prototype.transition = function(token, value) {
         var C = this
     }
     $ImportedModuleCtx.prototype.to_js = function() {
         this.js_processed = true
         return '"' + this.name + '"'
     }
+    var JoinedStrCtx = $B.parser.JoinedStrCtx = function(C, values) {
+        this.type = 'JoinedStr'
+        this.parent = C
+        this.tree = []
+        this.scope = $get_scope(C)
+        var line_num = $get_node(C).line_num
+        for (var value of values) {
+            if (typeof value == "string") {
+                new $StringCtx(this, "'" +
+                    value.replace(new RegExp("'", "g"), "\\" + "'") + "'")
+            } else {
+                if (value.format !== undefined) {
+                    value.format = new JoinedStrCtx(this, value.format)
+                    this.tree.pop()
+                }
+                var src = value.expression,
+                    save_pos = $pos,
+                    root = $create_root_node({
+                        src
+                    }, this.scope.module, this.scope.id, this.scope.parent_block, line_num)
+                dispatch_tokens(root, src)
+                $pos = save_pos
+                var expr = root.children[0].C.tree[0]
+                this.tree.push(expr)
+                expr.parent = this
+                expr.elt = value
+            }
+        }
+        C.tree.push(this)
+        this.raw = false
+        this.$pos = $pos
+    }
+    JoinedStrCtx.prototype.ast = function() {
+        console.log('ast, values', this.tree)
+        var res = {
+            type: 'JoinedStr',
+            values: []
+        }
+        for (var item of this.tree) {
+            if (item instanceof $StringCtx) {
+                res.values.push(new ast.Constant(item.value))
+            } else {
+                var conv_num = {
+                        a: 97,
+                        r: 114,
+                        s: 115
+                    },
+                    value = {
+                        type: 'FormattedValue',
+                        value: item,
+                        conversion: conv_num[item.conversion] || -1
+                    }
+                var format = item.format
+                if (format !== undefined) {
+                    value.format = item.format.ast()
+                }
+                res.values.push(value)
+            }
+        }
+        return res
+    }
+    JoinedStrCtx.prototype.toString = function() {
+        return 'f-string ' + (this.tree || '')
+    }
+    JoinedStrCtx.prototype.transition = function(token, value) {
+        var C = this
+        switch (token) {
+            case '[':
+                return new $AbstractExprCtx(new $SubCtx(C.parent), false)
+            case '(':
+                C.parent.tree[0] = C
+                return new $CallCtx(C.parent)
+            case 'str':
+                if (C.tree.length > 0 &&
+                    typeof $B.last(C.tree) == "string") {
+                    C.tree[C.tree.length - 1] =
+                        $B.last(C.tree) + eval(value)
+                } else {
+                    new $StringCtx(this, value)
+                }
+                return C
+            case 'JoinedStr':
+                var joined_expr = new JoinedStrCtx(C.parent, value)
+                C.parent.tree.pop()
+                if (C.tree.length > 0 &&
+                    $B.last(C.tree) instanceof $StringCtx &&
+                    joined_expr.tree[0] instanceof $StringCtx) {
+                    $B.last(C.tree).value += ' + ' + joined_expr.tree[0].value
+                    C.tree = C.tree.concat(joined_expr.tree.slice(1))
+                } else {
+                    C.tree = C.tree.concat(joined_expr.tree)
+                }
+                return C
+        }
+        return $transition(C.parent, token, value)
+    }
+    JoinedStrCtx.prototype.to_js = function() {
+        this.js_processed = true
+        var res = '',
+            elts = []
+        for (var value of this.tree) {
+            if (value instanceof $StringCtx) {
+                elts.push(value.to_js())
+            } else {
+                var elt = value.elt,
+                    js = value.to_js()
+                var pos = 0,
+                    br_stack = []
+                switch (elt.conversion) {
+                    case "a":
+                        js = '_b_.ascii(' + js + ')'
+                        break
+                    case "r":
+                        js = '_b_.repr(' + js + ')'
+                        break
+                    case "s":
+                        js = '_b_.str.$factory(' + js + ')'
+                        break
+                }
+                var fmt = elt.format
+                if (fmt !== undefined) {
+                    js = "_b_.str.format('{0:' + " +
+                        fmt.to_js() + " + '}', " + js + ")"
+                } else {
+                    if (elt.conversion === null) {
+                        js = '_b_.str.$factory(' + js + ')'
+                    }
+                }
+                elts.push(js)
+            }
+        }
+        return "$B.String(" + (elts.join(' + ') || "''") + ")"
+    }
     var $JSCode = $B.parser.$JSCode = function(js) {
         this.js = js
     }
     $JSCode.prototype.toString = function() {
         return this.js
     }
     $JSCode.prototype.transition = function(token, value) {
@@ -6048,17 +6682,14 @@
             return new $CallArgCtx(C.parent.parent)
         }
         return $transition(C.parent, token)
     }
     $KwArgCtx.prototype.to_js = function() {
         this.js_processed = true
         var key = this.tree[0].value
-        if (key.substr(0, 2) == '$$') {
-            key = key.substr(2)
-        }
         var res = '{$nat:"kw",name:"' + key + '",'
         return res + 'value:' +
             $to_js(this.tree.slice(1, this.tree.length)) + '}'
     }
     var $LambdaCtx = $B.parser.$LambdaCtx = function(C) {
         this.type = 'lambda'
         this.parent = C
@@ -6106,15 +6737,14 @@
         var scope = $get_scope(this)
         var rand = $B.UUID(),
             func_name = 'lambda_' + $B.lambda_magic + '_' + rand,
             py = 'def ' + func_name + '(' + args + '):\n'
         py += '    return (' + body + '\n)'
         var lambda_name = 'lambda' + rand,
             module_name = module.id.replace(/\./g, '_')
-        node.line_num--
         var root = $B.py2js(py, module_name, lambda_name, scope, node.line_num)
         var js = root.to_js()
         var params = `$locals_${lambda_name}`,
             args = "{}"
         if (module.is_comp) {
             params += `, $locals_${module.id.replace(/\./g, '_')}`
             args += `, typeof $locals_${module.id.replace(/\./g, '_')} ` +
@@ -6133,14 +6763,24 @@
         this.real = real
         this.expect = 'id'
         this.closed = false
         this.parent = C
         this.tree = []
         C.tree[C.tree.length] = this
     }
+    $ListOrTupleCtx.prototype.ast = function() {
+        var elts = []
+        for (var item of this.tree) {
+            elts.push(ast_or_obj(item))
+        }
+        return {
+            type: 'List',
+            elts
+        }
+    }
     $ListOrTupleCtx.prototype.toString = function() {
         switch (this.real) {
             case 'list':
                 return '(list) [' + this.tree + ']'
             case 'list_comp':
             case 'gen_expr':
                 return '(' + this.real + ') [' + this.intervals + '-' +
@@ -6238,30 +6878,32 @@
                                     $pos = _yield[1]
                                     var comp_type = C.parent.real == "set_comp" ?
                                         "set" : "dict"
                                     $_SyntaxError(C, [`'yield' inside ${comp_type} comprehension`])
                                 }
                             }
                             C.intervals.push($pos)
+                            C.src = $get_module(C).src
                             return $transition(C.parent, token)
                         }
                         break
                 }
                 switch (token) {
                     case ',':
                         if (C.real == 'tuple') {
                             C.has_comma = true
                         }
                         C.expect = 'id'
                         return C
                     case 'for':
                         if (C.real == 'list') {
                             if (this.tree.length > 1) {
-                                $_SyntaxError(C, "unparenthesized " +
-                                    "expression before 'for'")
+                                $_SyntaxError(C, ["did you forget " +
+                                    "parentheses around the comprehension target?"
+                                ])
                             }
                             C.real = 'list_comp'
                         } else {
                             C.real = 'gen_expr'
                         }
                         C.intervals = [C.start + 1]
                         C.expression = C.tree
@@ -6331,14 +6973,15 @@
             } else {
                 return $transition(C.parent, token, value)
             }
         }
     }
     $ListOrTupleCtx.prototype.close = function() {
         this.closed = true
+        this.src = $get_module(this).src
         for (var i = 0, len = this.tree.length; i < len; i++) {
             var elt = this.tree[i]
             if (elt.type == "expr" &&
                 elt.tree[0].type == "list_or_tuple" &&
                 elt.tree[0].real == "tuple" &&
                 elt.tree[0].tree.length == 1 &&
                 elt.tree[0].expect == ",") {
@@ -6358,24 +7001,24 @@
     }
     $ListOrTupleCtx.prototype.get_src = function() {
         var src = $get_module(this).src
         var scope = $get_scope(this)
         if (scope.comments === undefined) {
             return src
         }
-        scope.comments.forEach(function(comment) {
+        for (var comment of scope.comments) {
             var start = comment[0],
                 len = comment[1]
             src = src.substr(0, start) + ' '.repeat(len + 1) +
                 src.substr(start + len + 1)
-        })
+        }
         return src
     }
     $ListOrTupleCtx.prototype.bind_ids = function(scope) {
-        this.tree.forEach(function(item) {
+        for (var item of this.tree) {
             if (item.type == 'id') {
                 $bind(item.value, scope, this)
                 item.bound = true
             } else if (item.type == 'expr' && item.tree[0].type == "id") {
                 $bind(item.tree[0].value, scope, this)
                 item.tree[0].bound = true
             } else if (item.type == 'expr' && item.tree[0].type == "packed") {
@@ -6388,15 +7031,15 @@
                 (item.type == "expr" &&
                     item.tree[0].type == 'list_or_tuple')) {
                 if (item.type == "expr") {
                     item = item.tree[0]
                 }
                 item.bind_ids(scope)
             }
-        }, this)
+        }
     }
     $ListOrTupleCtx.prototype.packed_indices = function() {
         var ixs = []
         for (var i = 0; i < this.tree.length; i++) {
             var t = this.tree[i]
             if (t.type == "expr") {
                 t = t.tree[0]
@@ -6438,15 +7081,19 @@
                 if (packed.length > 0) {
                     return '$B.$list(' + this.unpack(packed) + ')'
                 }
                 return '$B.$list([' + $to_js(this.tree) + '])'
             case 'list_comp':
             case 'gen_expr':
             case 'dict_or_set_comp':
-                var src = this.get_src()
+                if (this.src === undefined) {
+                    console.log('no src', this)
+                    console.log($B.frames_stack.slice())
+                }
+                var src = this.src
                 var res1 = [],
                     items = []
                 var qesc = new RegExp('"', "g")
                 var comments = root.comments
                 for (var i = 1; i < this.intervals.length; i++) {
                     var start = this.intervals[i - 1],
                         end = this.intervals[i],
@@ -6460,36 +7107,36 @@
                                 txt.substr(pos + comment[1] + 1)
                         }
                     }
                     txt = txt.replace(/\\\n/g, " ")
                     items.push(txt)
                     var lines = txt.split('\n')
                     var res2 = []
-                    lines.forEach(function(txt) {
+                    for (var txt of lines) {
                         if (txt.replace(/ /g, '').length != 0) {
                             txt = txt.replace(/\n/g, ' ')
                             txt = txt.replace(/\\/g, '\\\\')
                             txt = txt.replace(qesc, '\\"')
                             res2.push('"' + txt + '"')
                         }
-                    })
+                    }
                     res1.push('[' + res2.join(',') + ']')
                 }
                 var line_num = $get_node(this).line_num
                 switch (this.real) {
                     case 'list_comp':
                         var lc = $B.$list_comp(items),
                             py = lc[0],
                             ix = lc[1],
                             listcomp_name = 'comp_result_' + $B.lambda_magic + ix,
                             save_pos = $pos,
                             line_info = line_num + ',' + module_name
                         var root = $B.py2js({
                             src: py,
-                            is_comp: true,
+                            is_comp: 'listcomp',
                             line_info: line_info
                         }, module_name, listcomp_name, scope, 1)
                         var has_yield = root.yields_func_check !== undefined
                         var outermost_expr = root.outermost_expr
                         if ($get_node(this).has_yield) {
                             outermost_expr = this.tree[0].tree[0].tree[1]
                         }
@@ -6500,15 +7147,15 @@
                         $pos = save_pos
                         var js = root.to_js()
                         root = null
                         $B.clear_ns(listcomp_name)
                         delete $B.$py_src[listcomp_name]
                         js += 'return ' + listcomp_name
                         js = "function" + (has_yield ? "*" : "") +
-                            `(expr){${js}})(${outer_most})`
+                            `(_expr){${js}})(${outer_most})`
                         if (this.is_await) {
                             js = 'async ' + js
                         }
                         return '(' + js
                     case 'dict_or_set_comp':
                         if (this.expression.length == 1) {
                             return $B.$gen_expr(module_name, scope, items, line_num, true)
@@ -6533,15 +7180,14 @@
         node_ctx.node.is_match = true
         this.parent = node_ctx
         this.tree = []
         this.expect = 'as'
     }
     $MatchCtx.prototype.transition = function(token, value) {
         var C = this
-        console.log('transition on match', token, value)
         switch (token) {
             case 'as':
                 return new $AbstractExprCtx(new $AliasCtx(C))
             case ':':
                 switch (C.expect) {
                     case 'id':
                     case 'as':
@@ -6616,14 +7262,15 @@
             case '.':
             case 'bytes':
             case 'float':
             case 'id':
             case 'imaginary':
             case 'int':
             case 'str':
+            case 'JoinedStr':
             case 'not':
             case 'lambda':
                 var expr = new $AbstractExprCtx(C, true)
                 return $transition(expr, token, value)
             case 'assert':
                 return new $AbstractExprCtx(
                     new $AssertCtx(C), false, true)
@@ -6689,19 +7336,20 @@
             case 'lambda':
                 return new $LambdaCtx(C)
             case 'nonlocal':
                 return new $NonlocalCtx(C)
             case 'op':
                 switch (value) {
                     case '*':
+                        var expr = new $AbstractExprCtx(C, true)
+                        return $transition(expr, token, value)
                     case '+':
                     case '-':
                     case '~':
-                        var expr = new $AbstractExprCtx(C, true)
-                        return $transition(expr, token, value)
+                        return new $UnaryCtx(C, value)
                     case '@':
                         return new $DecoratorCtx(C)
                 }
                 break
             case 'pass':
                 return new $PassCtx(C)
             case 'raise':
@@ -6745,15 +7393,14 @@
                             this.tree[0].tree[0].value + "', " +
                             this.tree[0].annotation.to_js() + ");"
                     } else if (this.tree[0].type == "def" ||
                         this.tree[0].type == "generator") {
                         this.js = this.tree[0].annotation.to_js() + ";"
                     } else {
                         this.js = ""
-                        this.tree = []
                     }
                 } else if (["def", "generator"].indexOf(this.tree[0].type) == -1) {
                     this.tree = []
                 }
             } else if (this.tree[0].type == "assign" &&
                 !this.tree[0].tree[0].$in_parens &&
                 this.tree[0].tree[0].annotation) {
@@ -6807,34 +7454,35 @@
         this.type = 'nonlocal'
         this.parent = C
         this.tree = []
         this.names = {}
         C.tree[C.tree.length] = this
         this.expect = 'id'
         this.scope = $get_scope(this)
-        this.scope.nonlocals = this.scope.nonlocals || {}
+        this.scope.nonlocals = this.scope.nonlocals || new Set()
         if (this.scope.C === undefined) {
             $_SyntaxError(C, ["nonlocal declaration not allowed at module level"])
         }
     }
     $NonlocalCtx.prototype.toString = function() {
         return 'nonlocal ' + this.tree
     }
     $NonlocalCtx.prototype.add = function(name) {
         if (this.scope.binding[name] == "arg") {
             $_SyntaxError(C, ["name '" + name + "' is parameter and nonlocal"])
         }
         this.names[name] = [false, $pos]
-        this.scope.nonlocals[name] = true
+        this.scope.nonlocals.add(name)
     }
     $NonlocalCtx.prototype.transition = function(token, value) {
         var C = this
         switch (token) {
             case 'id':
                 if (C.expect == 'id') {
+                    check_global_nonlocal(C, value, 'nonlocal')
                     new $IdCtx(C, value)
                     C.add(value)
                     C.expect = ','
                     return C
                 }
                 break
             case ',':
@@ -6884,28 +7532,32 @@
     }
     var $NotCtx = $B.parser.$NotCtx = function(C) {
         this.type = 'not'
         this.parent = C
         this.tree = []
         C.tree[C.tree.length] = this
     }
+    $NotCtx.prototype.ast = function() {
+        return new ast.UnaryOp(new ast.Not(), ast_or_obj(this.tree[0]))
+    }
     $NotCtx.prototype.toString = function() {
         return 'not (' + this.tree + ')'
     }
     $NotCtx.prototype.transition = function(token, value) {
         var C = this
         switch (token) {
             case 'in':
                 C.parent.parent.tree.pop()
                 return new $ExprCtx(new $OpCtx(C.parent, 'not_in'), 'op', false)
             case 'id':
             case 'imaginary':
             case 'int':
             case 'float':
             case 'str':
+            case 'JoinedStr':
             case 'bytes':
             case '[':
             case '(':
             case '{':
             case '.':
             case 'not':
             case 'lambda':
@@ -6927,33 +7579,29 @@
     var $NumberCtx = $B.parser.$NumberCtx = function(type, C, value) {
         this.type = type
         this.value = value
         this.parent = C
         this.tree = []
         C.tree[C.tree.length] = this
     }
+    $NumberCtx.prototype.ast = function() {
+        var value = this.value
+        if (Array.isArray(value)) {
+            value = parseInt(value[1], value[0])
+        }
+        if (this.type == 'imaginary') {
+            value += 'j'
+        }
+        return new ast.Constant(value)
+    }
     $NumberCtx.prototype.toString = function() {
         return this.type + ' ' + this.value
     }
     $NumberCtx.prototype.transition = function(token, value) {
         var C = this
-        switch (token) {
-            case 'id':
-            case 'imaginary':
-            case 'int':
-            case 'float':
-            case 'str':
-            case 'bytes':
-            case '[':
-            case '(':
-            case '{':
-            case 'lambda':
-                $_SyntaxError(C, 'token ' + token + ' after ' +
-                    C)
-        }
         return $transition(C.parent, token, value)
     }
     $NumberCtx.prototype.to_js = function() {
         this.js_processed = true
         var type = this.type,
             value = this.value
         if (type == 'int') {
@@ -6999,14 +7647,29 @@
                     this.left_type = binding.type
                 }
             }
         }
         C.parent.tree.pop()
         C.parent.tree.push(this)
     }
+    $OpCtx.prototype.ast = function() {
+        var op = binary_ops[this.op]
+        if (op) {
+            return new ast.BinaryOp(
+                ast_or_obj(this.tree[0]), ast[op], ast_or_obj(this.tree[1]))
+        }
+        op = boolean_ops[this.op]
+        if (op) {
+            return new ast.BooleanOp(
+                ast_or_obj(this.tree[0]), ast[op], ast_or_obj(this.tree[1]))
+        }
+        op = comparions_ops[this.op]
+        return new ast.BooleanOp(
+            ast_or_obj(this.tree[0]), ast[op], ast_or_obj(this.tree[1]))
+    }
     $OpCtx.prototype.toString = function() {
         return '(op ' + this.op + ') [' + this.tree + ']'
     }
     $OpCtx.prototype.transition = function(token, value) {
         var C = this
         if (C.op === undefined) {
             $_SyntaxError(C, ['C op undefined ' + C])
@@ -7032,14 +7695,15 @@
         }
         switch (token) {
             case 'id':
             case 'imaginary':
             case 'int':
             case 'float':
             case 'str':
+            case 'JoinedStr':
             case 'bytes':
             case '[':
             case '(':
             case '{':
             case '.':
             case 'not':
             case 'lambda':
@@ -7106,15 +7770,15 @@
                                     method + '__",' + this.tree[0].to_js() +
                                     ',' + this.tree[1].to_js() + '))'
                         }
                         break;
                     case 'str':
                         switch (t0.type) {
                             case 'str':
-                                return js0 + this.op + js1
+                                return js0 + '.valueOf() ' + this.op + js1 + '.valueOf()'
                             case 'int':
                                 switch (this.op) {
                                     case "==":
                                         return "false"
                                     case "!=":
                                         return "true"
                                     default:
@@ -7279,19 +7943,19 @@
                                     return '$B.mul(' + v0.to_js() + ',' +
                                         v1.to_js() + ')'
                             }
                         }
                         var tests = [],
                             tests1 = [],
                             pos = 0
-                        vars.forEach(function(_var) {
-                            tests.push('typeof ' + _var +
+                        for (var _var of vars) {
+                            tests.push(_var + '.valueOf && typeof ' + _var +
                                 '.valueOf() == "number"')
                             tests1.push('typeof ' + _var + ' == "number"')
-                        })
+                        }
                         var res = [tests.join(' && ') + ' ? ']
                         res.push('(' + tests1.join(' && ') + ' ? ')
                         res.push(this.simple_js())
                         res.push(' : new Number(' + this.simple_js() + ')')
                         res.push(')')
                         var t0 = this.tree[0].to_js(),
                             t1 = this.tree[1].to_js()
@@ -7391,14 +8055,17 @@
                 return new $ListOrTupleCtx(C, "list")
             case "(":
                 C.parent.expect = ','
                 return new $ListOrTupleCtx(C, "tuple")
             case 'str':
                 C.parent.expect = ","
                 return new $StringCtx(C, value)
+            case 'JoinedStr':
+                C.parent.expect = ","
+                return new JoinedStrCtx(C, value)
             case "]":
                 return $transition(C.parent, token, value)
             case "{":
                 C.parent.expect = ','
                 return new $DictOrSetCtx(C)
             case 'op':
                 switch (value) {
@@ -7419,14 +8086,17 @@
     }
     var $PassCtx = $B.parser.$PassCtx = function(C) {
         this.type = 'pass'
         this.parent = C
         this.tree = []
         C.tree[C.tree.length] = this
     }
+    $PassCtx.prototype.ast = function() {
+        return new ast.Pass()
+    }
     $PassCtx.prototype.toString = function() {
         return '(pass)'
     }
     $PassCtx.prototype.transition = function(token, value) {
         var C = this
         if (token == 'eol') {
             return C.parent
@@ -7455,36 +8125,50 @@
                     case 'imaginary':
                         C.expect = ','
                         return new $PatternLiteralCtx(C, token, value)
                     case 'op':
                         switch (value) {
                             case '-':
                             case '+':
-                                C.expect = 'number'
-                                C.sign = value
+                                C.expect = ','
+                                return new $PatternLiteralCtx(C, {
+                                    sign: value
+                                })
+                            case '*':
+                                C.expect = 'starred_id'
                                 return C
                             default:
                                 $_SyntaxError(C)
                         }
                     case 'id':
                         C.expect = ','
                         if (['None', 'True', 'False'].indexOf(value) > -1) {
                             return new $PatternLiteralCtx(C, token, value)
                         } else {
                             return new $PatternCaptureCtx(C, value)
                         }
                         break
                     case '[':
-                    case '(':
                         return new $PatternCtx(
                             new $PatternSequenceCtx(C.parent, token))
+                    case '(':
+                        return new $PatternCtx(
+                            new $PatternGroupCtx(C.parent, token))
                     case '{':
-                        return new $PatternMappingItemCtx(
-                            new $PatternMappingCtx(C.parent, token))
+                        return new $PatternMappingCtx(C.parent, token)
+                }
+                break
+            case 'starred_id':
+                if (token == 'id') {
+                    var capture = new $PatternCaptureCtx(C, value)
+                    capture.starred = true
+                    return capture
                 }
+                console.log('C expects starred id', C)
+                $_SyntaxError(C, 'expected id after *')
             case 'number':
                 switch (token) {
                     case 'int':
                     case 'float':
                     case 'imaginary':
                         C.expect = ','
                         return new $PatternLiteralCtx(C, token, value, C.sign)
@@ -7501,289 +8185,819 @@
                             new $PatternSequenceCtx(C.parent))
                     case ':':
                         return $BodyCtx(C)
                 }
         }
         return C.parent.transition(token, value)
     }
+
+    function as_pattern(C, token, value) {
+        if (C.expect == 'as') {
+            if (token == 'as') {
+                C.expect = 'alias'
+                return C
+            } else {
+                return $transition(C.parent, token, value)
+            }
+        } else if (C.expect == 'alias') {
+            if (token == 'id') {
+                if (value == '_') {
+                    $_SyntaxError(C, ["alias cannot be _"])
+                }
+                if (C.bindings().indexOf(value) > -1) {
+                    $_SyntaxError(C, [`multiple assignments to name '${value}' in pattern`])
+                }
+                C.alias = value
+                return C.parent
+            } else {
+                $_SyntaxError(C, 'bad alias')
+            }
+        }
+    }
     var $PatternCaptureCtx = function(C, value) {
         this.type = "capture_pattern"
         this.parent = C.parent
         C.parent.tree.pop()
         C.parent.tree.push(this)
         this.tree = [value]
         this.expect = '.'
         this.$pos = $pos
     }
+    $PatternCaptureCtx.prototype.bindings = function() {
+        var bindings = this.tree[0] == '_' ? [] : this.tree.slice()
+        if (this.alias) {
+            bindings.push(this.alias)
+        }
+        return bindings
+    }
     $PatternCaptureCtx.prototype.transition = function(token, value) {
         var C = this
         switch (C.expect) {
             case '.':
                 if (token == '.') {
                     C.type = "value_pattern"
-                    C.tree.push('.')
                     C.expect = 'id'
+                    if (C.tree.length == 1) {
+                        new $IdCtx(C, C.tree.pop())
+                    } else {
+                        C.tree.push('.')
+                    }
                     return C
                 } else if (token == '(') {
                     return new $PatternCtx(new $PatternClassCtx(C))
+                } else if (C.parent instanceof $PatternMappingCtx) {
+                    return C.parent.transition(token, value)
+                } else {
+                    C.expect = 'as'
+                    return C.transition(token, value)
                 }
+            case 'as':
+            case 'alias':
+                var res = as_pattern(C, token, value)
+                return res
             case 'id':
                 if (token == 'id') {
                     C.tree.push(value)
                     C.expect = '.'
                     return C
                 }
         }
         return $transition(C.parent, token, value)
     }
     $PatternCaptureCtx.prototype.to_js = function() {
+        var js
         if (this.tree.length == 1) {
-            return '{capture: "' + this.tree[0] + '"}'
+            js = '{capture'
+            if (this.starred == true) {
+                js += '_starred'
+            }
+            js += `: '${this.tree[0]}'`
+        } else {
+            js = this.tree[0].to_js()
+            for (var i = 1, len = this.tree.length; i < len; i += 2) {
+                js = '$B.$getattr(' + js + ', "' + this.tree[i] + '")'
+            }
+            js = `{value: ${js}`
         }
-        return '{value: "' + this.tree.join('') + '"}'
+        if (this.alias) {
+            js += `, alias: '${this.alias}'`
+        }
+        return js + '}'
     }
     $PatternClassCtx = function(C) {
         this.type = "class_pattern"
         this.tree = []
         this.parent = C.parent
-        this.class_name = C.tree.pop()
+        this.class_id = new $IdCtx(C, C.tree[0])
+        C.tree.pop()
+        this.attrs = C.tree.slice(2)
         C.parent.tree.pop()
         C.parent.tree.push(this)
         this.expect = ','
+        this.keywords = []
+        this.positionals = []
+        this.bound_names = []
+    }
+    $PatternClassCtx.prototype.bindings = function() {
+        var bindings = this.bound_names
+        if (this.alias) {
+            bindings.push(this.alias)
+        }
+        return bindings
     }
     $PatternClassCtx.prototype.transition = function(token, value) {
+        var C = this
+
+        function check_last_arg() {
+            var last = $B.last(C.tree),
+                bound
+            if (last instanceof $PatternCaptureCtx) {
+                if (!last.is_keyword &&
+                    C.keywords.length > 0) {
+                    $_SyntaxError(C, 'positional argument after keyword')
+                }
+                if (last.is_keyword) {
+                    if (C.keywords.indexOf(last.tree[0]) > -1) {
+                        $_SyntaxError(C, [`keyword argument repeated: ${last.tree[0]}`])
+                    }
+                    C.keywords.push(last.tree[0])
+                    bound = last.tree[1].bindings()
+                } else {
+                    bound = last.bindings()
+                }
+                for (var b of bound) {
+                    if (C.bound_names.indexOf(b) > -1) {
+                        $_SyntaxError(C, ['multiple assignments ' +
+                            `to name '${b}' in pattern`
+                        ])
+                    }
+                }
+                C.bound_names = C.bound_names.concat(bound)
+            }
+        }
         switch (this.expect) {
             case ',':
                 switch (token) {
                     case '=':
                         var current = $B.last(this.tree)
                         if (current instanceof $PatternCaptureCtx) {
-                            this.tree[this.tree.length - 1] = current.tree[0]
-                            return new $PatternCtx(this)
+                            if (this.keywords.indexOf(current.tree[0]) > -1) {
+                                $_SyntaxError(C, ['attribute name repeated in class pattern: ' +
+                                    current.tree[0]
+                                ])
+                            }
+                            current.is_keyword = true
+                            return new $PatternCtx(current)
                         }
-                        $_SyntaxError(this)
+                        $_SyntaxError(this, '= after non-capture')
                     case ',':
+                        check_last_arg()
                         return new $PatternCtx(this)
                     case ')':
-                        return this.parent
+                        check_last_arg()
+                        if ($B.last(this.tree).tree.length == 0) {
+                            this.tree.pop()
+                        }
+                        C.expect = 'as'
+                        return C
                     default:
                         $_SyntaxError(this)
                 }
+            case 'as':
+            case 'alias':
+                return as_pattern(C, token, value)
         }
+        return $transition(C.parent, token, value)
     }
     $PatternClassCtx.prototype.to_js = function() {
         var i = 0,
-            args = []
-        while (i < this.tree.length) {
-            var item = this.tree[i]
-            if (typeof item == "string") {
-                args.push('{' + item + ': ' + this.tree[i + 1].to_js() + '}')
-                i++
+            args = [],
+            kwargs = []
+        var klass = this.class_id.to_js()
+        for (var i = 0, len = this.attrs.length; i < len; i += 2) {
+            klass = '$B.$getattr(' + klass + ', "' + this.attrs[i] + '")'
+        }
+        for (var arg of this.positionals) {}
+        i = 0
+        for (item of this.tree) {
+            if (item instanceof $PatternCaptureCtx && item.tree.length > 1) {
+                kwargs.push(item.tree[0] + ': ' + item.tree[1].to_js())
             } else {
                 args.push(item.to_js())
             }
-            i++
         }
-        return '{class: [' + args.join(', ') + ']}'
+        var js = '{class: ' + klass + ', args: [' + args.join(', ') + '], ' +
+            'keywords: {' + kwargs.join(', ') + '}'
+        if (this.alias) {
+            js += `, alias: "${this.alias}"`
+        }
+        return js + '}'
+    }
+    var $PatternGroupCtx = function(C) {
+        this.type = "group_pattern"
+        this.parent = C
+        this.tree = []
+        var first_pattern = C.tree.pop()
+        this.expect = ',|'
+        C.tree.push(this)
+    }
+
+    function remove_empty_pattern(C) {
+        var last = $B.last(C.tree)
+        if (last && last instanceof $PatternCtx &&
+            last.tree.length == 0) {
+            C.tree.pop()
+        }
+    }
+    $PatternGroupCtx.prototype.bindings = function() {
+        var bindings = []
+        for (var item of this.tree) {
+            bindings = bindings.concat(item.bindings())
+        }
+        if (this.alias) {
+            bindings.push(this.alias)
+        }
+        return bindings
+    }
+    $PatternGroupCtx.prototype.transition = function(token, value) {
+        var C = this
+        switch (C.expect) {
+            case ',|':
+                if (token == ")") {
+                    remove_empty_pattern(C)
+                    C.expect = 'as'
+                    return C
+                } else if (token == ',') {
+                    C.expect = 'id'
+                    C.is_tuple = true
+                    return C
+                } else if (token == 'op' && value == '|') {
+                    var opctx = new $PatternOrCtx(C.parent)
+                    opctx.parenthese = true
+                    return new $PatternCtx(opctx)
+                } else if (this.token === undefined) {
+                    return $transition(C.parent, token, value)
+                }
+                $_SyntaxError(C)
+            case 'as':
+            case 'alias':
+                return as_pattern(C, token, value)
+            case 'id':
+                if (token == ')') {
+                    remove_empty_pattern(C)
+                    C.expect = 'as'
+                    return C
+                }
+                C.expect = ',|'
+                return $transition(new $PatternCtx(C), token, value)
+        }
+        console.log('error', this, token, value)
+        $_SyntaxError(C, 'token ' + token + ' after ' + C)
+    }
+    $PatternGroupCtx.prototype.to_js = function() {
+        if (this.is_tuple) {
+            var js = '{sequence: [' + $to_js(this.tree) + ']'
+        } else {
+            var js = '{group: [' + $to_js(this.tree) + ']'
+        }
+        if (this.alias) {
+            js += `, alias: "${this.alias}"`
+        }
+        return js + '}'
     }
     var $PatternLiteralCtx = function(C, token, value, sign) {
         this.type = "literal_pattern"
         this.parent = C.parent
         C.parent.tree.pop()
         C.parent.tree.push(this)
-        this.tree = [{
-            token,
-            value,
-            sign
-        }]
-        this.expect = 'op'
+        if (token.sign) {
+            this.tree = [{
+                sign: token.sign
+            }]
+            this.expect = 'number'
+        } else {
+            if (token == 'str') {
+                if (Array.isArray(value)) {
+                    $_SyntaxError(this, ["patterns cannot include f-strings"])
+                }
+                this.tree = []
+                new $StringCtx(this, value)
+            } else {
+                this.tree = [{
+                    token,
+                    value,
+                    sign
+                }]
+            }
+            this.expect = 'op'
+        }
+    }
+    $PatternLiteralCtx.prototype.bindings = function() {
+        if (this.alias) {
+            return [this.alias]
+        }
+        return []
     }
     $PatternLiteralCtx.prototype.transition = function(token, value) {
         var C = this
         switch (C.expect) {
             case 'op':
                 if (token == "op") {
                     switch (value) {
                         case '+':
                         case '-':
                             if (['int', 'float'].indexOf(this.tree[0].token) > -1) {
-                                C.expect = 'number'
+                                C.expect = 'imaginary'
                                 this.tree.push(value)
                                 C.num_sign = value
                                 return C
                             }
-                            $_SyntaxError(C, value + 'sign only after ' +
-                                'int or float')
+                            $_SyntaxError(C, ['patterns cannot include operators'])
                         default:
                             return $transition(C.parent, token, value)
                     }
                 }
                 break
             case 'number':
                 switch (token) {
+                    case 'int':
+                    case 'float':
+                    case 'imaginary':
+                        var last = $B.last(C.tree)
+                        if (this.tree.token === undefined) {
+                            last.token = token
+                            last.value = value
+                            C.expect = 'op'
+                            return C
+                        }
+                    default:
+                        $_SyntaxError(C)
+                }
+            case 'imaginary':
+                switch (token) {
                     case 'imaginary':
                         C.tree.push({
                             token,
                             value,
                             sign: C.num_sign
                         })
                         return C.parent
                     default:
                         $_SyntaxError(C, 'expected imaginary')
                 }
+            case 'as':
+            case 'alias':
+                return as_pattern(C, token, value)
+        }
+        if (token == 'as' && C.tree.length == 1) {
+            C.expect = 'as'
+            return C.transition(token, value)
         }
         return $transition(C.parent, token, value)
     }
     $PatternLiteralCtx.prototype.to_js = function() {
         function int_to_num(item) {
             var v = parseInt(item.value[1], item.value[0])
             return item.sign == '-' ? -v : v
         }
         var res = '',
-            first = this.tree[0]
-        switch (first.token) {
-            case 'id':
-                res = '_b_.' + first.value
-                break
-            case 'str':
-                res = first.value
-                break
-            case 'int':
-                res = int_to_num(first)
-                break
-            case 'float':
-                res = (first.sign == '-' ? '-' : '') + first.value
-                break
-            case 'imaginary':
-                res += '$B.make_complex(0, ' + first.value + ')'
-                break
+            first = this.tree[0],
+            num_value
+        if (first instanceof $StringCtx) {
+            res = first.to_js()
+        } else {
+            switch (first.token) {
+                case 'id':
+                    res = '_b_.' + first.value
+                    num_value = first.value == 'True' ? 1 : 0
+                    break
+                case 'str':
+                    res = first.value
+                    break
+                case 'int':
+                    res = int_to_num(first)
+                    break
+                case 'float':
+                    res = (first.sign == '-' ? '-' : '') + first.value
+                    break
+                case 'imaginary':
+                    res += '$B.make_complex(0, ' +
+                        (first.sign == '-' ? '-' : '') + first.value + ')'
+                    if (first.value == 0) {
+                        num_value = 0
+                    }
+                    break
+            }
         }
         if (this.tree.length > 1) {
             res = '$B.make_complex(' + res + ',' +
                 (this.tree[1] == '-' ? '-' : '') +
                 this.tree[2].value + ')'
         }
-        return res
+        this.js_value = res
+        this.num_value = num_value === undefined ? res : num_value
+        var js = '{literal: ' + res
+        if (this.alias) {
+            js += `, alias: '${this.alias}'`
+        }
+        return js + '}'
     }
     var $PatternMappingCtx = function(C) {
         this.type = "mapping_pattern"
         this.parent = C
         C.tree.pop()
         this.tree = []
         C.tree.push(this)
+        this.expect = 'key_value_pattern'
+        this.duplicate_keys = []
+        this.bound_names = []
+    }
+    $PatternMappingCtx.prototype.bindings = function() {
+        var bindings = []
+        for (var item of this.tree) {
+            bindings = bindings.concat(item.bindings())
+        }
+        if (this.rest) {
+            bindings = bindings.concat(this.rest.bindings())
+        }
+        if (this.alias) {
+            bindings.push(this.alias)
+        }
+        return bindings
     }
     $PatternMappingCtx.prototype.transition = function(token, value) {
         var C = this
-        switch (token) {
+
+        function check_duplicate_names() {
+            var last = $B.last(C.tree),
+                bindings
+            if (last instanceof $PatternKeyValueCtx) {
+                if (C.double_star) {
+                    C.$pos = C.double_star.$pos
+                    $_SyntaxError(C, ["can't use starred name here (consider moving to end)"])
+                }
+                if (last.tree[0].type == 'value_pattern') {
+                    bindings = last.tree[2].bindings()
+                } else {
+                    bindings = last.tree[1].bindings()
+                }
+                for (var binding of bindings) {
+                    if (C.bound_names.indexOf(binding) > -1) {
+                        $_SyntaxError(C, [`multiple assignments to name '${binding}'` +
+                            ' in pattern'
+                        ])
+                    }
+                }
+                C.bound_names = C.bound_names.concat(bindings)
+            }
+        }
+        switch (C.expect) {
+            case 'key_value_pattern':
+                if (token == '}' || token == ',') {
+                    check_duplicate_names()
+                    if (C.double_star) {
+                        var ix = C.tree.indexOf(C.double_star)
+                        if (ix != C.tree.length - 1) {
+                            C.$pos = C.double_star.$pos
+                            $_SyntaxError(C, ["can't use starred name here (consider moving to end)"])
+                        }
+                        C.rest = C.tree.pop()
+                    }
+                    return token == ',' ? C : C.parent
+                }
+                if (token == 'op' && value == '**') {
+                    C.expect = 'capture_pattern'
+                    return C
+                }
+                var p = new $PatternCtx(C)
+                var lit_or_val = p.transition(token, value)
+                if (lit_or_val instanceof $PatternLiteralCtx) {
+                    C.tree.pop()
+                    for (var kv of C.tree) {
+                        if (kv instanceof $PatternKeyValueCtx) {
+                            var key = kv.tree[0]
+                            if (key instanceof $PatternLiteralCtx) {
+                                var old_lit = key.tree[0],
+                                    new_lit = lit_or_val.tree[0]
+                                key.to_js()
+                                lit_or_val.to_js()
+                                key_value = key.num_value
+                                lit_or_val_value = lit_or_val.num_value
+                                if (key_value == lit_or_val_value) {
+                                    $_SyntaxError(C, ["duplicate literal key " +
+                                        lit_or_val_value
+                                    ])
+                                }
+                            }
+                        }
+                    }
+                    new $PatternKeyValueCtx(C, lit_or_val)
+                    return lit_or_val
+                } else if (lit_or_val instanceof $PatternCaptureCtx) {
+                    C.has_value_pattern_keys = true
+                    C.tree.pop()
+                    new $PatternKeyValueCtx(C, lit_or_val)
+                    C.expect = '.'
+                    return this
+                } else {
+                    console.log('lit_or_val', lit_or_val)
+                    $_SyntaxError(C, 'expected key or **')
+                }
+            case 'capture_pattern':
+                var p = new $PatternCtx(C)
+                var capture = $transition(p, token, value)
+                if (capture instanceof $PatternCaptureCtx) {
+                    if (C.double_star) {
+                        C.$pos = capture.$pos
+                        $_SyntaxError(C, ["only one double star pattern is accepted"])
+                    }
+                    if (value == '_') {
+                        $_SyntaxError(C, '**_ is not valid')
+                    }
+                    if (C.bound_names.indexOf(value) > -1) {
+                        $_SyntaxError(C, ['duplicate binding: ' + value])
+                    }
+                    C.bound_names.push(value)
+                    capture.double_star = true
+                    C.double_star = capture
+                    C.expect = ','
+                    return C
+                } else {
+                    $_SyntaxError(this, 'expected identifier')
+                }
             case ',':
-                return new $PatternMappingItemCtx(C)
-            case '}':
-                return C.parent
-            default:
-                $_SyntaxError(C)
+                if (token == ',') {
+                    C.expect = 'key_value_pattern'
+                    return C
+                } else if (token == '}') {
+                    C.expect = 'key_value_pattern'
+                    return C.transition(token, value)
+                }
+                $_SyntaxError(C, 'token ' + token + 'after C ' + C)
+            case '.':
+                if (C.tree.length > 0) {
+                    var last = $B.last(C.tree)
+                    if (last instanceof $PatternKeyValueCtx) {
+                        new $IdCtx(last, last.tree[0].tree[0])
+                        C.expect = 'key_value_pattern'
+                        return $transition(last.tree[0], token, value)
+                    }
+                }
+                $_SyntaxError(C, 'token ' + token + 'after ' + C)
         }
+        return $transition(C.parent, token, value)
     }
     $PatternMappingCtx.prototype.to_js = function() {
-        return '{mapping: ' + $to_js(this.tree) + '}'
+        var js = '{mapping: [' + $to_js(this.tree) + ']'
+        if (this.rest) {
+            js += ", rest: '" + this.rest.tree[0] + "'"
+        }
+        return js + '}'
     }
-    var $PatternMappingItemCtx = function(C) {
-        this.type = "mapping_pattern_item"
+    var $PatternKeyValueCtx = function(C, literal_or_value) {
+        this.type = "pattern_key_value"
         this.parent = C
-        this.tree = []
-        this.expect = 'literal'
+        this.tree = [literal_or_value]
+        literal_or_value.parent = this
+        this.expect = ':'
         C.tree.push(this)
     }
-    $PatternMappingItemCtx.prototype.transition = function(token, value) {
+    $PatternKeyValueCtx.prototype.bindings = $PatternMappingCtx.prototype.bindings
+    $PatternKeyValueCtx.prototype.transition = function(token, value) {
         var C = this
         switch (C.expect) {
-            case 'literal':
-                switch (token) {
-                    case 'str':
-                        this.tree.push(value)
-                        this.expect = ':'
-                        return this
-                    default:
-                        $_SyntaxError(this, 'expected a literal')
-                }
             case ':':
                 switch (token) {
                     case ':':
-                        this.expect = 'pattern'
+                        this.expect = ','
                         return new $PatternCtx(this)
                     default:
-                        $_SyntaxError('expected :')
+                        console.log('keyvalue', C, 'expected :, got', token, value)
+                        $_SyntaxError(C, 'expected :')
+                }
+            case ',':
+                switch (token) {
+                    case '}':
+                        return $transition(C.parent, token, value)
+                    case ',':
+                        C.parent.expect = 'key_value_pattern'
+                        return $transition(C.parent, token, value)
+                    case 'op':
+                        if (value == '|') {
+                            return new $PatternCtx(new $PatternOrCtx(C))
+                        }
                 }
-            case 'pattern':
-                console.log(token, value)
+                $_SyntaxError(C, 'expected , or }')
         }
         return $transition(C.parent, token, value)
     }
-    $PatternMappingItemCtx.prototype.to_js = function() {
-        console.log('pattern mapping to js', this)
-        return '[' + this.tree[0] + ',' + this.tree[1].to_js() + ']'
+    $PatternKeyValueCtx.prototype.to_js = function() {
+        var key, value
+        if (this.tree[0].type == 'value_pattern') {
+            key = this.tree[1].to_js()
+            for (var i = 2, len = this.tree[0].tree.length; i < len; i += 2) {
+                key = '$B.$getattr(' + key + ', "' + this.tree[0].tree[i] + '")'
+            }
+            key = '{value: ' + key + '}'
+            value = this.tree[2].to_js()
+        } else {
+            key = this.tree[0].to_js()
+            value = this.tree[1].to_js()
+        }
+        return '[' + key + ',' + value + ']'
     }
     var $PatternOrCtx = function(C) {
         this.type = "or_pattern"
         this.parent = C
         var first_pattern = C.tree.pop()
+        if (first_pattern instanceof $PatternGroupCtx &&
+            first_pattern.expect != 'as') {
+            first_pattern = first_pattern.tree[0]
+        }
         this.tree = [first_pattern]
+        first_pattern.parent = this
         this.expect = '|'
         C.tree.push(this)
+        this.check_reachable()
+    }
+    $PatternOrCtx.prototype.bindings = function() {
+        var names
+        for (var subpattern of this.tree) {
+            if (subpattern.bindings === undefined) {
+                console.log('no binding', subpattern)
+            }
+            var subbindings = subpattern.bindings()
+            if (names === undefined) {
+                names = subbindings
+            } else {
+                for (var item of names) {
+                    if (subbindings.indexOf(item) == -1) {
+                        $_SyntaxError(this, ["alternative patterns bind different names"])
+                    }
+                }
+                for (var item of subbindings) {
+                    if (names.indexOf(item) == -1) {
+                        $_SyntaxError(this, ["alternative patterns bind different names"])
+                    }
+                }
+            }
+        }
+        if (this.alias) {
+            return names.concat(this.alias)
+        }
+        return names
+    }
+    $PatternOrCtx.prototype.check_reachable = function() {
+        var item = $B.last(this.tree)
+        var capture
+        if (item.type == 'capture_pattern') {
+            capture = item.tree[0]
+        } else if (item.type == 'group_pattern' && item.tree.length == 1 &&
+            item.tree[0].type == 'capture_pattern') {
+            capture = item.tree[0].tree[0]
+        } else if (item instanceof $PatternOrCtx) {
+            item.check_reachable()
+        }
+        if (capture) {
+            var msg = capture == '_' ? 'wildcard' :
+                `name capture '${capture}'`
+            $_SyntaxError(this, [`${msg} makes remaining patterns unreachable`])
+        }
     }
     $PatternOrCtx.prototype.transition = function(token, value) {
-        var C = this
-        for (var i = 0, len = C.tree.length - 1; i < len; i++) {
-            if (C.tree[i].type == 'capture_pattern') {
-                $_SyntaxError(C.tree[i], [`name capture '${C.tree[i].tree[0]}' ` +
-                    'makes remaining patterns unreachable'
-                ])
+        function set_alias() {
+            var last = $B.last(C.tree)
+            if (last.alias) {
+                C.alias = last.alias
+                delete last.alias
             }
         }
+        var C = this
+        if (['as', 'alias'].indexOf(C.expect) > -1) {
+            return as_pattern(C, token, value)
+        }
         if (token == 'op' && value == "|") {
+            for (var item of C.tree) {
+                if (item.alias) {
+                    $_SyntaxError(C, 'no as pattern inside or pattern')
+                }
+            }
+            C.check_reachable()
             return new $PatternCtx(C)
+        } else if (token == ')' && C.parenthese) {
+            set_alias()
+            C.bindings()
+            delete C.parenthese
+            C.expect = 'as'
+            return C
         }
+        set_alias()
+        C.bindings()
         return $transition(C.parent, token, value)
     }
     $PatternOrCtx.prototype.to_js = function() {
-        return '{or : [' + $to_js(this.tree) + ']}'
+        var res = '{or : [' + $to_js(this.tree) + ']'
+        if (this.alias) {
+            res += `, alias: '${this.alias}'`
+        }
+        return res + '}'
     }
     var $PatternSequenceCtx = function(C, token) {
         this.type = "sequence_pattern"
         this.parent = C
         this.tree = []
+        this.bound_names = []
         var first_pattern = C.tree.pop()
         if (token === undefined) {
+            this.bound_names = first_pattern.bindings()
             this.tree = [first_pattern]
+            if (first_pattern.starred) {
+                this.has_star = true
+            }
             first_pattern.parent = this
         } else {
             this.token = token
         }
         this.expect = ','
         C.tree.push(this)
     }
+    $PatternSequenceCtx.prototype.bindings = $PatternMappingCtx.prototype.bindings
     $PatternSequenceCtx.prototype.transition = function(token, value) {
+        function check_duplicate_names() {
+            var last = $B.last(C.tree)
+            if (!(last instanceof $PatternCtx)) {
+                var last_bindings = last.bindings()
+                for (var b of last_bindings) {
+                    if (C.bound_names.indexOf(b) > -1) {
+                        $_SyntaxError(C, ["multiple assignments to name '" +
+                            b + "' in pattern"
+                        ])
+                    }
+                }
+                if (last.starred) {
+                    if (C.has_star) {
+                        $_SyntaxError(C, ['multiple starred names in sequence pattern'])
+                    }
+                    C.has_star = true
+                }
+                C.bound_names = C.bound_names.concat(last_bindings)
+            }
+        }
         var C = this
         if (C.expect == ',') {
-            if ((this.token == '[' && token == ']') ||
-                (this.token == '(' && token == ")")) {
-                return C.parent
+            if ((C.token == '[' && token == ']') ||
+                (C.token == '(' && token == ")")) {
+                var nb_starred = 0
+                for (var item of C.tree) {
+                    if (item instanceof $PatternCaptureCtx && item.starred) {
+                        nb_starred++
+                        if (nb_starred > 1) {
+                            $_SyntaxError(C, ['multiple starred names in sequence pattern'])
+                        }
+                    }
+                }
+                C.expect = 'as'
+                check_duplicate_names()
+                remove_empty_pattern(C)
+                return C
             } else if (token == ',') {
+                check_duplicate_names()
                 C.expect = 'id'
                 return C
+            } else if (token == 'op' && value == '|') {
+                remove_empty_pattern(C)
+                return new $PatternCtx(new $PatternOrCtx(C))
             } else if (this.token === undefined) {
+                check_duplicate_names()
                 return $transition(C.parent, token, value)
             }
             $_SyntaxError(C)
+        } else if (C.expect == 'as') {
+            if (token == 'as') {
+                this.expect = 'alias'
+                return C
+            }
+            return $transition(C.parent, token, value)
+        } else if (C.expect == 'alias') {
+            if (token = 'id') {
+                C.alias = value
+                return C.parent
+            }
+            $_SyntaxError(C, 'expected alias')
         } else if (C.expect == 'id') {
             C.expect = ','
             return $transition(new $PatternCtx(C), token, value)
         }
     }
     $PatternSequenceCtx.prototype.to_js = function() {
-        return '{sequence: [' + $to_js(this.tree) + ']}'
+        var js = '{sequence: [' + $to_js(this.tree) + ']'
+        if (this.alias) {
+            js += `, alias: '${this.alias}'`
+        }
+        return js + '}'
     }
     var $RaiseCtx = $B.parser.$RaiseCtx = function(C) {
         this.type = 'raise'
         this.parent = C
         this.tree = []
         C.tree[C.tree.length] = this
         this.scope_type = $get_scope(this).ntype
@@ -7851,34 +9065,42 @@
                 } else if (elt.type == 'single_kw' && elt.token == 'finally') {
                     elt.has_return = true
                 }
             }
             node = node.parent
         }
     }
+    $ReturnCtx.prototype.ast = function() {
+        var res = new ast.Return()
+        if (this.tree.length > 0) {
+            res.expr = ast_or_obj(this.tree[0])
+        }
+        return res
+    }
     $ReturnCtx.prototype.toString = function() {
         return 'return ' + this.tree
     }
     $ReturnCtx.prototype.transition = function(token, value) {
         var C = this
+        if (token == 'eol' && this.tree.length == 1 &&
+            this.tree[0].type == 'abstract_expr') {
+            this.tree.pop()
+        }
         return $transition(C.parent, token)
     }
     $ReturnCtx.prototype.to_js = function() {
         this.js_processed = true
-        if (this.tree.length == 1 && this.tree[0].type == 'abstract_expr') {
-            this.tree.pop()
-            new $IdCtx(new $ExprCtx(this, 'rvalue', false), 'None')
-        }
+        var expr = this.tree.length == 0 ? '_b_.None' : $to_js(this.tree)
         var scope = this.scope
         if (scope.ntype == 'generator') {
-            return 'var $res = ' + $to_js(this.tree) + '; $B.leave_frame({$locals});' +
+            return 'var $res = ' + expr + '; $B.leave_frame({$locals});' +
                 'return $B.generator_return($res)'
         }
         var indent = '    '.repeat(this.node.indent - 1)
-        var js = 'var $res = ' + $to_js(this.tree) + ';\n' + indent +
+        var js = 'var $res = ' + expr + ';\n' + indent +
             'if($locals.$f_trace !== _b_.None){$B.trace_return($res)}\n' + indent +
             '$B.leave_frame'
         if (scope.id.substr(0, 6) == '$exec_') {
             js += '_exec'
         }
         js += '({$locals});\n'
         if (this.is_await) {
@@ -7890,22 +9112,18 @@
     var $SingleKwCtx = $B.parser.$SingleKwCtx = function(C, token) {
         this.type = 'single_kw'
         this.token = token
         this.parent = C
         this.tree = []
         C.tree[C.tree.length] = this
         if (token == "else") {
-            var node = C.node
-            var pnode = node.parent
-            for (var rank = 0; rank < pnode.children.length; rank++) {
-                if (pnode.children[rank] === node) {
-                    break
-                }
-            }
-            var pctx = pnode.children[rank - 1].C
+            var node = C.node,
+                rank = node.parent.children.indexOf(node),
+                pctx = node.parent.children[rank - 1].C
+            pctx.tree[0].orelse = this
             if (pctx.tree.length > 0) {
                 var elt = pctx.tree[0]
                 if (elt.type == 'for' ||
                     elt.type == 'asyncfor' ||
                     (elt.type == 'condition' && elt.token == 'while')) {
                     elt.has_break = true
                     elt.else_node = $get_node(this)
@@ -7953,14 +9171,25 @@
     }
     var $SliceCtx = $B.parser.$SliceCtx = function(C) {
         this.type = 'slice'
         this.parent = C
         this.tree = C.tree.length > 0 ? [C.tree.pop()] : []
         C.tree.push(this)
     }
+    $SliceCtx.prototype.ast = function() {
+        var slice = new ast.Slice()
+        var attrs = ['lower', 'upper', 'step']
+        for (var i = 0; i < this.tree.length; i++) {
+            var item = this.tree[i]
+            if (item.type !== 'abstract_expr') {
+                slice[attrs[i]] = ast_or_obj(item)
+            }
+        }
+        return slice
+    }
     $SliceCtx.prototype.transition = function(token, value) {
         var C = this
         if (token == ":") {
             return new $AbstractExprCtx(C, false)
         }
         return $transition(C.parent, token, value)
     }
@@ -7993,14 +9222,15 @@
                     return C.parent
                 }
                 return $transition(new $AbstractExprCtx(C, false), token, value)
             case 'imaginary':
             case 'int':
             case 'float':
             case 'str':
+            case 'JoinedStr':
             case 'bytes':
             case '[':
             case '(':
             case '{':
             case 'not':
             case 'lambda':
                 return $transition(new $AbstractExprCtx(C, false), token, value)
@@ -8020,193 +9250,98 @@
     $StarArgCtx.prototype.to_js = function() {
         this.js_processed = true
         return '{$nat:"ptuple",arg:' + $to_js(this.tree) + '}'
     }
     var $StringCtx = $B.parser.$StringCtx = function(C, value) {
         this.type = 'str'
         this.parent = C
-        this.tree = [value]
-        C.tree[C.tree.length] = this
+
+        function prepare(value) {
+            value = value.replace(/\n/g, '\\n\\\n')
+            value = value.replace(/\r/g, '\\r\\\r')
+            return value
+        }
+        this.is_bytes = value.charAt(0) == 'b'
+        if (!this.is_bytes) {
+            this.value = prepare(value)
+        } else {
+            this.value = prepare(value.substr(1))
+        }
+        C.tree.push(this)
+        this.tree = [this.value]
         this.raw = false
         this.$pos = $pos
     }
+    $StringCtx.prototype.ast = function() {
+        return new ast.Constant(eval(this.value))
+    }
     $StringCtx.prototype.toString = function() {
-        return 'string ' + (this.tree || '')
+        return 'string ' + (this.value || '')
     }
     $StringCtx.prototype.transition = function(token, value) {
         var C = this
         switch (token) {
             case '[':
                 return new $AbstractExprCtx(new $SubCtx(C.parent), false)
             case '(':
                 C.parent.tree[0] = C
                 return new $CallCtx(C.parent)
             case 'str':
-                C.tree.push(value)
+                if ((this.is_bytes && !value.startsWith('b')) ||
+                    (!this.is_bytes && value.startsWith('b'))) {
+                    C.$pos = $pos
+                    $_SyntaxError(C, ["cannot mix bytes and nonbytes literals"])
+                }
+                C.value += ' + ' + (this.is_bytes ? value.substr(1) : value)
                 return C
+            case 'JoinedStr':
+                C.parent.tree.pop()
+                var joined_str = new JoinedStrCtx(C.parent, value)
+                if (typeof joined_str.tree[0] == "string") {
+                    joined_str.tree[0] = eval(this.value) + joined_str.tree[0]
+                } else {
+                    joined_str.tree.splice(0, 0, this)
+                }
+                return joined_str
         }
         return $transition(C.parent, token, value)
     }
     $StringCtx.prototype.to_js = function() {
         this.js_processed = true
-        var res = '',
-            type = null,
-            scope = $get_scope(this)
-
-        function fstring(parsed_fstring) {
-            var elts = []
-            for (var i = 0; i < parsed_fstring.length; i++) {
-                if (parsed_fstring[i].type == 'expression') {
-                    var expr = parsed_fstring[i].expression
-                    var pos = 0,
-                        br_stack = [],
-                        parts = [expr]
-                    while (pos < expr.length) {
-                        var car = expr.charAt(pos)
-                        if (car == ":" && br_stack.length == 0) {
-                            parts = [expr.substr(0, pos), expr.substr(pos + 1)]
-                            break
-                        } else if ("{[(".indexOf(car) > -1) {
-                            br_stack.push(car)
-                        } else if (")]}".indexOf(car) > -1) {
-                            br_stack.pop()
-                        }
-                        pos++
-                    }
-                    expr = parts[0]
-                    var save_pos = $pos
-                    var expr_node = $B.py2js(expr, scope.module, scope.id, scope)
-                    expr_node.to_js()
-                    $pos = save_pos
-                    for (var j = 0; j < expr_node.children.length; j++) {
-                        var node = expr_node.children[j]
-                        if (node.C.tree && node.C.tree.length == 1 &&
-                            node.C.tree[0] == "try") {
-                            for (var k = 0; k < node.children.length; k++) {
-                                if (node.children[k].is_line_num) {
-                                    continue
-                                }
-                                var expr1 = node.children[k].js
-                                if (expr1.length > 0) {
-                                    while ("\n;".indexOf(expr1.charAt(expr1.length - 1)) > -1) {
-                                        expr1 = expr1.substr(0, expr1.length - 1)
-                                    }
-                                } else {
-                                    console.log("f-string: empty expression not allowed")
-                                }
-                                break
-                            }
-                            break
-                        }
-                    }
-                    switch (parsed_fstring[i].conversion) {
-                        case "a":
-                            expr1 = '_b_.ascii(' + expr1 + ')'
-                            break
-                        case "r":
-                            expr1 = '_b_.repr(' + expr1 + ')'
-                            break
-                        case "s":
-                            expr1 = '_b_.str.$factory(' + expr1 + ')'
-                            break
-                    }
-                    var fmt = parts[1]
-                    if (fmt !== undefined) {
-                        var parsed_fmt = $B.parse_fstring(fmt)
-                        if (parsed_fmt.length > 1) {
-                            fmt = fstring(parsed_fmt)
-                        } else {
-                            fmt = "'" + fmt + "'"
-                        }
-                        var res1 = "_b_.str.format('{0:' + " +
-                            fmt + " + '}', " + expr1 + ")"
-                        elts.push(res1)
-                    } else {
-                        if (parsed_fstring[i].conversion === null) {
-                            expr1 = '_b_.str.$factory(' + expr1 + ')'
-                        }
-                        elts.push(expr1)
-                    }
-                } else {
-                    var re = new RegExp("'", "g")
-                    var elt = parsed_fstring[i].replace(re, "\\'")
-                        .replace(/\n/g, "\\n")
-                    elts.push("'" + elt + "'")
-                }
-            }
-            return elts.join(' + ')
-        }
-
-        function prepare(value) {
-            value = value.replace(/\n/g, '\\n\\\n')
-            value = value.replace(/\r/g, '\\r\\\r')
-            return value
-        }
-        for (var i = 0; i < this.tree.length; i++) {
-            if (this.tree[i].type == "call") {
-                var js = '(function(){throw _b_.TypeError.$factory("' + "'str'" +
-                    ' object is not callable")}())'
-                return js
-            } else {
-                var value = this.tree[i],
-                    is_fstring = Array.isArray(value),
-                    is_bytes = false
-                if (!is_fstring) {
-                    is_bytes = value.charAt(0) == 'b'
-                }
-                if (type == null) {
-                    type = is_bytes
-                    if (is_bytes) {
-                        res += '_b_.bytes.$new(_b_.bytes, '
-                    }
-                } else if (type != is_bytes) {
-                    return '$B.$TypeError("can\'t concat bytes to str")'
-                }
-                if (!is_bytes) {
-                    if (is_fstring) {
-                        res += fstring(value)
-                    } else {
-                        res += prepare(value)
-                    }
-                } else {
-                    res += prepare(value.substr(1))
-                }
-                if (i < this.tree.length - 1) {
-                    res += '+'
-                }
-            }
-        }
-        if (is_bytes) {
-            res += ',"ISO-8859-1")'
-        }
-        if (res.length == 0) {
-            res = '""'
+        if (!this.is_bytes) {
+            return "$B.String(" + this.value + ")"
+        } else {
+            return '_b_.bytes.$new(_b_.bytes, ' + this.value + ", 'ISO-8859-1')"
         }
-        return res
     }
     var $SubCtx = $B.parser.$SubCtx = function(C) {
         this.type = 'sub'
         this.func = 'getitem'
         this.value = C.tree[0]
         C.tree.pop()
         C.tree[C.tree.length] = this
         this.parent = C
         this.tree = []
     }
+    $SubCtx.prototype.ast = function() {
+        var slice = ast_or_obj(this.tree[0])
+        return new ast.Subscript(ast_or_obj(this.value), slice)
+    }
     $SubCtx.prototype.toString = function() {
         return '(sub) (value) ' + this.value + ' (tree) ' + this.tree
     }
     $SubCtx.prototype.transition = function(token, value) {
         var C = this
         switch (token) {
             case 'id':
             case 'imaginary':
             case 'int':
             case 'float':
             case 'str':
+            case 'JoinedStr':
             case 'bytes':
             case '[':
             case '(':
             case '{':
             case '.':
             case 'not':
             case 'lambda':
@@ -8283,21 +9418,21 @@
         }
         var val = this.value.to_js()
         res += '$B.$getattr(' + val + ',"__' + this.func + '__")('
         if (this.tree.length == 1) {
             res += this.tree[0].to_js() + ')'
         } else {
             var res1 = []
-            this.tree.forEach(function(elt) {
+            for (var elt of this.tree) {
                 if (elt.type == 'abstract_expr') {
                     res1.push('_b_.None')
                 } else {
                     res1.push(elt.to_js())
                 }
-            })
+            }
             res += '_b_.tuple.$factory([' + res1.join(',') + ']))'
         }
         return shortcut ? res + ')' : res
     }
     var $TargetListCtx = $B.parser.$TargetListCtx = function(C) {
         this.type = 'target_list'
         this.parent = C
@@ -8494,17 +9629,17 @@
             new $SingleKwCtx(ctx, 'else')
             new_node.add($NodeJS('throw ' + error_name))
         }
         if (has_else) {
             var else_node = new $Node()
             else_node.module = scope.module
             new $NodeJSCtx(else_node, 'if(!' + failed_name + ')')
-            else_body.children.forEach(function(elt) {
+            for (var elt of else_body.children) {
                 else_node.add(elt)
-            })
+            }
             if (has_finally) {
                 finally_node.insert(0, else_node)
             } else {
                 node.parent.insert(pos, else_node)
             }
             pos++
         }
@@ -8514,71 +9649,69 @@
         this.js_processed = true
         return 'try'
     }
     var $UnaryCtx = $B.parser.$UnaryCtx = function(C, op) {
         this.type = 'unary'
         this.op = op
         this.parent = C
-        C.tree[C.tree.length] = this
+        this.tree = []
+        C.tree.push(this)
+    }
+    $UnaryCtx.prototype.ast = function() {
+        var op = {
+            '+': ast.UAdd,
+            '-': ast.USub,
+            '~': ast.Invert
+        } [this.op]
+        return new ast.UnaryOp(new op(), ast_or_obj(this.tree[0]))
     }
     $UnaryCtx.prototype.toString = function() {
         return '(unary) ' + this.op
     }
     $UnaryCtx.prototype.transition = function(token, value) {
         var C = this
         switch (token) {
-            case 'int':
-            case 'float':
-            case 'imaginary':
-                if (C.parent.type == "packed") {
-                    $_SyntaxError(C, ["can't use starred expression here"])
-                }
-                var expr = C.parent
-                C.parent.parent.tree.pop()
-                if (C.op == '-') {
-                    value = "-" + value
-                } else if (C.op == '~') {
-                    value = ~value
-                }
-                return $transition(C.parent.parent, token, value)
-            case 'id':
-                var p = C.parent.parent.tree.pop()
-                if (p.type == "packed") {
-                    C.parent.parent.tree.push(p)
-                    p.tree.pop()
-                    var expr = new $ExprCtx(p, 'call', false)
-                } else {
-                    var expr = new $ExprCtx(C.parent.parent, 'call', false)
-                }
-                var expr1 = new $ExprCtx(expr, 'id', false)
-                new $IdCtx(expr1, value)
-                var repl = new $AttrCtx(expr)
-                if (C.op == '+') {
-                    repl.name = '__pos__'
-                } else if (C.op == '-') {
-                    repl.name = '__neg__'
-                } else {
-                    repl.name = '__invert__'
-                }
-                return expr1
             case 'op':
                 if ('+' == value || '-' == value) {
                     if (C.op === value) {
                         C.op = '+'
                     } else {
                         C.op = '-'
                     }
                     return C
                 }
+            case 'int':
+            case 'float':
+            case 'imaginary':
+                if (C.parent.type == "packed") {
+                    $_SyntaxError(C, ["can't use starred expression here"])
+                }
+                return $transition(new $AbstractExprCtx(C, false), token, value)
+            case 'id':
+                return $transition(new $AbstractExprCtx(C, false), token, value)
         }
         return $transition(C.parent, token, value)
     }
     $UnaryCtx.prototype.to_js = function() {
         this.js_processed = true
-        return this.op
+        var operand = this.tree[0].tree[0]
+        switch (operand.type) {
+            case 'float':
+                return eval(this.op + operand.value)
+            case 'int':
+                operand.value[1] = eval(this.op + operand.value[1])
+                return operand.to_js()
+        }
+        var method = {
+            '-': 'neg',
+            '+': 'pos',
+            '~': 'invert'
+        } [this.op]
+        return '$B.$call($B.$getattr(' + operand.to_js() + ', "__' +
+            method + '__"))()'
     }
     var $WithCtx = $B.parser.$WithCtx = function(C) {
         this.type = 'with'
         this.parent = C
         C.tree[C.tree.length] = this
         this.tree = []
         this.expect = 'as'
@@ -8641,19 +9774,19 @@
             C.expect)
     }
     $WithCtx.prototype.set_alias = function(ctx) {
         var ids = []
         if (ctx.type == "id") {
             ids = [ctx]
         } else if (ctx.type == "list_or_tuple") {
-            ctx.tree.forEach(function(expr) {
+            for (var expr of ctx.tree) {
                 if (expr.type == "expr" && expr.tree[0].type == "id") {
                     ids.push(expr.tree[0])
                 }
-            })
+            }
         }
         for (var i = 0, len = ids.length; i < len; i++) {
             var id_ctx = ids[i]
             $bind(id_ctx.value, this.scope, this)
             id_ctx.bound = true
             if (this.scope.ntype !== 'module') {
                 this.scope.C.tree[0].locals.push(id_ctx.value)
@@ -8666,17 +9799,17 @@
                 item = this.tree.pop(),
                 new_node = new $Node(),
                 ctx = new $NodeCtx(new_node),
                 with_ctx = new $WithCtx(ctx)
             item.parent = with_ctx
             with_ctx.tree = [item]
             with_ctx.async = this.async
-            suite.forEach(function(elt) {
+            for (var elt of suite) {
                 new_node.add(elt)
-            })
+            }
             node.children = [new_node]
         }
         if (this.transformed) {
             return
         }
         this.prefix = ""
         if (this.tree.length > 1) {
@@ -8684,17 +9817,17 @@
                 ctx = new $NodeCtx(nw)
             nw.parent = node
             nw.module = node.module
             nw.indent = node.indent + 4
             var wc = new $WithCtx(ctx)
             wc.async = this.async
             wc.tree = this.tree.slice(1)
-            node.children.forEach(function(elt) {
+            for (var elt of node.children) {
                 nw.add(elt)
-            })
+            }
             node.children = [nw]
             this.transformed = true
             return
         }
         if (this.async) {
             return this.transform_async(node, rank)
         }
@@ -8739,17 +9872,17 @@
             var new_node = new $Node(),
                 ctx = new $NodeCtx(new_node)
             try_node.add(new_node)
             this.tree[0].alias.tree[0].parent = ctx
             var assign = new $AssignCtx(this.tree[0].alias.tree[0])
             assign.tree.push(new $RawJSCtx(ctx, this.val_name))
         }
-        block.forEach(function(elt) {
+        for (var elt of block) {
             try_node.add(elt)
-        })
+        }
         var catch_node = new $Node()
         new $NodeJSCtx(catch_node, 'catch(' + this.err_name + ')')
         var js = this.exc_name + ' = false;' + this.err_name +
             ' = $B.exception(' + this.err_name + ', true)\n' +
             ' '.repeat(node.indent + 4) +
             'var $b = ' + this.cmexit_name + '(' +
             this.err_name + '.__class__,' +
@@ -8816,17 +9949,17 @@
                     cmenter_name + '))')
                 new_nodes.push(new_node)
             }
         } else {
             new_nodes.push($NodeJS('await ($B.promise(' + cmenter_name + '))'))
         }
         var try_node = new $NodeJS('try')
-        node.children.forEach(function(child) {
+        for (var child of node.children) {
             try_node.add(child)
-        })
+        }
         new_nodes.push(try_node)
         var catch_node = new $NodeJS('catch(err)')
         new_nodes.push(catch_node)
         catch_node.add($NodeJS(this.exc_name + ' = true'))
         catch_node.add($NodeJS('var ' + err_name +
             ' = $B.imported["_sys"].exc_info()'))
         var if_node = $NodeJS('if(! await ($B.promise(' +
@@ -9056,15 +10189,15 @@
             }
             return offset
         } else {
             return 1
         }
     }
     var $bind = $B.parser.$bind = function(name, scope, C) {
-        if (scope.nonlocals && scope.nonlocals[name]) {
+        if (scope.nonlocals && scope.nonlocals.has(name)) {
             return
         }
         if (scope.globals && scope.globals.has(name)) {
             var module = $get_module(C)
             module.binding[name] = true
             return
         }
@@ -9073,14 +10206,18 @@
             node.bindings = node.bindings || {}
             node.bindings[name] = true
         }
         scope.binding = scope.binding || {}
         if (scope.binding[name] === undefined) {
             scope.binding[name] = true
         }
+        scope.varnames = scope.varnames || {}
+        if (scope.varnames[name] === undefined) {
+            scope.varnames[name] = true
+        }
     }
 
     function $parent_match(ctx, obj) {
         var flag
         while (ctx.parent) {
             flag = true
             for (var attr in obj) {
@@ -9193,15 +10330,20 @@
         console.log('no to_js', tree_element)
         throw Error('no to_js() for ' + tree_element)
     }
     var $to_js = $B.parser.$to_js = function(tree, sep) {
         if (sep === undefined) {
             sep = ','
         }
-        return tree.map($to_js_map).join(sep)
+        try {
+            return tree.map($to_js_map).join(sep)
+        } catch (err) {
+            console.log('error', err, '\ntree', tree)
+            throw err
+        }
     }
     var $mangle = $B.parser.$mangle = function(name, C) {
         if (name.substr(0, 2) == "__" && name.substr(name.length - 2) !== "__") {
             var klass = null,
                 scope = $get_scope(C)
             while (true) {
                 if (scope.ntype == "module") {
@@ -9220,19 +10362,24 @@
                     }
                 }
             }
         } else {
             return name
         }
     }
+    $B.nb_debug_lines = 0
     var $transition = $B.parser.$transition = function(C, token, value) {
+        if ($B.nb_debug_lines > 100) {
+            alert('too many debug lines')
+            $B.nb_debug_lines = 0
+        }
         return C.transition(token, value)
     }
-    $B.forbidden = ["alert", "arguments", "case", "catch", "const", "constructor", "Date", "debugger", "delete", "default", "do", "document", "enum", "export", "eval", "extends", "Error", "history", "function", "instanceof", "keys", "length", "location", "Math", "message", "new", "null", "Number", "RegExp", "String", "super", "switch", "this", "throw", "typeof", "var", "window", "toLocaleString", "toString", "void"]
-    $B.aliased_names = $B.list2obj($B.forbidden)
+    $B.forbidden = []
+    $B.aliased_names = Object.create(null)
     var s_escaped = 'abfnrtvxuU"0123456789' + "'" + '\\',
         is_escaped = {}
     for (var i = 0; i < s_escaped.length; i++) {
         is_escaped[s_escaped.charAt(i)] = true
     }
 
     function SurrogatePair(value) {
@@ -9398,21 +10545,46 @@
                 pos++
             } else if (' \t'.indexOf(src[pos]) == -1) {
                 yield src[pos]
             }
             pos++
         }
     }
+    var opening = {
+        ')': '(',
+        '}': '{',
+        ']': '['
+    }
 
     function line_ends_with_comma(src) {
-        var expect = ':'
+        var expect = ':',
+            braces = []
         for (token of $B.tokenizer(src)) {
             if (expect == ':') {
-                if (token.type == 'OP' && token.string == ':') {
+                if (token.type == 'OP' && token.string == ':' && braces.length == 0) {
                     expect = 'eol'
+                } else if (token.type == 'OP') {
+                    if ('([{'.indexOf(token.string) > -1) {
+                        braces.push(token)
+                    } else if (')]}'.indexOf(token.string) > -1) {
+                        if (braces.length == 0) {
+                            var err = SyntaxError(
+                                `unmatched '${token.string}'`)
+                            err.offset = token.start[1]
+                            throw err
+                        } else if ($B.last(braces).string != opening[token.string]) {
+                            var err = SyntaxError("closing parenthesis " +
+                                `'${token.string}' does not match opening ` +
+                                `parenthesis '${$B.last(braces).string}'`)
+                            err.offset = token.start[1]
+                            throw err
+                        } else {
+                            braces.pop()
+                        }
+                    }
                 } else if (token.type == 'NEWLINE') {
                     return false
                 }
             } else {
                 return token.type == 'NEWLINE'
             }
         }
@@ -9815,16 +10987,16 @@
                     C = C || new $NodeCtx(node)
                     $pos = line2pos[err.line_num]
                     $_SyntaxError(C, err.message, 1)
                 } else if (err instanceof SyntaxError) {
                     if (braces_stack.length > 0) {
                         var last_brace = $B.last(braces_stack),
                             start = last_brace.start
-                        $pos = line2pos[start[0]] + start[1]
-                        $_SyntaxError(C, [`'${last_brace.string} was ` +
+                        C.$pos = line2pos[start[0]] + start[1]
+                        $_SyntaxError(C, [`'${last_brace.string}' was ` +
                             'never closed'
                         ])
                     }
                     $_SyntaxError(C, err.message)
                 }
                 throw err
             }
@@ -9862,15 +11034,17 @@
                         node.parent.children.pop()
                     }
                     return
                 case 'ENCODING':
                 case 'TYPE_COMMENT':
                     continue
                 case 'NL':
-                    node.line_num++
+                    if ((!node.C) || node.C.tree.length == 0) {
+                        node.line_num++
+                    }
                     continue
                 case 'COMMENT':
                     var end = line2pos[token.end[0]] + token.end[1]
                     root.comments.push([$pos, end - $pos])
                     continue
                 case 'ERRORTOKEN':
                     C = C || new $NodeCtx(node)
@@ -9895,17 +11069,14 @@
                         }
                         C = $transition(C, name)
                     } else if (name == 'not') {
                         C = $transition(C, 'not')
                     } else if (typeof $operators[name] == 'string') {
                         C = $transition(C, 'op', name)
                     } else {
-                        if ($B.forbidden.indexOf(name) > -1) {
-                            name = '$$' + name
-                        }
                         C = $transition(C, 'id', name)
                     }
                     continue
                 case 'OP':
                     var op = token[1]
                     if ((op.length == 1 && '()[]{}.,='.indexOf(op) > -1) || [':='].indexOf(op) > -1) {
                         if (braces_open.indexOf(op) > -1) {
@@ -9949,15 +11120,19 @@
                         C = $transition(C, 'augm_assign', op)
                     } else {
                         C = $transition(C, 'op', op)
                     }
                     continue
                 case 'STRING':
                     var prepared = prepare_string(C, token[1], token[2])
-                    C = $transition(C, 'str', prepared.value)
+                    if (prepared.value instanceof Array) {
+                        C = $transition(C, 'JoinedStr', prepared.value)
+                    } else {
+                        C = $transition(C, 'str', prepared.value)
+                    }
                     continue
                 case 'NUMBER':
                     var prepared = prepare_number(token[1])
                     if (prepared === undefined) {
                         console.log('pas de prepared pour', token)
                     }
                     C = $transition(C, prepared.type, prepared.value)
@@ -10019,15 +11194,14 @@
             src = src.src
         }
         root.src = src
         return root
     }
     $B.py2js = function(src, module, locals_id, parent_scope, line_num) {
         $pos = 0
-        line_num = line_num || 1
         if (typeof module == "object") {
             var __package__ = module.__package__
             module = module.__name__
         } else {
             var __package__ = ""
         }
         parent_scope = parent_scope || $B.builtins_scope
@@ -10043,14 +11217,18 @@
                 line_info = src.line_info,
                 ix = src.ix,
                 filename = src.filename
             if (line_info !== undefined) {
                 line_num = parseInt(line_info.split(",")[0])
             }
             src = src.src
+        } else if (line_num !== undefined) {
+            line_info = `${line_num},${module}`
+        } else {
+            line_num = 1
         }
         src = src.replace(/\r\n/gm, "\n")
         if (src.endsWith("\\") && !src.endsWith("\\\\")) {
             src = src.substr(0, src.length - 1)
         }
         if (src.charAt(src.length - 1) != "\n") {
             src += "\n"
@@ -10082,14 +11260,35 @@
         } else {
             js += '    $locals = ' + local_ns + ';\n'
         }
         var offset = 0
         root.insert(0, $NodeJS(js))
         offset++
         root.insert(offset++, $NodeJS(local_ns + '.__package__ = "' + __package__ + '"'))
+        if (is_comp) {
+            var info = '{co_argcount: 1, co_firstlineno:' + root.line_num +
+                ', co_name: "<' + is_comp + '>", co_flags: ' +
+                (is_comp == 'genexpr' ? 115 : 83) +
+                ', co_freevars: $B.fast_tuple([]), co_kwonlyargcount: 0,' +
+                'co_posonlyargount: 0'
+            if (root.varnames) {
+                delete root.varnames[root.id]
+                info += ", co_varnames: $B.fast_tuple(['.0', " +
+                    Object.keys(root.varnames).map(x => `'${x}'`).join(',') + '])'
+            }
+            info += '}'
+            root.insert(offset++, $NodeJS(local_ns + '.$comp_code = ' +
+                info))
+            var arg = "_expr"
+            if (is_comp == "genexpr" || is_comp == "setcomp") {
+                arg = "$locals_" + root.id
+            }
+            root.insert(offset++, $NodeJS('$locals[".0"] = ' + arg))
+        }
+        root.insert(offset++, $NodeJS(local_ns + '.__package__ = "' + __package__ + '"'))
         if (root.binding.__annotations__) {
             root.insert(offset++, $NodeJS('$locals.__annotations__ = $B.empty_dict()'))
         }
         var enter_frame_pos = offset,
             js = 'var $top_frame = ["' + locals_id.replace(/\./g, '_') + '", ' +
             local_ns + ', "' + module.replace(/\./g, '_') + '", ' +
             global_ns + ']\n$locals.$f_trace = $B.enter_frame($top_frame)\n' +
@@ -10097,17 +11296,17 @@
         root.insert(offset++, $NodeJS(js))
         var try_node = new $NodeJS('try'),
             children = root.children.slice(enter_frame_pos + 1, root.children.length)
         root.insert(enter_frame_pos + 1, try_node)
         if (children.length == 0) {
             children = [$NodeJS('')]
         }
-        children.forEach(function(child) {
+        for (var child of children) {
             try_node.add(child)
-        })
+        }
         try_node.add($NodeJS('$B.leave_frame({$locals, value: _b_.None})'))
         root.children.splice(enter_frame_pos + 2, root.children.length)
         var catch_node = $NodeJS('catch(err)')
         catch_node.add($NodeJS('$B.leave_frame({$locals, value: _b_.None})'))
         catch_node.add($NodeJS('throw err'))
         root.add(catch_node)
         $add_line_num(root, null, line_info)
@@ -10146,20 +11345,24 @@
         }
         $B.meta_path = meta_path
         $B.path_hooks = path_hooks
     }
     var brython = $B.parser.brython = function(options) {
         if (options === undefined) {
             options = {
-                'debug': 1
+                debug: 1
             }
-        }
-        if (typeof options == 'number') {
+        } else if (typeof options == 'number') {
+            options = {
+                debug: options
+            }
+        } else if (typeof options !== 'object') {
+            console.warn('ignoring invalid argument passed to brython():', options)
             options = {
-                'debug': options
+                debug: 1
             }
         }
         if (options.debug === undefined) {
             options.debug = 1
         }
         $B.debug = options.debug
         _b_.__debug__ = $B.debug > 0
@@ -10184,16 +11387,17 @@
             $href_elts.pop()
         }
         $B.curdir = $href_elts.join('/')
         if (options.pythonpath !== undefined) {
             $B.path = options.pythonpath
             $B.$options.static_stdlib_import = false
         }
+        options.python_extension = options.python_extension || '.py'
         if (options.python_paths) {
-            options.python_paths.forEach(function(path) {
+            for (var path of options.python_paths) {
                 var lang, prefetch
                 if (typeof path !== "string") {
                     lang = path.lang
                     prefetch = path.prefetch
                     path = path.path
                 }
                 $B.path.push(path)
@@ -10201,15 +11405,15 @@
                     (prefetch === undefined || prefetch === true)) {
                     $B.path_importer_cache[path + '/'] =
                         $B.imported['_importlib'].VFSPathFinder(path)
                 }
                 if (lang) {
                     _importlib.optimize_import_for_path(path, lang)
                 }
-            })
+            }
         }
         if (!($B.isWebWorker || $B.isNode)) {
             var path_links = document.querySelectorAll('head link[rel~=pythonpath]'),
                 _importlib = $B.imported['_importlib']
             for (var i = 0, e; e = path_links[i]; ++i) {
                 var href = e.href;
                 if ((' ' + e.rel + ' ').indexOf(' prepend ') != -1) {
@@ -10255,33 +11459,33 @@
             $B.handle_error(err)
         }
         if ($B.hasOwnProperty("VFS") && $B.has_indexedDB) {
             var imports1 = Object.keys(root.imports).slice(),
                 imports = imports1.filter(function(item) {
                     return $B.VFS.hasOwnProperty(item)
                 })
-            Object.keys(imports).forEach(function(name) {
+            for (var name of Object.keys(imports)) {
                 if ($B.VFS.hasOwnProperty(name)) {
                     var submodule = $B.VFS[name],
                         type = submodule[0]
                     if (type == ".py") {
                         var src = submodule[1],
                             subimports = submodule[2],
                             is_package = submodule.length == 4
                         if (type == ".py") {
                             required_stdlib_imports(subimports)
                         }
-                        subimports.forEach(function(mod) {
+                        for (var mod of subimports) {
                             if (imports.indexOf(mod) == -1) {
                                 imports.push(mod)
                             }
-                        })
+                        }
                     }
                 }
-            })
+            }
             for (var j = 0; j < imports.length; j++) {
                 $B.tasks.push([$B.inImported, imports[j]])
             }
             root = null
         }
         $B.tasks.push(["execute", script])
         if (run_loop) {
@@ -10300,24 +11504,24 @@
             webworkers = []
         var ids = options.ids || options.ipy_id
         if (ids !== undefined) {
             if (!Array.isArray(ids)) {
                 throw _b_.ValueError.$factory("ids is not a list")
             }
             var scripts = []
-            options.ids.forEach(function(id) {
+            for (var id of options.ids) {
                 var elt = document.getElementById(id)
                 if (elt === null) {
                     throw _b_.KeyError.$factory(`no script with id '${id}'`)
                 }
                 if (elt.tagName !== "SCRIPT") {
                     throw _b_.KeyError.$factory(`element ${id} is not a script`)
                 }
                 scripts.push(elt)
-            })
+            }
         } else {
             var scripts = document.getElementsByTagName('script')
         }
         for (var i = 0; i < scripts.length; i++) {
             var script = scripts[i]
             if (script.type == "text/python" || script.type == "text/python3") {
                 if (script.className == "webworker") {
@@ -10334,17 +11538,17 @@
         var first_script = true,
             module_name
         if (options.ipy_id !== undefined) {
             module_name = '__main__'
             var $src = "",
                 js, root
             $B.$py_module_path[module_name] = $B.script_path
-            $elts.forEach(function(elt) {
+            for (var elt of $elts) {
                 $src += (elt.innerHTML || elt.textContent)
-            })
+            }
             try {
                 root = $B.py2js($src, module_name, module_name)
                 js = root.to_js()
                 if ($B.debug > 1) {
                     $log(js)
                 }
                 eval(js)
@@ -10489,23 +11693,14 @@
                     } catch (err) {
                         $B.handle_error(err)
                     }
                     delete $B.imported[module]
                     if ($B.debug > 1) {
                         console.log("precompile", module)
                     }
-                    var parts = module.split(".")
-                    if (parts.length > 1) {
-                        parts.pop()
-                    }
-                    if ($B.stdlib.hasOwnProperty(parts.join("."))) {
-                        var imports = elts[2]
-                        imports = imports.join(",")
-                        $B.tasks.splice(0, 0, [store_precompiled, module, js, source_ts, imports, is_package])
-                    }
                 } else {
                     console.log('bizarre', module, ext)
                 }
             } else {}
         } else {
             if (res.is_package) {
                 $B.precompiled[module] = [res.content]
@@ -10746,23 +11941,25 @@
             if ($B.idb_cx && !$B.idb_cx.$closed) {
                 var db = $B.idb_cx.result,
                     tx = db.transaction("modules", "readwrite"),
                     store = tx.objectStore("modules")
                 while ($B.outdated.length > 0) {
                     var module = $B.outdated.pop(),
                         req = store.delete(module)
-                    req.onsuccess = function(event) {
-                        if ($B.debug > 1) {
-                            console.info("delete outdated", module)
+                    req.onsuccess = (function(mod) {
+                        return function(event) {
+                            if ($B.debug > 1) {
+                                console.info("delete outdated", mod)
+                            }
+                            document.dispatchEvent(new CustomEvent('precompile', {
+                                detail: 'remove outdated ' + mod +
+                                    ' from cache'
+                            }))
                         }
-                        document.dispatchEvent(new CustomEvent('precompile', {
-                            detail: 'remove outdated ' + module +
-                                ' from cache'
-                        }))
-                    }
+                    })(module)
                 }
                 document.dispatchEvent(new CustomEvent('precompile', {
                     detail: "close"
                 }))
                 $B.idb_cx.result.close()
                 $B.idb_cx.$closed = true
             }
@@ -10807,16 +12004,21 @@
                 $B.handle_error(err)
             }
         }
     }
     $B.tasks = []
     $B.has_indexedDB = self.indexedDB !== undefined
     $B.handle_error = function(err) {
+        if (err.$handled) {
+            return
+        }
+        err.$handled = true
         if ($B.debug > 1) {
             console.log("handle error", err.__class__, err.args, 'stderr', $B.stderr)
+            console.log(err)
         }
         if (err.__class__ !== undefined) {
             var name = $B.class_name(err),
                 trace = $B.$getattr(err, 'info')
             if (name == 'SyntaxError' || name == 'IndentationError') {
                 var offset = err.args[1][2]
                 trace += '\n    ' + ' '.repeat(offset) + '^' +
@@ -10882,15 +12084,14 @@
         },
         $is_class: true,
         $native: true
     }
     var opnames = ["add", "sub", "mul", "truediv", "floordiv", "mod", "pow", "lshift", "rshift", "and", "xor", "or"]
     var opsigns = ["+", "-", "*", "/", "//", "%", "**", "<<", ">>", "&", "^", "|"]
     object.__delattr__ = function(self, attr) {
-        attr = $B.from_alias(attr)
         if (self.__dict__ && self.__dict__.$string_dict &&
             self.__dict__.$string_dict[attr] !== undefined) {
             delete self.__dict__.$string_dict[attr]
             return _b_.None
         } else if (self.__dict__ === undefined && self[attr] !== undefined) {
             delete self[attr]
             return _b_.None
@@ -10932,17 +12133,15 @@
                     continue
                 }
                 res.push(attr)
             }
         }
         if (self.__dict__) {
             for (var attr in self.__dict__.$string_dict) {
-                if (attr.substr(0, 2) == "$$") {
-                    res.push(attr.substr(2))
-                } else if (attr.charAt(0) != "$") {
+                if (attr.charAt(0) != "$") {
                     res.push(attr)
                 }
             }
         }
         res = _b_.list.$factory(_b_.set.$factory(res))
         _b_.list.sort(res)
         return res
@@ -10978,21 +12177,20 @@
             return klass
         }
         var res = obj[attr]
         if (Array.isArray(obj) && Array.prototype[attr] !== undefined) {
             res = undefined
         }
         if (res === undefined && obj.__dict__) {
-            var dict = obj.__dict__,
-                attr1 = $B.from_alias(attr)
-            if (dict.$string_dict.hasOwnProperty(attr1)) {
+            var dict = obj.__dict__
+            if (dict.$string_dict.hasOwnProperty(attr)) {
                 if ($test) {
-                    console.log("__dict__ hasOwnProperty", attr1, dict.$string_dict[attr1])
+                    console.log("__dict__ hasOwnProperty", attr, dict.$string_dict[attr])
                 }
-                return dict.$string_dict[attr1][0]
+                return dict.$string_dict[attr][0]
             }
         }
         if (res === undefined) {
             function check(obj, kl, attr) {
                 var v = kl[attr]
                 if (v !== undefined) {
                     return v
@@ -11194,18 +12392,20 @@
         }
         var init_func = $B.$getattr(cls, "__init__")
         if (init_func === object.__init__) {
             if (args.length > 0) {
                 throw _b_.TypeError.$factory("object() takes no parameters")
             }
         }
-        return {
+        var res = Object.create(null)
+        $B.update_obj(res, {
             __class__: cls,
             __dict__: $B.empty_dict()
-        }
+        })
+        return res
     }
     object.__ne__ = function(self, other) {
         if (self === other) {
             return false
         }
         var eq = $B.$getattr(self, "__eq__", null)
         if (eq !== null) {
@@ -11297,17 +12497,14 @@
                 throw _b_.AttributeError.$factory(
                     "'object' object has no attribute '" + attr + "'")
             } else {
                 throw _b_.AttributeError.$factory(
                     "'object' object attribute '" + attr + "' is read-only")
             }
         }
-        if ($B.aliased_names[attr]) {
-            attr = "$$" + attr
-        }
         if (self.__dict__) {
             _b_.dict.$setitem(self.__dict__, attr, val)
         } else {
             self[attr] = val
         }
         return _b_.None
     }
@@ -11353,20 +12550,21 @@
                 __class__: object
             },
             args = [res].concat(Array.prototype.slice.call(arguments))
         object.__init__.apply(null, args)
         return res
     }
     $B.set_func_names(object, "builtins")
-    $B.make_class = function(name, factory) {
+    $B.make_class = function(qualname, factory) {
         var A = {
             __class__: _b_.type,
             __mro__: [object],
             $infos: {
-                __name__: name
+                __qualname__: qualname,
+                __name__: $B.last(qualname.split('.'))
             },
             $is_class: true
         }
         A.$factory = factory
         return A
     }
     return object
@@ -11466,15 +12664,15 @@
                 if (cl_dict.$string_dict[attr] === undefined) {
                     cl_dict.$string_dict[attr] = [$B.empty_dict(), cl_dict.$order++]
                 }
                 for (var key in class_obj[attr].$string_dict) {
                     $B.$setitem(cl_dict.$string_dict[attr][0], key, class_obj[attr].$string_dict[key][0])
                 }
             } else {
-                if (attr.charAt(0) != "$" || attr.substr(0, 2) == "$$") {
+                if (attr.charAt(0) != "$") {
                     set_class_item(attr, class_obj[attr])
                 }
             }
         }
         if (use_mro_entries) {
             set_class_item("__orig_bases__", _b_.tuple.$factory(orig_bases))
         }
@@ -11515,14 +12713,16 @@
                     if (v.__isabstractmethod__ === true ||
                         (v.$attrs && v.$attrs.__isabstractmethod__)) {
                         is_instanciable = false
                         abstract_methods[attr] = true
                     } else {
                         non_abstract_methods[attr] = true
                     }
+                } else {
+                    non_abstract_methods[attr] = true
                 }
             }
         }
         var _slots = class_obj.__slots__
         if (_slots !== undefined) {
             if (typeof _slots == "string") {
                 _slots = [_slots]
@@ -11542,62 +12742,66 @@
                         cl_dict.$has_setattr = true
                         break
                     }
                 }
             }
         }
         var meta_new = _b_.type.__getattribute__(metaclass, "__new__")
-        var kls = meta_new(metaclass, class_name, bases, cl_dict)
+        var kls = meta_new(metaclass, class_name, bases, cl_dict, {
+            $nat: 'kw',
+            kw: extra_kwargs
+        })
         kls.__module__ = module
         kls.$infos = {
             __module__: module,
-            __name__: $B.from_alias(class_name),
+            __name__: class_name,
             __qualname__: class_obj.$qualname
         }
         kls.$subclasses = []
+        if (kls.__bases__ === undefined || kls.__bases__.length == 0) {
+            kls.__bases__ = $B.fast_tuple([_b_.object])
+        }
         for (var attr in class_obj) {
-            if (attr.charAt(0) != "$" || attr.substr(0, 2) == "$$") {
+            if (attr.charAt(0) != "$") {
                 if (typeof class_obj[attr] == "function") {
                     class_obj[attr].$infos.$class = kls
                 }
             }
         }
         if (kls.__class__ === metaclass) {
             var meta_init = _b_.type.__getattribute__(metaclass, "__init__")
             meta_init(kls, class_name, bases, cl_dict)
         }
         for (var i = 0; i < bases.length; i++) {
             bases[i].$subclasses = bases[i].$subclasses || []
             bases[i].$subclasses.push(kls)
         }
-        var sup = _b_.$$super.$factory(kls, kls)
-        var init_subclass = _b_.$$super.__getattribute__(sup, "__init_subclass__")
-        init_subclass({
-            $nat: "kw",
-            kw: extra_kwargs
-        })
         if (!is_instanciable) {
             function nofactory() {
                 throw _b_.TypeError.$factory("Can't instantiate abstract class " +
                     "interface with abstract methods " +
                     Object.keys(abstract_methods).join(", "))
             }
             kls.$factory = nofactory
         }
-        kls.__qualname__ = class_name.replace("$$", "")
+        kls.__qualname__ = class_name
         return kls
     }
     var type = $B.make_class("type", function(obj, bases, cl_dict) {
-        if (arguments.length == 1) {
+        var len = arguments.length
+        if (len == 1) {
             if (obj === undefined) {
                 return $B.UndefinedClass
             }
             return obj.__class__ || $B.get_class(obj)
+        } else if (len == 3) {
+            return type.__new__(type, obj, bases, cl_dict)
+        } else {
+            throw _b_.TypeError.$factory('type() takes 1 or 3 arguments')
         }
-        return type.__new__(type, obj, bases, cl_dict)
     })
     type.__call__ = function() {
         var extra_args = [],
             klass = arguments[0]
         for (var i = 1, len = arguments.length; i < len; i++) {
             extra_args.push(arguments[i])
         }
@@ -11637,19 +12841,17 @@
                     }
                 }
                 if (res === undefined) {
                     res = $B.empty_dict()
                 }
                 return res
             case "__bases__":
-                var res = klass.__bases__ || _b_.tuple.$factory()
+                var res = klass.__bases__
                 res.__class__ = _b_.tuple
-                if (res.length == 0) {
-                    res.push(_b_.object)
-                }
+                if (res.length == 0) {}
                 return res
             case "__class__":
                 return klass.__class__
             case "__doc__":
                 return klass.__doc__ || _b_.None
             case "__setattr__":
                 if (klass["__setattr__"] !== undefined) {
@@ -11808,15 +13010,20 @@
                 return res
             }
         }
     }
     type.__hash__ = function(cls) {
         return _b_.hash(cls)
     }
-    type.__init__ = function() {}
+    type.__init__ = function() {
+        if (arguments.length == 0) {
+            throw _b_.TypeError.$factory("descriptor '__init__' of 'type' " +
+                "object needs an argument")
+        }
+    }
     type.__init_subclass__ = function() {
         var $ = $B.args("__init_subclass__", 1, {}, [], arguments, {}, "args", "kwargs")
         if ($.kwargs !== undefined) {
             if ($.kwargs.__class__ !== _b_.dict ||
                 Object.keys($.kwargs.$string_dict).length > 0) {
                 throw _b_.TypeError.$factory(
                     "__init_subclass__() takes no keyword arguments")
@@ -11848,34 +13055,39 @@
         __str__: function(self) {
             return "type"
         },
         __eq__: function(self, other) {
             return self.$infos.__name__ == other
         }
     }
-    type.__new__ = function(meta, name, bases, cl_dict) {
+    type.__new__ = function(meta, name, bases, cl_dict, extra_kwargs) {
+        extra_kwargs = extra_kwargs === undefined ? {
+                $nat: 'kw',
+                kw: {}
+            } :
+            extra_kwargs
         var module = cl_dict.$string_dict.__module__
         if (module) {
             module = module[0]
         }
         var class_dict = {
             __class__: meta,
             __bases__: bases,
             __dict__: cl_dict,
             $infos: {
-                __name__: name.replace("$$", ""),
+                __name__: name,
                 __module__: module
             },
             $is_class: true,
             $has_setattr: cl_dict.$has_setattr
         }
         class_dict.__mro__ = type.mro(class_dict).slice(1)
         var items = $B.dict_to_list(cl_dict)
         for (var i = 0; i < items.length; i++) {
-            var key = $B.to_alias(items[i][0]),
+            var key = items[i][0],
                 v = items[i][1]
             if (key === "__module__") {
                 continue
             }
             if (v === undefined) {
                 continue
             }
@@ -11896,14 +13108,17 @@
                     if (v.$infos.$defaults) {
                         var $defaults = v.$infos.$defaults
                         $B.Function.__setattr__(v, "__defaults__", $defaults)
                     }
                 }
             }
         }
+        var sup = _b_.super.$factory(class_dict, class_dict)
+        var init_subclass = _b_.super.__getattribute__(sup, "__init_subclass__")
+        init_subclass(extra_kwargs)
         return class_dict
     }
     type.__or__ = function() {
         var len = arguments.length
         if (len != 1) {
             throw _b_.TypeError.$factory(`expected 1 argument, got ${len}`)
         }
@@ -11943,14 +13158,18 @@
         var len = arguments.length
         if (len != 1) {
             throw _b_.TypeError.$factory(`expected 1 argument, got ${len}`)
         }
         return _b_.NotImplemented
     }
     type.mro = function(cls) {
+        if (cls === undefined) {
+            throw _b_.TypeError.$factory(
+                'unbound method type.mro() needs an argument')
+        }
         var bases = cls.__bases__,
             seqs = [],
             pos1 = 0
         for (var i = 0; i < bases.length; i++) {
             if (bases[i] === _b_.str) {
                 bases[i] = $B.StringSubclass
             }
@@ -11971,17 +13190,14 @@
                 _tmp.splice(0, 1)
             }
             for (var k = 0; k < _tmp.length; k++) {
                 bmro[pos++] = _tmp[k]
             }
             seqs[pos1++] = bmro
         }
-        if (bases.indexOf(_b_.object) == -1) {
-            bases = bases.concat(_b_.tuple.$factory([_b_.object]))
-        }
         seqs[pos1++] = bases.slice()
         var mro = [cls],
             mpos = 1
         while (1) {
             var non_empty = [],
                 pos = 0
             for (var i = 0; i < seqs.length; i++) {
@@ -12041,14 +13257,15 @@
     $B.set_func_names(type, "builtins")
     _b_.type = type
     var wrapper_descriptor = $B.make_class("wrapper_descriptor")
     $B.set_func_names(wrapper_descriptor, "builtins")
     type.__call__.__class__ = wrapper_descriptor
     var $instance_creator = $B.$instance_creator = function(klass) {
         if (klass.prototype && klass.prototype.constructor == klass) {
+            console.log(801)
             return function() {
                 return new klass(...arguments)
             }
         }
         if (klass.$instanciable !== undefined) {
             return function() {
                 throw _b_.TypeError.$factory(
@@ -12086,18 +13303,20 @@
                 factory = function() {
                     if (arguments.length > 0) {
                         if (arguments.length == 1 && arguments[0].$nat &&
                             Object.keys(arguments[0].kw).length == 0) {} else {
                             throw _b_.TypeError.$factory("object() takes no parameters")
                         }
                     }
-                    return {
+                    var res = Object.create(null)
+                    $B.update_obj(res, {
                         __class__: klass,
                         __dict__: $B.empty_dict()
-                    }
+                    })
+                    return res
                 }
             }
         } else {
             call_func = _b_.type.__getattribute__(metaclass, "__call__")
             var factory = function() {
                 return call_func.bind(null, klass).apply(null, arguments)
             }
@@ -12349,34 +13568,30 @@
             if (extra_kw_args) {
                 slots[extra_kw_args] = extra_kw
             }
             return slots
         }
         if (has_kw_args) {
             for (var key in kw_args) {
-                var value = kw_args[key],
-                    key1 = $B.to_alias(key)
-                if (slots[key1] === undefined) {
+                var value = kw_args[key]
+                if (slots[key] === undefined) {
                     if (extra_kw_args) {
-                        if (key.substr(0, 2) == "$$") {
-                            key = key.substr(2)
-                        }
                         extra_kw.$string_dict[key] = [value, extra_kw.$order++]
                     } else {
                         throw _b_.TypeError.$factory($fname +
                             "() got an unexpected keyword argument '" + key + "'")
                     }
-                } else if (slots[key1] !== null) {
+                } else if (slots[key] !== null) {
                     throw _b_.TypeError.$factory($fname +
                         "() got multiple values for argument '" + key + "'")
-                } else if (only_positional && only_positional.indexOf(key1) > -1) {
+                } else if (only_positional && only_positional.indexOf(key) > -1) {
                     throw _b_.TypeError.$factory($fname + "() got an " +
                         "unexpected keyword argument '" + key + "'")
                 } else {
-                    slots[key1] = value
+                    slots[key] = value
                 }
             }
         }
         var missing = []
         for (var attr in slots) {
             if (slots[attr] === null) {
                 if ($dobj[attr] !== undefined) {
@@ -12492,21 +13707,21 @@
             indent++
         }
         py += "    ".repeat(indent) + res + ".update({" + items[0] + "})"
         var line_info = line_num + ',' + module_name
         var dictcomp_name = "dc" + ix,
             root = $B.py2js({
                 src: py,
-                is_comp: true,
-                line_info: line_info
+                is_comp: 'dictcomp',
+                line_info
             }, module_name, dictcomp_name, parent_scope, line_num),
             outer_expr = root.outermost_expr.to_js(),
             js = root.to_js()
         js += '\nreturn ' + res + '\n'
-        js = "(function(expr){" + js + "})(" + outer_expr + ")"
+        js = "(function(_expr){" + js + "})(" + outer_expr + ")"
         $B.clear_ns(dictcomp_name)
         delete $B.$py_src[dictcomp_name]
         return js
     }
     $B.$gen_expr = function(module_name, parent_scope, items, line_num, set_comp) {
         var ix = $B.UUID(),
             genexpr_name = (set_comp ? "set_comp" + $B.lambda_magic : "__ge") + ix,
@@ -12518,17 +13733,17 @@
             indent += 4
         }
         py += " ".repeat(indent)
         py += "yield (" + items[0] + ")"
         var line_info = line_num + ',' + module_name
         var root = $B.py2js({
                 src: py,
-                is_comp: true,
-                line_info: line_info,
-                ix: ix
+                is_comp: set_comp ? 'setcomp' : 'genexpr',
+                line_info,
+                ix
             }, genexpr_name, genexpr_name, parent_scope, line_num),
             js = root.to_js(),
             lines = js.split("\n")
         if (root.outermost_expr === undefined) {
             console.log("no outermost", module_name, parent_scope)
         }
         var outer_expr = root.outermost_expr.to_js()
@@ -12539,15 +13754,15 @@
         return js
     }
     $B.copy_namespace = function() {
         var ns = {}
         for (const frame of $B.frames_stack) {
             for (const kv of [frame[1], frame[3]]) {
                 for (var key in kv) {
-                    if (key.startsWith('$$') || !key.startsWith('$')) {
+                    if (!key.startsWith('$')) {
                         ns[key] = kv[key]
                     }
                 }
             }
         }
         return ns
     }
@@ -12565,20 +13780,14 @@
         $B.$py_src[name] = null
         delete $B.$py_src[name]
         var alt_name = name.replace(/\./g, "_")
         if (alt_name != name) {
             $B.clear_ns(alt_name)
         }
     }
-    $B.from_alias = function(attr) {
-        if (attr.substr(0, 2) == "$$" && $B.aliased_names[attr.substr(2)]) {
-            return attr.substr(2)
-        }
-        return attr
-    }
     $B.$search = function(name, global_ns) {
         var frame = $B.last($B.frames_stack)
         if (frame[1][name] !== undefined) {
             return frame[1][name]
         } else if (frame[3][name] !== undefined) {
             return frame[3][name]
         } else if (_b_[name] !== undefined) {
@@ -12619,25 +13828,38 @@
         }
         for (var i = 0; i < search_ids.length; i++) {
             var search_id = search_ids[i]
             if ($B.imported[search_id] && $B.imported[search_id][name]) {
                 return $B.imported[search_id][name]
             }
         }
-        throw _b_.NameError.$factory("name '" + $B.from_alias(name) +
+        throw _b_.NameError.$factory("name '" + name +
             "' is not defined")
     }
     $B.$local_search = function(name) {
         var frame = $B.last($B.frames_stack)
         if (frame[1][name] !== undefined) {
             return frame[1][name]
         } else {
             throw _b_.UnboundLocalError.$factory("local variable '" +
-                $B.from_alias(name) + "' referenced before assignment")
+                name + "' referenced before assignment")
+        }
+    }
+    $B.get_method_class = function(ns, qualname) {
+        var refs = qualname.split('.'),
+            klass = ns
+        while (refs.length > 0) {
+            var ref = refs.shift()
+            if (klass[ref] === undefined) {
+                var fake_class = $B.make_class(qualname)
+                return fake_class
+            }
+            klass = klass[ref]
         }
+        return klass
     }
     $B.$check_def = function(name, value) {
         if (value !== undefined) {
             return value
         } else if (_b_[name] !== undefined) {
             return _b_[name]
         } else {
@@ -12653,15 +13875,15 @@
             } else if (frame[1][name] !== undefined) {
                 return frame[1][name]
             }
             if (frame[3][name] !== undefined) {
                 return frame[3][name]
             }
         }
-        throw _b_.NameError.$factory("name '" + $B.from_alias(name) +
+        throw _b_.NameError.$factory("name '" + name +
             "' is not defined")
     }
     $B.$check_def_global = function(name, ns) {
         var res = ns[name]
         if (res === undefined) {
             throw _b_.NameError.$factory("name '" + name +
                 "' is not defined")
@@ -12669,15 +13891,15 @@
         return res
     }
     $B.$check_def_local = function(name, value) {
         if (value !== undefined) {
             return value
         }
         throw _b_.UnboundLocalError.$factory("local variable '" +
-            $B.from_alias(name) + "' referenced before assignment")
+            name + "' referenced before assignment")
     }
     $B.$check_def_free = function(name, value) {
         if (value !== undefined) {
             return value
         }
         var res
         for (var i = $B.frames_stack.length - 1; i >= 0; i--) {
@@ -12686,15 +13908,15 @@
                 return res
             }
             res = $B.frames_stack[i][3][name]
             if (res !== undefined) {
                 return res
             }
         }
-        throw _b_.NameError.$factory("free variable '" + $B.from_alias(name) +
+        throw _b_.NameError.$factory("free variable '" + name +
             "' referenced before assignment in enclosing scope")
     }
     $B.$check_def_free1 = function(name, scope_id) {
         var res
         for (var i = $B.frames_stack.length - 1; i >= 0; i--) {
             var frame = $B.frames_stack[i]
             res = frame[1][name]
@@ -12710,15 +13932,15 @@
             if (frame[2] == scope_id) {
                 res = frame[3][name]
                 if (res !== undefined) {
                     return res
                 }
             }
         }
-        throw _b_.NameError.$factory("free variable '" + $B.from_alias(name) +
+        throw _b_.NameError.$factory("free variable '" + name +
             "' referenced before assignment in enclosing scope")
     }
     $B.$JS2Py = function(src) {
         if (typeof src === "number") {
             if (src % 1 === 0) {
                 return src
             }
@@ -12803,29 +14025,27 @@
         var type = typeof obj == "string" ? "string" : "list"
         throw _b_.IndexError.$factory(type + " index out of range")
     }
     $B.$getitem = function(obj, item) {
         var is_list = Array.isArray(obj) && obj.__class__ === _b_.list,
             is_dict = obj.__class__ === _b_.dict && !obj.$jsobj
         if (typeof item == "number") {
-            if (is_list ||
-                (typeof obj == "string" &&
-                    !$B.has_surrogate(obj))) {
+            if (is_list || typeof obj == "string") {
                 item = item >= 0 ? item : obj.length + item
                 if (obj[item] !== undefined) {
                     return obj[item]
                 } else {
                     index_error(obj)
                 }
             } else if (is_dict) {
                 if (obj.$numeric_dict[item] !== undefined) {
                     return obj.$numeric_dict[item][0]
                 }
             }
-        } else if (typeof item == "string" && is_dict) {
+        } else if (item.valueOf && typeof item.valueOf() == "string" && is_dict) {
             var res = obj.$string_dict[item]
             if (res !== undefined) {
                 return res[0]
             }
             throw _b_.KeyError.$factory(item)
         }
         if (obj.$is_class) {
@@ -13340,22 +14560,14 @@
                 })(r_opname)
             }
         }
     }
     $B.UUID = function() {
         return $B.$py_UUID++
     }
-    $B.InjectBuiltins = function() {
-        var _str = ["var _b_ = $B.builtins"],
-            pos = 1
-        for (var $b in $B.builtins) {
-            _str[pos++] = "var " + $b + '=_b_["' + $b + '"]'
-        }
-        return _str.join(";")
-    }
     $B.$GetInt = function(value) {
         if (typeof value == "number" || value.constructor === Number) {
             return value
         } else if (typeof value === "boolean") {
             return value ? 1 : 0
         } else if (_b_.isinstance(value, _b_.int)) {
             return value
@@ -13454,15 +14666,20 @@
                 return _b_.None
             } else {
                 for (var i = $B.frames_stack.length - 1; i >= 0; i--) {
                     if ($B.frames_stack[i][0] == $B.tracefunc.$frame_id) {
                         return _b_.None
                     }
                 }
-                return $B.tracefunc($B._frame.$factory($B.frames_stack, $B.frames_stack.length - 1), 'call', _b_.None)
+                try {
+                    return $B.tracefunc($B._frame.$factory($B.frames_stack, $B.frames_stack.length - 1), 'call', _b_.None)
+                } catch (err) {
+                    err.$in_trace_func = true
+                    throw err
+                }
             }
         }
         return _b_.None
     }
     $B.trace_exception = function() {
         var top_frame = $B.last($B.frames_stack)
         if (top_frame[0] == $B.tracefunc.$current_frame_id) {
@@ -13505,15 +14722,15 @@
         trace_func(frame_obj, 'return', value)
     }
 
     function exit_ctx_managers_in_generators(frame) {
         for (key in frame[1]) {
             if (frame[1][key] && frame[1][key].__class__ == $B.generator) {
                 var gen_obj = frame[1][key]
-                gen_obj.return()
+                gen_obj.js_gen.return()
             }
         }
     }
     $B.set_cm_in_generator = function(cm_exit) {
         if (cm_exit !== undefined) {
             $B.frames_stack.forEach(function(frame) {
                 frame[1].$cm_in_gen = frame[1].$cm_in_gen || new Set()
@@ -13570,15 +14787,16 @@
             if (arg < min_int || arg > max_int) {
                 return false
             }
         }
         return true
     }
     $B.add = function(x, y) {
-        if (typeof x.valueOf() == "number" && typeof y.valueOf() == "number") {
+        if (x.valueOf && typeof x.valueOf() == "number" &&
+            y.valueOf && typeof y.valueOf() == "number") {
             if (typeof x == "number" && typeof y == "number") {
                 var z = x + y
                 if (z < $B.max_int && z > $B.min_int) {
                     return z
                 } else if (z === Infinity) {
                     return _b_.float.$factory("inf")
                 } else if (z === -Infinity) {
@@ -13726,16 +14944,19 @@
     var method2comp = {
         "__lt__": "<",
         "__le__": "<=",
         "__gt__": ">",
         "__ge__": ">="
     }
     $B.rich_comp = function(op, x, y) {
-        var x1 = x.valueOf(),
-            y1 = y.valueOf()
+        if (x === undefined) {
+            throw _b_.RuntimeError.$factory('error in rich comp')
+        }
+        var x1 = x.valueOf ? x.valueOf() : x,
+            y1 = y.valueOf ? y.valueOf() : y
         if (typeof x1 == "number" && typeof y1 == "number" &&
             x.__class__ === undefined && y.__class__ === undefined) {
             switch (op) {
                 case "__eq__":
                     return x1 == y1
                 case "__ne__":
                     return x1 != y1
@@ -13745,42 +14966,43 @@
                     return x1 < y1
                 case "__ge__":
                     return x1 >= y1
                 case "__gt__":
                     return x1 > y1
             }
         }
-        var res, rev_op
+        var res
         if (x.$is_class || x.$factory) {
             if (op == "__eq__") {
                 return (x === y)
             } else if (op == "__ne__") {
                 return !(x === y)
             } else {
                 throw _b_.TypeError.$factory("'" + method2comp[op] +
                     "' not supported between instances of '" + $B.class_name(x) +
                     "' and '" + $B.class_name(y) + "'")
             }
         }
+        var x_class_op = $B.$call($B.$getattr(x.__class__ || $B.get_class(x), op)),
+            rev_op = reversed_op[op] || op
         if (x.__class__ && y.__class__) {
             if (y.__class__.__mro__.indexOf(x.__class__) > -1) {
-                rev_op = reversed_op[op] || op
                 var rev_func = $B.$getattr(y, rev_op)
                 res = $B.$call($B.$getattr(y, rev_op))(x)
                 if (res !== _b_.NotImplemented) {
                     return res
                 }
             }
         }
-        res = $B.$call($B.$getattr(x, op))(y)
+        res = x_class_op(x, y)
         if (res !== _b_.NotImplemented) {
             return res
         }
-        rev_op = reversed_op[op] || op
-        res = $B.$call($B.$getattr(y, rev_op))(x)
+        var y_class_op = $B.$call($B.$getattr(y.__class__ || $B.get_class(y), rev_op))
+        res = y_class_op(y, x)
         if (res !== _b_.NotImplemented) {
             return res
         }
         if (op == "__eq__") {
             return _b_.False
         } else if (op == "__ne__") {
             return _b_.True
@@ -13839,17 +15061,20 @@
             }
             throw _b_.TypeError.$factory("'" + (opname2opsign[op] || op) +
                 "' not supported between instances of '" + $B.class_name(x) +
                 "' and '" + $B.class_name(y) + "'")
         }
         res = method(y)
         if (res === _b_.NotImplemented) {
-            res = $B.$call($B.$getattr(y, "__r" + op + "__"))(x)
-            if (res !== _b_.NotImplemented) {
-                return res
+            var reflected = $B.$getattr(y, "__r" + op + "__", null)
+            if (reflected !== null) {
+                res = $B.$call(reflected)(x)
+                if (res !== _b_.NotImplemented) {
+                    return res
+                }
             }
             throw _b_.TypeError.$factory("'" + (opname2opsign[op] || op) +
                 "' not supported between instances of '" + $B.class_name(x) +
                 "' and '" + $B.class_name(y) + "'")
         } else {
             return res
         }
@@ -13866,14 +15091,644 @@
                 repr_stack.add(obj)
             }
         },
         leave: function(obj) {
             repr_stack.delete(obj)
         }
     }
+})(__BRYTHON__);;
+(function($B) {
+    var DEFAULT_MIN_MERGE = 32
+    var DEFAULT_MIN_GALLOPING = 7
+    var DEFAULT_TMP_STORAGE_LENGTH = 256
+    var POWERS_OF_TEN = [1e0, 1e1, 1e2, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9]
+
+    function log10(x) {
+        if (x < 1e5) {
+            if (x < 1e2) {
+                return x < 1e1 ? 0 : 1
+            }
+            if (x < 1e4) {
+                return x < 1e3 ? 2 : 3
+            }
+            return 4
+        }
+        if (x < 1e7) {
+            return x < 1e6 ? 5 : 6
+        }
+        if (x < 1e9) {
+            return x < 1e8 ? 7 : 8
+        }
+        return 9
+    }
+
+    function alphabeticalCompare(a, b) {
+        if (a === b) {
+            return 0
+        }
+        if (~~a === a && ~~b === b) {
+            if (a === 0 || b === 0) {
+                return a < b ? -1 : 1
+            }
+            if (a < 0 || b < 0) {
+                if (b >= 0) {
+                    return -1
+                }
+                if (a >= 0) {
+                    return 1
+                }
+                a = -a
+                b = -b
+            }
+            al = log10(a)
+            bl = log10(b)
+            var t = 0
+            if (al < bl) {
+                a *= POWERS_OF_TEN[bl - al - 1]
+                b /= 10
+                t = -1
+            } else if (al > bl) {
+                b *= POWERS_OF_TEN[al - bl - 1]
+                a /= 10;
+                t = 1;
+            }
+            if (a === b) {
+                return t
+            }
+            return a < b ? -1 : 1
+        }
+        var aStr = String(a)
+        var bStr = String(b)
+        if (aStr === bStr) {
+            return 0
+        }
+        return aStr < bStr ? -1 : 1
+    }
+
+    function minRunLength(n) {
+        var r = 0
+        while (n >= DEFAULT_MIN_MERGE) {
+            r |= (n & 1)
+            n >>= 1
+        }
+        return n + r
+    }
+
+    function makeAscendingRun(array, lo, hi, compare) {
+        var runHi = lo + 1
+        if (runHi === hi) {
+            return 1;
+        }
+        if (compare(array[runHi++], array[lo]) < 0) {
+            while (runHi < hi && compare(array[runHi], array[runHi - 1]) < 0) {
+                runHi++
+            }
+            reverseRun(array, lo, runHi)
+        } else {
+            while (runHi < hi && compare(array[runHi], array[runHi - 1]) >= 0) {
+                runHi++
+            }
+        }
+        return runHi - lo
+    }
+
+    function reverseRun(array, lo, hi) {
+        hi--
+        while (lo < hi) {
+            var t = array[lo]
+            array[lo++] = array[hi]
+            array[hi--] = t
+        }
+    }
+
+    function binaryInsertionSort(array, lo, hi, start, compare) {
+        if (start === lo) {
+            start++
+        }
+        for (; start < hi; start++) {
+            var pivot = array[start]
+            var left = lo
+            var right = start
+            while (left < right) {
+                var mid = (left + right) >>> 1
+                if (compare(pivot, array[mid]) < 0) {
+                    right = mid
+                } else {
+                    left = mid + 1
+                }
+            }
+            var n = start - left
+            switch (n) {
+                case 3:
+                    array[left + 3] = array[left + 2]
+                case 2:
+                    array[left + 2] = array[left + 1]
+                case 1:
+                    array[left + 1] = array[left]
+                    break;
+                default:
+                    while (n > 0) {
+                        array[left + n] = array[left + n - 1]
+                        n--;
+                    }
+            }
+            array[left] = pivot
+        }
+    }
+
+    function gallopLeft(value, array, start, length, hint, compare) {
+        var lastOffset = 0,
+            maxOffset = 0,
+            offset = 1
+        if (compare(value, array[start + hint]) > 0) {
+            maxOffset = length - hint
+            while (offset < maxOffset && compare(value, array[start + hint + offset]) > 0) {
+                lastOffset = offset
+                offset = (offset << 1) + 1
+                if (offset <= 0) {
+                    offset = maxOffset
+                }
+            }
+            if (offset > maxOffset) {
+                offset = maxOffset
+            }
+            lastOffset += hint
+            offset += hint
+        } else {
+            maxOffset = hint + 1
+            while (offset < maxOffset && compare(value, array[start + hint - offset]) <= 0) {
+                lastOffset = offset
+                offset = (offset << 1) + 1
+                if (offset <= 0) {
+                    offset = maxOffset
+                }
+            }
+            if (offset > maxOffset) {
+                offset = maxOffset
+            }
+            var tmp = lastOffset
+            lastOffset = hint - offset
+            offset = hint - tmp
+        }
+        lastOffset++
+        while (lastOffset < offset) {
+            var m = lastOffset + ((offset - lastOffset) >>> 1)
+            if (compare(value, array[start + m]) > 0) {
+                lastOffset = m + 1
+            } else {
+                offset = m
+            }
+        }
+        return offset
+    }
+
+    function gallopRight(value, array, start, length, hint, compare) {
+        var lastOffset = 0,
+            maxOffset = 0,
+            offset = 1
+        if (compare(value, array[start + hint]) < 0) {
+            maxOffset = hint + 1
+            while (offset < maxOffset && compare(value, array[start + hint - offset]) < 0) {
+                lastOffset = offset
+                offset = (offset << 1) + 1
+                if (offset <= 0) {
+                    offset = maxOffset
+                }
+            }
+            if (offset > maxOffset) {
+                offset = maxOffset
+            }
+            var tmp = lastOffset
+            lastOffset = hint - offset
+            offset = hint - tmp
+        } else {
+            maxOffset = length - hint
+            while (offset < maxOffset && compare(value, array[start + hint + offset]) >= 0) {
+                lastOffset = offset
+                offset = (offset << 1) + 1
+                if (offset <= 0) {
+                    offset = maxOffset
+                }
+            }
+            if (offset > maxOffset) {
+                offset = maxOffset
+            }
+            lastOffset += hint
+            offset += hint
+        }
+        lastOffset++
+        while (lastOffset < offset) {
+            var m = lastOffset + ((offset - lastOffset) >>> 1)
+            if (compare(value, array[start + m]) < 0) {
+                offset = m
+            } else {
+                lastOffset = m + 1
+            }
+        }
+        return offset
+    }
+    var TIM_SORT_ASSERTION = "TimSortAssertion"
+    var TimSortAssertion = function(message) {
+        this.name = TIM_SORT_ASSERTION
+        this.message = message
+    }
+    var TimSort = function(array, compare) {
+        var self = {
+            array: array,
+            compare: compare,
+            minGallop: DEFAULT_MIN_GALLOPING,
+            length: array.length,
+            tmpStorageLength: DEFAULT_TMP_STORAGE_LENGTH,
+            stackLength: 0,
+            runStart: null,
+            runLength: null,
+            stackSize: 0,
+            pushRun: function(runStart, runLength) {
+                this.runStart[this.stackSize] = runStart
+                this.runLength[this.stackSize] = runLength
+                this.stackSize += 1
+            },
+            mergeRuns: function() {
+                while (this.stackSize > 1) {
+                    var n = this.stackSize - 2
+                    if ((n >= 1 && this.runLength[n - 1] <=
+                            this.runLength[n] + this.runLength[n + 1]) ||
+                        (n >= 2 && this.runLength[n - 2] <=
+                            this.runLength[n] + this.runLength[n - 1])) {
+                        if (this.runLength[n - 1] < this.runLength[n + 1]) {
+                            n--
+                        }
+                    } else if (this.runLength[n] > this.runLength[n + 1]) {
+                        break
+                    }
+                    this.mergeAt(n)
+                }
+            },
+            forceMergeRuns: function() {
+                while (this.stackSize > 1) {
+                    var n = this.stackSize - 2
+                    if (n > 0 && this.runLength[n - 1] < this.runLength[n + 1]) {
+                        n--
+                    }
+                    this.mergeAt(n)
+                }
+            },
+            mergeAt: function(i) {
+                var compare = this.compare,
+                    array = this.array,
+                    start1 = this.runStart[i],
+                    length1 = this.runLength[i],
+                    start2 = this.runStart[i + 1],
+                    length2 = this.runLength[i + 1]
+                this.runLength[i] = length1 + length2
+                if (i === this.stackSize - 3) {
+                    this.runStart[i + 1] = this.runStart[i + 2]
+                    this.runLength[i + 1] = this.runLength[i + 2]
+                }
+                this.stackSize--;
+                var k = gallopRight(array[start2], array, start1, length1, 0, compare)
+                start1 += k
+                length1 -= k
+                if (length1 === 0) {
+                    return
+                }
+                length2 = gallopLeft(array[start1 + length1 - 1], array, start2, length2, length2 - 1, compare)
+                if (length2 === 0) {
+                    return
+                }
+                if (length1 <= length2) {
+                    this.mergeLow(start1, length1, start2, length2)
+                } else {
+                    this.mergeHigh(start1, length1, start2, length2)
+                }
+            },
+            mergeLow: function(start1, length1, start2, length2) {
+                var compare = this.compare,
+                    array = this.array,
+                    tmp = this.tmp,
+                    i = 0
+                for (var i = 0; i < length1; i++) {
+                    tmp[i] = array[start1 + i]
+                }
+                var cursor1 = 0,
+                    cursor2 = start2,
+                    dest = start1
+                array[dest++] = array[cursor2++]
+                if (--length2 === 0) {
+                    for (var i = 0; i < length1; i++) {
+                        array[dest + i] = tmp[cursor1 + i]
+                    }
+                    return
+                }
+                if (length1 === 1) {
+                    for (var i = 0; i < length2; i++) {
+                        array[dest + i] = array[cursor2 + i]
+                    }
+                    array[dest + length2] = tmp[cursor1]
+                    return
+                }
+                var minGallop = this.minGallop
+                while (true) {
+                    var count1 = 0,
+                        count2 = 0,
+                        exit = false
+                    do {
+                        if (compare(array[cursor2], tmp[cursor1]) < 0) {
+                            array[dest++] = array[cursor2++]
+                            count2++
+                            count1 = 0
+                            if (--length2 === 0) {
+                                exit = true
+                                break
+                            }
+                        } else {
+                            array[dest++] = tmp[cursor1++]
+                            count1++
+                            count2 = 0
+                            if (--length1 === 1) {
+                                exit = true
+                                break
+                            }
+                        }
+                    } while ((count1 | count2) < minGallop)
+                    if (exit) {
+                        break
+                    }
+                    do {
+                        count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare)
+                        if (count1 !== 0) {
+                            for (var i = 0; i < count1; i++) {
+                                array[dest + i] = tmp[cursor1 + i]
+                            }
+                            dest += count1
+                            cursor1 += count1
+                            length1 -= count1
+                            if (length1 <= 1) {
+                                exit = true
+                                break
+                            }
+                        }
+                        array[dest++] = array[cursor2++]
+                        if (--length2 === 0) {
+                            exit = true
+                            break
+                        }
+                        count2 = gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare)
+                        if (count2 !== 0) {
+                            for (var i = 0; i < count2; i++) {
+                                array[dest + i] = array[cursor2 + i]
+                            }
+                            dest += count2
+                            cursor2 += count2
+                            length2 -= count2
+                            if (length2 === 0) {
+                                exit = true
+                                break
+                            }
+                        }
+                        array[dest++] = tmp[cursor1++]
+                        if (--length1 === 1) {
+                            exit = true
+                            break
+                        }
+                        minGallop--;
+                    } while (count1 >= DEFAULT_MIN_GALLOPING ||
+                        count2 >= DEFAULT_MIN_GALLOPING);
+                    if (exit) {
+                        break
+                    }
+                    if (minGallop < 0) {
+                        minGallop = 0
+                    }
+                    minGallop += 2
+                }
+                this.minGallop = minGallop
+                if (minGallop < 1) {
+                    this.minGallop = 1
+                }
+                if (length1 === 1) {
+                    for (var i = 0; i < length2; i++) {
+                        array[dest + i] = array[cursor2 + i]
+                    }
+                    array[dest + length2] = tmp[cursor1]
+                } else if (length1 === 0) {
+                    throw new TimSortAssertion('mergeLow preconditions were not respected')
+                } else {
+                    for (var i = 0; i < length1; i++) {
+                        array[dest + i] = tmp[cursor1 + i]
+                    }
+                }
+            },
+            mergeHigh: function(start1, length1, start2, length2) {
+                var compare = this.compare,
+                    array = this.array,
+                    tmp = this.tmp,
+                    i = 0
+                for (var i = 0; i < length2; i++) {
+                    tmp[i] = array[start2 + i]
+                }
+                var cursor1 = start1 + length1 - 1,
+                    cursor2 = length2 - 1,
+                    dest = start2 + length2 - 1,
+                    customCursor = 0,
+                    customDest = 0
+                array[dest--] = array[cursor1--]
+                if (--length1 === 0) {
+                    customCursor = dest - (length2 - 1)
+                    for (var i = 0; i < length2; i++) {
+                        array[customCursor + i] = tmp[i]
+                    }
+                    return
+                }
+                if (length2 === 1) {
+                    dest -= length1
+                    cursor1 -= length1
+                    customDest = dest + 1
+                    customCursor = cursor1 + 1
+                    for (var i = length1 - 1; i >= 0; i--) {
+                        array[customDest + i] = array[customCursor + i]
+                    }
+                    array[dest] = tmp[cursor2]
+                    return
+                }
+                var minGallop = this.minGallop
+                while (true) {
+                    var count1 = 0,
+                        count2 = 0,
+                        exit = false
+                    do {
+                        if (compare(tmp[cursor2], array[cursor1]) < 0) {
+                            array[dest--] = array[cursor1--]
+                            count1++
+                            count2 = 0
+                            if (--length1 === 0) {
+                                exit = true
+                                break
+                            }
+                        } else {
+                            array[dest--] = tmp[cursor2--]
+                            count2++
+                            count1 = 0
+                            if (--length2 === 1) {
+                                exit = true
+                                break
+                            }
+                        }
+                    } while ((count1 | count2) < minGallop)
+                    if (exit) {
+                        break
+                    }
+                    do {
+                        count1 = length1 - gallopRight(tmp[cursor2], array, start1, length1, length1 - 1, compare)
+                        if (count1 !== 0) {
+                            dest -= count1
+                            cursor1 -= count1
+                            length1 -= count1
+                            customDest = dest + 1
+                            customCursor = cursor1 + 1
+                            for (var i = count1 - 1; i >= 0; i--) {
+                                array[customDest + i] = array[customCursor + i]
+                            }
+                            if (length1 === 0) {
+                                exit = true
+                                break
+                            }
+                        }
+                        array[dest--] = tmp[cursor2--]
+                        if (--length2 === 1) {
+                            exit = true
+                            break
+                        }
+                        count2 = length2 - gallopLeft(array[cursor1], tmp, 0, length2, length2 - 1, compare)
+                        if (count2 !== 0) {
+                            dest -= count2
+                            cursor2 -= count2
+                            length2 -= count2
+                            customDest = dest + 1
+                            customCursor = cursor2 + 1
+                            for (var i = 0; i < count2; i++) {
+                                array[customDest + i] = tmp[customCursor + i]
+                            }
+                            if (length2 <= 1) {
+                                exit = true
+                                break
+                            }
+                        }
+                        array[dest--] = array[cursor1--]
+                        if (--length1 === 0) {
+                            exit = true
+                            break
+                        }
+                        minGallop--
+                    } while (count1 >= DEFAULT_MIN_GALLOPING ||
+                        count2 >= DEFAULT_MIN_GALLOPING)
+                    if (exit) {
+                        break
+                    }
+                    if (minGallop < 0) {
+                        minGallop = 0
+                    }
+                    minGallop += 2
+                }
+                this.minGallop = minGallop
+                if (minGallop < 1) {
+                    this.minGallop = 1
+                }
+                if (length2 === 1) {
+                    dest -= length1
+                    cursor1 -= length1
+                    customDest = dest + 1
+                    customCursor = cursor1 + 1
+                    for (var i = length1 - 1; i >= 0; i--) {
+                        array[customDest + i] = array[customCursor + i]
+                    }
+                    array[dest] = tmp[cursor2]
+                } else if (length2 == 0) {
+                    throw new TimSortAssertion("mergeHigh preconditions were not respected")
+                } else {
+                    customCursor = dest - (length2 - 1)
+                    for (var i = 0; i < length2; i++) {
+                        array[customCursor + i] = tmp[i]
+                    }
+                }
+            }
+        }
+        if (self.length < 2 * DEFAULT_TMP_STORAGE_LENGTH) {
+            self.tmpStorageLength = self.length >>> 1
+        }
+        self.tmp = new Array(self.tmpStorageLength)
+        self.stackLength =
+            (self.length < 120 ? 5 :
+                self.length < 1542 ? 10 :
+                self.length < 119151 ? 19 : 40)
+        self.runStart = new Array(self.stackLength)
+        self.runLength = new Array(self.stackLength)
+        return self
+    }
+
+    function tim_sort(array, compare, lo, hi) {
+        if (!Array.isArray(array)) {
+            throw _b_.TypeError.$factory("Can only sort arrays")
+        }
+        if (!compare) {
+            compare = alphabeticalCompare
+        } else if (typeof compare !== "function") {
+            hi = lo
+            lo = compare
+            compare = alphabeticalCompare
+        }
+        if (!lo) {
+            lo = 0
+        }
+        if (!hi) {
+            hi = array.length
+        }
+        var remaining = hi - lo
+        if (remaining < 2) {
+            return
+        }
+        var runLength = 0
+        if (remaining < DEFAULT_MIN_MERGE) {
+            runLength = makeAscendingRun(array, lo, hi, compare)
+            binaryInsertionSort(array, lo, hi, lo + runLength, compare)
+            return
+        }
+        var ts = new TimSort(array, compare)
+        var minRun = minRunLength(remaining)
+        do {
+            runLength = makeAscendingRun(array, lo, hi, compare)
+            if (runLength < minRun) {
+                var force = remaining
+                if (force > minRun) {
+                    force = minRun
+                }
+                binaryInsertionSort(array, lo, lo + force, lo + runLength, compare)
+                runLength = force
+            }
+            ts.pushRun(lo, runLength)
+            ts.mergeRuns()
+            remaining -= runLength
+            lo += runLength
+        } while (remaining !== 0)
+        ts.forceMergeRuns()
+    }
+
+    function tim_sort_safe(array, compare) {
+        try {
+            tim_sort(array, compare, 0, array.length)
+        } catch (e) {
+            if (e.name == TIM_SORT_ASSERTION) {
+                array.sort(compare);
+            } else {
+                throw e;
+            }
+        }
+    }
+    $B.$TimSort = tim_sort_safe
+    $B.$AlphabeticalCompare = alphabeticalCompare
 })(__BRYTHON__);
 
 ;
 (function($B) {
     var _b_ = $B.builtins
     _b_.__debug__ = false
     $B.$comps = {
@@ -14133,14 +15988,15 @@
         check_no_kw('callable', obj)
         return hasattr(obj, '__call__')
     }
 
     function chr(i) {
         check_nb_args('chr', 1, arguments)
         check_no_kw('chr', i)
+        i = $B.PyNumber_Index(i)
         if (i < 0 || i > 1114111) {
             throw _b_.ValueError.$factory('Outside valid range')
         } else if (i >= 0x10000 && i <= 0x10FFFF) {
             var code = (i - 0x10000)
             return String.fromCodePoint(0xD800 | (code >> 10)) +
                 String.fromCodePoint(0xDC00 | (code & 0x3FF))
         } else {
@@ -14233,15 +16089,15 @@
                 $B.class_name(attr) + "'")
         }
         return $B.$getattr(obj, '__delattr__')(attr)
     }
     $B.$delete = function(name, is_global) {
         function del(obj) {
             if (obj.__class__ === $B.generator) {
-                obj.return()
+                obj.js_gen.return()
             }
         }
         var found = false,
             frame = $B.last($B.frames_stack)
         if (!is_global) {
             if (frame[1][name] !== undefined) {
                 found = true
@@ -14329,26 +16185,14 @@
         return self
     }
     enumerate.__next__ = function(self) {
         self.counter++
         return $B.fast_tuple([self.counter, next(self.iter)])
     }
     $B.set_func_names(enumerate, "builtins")
-    $B.from_alias = function(attr) {
-        if (attr.substr(0, 2) == '$$' && $B.aliased_names[attr.substr(2)]) {
-            return attr.substr(2)
-        }
-        return attr
-    }
-    $B.to_alias = function(attr) {
-        if ($B.aliased_names[attr]) {
-            return '$$' + attr
-        }
-        return attr
-    }
 
     function $$eval(src, _globals, _locals) {
         var $ = $B.args("eval", 4, {
                 src: null,
                 globals: null,
                 locals: null,
                 mode: null
@@ -14363,17 +16207,19 @@
             mode = $.mode
         if ($.src.mode && $.src.mode == "single" && ["<console>", "<stdin>"].indexOf($.src.filename) > -1) {
             _b_.print(">", $.src.source.trim())
         }
         if (src.__class__ === code) {
             mode = src.mode
             src = src.source
-        } else if (typeof src !== 'string') {
+        } else if (typeof src.valueOf() !== 'string') {
             throw _b_.TypeError.$factory("eval() arg 1 must be a string, bytes " +
                 "or code object")
+        } else {
+            src = src.valueOf()
         }
         var current_frame = $B.frames_stack[$B.frames_stack.length - 1]
         if (current_frame !== undefined) {
             var current_locals_id = current_frame[0].replace(/\./g, '_'),
                 current_globals_id = current_frame[2].replace(/\./g, '_')
         }
         var stack_len = $B.frames_stack.length
@@ -14429,31 +16275,31 @@
                 }
                 parent_scope = {
                     id: locals_id,
                     parent_block: grandparent_scope,
                     binding: {}
                 }
                 for (var attr in _globals.$string_dict) {
-                    grandparent_scope.binding[$B.to_alias(attr)] = true
+                    grandparent_scope.binding[attr] = true
                 }
                 for (var attr in _locals.$string_dict) {
-                    parent_scope.binding[$B.to_alias(attr)] = true
+                    parent_scope.binding[attr] = true
                 }
             }
         }
         $B.$py_module_path[globals_id] = $B.$py_module_path[current_globals_id]
         eval('var $locals_' + globals_id + ' = {}\nvar $locals_' +
             locals_id + ' = {}')
         if (_globals === _b_.None) {
             var gobj = current_frame[3],
                 ex = 'var $locals_' + globals_id + ' = gobj;',
                 obj = {}
             eval(ex)
             for (var attr in gobj) {
-                if (attr.startsWith("$") && !attr.startsWith("$$")) {
+                if (attr.startsWith("$")) {
                     continue
                 }
                 obj[attr] = gobj[attr]
             }
             eval("$locals_" + globals_id + " = obj")
         } else {
             var globals_is_dict = false
@@ -14462,17 +16308,16 @@
             } else {
                 var items = _b_.dict.$to_obj(_globals)
                 _globals.$jsobj = items
                 globals_is_dict = true
             }
             eval("$locals_" + globals_id + " = _globals.$jsobj")
             for (var item in items) {
-                var item1 = $B.to_alias(item)
                 try {
-                    eval('$locals_' + globals_id + '["' + item1 + '"] = items.' + item)
+                    eval('$locals_' + globals_id + '["' + item + '"] = items.' + item)
                 } catch (err) {
                     console.log(err)
                     console.log('error setting', item)
                     break
                 }
             }
         }
@@ -14481,15 +16326,15 @@
             if (_globals !== _b_.None) {
                 eval('var $locals_' + locals_id + ' = $locals_' + globals_id)
             } else {
                 var lobj = current_frame[1],
                     ex = '',
                     obj = {}
                 for (var attr in current_frame[1]) {
-                    if (attr.startsWith("$") && !attr.startsWith("$$")) {
+                    if (attr.startsWith("$")) {
                         continue
                     }
                     obj[attr] = lobj[attr]
                 }
                 eval('$locals_' + locals_id + " = obj")
             }
         } else {
@@ -14499,17 +16344,16 @@
             } else if (_locals.__class__ !== _b_.dict) {
                 items = _locals
             } else {
                 items = _b_.dict.$to_obj(_locals)
                 _locals.$jsobj = items
             }
             for (var item in items) {
-                var item1 = $B.to_alias(item)
                 try {
-                    eval('$locals_' + locals_id + '["' + item1 + '"] = items.' + item)
+                    eval('$locals_' + locals_id + '["' + item + '"] = items.' + item)
                 } catch (err) {
                     console.log(err)
                     console.log('error setting', item)
                     break
                 }
             }
             eval("$locals_" + locals_id + ".$exec_locals = true")
@@ -14534,14 +16378,15 @@
                 instr = try_node.children[try_node.children.length - 2]
             var type = instr.C.tree[0].type
             switch (type) {
                 case 'expr':
                 case 'list_or_tuple':
                 case 'op':
                 case 'ternary':
+                case 'unary':
                     var children = try_node.children
                     root.children.splice(root.children.length - 2, 2)
                     for (var i = 0; i < children.length - 1; i++) {
                         root.add(children[i])
                     }
                     break
                 default:
@@ -14592,22 +16437,21 @@
             gns = eval("$locals_" + globals_id)
             if ($B.frames_stack[$B.frames_stack.length - 1][2] == globals_id) {
                 gns = $B.frames_stack[$B.frames_stack.length - 1][3]
             }
             if (_locals !== _b_.None) {
                 lns = eval("$locals_" + locals_id)
                 for (var attr in lns) {
-                    var attr1 = $B.from_alias(attr)
-                    if (attr1.charAt(0) != '$') {
+                    if (attr.charAt(0) != '$') {
                         if (_locals.$jsobj) {
                             _locals.$jsobj[attr] = lns[attr]
                         } else if (_locals.__class__ !== _b_.dict) {
-                            $B.$setitem(_locals, attr1, lns[attr])
+                            $B.$setitem(_locals, attr, lns[attr])
                         } else {
-                            _b_.dict.$setitem(_locals, attr1, lns[attr])
+                            _b_.dict.$setitem(_locals, attr, lns[attr])
                         }
                     }
                 }
             } else {
                 for (var attr in lns) {
                     if (attr !== "$src") {
                         current_frame[1][attr] = lns[attr]
@@ -14616,25 +16460,24 @@
             }
             if (_globals !== _b_.None) {
                 if (globals_is_dict) {
                     var jsobj = _globals.$jsobj
                     delete _globals.$jsobj
                 }
                 for (var attr in gns) {
-                    attr1 = $B.from_alias(attr)
-                    if (attr1.charAt(0) != '$') {
+                    if (attr.charAt(0) != '$') {
                         if (globals_is_dict) {
                             _b_.dict.$setitem(_globals, attr, gns[attr])
                         } else {
-                            _globals.$jsobj[attr1] = gns[attr]
+                            _globals.$jsobj[attr] = gns[attr]
                         }
                     }
                 }
                 for (var attr in _globals.$string_dict) {
-                    if (attr.startsWith("$") && !attr.startsWith("$$")) {
+                    if (attr.startsWith("$")) {
                         delete _globals.$string_dict[attr]
                     }
                 }
             } else {
                 for (var attr in gns) {
                     if (attr !== "$src") {
                         current_frame[3][attr] = gns[attr]
@@ -14783,15 +16626,14 @@
             if (mro[i].hasOwnProperty(attr)) {
                 return mro[i][attr]
             }
         }
         return false
     }
     $B.$getattr = function(obj, attr, _default) {
-        attr = $B.to_alias(attr)
         if (obj.$method_cache &&
             obj.$method_cache[attr] &&
             obj.__class__ &&
             obj.__class__[attr] == obj.$method_cache[attr][1]) {
             return obj.$method_cache[attr][0]
         }
         var rawname = attr
@@ -14800,23 +16642,24 @@
         }
         var is_class = obj.$is_class || obj.$factory
         var klass = obj.__class__
         var $test = false
         if ($test) {
             console.log("$getattr", attr, obj, klass)
         }
-        if (klass !== undefined && klass.__bases__ &&
+        if (klass !== undefined && (!klass.$native) && klass.__bases__ &&
             klass.__getattribute__ === undefined &&
             (klass.__bases__.length == 0 ||
                 (klass.__bases__.length == 1 &&
                     klass.__bases__[0] === _b_.object))) {
             if ($test) {
-                console.log("class without parent")
+                console.log("class without parent", klass)
+                console.log('obj[attr]', obj[attr])
             }
-            if (obj.hasOwnProperty(attr)) {
+            if (obj[attr] !== undefined) {
                 return obj[attr]
             } else if (obj.__dict__ &&
                 obj.__dict__.$string_dict.hasOwnProperty(attr) &&
                 !(klass.hasOwnProperty(attr) &&
                     klass[attr].__get__)) {
                 return obj.__dict__.$string_dict[attr][0]
             } else if (klass.hasOwnProperty(attr)) {
@@ -14883,23 +16726,22 @@
                 break
             case '__class__':
                 return klass
             case '__dict__':
                 if (is_class) {
                     var proxy = {}
                     for (var key in obj) {
-                        var key1 = $B.from_alias(key)
-                        if (!key1.startsWith("$")) {
-                            proxy[key1] = obj[key]
+                        if (!key.startsWith("$")) {
+                            proxy[key] = obj[key]
                         }
                     }
                     proxy.__dict__ = $B.getset_descriptor.$factory(obj, "__dict__")
                     return $B.mappingproxy.$factory(proxy)
                 } else {
-                    if (obj.hasOwnProperty(attr)) {
+                    if (obj[attr] !== undefined) {
                         return obj[attr]
                     } else if (obj.$infos) {
                         if (obj.$infos.hasOwnProperty("__dict__")) {
                             return obj.$infos.__dict__
                         } else if (obj.$infos.hasOwnProperty("__func__")) {
                             return obj.$infos.__func__.$infos.__dict__
                         }
@@ -15028,19 +16870,22 @@
         if ($test) {
             console.log("attr_func is odga ?", attr_func, attr_func === odga, obj[attr])
         }
         if (attr_func === odga) {
             var res = obj[attr]
             if (Array.isArray(obj) && Array.prototype[attr] !== undefined) {
                 res = undefined
-            }
-            if (res === null) {
+            } else if (res === null) {
                 return null
-            } else if (res === undefined && obj.hasOwnProperty(attr)) {
-                return res
+            } else if (res === undefined && obj[attr] !== undefined) {
+                console.log('cas 1')
+                if (_default === undefined) {
+                    throw _b_.AttributeError.$factory(attr)
+                }
+                return _default
             } else if (res !== undefined) {
                 if ($test) {
                     console.log(obj, attr, obj[attr], res.__set__ || res.$is_class)
                 }
                 if (res.__set__ === undefined || res.$is_class) {
                     if ($test) {
                         console.log("return", res, res + '', res.__set__, res.$is_class)
@@ -15445,15 +17290,15 @@
                 $B.class_name(obj) + "' has no len()")
         }
         return $B.$call(method)(obj)
     }
 
     function locals() {
         check_nb_args('locals', 0, arguments)
-        var res = $B.obj_dict($B.last($B.frames_stack)[1])
+        var res = $B.obj_dict($B.clone($B.last($B.frames_stack)[1]))
         res.$is_namespace = true
         delete res.$jsobj.__annotations__
         return res
     }
     var map = $B.make_class("map", function() {
         var $ = $B.args('map', 2, {
                 func: null,
@@ -15484,55 +17329,53 @@
     $B.set_func_names(map, "builtins")
 
     function $extreme(args, op) {
         var $op_name = 'min'
         if (op === '__gt__') {
             $op_name = "max"
         }
-        if (args.length == 0) {
-            throw _b_.TypeError.$factory($op_name +
-                " expected 1 arguments, got 0")
-        }
-        var last_arg = args[args.length - 1],
-            nb_args = args.length,
-            has_default = false,
+        var $ = $B.args($op_name, 0, {}, [], args, {}, 'args', 'kw')
+        var has_default = false,
             func = false
-        if (last_arg.$nat == 'kw') {
-            nb_args--
-            last_arg = last_arg.kw
-            for (var attr in last_arg) {
-                switch (attr) {
-                    case 'key':
-                        func = last_arg[attr]
-                        break
-                    case '$$default':
-                        var default_value = last_arg[attr]
-                        has_default = true
-                        break
-                    default:
-                        throw _b_.TypeError.$factory("'" + attr +
-                            "' is an invalid keyword argument for this function")
-                }
+        for (var attr in $.kw.$string_dict) {
+            switch (attr) {
+                case 'key':
+                    func = $.kw.$string_dict[attr][0]
+                    break
+                case 'default':
+                    var default_value = $.kw.$string_dict[attr][0]
+                    has_default = true
+                    break
+                default:
+                    throw _b_.TypeError.$factory("'" + attr +
+                        "' is an invalid keyword argument for this function")
             }
         }
         if ((!func) || func === _b_.None) {
-            func = function(x) {
-                return x
-            }
+            func = x => x
         }
-        if (nb_args == 0) {
-            throw _b_.TypeError.$factory($op_name + " expected 1 argument, got 0")
-        } else if (nb_args == 1) {
-            var $iter = iter(args[0]),
-                res = null
+        if ($.args.length == 0) {
+            throw _b_.TypeError.$factory($op_name +
+                " expected 1 arguments, got 0")
+        } else if ($.args.length == 1) {
+            var $iter = iter($.args[0]),
+                res = null,
+                x_value, extr_value
             while (true) {
                 try {
                     var x = next($iter)
-                    if (res === null || $B.$bool($B.$getattr(func(x), op)(func(res)))) {
+                    if (res === null) {
+                        extr_value = func(x)
                         res = x
+                    } else {
+                        x_value = func(x)
+                        if ($B.rich_comp(op, x_value, extr_value)) {
+                            res = x
+                            extr_value = x_value
+                        }
                     }
                 } catch (err) {
                     if (err.__class__ == _b_.StopIteration) {
                         if (res === null) {
                             if (has_default) {
                                 return default_value
                             } else {
@@ -15547,22 +17390,20 @@
                 }
             }
         } else {
             if (has_default) {
                 throw _b_.TypeError.$factory("Cannot specify a default for " +
                     $op_name + "() with multiple positional arguments")
             }
-            var res = null
-            for (var i = 0; i < nb_args; i++) {
-                var x = args[i]
-                if (res === null || $B.$bool($B.$getattr(func(x), op)(func(res)))) {
-                    res = x
-                }
+            if ($B.last(args).$nat) {
+                var _args = [$.args].concat($B.last(args))
+            } else {
+                var _args = [$.args]
             }
-            return res
+            return $extreme.call(null, _args, op)
         }
     }
 
     function max() {
         return $extreme(arguments, '__gt__')
     }
     var memoryview = $B.make_class('memoryview', function(obj) {
@@ -15586,20 +17427,21 @@
                 contiguous: true
             }
         } else {
             throw _b_.TypeError.$factory("memoryview: a bytes-like object " +
                 "is required, not '" + $B.class_name(obj) + "'")
         }
     })
-    memoryview.__eq__ = function(self, other) {
-        if (other.__class__ !== memoryview) {
-            return false
+    memoryview.$match_sequence_pattern = true,
+        memoryview.__eq__ = function(self, other) {
+            if (other.__class__ !== memoryview) {
+                return false
+            }
+            return $B.$getattr(self.obj, '__eq__')(other.obj)
         }
-        return $B.$getattr(self.obj, '__eq__')(other.obj)
-    }
     memoryview.__getitem__ = function(self, key) {
         if (isinstance(key, _b_.int)) {
             var start = key * self.itemsize
             if (self.format == "I") {
                 var res = self.obj.source[start],
                     coef = 256
                 for (var i = 1; i < 4; i++) {
@@ -15620,14 +17462,21 @@
         if (key.__class__ === _b_.slice) {
             return memoryview.$factory(res)
         }
     }
     memoryview.__len__ = function(self) {
         return len(self.obj) / self.itemsize
     }
+    memoryview.__setitem__ = function(self, key, value) {
+        try {
+            $B.$setitem(self.obj, key, value)
+        } catch (err) {
+            throw _b_.TypeError.$factory("cannot modify read-only memory")
+        }
+    }
     memoryview.cast = function(self, format) {
         switch (format) {
             case "B":
                 return memoryview.$factory(self.obj)
             case "I":
                 var res = memoryview.$factory(self.obj),
                     objlen = len(self.obj)
@@ -15721,15 +17570,15 @@
         check_nb_args('oct', 1, arguments)
         return bin_hex_oct(8, obj)
     }
 
     function ord(c) {
         check_no_kw('ord', c)
         check_nb_args('ord', 1, arguments)
-        if (typeof c == 'string') {
+        if (typeof c.valueOf() == 'string') {
             if (c.length == 1) {
                 return c.charCodeAt(0)
             }
             if ((0xD800 <= c[0] && c[0] <= 0xDBFF) ||
                 (0xDC00 <= c[1] && c[1] <= 0xDFFF)) {
                 throw _b_.TypeError.$factory('ord() expected a character, but ' +
                     'string of length ' + c.length + ' found')
@@ -15970,18 +17819,15 @@
         if (!(typeof attr == 'string')) {
             throw _b_.TypeError.$factory("setattr(): attribute name must be string")
         }
         return $B.$setattr(obj, attr, value)
     }
     $B.$setattr = function(obj, attr, value) {
         var $test = false
-        var unaliased = $B.from_alias(attr)
-        if ($B.aliased_names[attr]) {
-            attr = '$$' + attr
-        } else if (attr == '__dict__') {
+        if (attr == '__dict__') {
             if (!isinstance(value, _b_.dict)) {
                 throw _b_.TypeError.$factory("__dict__ must be set to a dictionary, " +
                     "not a '" + $B.class_name(value) + "'")
             }
             if (obj.$infos) {
                 obj.$infos.__dict__ = value
                 return None
@@ -15994,15 +17840,16 @@
             }
             if (value.__class__) {
                 if (value.__module__ == "builtins") {
                     error("__class__ assignement only " +
                         "supported for heap types or ModuleType subclasses")
                 } else if (Array.isArray(value.__bases__)) {
                     for (var i = 0; i < value.__bases__.length; i++) {
-                        if (value.__bases__[i].__module__ == "builtins") {
+                        if (value.__bases__[i] !== _b_.object &&
+                            value.__bases__[i].__module__ == "builtins") {
                             error("__class__ assignment: '" + $B.class_name(obj) +
                                 "' object layout differs from '" +
                                 $B.class_name(value) + "'")
                         }
                     }
                 }
             }
@@ -16130,38 +17977,38 @@
                     } else {
                         return klass.__slots__
                     }
                 }
                 return []
             }
             var has_slot = false
-            if (mangled_slots(klass).indexOf(unaliased) > -1) {
+            if (mangled_slots(klass).indexOf(attr) > -1) {
                 has_slot = true
             } else {
                 for (var i = 0; i < klass.__mro__.length; i++) {
                     var kl = klass.__mro__[i]
-                    if (mangled_slots(kl).indexOf(unaliased) > -1) {
+                    if (mangled_slots(kl).indexOf(attr) > -1) {
                         has_slot = true
                         break
                     }
                 }
             }
             if (!has_slot) {
                 throw _b_.AttributeError.$factory("'" + klass.$infos.__name__ +
-                    "' object has no attribute '" + unaliased + "'")
+                    "' object has no attribute '" + attr + "'")
             }
         }
         if ($test) {
             console.log("attr", attr, "use _setattr", _setattr)
         }
         if (!_setattr) {
             if (obj.__dict__ === undefined) {
                 obj[attr] = value
             } else {
-                _b_.dict.$setitem(obj.__dict__, unaliased, value)
+                _b_.dict.$setitem(obj.__dict__, attr, value)
             }
             if ($test) {
                 console.log("no setattr, obj", obj)
             }
         } else {
             _setattr(obj, attr, value)
         }
@@ -16199,15 +18046,15 @@
                 start: null
             }, ['iterable', 'start'], arguments, {
                 start: 0
             }, null, null),
             iterable = $.iterable,
             start = $.start
         if (_b_.isinstance(start, [_b_.str, _b_.bytes])) {
-            throw _b_.TypeError.$factory("TypeError: sum() can't sum bytes" +
+            throw _b_.TypeError.$factory("sum() can't sum bytes" +
                 " [use b''.join(seq) instead]")
         }
         var res = start,
             iterable = iter(iterable)
         while (1) {
             try {
                 var _item = next(iterable)
@@ -16337,14 +18184,24 @@
                 __qualname__: self.__thisclass__.$infos.__name__ + "." + attr
             }
             return method
         }
         throw _b_.AttributeError.$factory("object 'super' has no attribute '" +
             attr + "'")
     }
+    $$super.__init__ = function(cls) {
+        if (cls === undefined) {
+            throw _b_.TypeError.$factory("descriptor '__init__' of 'super' " +
+                "object needs an argument")
+        }
+        if (cls.__class__ !== $$super) {
+            throw _b_.TypeError.$factory("descriptor '__init__' requires a" +
+                " 'super' object but received a '" + $B.class_name(cls) + "'")
+        }
+    }
     $$super.__repr__ = function(self) {
         $B.builtins_repr_check($$super, arguments)
         var res = "<super: <class '" + self.__thisclass__.$infos.__name__ + "'>"
         if (self.__self_class__ !== undefined) {
             res += ', <' + self.__self_class__.__class__.$infos.__name__ + ' object>'
         } else {
             res += ', NULL'
@@ -16419,14 +18276,18 @@
         return true
     }
 
     function make_lines(self) {
         if (self.$lines === undefined) {
             if (!self.$binary) {
                 self.$lines = self.$content.split("\n")
+                if ($B.last(self.$lines) == '') {
+                    self.$lines.pop()
+                }
+                self.$lines = self.$lines.map(x => x + '\n')
             } else {
                 var lines = [],
                     pos = 0,
                     source = self.$content.source
                 while (pos < self.$length) {
                     var ix = source.indexOf(10, pos)
                     if (ix == -1) {
@@ -16512,17 +18373,14 @@
             var lines = []
             while (self.$lc < self.$lines.length &&
                 nb_read < hint) {
                 self.$lc++
                 lines.push(self.$lines[self.$lc])
             }
         }
-        while (lines[lines.length - 1] == '') {
-            lines.pop()
-        }
         return lines
     }
     $Reader.seek = function(self, offset, whence) {
         if (self.closed === True) {
             throw _b_.ValueError.$factory('I/O operation on closed file')
         }
         if (whence === undefined) {
@@ -16562,15 +18420,15 @@
             errors: _b_.None,
             newline: _b_.None,
             line_buffering: _b_.False,
             write_through: _b_.False
         }, null, null)
         return {
             __class__: $TextIOWrapper,
-            $bytes: $.buffer.$bytes,
+            $content: _b_.bytes.decode($.buffer.$content, $.encoding),
             encoding: $.encoding,
             errors: $.errors,
             newline: $.newline
         }
     })
     $TextIOWrapper.__mro__ = [$Reader, _b_.object]
     $B.set_func_names($TextIOWrapper, "builtins")
@@ -16595,21 +18453,19 @@
             throw _b_.IOError.$factory("Browsers cannot write on disk")
         } else if (['r', 'rb'].indexOf(mode) == -1) {
             throw _b_.ValueError.$factory("Invalid mode '" + mode + "'")
         }
         if (isinstance(file, _b_.str)) {
             var is_binary = mode.search('b') > -1
             if ($B.file_cache.hasOwnProperty($.file)) {
-                console.log('open cas 1')
                 result.content = $B.file_cache[$.file]
                 if (is_binary) {
-                    result.content = _b_.str.encode(content, 'utf-8')
+                    result.content = _b_.str.encode(result.content, 'utf-8')
                 }
             } else if ($B.files && $B.files.hasOwnProperty($.file)) {
-                console.log('open cas 2')
                 $res = atob($B.files[$.file].content)
                 var source = []
                 for (const char of $res) {
                     source.push(char.charCodeAt(0))
                 }
                 $bytes = _b_.bytes.$factory()
                 $bytes.source = source
@@ -16643,15 +18499,15 @@
                                 result.error = error
                             }
                         }
                     }
                 }
                 var fake_qs = $B.$options.cache ? '' :
                     '?foo=' + (new Date().getTime())
-                req.open('GET', file + fake_qs, false)
+                req.open('GET', encodeURI(file + fake_qs), false)
                 req.send()
             } else {
                 throw _b_.FileNotFoundError.$factory(
                     "cannot use 'open()' with protocol 'file'")
             }
             if (result.error !== undefined) {
                 throw result.error
@@ -16983,18 +18839,18 @@
         var name = builtin_names[i],
             orig_name = name,
             name1 = name
         if (name == 'open') {
             name1 = '$url_open'
         }
         if (name == 'super') {
-            name = name1 = '$$super'
+            name1 = '$$super'
         }
         if (name == 'eval') {
-            name = name1 = '$$eval'
+            name1 = '$$eval'
         }
         if (name == 'print') {
             name1 = '$print'
         }
         try {
             _b_[name] = eval(name1)
             if ($B.builtin_funcs.indexOf(orig_name) > -1) {
@@ -17005,21 +18861,20 @@
                     __qualname__: orig_name
                 }
             }
         } catch (err) {}
     }
     _b_['open'] = $url_open
     _b_['print'] = $print
-    _b_['$$super'] = $$super
+    _b_['super'] = $$super
     _b_.object.__init__.__class__ = wrapper_descriptor
     _b_.object.__new__.__class__ = builtin_function
 })(__BRYTHON__);;
 (function($B) {
-    var bltns = $B.InjectBuiltins()
-    eval(bltns)
+    var _b_ = $B.builtins
     $B.del_exc = function() {
         var frame = $B.last($B.frames_stack)
         frame[1].$current_exception = undefined
     }
     $B.set_exc = function(exc) {
         var frame = $B.last($B.frames_stack)
         if (frame === undefined) {
@@ -17034,21 +18889,21 @@
     $B.$raise = function(arg) {
         if (arg === undefined) {
             var es = $B.get_exc()
             if (es !== undefined) {
                 throw es
             }
             throw _b_.RuntimeError.$factory("No active exception to reraise")
-        } else if (isinstance(arg, BaseException)) {
+        } else if (_b_.isinstance(arg, BaseException)) {
             if (arg.__class__ === _b_.StopIteration &&
                 $B.last($B.frames_stack)[1].$is_generator) {
                 arg = _b_.RuntimeError.$factory("generator raised StopIteration")
             }
             throw arg
-        } else if (arg.$is_class && issubclass(arg, BaseException)) {
+        } else if (arg.$is_class && _b_.issubclass(arg, BaseException)) {
             if (arg === _b_.StopIteration) {
                 if ($B.last($B.frames_stack)[1].$is_generator) {
                     throw _b_.RuntimeError.$factory("generator raised StopIteration")
                 }
             }
             throw $B.$call(arg)()
         } else {
@@ -17220,15 +19075,15 @@
                         console.log(file)
                         console.log("no src for", info)
                         return ""
                     }
                 }
             case "tb_next":
                 if (self.$stack.length <= 1) {
-                    return None
+                    return _b_.None
                 } else {
                     return traceback.$factory(self.exc, self.$stack.slice(1))
                 }
             default:
                 return _b_.object.__getattribute__(self, attr)
         }
     }
@@ -17277,16 +19132,16 @@
             if (locals_id == _frame[2]) {
                 co_name = "<module>"
             } else if (locals_id.startsWith("lc" + $B.lambda_magic)) {
                 co_name = "<listcomp>"
             } else {
                 if (_frame[1].$name) {
                     co_name = _frame[1].$name
-                } else if (_frame[1].$dict_comp) {
-                    co_name = '<dictcomp>'
+                } else if (_frame[1].$comprehension) {
+                    co_name = '<' + _frame[1].$comprehension + '>'
                 } else if (_frame[1].$list_comp) {
                     co_name = '<listcomp>'
                 } else if (_frame.length > 4) {
                     if (_frame[4].$infos) {
                         co_name = _frame[4].$infos.__name__
                     } else {
                         co_name = _frame[4].name
@@ -17313,14 +19168,17 @@
             if (_frame.length > 4 && _frame[4].$infos !== undefined) {
                 res.f_code = _frame[4].$infos.__code__
             } else {
                 res.f_code = {
                     co_name: co_name,
                     co_filename: filename
                 }
+                if (_frame[1].$comp_code) {
+                    $B.update_obj(res.f_code, _frame[1].$comp_code)
+                }
             }
             res.f_code.__class__ = $B.code
             res.f_code.co_code = _b_.None
             if (filename === undefined) {
                 res.f_code.co_filename = "<string>"
             }
         }
@@ -17373,18 +19231,18 @@
     BaseException.__init__ = function(self) {
         var args = arguments[1] === undefined ? [] : [arguments[1]]
         self.args = _b_.tuple.$factory(args)
     }
     BaseException.__repr__ = function(self) {
         var res = self.__class__.$infos.__name__
         if (self.args[0] !== undefined) {
-            res += '(' + repr(self.args[0])
+            res += '(' + _b_.repr(self.args[0])
         }
         if (self.args.length > 1) {
-            res += ', ' + repr($B.fast_tuple(self.args.slice(1)))
+            res += ', ' + _b_.repr($B.fast_tuple(self.args.slice(1)))
         }
         return res + ')'
     }
     BaseException.__str__ = function(self) {
         if (self.args.length > 0) {
             return _b_.str.$factory(self.args[0])
         }
@@ -17567,15 +19425,14 @@
             exc.__class__ = _b_.Exception
             exc.$js_exc = js_exc
             if ($B.is_recursion_error(js_exc)) {
                 return _b_.RecursionError.$factory("too much recursion")
             } else if (js_exc.name == "ReferenceError") {
                 exc.__name__ = "NameError"
                 exc.__class__ = _b_.NameError
-                js_exc.message = js_exc.message.replace("$$", "")
             } else if (js_exc.name == "InternalError") {
                 exc.__name__ = "RuntimeError"
                 exc.__class__ = _b_.RuntimeError
             }
             exc.__cause__ = _b_.None
             exc.__context__ = _b_.None
             exc.__suppress_context__ = false
@@ -17606,15 +19463,15 @@
         }
         var this_exc_class = exc.$is_class ? exc : exc.__class__
         for (var i = 0; i < exc_list.length; i++) {
             var exc_class = exc_list[i]
             if (this_exc_class === undefined) {
                 console.log("exc class undefined", exc)
             }
-            if (issubclass(this_exc_class, exc_class)) {
+            if (_b_.issubclass(this_exc_class, exc_class)) {
                 return true
             }
         }
         return false
     }
     $B.is_recursion_error = function(js_exc) {
         console.log("test is js exc is recursion error", js_exc, js_exc + "")
@@ -17637,14 +19494,15 @@
                 var code = name[1],
                     name = name[0]
             }
             $B.builtins_scope[name] = true
             var $exc = (BaseException.$factory + "").replace(/BaseException/g, name)
             $exc = $exc.replace("//placeholder//", code)
             _str[pos++] = "_b_." + name + ' = {__class__:_b_.type, ' +
+                '__bases__: [_b_.' + parent.$infos.__name__ + '], ' +
                 '__mro__: [_b_.' + parent.$infos.__name__ +
                 "].concat(parent.__mro__), $is_class: true," +
                 "$infos: {__name__:'" + name + "'}}"
             _str[pos++] = "_b_." + name + ".$factory = " + $exc
             _str[pos++] = "_b_." + name + '.$factory.$infos = {__name__: "' +
                 name + '", __qualname__: "' + name + '"}'
             _str[pos++] = "$B.set_func_names(_b_." + name + ", 'builtins')"
@@ -17712,14 +19570,15 @@
             __mro__: [_b_.object],
             $infos: {
                 __module__: "builtins",
                 __name__: "range"
             },
             $is_class: true,
             $native: true,
+            $match_sequence_pattern: true,
             $descriptors: {
                 start: true,
                 step: true,
                 stop: true
             }
         }
     range.__contains__ = function(self, other) {
@@ -18303,15 +20162,15 @@
             self.source.splice(start, stop - start)
             try {
                 var $temp = _b_.list.$factory(value)
                 for (var i = $temp.length - 1; i >= 0; i--) {
                     if (!_b_.isinstance($temp[i], _b_.int)) {
                         throw _b_.TypeError.$factory('an integer is required')
                     } else if ($temp[i] > 255) {
-                        throw ValueError.$factory("byte must be in range(0, 256)")
+                        throw _b_.ValueError.$factory("byte must be in range(0, 256)")
                     }
                     self.source.splice(start, 0, $temp[i])
                 }
             } catch (err) {
                 throw _b_.TypeError.$factory("can only assign an iterable")
             }
         } else {
@@ -18325,15 +20184,15 @@
                 "append takes exactly one argument (" + (arguments.length - 1) +
                 " given)")
         }
         if (!_b_.isinstance(b, _b_.int)) {
             throw _b_.TypeError.$factory("an integer is required")
         }
         if (b > 255) {
-            throw ValueError.$factory("byte must be in range(0, 256)")
+            throw _b_.ValueError.$factory("byte must be in range(0, 256)")
         }
         self.source[self.source.length] = b
     }
     bytearray.extend = function(self, b) {
         if (self.in_iteration) {
             throw _b_.BufferError.$factory("Existing exports of data: object " +
                 "cannot be re-sized")
@@ -18363,15 +20222,15 @@
                 "insert takes exactly 2 arguments (" + (arguments.length - 1) +
                 " given)")
         }
         if (!_b_.isinstance(b, _b_.int)) {
             throw _b_.TypeError.$factory("an integer is required")
         }
         if (b > 255) {
-            throw ValueError.$factory("byte must be in range(0, 256)")
+            throw _b_.ValueError.$factory("byte must be in range(0, 256)")
         }
         _b_.list.insert(self.source, pos, b)
     }
     bytearray.$factory = function() {
         var args = [bytearray]
         for (var i = 0, len = arguments.length; i < len; i++) {
             args.push(arguments[i])
@@ -18818,25 +20677,50 @@
                     "in fromhex() arg")
             }
             source.push(_b_.int.$factory(string.substr(i, 2), 16))
         }
         return $.cls.$factory(source)
     }
     bytes.hex = function() {
-        var $ = $B.args('hex', 1, {
-                self: null
-            }, ['self'], arguments, {}, null, null),
+        var $ = $B.args('hex', 3, {
+                self: null,
+                sep: null,
+                bytes_per_sep: null
+            }, ['self', 'sep', 'bytes_per_sep'], arguments, {
+                sep: "",
+                bytes_per_sep: 1
+            }, null, null),
             self = $.self,
-            res = ""
-        for (var i = 0, len = self.source.length; i < len; i++) {
-            var hexa = self.source[i].toString(16)
-            if (hexa.length < 2) {
-                hexa = "0" + hexa
-            }
-            res += hexa
+            sep = $.sep,
+            bytes_per_sep = $.bytes_per_sep,
+            res = "",
+            digits = "0123456789abcdef",
+            bps = bytes_per_sep,
+            jstart = bps,
+            len = self.source.length;
+        if (bytes_per_sep < 0) {
+            bps = -bytes_per_sep;
+            jstart = bps
+        } else if (bytes_per_sep == 0) {
+            sep = ''
+        } else {
+            jstart = len % bps
+            if (jstart == 0) {
+                jstart = bps
+            }
+        }
+        for (var i = 0, j = jstart; i < len; i++) {
+            var c = self.source[i]
+            if (j == 0) {
+                res += sep
+                j = bps
+            }
+            j--
+            res += digits[c >> 4]
+            res += digits[c & 0x0f]
         }
         return res
     }
     bytes.index = function() {
         var $ = $B.args('rfind', 4, {
             self: null,
             sub: null,
@@ -19919,15 +21803,20 @@
                 throw err
             }
         }
         return $N
     }
     var set_iterator = $B.make_iterator_class("set iterator")
     set.__iter__ = function(self) {
-        self.$items.sort()
+        self.$items.sort(function(x, y) {
+            var hx = _b_.hash(x),
+                hy = _b_.hash(y)
+            return hx == hy ? 0 :
+                hx < hy ? -1 : 1
+        })
         return set_iterator.$factory(self.$items)
     }
     set.__le__ = function(self, other) {
         if (_b_.isinstance(other, [set, frozenset])) {
             var cfunc = _b_.getattr(other, "__contains__")
             for (var i = 0, len = self.$items.length; i < len; i++) {
                 if (!cfunc(self.$items[i])) {
@@ -20586,25 +22475,27 @@
             case 'boolean':
                 return value ? "true" : "false"
             case 'object':
                 if (value === _b_.None) {
                     return 'null'
                 } else if (value instanceof Number) {
                     return value.valueOf()
+                } else if (value instanceof String) {
+                    return value.valueOf()
                 }
             default:
                 console.log("erreur", value)
                 throw _b_.TypeError.$factory("keys must be str, int, " +
                     "float, bool or None, not " + $B.class_name(value))
         }
     }
     $B.pyobj2structuredclone = function(obj, strict) {
         strict = strict === undefined ? true : strict
         if (typeof obj == "boolean" || typeof obj == "number" ||
-            typeof obj == "string") {
+            typeof obj == "string" || obj instanceof String) {
             return obj
         } else if (obj instanceof Number) {
             return obj.valueOf()
         } else if (obj === _b_.None) {
             return null
         } else if (Array.isArray(obj) || obj.__class__ === _b_.list ||
             obj.__class__ === _b_.tuple) {
@@ -20635,15 +22526,15 @@
         if (obj === null) {
             return _b_.None
         } else if (obj === undefined) {
             return $B.Undefined
         } else if (typeof obj == "boolean" || typeof obj == "number" ||
             typeof obj == "string") {
             return obj
-        } else if (obj instanceof Number) {
+        } else if (obj instanceof Number || obj instanceof String) {
             return obj.valueOf()
         } else if (Array.isArray(obj) || obj.__class__ === _b_.list ||
             obj.__class__ === _b_.tuple) {
             var res = _b_.list.$factory()
             for (var i = 0, len = obj.length; i < len; i++) {
                 res.push($B.structuredclone2pyobj(obj[i]))
             }
@@ -20710,22 +22601,22 @@
         if (jsobj === undefined) {
             return $B.Undefined
         } else if (jsobj === null) {
             return _b_.None
         }
         if (Array.isArray(jsobj)) {
             return _b_.list.$factory(jsobj.map(jsobj2pyobj))
-        }
-        if (typeof jsobj === 'number') {
+        } else if (typeof jsobj === 'number') {
             if (jsobj.toString().indexOf('.') == -1) {
                 return _b_.int.$factory(jsobj)
             }
             return _b_.float.$factory(jsobj)
-        }
-        if (typeof jsobj == "function") {
+        } else if (typeof jsobj == "string") {
+            return $B.String(jsobj)
+        } else if (typeof jsobj == "function") {
             return function() {
                 var args = []
                 for (var i = 0, len = arguments.length; i < len; i++) {
                     args.push(pyobj2jsobj(arguments[i]))
                 }
                 return jsobj2pyobj(jsobj.apply(null, args))
             }
@@ -20772,15 +22663,15 @@
             items.forEach(function(item) {
                 if (typeof item[1] == 'function') {
                     item[1].bind(jsobj)
                 }
                 jsobj[item[0]] = pyobj2jsobj(item[1])
             })
             return jsobj
-        } else if (klass === _b_.float) {
+        } else if (klass === _b_.float || klass === _b_.str) {
             return pyobj.valueOf()
         } else if (klass === $B.Function || klass === $B.method) {
             if (pyobj.prototype &&
                 pyobj.prototype.constructor === pyobj &&
                 !pyobj.$is_func) {
                 return pyobj
             }
@@ -20861,14 +22752,17 @@
     for (var op in ops) {
         eval('$B.JSObj.' + ops[op] + ' = ' +
             ($B.JSObj.__sub__ + '').replace(/-/g, op))
     }
     $B.JSObj.__eq__ = function(self, other) {
         switch (typeof self) {
             case "object":
+                if (self.__eq__ !== undefined) {
+                    return self.__eq__(other)
+                }
                 if (Object.keys(self).length !== Object.keys(other).length) {
                     return false
                 }
                 for (var key in self) {
                     if (!$B.JSObj.__eq__(self[key], other[key])) {
                         return false
                     }
@@ -20881,30 +22775,27 @@
         return !$B.JSObj.__eq__(self, other)
     }
     $B.JSObj.__getattribute__ = function(self, attr) {
         var test = false
         if (test) {
             console.log("__ga__", self, attr)
         }
-        if (attr == "$$new" && typeof self == "function") {
+        if (attr == "new" && typeof self == "function") {
             if (self.$js_func) {
                 return function() {
                     var args = pyargs2jsargs(arguments)
                     return $B.JSObj.$factory(new self.$js_func(...args))
                 }
             } else {
                 return function() {
                     var args = pyargs2jsargs(arguments)
                     return $B.JSObj.$factory(new self(...args))
                 }
             }
         }
-        if (typeof attr == "string") {
-            attr = $B.from_alias(attr)
-        }
         var js_attr = self[attr]
         if (js_attr == undefined && typeof self == "function" && self.$js_func) {
             js_attr = self.$js_func[attr]
         }
         if (js_attr === undefined) {
             if (typeof self.getNamedItem == 'function') {
                 var res = self.getNamedItem(attr)
@@ -20964,17 +22855,14 @@
             }
             return $B.JSObj.$factory(res)
         } else {
             return $B.JSObj.$factory(js_attr)
         }
     }
     $B.JSObj.__setattr__ = function(self, attr, value) {
-        if (typeof attr == "string") {
-            attr = $B.from_alias(attr)
-        }
         self[attr] = $B.pyobj2structuredclone(value)
         return _b_.None
     }
     $B.JSObj.__getitem__ = function(self, key) {
         if (typeof key == "string") {
             return $B.JSObj.__getattribute__(self, key)
         } else if (typeof key == "number") {
@@ -21100,20 +22988,20 @@
 __BRYTHON__.stdlib = {}
 
 ;
 (function($B) {
     var _b_ = $B.builtins,
         _window = self
     var Module = $B.module = $B.make_class("module", function(name, doc, $package) {
-        return {
-            __class__: Module,
-            __name__: name,
-            __doc__: doc || _b_.None,
-            __package__: $package || _b_.None
-        }
+        var obj = Object.create(null)
+        obj.__class__ = Module
+        obj.__name__ = name
+        obj.__doc__ = doc || _b_.None
+        obj.__package__ = $package || _b_.None
+        return obj
     })
     Module.__new__ = function(cls, name, doc, $package) {
         return {
             __class__: cls,
             __name__: name,
             __doc__: doc || _b_.None,
             __package__: $package || _b_.None
@@ -21212,16 +23100,16 @@
             throw _b_.ImportError.$factory("name '$module' not defined in module")
         }
         $module.__name__ = _module.__name__
         for (var attr in $module) {
             if (typeof $module[attr] == "function") {
                 $module[attr].$infos = {
                     __module__: _module.__name__,
-                    __name__: $B.from_alias(attr),
-                    __qualname__: $B.from_alias(attr)
+                    __name__: attr,
+                    __qualname__: attr
                 }
                 $module[attr].$in_js_module = true
             }
         }
         if (_module !== undefined) {
             for (var attr in $module) {
                 _module[attr] = $module[attr]
@@ -21476,14 +23364,15 @@
             return $module
         } else {
             var mod_name = modobj.__name__
             if ($B.debug > 1) {
                 console.log("run Python code from VFS", mod_name)
             }
             var record = run_py(module_contents, modobj.__path__, modobj)
+            record.imports = imports.join(',')
             record.is_package = modobj.$is_package
             record.timestamp = $B.timestamp
             record.source_ts = timestamp
             $B.precompiled[mod_name] = record.is_package ? [record.content] :
                 record.content
             var elts = mod_name.split(".")
             if (elts.length > 1) {
@@ -21704,20 +23593,21 @@
         }
     })
     PathEntryFinder.find_spec = function(self, fullname) {
         var loader_data = {},
             notfound = true,
             hint = self.hint,
             base_path = self.path_entry + fullname.match(/[^.]+$/g)[0],
-            modpaths = []
+            modpaths = [],
+            py_ext = $B.$options.python_extension
         var tryall = hint === undefined
         if (tryall || hint == 'py') {
             modpaths = modpaths.concat([
-                [base_path + ".py", "py", false],
-                [base_path + "/__init__.py", "py", true]
+                [base_path + py_ext, "py", false],
+                [base_path + "/__init__" + py_ext, "py", true]
             ])
         }
         for (var j = 0; notfound && j < modpaths.length; ++j) {
             try {
                 var file_info = modpaths[j],
                     module = {
                         __name__: fullname,
@@ -22006,15 +23896,15 @@
                 elt = norm_parts.pop()
                 if (elt === undefined) {
                     throw _b_.ImportError.$factory("Parent module '' not loaded, " +
                         "cannot perform relative import")
                 }
             } else {
                 prefix = false;
-                norm_parts.push(p.substr(0, 2) == "$$" ? p.substr(2) : p)
+                norm_parts.push(p)
             }
         }
         var mod_name = norm_parts.join(".")
         if ($B.$options.debug == 10) {
             console.log("$import " + mod_name)
             console.log("use VFS ? " + $B.use_VFS)
             console.log("use static stdlib paths ? " + $B.static_stdlib_import)
@@ -22031,15 +23921,15 @@
             $B.$getattr(__import__, "__call__"),
             modobj = importer(mod_name, globals, undefined, fromlist, 0)
         if (!fromlist || fromlist.length == 0) {
             var alias = aliases[mod_name]
             if (alias) {
                 locals[alias] = $B.imported[mod_name]
             } else {
-                locals[$B.to_alias(norm_parts[0])] = modobj
+                locals[norm_parts[0]] = modobj
             }
         } else {
             var __all__ = fromlist,
                 thunk = {}
             if (fromlist && fromlist[0] == "*") {
                 __all__ = $B.$getattr(modobj, "__all__", thunk);
                 if (__all__ !== thunk) {
@@ -22056,33 +23946,26 @@
                 for (var i = 0, l = __all__.length; i < l; ++i) {
                     var name = __all__[i]
                     var alias = aliases[name] || name
                     try {
                         locals[alias] = $B.$getattr(modobj, name)
                     } catch ($err1) {
                         try {
-                            var name1 = $B.from_alias(name)
-                            $B.$getattr(__import__, '__call__')(mod_name + '.' + name1, globals, undefined, [], 0)
-                            locals[alias] = $B.$getattr(modobj, name1)
+                            $B.$getattr(__import__, '__call__')(mod_name + '.' + name, globals, undefined, [], 0)
+                            locals[alias] = $B.$getattr(modobj, name)
                         } catch ($err3) {
                             if (mod_name === "__future__") {
                                 var frame = $B.last($B.frames_stack),
                                     line_info = frame[3].$line_info,
                                     line_elts = line_info.split(','),
                                     line_num = parseInt(line_elts[0])
                                 $B.$SyntaxError(frame[2], "future feature " + name + " is not defined", current_frame[3].src, undefined, line_num)
                             }
                             if ($err3.$py_error) {
-                                var errname = $err3.__class__.$infos.__name__
-                                if ($err3.__class__ !== _b_.ImportError &&
-                                    $err3.__class__ !== _b_.ModuleNotFoundError) {
-                                    $B.handle_error($err3)
-                                }
-                                throw _b_.ImportError.$factory(
-                                    "cannot import name '" + name + "'")
+                                throw $err3
                             }
                             if ($B.debug > 1) {
                                 console.log($err3)
                                 console.log($B.last($B.frames_stack))
                             }
                             throw _b_.ImportError.$factory(
                                 "cannot import name '" + name + "'")
@@ -22091,17 +23974,15 @@
                 }
             }
             return locals
         }
     }
     $B.import_all = function(locals, module) {
         for (var attr in module) {
-            if (attr.startsWith("$$")) {
-                locals[attr] = module[attr]
-            } else if ('_$'.indexOf(attr.charAt(0)) == -1) {
+            if ('_$'.indexOf(attr.charAt(0)) == -1) {
                 locals[attr] = module[attr]
             }
         }
     }
     $B.$path_hooks = [url_hook]
     $B.$meta_path = [VFSFinder, StdlibStaticFinder, PathFinder]
     $B.finders = {
@@ -22134,5288 +24015,15 @@
         UrlPathFinder: url_hook,
         optimize_import_for_path: optimize_import_for_path
     }
     _importlib_module.__repr__ = _importlib_module.__str__ = function() {
         return "<module '_importlib' (built-in)>"
     }
     $B.imported["_importlib"] = _importlib_module
-})(__BRYTHON__);;
-(function($B) {
-    var bltns = $B.InjectBuiltins()
-    eval(bltns)
-    var object = _b_.object
-
-    function $err(op, other) {
-        var msg = "unsupported operand type(s) for " + op +
-            ": 'float' and '" + $B.class_name(other) + "'"
-        throw _b_.TypeError.$factory(msg)
-    }
-
-    function float_value(obj) {
-        return obj.$brython_value !== undefined ? obj.$brython_value : obj
-    }
-    var float = {
-        __class__: _b_.type,
-        __dir__: object.__dir__,
-        $infos: {
-            __module__: "builtins",
-            __name__: "float"
-        },
-        $is_class: true,
-        $native: true,
-        $descriptors: {
-            "numerator": true,
-            "denominator": true,
-            "imag": true,
-            "real": true
-        }
-    }
-    float.numerator = function(self) {
-        return float_value(self)
-    }
-    float.denominator = function(self) {
-        return _b_.int.$factory(1)
-    }
-    float.imag = function(self) {
-        return _b_.int.$factory(0)
-    }
-    float.real = function(self) {
-        return float_value(self)
-    }
-    float.__float__ = function(self) {
-        return float_value(self)
-    }
-    $B.shift1_cache = {}
-    float.as_integer_ratio = function(self) {
-        self = float_value(self)
-        if (self.valueOf() == Number.POSITIVE_INFINITY ||
-            self.valueOf() == Number.NEGATIVE_INFINITY) {
-            throw _b_.OverflowError.$factory("Cannot pass infinity to " +
-                "float.as_integer_ratio.")
-        }
-        if (!Number.isFinite(self.valueOf())) {
-            throw _b_.ValueError.$factory("Cannot pass NaN to " +
-                "float.as_integer_ratio.")
-        }
-        var tmp = _b_.$frexp(self.valueOf()),
-            fp = tmp[0],
-            exponent = tmp[1]
-        for (var i = 0; i < 300; i++) {
-            if (fp == Math.floor(fp)) {
-                break
-            } else {
-                fp *= 2
-                exponent--
-            }
-        }
-        numerator = _b_.int.$factory(fp)
-        py_exponent = abs(exponent)
-        denominator = 1
-        var x
-        if ($B.shift1_cache[py_exponent] !== undefined) {
-            x = $B.shift1_cache[py_exponent]
-        } else {
-            x = $B.$getattr(1, "__lshift__")(py_exponent)
-            $B.shift1_cache[py_exponent] = x
-        }
-        py_exponent = x
-        if (exponent > 0) {
-            numerator = $B.rich_op("mul", numerator, py_exponent)
-        } else {
-            denominator = py_exponent
-        }
-        return $B.fast_tuple([_b_.int.$factory(numerator), _b_.int.$factory(denominator)])
-    }
-    float.__abs__ = function(self) {
-        return new Number(Math.abs(float_value(self)))
-    }
-    float.__bool__ = function(self) {
-        self = float_value(self)
-        return _b_.bool.$factory(self.valueOf())
-    }
-    float.__divmod__ = function(self, other) {
-        if (!_b_.isinstance(other, [int, float])) {
-            return _b_.NotImplemented
-        }
-        return $B.fast_tuple([float.__floordiv__(self, other), float.__mod__(self, other)])
-    }
-    float.__eq__ = function(self, other) {
-        self = float_value(self)
-        other = float_value(other)
-        if (isNaN(self) && isNaN(other)) {
-            return false
-        }
-        if (isinstance(other, _b_.int)) {
-            return self == other
-        }
-        if (isinstance(other, float)) {
-            return self.valueOf() == other.valueOf()
-        }
-        if (isinstance(other, _b_.complex)) {
-            if (other.$imag != 0) {
-                return false
-            }
-            return self == other.$real
-        }
-        return _b_.NotImplemented
-    }
-    float.__floordiv__ = function(self, other) {
-        self = float_value(self)
-        other = float_value(other)
-        if (isinstance(other, [_b_.int, float])) {
-            if (other.valueOf() == 0) {
-                throw ZeroDivisionError.$factory('division by zero')
-            }
-            return float.$factory(Math.floor(self / other))
-        }
-        return _b_.NotImplemented
-    }
-    float.fromhex = function(arg) {
-        if (!isinstance(arg, _b_.str)) {
-            throw _b_.ValueError.$factory("argument must be a string")
-        }
-        var value = arg.trim()
-        switch (value.toLowerCase()) {
-            case "+inf":
-            case "inf":
-            case "+infinity":
-            case "infinity":
-                return $FloatClass(Infinity)
-            case "-inf":
-            case "-infinity":
-                return $FloatClass(-Infinity)
-            case "+nan":
-            case "nan":
-                return $FloatClass(Number.NaN)
-            case "-nan":
-                return $FloatClass(-Number.NaN)
-            case "":
-                throw _b_.ValueError.$factory("could not convert string to float")
-        }
-        var mo = /^(\d*)(\.?)(\d*)$/.exec(value)
-        if (mo !== null) {
-            var res = parseFloat(mo[1]),
-                coef = 16
-            if (mo[2]) {
-                for (var digit of mo[3]) {
-                    res += parseInt(digit, 16) / coef
-                    coef *= 16
-                }
-            }
-            return $FloatClass(res)
-        }
-        var _m = /^(\+|-)?(0x)?([0-9A-F]+\.?)?(\.[0-9A-F]+)?(p(\+|-)?\d+)?$/i.exec(value)
-        if (_m == null) {
-            throw _b_.ValueError.$factory("invalid hexadecimal floating-point string")
-        }
-        var _sign = _m[1],
-            _int = parseInt(_m[3] || '0', 16),
-            _fraction = _m[4] || '.0',
-            _exponent = _m[5] || 'p0'
-        if (_sign == "-") {
-            _sign = -1
-        } else {
-            _sign = 1
-        }
-        var _sum = _int
-        for (var i = 1, len = _fraction.length; i < len; i++) {
-            _sum += parseInt(_fraction.charAt(i), 16) / Math.pow(16, i)
-        }
-        return new Number(_sign * _sum * Math.pow(2, parseInt(_exponent.substring(1))))
-    }
-    float.__getformat__ = function(arg) {
-        if (arg == "double" || arg == "float") {
-            return "IEEE, little-endian"
-        }
-        throw _b_.ValueError.$factory("__getformat__() argument 1 must be " +
-            "'double' or 'float'")
-    }
-
-    function preformat(self, fmt) {
-        if (fmt.empty) {
-            return _b_.str.$factory(self)
-        }
-        if (fmt.type && 'eEfFgGn%'.indexOf(fmt.type) == -1) {
-            throw _b_.ValueError.$factory("Unknown format code '" + fmt.type +
-                "' for object of type 'float'")
-        }
-        if (isNaN(self)) {
-            if (fmt.type == "f" || fmt.type == "g") {
-                return "nan"
-            } else {
-                return "NAN"
-            }
-        }
-        if (self == Number.POSITIVE_INFINITY) {
-            if (fmt.type == "f" || fmt.type == "g") {
-                return "inf"
-            } else {
-                return "INF"
-            }
-        }
-        if (fmt.precision === undefined && fmt.type !== undefined) {
-            fmt.precision = 6
-        }
-        if (fmt.type == "%") {
-            self *= 100
-        }
-        if (fmt.type == "e") {
-            var res = self.toExponential(fmt.precision),
-                exp = parseInt(res.substr(res.search("e") + 1))
-            if (Math.abs(exp) < 10) {
-                res = res.substr(0, res.length - 1) + "0" +
-                    res.charAt(res.length - 1)
-            }
-            return res
-        }
-        if (fmt.precision !== undefined) {
-            var prec = fmt.precision
-            if (prec == 0) {
-                return Math.round(self) + ""
-            }
-            var res = self.toFixed(prec),
-                pt_pos = res.indexOf(".")
-            if (fmt.type !== undefined &&
-                (fmt.type == "%" || fmt.type.toLowerCase() == "f")) {
-                if (pt_pos == -1) {
-                    res += "." + "0".repeat(fmt.precision)
-                } else {
-                    var missing = fmt.precision - res.length + pt_pos + 1
-                    if (missing > 0) {
-                        res += "0".repeat(missing)
-                    }
-                }
-            } else if (fmt.type && fmt.type.toLowerCase() == "g") {
-                var exp_fmt = preformat(self, {
-                        type: "e"
-                    }).split("e"),
-                    exp = parseInt(exp_fmt[1])
-                if (-4 <= exp && exp < fmt.precision) {
-                    res = preformat(self, {
-                        type: "f",
-                        precision: fmt.precision - 1 - exp
-                    })
-                } else {
-                    res = preformat(self, {
-                        type: "e",
-                        precision: fmt.precision - 1
-                    })
-                }
-                var parts = res.split("e")
-                if (fmt.alternate) {
-                    if (parts[0].search(/\./) == -1) {
-                        parts[0] += '.'
-                    }
-                } else {
-                    if (parts[1]) {
-                        var signif = parts[0]
-                        while (signif.endsWith("0")) {
-                            signif = signif.substr(0, signif.length - 1)
-                        }
-                        if (signif.endsWith(".")) {
-                            signif = signif.substr(0, signif.length - 1)
-                        }
-                        parts[0] = signif
-                    }
-                }
-                res = parts.join("e")
-                if (fmt.type == "G") {
-                    res = res.toUpperCase()
-                }
-                return res
-            } else if (fmt.type === undefined) {
-                fmt.type = "g"
-                res = preformat(self, fmt)
-                fmt.type = undefined
-            } else {
-                var res1 = self.toExponential(fmt.precision - 1),
-                    exp = parseInt(res1.substr(res1.search("e") + 1))
-                if (exp < -4 || exp >= fmt.precision - 1) {
-                    var elts = res1.split("e")
-                    while (elts[0].endsWith("0")) {
-                        elts[0] = elts[0].substr(0, elts[0].length - 1)
-                    }
-                    res = elts.join("e")
-                }
-            }
-        } else {
-            var res = _b_.str.$factory(self)
-        }
-        if (fmt.type === undefined || "gGn".indexOf(fmt.type) != -1) {
-            if (res.search("e") == -1) {
-                while (res.charAt(res.length - 1) == "0") {
-                    res = res.substr(0, res.length - 1)
-                }
-            }
-            if (res.charAt(res.length - 1) == ".") {
-                if (fmt.type === undefined) {
-                    res += "0"
-                } else {
-                    res = res.substr(0, res.length - 1)
-                }
-            }
-        }
-        if (fmt.sign !== undefined) {
-            if ((fmt.sign == " " || fmt.sign == "+") && self > 0) {
-                res = fmt.sign + res
-            }
-        }
-        if (fmt.type == "%") {
-            res += "%"
-        }
-        return res
-    }
-    float.__format__ = function(self, format_spec) {
-        self = float_value(self)
-        var fmt = new $B.parse_format_spec(format_spec)
-        fmt.align = fmt.align || ">"
-        var raw = preformat(self, fmt).split('.'),
-            _int = raw[0]
-        if (fmt.comma) {
-            var len = _int.length,
-                nb = Math.ceil(_int.length / 3),
-                chunks = []
-            for (var i = 0; i < nb; i++) {
-                chunks.push(_int.substring(len - 3 * i - 3, len - 3 * i))
-            }
-            chunks.reverse()
-            raw[0] = chunks.join(",")
-        }
-        return $B.format_width(raw.join("."), fmt)
-    }
-    float.__hash__ = function(self) {
-        if (self === undefined) {
-            return float.__hashvalue__ || $B.$py_next_hash--
-        }
-        var _v = self.valueOf()
-        if (_v === Infinity) {
-            return 314159
-        }
-        if (_v === -Infinity) {
-            return -271828
-        }
-        if (isNaN(_v)) {
-            return 0
-        }
-        if (_v == Math.round(_v)) {
-            return Math.round(_v)
-        }
-        var r = _b_.$frexp(_v)
-        r[0] *= Math.pow(2, 31)
-        var hipart = _b_.int.$factory(r[0])
-        r[0] = (r[0] - hipart) * Math.pow(2, 31)
-        var x = hipart + _b_.int.$factory(r[0]) + (r[1] << 15)
-        return x & 0xFFFFFFFF
-    }
-    _b_.$isninf = function(x) {
-        var x1 = x
-        if (isinstance(x, float)) {
-            x1 = float.numerator(x)
-        }
-        return x1 == -Infinity || x1 == Number.NEGATIVE_INFINITY
-    }
-    _b_.$isinf = function(x) {
-        var x1 = x
-        if ((!x instanceof Number) && isinstance(x, float)) {
-            x1 = float.numerator(x)
-        }
-        return x1 == Infinity || x1 == -Infinity ||
-            x1 == Number.POSITIVE_INFINITY || x1 == Number.NEGATIVE_INFINITY
-    }
-    _b_.$isnan = function(x) {
-        var x1 = x
-        if (isinstance(x, float)) {
-            x1 = float.numerator(x)
-        }
-        return isNaN(x1)
-    }
-    _b_.$fabs = function(x) {
-        if (x == 0) {
-            return new Number(0)
-        }
-        return x > 0 ? float.$factory(x) : float.$factory(-x)
-    }
-    _b_.$frexp = function(x) {
-        var x1 = x
-        if (isinstance(x, float)) {
-            x1 = x.valueOf()
-        }
-        if (isNaN(x1) || _b_.$isinf(x1)) {
-            return [x1, -1]
-        } else if (x1 == 0) {
-            return [0, 0]
-        }
-        var sign = 1,
-            ex = 0,
-            man = x1
-        if (man < 0.) {
-            sign = -sign
-            man = -man
-        }
-        while (man < 0.5) {
-            man *= 2.0
-            ex--
-        }
-        while (man >= 1.0) {
-            man *= 0.5
-            ex++
-        }
-        man *= sign
-        return [man, ex]
-    }
-    _b_.$ldexp = function(x, i) {
-        if (_b_.$isninf(x)) {
-            return float.$factory('-inf')
-        }
-        if (_b_.$isinf(x)) {
-            return float.$factory('inf')
-        }
-        var y = x
-        if (isinstance(x, float)) {
-            y = x.valueOf()
-        }
-        if (y == 0) {
-            return y
-        }
-        var j = i
-        if (isinstance(i, float)) {
-            j = i.valueOf()
-        }
-        return y * Math.pow(2, j)
-    }
-    float.hex = function(self) {
-        self = float_value(self)
-        var DBL_MANT_DIG = 53,
-            TOHEX_NBITS = DBL_MANT_DIG + 3 - (DBL_MANT_DIG + 2) % 4
-        switch (self.valueOf()) {
-            case Infinity:
-            case -Infinity:
-            case Number.NaN:
-            case -Number.NaN:
-                return self
-            case -0:
-                return "-0x0.0p0"
-            case 0:
-                return "0x0.0p0"
-        }
-        var _a = _b_.$frexp(_b_.$fabs(self.valueOf())),
-            _m = _a[0],
-            _e = _a[1],
-            _shift = 1 - Math.max(-1021 - _e, 0)
-        _m = _b_.$ldexp(_m, _shift)
-        _e -= _shift
-        var _int2hex = "0123456789ABCDEF".split(""),
-            _s = _int2hex[Math.floor(_m)]
-        _s += '.'
-        _m -= Math.floor(_m)
-        for (var i = 0; i < (TOHEX_NBITS - 1) / 4; i++) {
-            _m *= 16.0
-            _s += _int2hex[Math.floor(_m)]
-            _m -= Math.floor(_m)
-        }
-        var _esign = "+"
-        if (_e < 0) {
-            _esign = "-"
-            _e = -_e
-        }
-        if (self.value < 0) {
-            return "-0x" + _s + "p" + _esign + _e
-        }
-        return "0x" + _s + "p" + _esign + _e
-    }
-    float.__init__ = function(self, value) {
-        return _b_.None
-    }
-    float.__int__ = function(self) {
-        return parseInt(self)
-    }
-    float.is_integer = function(self) {
-        return _b_.int.$factory(self) == self
-    }
-    float.__mod__ = function(self, other) {
-        self = float_value(self)
-        other = float_value(other)
-        if (other == 0) {
-            throw ZeroDivisionError.$factory("float modulo")
-        }
-        if (isinstance(other, _b_.int)) {
-            other = _b_.int.numerator(other)
-            return new Number((self % other + other) % other)
-        }
-        if (isinstance(other, float)) {
-            var q = Math.floor(self / other),
-                r = self - other * q
-            return new Number(r)
-        }
-        return _b_.NotImplemented
-    }
-    float.__mro__ = [object]
-    float.__mul__ = function(self, other) {
-        self = float_value(self)
-        other = float_value(other)
-        if (isinstance(other, _b_.int)) {
-            if (other.__class__ == $B.long_int) {
-                return new Number(self * parseFloat(other.value))
-            }
-            other = _b_.int.numerator(other)
-            return new Number(self * other)
-        }
-        if (isinstance(other, float)) {
-            return new Number(self * float_value(other))
-        }
-        return _b_.NotImplemented
-    }
-    float.__ne__ = function(self, other) {
-        var res = float.__eq__(self, other)
-        return res === _b_.NotImplemented ? res : !res
-    }
-    float.__neg__ = function(self) {
-        return new Number(-float_value(self))
-    }
-    float.__new__ = function(cls, value) {
-        if (cls === undefined) {
-            throw _b_.TypeError.$factory("float.__new__(): not enough arguments")
-        } else if (!_b_.isinstance(cls, _b_.type)) {
-            throw _b_.TypeError.$factory("float.__new__(X): X is not a type object")
-        }
-        if (cls === float) {
-            return float.$factory(value)
-        }
-        return {
-            __class__: cls,
-            __dict__: $B.empty_dict(),
-            $brython_value: value || 0
-        }
-    }
-    float.__pos__ = function(self) {
-        return float_value(self)
-    }
-    float.__pow__ = function(self, other) {
-        self = float_value(self)
-        other = float_value(other)
-        var other_int = isinstance(other, _b_.int)
-        if (other_int || isinstance(other, float)) {
-            if (self == 1) {
-                return self
-            }
-            if (other == 0) {
-                return new Number(1)
-            }
-            if (self == -1 &&
-                (!isFinite(other) || other.__class__ === $B.long_int ||
-                    !$B.is_safe_int(other)) &&
-                !isNaN(other)) {
-                return new Number(1)
-            } else if (self == 0 && isFinite(other) && other < 0) {
-                throw _b_.ZeroDivisionError.$factory("0.0 cannot be raised " +
-                    "to a negative power")
-            } else if (self == Number.NEGATIVE_INFINITY && !isNaN(other)) {
-                if (other < 0 && other % 2 == 1) {
-                    return new Number(-0.0)
-                } else if (other < 0) {
-                    return new Number(0)
-                } else if (other > 0 && other % 2 == 1) {
-                    return Number.NEGATIVE_INFINITY
-                } else {
-                    return Number.POSITIVE_INFINITY
-                }
-            } else if (self == Number.POSITIVE_INFINITY && !isNaN(other)) {
-                return other > 0 ? self : new Number(0)
-            }
-            if (other == Number.NEGATIVE_INFINITY && !isNaN(self)) {
-                return Math.abs(self) < 1 ? Number.POSITIVE_INFINITY :
-                    new Number(0)
-            } else if (other == Number.POSITIVE_INFINITY && !isNaN(self)) {
-                return Math.abs(self) < 1 ? new Number(0) :
-                    Number.POSITIVE_INFINITY
-            }
-            if (self < 0 &&
-                !_b_.getattr(other, "__eq__")(_b_.int.$factory(other))) {
-                return _b_.complex.__pow__($B.make_complex(self, 0), other)
-            }
-            return float.$factory(Math.pow(self, other))
-        }
-        return _b_.NotImplemented
-    }
-
-    function __newobj__() {
-        var $ = $B.args('__newobj__', 0, {}, [], arguments, {}, 'args', null),
-            args = $.args
-        var res = args.slice(1)
-        res.__class__ = args[0]
-        return res
-    }
-    float.__reduce_ex__ = function(self) {
-        return $B.fast_tuple([__newobj__, $B.fast_tuple([self.__class__ || int, float_value(self)]), _b_.None, _b_.None, _b_.None])
-    }
-    float.__repr__ = function(self) {
-        $B.builtins_repr_check(float, arguments)
-        self = float_value(self).valueOf()
-        if (self == Infinity) {
-            return 'inf'
-        } else if (self == -Infinity) {
-            return '-inf'
-        } else if (isNaN(self)) {
-            return 'nan'
-        } else if (self === 0) {
-            if (1 / self === -Infinity) {
-                return '-0.0'
-            }
-            return '0.0'
-        }
-        var res = self + ""
-        if (res.indexOf(".") == -1) {
-            res += ".0"
-        }
-        var split_e = res.split(/e/i)
-        if (split_e.length == 2) {
-            var mant = split_e[0],
-                exp = split_e[1]
-            if (exp.startsWith('-')) {
-                exp_str = parseInt(exp.substr(1)) + ''
-                if (exp_str.length < 2) {
-                    exp_str = '0' + exp_str
-                }
-                return mant + 'e-' + exp_str
-            }
-        }
-        var x, y[x, y] = res.split('.')
-        if (x.length > 16) {
-            var exp = x.length - 1,
-                int_part = x[0],
-                dec_part = x.substr(1) + y
-            while (dec_part.endsWith("0")) {
-                dec_part = dec_part.substr(0, dec_part.length - 1)
-            }
-            var mant = int_part
-            if (dec_part.length > 0) {
-                mant += '.' + dec_part
-            }
-            return mant + 'e+' + exp
-        } else if (x == "0") {
-            var exp = 0
-            while (exp < y.length && y.charAt(exp) == "0") {
-                exp++
-            }
-            if (exp > 3) {
-                var rest = y.substr(exp),
-                    exp = (exp + 1).toString()
-                while (rest.endsWith("0")) {
-                    rest = rest.substr(0, res.length - 1)
-                }
-                var mant = rest[0]
-                if (rest.length > 1) {
-                    mant += '.' + rest.substr(1)
-                }
-                if (exp.length == 1) {
-                    exp = '0' + exp
-                }
-                return mant + 'e-' + exp
-            }
-        }
-        return _b_.str.$factory(res)
-    }
-    float.__setattr__ = function(self, attr, value) {
-        if (self.constructor === Number) {
-            if (float[attr] === undefined) {
-                throw _b_.AttributeError.$factory("'float' object has no attribute '" +
-                    attr + "'")
-            } else {
-                throw _b_.AttributeError.$factory("'float' object attribute '" +
-                    attr + "' is read-only")
-            }
-        }
-        self[attr] = value
-        return _b_.None
-    }
-    float.__truediv__ = function(self, other) {
-        self = float_value(self)
-        other = float_value(other)
-        if (isinstance(other, [_b_.int, float])) {
-            if (other.valueOf() == 0) {
-                throw ZeroDivisionError.$factory("division by zero")
-            }
-            return float.$factory(self / other)
-        }
-        return _b_.NotImplemented
-    }
-    var $op_func = function(self, other) {
-        self = float_value(self)
-        other = float_value(other)
-        if (isinstance(other, _b_.int)) {
-            if (typeof other == "boolean") {
-                return other ? self - 1 : self
-            } else if (other.__class__ === $B.long_int) {
-                return float.$factory(self - parseInt(other.value))
-            } else {
-                return float.$factory(self - other)
-            }
-        }
-        if (isinstance(other, float)) {
-            return float.$factory(self - other)
-        }
-        return _b_.NotImplemented
-    }
-    $op_func += ""
-    var $ops = {
-        "+": "add",
-        "-": "sub"
-    }
-    for (var $op in $ops) {
-        var $opf = $op_func.replace(/-/gm, $op)
-        $opf = $opf.replace(/__rsub__/gm, "__r" + $ops[$op] + "__")
-        eval("float.__" + $ops[$op] + "__ = " + $opf)
-    }
-    var $comp_func = function(self, other) {
-        self = float_value(self)
-        other = float_value(other)
-        if (isinstance(other, _b_.int)) {
-            if (other.__class__ === $B.long_int) {
-                return self > parseInt(other.value)
-            }
-            return self > other.valueOf()
-        }
-        if (isinstance(other, float)) {
-            return self > other
-        }
-        if (isinstance(other, _b_.bool)) {
-            return self.valueOf() > _b_.bool.__hash__(other)
-        }
-        if (hasattr(other, "__int__") || hasattr(other, "__index__")) {
-            return _b_.int.__gt__(self, $B.$GetInt(other))
-        }
-        var inv_op = getattr(other, "__le__", None)
-        if (inv_op !== None) {
-            return inv_op(self)
-        }
-        throw _b_.TypeError.$factory(
-            "unorderable types: float() > " + $B.class_name(other) + "()")
-    }
-    $comp_func += ""
-    for (var $op in $B.$comps) {
-        eval("float.__" + $B.$comps[$op] + "__ = " +
-            $comp_func.replace(/>/gm, $op).replace(/__gt__/gm, "__" + $B.$comps[$op] + "__").replace(/__le__/, "__" + $B.$inv_comps[$op] + "__"))
-    }
-    var r_opnames = ["add", "sub", "mul", "truediv", "floordiv", "mod", "pow", "lshift", "rshift", "and", "xor", "or", "divmod"]
-    for (var r_opname of r_opnames) {
-        if (float["__r" + r_opname + "__"] === undefined &&
-            float['__' + r_opname + '__']) {
-            float["__r" + r_opname + "__"] = (function(name) {
-                return function(self, other) {
-                    if (_b_.isinstance(other, _b_.int)) {
-                        other = float_value(_b_.int.numerator(other))
-                        return float["__" + name + "__"](other, self)
-                    } else if (_b_.isinstance(other, float)) {
-                        other = float_value(other)
-                        return float["__" + name + "__"](other, self)
-                    }
-                    return _b_.NotImplemented
-                }
-            })(r_opname)
-        }
-    }
-
-    function $FloatClass(value) {
-        return new Number(value)
-    }
-
-    function to_digits(s) {
-        var arabic_digits = "\u0660\u0661\u0662\u0663\u0664\u0665\u0666\u0667\u0668\u0669",
-            res = ""
-        for (var i = 0; i < s.length; i++) {
-            var x = arabic_digits.indexOf(s[i])
-            if (x > -1) {
-                res += x
-            } else {
-                res += s[i]
-            }
-        }
-        return res
-    }
-    float.$factory = function(value) {
-        switch (value) {
-            case undefined:
-                return $FloatClass(0.0)
-            case Number.MAX_VALUE:
-                return $FloatClass(Infinity)
-            case -Number.MAX_VALUE:
-                return $FloatClass(-Infinity)
-            case true:
-                return new Number(1)
-            case false:
-                return new Number(0)
-        }
-        if (typeof value == "number") {
-            return new Number(value)
-        }
-        if (isinstance(value, float)) {
-            return float_value(value)
-        }
-        if (isinstance(value, bytes)) {
-            var s = getattr(value, "decode")("latin-1")
-            return float.$factory(getattr(value, "decode")("latin-1"))
-        }
-        if (typeof value == "string") {
-            value = value.trim()
-            switch (value.toLowerCase()) {
-                case "+inf":
-                case "inf":
-                case "+infinity":
-                case "infinity":
-                    return Number.POSITIVE_INFINITY
-                case "-inf":
-                case "-infinity":
-                    return Number.NEGATIVE_INFINITY
-                case "+nan":
-                case "nan":
-                    return Number.NaN
-                case "-nan":
-                    return -Number.NaN
-                case "":
-                    throw _b_.ValueError.$factory("count not convert string to float")
-                default:
-                    value = value.charAt(0) + value.substr(1).replace(/_/g, "")
-                    value = to_digits(value)
-                    if (isFinite(value)) return $FloatClass(eval(value))
-                    else {
-                        _b_.str.encode(value, "latin-1")
-                        throw _b_.ValueError.$factory(
-                            "Could not convert to float(): '" +
-                            _b_.str.$factory(value) + "'")
-                    }
-            }
-        }
-        var klass = value.__class__ || $B.get_class(value),
-            num_value = $B.to_num(value, ["__float__", "__index__"])
-        if (value !== Number.POSITIVE_INFINITY && !isFinite(num_value)) {
-            throw _b_.OverflowError.$factory('int too large to convert to float')
-        }
-        if (num_value !== null) {
-            return num_value
-        }
-        throw _b_.TypeError.$factory("float() argument must be a string or a " +
-            "number, not '" + $B.class_name(value) + "'")
-    }
-    $B.$FloatClass = $FloatClass
-    $B.set_func_names(float, "builtins")
-    var FloatSubclass = $B.FloatSubclass = {
-        __class__: _b_.type,
-        __mro__: [object],
-        $infos: {
-            __module__: "builtins",
-            __name__: "float"
-        },
-        $is_class: true
-    }
-    for (var $attr in float) {
-        if (typeof float[$attr] == "function") {
-            FloatSubclass[$attr] = (function(attr) {
-                return function() {
-                    var args = [],
-                        pos = 0
-                    if (arguments.length > 0) {
-                        var args = [arguments[0].valueOf()],
-                            pos = 1
-                        for (var i = 1, len = arguments.length; i < len; i++) {
-                            args[pos++] = arguments[i]
-                        }
-                    }
-                    return float[attr].apply(null, args)
-                }
-            })($attr)
-        }
-    }
-    $B.set_func_names(FloatSubclass, "builtins")
-    _b_.float = float
-})(__BRYTHON__);;
-(function($B) {
-    var _b_ = $B.builtins
-
-    function $err(op, other) {
-        var msg = "unsupported operand type(s) for " + op +
-            " : 'int' and '" + $B.class_name(other) + "'"
-        throw _b_.TypeError.$factory(msg)
-    }
-
-    function int_value(obj) {
-        if (typeof obj == "boolean") {
-            return obj ? 1 : 0
-        }
-        return obj.$brython_value !== undefined ? obj.$brython_value : obj
-    }
-    var int = {
-        __class__: _b_.type,
-        __dir__: _b_.object.__dir__,
-        __mro__: [_b_.object],
-        $infos: {
-            __module__: "builtins",
-            __name__: "int"
-        },
-        $is_class: true,
-        $native: true,
-        $descriptors: {
-            "numerator": true,
-            "denominator": true,
-            "imag": true,
-            "real": true
-        }
-    }
-    int.as_integer_ratio = function() {
-        var $ = $B.args("as_integer_ratio", 1, {
-            self: null
-        }, ["self"], arguments, {}, null, null)
-        return $B.$list([$.self, 1])
-    }
-    int.from_bytes = function() {
-        var $ = $B.args("from_bytes", 3, {
-            bytes: null,
-            byteorder: null,
-            signed: null
-        }, ["bytes", "byteorder", "signed"], arguments, {
-            signed: false
-        }, null, null)
-        var x = $.bytes,
-            byteorder = $.byteorder,
-            signed = $.signed,
-            _bytes, _len
-        if (_b_.isinstance(x, [_b_.bytes, _b_.bytearray])) {
-            _bytes = x.source
-            _len = x.source.length
-        } else {
-            _bytes = _b_.list.$factory(x)
-            _len = _bytes.length
-            for (var i = 0; i < _len; i++) {
-                _b_.bytes.$factory([_bytes[i]])
-            }
-        }
-        if (byteorder == "big") {
-            _bytes.reverse()
-        } else if (byteorder != "little") {
-            throw _b_.ValueError.$factory(
-                "byteorder must be either 'little' or 'big'")
-        }
-        var num = _bytes[0]
-        if (signed && num >= 128) {
-            num = num - 256
-        }
-        var _mult = 256
-        for (var i = 1; i < _len; i++) {
-            num = $B.add($B.mul(_mult, _bytes[i]), num)
-            _mult = $B.mul(_mult, 256)
-        }
-        if (!signed) {
-            return num
-        }
-        if (_bytes[_len - 1] < 128) {
-            return num
-        }
-        return $B.sub(num, _mult)
-    }
-    int.to_bytes = function() {
-        var $ = $B.args("to_bytes", 3, {
-                self: null,
-                len: null,
-                byteorder: null,
-                signed: null
-            }, ["self", "len", "byteorder", "*", "signed"], arguments, {
-                signed: false
-            }, null, null),
-            self = $.self,
-            len = $.len,
-            byteorder = $.byteorder,
-            signed = $.signed
-        if (!_b_.isinstance(len, _b_.int)) {
-            throw _b_.TypeError.$factory("integer argument expected, got " +
-                $B.class_name(len))
-        }
-        if (["little", "big"].indexOf(byteorder) == -1) {
-            throw _b_.ValueError.$factory(
-                "byteorder must be either 'little' or 'big'")
-        }
-        if (_b_.isinstance(self, $B.long_int)) {
-            return $B.long_int.to_bytes(self, len, byteorder, signed)
-        }
-        if (self < 0) {
-            if (!signed) {
-                throw _b_.OverflowError.$factory(
-                    "can't convert negative int to unsigned")
-            }
-            self = Math.pow(256, len) + self
-        }
-        var res = [],
-            value = self
-        while (value > 0) {
-            var quotient = Math.floor(value / 256),
-                rest = value - 256 * quotient
-            res.push(rest)
-            if (res.length > len) {
-                throw _b_.OverflowError.$factory("int too big to convert")
-            }
-            value = quotient
-        }
-        while (res.length < len) {
-            res.push(0)
-        }
-        if (byteorder == "big") {
-            res.reverse()
-        }
-        return {
-            __class__: _b_.bytes,
-            source: res
-        }
-    }
-    int.__abs__ = function(self) {
-        return _b_.abs(self)
-    }
-    int.__add__ = function(self, other) {
-        self = int_value(self)
-        if (_b_.isinstance(other, int)) {
-            if (other.__class__ == $B.long_int) {
-                return $B.long_int.__add__($B.long_int.$factory(self), $B.long_int.$factory(other))
-            }
-            other = int_value(other)
-            var res = self + other
-            if (res > $B.min_int && res < $B.max_int) {
-                return res
-            } else {
-                return $B.long_int.__add__($B.long_int.$factory(self), $B.long_int.$factory(other))
-            }
-        }
-        return _b_.NotImplemented
-    }
-    int.__bool__ = function(self) {
-        return int_value(self).valueOf() == 0 ? false : true
-    }
-    int.__ceil__ = function(self) {
-        return Math.ceil(int_value(self))
-    }
-    int.__divmod__ = function(self, other) {
-        if (!_b_.isinstance(other, int)) {
-            return _b_.NotImplemented
-        }
-        return $B.fast_tuple([int.__floordiv__(self, other), int.__mod__(self, other)])
-    }
-    int.__eq__ = function(self, other) {
-        if (other === undefined) {
-            return self === int
-        }
-        if (_b_.isinstance(other, int)) {
-            return self.valueOf() == int_value(other).valueOf()
-        }
-        if (_b_.isinstance(other, _b_.float)) {
-            return self.valueOf() == other.valueOf()
-        }
-        if (_b_.isinstance(other, _b_.complex)) {
-            if (other.$imag != 0) {
-                return False
-            }
-            return self.valueOf() == other.$real
-        }
-        return _b_.NotImplemented
-    }
-    int.__float__ = function(self) {
-        return new Number(self)
-    }
-
-    function preformat(self, fmt) {
-        if (fmt.empty) {
-            return _b_.str.$factory(self)
-        }
-        if (fmt.type && 'bcdoxXn'.indexOf(fmt.type) == -1) {
-            throw _b_.ValueError.$factory("Unknown format code '" + fmt.type +
-                "' for object of type 'int'")
-        }
-        var res
-        switch (fmt.type) {
-            case undefined:
-            case "d":
-                res = self.toString()
-                break
-            case "b":
-                res = (fmt.alternate ? "0b" : "") + self.toString(2)
-                break
-            case "c":
-                res = _b_.chr(self)
-                break
-            case "o":
-                res = (fmt.alternate ? "0o" : "") + self.toString(8)
-                break
-            case "x":
-                res = (fmt.alternate ? "0x" : "") + self.toString(16)
-                break
-            case "X":
-                res = (fmt.alternate ? "0X" : "") + self.toString(16).toUpperCase()
-                break
-            case "n":
-                return self
-        }
-        if (fmt.sign !== undefined) {
-            if ((fmt.sign == " " || fmt.sign == "+") && self >= 0) {
-                res = fmt.sign + res
-            }
-        }
-        return res
-    }
-    int.__format__ = function(self, format_spec) {
-        var fmt = new $B.parse_format_spec(format_spec)
-        if (fmt.type && 'eEfFgG%'.indexOf(fmt.type) != -1) {
-            return _b_.float.__format__(self, format_spec)
-        }
-        fmt.align = fmt.align || ">"
-        var res = preformat(self, fmt)
-        if (fmt.comma) {
-            var sign = res[0] == "-" ? "-" : "",
-                rest = res.substr(sign.length),
-                len = rest.length,
-                nb = Math.ceil(rest.length / 3),
-                chunks = []
-            for (var i = 0; i < nb; i++) {
-                chunks.push(rest.substring(len - 3 * i - 3, len - 3 * i))
-            }
-            chunks.reverse()
-            res = sign + chunks.join(",")
-        }
-        return $B.format_width(res, fmt)
-    }
-    int.__floordiv__ = function(self, other) {
-        if (other.__class__ === $B.long_int) {
-            return $B.long_int.__floordiv__($B.long_int.$factory(self), other)
-        }
-        if (_b_.isinstance(other, int)) {
-            other = int_value(other)
-            if (other == 0) {
-                throw _b_.ZeroDivisionError.$factory("division by zero")
-            }
-            return Math.floor(self / other)
-        }
-        return _b_.NotImplemented
-    }
-    int.__hash__ = function(self) {
-        if (self.$brython_value) {
-            var hash_method = $B.$getattr(self.__class__, '__hash__')
-            if (hash_method === int.__hash__) {
-                if (typeof self.$brython_value == "number") {
-                    return self.$brython_value
-                } else {
-                    return $B.long_int.__hash__(self.$brython_value)
-                }
-            } else {
-                return hash_method(self)
-            }
-        }
-        return self.valueOf()
-    }
-    int.__index__ = function(self) {
-        return int_value(self)
-    }
-    int.__init__ = function(self, value) {
-        if (value === undefined) {
-            value = 0
-        }
-        self.toString = function() {
-            return value
-        }
-        return _b_.None
-    }
-    int.__int__ = function(self) {
-        return self
-    }
-    int.__invert__ = function(self) {
-        return ~self
-    }
-    int.__lshift__ = function(self, other) {
-        self = int_value(self)
-        if (_b_.isinstance(other, int)) {
-            other = int_value(other)
-            try {
-                return int.$factory($B.long_int.__lshift__($B.long_int.$factory(self), $B.long_int.$factory(other)))
-            } catch (err) {
-                console.log('err in lshift', self, other)
-                throw err
-            }
-        }
-        return _b_.NotImplemented
-    }
-    int.__mod__ = function(self, other) {
-        if (_b_.isinstance(other, _b_.tuple) && other.length == 1) {
-            other = other[0]
-        }
-        if (other.__class__ === $B.long_int) {
-            return $B.long_int.__mod__($B.long_int.$factory(self), other)
-        }
-        if (_b_.isinstance(other, int)) {
-            other = int_value(other)
-            if (other === false) {
-                other = 0
-            } else if (other === true) {
-                other = 1
-            }
-            if (other == 0) {
-                throw _b_.ZeroDivisionError.$factory(
-                    "integer division or modulo by zero")
-            }
-            return (self % other + other) % other
-        }
-        return _b_.NotImplemented
-    }
-    int.__mul__ = function(self, other) {
-        self = int_value(self)
-        if (_b_.isinstance(other, int)) {
-            if (other.__class__ == $B.long_int) {
-                return $B.long_int.__mul__($B.long_int.$factory(self), $B.long_int.$factory(other))
-            }
-            other = int_value(other)
-            var res = self * other
-            if (res > $B.min_int && res < $B.max_int) {
-                return res
-            } else {
-                return int.$factory($B.long_int.__mul__($B.long_int.$factory(self), $B.long_int.$factory(other)))
-            }
-        }
-        return _b_.NotImplemented
-    }
-    int.__ne__ = function(self, other) {
-        var res = int.__eq__(self, other)
-        return (res === _b_.NotImplemented) ? res : !res
-    }
-    int.__neg__ = function(self) {
-        return -self
-    }
-    int.__new__ = function(cls, value) {
-        if (cls === undefined) {
-            throw _b_.TypeError.$factory("int.__new__(): not enough arguments")
-        } else if (!_b_.isinstance(cls, _b_.type)) {
-            throw _b_.TypeError.$factory("int.__new__(X): X is not a type object")
-        }
-        if (cls === int) {
-            return int.$factory(value)
-        }
-        return {
-            __class__: cls,
-            __dict__: $B.empty_dict(),
-            $brython_value: value || 0
-        }
-    }
-    int.__pos__ = function(self) {
-        return self
-    }
-
-    function extended_euclidean(a, b) {
-        var d, u, v
-        if (b == 0) {
-            return [a, 1, 0]
-        } else {
-            [d, u, v] = extended_euclidean(b, a % b)
-            return [d, v, u - Math.floor(a / b) * v]
-        }
-    }
-    int.__pow__ = function(self, other, z) {
-        if (!_b_.isinstance(other, int)) {
-            return _b_.NotImplemented
-        }
-        if (typeof other == "number" || _b_.isinstance(other, int)) {
-            other = int_value(other)
-            switch (other.valueOf()) {
-                case 0:
-                    return int.$factory(1)
-                case 1:
-                    return int.$factory(self.valueOf())
-            }
-            if (z !== undefined && z !== _b_.None) {
-                if (z == 1) {
-                    return 0
-                }
-                var result = 1,
-                    base = self % z,
-                    exponent = other,
-                    long_int = $B.long_int
-                if (exponent < 0) {
-                    var gcd, inv, _[gcd, inv, _] = extended_euclidean(self, z)
-                    if (gcd !== 1) {
-                        throw _b_.ValueError.$factory("not relative primes: " +
-                            self + ' and ' + z)
-                    }
-                    return int.__pow__(inv, -exponent, z)
-                }
-                while (exponent > 0) {
-                    if (exponent % 2 == 1) {
-                        if (result * base > $B.max_int) {
-                            result = long_int.__mul__(
-                                long_int.$factory(result), long_int.$factory(base))
-                            result = long_int.__mod__(result, z)
-                        } else {
-                            result = (result * base) % z
-                        }
-                    }
-                    exponent = exponent >> 1
-                    if (base * base > $B.max_int) {
-                        base = long_int.__mul__(long_int.$factory(base), long_int.$factory(base))
-                        base = long_int.__mod__(base, z)
-                    } else {
-                        base = (base * base) % z
-                    }
-                }
-                return result
-            }
-            var res = Math.pow(self.valueOf(), other.valueOf())
-            if (res > $B.min_int && res < $B.max_int) {
-                return other > 0 ? res : new Number(res)
-            } else if (res !== Infinity && !isFinite(res)) {
-                return res
-            } else {
-                if ($B.BigInt) {
-                    return {
-                        __class__: $B.long_int,
-                        value: ($B.BigInt(self) ** $B.BigInt(other)).toString(),
-                        pos: true
-                    }
-                }
-                return $B.long_int.__pow__($B.long_int.$from_int(self), $B.long_int.$from_int(other))
-            }
-        }
-        if (_b_.isinstance(other, _b_.float)) {
-            other = _b_.float.numerator(other)
-            if (self >= 0) {
-                return new Number(Math.pow(self, other))
-            } else {
-                return _b_.complex.__pow__($B.make_complex(self, 0), other)
-            }
-        } else if (_b_.isinstance(other, _b_.complex)) {
-            var preal = Math.pow(self, other.$real),
-                ln = Math.log(self)
-            return $B.make_complex(preal * Math.cos(ln), preal * Math.sin(ln))
-        }
-        var rpow = $B.$getattr(other, "__rpow__", _b_.None)
-        if (rpow !== _b_.None) {
-            return rpow(self)
-        }
-        $err("**", other)
-    }
-
-    function __newobj__() {
-        var $ = $B.args('__newobj__', 0, {}, [], arguments, {}, 'args', null),
-            args = $.args
-        var res = args.slice(1)
-        res.__class__ = args[0]
-        return res
-    }
-    int.__reduce_ex__ = function(self) {
-        return $B.fast_tuple([__newobj__, $B.fast_tuple([self.__class__ || int, int_value(self)]), _b_.None, _b_.None, _b_.None])
-    }
-    int.__repr__ = function(self) {
-        $B.builtins_repr_check(int, arguments)
-        return int_value(self).toString()
-    }
-    int.__rshift__ = function(self, other) {
-        self = int_value(self)
-        if (typeof other == "number" || _b_.isinstance(other, int)) {
-            other = int_value(other)
-            return int.$factory($B.long_int.__rshift__($B.long_int.$factory(self), $B.long_int.$factory(other)))
-        }
-        return _b_.NotImplemented
-    }
-    int.__setattr__ = function(self, attr, value) {
-        if (typeof self == "number" || typeof self == "boolean") {
-            var cl_name = $B.class_name(self)
-            if (_b_.dir(self).indexOf(attr) > -1) {
-                var msg = "attribute '" + attr + `' of '${cl_name}'` +
-                    "objects is not writable"
-            } else {
-                var msg = `'${cl_name}' object has no attribute '${attr}'`
-            }
-            throw _b_.AttributeError.$factory(msg)
-        }
-        _b_.dict.$setitem(self.__dict__, attr, value)
-        return _b_.None
-    }
-    int.__sub__ = function(self, other) {
-        self = int_value(self)
-        if (_b_.isinstance(other, int)) {
-            if (other.__class__ == $B.long_int) {
-                return $B.long_int.__sub__($B.long_int.$factory(self), $B.long_int.$factory(other))
-            }
-            other = int_value(other)
-            var res = self - other
-            if (res > $B.min_int && res < $B.max_int) {
-                return res
-            } else {
-                return $B.long_int.__sub__($B.long_int.$factory(self), $B.long_int.$factory(other))
-            }
-        }
-        return _b_.NotImplemented
-    }
-    int.__truediv__ = function(self, other) {
-        if (_b_.isinstance(other, int)) {
-            other = int_value(other)
-            if (other == 0) {
-                throw _b_.ZeroDivisionError.$factory("division by zero")
-            }
-            if (other.__class__ === $B.long_int) {
-                return new Number(self / parseInt(other.value))
-            }
-            return new Number(self / other)
-        }
-        return _b_.NotImplemented
-    }
-    int.bit_length = function(self) {
-        s = _b_.bin(self)
-        s = $B.$getattr(s, "lstrip")("-0b")
-        return s.length
-    }
-    int.numerator = function(self) {
-        return int_value(self)
-    }
-    int.denominator = function(self) {
-        return int.$factory(1)
-    }
-    int.imag = function(self) {
-        return int.$factory(0)
-    }
-    int.real = function(self) {
-        return self
-    }
-    for (var attr of ['numerator', 'denominator', 'imag', 'real']) {
-        int[attr].setter = (function(x) {
-            return function(self, value) {
-                throw _b_.AttributeError.$factory(`attribute '${x}' of ` +
-                    `'${$B.class_name(self)}' objects is not writable`)
-            }
-        })(attr)
-    }
-    $B.max_int32 = (1 << 30) * 2 - 1
-    $B.min_int32 = -$B.max_int32
-    var $op_func = function(self, other) {
-        self = int_value(self)
-        if (typeof other == "number" || _b_.isinstance(other, int)) {
-            if (other.__class__ === $B.long_int) {
-                return $B.long_int.__sub__($B.long_int.$factory(self), $B.long_int.$factory(other))
-            }
-            other = int_value(other)
-            if (self > $B.max_int32 || self < $B.min_int32 ||
-                other > $B.max_int32 || other < $B.min_int32) {
-                return $B.long_int.__sub__($B.long_int.$factory(self), $B.long_int.$factory(other))
-            }
-            return self - other
-        }
-        return _b_.NotImplemented
-    }
-    $op_func += ""
-    var $ops = {
-        "&": "and",
-        "|": "or",
-        "^": "xor"
-    }
-    for (var $op in $ops) {
-        var opf = $op_func.replace(/-/gm, $op)
-        opf = opf.replace(new RegExp("sub", "gm"), $ops[$op])
-        eval("int.__" + $ops[$op] + "__ = " + opf)
-    }
-    var $comp_func = function(self, other) {
-        if (other.__class__ === $B.long_int) {
-            return $B.long_int.__lt__(other, $B.long_int.$factory(self))
-        }
-        if (_b_.isinstance(other, int)) {
-            other = int_value(other)
-            return self.valueOf() > other.valueOf()
-        } else if (_b_.isinstance(other, _b_.float)) {
-            return self.valueOf() > _b_.float.numerator(other)
-        } else if (_b_.isinstance(other, _b_.bool)) {
-            return self.valueOf() > _b_.bool.__hash__(other)
-        }
-        if (_b_.hasattr(other, "__int__") || _b_.hasattr(other, "__index__")) {
-            return int.__gt__(self, $B.$GetInt(other))
-        }
-        return _b_.NotImplemented
-    }
-    $comp_func += ""
-    for (var $op in $B.$comps) {
-        eval("int.__" + $B.$comps[$op] + "__ = " +
-            $comp_func.replace(/>/gm, $op).replace(/__gt__/gm, "__" + $B.$comps[$op] + "__").replace(/__lt__/, "__" + $B.$inv_comps[$op] + "__"))
-    }
-    var r_opnames = ["add", "sub", "mul", "truediv", "floordiv", "mod", "pow", "lshift", "rshift", "and", "xor", "or", "divmod"]
-    for (var r_opname of r_opnames) {
-        if (int["__r" + r_opname + "__"] === undefined &&
-            int['__' + r_opname + '__']) {
-            int["__r" + r_opname + "__"] = (function(name) {
-                return function(self, other) {
-                    if (_b_.isinstance(other, int)) {
-                        other = int_value(other)
-                        return int["__" + name + "__"](other, self)
-                    }
-                    return _b_.NotImplemented
-                }
-            })(r_opname)
-        }
-    }
-    var $valid_digits = function(base) {
-        var digits = ""
-        if (base === 0) {
-            return "0"
-        }
-        if (base < 10) {
-            for (var i = 0; i < base; i++) {
-                digits += String.fromCharCode(i + 48)
-            }
-            return digits
-        }
-        var digits = "0123456789"
-        for (var i = 10; i < base; i++) {
-            digits += String.fromCharCode(i + 55)
-        }
-        return digits
-    }
-    int.$factory = function(value, base) {
-        if (value === undefined) {
-            return 0
-        }
-        if (typeof value == "number" &&
-            (base === undefined || base == 10)) {
-            return parseInt(value)
-        }
-        if (_b_.isinstance(value, _b_.complex)) {
-            throw _b_.TypeError.$factory("can't convert complex to int")
-        }
-        var $ns = $B.args("int", 2, {
-                x: null,
-                base: null
-            }, ["x", "base"], arguments, {
-                "base": 10
-            }, null, null),
-            value = $ns["x"],
-            base = $ns["base"]
-        if (_b_.isinstance(value, _b_.float) && base == 10) {
-            value = _b_.float.numerator(value)
-            if (value < $B.min_int || value > $B.max_int) {
-                return $B.long_int.$from_float(value)
-            } else {
-                return value > 0 ? Math.floor(value) : Math.ceil(value)
-            }
-        }
-        if (!(base >= 2 && base <= 36)) {
-            if (base != 0) {
-                throw _b_.ValueError.$factory("invalid base")
-            }
-        }
-        if (typeof value == "number") {
-            if (base == 10) {
-                if (value < $B.min_int || value > $B.max_int) {
-                    return $B.long_int.$factory(value)
-                }
-                return value
-            } else if (value.toString().search("e") > -1) {
-                throw _b_.OverflowError.$factory("can't convert to base " + base)
-            } else {
-                var res = parseInt(value, base)
-                if (value < $B.min_int || value > $B.max_int) {
-                    return $B.long_int.$factory(value, base)
-                }
-                return res
-            }
-        }
-        if (value === true) {
-            return Number(1)
-        }
-        if (value === false) {
-            return Number(0)
-        }
-        if (value.__class__ === $B.long_int) {
-            var z = parseInt(value.value)
-            if (z > $B.min_int && z < $B.max_int) {
-                return z
-            } else {
-                return value
-            }
-        }
-        base = $B.$GetInt(base)
-
-        function invalid(value, base) {
-            throw _b_.ValueError.$factory("invalid literal for int() with base " +
-                base + ": '" + _b_.str.$factory(value) + "'")
-        }
-        if (_b_.isinstance(value, _b_.str)) {
-            value = value.valueOf()
-        }
-        if (typeof value == "string") {
-            var _value = value.trim()
-            if (_value.length == 2 && base == 0 &&
-                (_value == "0b" || _value == "0o" || _value == "0x")) {
-                throw _b_.ValueError.$factory("invalid value")
-            }
-            if (_value.length > 2) {
-                var _pre = _value.substr(0, 2).toUpperCase()
-                if (base == 0) {
-                    if (_pre == "0B") {
-                        base = 2
-                    }
-                    if (_pre == "0O") {
-                        base = 8
-                    }
-                    if (_pre == "0X") {
-                        base = 16
-                    }
-                } else if (_pre == "0X" && base != 16) {
-                    invalid(_value, base)
-                } else if (_pre == "0O" && base != 8) {
-                    invalid(_value, base)
-                }
-                if ((_pre == "0B" && base == 2) || _pre == "0O" || _pre == "0X") {
-                    _value = _value.substr(2)
-                    while (_value.startsWith("_")) {
-                        _value = _value.substr(1)
-                    }
-                }
-            } else if (base == 0) {
-                base = 10
-            }
-            var _digits = $valid_digits(base),
-                _re = new RegExp("^[+-]?[" + _digits + "]" +
-                    "[" + _digits + "_]*$", "i"),
-                match = _re.exec(_value)
-            if (match === null) {
-                invalid(value, base)
-            } else {
-                value = _value.replace(/_/g, "")
-            }
-            if (base <= 10 && !isFinite(value)) {
-                invalid(_value, base)
-            }
-            var res = parseInt(value, base)
-            if (res < $B.min_int || res > $B.max_int) {
-                return $B.long_int.$factory(value, base)
-            }
-            return res
-        }
-        if (_b_.isinstance(value, [_b_.bytes, _b_.bytearray])) {
-            return int.$factory($B.$getattr(value, "decode")("latin-1"), base)
-        }
-        for (var special_method of ["__int__", "__index__", "__trunc__"]) {
-            var num_value = $B.$getattr(value.__class__ || $B.get_class(value), special_method, _b_.None)
-            if (num_value !== _b_.None) {
-                return $B.$call(num_value)(value)
-            }
-        }
-        throw _b_.TypeError.$factory(
-            "int() argument must be a string, a bytes-like " +
-            "object or a number, not '" + $B.class_name(value) + "'")
-    }
-    $B.set_func_names(int, "builtins")
-    _b_.int = int
-    $B.$bool = function(obj) {
-        if (obj === null || obj === undefined) {
-            return false
-        }
-        switch (typeof obj) {
-            case "boolean":
-                return obj
-            case "number":
-            case "string":
-                if (obj) {
-                    return true
-                }
-                return false
-            default:
-                if (obj.$is_class) {
-                    return true
-                }
-                var klass = obj.__class__ || $B.get_class(obj),
-                    missing = {},
-                    bool_method = $B.$getattr(klass, "__bool__", missing)
-                if (bool_method === missing) {
-                    try {
-                        return _b_.len(obj) > 0
-                    } catch (err) {
-                        return true
-                    }
-                } else {
-                    var res = $B.$call(bool_method)(obj)
-                    if (res !== true && res !== false) {
-                        throw _b_.TypeError.$factory("__bool__ should return " +
-                            "bool, returned " + $B.class_name(res))
-                    }
-                    return res
-                }
-        }
-    }
-    var bool = {
-        __bases__: [int],
-        __class__: _b_.type,
-        __mro__: [int, _b_.object],
-        $infos: {
-            __name__: "bool",
-            __module__: "builtins"
-        },
-        $is_class: true,
-        $native: true,
-        $descriptors: {
-            "numerator": true,
-            "denominator": true,
-            "imag": true,
-            "real": true
-        }
-    }
-    bool.__and__ = function(self, other) {
-        if (_b_.isinstance(other, bool)) {
-            return self && other
-        } else if (_b_.isinstance(other, int)) {
-            return int.__and__(bool.__index__(self), int.__index__(other))
-        }
-        return _b_.NotImplemented
-    }
-    bool.__float__ = function(self) {
-        return self ? new Number(1) : new Number(0)
-    }
-    bool.__hash__ = bool.__index__ = bool.__int__ = function(self) {
-        if (self.valueOf()) return 1
-        return 0
-    }
-    bool.__neg__ = function(self) {
-        return -$B.int_or_bool(self)
-    }
-    bool.__or__ = function(self, other) {
-        if (_b_.isinstance(other, bool)) {
-            return self || other
-        } else if (_b_.isinstance(other, int)) {
-            return int.__or__(bool.__index__(self), int.__index__(other))
-        }
-        return _b_.NotImplemented
-    }
-    bool.__pos__ = $B.int_or_bool
-    bool.__repr__ = function(self) {
-        $B.builtins_repr_check(bool, arguments)
-        return self ? "True" : "False"
-    }
-    bool.__xor__ = function(self, other) {
-        if (_b_.isinstance(other, bool)) {
-            return self ^ other ? true : false
-        } else if (_b_.isinstance(other, int)) {
-            return int.__xor__(bool.__index__(self), int.__index__(other))
-        }
-        return _b_.NotImplemented
-    }
-    bool.$factory = function() {
-        var $ = $B.args("bool", 1, {
-            x: null
-        }, ["x"], arguments, {
-            x: false
-        }, null, null)
-        return $B.$bool($.x)
-    }
-    bool.numerator = int.numerator
-    bool.denominator = int.denominator
-    bool.real = int.real
-    bool.imag = int.imag
-    _b_.bool = bool
-    $B.set_func_names(bool, "builtins")
-})(__BRYTHON__);;
-(function($B) {
-    var bltns = $B.InjectBuiltins()
-    eval(bltns)
-    try {
-        eval("window")
-    } catch (err) {
-        window = self
-    }
-    var long_int = {
-        __class__: _b_.type,
-        __mro__: [int, object],
-        $infos: {
-            __module__: "builtins",
-            __name__: "int"
-        },
-        $is_class: true,
-        $native: true,
-        $descriptors: {
-            "numerator": true,
-            "denominator": true,
-            "imag": true,
-            "real": true
-        }
-    }
-    var max_safe_divider = $B.max_int / 9
-
-    function add_pos(v1, v2) {
-        if (window.BigInt) {
-            return {
-                __class__: long_int,
-                value: (BigInt(v1) + BigInt(v2)).toString(),
-                pos: true
-            }
-        }
-        var res = "",
-            carry = 0,
-            iself = v1.length,
-            sv = 0,
-            x
-        for (var i = v2.length - 1; i >= 0; i--) {
-            iself--
-            if (iself < 0) {
-                sv = 0
-            } else {
-                sv = parseInt(v1.charAt(iself))
-            }
-            x = (carry + sv + parseInt(v2.charAt(i))).toString()
-            if (x.length == 2) {
-                res = x.charAt(1) + res
-                carry = parseInt(x.charAt(0))
-            } else {
-                res = x + res;
-                carry = 0
-            }
-        }
-        while (iself > 0) {
-            iself--
-            x = (carry + parseInt(v1.charAt(iself))).toString()
-            if (x.length == 2) {
-                res = x.charAt(1) + res
-                carry = parseInt(x.charAt(0))
-            } else {
-                res = x + res;
-                carry = 0
-            }
-        }
-        if (carry) {
-            res = carry + res
-        }
-        return {
-            __class__: long_int,
-            value: res,
-            pos: true
-        }
-    }
-    var len = ((Math.pow(2, 53) - 1) + '').length - 1
-
-    function binary_pos(t) {
-        var nb_chunks = Math.ceil(t.length / len),
-            chunks = [],
-            pos, start, nb, bin = []
-        for (var i = 0; i < nb_chunks; i++) {
-            pos = t.length - (i + 1) * len
-            start = Math.max(0, pos)
-            nb = pos - start
-            chunks.push(t.substr(start, len + nb))
-        }
-        chunks = chunks.reverse()
-        chunks.forEach(function(chunk, i) {
-            chunks[i] = parseInt(chunk)
-        })
-        var rest
-        var carry = Math.pow(10, 15)
-        while (chunks[chunks.length - 1] > 0) {
-            chunks.forEach(function(chunk, i) {
-                rest = chunk % 2
-                chunks[i] = Math.floor(chunk / 2)
-                if (rest && i < chunks.length - 1) {
-                    chunks[i + 1] += carry
-                }
-            })
-            bin.push(rest)
-            if (chunks[0] == 0) {
-                chunks.shift()
-            }
-        }
-        bin = bin.reverse().join('')
-        return bin
-    }
-
-    function binary(obj) {
-        var bpos = binary_pos(obj.value)
-        if (obj.pos) {
-            return bpos
-        }
-        var res = ''
-        for (var i = 0, len = bpos.length; i < len; i++) {
-            res += bpos.charAt(i) == "0" ? "1" : "0"
-        }
-        var add1 = add_pos(res, "1").value
-        add1 = res.substr(0, res.length - add1.length) + add1
-        return add1
-    }
-
-    function check_shift(shift) {
-        if (!isinstance(shift, long_int)) {
-            throw TypeError.$factory("shift must be int, not '" +
-                $B.class_name(shift) + "'")
-        }
-        if (!shift.pos) {
-            throw ValueError.$factory("negative shift count")
-        }
-    }
-
-    function clone(obj) {
-        var obj1 = {}
-        for (var attr in obj) {
-            obj1[attr] = obj[attr]
-        }
-        return obj1
-    }
-
-    function comp_pos(v1, v2) {
-        if (v1.length > v2.length) {
-            return 1
-        } else if (v1.length < v2.length) {
-            return -1
-        } else {
-            if (v1 > v2) {
-                return 1
-            } else if (v1 < v2) {
-                return -1
-            }
-        }
-        return 0
-    }
-
-    function divmod_by_safe_int(t, n) {
-        if (n == 1) {
-            return [t, 0]
-        }
-        var T = t.toString(),
-            L = n.toString().length,
-            a = parseInt(T.substr(0, L)),
-            next_pos = L - 1,
-            quotient = '',
-            q, rest
-        while (true) {
-            q = Math.floor(a / n)
-            rest = a - q * n
-            quotient += q
-            next_pos++
-            if (next_pos >= T.length) {
-                return [quotient, rest]
-            }
-            a = 10 * rest + parseInt(T[next_pos])
-        }
-    }
-
-    function divmod_pos(v1, v2) {
-        if ($B.BigInt) {
-            var a = {
-                    __class__: long_int,
-                    value: (BigInt(v1) / BigInt(v2)).toString(),
-                    pos: true
-                },
-                b = {
-                    __class__: long_int,
-                    value: (BigInt(v1) % BigInt(v2)).toString(),
-                    pos: true
-                }
-            return [a, b]
-        }
-        var iv1 = parseInt(v1),
-            iv2 = parseInt(v2),
-            res1
-        if (iv1 < $B.max_int && iv2 < $B.max_int) {
-            var rest = iv1 % iv2,
-                quot = Math.floor(iv1 / iv2).toString()
-            var res1 = [{
-                __class__: long_int,
-                value: quot.toString(),
-                pos: true
-            }, {
-                __class__: long_int,
-                value: rest.toString(),
-                pos: true
-            }]
-            return res1
-        } else if (iv2 < max_safe_divider) {
-            var res_safe = divmod_by_safe_int(v1, iv2)
-            return [long_int.$factory(res_safe[0]), long_int.$factory(res_safe[1])]
-        }
-        var quotient, mod
-        if (comp_pos(v1, v2) == -1) {
-            quotient = "0"
-            mod = long_int.$factory(v1)
-        } else if (v2 == v1) {
-            quotient = "1"
-            mod = long_int.$factory("0")
-        } else {
-            var quotient = "",
-                left = v1.substr(0, v2.length)
-            if (v1 < v2) {
-                left = v1.substr(0, v2.length + 1)
-            }
-            var right = v1.substr(left.length)
-            var mv2 = {}
-            while (true) {
-                var candidate = Math.floor(parseInt(left) / parseInt(v2)) + ""
-                if (candidate == "10") {
-                    candidate = "9"
-                }
-                if (mv2[candidate] === undefined) {
-                    mv2[candidate] = mul_pos(v2, candidate).value
-                }
-                if (comp_pos(left, mv2[candidate]) == -1) {
-                    candidate--
-                    if (mv2[candidate] === undefined) {
-                        mv2[candidate] = mul_pos(v2, candidate).value
-                    }
-                }
-                quotient += candidate
-                left = sub_pos(left, mv2[candidate]).value
-                if (right.length == 0) {
-                    break
-                }
-                left += right.charAt(0)
-                right = right.substr(1)
-            }
-            mod = sub_pos(v1, mul_pos(quotient, v2).value)
-        }
-        return [long_int.$factory(quotient), mod]
-    }
-
-    function split_chunks(s, size) {
-        var nb = Math.ceil(s.length / size),
-            chunks = [],
-            len = s.length
-        for (var i = 0; i < nb; i++) {
-            var pos = len - size * (i + 1)
-            if (pos < 0) {
-                size += pos;
-                pos = 0
-            }
-            chunks.push(parseInt(s.substr(pos, size)))
-        }
-        return chunks
-    }
-
-    function mul_pos(x, y) {
-        if ($B.BigInt) {
-            return long_int.$factory(from_BigInt(BigInt(x) * BigInt(y)))
-        }
-        var ix = parseInt(x),
-            iy = parseInt(y),
-            z = ix * iy
-        if (z < $B.max_int) {
-            return {
-                __class__: long_int,
-                value: z.toString(),
-                pos: true
-            }
-        }
-        var chunk_size = 6,
-            cx = split_chunks(x, chunk_size),
-            cy = split_chunks(y, chunk_size)
-        var products = {},
-            len = cx.length + cy.length
-        for (var i = 0; i < len - 1; i++) {
-            products[i] = 0
-        }
-        for (var i = 0; i < cx.length; i++) {
-            for (var j = 0; j < cy.length; j++) {
-                products[i + j] += cx[i] * cy[j]
-            }
-        }
-        var nb = len - 1,
-            pos
-        for (var i = 0; i < len - 1; i++) {
-            var chunks = split_chunks(products[i].toString(), chunk_size)
-            for (var j = 1; j < chunks.length; j++) {
-                pos = i + j
-                if (products[pos] === undefined) {
-                    products[pos] = parseInt(chunks[j])
-                    nb = pos
-                } else {
-                    products[pos] += parseInt(chunks[j])
-                }
-            }
-            products[i] = chunks[0]
-        }
-        var result = "",
-            i = 0,
-            s
-        while (products[i] !== undefined) {
-            s = products[i].toString()
-            if (products[i + 1] !== undefined) {
-                s = "0".repeat(chunk_size - s.length) + s
-            }
-            result = s + result
-            i++
-        }
-        try {
-            return long_int.$factory(result)
-        } catch (err) {
-            console.log(x, y, products, result)
-            throw err
-        }
-    }
-
-    function sub_pos(v1, v2) {
-        if (window.BigInt) {
-            return {
-                __class__: long_int,
-                value: (BigInt(v1) - BigInt(v2)).toString(),
-                pos: true
-            }
-        }
-        var res = "",
-            carry = 0,
-            i1 = v1.length,
-            sv = 0,
-            x
-        for (var i = v2.length - 1; i >= 0; i--) {
-            i1--
-            sv = parseInt(v1.charAt(i1))
-            x = (sv - carry - parseInt(v2.charAt(i)))
-            if (isNaN(x)) {
-                console.log("x is NaN", v1.length, v2.length, i, i1, sv, carry, i, v2.charAt(i))
-            }
-            if (x < 0) {
-                res = (10 + x) + res;
-                carry = 1
-            } else {
-                res = x + res;
-                carry = 0
-            }
-        }
-        if (res.startsWith("NaN")) {
-            alert(res)
-        }
-        while (i1 > 0) {
-            i1--
-            x = (parseInt(v1.charAt(i1)) - carry)
-            if (x < 0) {
-                res = (10 + x) + res;
-                carry = 1
-            } else {
-                res = x + res;
-                carry = 0
-            }
-        }
-        while (res.charAt(0) == "0" && res.length > 1) {
-            res = res.substr(1)
-        }
-        if (res.startsWith("NaN")) {
-            console.log("hoho !!", v1, v2, v1 >= v2, res)
-        }
-        return {
-            __class__: long_int,
-            value: res,
-            pos: true
-        }
-    }
-
-    function to_BigInt(x) {
-        var res = $B.BigInt(x.value)
-        if (x.pos) {
-            return res
-        }
-        return -res
-    }
-
-    function to_int(long_int) {
-        return long_int.pos ? parseInt(long_int.value) : -parseInt(long_int.value)
-    }
-
-    function from_BigInt(y) {
-        var pos = y >= 0
-        y = y.toString()
-        y = y.endsWith("n") ? y.substr(0, y.length - 1) : y
-        y = y.startsWith('-') ? y.substr(1) : y
-        return intOrLong({
-            __class__: long_int,
-            value: y,
-            pos: pos
-        })
-    }
-    long_int.$from_float = function(value) {
-        var s = Math.abs(value).toString(),
-            v = s
-        if (s.search("e") > -1) {
-            var t = /-?(\d)(\.\d+)?e([+-])(\d*)/.exec(s),
-                n1 = t[1],
-                n2 = t[2],
-                pos = t[3],
-                exp = t[4]
-            if (pos == "+") {
-                if (n2 === undefined) {
-                    v = n1 + "0".repeat(exp - 1)
-                } else {
-                    v = n1 + n2 + "0".repeat(exp - 1 - n2.length)
-                }
-            }
-        }
-        return {
-            __class__: long_int,
-            value: v,
-            pos: value >= 0
-        }
-    }
-
-    function preformat(self, fmt) {
-        if (fmt.empty) {
-            return _b_.str.$factory(self)
-        }
-        if (fmt.type && 'bcdoxXn'.indexOf(fmt.type) == -1) {
-            throw _b_.ValueError.$factory("Unknown format code '" + fmt.type +
-                "' for object of type 'int'")
-        }
-        var res
-        switch (fmt.type) {
-            case undefined:
-            case "d":
-                res = self.toString()
-                break
-            case "b":
-                res = (fmt.alternate ? "0b" : "") + BigInt(self.value).toString(2)
-                break
-            case "c":
-                res = _b_.chr(self)
-                break
-            case "o":
-                res = (fmt.alternate ? "0o" : "") + BigInt(self.value).toString(8)
-                break
-            case "x":
-                res = (fmt.alternate ? "0x" : "") + BigInt(self.value).toString(16)
-                break
-            case "X":
-                res = (fmt.alternate ? "0X" : "") + BigInt(self.value).toString(16).toUpperCase()
-                break
-            case "n":
-                return self
-        }
-        if (fmt.sign !== undefined) {
-            if ((fmt.sign == " " || fmt.sign == "+") && self >= 0) {
-                res = fmt.sign + res
-            }
-        }
-        return res
-    }
-    long_int.__format__ = function(self, format_spec) {
-        var fmt = new $B.parse_format_spec(format_spec)
-        if (fmt.type && 'eEfFgG%'.indexOf(fmt.type) != -1) {
-            return _b_.float.__format__(self, format_spec)
-        }
-        fmt.align = fmt.align || ">"
-        var res = preformat(self, fmt)
-        if (fmt.comma) {
-            var sign = res[0] == "-" ? "-" : "",
-                rest = res.substr(sign.length),
-                len = rest.length,
-                nb = Math.ceil(rest.length / 3),
-                chunks = []
-            for (var i = 0; i < nb; i++) {
-                chunks.push(rest.substring(len - 3 * i - 3, len - 3 * i))
-            }
-            chunks.reverse()
-            res = sign + chunks.join(",")
-        }
-        return $B.format_width(res, fmt)
-    }
-    long_int.__abs__ = function(self) {
-        return {
-            __class__: long_int,
-            value: self.value,
-            pos: true
-        }
-    }
-    long_int.__add__ = function(self, other) {
-        if (isinstance(other, _b_.float)) {
-            return _b_.float.$factory(to_int(self) + other)
-        }
-        if (typeof other == "number") {
-            other = long_int.$factory(_b_.str.$factory(other))
-        } else if (other.__class__ !== long_int) {
-            if (isinstance(other, _b_.bool)) {
-                other = long_int.$factory(other ? 1 : 0)
-            } else if (isinstance(other, int)) {
-                other = long_int.$factory(_b_.str.$factory(_b_.int.__index__(other)))
-            } else {
-                return _b_.NotImplemented
-            }
-        }
-        if ($B.BigInt) {
-            return from_BigInt(to_BigInt(self) + to_BigInt(other))
-        }
-        var res
-        if (self.pos && other.pos) {
-            return add_pos(self.value, other.value)
-        } else if (!self.pos && !other.pos) {
-            res = add_pos(self.value, other.value)
-            res.pos = false
-            return intOrLong(res)
-        } else if (self.pos && !other.pos) {
-            switch (comp_pos(self.value, other.value)) {
-                case 1:
-                    res = sub_pos(self.value, other.value)
-                    break
-                case 0:
-                    res = {
-                        __class__: long_int,
-                        value: 0,
-                        pos: true
-                    }
-                    break
-                case -1:
-                    res = sub_pos(other.value, self.value)
-                    res.pos = false
-                    break
-            }
-            return intOrLong(res)
-        } else {
-            switch (comp_pos(self.value, other.value)) {
-                case 1:
-                    res = sub_pos(self.value, other.value)
-                    res.pos = false
-                    break
-                case 0:
-                    res = {
-                        __class__: long_int,
-                        value: 0,
-                        pos: true
-                    }
-                    break
-                case -1:
-                    res = sub_pos(other.value, self.value)
-                    break
-            }
-            return intOrLong(res)
-        }
-    }
-    long_int.__and__ = function(self, other) {
-        if (typeof other == "number") {
-            other = long_int.$factory(_b_.str.$factory(other))
-        }
-        if ($B.BigInt) {
-            return from_BigInt(to_BigInt(self) & to_BigInt(other))
-        }
-        var v1 = self.value,
-            v2 = other.value,
-            temp1, temp2, res = ""
-        var neg = (!self.pos) && (!other.pos)
-        if (neg) {
-            self = long_int.__neg__(self)
-            other = long_int.__neg__(other)
-        }
-        var b1 = binary(self),
-            len1 = b1.length,
-            b2 = binary(other),
-            len2 = b2.length,
-            i = 1,
-            res = '',
-            x1, x2
-        while (true) {
-            if (i > len1 && i > len2) {
-                break
-            }
-            if (i > len1) {
-                x1 = self.pos ? "0" : "1"
-            } else {
-                x1 = b1.charAt(len1 - i)
-            }
-            if (i > len2) {
-                x2 = other.pos ? "0" : "1"
-            } else {
-                x2 = b2.charAt(len2 - i)
-            }
-            if (x1 == "1" && x2 == "1") {
-                res = "1" + res
-            } else {
-                res = "0" + res
-            }
-            i++
-        }
-        while (res.charAt(0) == "0") {
-            res = res.substr(1)
-        }
-        res = $B.long_int.$factory(res, 2)
-        if (neg) {
-            res.pos = false
-        }
-        return intOrLong(res)
-    }
-    long_int.__divmod__ = function(self, other) {
-        if (typeof other == "number") {
-            other = long_int.$factory(_b_.str.$factory(other))
-        }
-        var dm = divmod_pos(self.value, other.value)
-        if (self.pos !== other.pos) {
-            if (dm[0].value != "0") {
-                dm[0].pos = false
-            }
-            if (dm[1].value != "0") {
-                dm[0] = long_int.__sub__(dm[0], long_int.$factory("1"))
-                dm[1] = long_int.__sub__(self, long_int.__mul__(other, long_int.$factory(dm[0])))
-            }
-        }
-        return $B.fast_tuple([intOrLong(dm[0]), intOrLong(dm[1])])
-    }
-    long_int.__eq__ = function(self, other) {
-        if (typeof other == "number") {
-            other = long_int.$factory(_b_.str.$factory(other))
-        }
-        return self.value == other.value && self.pos == other.pos
-    }
-    long_int.__float__ = function(self) {
-        if (!isFinite(parseFloat(self.value))) {
-            throw _b_.OverflowError.$factory("int too big to convert to float")
-        }
-        return new Number(parseFloat(self.value))
-    }
-    long_int.__floordiv__ = function(self, other) {
-        if (isinstance(other, _b_.float)) {
-            return _b_.float.$factory(to_int(self) / other)
-        }
-        if (typeof other == "number" && Math.abs(other) < $B.max_safe_divider) {
-            var t = self.value,
-                res = divmod_by_safe_int(t, other),
-                pos = other > 0 ? self.pos : !self.pos
-            return {
-                __class__: long_int,
-                value: res[0],
-                pos: pos
-            }
-        }
-        var res = intOrLong(long_int.__divmod__(self, other)[0])
-        return res
-    }
-    long_int.__ge__ = function(self, other) {
-        if (typeof other == "number") {
-            other = long_int.$factory(_b_.str.$factory(other))
-        }
-        if (self.pos != other.pos) {
-            return !other.pos
-        }
-        if (self.value.length > other.value.length) {
-            return self.pos
-        } else if (self.value.length < other.value.length) {
-            return !self.pos
-        } else {
-            return self.pos ? self.value >= other.value :
-                self.value <= other.value
-        }
-    }
-    long_int.__gt__ = function(self, other) {
-        return !long_int.__le__(self, other)
-    }
-    long_int.__hash__ = function(self) {
-        var modulus = $B.fast_long_int("2305843009213693951", true),
-            self_pos = $B.fast_long_int(self.value, true)
-        var _hash = $B.long_int.__mod__(self_pos, modulus)
-        if (typeof _hash == "number") {
-            _hash = self.pos ? _hash : -_hash
-        } else {
-            _hash.pos = self.pos
-        }
-        return self.__hashvalue__ = _hash
-    }
-    long_int.__index__ = function(self) {
-        var res = '',
-            temp = self.value,
-            d
-        while (true) {
-            d = divmod_pos(temp, "2")
-            res = d[1].value + res
-            temp = d[0].value
-            if (temp == "0") {
-                break
-            }
-        }
-        if (!self.pos) {
-            var nres = "",
-                flag = false
-            for (var len = res.length - 1, i = len; i >= 0; i--) {
-                var bit = res.charAt(i)
-                if (bit == "0") {
-                    if (flag) {
-                        nres = "1" + nres
-                    } else {
-                        nres = "0" + nres
-                    }
-                } else {
-                    if (flag) {
-                        nres = "0" + nres
-                    } else {
-                        flag = true;
-                        nres = "1" + nres
-                    }
-                }
-            }
-            nres = "1" + nres
-            res = nres
-        } else {
-            res = "0" + res
-        }
-        return intOrLong(res)
-    }
-    long_int.__invert__ = function(self) {
-        return long_int.__sub__(long_int.$factory("-1"), self)
-    }
-    long_int.__le__ = function(self, other) {
-        if (typeof other == "number") {
-            other = long_int.$factory(_b_.str.$factory(other))
-        }
-        if (self.pos !== other.pos) {
-            return !self.pos
-        }
-        if (self.value.length > other.value.length) {
-            return !self.pos
-        } else if (self.value.length < other.value.length) {
-            return self.pos
-        } else {
-            return self.pos ? self.value <= other.value :
-                self.value >= other.value
-        }
-    }
-    long_int.__lt__ = function(self, other) {
-        return !long_int.__ge__(self, other)
-    }
-    long_int.__lshift__ = function(self, shift) {
-        if (window.BigInt) {
-            if (shift.__class__ == long_int) {
-                shift = shift.value
-            }
-            return intOrLong({
-                __class__: long_int,
-                value: (BigInt(self.value) << BigInt(shift)).toString(),
-                pos: self.pos
-            })
-        }
-        var is_long = shift.__class__ === long_int,
-            shift_safe
-        if (is_long) {
-            var shift_value = parseInt(shift.value)
-            if (shift_value < 0) {
-                throw _b_.ValueError.$factory('negative shift count')
-            }
-            if (shift_value < $B.max_int) {
-                shift_safe = true
-                shift = shift_value
-            }
-        }
-        if (shift_safe) {
-            if (shift_value == 0) {
-                return self
-            }
-        } else {
-            shift = long_int.$factory(shift)
-            if (shift.value == "0") {
-                return self
-            }
-        }
-        var res = self.value
-        while (true) {
-            var x, carry = 0,
-                res1 = ""
-            for (var i = res.length - 1; i >= 0; i--) {
-                x = (carry + parseInt(res.charAt(i)) * 2).toString()
-                if (x.length == 2) {
-                    res1 = x.charAt(1) + res1
-                    carry = parseInt(x.charAt(0))
-                } else {
-                    res1 = x + res1
-                    carry = 0
-                }
-            }
-            if (carry) {
-                res1 = carry + res1
-            }
-            res = res1
-            if (shift_safe) {
-                shift--
-                if (shift == 0) {
-                    break
-                }
-            } else {
-                shift = sub_pos(shift.value, "1")
-                if (shift.value == "0") {
-                    break
-                }
-            }
-        }
-        return intOrLong({
-            __class__: long_int,
-            value: res,
-            pos: self.pos
-        })
-    }
-    long_int.__mod__ = function(self, other) {
-        return intOrLong(long_int.__divmod__(self, other)[1])
-    }
-    long_int.__mro__ = [_b_.int, _b_.object]
-    long_int.__mul__ = function(self, other) {
-        switch (self) {
-            case Number.NEGATIVE_INFINITY:
-            case Number.POSITIVE_INFINITY:
-                if ($B.rich_comp("__eq__", other, 0)) {
-                    return NaN
-                } else if (_b_.getattr(other, "__gt__")(0)) {
-                    return self
-                } else {
-                    return -self
-                }
-        }
-        if (isinstance(other, _b_.float)) {
-            return _b_.float.$factory(to_int(self) * other)
-        }
-        if (typeof other == "number") {
-            other = long_int.$factory(other)
-        }
-        other_value = other.value
-        other_pos = other.pos
-        if (other.__class__ !== long_int && isinstance(other, int)) {
-            var value = int.__index__(other)
-            other_value = _b_.str.$factory(value)
-            other_pos = value > 0
-        }
-        if ($B.BigInt) {
-            return from_BigInt(to_BigInt(self) * to_BigInt(other))
-        }
-        var res = mul_pos(self.value, other_value)
-        if (self.pos == other_pos) {
-            return intOrLong(res)
-        }
-        res.pos = false
-        return intOrLong(res)
-    }
-    long_int.__neg__ = function(obj) {
-        return {
-            __class__: long_int,
-            value: obj.value,
-            pos: !obj.pos
-        }
-    }
-    long_int.__or__ = function(self, other) {
-        other = long_int.$factory(other)
-        var v1 = long_int.__index__(self)
-        var v2 = long_int.__index__(other)
-        if (v1.length < v2.length) {
-            var temp = v2;
-            v2 = v1;
-            v1 = temp
-        }
-        var start = v1.length - v2.length
-        var res = v1.substr(0, start)
-        for (var i = 0; i < v2.length; i++) {
-            if (v1.charAt(start + i) == "1" || v2.charAt(i) == "1") {
-                res += "1"
-            } else {
-                res += "0"
-            }
-        }
-        return intOrLong(long_int.$factory(res, 2))
-    }
-    long_int.__pos__ = function(self) {
-        return self
-    }
-    long_int.__pow__ = function(self, power, z) {
-        if (typeof power == "number") {
-            power = long_int.$from_int(power)
-        } else if (isinstance(power, int)) {
-            power = long_int.$factory(_b_.str.$factory(_b_.int.__index__(power)))
-        } else if (!isinstance(power, long_int)) {
-            var msg = "power must be an integer, not '"
-            throw TypeError.$factory(msg + $B.class_name(power) + "'")
-        }
-        if (!power.pos) {
-            if (self.value == "1") {
-                return self
-            }
-            return long_int.$factory("0")
-        } else if (power.value == "0") {
-            return long_int.$factory("1")
-        }
-        if ($B.BigInt) {
-            var s = $B.BigInt(self.value),
-                b = $B.BigInt(1),
-                x = $B.BigInt(power.value),
-                z = z === undefined ? z : typeof z == "number" ? $B.BigInt(z) :
-                $B.BigInt(z.value)
-            if (z === undefined) {
-                return {
-                    __class__: long_int,
-                    value: (s ** x).toString(),
-                    pos: true
-                }
-            }
-            while (x > 0) {
-                if (x % $B.BigInt(2) == 1) {
-                    b = b * s
-                }
-                x = x / $B.BigInt(2)
-                if (x > 0) {
-                    s = s * s
-                }
-                if (z !== undefined) {
-                    b = b % z
-                }
-            }
-            return {
-                __class__: long_int,
-                value: b.toString(),
-                pos: true
-            }
-        }
-        var b = {
-                __class__: long_int,
-                value: "1",
-                pos: true
-            },
-            s = self,
-            pow = power.value,
-            temp
-        while (true) {
-            if (typeof pow == "string" && parseInt(pow) < $B.max_int) {
-                pow = parseInt(pow)
-            }
-            if (pow == 0) {
-                break
-            } else if (typeof pow == "string") {
-                if (parseInt(pow.charAt(pow.length - 1)) % 2 == 1) {
-                    b = long_int.__mul__(b, s)
-                }
-                pow = long_int.__floordiv__(pow, 2)
-            } else {
-                if (pow % 2 == 1) {
-                    if (typeof b == "number" && typeof s == "number" &&
-                        (temp = b * s) < $B.max_int) {
-                        b = temp
-                    } else {
-                        b = long_int.__mul__(long_int.$factory(b), long_int.$factory(s))
-                    }
-                }
-                pow = Math.floor(pow / 2)
-            }
-            if (pow > 0) {
-                if (typeof s == "number" && (temp = s * s) < $B.max_int) {
-                    s = temp
-                } else {
-                    s = long_int.$factory(s)
-                    s = long_int.__mul__(s, s)
-                }
-            }
-            if (z !== undefined) {
-                b = long_int.__mod__(b, z)
-            }
-        }
-        return intOrLong(b)
-    }
-    long_int.__rshift__ = function(self, shift) {
-        if (window.BigInt) {
-            if (shift.__class__ === long_int) {
-                shift = shift.value
-            }
-            return intOrLong({
-                __class__: long_int,
-                value: (BigInt(self.value) >> BigInt(shift)).toString(),
-                pos: self.pos
-            })
-        }
-        if (typeof shift == "number") {
-            var pow2 = Math.pow(2, shift)
-            if (pow2 < $B.max_int) {
-                var res = divmod_by_safe_int(self.value, pow2)
-                return intOrLong({
-                    __class__: long_int,
-                    value: res[0],
-                    pos: self.pos
-                })
-            }
-        }
-        shift = long_int.$factory(shift)
-        if (shift.value == "0") {
-            return self
-        }
-        var res = self.value
-        while (true) {
-            res = divmod_pos(res, "2")[0].value
-            if (res.value == "0") {
-                break
-            }
-            shift = sub_pos(shift.value, "1")
-            if (shift.value == "0") {
-                break
-            }
-        }
-        return intOrLong({
-            __class__: long_int,
-            value: res,
-            pos: self.pos
-        })
-    }
-    long_int.__str__ = long_int.__repr__ = function(self) {
-        var res = ""
-        if (!self.pos) {
-            res += '-'
-        }
-        return res + self.value
-    }
-    long_int.__sub__ = function(self, other) {
-        if (isinstance(other, _b_.float)) {
-            other = other instanceof Number ? other : other.$brython_value
-            return _b_.float.$factory(to_int(self) - other)
-        }
-        if (typeof other == "number") {
-            other = long_int.$factory(_b_.str.$factory(other))
-        }
-        if ($B.BigInt) {}
-        var res
-        if (self.pos && other.pos) {
-            switch (comp_pos(self.value, other.value)) {
-                case 1:
-                    res = sub_pos(self.value, other.value)
-                    break
-                case 0:
-                    res = {
-                        __class__: long_int,
-                        value: "0",
-                        pos: true
-                    }
-                    break
-                case -1:
-                    res = sub_pos(other.value, self.value)
-                    res.pos = false
-                    break
-            }
-            return intOrLong(res)
-        } else if (!self.pos && !other.pos) {
-            switch (comp_pos(self.value, other.value)) {
-                case 1:
-                    res = sub_pos(self.value, other.value)
-                    res.pos = false
-                    break
-                case 0:
-                    res = {
-                        __class__: long_int,
-                        value: "0",
-                        pos: true
-                    }
-                    break
-                case -1:
-                    res = sub_pos(other.value, self.value)
-                    break
-            }
-            return intOrLong(res)
-        } else if (self.pos && !other.pos) {
-            return intOrLong(add_pos(self.value, other.value))
-        } else {
-            res = add_pos(self.value, other.value)
-            res.pos = false
-            return intOrLong(res)
-        }
-    }
-    long_int.__truediv__ = function(self, other) {
-        if (isinstance(other, long_int)) {
-            return _b_.float.$factory(to_int(self) / to_int(other))
-        } else if (isinstance(other, _b_.int)) {
-            return _b_.float.$factory(to_int(self) / other)
-        } else if (isinstance(other, _b_.float)) {
-            return _b_.float.$factory(to_int(self) / other)
-        } else {
-            throw TypeError.$factory(
-                "unsupported operand type(s) for /: 'int' and '" +
-                $B.class_name(other) + "'")
-        }
-    }
-    long_int.__xor__ = function(self, other) {
-        other = long_int.$factory(other)
-        var v1 = long_int.__index__(self),
-            v2 = long_int.__index__(other)
-        if (v1.length < v2.length) {
-            var temp = v2;
-            v2 = v1;
-            v1 = temp
-        }
-        var start = v1.length - v2.length
-        var res = v1.substr(0, start)
-        for (var i = 0; i < v2.length; i++) {
-            if (v1.charAt(start + i) == "1" && v2.charAt(i) == "0") {
-                res += "1"
-            } else if (v1.charAt(start + i) == "0" && v2.charAt(i) == "1") {
-                res += "1"
-            } else {
-                res += "0"
-            }
-        }
-        return intOrLong(long_int.$factory(res, 2))
-    }
-    long_int.bit_length = function(self) {
-        return binary(self).length
-    }
-    long_int.numerator = function(self) {
-        return self
-    }
-    long_int.denominator = function(self) {
-        return _b_.int.$factory(1)
-    }
-    long_int.imag = function(self) {
-        return _b_.int.$factory(0)
-    }
-    long_int.real = function(self) {
-        return self
-    }
-    long_int.to_base = function(self, base) {
-        if (base == 2) {
-            return binary_pos(self.value)
-        }
-        var res = "",
-            v = self.value
-        while (v > 0) {
-            var dm = divmod_pos(v, base.toString())
-            res = parseInt(dm[1].value).toString(base) + res
-            v = dm[0].value
-            if (v == 0) {
-                break
-            }
-        }
-        return res
-    }
-    long_int.to_bytes = function(self, len, byteorder, signed) {
-        var res = [],
-            v = self.value
-        if (!$B.$bool(signed) && !self.pos) {
-            throw _b_.OverflowError.$factory("can't convert negative int to unsigned")
-        }
-        while (v > 0) {
-            var dm = divmod_pos(v, 256)
-            v = parseInt(dm[0].value)
-            res.push(parseInt(dm[1].value))
-            if (res.length > len) {
-                throw _b_.OverflowError.$factory("int too big to convert")
-            }
-        }
-        while (res.length < len) {
-            res.push(0)
-        }
-        if (byteorder == 'big') {
-            res.reverse()
-        }
-        return _b_.bytes.$factory(res)
-    }
-
-    function digits(base) {
-        var is_digits = {}
-        for (var i = 0; i < base; i++) {
-            if (i == 10) {
-                break
-            }
-            is_digits[i] = true
-        }
-        if (base > 10) {
-            for (var i = 0; i < base - 10; i++) {
-                is_digits[String.fromCharCode(65 + i)] = true
-                is_digits[String.fromCharCode(97 + i)] = true
-            }
-        }
-        return is_digits
-    }
-    var MAX_SAFE_INTEGER = Math.pow(2, 53) - 1
-    var MIN_SAFE_INTEGER = -MAX_SAFE_INTEGER
-
-    function isSafeInteger(n) {
-        return (typeof n === "number" &&
-            Math.round(n) === n &&
-            MIN_SAFE_INTEGER <= n &&
-            n <= MAX_SAFE_INTEGER)
-    }
-
-    function intOrLong(long) {
-        var v = parseInt(long.value) * (long.pos ? 1 : -1)
-        if (v > MIN_SAFE_INTEGER && v < MAX_SAFE_INTEGER) {
-            return v
-        }
-        return long
-    }
-    long_int.$from_int = function(value) {
-        return {
-            __class__: long_int,
-            value: value.toString(),
-            pos: value > 0
-        }
-    }
-    long_int.$factory = function(value, base) {
-        if (arguments.length > 2) {
-            throw _b_.TypeError.$factory("long_int takes at most 2 arguments (" +
-                arguments.length + " given)")
-        }
-        if (base === undefined) {
-            base = 10
-        } else if (!isinstance(base, int)) {
-            throw TypeError.$factory("'" + $B.class_name(base) +
-                "' object cannot be interpreted as an integer")
-        }
-        if (base < 0 || base == 1 || base > 36) {
-            throw ValueError.$factory(
-                "long_int.$factory() base must be >= 2 and <= 36")
-        }
-        if (typeof value == "number") {
-            var pos = value >= 0,
-                value = Math.abs(value),
-                res
-            if (isSafeInteger(value)) {
-                res = long_int.$from_int(value)
-            } else if (value.constructor == Number) {
-                var s = value.toString(),
-                    pos_exp = s.search("e")
-                if (pos_exp > -1) {
-                    var mant = s.substr(0, pos_exp),
-                        exp = parseInt(s.substr(pos_exp + 1)),
-                        point = mant.search(/\./)
-                    if (point > -1) {
-                        var nb_dec = mant.substr(point + 1).length
-                        if (nb_dec > exp) {
-                            var res = mant.substr(0, point) +
-                                mant.substr(point + 1).substr(0, exp)
-                            res = long_int.$from_int(res)
-                        } else {
-                            var res = mant.substr(0, point) +
-                                mant.substr(point + 1) + '0'.repeat(exp - nb_dec)
-                            res = long_int.$from_int(res)
-                        }
-                    } else {
-                        res = long_int.$from_int(mant + '0'.repeat(exp))
-                    }
-                } else {
-                    var point = s.search(/\./)
-                    if (point > -1) {
-                        res = long_int.$from_int(s.substr(0, point))
-                    } else {
-                        res = long_int.$from_int(s)
-                    }
-                }
-            } else {
-                throw ValueError.$factory(
-                    "argument of long_int is not a safe integer")
-            }
-            res.pos = pos
-            return res
-        } else if (isinstance(value, _b_.float)) {
-            if (value === Number.POSITIVE_INFINITY ||
-                value === Number.NEGATIVE_INFINITY) {
-                return value
-            }
-            if (value >= 0) {
-                value = new Number(Math.round(value.value))
-            } else {
-                value = new Number(Math.ceil(value.value))
-            }
-        } else if (isinstance(value, _b_.bool)) {
-            if (value.valueOf()) {
-                return int.$factory(1)
-            }
-            return int.$factory(0)
-        } else if (value.__class__ === long_int) {
-            return value
-        } else if (isinstance(value, int)) {
-            value = value.$brython_value + ""
-        } else if (isinstance(value, _b_.bool)) {
-            value = _b_.bool.__int__(value) + ""
-        } else if (typeof value != "string") {
-            throw ValueError.$factory(
-                "argument of long_int must be a string, not " +
-                $B.class_name(value))
-        }
-        var has_prefix = false,
-            pos = true,
-            start = 0
-        while (value.charAt(0) == " " && value.length) {
-            value = value.substr(1)
-        }
-        while (value.charAt(value.length - 1) == " " && value.length) {
-            value = value.substr(0, value.length - 1)
-        }
-        if (value.charAt(0) == "+") {
-            has_prefix = true
-        } else if (value.charAt(0) == "-") {
-            has_prefix = true;
-            pos = false
-        }
-        if (has_prefix) {
-            if (value.length == 1) {
-                throw ValueError.$factory(
-                    'long_int argument is not a valid number: "' + value + '"')
-            } else {
-                value = value.substr(1)
-            }
-        }
-        while (start < value.length - 1 && value.charAt(start) == "0") {
-            start++
-        }
-        value = value.substr(start)
-        var is_digits = digits(base),
-            point = -1
-        for (var i = 0; i < value.length; i++) {
-            if (value.charAt(i) == "." && point == -1) {
-                point = i
-            } else if (false) {
-                var mant = value.substr(0, i)
-                if (/^[+-]?\d+$/.exec(value.substr(i + 1))) {
-                    exp = parseInt(value.substr(i + 1))
-                } else {
-                    throw Error("wrong exp " + value.substr(i + 1))
-                }
-                if (point != -1) {
-                    mant = mant.substr(0, point) + mant.substr(point + 1)
-                    exp = exp + point - 1
-                }
-                point = -1
-                value = mant + "0".repeat(exp - mant.length)
-                break
-            } else if (!is_digits[value.charAt(i)]) {
-                throw ValueError.$factory(
-                    'long_int argument is not a valid number: "' + value + '"')
-            }
-        }
-        if (point != -1) {
-            value = value.substr(0, point)
-        }
-        if (base != 10) {
-            var coef = "1",
-                v10 = long_int.$factory(0),
-                ix = value.length
-            while (ix--) {
-                var digit_base10 = parseInt(value.charAt(ix), base).toString(),
-                    digit_by_coef = mul_pos(coef, digit_base10).value
-                v10 = add_pos(v10.value, digit_by_coef)
-                coef = mul_pos(coef, base.toString()).value
-            }
-            return v10
-        }
-        return {
-            __class__: long_int,
-            value: value,
-            pos: pos
-        }
-    }
-
-    function extended_euclidean_algorithm(a, b) {
-        var s = 0,
-            old_s = 1,
-            t = 1,
-            old_t = 0,
-            r = b,
-            old_r = a,
-            quotient, tmp
-        while ($B.rich_comp('__ne__', r, 0)) {
-            quotient = $B.rich_op('floordiv', old_r, r)
-            tmp = $B.rich_op('sub', old_r, $B.rich_op('mul', quotient, r))
-            old_r = r
-            r = tmp
-            tmp = $B.rich_op('sub', old_s, $B.rich_op('mul', quotient, s))
-            old_s = s
-            s = tmp
-            tmp = $B.rich_op('sub', old_t, $B.rich_op('mul', quotient, t))
-            old_t = t
-            t = tmp
-        }
-        return [old_r, old_s, old_t]
-    }
-
-    function inverse_of(n, p) {
-        var gcd, x, y[gcd, x, y] = extended_euclidean_algorithm(n, p)
-        if ($B.rich_comp('__ne__', gcd, 1)) {
-            throw Error(
-                `${n} has no multiplicative inverse '
-            'modulo ${p}`)
-        } else {
-            return $B.rich_op('mod', x, p)
-        }
-    }
-    $B.inverse_of = inverse_of
-    $B.set_func_names(long_int, "builtins")
-    $B.long_int = long_int
-    $B.fast_long_int = function(value, pos) {
-        return {
-            __class__: $B.long_int,
-            value: value,
-            pos: pos
-        }
-    }
-})(__BRYTHON__);;
-(function($B) {
-    var _b_ = $B.builtins
-
-    function $UnsupportedOpType(op, class1, class2) {
-        throw _b_.TypeError.$factory("unsupported operand type(s) for " +
-            op + ": '" + class1 + "' and '" + class2 + "'")
-    }
-    var complex = {
-        __class__: _b_.type,
-        __dir__: _b_.object.__dir__,
-        $infos: {
-            __module__: "builtins",
-            __name__: "complex"
-        },
-        $is_class: true,
-        $native: true,
-        $descriptors: {
-            real: true,
-            imag: true
-        }
-    }
-    complex.__abs__ = function(self) {
-        var _rf = isFinite(self.$real),
-            _if = isFinite(self.$imag)
-        if ((_rf && isNaN(self.$imag)) || (_if && isNaN(self.$real)) ||
-            (isNaN(self.$imag) && isNaN(self.$real))) {
-            return NaN
-        }
-        if (!_rf || !_if) {
-            return Infinity
-        }
-        var mag = Math.sqrt(Math.pow(self.$real, 2) + Math.pow(self.$imag, 2))
-        if (!isFinite(mag) && _rf && _if) {
-            throw _b_.OverflowError.$factory("absolute value too large")
-        }
-        return mag
-    }
-    complex.__add__ = function(self, other) {
-        if (_b_.isinstance(other, complex)) {
-            return make_complex(self.$real + other.$real, self.$imag + other.$imag)
-        }
-        if (_b_.isinstance(other, _b_.int)) {
-            other = _b_.int.numerator(other)
-            return make_complex($B.add(self.$real, other.valueOf()), self.$imag)
-        }
-        if (_b_.isinstance(other, _b_.float)) {
-            return make_complex(self.$real + other.valueOf(), self.$imag)
-        }
-        return _b_.NotImplemented
-    }
-    complex.__bool__ = function(self) {
-        return (self.$real != 0 || self.$imag != 0)
-    }
-    complex.__complex__ = function(self) {
-        return self
-    }
-    complex.__eq__ = function(self, other) {
-        if (_b_.isinstance(other, complex)) {
-            return self.$real.valueOf() == other.$real.valueOf() &&
-                self.$imag.valueOf() == other.$imag.valueOf()
-        }
-        if (_b_.isinstance(other, _b_.int)) {
-            if (self.$imag != 0) {
-                return false
-            }
-            return self.$real == other.valueOf()
-        }
-        if (_b_.isinstance(other, _b_.float)) {
-            if (self.$imag != 0) {
-                return false
-            }
-            return self.$real == other.valueOf()
-        }
-        return _b_.NotImplemented
-    }
-    complex.__hash__ = function(self) {
-        return self.$imag * 1000003 + self.$real
-    }
-    complex.__init__ = function() {
-        return _b_.None
-    }
-    complex.__invert__ = function(self) {
-        return ~self
-    }
-    complex.__mro__ = [_b_.object]
-    complex.__mul__ = function(self, other) {
-        if (_b_.isinstance(other, complex)) {
-            return make_complex(self.$real * other.$real - self.$imag * other.$imag, self.$imag * other.$real + self.$real * other.$imag)
-        } else if (_b_.isinstance(other, _b_.int)) {
-            return make_complex(self.$real * other.valueOf(), self.$imag * other.valueOf())
-        } else if (_b_.isinstance(other, _b_.float)) {
-            return make_complex(self.$real * other, self.$imag * other)
-        } else if (_b_.isinstance(other, _b_.bool)) {
-            if (other.valueOf()) {
-                return self
-            }
-            return make_complex(0, 0)
-        }
-        $UnsupportedOpType("*", complex, other)
-    }
-    complex.__ne__ = function(self, other) {
-        var res = complex.__eq__(self, other)
-        return res === _b_.NotImplemented ? res : !res
-    }
-    complex.__neg__ = function(self) {
-        return make_complex(-self.$real, -self.$imag)
-    }
-    complex.__new__ = function(cls) {
-        if (cls === undefined) {
-            throw _b_.TypeError.$factory('complex.__new__(): not enough arguments')
-        }
-        var res, missing = {},
-            args = $B.args("complex", 3, {
-                cls: null,
-                real: null,
-                imag: null
-            }, ["cls", "real", "imag"], arguments, {
-                real: 0,
-                imag: missing
-            }, null, null),
-            $real = args.real,
-            $imag = args.imag
-        if (typeof $real == "string") {
-            if ($imag !== missing) {
-                throw _b_.TypeError.$factory("complex() can't take second arg " +
-                    "if first is a string")
-            } else {
-                var arg = $real
-                $real = $real.trim()
-                if ($real.startsWith("(") && $real.endsWith(")")) {
-                    $real = $real.substr(1)
-                    $real = $real.substr(0, $real.length - 1)
-                }
-                var complex_re = /^\s*([\+\-]*[0-9_]*\.?[0-9_]*(e[\+\-]*[0-9_]*)?)([\+\-]?)([0-9_]*\.?[0-9_]*(e[\+\-]*[0-9_]*)?)(j?)\s*$/i
-                var parts = complex_re.exec($real)
-
-                function to_num(s) {
-                    var res = parseFloat(s.charAt(0) + s.substr(1).replace(/_/g, ""))
-                    if (isNaN(res)) {
-                        throw _b_.ValueError.$factory("could not convert string " +
-                            "to complex: '" + arg + "'")
-                    }
-                    return res
-                }
-                if (parts === null) {
-                    throw _b_.ValueError.$factory("complex() arg is a malformed string")
-                } else if (parts[_real] == "." || parts[_imag] == "." ||
-                    parts[_real] == ".e" || parts[_imag] == ".e" ||
-                    parts[_real] == "e" || parts[_imag] == "e") {
-                    throw _b_.ValueError.$factory("complex() arg is a malformed string")
-                } else if (parts[_j] != "") {
-                    if (parts[_sign] == "") {
-                        $real = 0
-                        if (parts[_real] == "+" || parts[_real] == "") {
-                            $imag = 1
-                        } else if (parts[_real] == '-') {
-                            $imag = -1
-                        } else {
-                            $imag = to_num(parts[_real])
-                        }
-                    } else {
-                        $real = to_num(parts[_real])
-                        $imag = parts[_imag] == "" ? 1 : to_num(parts[_imag])
-                        $imag = parts[_sign] == "-" ? -$imag : $imag
-                    }
-                } else {
-                    $real = to_num(parts[_real])
-                    $imag = 0
-                }
-                res = {
-                    __class__: complex,
-                    $real: $real || 0,
-                    $imag: $imag || 0
-                }
-                return res
-            }
-        }
-        $imag = $imag === missing ? 0 : $imag
-        if (arguments.length == 2 && $real.__class__ === complex && $imag == 0) {
-            return $real
-        }
-        if (_b_.isinstance($real, [_b_.float, _b_.int]) &&
-            _b_.isinstance($imag, [_b_.float, _b_.int])) {
-            res = {
-                __class__: complex,
-                $real: $real,
-                $imag: $imag
-            }
-            return res
-        }
-        var real_to_num = $B.to_num($real, ["__complex__", "__float__", "__index__"])
-        if (real_to_num === null) {
-            throw _b_.TypeError.$factory("complex() first argument must be a " +
-                " string or a number, not '" + $B.class_name($real) + "'")
-        }
-        $real = real_to_num
-        $imag = _convert($imag)
-        if (!_b_.isinstance($real, _b_.float) && !_b_.isinstance($real, _b_.int) &&
-            !_b_.isinstance($real, _b_.complex)) {
-            throw _b_.TypeError.$factory("complex() argument must be a string " +
-                "or a number")
-        }
-        if (typeof $imag == "string") {
-            throw _b_.TypeError.$factory("complex() second arg can't be a string")
-        }
-        if (!_b_.isinstance($imag, _b_.float) && !_b_.isinstance($imag, _b_.int) &&
-            !_b_.isinstance($imag, _b_.complex) && $imag !== missing) {
-            throw _b_.TypeError.$factory("complex() argument must be a string " +
-                "or a number")
-        }
-        $imag = complex.__mul__(complex.$factory("1j"), $imag)
-        return complex.__add__($imag, $real)
-    }
-    complex.__pos__ = function(self) {
-        return self
-    }
-
-    function complex2expo(cx) {
-        var norm = Math.sqrt((cx.$real * cx.$real) + (cx.$imag * cx.$imag)),
-            sin = cx.$imag / norm,
-            cos = cx.$real / norm,
-            angle
-        if (cos == 0) {
-            angle = sin == 1 ? Math.PI / 2 : 3 * Math.PI / 2
-        } else if (sin == 0) {
-            angle = cos == 1 ? 0 : Math.PI
-        } else {
-            angle = Math.atan(sin / cos)
-        }
-        return {
-            norm: norm,
-            angle: angle
-        }
-    }
-    complex.__pow__ = function(self, other) {
-        if (other == 1) {
-            return self
-        }
-        var exp = complex2expo(self),
-            angle = exp.angle,
-            res = Math.pow(exp.norm, other)
-        if (_b_.isinstance(other, [_b_.int, _b_.float])) {
-            return make_complex(res * Math.cos(angle * other), res * Math.sin(angle * other))
-        } else if (_b_.isinstance(other, complex)) {
-            var x = other.$real,
-                y = other.$imag
-            var pw = Math.pow(exp.norm, x) * Math.pow(Math.E, -y * angle),
-                theta = y * Math.log(exp.norm) - x * angle
-            return make_complex(pw * Math.cos(theta), pw * Math.sin(theta))
-        } else {
-            throw _b_.TypeError.$factory("unsupported operand type(s) " +
-                "for ** or pow(): 'complex' and '" +
-                $B.class_name(other) + "'")
-        }
-    }
-    complex.__radd__ = function(self, other) {
-        if (_b_.isinstance(other, _b_.bool)) {
-            other = other ? 1 : 0
-        }
-        if (_b_.isinstance(other, [_b_.int, _b_.float])) {
-            return make_complex(other + self.$real, self.$imag)
-        }
-        return _b_.NotImplemented
-    }
-    complex.__repr__ = function(self) {
-        $B.builtins_repr_check(complex, arguments)
-        var real = _b_.str.$factory(self.$real),
-            imag = _b_.str.$factory(self.$imag)
-        if (self.$real instanceof Number && self.$real == parseInt(self.$real)) {
-            real = _b_.str.$factory(parseInt(self.$real))
-        }
-        if (self.$imag instanceof Number && self.$imag == parseInt(self.$imag)) {
-            imag = _b_.str.$factory(parseInt(self.$imag))
-            if (self.$imag == 0 && 1 / self.$imag === -Infinity) {
-                imag = "-0"
-            }
-        }
-        if (self.$real == 0) {
-            if (1 / self.$real < 0) {
-                if (imag.startsWith('-')) {
-                    return "-0" + imag + "j"
-                }
-                return "-0+" + imag + "j"
-            } else {
-                return imag + "j"
-            }
-        }
-        if (self.$imag > 0 || isNaN(self.$imag)) {
-            return "(" + real + "+" + imag + "j)"
-        }
-        if (self.$imag == 0) {
-            if (1 / self.$imag < 0) {
-                return "(" + real + "-0j)"
-            }
-            return "(" + real + "+0j)"
-        }
-        return "(" + real + "-" + _b_.str.$factory(-self.$imag) + "j)"
-    }
-    complex.__rmul__ = function(self, other) {
-        if (_b_.isinstance(other, _b_.bool)) {
-            other = other ? 1 : 0
-        }
-        if (_b_.isinstance(other, [_b_.int, _b_.float])) {
-            return make_complex(other * self.$real, other * self.$imag)
-        }
-        return _b_.NotImplemented
-    }
-    complex.__sqrt__ = function(self) {
-        if (self.$imag == 0) {
-            return complex(Math.sqrt(self.$real))
-        }
-        var r = self.$real,
-            i = self.$imag,
-            _a = Math.sqrt((r + sqrt) / 2),
-            _b = Number.sign(i) * Math.sqrt((-r + sqrt) / 2)
-        return make_complex(_a, _b)
-    }
-    complex.__sub__ = function(self, other) {
-        if (_b_.isinstance(other, complex)) {
-            return make_complex(self.$real - other.$real, self.$imag - other.$imag)
-        }
-        if (_b_.isinstance(other, _b_.int)) {
-            other = _b_.int.numerator(other)
-            return make_complex($B.sub(self.$real, other.valueOf()), self.$imag)
-        }
-        if (_b_.isinstance(other, _b_.float)) {
-            return make_complex(self.$real - other.valueOf(), self.$imag)
-        }
-        return _b_.NotImplemented
-    }
-    complex.__truediv__ = function(self, other) {
-        if (_b_.isinstance(other, complex)) {
-            if (other.$real == 0 && other.$imag == 0) {
-                throw _b_.ZeroDivisionError.$factory("division by zero")
-            }
-            var _num = self.$real * other.$real + self.$imag * other.$imag,
-                _div = other.$real * other.$real + other.$imag * other.$imag
-            var _num2 = self.$imag * other.$real - self.$real * other.$imag
-            return make_complex(_num / _div, _num2 / _div)
-        }
-        if (_b_.isinstance(other, _b_.int)) {
-            if (!other.valueOf()) {
-                throw _b_.ZeroDivisionError.$factory('division by zero')
-            }
-            return complex.__truediv__(self, complex.$factory(other.valueOf()))
-        }
-        if (_b_.isinstance(other, _b_.float)) {
-            if (!other.valueOf()) {
-                throw _b_.ZeroDivisionError.$factory("division by zero")
-            }
-            return complex.__truediv__(self, complex.$factory(other.valueOf()))
-        }
-        $UnsupportedOpType("//", "complex", other.__class__)
-    }
-    complex.conjugate = function(self) {
-        return make_complex(self.$real, -self.$imag)
-    }
-    complex.__ior__ = complex.__or__
-    var r_opnames = ["add", "sub", "mul", "truediv", "floordiv", "mod", "pow", "lshift", "rshift", "and", "xor", "or"]
-    for (var r_opname of r_opnames) {
-        if (complex["__r" + r_opname + "__"] === undefined &&
-            complex['__' + r_opname + '__']) {
-            complex["__r" + r_opname + "__"] = (function(name) {
-                return function(self, other) {
-                    if (_b_.isinstance(other, [_b_.int, _b_.float])) {
-                        other = make_complex(other, 0)
-                        return complex["__" + name + "__"](other, self)
-                    } else if (_b_.isinstance(other, complex)) {
-                        return complex["__" + name + "__"](other, self)
-                    }
-                    return _b_.NotImplemented
-                }
-            })(r_opname)
-        }
-    }
-    var $comp_func = function(self, other) {
-        if (other === undefined || other == _b_.None) {
-            return _b_.NotImplemented
-        }
-        throw _b_.TypeError.$factory("TypeError: no ordering relation " +
-            "is defined for complex numbers")
-    }
-    $comp_func += ''
-    for (var $op in $B.$comps) {
-        eval("complex.__" + $B.$comps[$op] + "__ = " +
-            $comp_func.replace(/>/gm, $op))
-    }
-    complex.real = function(self) {
-        return new Number(self.$real)
-    }
-    complex.real.setter = function() {
-        throw _b_.AttributeError.$factory("readonly attribute")
-    }
-    complex.imag = function(self) {
-        return new Number(self.$imag)
-    }
-    complex.imag.setter = function() {
-        throw _b_.AttributeError.$factory("readonly attribute")
-    }
-    var _real = 1,
-        _real_mantissa = 2,
-        _sign = 3,
-        _imag = 4,
-        _imag_mantissa = 5,
-        _j = 6
-    var type_conversions = ["__complex__", "__float__", "__index__"]
-    var _convert = function(num) {
-        var klass = num.__class__ || $B.get_class(num)
-        for (var i = 0; i < type_conversions.length; i++) {
-            var missing = {},
-                method = $B.$getattr(klass, type_conversions[i], missing)
-            if (method !== missing) {
-                return method(num)
-            }
-        }
-        return null
-    }
-    var make_complex = $B.make_complex = function(real, imag) {
-        return {
-            __class__: complex,
-            $real: real,
-            $imag: imag
-        }
-    }
-    complex.$factory = function() {
-        return complex.__new__(complex, ...arguments)
-    }
-    $B.set_func_names(complex, "builtins")
-    _b_.complex = complex
-})(__BRYTHON__);;
-(function($B) {
-    var DEFAULT_MIN_MERGE = 32
-    var DEFAULT_MIN_GALLOPING = 7
-    var DEFAULT_TMP_STORAGE_LENGTH = 256
-    var POWERS_OF_TEN = [1e0, 1e1, 1e2, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9]
-
-    function log10(x) {
-        if (x < 1e5) {
-            if (x < 1e2) {
-                return x < 1e1 ? 0 : 1
-            }
-            if (x < 1e4) {
-                return x < 1e3 ? 2 : 3
-            }
-            return 4
-        }
-        if (x < 1e7) {
-            return x < 1e6 ? 5 : 6
-        }
-        if (x < 1e9) {
-            return x < 1e8 ? 7 : 8
-        }
-        return 9
-    }
-
-    function alphabeticalCompare(a, b) {
-        if (a === b) {
-            return 0
-        }
-        if (~~a === a && ~~b === b) {
-            if (a === 0 || b === 0) {
-                return a < b ? -1 : 1
-            }
-            if (a < 0 || b < 0) {
-                if (b >= 0) {
-                    return -1
-                }
-                if (a >= 0) {
-                    return 1
-                }
-                a = -a
-                b = -b
-            }
-            al = log10(a)
-            bl = log10(b)
-            var t = 0
-            if (al < bl) {
-                a *= POWERS_OF_TEN[bl - al - 1]
-                b /= 10
-                t = -1
-            } else if (al > bl) {
-                b *= POWERS_OF_TEN[al - bl - 1]
-                a /= 10;
-                t = 1;
-            }
-            if (a === b) {
-                return t
-            }
-            return a < b ? -1 : 1
-        }
-        var aStr = String(a)
-        var bStr = String(b)
-        if (aStr === bStr) {
-            return 0
-        }
-        return aStr < bStr ? -1 : 1
-    }
-
-    function minRunLength(n) {
-        var r = 0
-        while (n >= DEFAULT_MIN_MERGE) {
-            r |= (n & 1)
-            n >>= 1
-        }
-        return n + r
-    }
-
-    function makeAscendingRun(array, lo, hi, compare) {
-        var runHi = lo + 1
-        if (runHi === hi) {
-            return 1;
-        }
-        if (compare(array[runHi++], array[lo]) < 0) {
-            while (runHi < hi && compare(array[runHi], array[runHi - 1]) < 0) {
-                runHi++
-            }
-            reverseRun(array, lo, runHi)
-        } else {
-            while (runHi < hi && compare(array[runHi], array[runHi - 1]) >= 0) {
-                runHi++
-            }
-        }
-        return runHi - lo
-    }
-
-    function reverseRun(array, lo, hi) {
-        hi--
-        while (lo < hi) {
-            var t = array[lo]
-            array[lo++] = array[hi]
-            array[hi--] = t
-        }
-    }
-
-    function binaryInsertionSort(array, lo, hi, start, compare) {
-        if (start === lo) {
-            start++
-        }
-        for (; start < hi; start++) {
-            var pivot = array[start]
-            var left = lo
-            var right = start
-            while (left < right) {
-                var mid = (left + right) >>> 1
-                if (compare(pivot, array[mid]) < 0) {
-                    right = mid
-                } else {
-                    left = mid + 1
-                }
-            }
-            var n = start - left
-            switch (n) {
-                case 3:
-                    array[left + 3] = array[left + 2]
-                case 2:
-                    array[left + 2] = array[left + 1]
-                case 1:
-                    array[left + 1] = array[left]
-                    break;
-                default:
-                    while (n > 0) {
-                        array[left + n] = array[left + n - 1]
-                        n--;
-                    }
-            }
-            array[left] = pivot
-        }
-    }
-
-    function gallopLeft(value, array, start, length, hint, compare) {
-        var lastOffset = 0,
-            maxOffset = 0,
-            offset = 1
-        if (compare(value, array[start + hint]) > 0) {
-            maxOffset = length - hint
-            while (offset < maxOffset && compare(value, array[start + hint + offset]) > 0) {
-                lastOffset = offset
-                offset = (offset << 1) + 1
-                if (offset <= 0) {
-                    offset = maxOffset
-                }
-            }
-            if (offset > maxOffset) {
-                offset = maxOffset
-            }
-            lastOffset += hint
-            offset += hint
-        } else {
-            maxOffset = hint + 1
-            while (offset < maxOffset && compare(value, array[start + hint - offset]) <= 0) {
-                lastOffset = offset
-                offset = (offset << 1) + 1
-                if (offset <= 0) {
-                    offset = maxOffset
-                }
-            }
-            if (offset > maxOffset) {
-                offset = maxOffset
-            }
-            var tmp = lastOffset
-            lastOffset = hint - offset
-            offset = hint - tmp
-        }
-        lastOffset++
-        while (lastOffset < offset) {
-            var m = lastOffset + ((offset - lastOffset) >>> 1)
-            if (compare(value, array[start + m]) > 0) {
-                lastOffset = m + 1
-            } else {
-                offset = m
-            }
-        }
-        return offset
-    }
-
-    function gallopRight(value, array, start, length, hint, compare) {
-        var lastOffset = 0,
-            maxOffset = 0,
-            offset = 1
-        if (compare(value, array[start + hint]) < 0) {
-            maxOffset = hint + 1
-            while (offset < maxOffset && compare(value, array[start + hint - offset]) < 0) {
-                lastOffset = offset
-                offset = (offset << 1) + 1
-                if (offset <= 0) {
-                    offset = maxOffset
-                }
-            }
-            if (offset > maxOffset) {
-                offset = maxOffset
-            }
-            var tmp = lastOffset
-            lastOffset = hint - offset
-            offset = hint - tmp
-        } else {
-            maxOffset = length - hint
-            while (offset < maxOffset && compare(value, array[start + hint + offset]) >= 0) {
-                lastOffset = offset
-                offset = (offset << 1) + 1
-                if (offset <= 0) {
-                    offset = maxOffset
-                }
-            }
-            if (offset > maxOffset) {
-                offset = maxOffset
-            }
-            lastOffset += hint
-            offset += hint
-        }
-        lastOffset++
-        while (lastOffset < offset) {
-            var m = lastOffset + ((offset - lastOffset) >>> 1)
-            if (compare(value, array[start + m]) < 0) {
-                offset = m
-            } else {
-                lastOffset = m + 1
-            }
-        }
-        return offset
-    }
-    var TIM_SORT_ASSERTION = "TimSortAssertion"
-    var TimSortAssertion = function(message) {
-        this.name = TIM_SORT_ASSERTION
-        this.message = message
-    }
-    var TimSort = function(array, compare) {
-        var self = {
-            array: array,
-            compare: compare,
-            minGallop: DEFAULT_MIN_GALLOPING,
-            length: array.length,
-            tmpStorageLength: DEFAULT_TMP_STORAGE_LENGTH,
-            stackLength: 0,
-            runStart: null,
-            runLength: null,
-            stackSize: 0,
-            pushRun: function(runStart, runLength) {
-                this.runStart[this.stackSize] = runStart
-                this.runLength[this.stackSize] = runLength
-                this.stackSize += 1
-            },
-            mergeRuns: function() {
-                while (this.stackSize > 1) {
-                    var n = this.stackSize - 2
-                    if ((n >= 1 && this.runLength[n - 1] <=
-                            this.runLength[n] + this.runLength[n + 1]) ||
-                        (n >= 2 && this.runLength[n - 2] <=
-                            this.runLength[n] + this.runLength[n - 1])) {
-                        if (this.runLength[n - 1] < this.runLength[n + 1]) {
-                            n--
-                        }
-                    } else if (this.runLength[n] > this.runLength[n + 1]) {
-                        break
-                    }
-                    this.mergeAt(n)
-                }
-            },
-            forceMergeRuns: function() {
-                while (this.stackSize > 1) {
-                    var n = this.stackSize - 2
-                    if (n > 0 && this.runLength[n - 1] < this.runLength[n + 1]) {
-                        n--
-                    }
-                    this.mergeAt(n)
-                }
-            },
-            mergeAt: function(i) {
-                var compare = this.compare,
-                    array = this.array,
-                    start1 = this.runStart[i],
-                    length1 = this.runLength[i],
-                    start2 = this.runStart[i + 1],
-                    length2 = this.runLength[i + 1]
-                this.runLength[i] = length1 + length2
-                if (i === this.stackSize - 3) {
-                    this.runStart[i + 1] = this.runStart[i + 2]
-                    this.runLength[i + 1] = this.runLength[i + 2]
-                }
-                this.stackSize--;
-                var k = gallopRight(array[start2], array, start1, length1, 0, compare)
-                start1 += k
-                length1 -= k
-                if (length1 === 0) {
-                    return
-                }
-                length2 = gallopLeft(array[start1 + length1 - 1], array, start2, length2, length2 - 1, compare)
-                if (length2 === 0) {
-                    return
-                }
-                if (length1 <= length2) {
-                    this.mergeLow(start1, length1, start2, length2)
-                } else {
-                    this.mergeHigh(start1, length1, start2, length2)
-                }
-            },
-            mergeLow: function(start1, length1, start2, length2) {
-                var compare = this.compare,
-                    array = this.array,
-                    tmp = this.tmp,
-                    i = 0
-                for (var i = 0; i < length1; i++) {
-                    tmp[i] = array[start1 + i]
-                }
-                var cursor1 = 0,
-                    cursor2 = start2,
-                    dest = start1
-                array[dest++] = array[cursor2++]
-                if (--length2 === 0) {
-                    for (var i = 0; i < length1; i++) {
-                        array[dest + i] = tmp[cursor1 + i]
-                    }
-                    return
-                }
-                if (length1 === 1) {
-                    for (var i = 0; i < length2; i++) {
-                        array[dest + i] = array[cursor2 + i]
-                    }
-                    array[dest + length2] = tmp[cursor1]
-                    return
-                }
-                var minGallop = this.minGallop
-                while (true) {
-                    var count1 = 0,
-                        count2 = 0,
-                        exit = false
-                    do {
-                        if (compare(array[cursor2], tmp[cursor1]) < 0) {
-                            array[dest++] = array[cursor2++]
-                            count2++
-                            count1 = 0
-                            if (--length2 === 0) {
-                                exit = true
-                                break
-                            }
-                        } else {
-                            array[dest++] = tmp[cursor1++]
-                            count1++
-                            count2 = 0
-                            if (--length1 === 1) {
-                                exit = true
-                                break
-                            }
-                        }
-                    } while ((count1 | count2) < minGallop)
-                    if (exit) {
-                        break
-                    }
-                    do {
-                        count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare)
-                        if (count1 !== 0) {
-                            for (var i = 0; i < count1; i++) {
-                                array[dest + i] = tmp[cursor1 + i]
-                            }
-                            dest += count1
-                            cursor1 += count1
-                            length1 -= count1
-                            if (length1 <= 1) {
-                                exit = true
-                                break
-                            }
-                        }
-                        array[dest++] = array[cursor2++]
-                        if (--length2 === 0) {
-                            exit = true
-                            break
-                        }
-                        count2 = gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare)
-                        if (count2 !== 0) {
-                            for (var i = 0; i < count2; i++) {
-                                array[dest + i] = array[cursor2 + i]
-                            }
-                            dest += count2
-                            cursor2 += count2
-                            length2 -= count2
-                            if (length2 === 0) {
-                                exit = true
-                                break
-                            }
-                        }
-                        array[dest++] = tmp[cursor1++]
-                        if (--length1 === 1) {
-                            exit = true
-                            break
-                        }
-                        minGallop--;
-                    } while (count1 >= DEFAULT_MIN_GALLOPING ||
-                        count2 >= DEFAULT_MIN_GALLOPING);
-                    if (exit) {
-                        break
-                    }
-                    if (minGallop < 0) {
-                        minGallop = 0
-                    }
-                    minGallop += 2
-                }
-                this.minGallop = minGallop
-                if (minGallop < 1) {
-                    this.minGallop = 1
-                }
-                if (length1 === 1) {
-                    for (var i = 0; i < length2; i++) {
-                        array[dest + i] = array[cursor2 + i]
-                    }
-                    array[dest + length2] = tmp[cursor1]
-                } else if (length1 === 0) {
-                    throw new TimSortAssertion('mergeLow preconditions were not respected')
-                } else {
-                    for (var i = 0; i < length1; i++) {
-                        array[dest + i] = tmp[cursor1 + i]
-                    }
-                }
-            },
-            mergeHigh: function(start1, length1, start2, length2) {
-                var compare = this.compare,
-                    array = this.array,
-                    tmp = this.tmp,
-                    i = 0
-                for (var i = 0; i < length2; i++) {
-                    tmp[i] = array[start2 + i]
-                }
-                var cursor1 = start1 + length1 - 1,
-                    cursor2 = length2 - 1,
-                    dest = start2 + length2 - 1,
-                    customCursor = 0,
-                    customDest = 0
-                array[dest--] = array[cursor1--]
-                if (--length1 === 0) {
-                    customCursor = dest - (length2 - 1)
-                    for (var i = 0; i < length2; i++) {
-                        array[customCursor + i] = tmp[i]
-                    }
-                    return
-                }
-                if (length2 === 1) {
-                    dest -= length1
-                    cursor1 -= length1
-                    customDest = dest + 1
-                    customCursor = cursor1 + 1
-                    for (var i = length1 - 1; i >= 0; i--) {
-                        array[customDest + i] = array[customCursor + i]
-                    }
-                    array[dest] = tmp[cursor2]
-                    return
-                }
-                var minGallop = this.minGallop
-                while (true) {
-                    var count1 = 0,
-                        count2 = 0,
-                        exit = false
-                    do {
-                        if (compare(tmp[cursor2], array[cursor1]) < 0) {
-                            array[dest--] = array[cursor1--]
-                            count1++
-                            count2 = 0
-                            if (--length1 === 0) {
-                                exit = true
-                                break
-                            }
-                        } else {
-                            array[dest--] = tmp[cursor2--]
-                            count2++
-                            count1 = 0
-                            if (--length2 === 1) {
-                                exit = true
-                                break
-                            }
-                        }
-                    } while ((count1 | count2) < minGallop)
-                    if (exit) {
-                        break
-                    }
-                    do {
-                        count1 = length1 - gallopRight(tmp[cursor2], array, start1, length1, length1 - 1, compare)
-                        if (count1 !== 0) {
-                            dest -= count1
-                            cursor1 -= count1
-                            length1 -= count1
-                            customDest = dest + 1
-                            customCursor = cursor1 + 1
-                            for (var i = count1 - 1; i >= 0; i--) {
-                                array[customDest + i] = array[customCursor + i]
-                            }
-                            if (length1 === 0) {
-                                exit = true
-                                break
-                            }
-                        }
-                        array[dest--] = tmp[cursor2--]
-                        if (--length2 === 1) {
-                            exit = true
-                            break
-                        }
-                        count2 = length2 - gallopLeft(array[cursor1], tmp, 0, length2, length2 - 1, compare)
-                        if (count2 !== 0) {
-                            dest -= count2
-                            cursor2 -= count2
-                            length2 -= count2
-                            customDest = dest + 1
-                            customCursor = cursor2 + 1
-                            for (var i = 0; i < count2; i++) {
-                                array[customDest + i] = tmp[customCursor + i]
-                            }
-                            if (length2 <= 1) {
-                                exit = true
-                                break
-                            }
-                        }
-                        array[dest--] = array[cursor1--]
-                        if (--length1 === 0) {
-                            exit = true
-                            break
-                        }
-                        minGallop--
-                    } while (count1 >= DEFAULT_MIN_GALLOPING ||
-                        count2 >= DEFAULT_MIN_GALLOPING)
-                    if (exit) {
-                        break
-                    }
-                    if (minGallop < 0) {
-                        minGallop = 0
-                    }
-                    minGallop += 2
-                }
-                this.minGallop = minGallop
-                if (minGallop < 1) {
-                    this.minGallop = 1
-                }
-                if (length2 === 1) {
-                    dest -= length1
-                    cursor1 -= length1
-                    customDest = dest + 1
-                    customCursor = cursor1 + 1
-                    for (var i = length1 - 1; i >= 0; i--) {
-                        array[customDest + i] = array[customCursor + i]
-                    }
-                    array[dest] = tmp[cursor2]
-                } else if (length2 == 0) {
-                    throw new TimSortAssertion("mergeHigh preconditions were not respected")
-                } else {
-                    customCursor = dest - (length2 - 1)
-                    for (var i = 0; i < length2; i++) {
-                        array[customCursor + i] = tmp[i]
-                    }
-                }
-            }
-        }
-        if (self.length < 2 * DEFAULT_TMP_STORAGE_LENGTH) {
-            self.tmpStorageLength = self.length >>> 1
-        }
-        self.tmp = new Array(self.tmpStorageLength)
-        self.stackLength =
-            (self.length < 120 ? 5 :
-                self.length < 1542 ? 10 :
-                self.length < 119151 ? 19 : 40)
-        self.runStart = new Array(self.stackLength)
-        self.runLength = new Array(self.stackLength)
-        return self
-    }
-
-    function tim_sort(array, compare, lo, hi) {
-        if (!Array.isArray(array)) {
-            throw TypeError.$factory("Can only sort arrays")
-        }
-        if (!compare) {
-            compare = alphabeticalCompare
-        } else if (typeof compare !== "function") {
-            hi = lo
-            lo = compare
-            compare = alphabeticalCompare
-        }
-        if (!lo) {
-            lo = 0
-        }
-        if (!hi) {
-            hi = array.length
-        }
-        var remaining = hi - lo
-        if (remaining < 2) {
-            return
-        }
-        var runLength = 0
-        if (remaining < DEFAULT_MIN_MERGE) {
-            runLength = makeAscendingRun(array, lo, hi, compare)
-            binaryInsertionSort(array, lo, hi, lo + runLength, compare)
-            return
-        }
-        var ts = new TimSort(array, compare)
-        var minRun = minRunLength(remaining)
-        do {
-            runLength = makeAscendingRun(array, lo, hi, compare)
-            if (runLength < minRun) {
-                var force = remaining
-                if (force > minRun) {
-                    force = minRun
-                }
-                binaryInsertionSort(array, lo, lo + force, lo + runLength, compare)
-                runLength = force
-            }
-            ts.pushRun(lo, runLength)
-            ts.mergeRuns()
-            remaining -= runLength
-            lo += runLength
-        } while (remaining !== 0)
-        ts.forceMergeRuns()
-    }
-
-    function tim_sort_safe(array, compare) {
-        try {
-            tim_sort(array, compare, 0, array.length)
-        } catch (e) {
-            if (e.name == TIM_SORT_ASSERTION) {
-                array.sort(compare);
-            } else {
-                throw e;
-            }
-        }
-    }
-    $B.$TimSort = tim_sort_safe
-    $B.$AlphabeticalCompare = alphabeticalCompare
-})(__BRYTHON__);;
-(function($B) {
-    var _b_ = $B.builtins,
-        object = _b_.object,
-        getattr = $B.$getattr,
-        isinstance = _b_.isinstance,
-        $N = _b_.None
-
-    function check_not_tuple(self, attr) {
-        if (self.__class__ === tuple) {
-            throw _b_.AttributeError.$factory(
-                "'tuple' object has no attribute '" + attr + "'")
-        }
-    }
-
-    function $list() {
-        return list.$factory.apply(null, arguments)
-    }
-    var list = {
-        __class__: _b_.type,
-        __mro__: [object],
-        $infos: {
-            __module__: "builtins",
-            __name__: "list"
-        },
-        $is_class: true,
-        $native: true,
-        __dir__: object.__dir__
-    }
-    list.__add__ = function(self, other) {
-        if ($B.get_class(self) !== $B.get_class(other)) {
-            var this_name = $B.class_name(self)
-            var radd = $B.$getattr(other, '__radd__', null)
-            if (radd === null) {
-                throw _b_.TypeError.$factory('can only concatenate ' +
-                    this_name + ' (not "' + $B.class_name(other) +
-                    '") to ' + this_name)
-            }
-            return _b_.NotImplemented
-        }
-        var res = self.slice(),
-            is_js = other.$brython_class == "js"
-        for (const item of other) {
-            res.push(is_js ? $B.$JS2Py(item) : item)
-        }
-        res.__brython__ = true
-        if (isinstance(self, tuple)) {
-            res = tuple.$factory(res)
-        }
-        return res
-    }
-    list.__class_getitem__ = function(cls, item) {
-        if (!Array.isArray(item)) {
-            item = [item]
-        }
-        return $B.GenericAlias.$factory(cls, item)
-    }
-    list.__contains__ = function(self, item) {
-        var $ = $B.args("__contains__", 2, {
-                self: null,
-                item: null
-            }, ["self", "item"], arguments, {}, null, null),
-            self = $.self,
-            item = $.item
-        var _eq = function(other) {
-            return $B.rich_comp("__eq__", item, other)
-        }
-        var i = 0
-        while (i < self.length) {
-            if (_eq(self[i])) {
-                return true
-            }
-            i++
-        }
-        return false
-    }
-    list.__delitem__ = function(self, arg) {
-        if (isinstance(arg, _b_.int)) {
-            var pos = arg
-            if (arg < 0) {
-                pos = self.length + pos
-            }
-            if (pos >= 0 && pos < self.length) {
-                self.splice(pos, 1)
-                return $N
-            }
-            throw _b_.IndexError.$factory($B.class_name(self) +
-                " index out of range")
-        }
-        if (isinstance(arg, _b_.slice)) {
-            var step = arg.step
-            if (step === $N) {
-                step = 1
-            }
-            var start = arg.start
-            if (start === $N) {
-                start = step > 0 ? 0 : self.length
-            }
-            var stop = arg.stop
-            if (stop === $N) {
-                stop = step > 0 ? self.length : 0
-            }
-            if (start < 0) {
-                start = self.length + start
-            }
-            if (stop < 0) {
-                stop = self.length + stop
-            }
-            var res = [],
-                i = null,
-                pos = 0
-            if (step > 0) {
-                if (stop > start) {
-                    for (var i = start; i < stop; i += step) {
-                        if (self[i] !== undefined) {
-                            res[pos++] = i
-                        }
-                    }
-                }
-            } else {
-                if (stop < start) {
-                    for (var i = start; i > stop; i += step) {
-                        if (self[i] !== undefined) {
-                            res[pos++] = i
-                        }
-                    }
-                    res.reverse()
-                }
-            }
-            var i = res.length
-            while (i--) {
-                self.splice(res[i], 1)
-            }
-            return $N
-        }
-        if (_b_.hasattr(arg, "__int__") || _b_.hasattr(arg, "__index__")) {
-            list.__delitem__(self, _b_.int.$factory(arg))
-            return $N
-        }
-        throw _b_.TypeError.$factory($B.class_name(self) +
-            " indices must be integer, not " + $B.class_name(arg))
-    }
-    list.__eq__ = function(self, other) {
-        if (isinstance(self, list)) {
-            var klass = list
-        } else {
-            var klass = tuple
-        }
-        if (isinstance(other, klass)) {
-            if (other.length == self.length) {
-                var i = self.length
-                while (i--) {
-                    if (!$B.rich_comp("__eq__", self[i], other[i])) {
-                        return false
-                    }
-                }
-                return true
-            }
-        }
-        return _b_.NotImplemented
-    }
-    list.__getitem__ = function(self, key) {
-        $B.check_no_kw("__getitem__", self, key)
-        $B.check_nb_args("__getitem__", 2, arguments)
-        return list.$getitem(self, key)
-    }
-    list.$getitem = function(self, key) {
-        var klass = (self.__class__ || $B.get_class(self))
-        var factory = function(list_res) {
-            list_res.__class__ = klass
-            return list_res
-        }
-        var int_key
-        try {
-            int_key = $B.PyNumber_Index(key)
-        } catch (err) {}
-        if (int_key !== undefined) {
-            var items = self.valueOf(),
-                pos = int_key
-            if (int_key < 0) {
-                pos = items.length + pos
-            }
-            if (pos >= 0 && pos < items.length) {
-                return items[pos]
-            }
-            throw _b_.IndexError.$factory($B.class_name(self) +
-                " index out of range")
-        }
-        if (key.__class__ === _b_.slice || isinstance(key, _b_.slice)) {
-            if (key.start === _b_.None && key.stop === _b_.None &&
-                key.step === _b_.None) {
-                return self.slice()
-            }
-            var s = _b_.slice.$conv_for_seq(key, self.length)
-            var res = [],
-                i = null,
-                items = self.valueOf(),
-                pos = 0,
-                start = s.start,
-                stop = s.stop,
-                step = s.step
-            if (step > 0) {
-                if (stop <= start) {
-                    return factory(res)
-                }
-                for (var i = start; i < stop; i += step) {
-                    res[pos++] = items[i]
-                }
-                return factory(res)
-            } else {
-                if (stop > start) {
-                    return factory(res)
-                }
-                for (var i = start; i > stop; i += step) {
-                    res[pos++] = items[i]
-                }
-                return factory(res)
-            }
-        }
-        throw _b_.TypeError.$factory($B.class_name(self) +
-            " indices must be integer, not " + $B.class_name(key))
-    }
-    list.__ge__ = function(self, other) {
-        if (!isinstance(other, [list, _b_.tuple])) {
-            return _b_.NotImplemented
-        }
-        var i = 0
-        while (i < self.length) {
-            if (i >= other.length) {
-                return true
-            }
-            if ($B.rich_comp("__eq__", self[i], other[i])) {
-                i++
-            } else {
-                res = getattr(self[i], "__ge__")(other[i])
-                if (res === _b_.NotImplemented) {
-                    throw _b_.TypeError.$factory("unorderable types: " +
-                        $B.class_name(self[i]) + "() >= " +
-                        $B.class_name(other[i]) + "()")
-                } else {
-                    return res
-                }
-            }
-        }
-        return other.length == self.length
-    }
-    list.__gt__ = function(self, other) {
-        if (!isinstance(other, [list, _b_.tuple])) {
-            return _b_.NotImplemented
-        }
-        var i = 0
-        while (i < self.length) {
-            if (i >= other.length) {
-                return true
-            }
-            if ($B.rich_comp("__eq__", self[i], other[i])) {
-                i++
-            } else {
-                res = getattr(self[i], "__gt__")(other[i])
-                if (res === _b_.NotImplemented) {
-                    throw _b_.TypeError.$factory("unorderable types: " +
-                        $B.class_name(self[i]) + "() > " +
-                        $B.class_name(other[i]) + "()")
-                } else return res
-            }
-        }
-        return false
-    }
-    list.__hash__ = $N
-    list.__iadd__ = function() {
-        var $ = $B.args("__iadd__", 2, {
-            self: null,
-            x: null
-        }, ["self", "x"], arguments, {}, null, null)
-        var x = list.$factory($B.$iter($.x))
-        for (var i = 0; i < x.length; i++) {
-            $.self.push(x[i])
-        }
-        return $.self
-    }
-    list.__imul__ = function() {
-        var $ = $B.args("__imul__", 2, {
-                self: null,
-                x: null
-            }, ["self", "x"], arguments, {}, null, null),
-            x = $B.$GetInt($.x),
-            len = $.self.length,
-            pos = len
-        if (x == 0) {
-            list.clear($.self);
-            return $.self
-        }
-        for (var i = 1; i < x; i++) {
-            for (j = 0; j < len; j++) {
-                $.self[pos++] = $.self[j]
-            }
-        }
-        return $.self
-    }
-    list.__init__ = function(self, arg) {
-        var $ = $B.args('__init__', 1, {
-                self: null
-            }, ['self'], arguments, {}, 'args', null),
-            self = $.self,
-            args = $.args
-        if (args.length > 1) {
-            throw _b_.TypeError.$factory('expected at most 1 argument, got ' +
-                args.length)
-        }
-        var arg = args[0]
-        var len_func = $B.$call($B.$getattr(self, "__len__")),
-            pop_func = $B.$getattr(self, "pop", $N)
-        if (pop_func !== $N) {
-            pop_func = $B.$call(pop_func)
-            while (len_func()) {
-                pop_func()
-            }
-        }
-        if (arg === undefined) {
-            return $N
-        }
-        var arg = $B.$iter(arg),
-            next_func = $B.$call($B.$getattr(arg, "__next__")),
-            pos = len_func()
-        while (1) {
-            try {
-                var res = next_func()
-                self[pos++] = res
-            } catch (err) {
-                if (err.__class__ === _b_.StopIteration) {
-                    break
-                } else {
-                    throw err
-                }
-            }
-        }
-        return $N
-    }
-    var list_iterator = $B.make_iterator_class("list_iterator")
-    list_iterator.__reduce__ = list_iterator.__reduce_ex__ = function(self) {
-        return $B.fast_tuple([_b_.iter, $B.fast_tuple([list.$factory(self)]), 0])
-    }
-    list.__iter__ = function(self) {
-        return list_iterator.$factory(self)
-    }
-    list.__le__ = function(self, other) {
-        var res = list.__ge__(self, other)
-        if (res === _b_.NotImplemented) {
-            return res
-        }
-        return !res
-    }
-    list.__len__ = function(self) {
-        return self.length
-    }
-    list.__lt__ = function(self, other) {
-        if (!isinstance(other, [list, _b_.tuple])) {
-            return _b_.NotImplemented
-        }
-        var i = 0
-        while (i < self.length) {
-            if (i >= other.length) {
-                return false
-            }
-            if ($B.rich_comp("__eq__", self[i], other[i])) {
-                i++
-            } else {
-                res = getattr(self[i], "__lt__")(other[i])
-                if (res === _b_.NotImplemented) {
-                    throw _b_.TypeError.$factory("unorderable types: " +
-                        $B.class_name(self[i]) + "() >= " +
-                        $B.class_name(other[i]) + "()")
-                } else {
-                    return res
-                }
-            }
-        }
-        return other.length > self.length
-    }
-    list.__mul__ = function(self, other) {
-        if (isinstance(other, _b_.int)) {
-            other = _b_.int.numerator(other)
-            var res = [],
-                $temp = self.slice(),
-                len = $temp.length
-            for (var i = 0; i < other; i++) {
-                for (var j = 0; j < len; j++) {
-                    res.push($temp[j])
-                }
-            }
-            res.__class__ = self.__class__
-            return res
-        }
-        if (_b_.hasattr(other, "__int__") || _b_.hasattr(other, "__index__")) {
-            return list.__mul__(self, _b_.int.$factory(other))
-        }
-        var rmul = $B.$getattr(other, '__rmul__', null)
-        if (rmul === null) {
-            throw _b_.TypeError.$factory(`can't multiply sequence by non-int ` +
-                `of type '${$B.class_name(other)}'`)
-        }
-        return _b_.NotImplemented
-    }
-    list.__new__ = function(cls, ...args) {
-        if (cls === undefined) {
-            throw _b_.TypeError.$factory("list.__new__(): not enough arguments")
-        }
-        var res = []
-        res.__class__ = cls
-        res.__brython__ = true
-        res.__dict__ = $B.empty_dict()
-        return res
-    }
-
-    function __newobj__() {
-        var $ = $B.args('__newobj__', 0, {}, [], arguments, {}, 'args', null),
-            args = $.args
-        var res = args.slice(1)
-        res.__class__ = args[0]
-        return res
-    }
-    list.__reduce_ex__ = function(self) {
-        return $B.fast_tuple([__newobj__, $B.fast_tuple([self.__class__]), _b_.None, _b_.iter(self)])
-    }
-    list.__repr__ = function(self) {
-        $B.builtins_repr_check(list, arguments)
-        return list_repr(self)
-    }
-
-    function list_repr(self) {
-        if ($B.repr.enter(self)) {
-            return '[...]'
-        }
-        var _r = [],
-            res
-        for (var i = 0; i < self.length; i++) {
-            _r.push(_b_.repr(self[i]))
-        }
-        if (_b_.isinstance(self, tuple)) {
-            if (self.length == 1) {
-                res = "(" + _r[0] + ",)"
-            } else {
-                res = "(" + _r.join(", ") + ")"
-            }
-        } else {
-            res = "[" + _r.join(", ") + "]"
-        }
-        $B.repr.leave(self)
-        return res
-    }
-    list.__rmul__ = function(self, other) {
-        return list.__mul__(self, other)
-    }
-    list.__setattr__ = function(self, attr, value) {
-        if (self.__class__ === list || self.__class__ === tuple) {
-            var cl_name = $B.class_name(self)
-            if (list.hasOwnProperty(attr)) {
-                throw _b_.AttributeError.$factory("'" + cl_name +
-                    "' object attribute '" + attr + "' is read-only")
-            } else {
-                throw _b_.AttributeError.$factory(
-                    "'" + cl_name + " object has no attribute '" + attr + "'")
-            }
-        }
-        _b_.dict.$setitem(self.__dict__, attr, value)
-        return $N
-    }
-    list.__setitem__ = function() {
-        var $ = $B.args("__setitem__", 3, {
-                self: null,
-                key: null,
-                value: null
-            }, ["self", "key", "value"], arguments, {}, null, null),
-            self = $.self,
-            arg = $.key,
-            value = $.value
-        list.$setitem(self, arg, value)
-    }
-    list.$setitem = function(self, arg, value) {
-        if (typeof arg == "number" || isinstance(arg, _b_.int)) {
-            var pos = arg
-            if (arg < 0) {
-                pos = self.length + pos
-            }
-            if (pos >= 0 && pos < self.length) {
-                self[pos] = value
-            } else {
-                throw _b_.IndexError.$factory("list index out of range")
-            }
-            return $N
-        }
-        if (isinstance(arg, _b_.slice)) {
-            var s = _b_.slice.$conv_for_seq(arg, self.length)
-            if (arg.step === null) {
-                $B.set_list_slice(self, s.start, s.stop, value)
-            } else {
-                $B.set_list_slice_step(self, s.start, s.stop, s.step, value)
-            }
-            return $N
-        }
-        if (_b_.hasattr(arg, "__int__") || _b_.hasattr(arg, "__index__")) {
-            list.__setitem__(self, _b_.int.$factory(arg), value)
-            return $N
-        }
-        throw _b_.TypeError.$factory("list indices must be integer, not " +
-            $B.class_name(arg))
-    }
-    list.append = function(self, x) {
-        $B.check_no_kw("append", self, x)
-        $B.check_nb_args("append", 2, arguments)
-        self.push(x)
-        return $N
-    }
-    list.clear = function() {
-        var $ = $B.args("clear", 1, {
-            self: null
-        }, ["self"], arguments, {}, null, null)
-        while ($.self.length) {
-            $.self.pop()
-        }
-        return $N
-    }
-    list.copy = function() {
-        var $ = $B.args("copy", 1, {
-            self: null
-        }, ["self"], arguments, {}, null, null)
-        return $.self.slice()
-    }
-    list.count = function() {
-        var $ = $B.args("count", 2, {
-            self: null,
-            x: null
-        }, ["self", "x"], arguments, {}, null, null)
-        var res = 0,
-            _eq = function(other) {
-                return $B.rich_comp("__eq__", $.x, other)
-            },
-            i = $.self.length
-        while (i--) {
-            if (_eq($.self[i])) {
-                res++
-            }
-        }
-        return res
-    }
-    list.extend = function() {
-        var $ = $B.args("extend", 2, {
-            self: null,
-            t: null
-        }, ["self", "t"], arguments, {}, null, null)
-        var other = list.$factory($B.$iter($.t))
-        for (var i = 0; i < other.length; i++) {
-            $.self.push(other[i])
-        }
-        return $N
-    }
-    list.index = function() {
-        var missing = {},
-            $ = $B.args("index", 4, {
-                self: null,
-                x: null,
-                start: null,
-                stop: null
-            }, ["self", "x", "start", "stop"], arguments, {
-                start: 0,
-                stop: missing
-            }, null, null),
-            self = $.self,
-            start = $.start,
-            stop = $.stop
-        var _eq = function(other) {
-            return $B.rich_comp("__eq__", $.x, other)
-        }
-        if (start.__class__ === $B.long_int) {
-            start = parseInt(start.value) * (start.pos ? 1 : -1)
-        }
-        if (start < 0) {
-            start = Math.max(0, start + self.length)
-        }
-        if (stop === missing) {
-            stop = self.length
-        } else {
-            if (stop.__class__ === $B.long_int) {
-                stop = parseInt(stop.value) * (stop.pos ? 1 : -1)
-            }
-            if (stop < 0) {
-                stop = Math.min(self.length, stop + self.length)
-            }
-            stop = Math.min(stop, self.length)
-        }
-        for (var i = start; i < stop; i++) {
-            if (_eq(self[i])) {
-                return i
-            }
-        }
-        throw _b_.ValueError.$factory(_b_.repr($.x) + " is not in " +
-            $B.class_name(self))
-    }
-    list.insert = function() {
-        var $ = $B.args("insert", 3, {
-            self: null,
-            i: null,
-            item: null
-        }, ["self", "i", "item"], arguments, {}, null, null)
-        $.self.splice($.i, 0, $.item)
-        return $N
-    }
-    list.pop = function() {
-        var missing = {}
-        var $ = $B.args("pop", 2, {
-                self: null,
-                pos: null
-            }, ["self", "pos"], arguments, {
-                pos: missing
-            }, null, null),
-            self = $.self,
-            pos = $.pos
-        check_not_tuple(self, "pop")
-        if (pos === missing) {
-            pos = self.length - 1
-        }
-        pos = $B.$GetInt(pos)
-        if (pos < 0) {
-            pos += self.length
-        }
-        var res = self[pos]
-        if (res === undefined) {
-            throw _b_.IndexError.$factory("pop index out of range")
-        }
-        self.splice(pos, 1)
-        return res
-    }
-    list.remove = function() {
-        var $ = $B.args("remove", 2, {
-            self: null,
-            x: null
-        }, ["self", "x"], arguments, {}, null, null)
-        for (var i = 0, len = $.self.length; i < len; i++) {
-            if ($B.rich_comp("__eq__", $.self[i], $.x)) {
-                $.self.splice(i, 1)
-                return $N
-            }
-        }
-        throw _b_.ValueError.$factory(_b_.str.$factory($.x) + " is not in list")
-    }
-    list.reverse = function(self) {
-        var $ = $B.args("reverse", 1, {
-                self: null
-            }, ["self"], arguments, {}, null, null),
-            _len = $.self.length - 1,
-            i = parseInt($.self.length / 2)
-        while (i--) {
-            var buf = $.self[i]
-            $.self[i] = $.self[_len - i]
-            $.self[_len - i] = buf
-        }
-        return $N
-    }
-
-    function $partition(arg, array, begin, end, pivot) {
-        var piv = array[pivot]
-        array = swap(array, pivot, end - 1)
-        var store = begin
-        if (arg === null) {
-            if (array.$cl !== false) {
-                var le_func = _b_.getattr(array.$cl, "__le__")
-                for (var ix = begin; ix < end - 1; ++ix) {
-                    if (le_func(array[ix], piv)) {
-                        array = swap(array, store, ix);
-                        ++store
-                    }
-                }
-            } else {
-                for (var ix = begin; ix < end - 1; ++ix) {
-                    if (getattr(array[ix], "__le__")(piv)) {
-                        array = swap(array, store, ix)
-                            ++store
-                    }
-                }
-            }
-        } else {
-            var len = array.length
-            for (var ix = begin; ix < end - 1; ++ix) {
-                var x = arg(array[ix])
-                if (array.length !== len) {
-                    throw _b_.ValueError.$factory("list modified during sort")
-                }
-                if (getattr(x, "__le__")(arg(piv))) {
-                    array = swap(array, store, ix)
-                        ++store
-                }
-            }
-        }
-        array = swap(array, end - 1, store)
-        return store
-    }
-
-    function swap(_array, a, b) {
-        var tmp = _array[a]
-        _array[a] = _array[b]
-        _array[b] = tmp
-        return _array
-    }
-
-    function $qsort(arg, array, begin, end) {
-        if (end - 1 > begin) {
-            var pivot = begin + Math.floor(Math.random() * (end - begin))
-            pivot = $partition(arg, array, begin, end, pivot)
-            $qsort(arg, array, begin, pivot)
-            $qsort(arg, array, pivot + 1, end)
-        }
-    }
-
-    function $elts_class(self) {
-        if (self.length == 0) {
-            return null
-        }
-        var cl = $B.get_class(self[0]),
-            i = self.length
-        while (i--) {
-            if ($B.get_class(self[i]) !== cl) {
-                return false
-            }
-        }
-        return cl
-    }
-    list.sort = function(self) {
-        var $ = $B.args("sort", 1, {
-            self: null
-        }, ["self"], arguments, {}, null, "kw")
-        check_not_tuple(self, "sort")
-        var func = $N,
-            reverse = false,
-            kw_args = $.kw,
-            keys = _b_.list.$factory(_b_.dict.$$keys(kw_args))
-        for (var i = 0; i < keys.length; i++) {
-            if (keys[i] == "key") {
-                func = kw_args.$string_dict[keys[i]][0]
-            } else if (keys[i] == "reverse") {
-                reverse = kw_args.$string_dict[keys[i]][0]
-            } else {
-                throw _b_.TypeError.$factory("'" + keys[i] +
-                    "' is an invalid keyword argument for this function")
-            }
-        }
-        if (self.length == 0) {
-            return
-        }
-        if (func !== $N) {
-            func = $B.$call(func)
-        }
-        self.$cl = $elts_class(self)
-        var cmp = null;
-        if (func === $N && self.$cl === _b_.str) {
-            if (reverse) {
-                cmp = function(b, a) {
-                    return $B.$AlphabeticalCompare(a, b)
-                }
-            } else {
-                cmp = function(a, b) {
-                    return $B.$AlphabeticalCompare(a, b)
-                }
-            }
-        } else if (func === $N && self.$cl === _b_.int) {
-            if (reverse) {
-                cmp = function(b, a) {
-                    return a - b
-                }
-            } else {
-                cmp = function(a, b) {
-                    return a - b
-                }
-            }
-        } else {
-            if (func === $N) {
-                if (reverse) {
-                    cmp = function(b, a) {
-                        res = getattr(a, "__lt__")(b)
-                        if (res === _b_.NotImplemented) {
-                            throw _b_.TypeError.$factory("unorderable types: " +
-                                $B.class_name(b) + "() < " +
-                                $B.class_name(a) + "()")
-                        }
-                        if (res) {
-                            if (a == b) {
-                                return 0
-                            }
-                            return -1
-                        }
-                        return 1
-                    }
-                } else {
-                    cmp = function(a, b) {
-                        res = getattr(a, "__lt__")(b)
-                        if (res === _b_.NotImplemented) {
-                            throw _b_.TypeError.$factory("unorderable types: " +
-                                $B.class_name(a) + "() < " +
-                                $B.class_name(b) + "()")
-                        }
-                        if (res) {
-                            if (a == b) {
-                                return 0
-                            }
-                            return -1
-                        }
-                        return 1
-                    }
-                }
-            } else {
-                if (reverse) {
-                    cmp = function(b, a) {
-                        var _a = func(a),
-                            _b = func(b)
-                        res = getattr(_a, "__lt__")(_b)
-                        if (res === _b_.NotImplemented) {
-                            throw _b_.TypeError.$factory("unorderable types: " +
-                                $B.class_name(b) + "() < " +
-                                $B.class_name(a) + "()")
-                        }
-                        if (res) {
-                            if (_a == _b) {
-                                return 0
-                            }
-                            return -1
-                        }
-                        return 1
-                    }
-                } else {
-                    cmp = function(a, b) {
-                        var _a = func(a),
-                            _b = func(b)
-                        res = $B.$getattr(_a, "__lt__")(_b)
-                        if (res === _b_.NotImplemented) {
-                            throw _b_.TypeError.$factory("unorderable types: " +
-                                $B.class_name(a) + "() < " +
-                                $B.class_name(b) + "()")
-                        }
-                        if (res) {
-                            if (_a == _b) {
-                                return 0
-                            }
-                            return -1
-                        }
-                        return 1
-                    }
-                }
-            }
-        }
-        $B.$TimSort(self, cmp)
-        return (self.__brython__ ? $N : self)
-    }
-    $B.$list = function(t) {
-        t.__brython__ = true
-        t.__class__ = _b_.list
-        return t
-    }
-    list.$factory = function() {
-        if (arguments.length == 0) {
-            return []
-        }
-        var $ = $B.args("list", 1, {
-                obj: null
-            }, ["obj"], arguments, {}, null, null),
-            obj = $.obj
-        if (Array.isArray(obj)) {
-            obj = obj.slice()
-            obj.__brython__ = true;
-            if (obj.__class__ == tuple) {
-                var res = obj.slice()
-                res.__class__ = list
-                return res
-            }
-            return obj
-        }
-        var res = [],
-            pos = 0,
-            arg = $B.$iter(obj),
-            next_func = $B.$call(getattr(arg, "__next__"))
-        while (1) {
-            try {
-                res[pos++] = next_func()
-            } catch (err) {
-                if (!isinstance(err, _b_.StopIteration)) {
-                    throw err
-                }
-                break
-            }
-        }
-        res.__brython__ = true
-        return res
-    }
-    $B.set_func_names(list, "builtins")
-    list.__class_getitem__ = _b_.classmethod.$factory(list.__class_getitem__)
-    var JSArray = $B.JSArray = $B.make_class("JSArray", function(array) {
-        return {
-            __class__: JSArray,
-            js: array
-        }
-    })
-    JSArray.__repr__ = JSArray.__str__ = function() {
-        return "<JSArray object>"
-    }
-
-    function make_args(args) {
-        var res = [args[0].js]
-        for (var i = 1, len = args.length; i < len; i++) {
-            res.push(args[i])
-        }
-        return res
-    }
-    for (var attr in list) {
-        if ($B.JSArray[attr] !== undefined) {
-            continue
-        }
-        if (typeof list[attr] == "function") {
-            $B.JSArray[attr] = (function(fname) {
-                return function() {
-                    return $B.$JS2Py(list[fname].apply(null, make_args(arguments)))
-                }
-            })(attr)
-        }
-    }
-    $B.set_func_names($B.JSArray, "builtins")
-
-    function $tuple(arg) {
-        return arg
-    }
-    var tuple = {
-        __class__: _b_.type,
-        __mro__: [object],
-        $infos: {
-            __module__: "builtins",
-            __name__: "tuple"
-        },
-        $is_class: true,
-        $native: true
-    }
-    var tuple_iterator = $B.make_iterator_class("tuple_iterator")
-    tuple.__iter__ = function(self) {
-        return tuple_iterator.$factory(self)
-    }
-    tuple.$factory = function() {
-        var obj = list.$factory(...arguments)
-        obj.__class__ = tuple
-        return obj
-    }
-    $B.fast_tuple = function(array) {
-        array.__class__ = tuple
-        array.__brython__ = true
-        array.__dict__ = $B.empty_dict()
-        return array
-    }
-    for (var attr in list) {
-        switch (attr) {
-            case "__delitem__":
-            case "__iadd__":
-            case "__imul__":
-            case "__setitem__":
-            case "append":
-            case "extend":
-            case "insert":
-            case "remove":
-            case "reverse":
-                break
-            default:
-                if (tuple[attr] === undefined) {
-                    if (typeof list[attr] == "function") {
-                        tuple[attr] = (function(x) {
-                            return function() {
-                                return list[x].apply(null, arguments)
-                            }
-                        })(attr)
-                    }
-                }
-        }
-    }
-    tuple.__eq__ = function(self, other) {
-        if (other === undefined) {
-            return self === tuple
-        }
-        return list.__eq__(self, other)
-    }
-
-    function c_mul(a, b) {
-        s = ((parseInt(a) * b) & 0xFFFFFFFF).toString(16)
-        return parseInt(s.substr(0, s.length - 1), 16)
-    }
-    tuple.__hash__ = function(self) {
-        var x = 0x3456789
-        for (var i = 0, len = self.length; i < len; i++) {
-            var y = _b_.hash(self[i])
-            x = c_mul(1000003, x) ^ y & 0xFFFFFFFF
-        }
-        return x
-    }
-    tuple.__init__ = function() {
-        return $N
-    }
-    tuple.__new__ = function(cls, ...args) {
-        if (cls === undefined) {
-            throw _b_.TypeError.$factory("list.__new__(): not enough arguments")
-        }
-        var self = []
-        self.__class__ = cls
-        self.__brython__ = true
-        self.__dict__ = $B.empty_dict()
-        var arg = $B.$iter(args[0]),
-            next_func = $B.$call(getattr(arg, "__next__"))
-        while (1) {
-            try {
-                var item = next_func()
-                self.push(item)
-            } catch (err) {
-                if (err.__class__ === _b_.StopIteration) {
-                    break
-                } else {
-                    throw err
-                }
-            }
-        }
-        return self
-    }
-    tuple.__reduce_ex__ = function(self) {
-        return $B.fast_tuple([__newobj__, $B.fast_tuple([self.__class__].concat(self.slice())), _b_.None, _b_.None])
-    }
-    tuple.__repr__ = function(self) {
-        $B.builtins_repr_check(tuple, arguments)
-        return list_repr(self)
-    }
-    $B.set_func_names(tuple, "builtins")
-    _b_.list = list
-    _b_.tuple = tuple
-    _b_.object.__bases__ = tuple.$factory()
-})(__BRYTHON__);
+})(__BRYTHON__);
 
 var $B = __BRYTHON__
 $B.unicode = {
     "Cc": [
         [0, 32],
         [127, 33]
     ],
@@ -30146,49 +26754,104 @@
             code = s.charCodeAt(i)
             if (code >= 0xD800 && code <= 0xDBFF) {
                 return true
             }
         }
         return false
     }
+    $B.String = function(s) {
+        var codepoints = [],
+            surrogates = [],
+            j = 0
+        for (var i = 0, len = s.length; i < len; i++) {
+            var cp = s.codePointAt(i)
+            if (cp >= 0x10000) {
+                surrogates.push(j)
+                i++
+            }
+            j++
+        }
+        if (surrogates.length == 0) {
+            return s
+        }
+        var res = new String(s)
+        res.__class__ = str
+        res.surrogates = surrogates
+        return res
+    }
+
+    function pypos2jspos(s, pypos) {
+        if (s.surrogates === undefined) {
+            return pypos
+        }
+        var nb = 0
+        while (s.surrogates[nb] < pypos) {
+            nb++
+        }
+        return pypos + nb
+    }
+
+    function jspos2pypos(s, jspos) {
+        if (s.surrogates === undefined) {
+            return jspos
+        }
+        var nb = 0
+        while (s.surrogates[nb] + nb < jspos) {
+            nb++
+        }
+        return jspos - nb
+    }
     var str = {
         __class__: _b_.type,
         __dir__: _b_.object.__dir__,
         $infos: {
             __module__: "builtins",
             __name__: "str"
         },
         $is_class: true,
         $native: true
     }
 
     function normalize_start_end($) {
+        var len
+        if (typeof $.self == "string") {
+            len = $.self.length
+        } else {
+            len = str.__len__($.self)
+        }
         if ($.start === null || $.start === _b_.None) {
             $.start = 0
         } else if ($.start < 0) {
-            $.start += $.self.length
+            $.start += len
             $.start = Math.max(0, $.start)
         }
         if ($.end === null || $.end === _b_.None) {
-            $.end = $.self.length
+            $.end = len
         } else if ($.end < 0) {
-            $.end += $.self.length
+            $.end += len
             $.end = Math.max(0, $.end)
         }
         if (!_b_.isinstance($.start, _b_.int) || !_b_.isinstance($.end, _b_.int)) {
             throw _b_.TypeError.$factory("slice indices must be integers " +
                 "or None or have an __index__ method")
         }
+        if ($.self.surrogates) {
+            $.js_start = pypos2jspos($.self, $.start)
+            $.js_end = pypos2jspos($.self, $.end)
+        }
     }
 
     function reverse(s) {
         return s.split("").reverse().join("")
     }
 
     function check_str(obj, prefix) {
+        if (obj instanceof String || typeof obj == "string") {
+            return
+        }
         if (!_b_.isinstance(obj, str)) {
             throw _b_.TypeError.$factory((prefix || '') +
                 "must be str, not " + $B.class_name(obj))
         }
     }
 
     function to_chars(s) {
@@ -30202,54 +26865,58 @@
                 chars.push(s.charAt(i))
             }
         }
         return chars
     }
 
     function to_codepoints(s) {
+        if (s.codepoints) {
+            return s.codepoints
+        }
         var cps = []
         for (var i = 0, len = s.length; i < len; i++) {
             var code = s.charCodeAt(i)
             if (code >= 0xD800 && code <= 0xDBFF) {
                 var v = 0x10000
                 v += (code & 0x03FF) << 10
                 v += (s.charCodeAt(i + 1) & 0x03FF)
                 cps.push(v)
                 i++
             } else {
                 cps.push(code)
             }
         }
-        return cps
+        return s.codepoints = cps
     }
     str.__add__ = function(self, other) {
-        if (!(typeof other === "string")) {
+        if (!_b_.isinstance(other, str)) {
             try {
                 return $B.$getattr(other, "__radd__")(self)
             } catch (err) {
                 throw _b_.TypeError.$factory("Can't convert " +
                     $B.class_name(other) + " to str implicitly")
             }
         }
-        return self + other
+        return $B.String(self + other)
     }
     str.__contains__ = function(self, item) {
         if (!_b_.isinstance(item, str)) {
             throw _b_.TypeError.$factory("'in <string>' requires " +
                 "string as left operand, not " + item.__class__)
         }
-        if (typeof item == "string") {
+        if (item.__class__ === str || _b_.isinstance(item, str)) {
             var nbcar = item.length
         } else {
             var nbcar = _b_.len(item)
         }
         if (nbcar == 0) {
             return true
         }
-        if (self.length == 0) {
+        var len = self.length
+        if (len == 0) {
             return nbcar == 0
         }
         for (var i = 0, len = self.length; i < len; i++) {
             if (self.substr(i, nbcar) == item) {
                 return true
             }
         }
@@ -30285,48 +26952,53 @@
         if (fmt.precision) {
             self = self.substr(0, fmt.precision)
         }
         fmt.align = fmt.align || "<"
         return $B.format_width(preformat(self, fmt), fmt)
     }
     str.__getitem__ = function(self, arg) {
-        var chars = to_chars(self)
+        var len = str.__len__(self)
         if (_b_.isinstance(arg, _b_.int)) {
             var pos = arg
             if (arg < 0) {
-                pos += self.length
+                pos += len
             }
-            if (pos >= 0 && pos < chars.length) {
-                return chars[pos]
+            if (pos >= 0 && pos < len) {
+                var jspos = pypos2jspos(self, pos)
+                if (self.codePointAt(jspos) >= 0x10000) {
+                    return $B.String(self.substr(jspos, 2))
+                } else {
+                    return self[jspos]
+                }
             }
             throw _b_.IndexError.$factory("string index out of range")
         }
         if (_b_.isinstance(arg, _b_.slice)) {
-            var s = _b_.slice.$conv_for_seq(arg, self.length),
-                start = s.start,
-                stop = s.stop,
+            var s = _b_.slice.$conv_for_seq(arg, len),
+                start = pypos2jspos(self, s.start),
+                stop = pypos2jspos(self, s.stop),
                 step = s.step
             var res = "",
                 i = null
             if (step > 0) {
                 if (stop <= start) {
                     return ""
                 }
                 for (var i = start; i < stop; i += step) {
-                    res += chars[i]
+                    res += self[i]
                 }
             } else {
                 if (stop >= start) {
                     return ''
                 }
                 for (var i = start; i > stop; i += step) {
-                    res += chars[i]
+                    res += self[i]
                 }
             }
-            return res
+            return $B.String(res)
         }
         if (_b_.isinstance(arg, _b_.bool)) {
             return self.__getitem__(_b_.int.$factory(arg))
         }
         throw _b_.TypeError.$factory("string indices must be integers")
     }
     var prefix = 2,
@@ -30356,15 +27028,20 @@
             return str_hash_cache[self]
         }
         str.$nb_str_hash_cache++
         if (str.$nb_str_hash_cache > 100000) {
             str.$nb_str_hash_cache = 0
             str_hash_cache = {}
         }
-        return str_hash_cache[self] = fnv(to_codepoints(self))
+        try {
+            return str_hash_cache[self] = fnv(to_codepoints(self))
+        } catch (err) {
+            console.log('error hash, cps', self, to_codepoints(self))
+            throw err
+        }
     }
     str.__init__ = function(self, arg) {
         self.valueOf = function() {
             return arg
         }
         self.toString = function() {
             return arg
@@ -30372,15 +27049,22 @@
         return _b_.None
     }
     var str_iterator = $B.make_iterator_class("str_iterator")
     str.__iter__ = function(self) {
         return str_iterator.$factory(to_chars(self))
     }
     str.__len__ = function(self) {
-        return [...self].length
+        if (self.surrogates === undefined) {
+            return self.length
+        }
+        if (self.len !== undefined) {
+            return self.len
+        }
+        var len = self.len = self.valueOf().length - self.surrogates.length
+        return len
     }
     var kwarg_key = new RegExp("([^\\)]*)\\)")
     var NotANumber = function() {
         this.name = "NotANumber"
     }
     var number_check = function(s) {
         if (!_b_.isinstance(s, [_b_.int, _b_.float])) {
@@ -30969,15 +27653,15 @@
             throw _b_.TypeError.$factory(
                 "Can't multiply sequence by non-int of type '" +
                 $B.class_name($.other) + "'")
         }
         return $.self.valueOf().repeat($.other)
     }
     str.__ne__ = function(self, other) {
-        return other !== self.valueOf()
+        return other.valueOf() !== self.valueOf()
     }
 
     function __newobj__() {
         var $ = $B.args('__newobj__', 0, {}, [], arguments, {}, 'args', null),
             args = $.args
         var res = args[1]
         res.__class__ = args[0]
@@ -31157,15 +27841,15 @@
             sub: null,
             start: null,
             stop: null
         }, ["self", "sub", "start", "stop"], arguments, {
             start: null,
             stop: null
         }, null, null)
-        if (!(typeof $.sub == "string")) {
+        if (!(typeof $.sub.valueOf() == "string")) {
             throw _b_.TypeError.$factory("Can't convert '" + $B.class_name($.sub) +
                 "' object to str implicitly")
         }
         var substr = $.self
         if ($.start !== null) {
             var _slice
             if ($.stop !== null) {
@@ -31302,37 +27986,29 @@
             end: null
         }, ["self", "sub", "start", "end"], arguments, {
             start: 0,
             end: null
         }, null, null)
         check_str($.sub)
         normalize_start_end($)
-        if (!_b_.isinstance($.start, _b_.int) ||
-            !_b_.isinstance($.end, _b_.int)) {
-            throw _b_.TypeError.$factory("slice indices must be " +
-                "integers or None or have an __index__ method")
-        }
-        var s = ""
-        for (var i = $.start; i < $.end; i++) {
-            s += $.self.charAt(i)
-        }
-        var len = str.__len__($.self)
-        if ($.sub.length == 0 && $.start == len) {
+        var len = str.__len__($.self),
+            sub_len = str.__len__($.sub)
+        if (sub_len == 0 && $.start == len) {
             return len
         }
-        if (s.length + $.sub.length == 0) {
+        if (len + sub_len == 0) {
             return -1
         }
-        var last_search = s.length - $.sub.length
-        for (var i = 0; i <= last_search; i++) {
-            if (s.substr(i, $.sub.length) == $.sub) {
-                return $.start + str.__len__(s.substr(0, i))
-            }
+        var js_start = pypos2jspos($.self, $.start),
+            js_end = pypos2jspos($.self, $.end),
+            ix = $.self.substring(js_start, js_end).indexOf($.sub)
+        if (ix == -1) {
+            return -1
         }
-        return -1
+        return jspos2pypos($.self, js_start + ix)
     }
     $B.parse_format = function(fmt_string) {
         var elts = fmt_string.split(":"),
             name, conv, spec, name_ext = []
         if (elts.length == 1) {
             name = fmt_string
         } else {
@@ -31740,29 +28416,38 @@
         var $ = $B.args("lower", 1, {
             self: null
         }, ["self"], arguments, {}, null, null)
         return self.toLowerCase()
     }
     str.lstrip = function(self, x) {
         var $ = $B.args("lstrip", 2, {
-            self: null,
-            chars: null
-        }, ["self", "chars"], arguments, {
-            chars: _b_.None
-        }, null, null)
-        if ($.chars === _b_.None) {
-            return $.self.trimLeft()
+                self: null,
+                chars: null
+            }, ["self", "chars"], arguments, {
+                chars: _b_.None
+            }, null, null),
+            self = $.self,
+            chars = $.chars
+        if (chars === _b_.None) {
+            return self.trimStart()
         }
-        var chars = to_chars(self)
-        for (var i = 0, len = chars.length; i < len; i++) {
-            if ($.chars.indexOf(chars[i]) === -1) {
-                return chars.slice(i).join('')
+        while (self.length > 0) {
+            var flag = false
+            for (var char of chars) {
+                if (self.startsWith(char)) {
+                    self = self.substr(char.length)
+                    flag = true
+                    break
+                }
+            }
+            if (!flag) {
+                return $.self.surrogates ? $B.String(self) : self
             }
         }
-        return ""
+        return ''
     }
     str.maketrans = function() {
         var $ = $B.args("maketrans", 3, {
             x: null,
             y: null,
             z: null
         }, ["x", "y", "z"], arguments, {
@@ -31877,23 +28562,23 @@
         }
         return str
     }
     str.replace = function(self, old, _new, count) {
         var $ = $B.args("replace", 4, {
                 self: null,
                 old: null,
-                $$new: null,
+                new: null,
                 count: null
-            }, ["self", "old", "$$new", "count"], arguments, {
+            }, ["self", "old", "new", "count"], arguments, {
                 count: -1
             }, null, null),
             count = $.count,
             self = $.self,
             old = $.old,
-            _new = $.$$new
+            _new = $.new
         check_str(old, "replace() argument 1 ")
         check_str(_new, "replace() argument 2 ")
         if (!_b_.isinstance(count, [_b_.int, _b_.float])) {
             throw _b_.TypeError.$factory("'" + $B.class_name(count) +
                 "' object cannot be interpreted as an integer")
         } else if (_b_.isinstance(count, _b_.float)) {
             throw _b_.TypeError.$factory("integer argument expected, got float")
@@ -31941,42 +28626,41 @@
             res = res.substr(0, pos) + _new + res.substr(pos + old.length)
             pos = pos + _new.length
             count--
         }
         return res
     }
     str.rfind = function(self, substr) {
-        if (arguments.length == 2 && typeof substr == "string") {
-            return self.lastIndexOf(substr)
-        }
         var $ = $B.args("rfind", 4, {
             self: null,
             sub: null,
             start: null,
             end: null
         }, ["self", "sub", "start", "end"], arguments, {
             start: 0,
             end: null
         }, null, null)
         normalize_start_end($)
         check_str($.sub)
-        if ($.sub.length == 0) {
-            if ($.start > $.self.length) {
+        var len = str.__len__($.self),
+            sub_len = str.__len__($.sub)
+        if (sub_len == 0) {
+            if ($.js_start > len) {
                 return -1
             } else {
                 return str.__len__($.self)
             }
         }
-        var sublen = $.sub.length
-        for (var i = $.end - sublen; i >= $.start; i--) {
-            if ($.self.substr(i, sublen) == $.sub) {
-                return str.__len__($.self.substr(0, i))
-            }
+        var js_start = pypos2jspos($.self, $.start),
+            js_end = pypos2jspos($.self, $.end),
+            ix = $.self.substring(js_start, js_end).lastIndexOf($.sub)
+        if (ix == -1) {
+            return -1
         }
-        return -1
+        return jspos2pypos($.self, js_start + ix) - $.start
     }
     str.rindex = function() {
         var res = str.rfind.apply(null, arguments)
         if (res == -1) {
             throw _b_.ValueError.$factory("substring not found")
         }
         return res
@@ -31985,18 +28669,19 @@
         var $ = $B.args("rjust", 3, {
             self: null,
             width: null,
             fillchar: null
         }, ["self", "width", "fillchar"], arguments, {
             fillchar: " "
         }, null, null)
-        if ($.width <= self.length) {
+        var len = str.__len__(self)
+        if ($.width <= len) {
             return self
         }
-        return $.fillchar.repeat($.width - self.length) + self
+        return $B.String($.fillchar.repeat($.width - len) + self)
     }
     str.rpartition = function(self, sep) {
         var $ = $B.args("rpartition", 2, {
             self: null,
             sep: null
         }, ["self", "sep"], arguments, {}, null, null)
         check_str($.sep)
@@ -32025,29 +28710,38 @@
         for (var i = 0; i < rev_res.length; i++) {
             rev_res[i] = reverse(rev_res[i])
         }
         return rev_res
     }
     str.rstrip = function(self, x) {
         var $ = $B.args("rstrip", 2, {
-            self: null,
-            chars: null
-        }, ["self", "chars"], arguments, {
-            chars: _b_.None
-        }, null, null)
-        if ($.chars === _b_.None) {
-            return $.self.trimRight()
+                self: null,
+                chars: null
+            }, ["self", "chars"], arguments, {
+                chars: _b_.None
+            }, null, null),
+            self = $.self,
+            chars = $.chars
+        if (chars === _b_.None) {
+            return self.trimEnd()
         }
-        var chars = to_chars(self)
-        for (var j = chars.length - 1; j >= 0; j--) {
-            if ($.chars.indexOf(chars[j]) == -1) {
-                return chars.slice(0, j + 1).join('')
+        while (self.length > 0) {
+            var flag = false
+            for (var char of chars) {
+                if (self.endsWith(char)) {
+                    self = self.substr(0, self.length - char.length)
+                    flag = true
+                    break
+                }
+            }
+            if (!flag) {
+                return $.self.surrogates ? $B.String(self) : self
             }
         }
-        return ""
+        return ''
     }
     str.split = function() {
         var $ = $B.args("split", 3, {
                 self: null,
                 sep: null,
                 maxsplit: null
             }, ["self", "sep", "maxsplit"], arguments, {
@@ -32095,38 +28789,38 @@
                 if (pos > self.length - 1) {
                     if (name) {
                         res.push(name)
                     }
                     break
                 }
             }
-            return res
+            return res.map($B.String)
         } else {
             var res = [],
                 s = "",
                 seplen = sep.length
             if (maxsplit == 0) {
                 return [self]
             }
             while (pos < self.length) {
                 if (self.substr(pos, seplen) == sep) {
                     res.push(s)
                     pos += seplen
                     if (maxsplit > -1 && res.length >= maxsplit) {
                         res.push(self.substr(pos))
-                        return res
+                        return res.map($B.String)
                     }
                     s = ""
                 } else {
                     s += self.charAt(pos)
                     pos++
                 }
             }
             res.push(s)
-            return res
+            return res.map($B.String)
         }
     }
     str.splitlines = function(self) {
         var $ = $B.args('splitlines', 2, {
             self: null,
             keepends: null
         }, ['self', 'keepends'], arguments, {
@@ -32154,15 +28848,15 @@
             } else {
                 pos++
             }
         }
         if (start < self.length) {
             res.push(self.slice(start))
         }
-        return res
+        return res.map($B.String)
     }
     str.startswith = function() {
         var $ = $B.args("startswith", 4, {
             self: null,
             prefix: null,
             start: null,
             end: null
@@ -32171,17 +28865,16 @@
             end: null
         }, null, null)
         normalize_start_end($)
         var prefixes = $.prefix
         if (!_b_.isinstance(prefixes, _b_.tuple)) {
             prefixes = [prefixes]
         }
-        var s = to_chars($.self).slice($.start, $.end).join('')
-        for (var i = 0, len = prefixes.length; i < len; i++) {
-            var prefix = prefixes[i]
+        var s = $.self.substring($.js_start, $.js_end)
+        for (var prefix of prefixes) {
             if (!_b_.isinstance(prefix, str)) {
                 throw _b_.TypeError.$factory("endswith first arg must be str " +
                     "or a tuple of str, not int")
             }
             if (s.substr(0, prefix.length) == prefix) {
                 return true
             }
@@ -32194,26 +28887,15 @@
             chars: null
         }, ["self", "chars"], arguments, {
             chars: _b_.None
         }, null, null)
         if ($.chars === _b_.None) {
             return $.self.trim()
         }
-        var chars = to_chars($.self)
-        for (var i = 0; i < chars.length; i++) {
-            if ($.chars.indexOf(chars[i]) == -1) {
-                break
-            }
-        }
-        for (var j = chars.length - 1; j >= i; j--) {
-            if ($.chars.indexOf(chars[j]) == -1) {
-                break
-            }
-        }
-        return chars.slice(i, j + 1).join('')
+        return str.rstrip(str.lstrip($.self, $.chars), $.chars)
     }
     str.swapcase = function(self) {
         var $ = $B.args("swapcase", 1, {
                 self
             }, ["self"], arguments, {}, null, null),
             res = "",
             cp
@@ -32315,21 +28997,19 @@
                 }, ["arg", "encoding", "errors"], arguments, {
                     encoding: "utf-8",
                     errors: "strict"
                 }, null, null),
                 encoding = $.encoding,
                 errors = $.errors
         }
-        switch (typeof arg) {
-            case "string":
-                return str.__str__(arg)
-            case "number":
-                if (isFinite(arg)) {
-                    return arg.toString()
-                }
+        if (typeof arg == "string" || arg instanceof String ||
+            typeof arg == "number") {
+            if (isFinite(arg)) {
+                return arg.toString()
+            }
         }
         try {
             if (arg.$is_class || arg.$factory) {
                 var func = $B.$getattr(arg.__class__, "__str__")
                 return func(arg)
             }
             if (arg.__class__ && arg.__class__ === _b_.bytes &&
@@ -32544,25 +29224,26 @@
     }
     $B.parse_fstring = function(string) {
         var elts = [],
             pos = 0,
             current = "",
             ctype = null,
             nb_braces = 0,
-            car
+            expr_start, car
         while (pos < string.length) {
             if (ctype === null) {
                 car = string.charAt(pos)
                 if (car == "{") {
                     if (string.charAt(pos + 1) == "{") {
                         ctype = "string"
                         current = "{"
                         pos += 2
                     } else {
                         ctype = "expression"
+                        expr_start = pos + 1
                         nb_braces = 1
                         pos++
                     }
                 } else if (car == "}") {
                     if (string.charAt(pos + 1) == car) {
                         ctype = "string"
                         current = "}"
@@ -32582,14 +29263,15 @@
                     if (car == "{") {
                         if (string.charAt(i + 1) == "{") {
                             current += "{"
                             i += 2
                         } else {
                             elts.push(current)
                             ctype = "expression"
+                            expr_start = i + 1
                             pos = i + 1
                             break
                         }
                     } else if (car == "}") {
                         if (string.charAt(i + 1) == car) {
                             current += car
                             i += 2
@@ -32678,16 +29360,40 @@
                             } else {
                                 current.expression += string.substring(i, end + 1)
                                 i = end + 1
                             }
                         }
                     } else if (nb_paren == 0 && car == ":") {
                         current.fmt = true
-                        current.expression += car
-                        i++
+                        var cb = 0,
+                            fmt_complete = false
+                        for (var j = i + 1; j < string.length; j++) {
+                            if (string[j] == '{') {
+                                if (string[j + 1] == '{') {
+                                    j += 2
+                                } else {
+                                    cb++
+                                }
+                            } else if (string[j] == '}') {
+                                if (string[j + 1] == '}') {
+                                    j += 2
+                                } else if (cb == 0) {
+                                    fmt_complete = true
+                                    var fmt = string.substring(i + 1, j)
+                                    current.format = $B.parse_fstring(fmt)
+                                    i = j
+                                    break
+                                } else {
+                                    cb--
+                                }
+                            }
+                        }
+                        if (!fmt_complete) {
+                            fstring_error('invalid format', pos)
+                        }
                     } else if (car == "=") {
                         var ce = current.expression,
                             last_char = ce.charAt(ce.length - 1),
                             last_char_re = ('()'.indexOf(last_char) > -1 ? "\\" : "") + last_char
                         if (ce.length == 0 ||
                             nb_paren > 0 ||
                             string.charAt(i + 1) == "=" ||
@@ -32717,14 +29423,23 @@
                     fstring_error("f-string: expected '}'", pos)
                 }
             }
         }
         if (current.length > 0) {
             elts.push(current)
         }
+        for (var elt of elts) {
+            if (typeof elt == "object") {
+                if (elt.fmt_pos !== undefined &&
+                    elt.expression.charAt(elt.fmt_pos) != ':') {
+                    console.log('mauvais format', string, elts)
+                    throw Error()
+                }
+            }
+        }
         return elts
     }
     var _chr = $B.codepoint2jsstring = function(i) {
         if (i >= 0x10000 && i <= 0x10FFFF) {
             var code = (i - 0x10000)
             return String.fromCodePoint(0xD800 | (code >> 10)) +
                 String.fromCodePoint(0xDC00 | (code & 0x3FF))
@@ -32739,16 +29454,3624 @@
         var code = 0x10000
         code += (c.charCodeAt(0) & 0x03FF) << 10
         code += (c.charCodeAt(1) & 0x03FF)
         return code
     }
 })(__BRYTHON__);;
 (function($B) {
-    var bltns = $B.InjectBuiltins()
-    eval(bltns)
+    var _b_ = $B.builtins
+
+    function $err(op, other) {
+        var msg = "unsupported operand type(s) for " + op +
+            " : 'int' and '" + $B.class_name(other) + "'"
+        throw _b_.TypeError.$factory(msg)
+    }
+
+    function int_value(obj) {
+        if (typeof obj == "boolean") {
+            return obj ? 1 : 0
+        }
+        return obj.$brython_value !== undefined ? obj.$brython_value : obj
+    }
+    var int = {
+        __class__: _b_.type,
+        __dir__: _b_.object.__dir__,
+        __mro__: [_b_.object],
+        $infos: {
+            __module__: "builtins",
+            __name__: "int"
+        },
+        $is_class: true,
+        $native: true,
+        $descriptors: {
+            "numerator": true,
+            "denominator": true,
+            "imag": true,
+            "real": true
+        }
+    }
+    int.as_integer_ratio = function() {
+        var $ = $B.args("as_integer_ratio", 1, {
+            self: null
+        }, ["self"], arguments, {}, null, null)
+        return $B.$list([$.self, 1])
+    }
+    int.from_bytes = function() {
+        var $ = $B.args("from_bytes", 3, {
+            bytes: null,
+            byteorder: null,
+            signed: null
+        }, ["bytes", "byteorder", "signed"], arguments, {
+            signed: false
+        }, null, null)
+        var x = $.bytes,
+            byteorder = $.byteorder,
+            signed = $.signed,
+            _bytes, _len
+        if (_b_.isinstance(x, [_b_.bytes, _b_.bytearray])) {
+            _bytes = x.source
+            _len = x.source.length
+        } else {
+            _bytes = _b_.list.$factory(x)
+            _len = _bytes.length
+            for (var i = 0; i < _len; i++) {
+                _b_.bytes.$factory([_bytes[i]])
+            }
+        }
+        if (byteorder == "big") {
+            _bytes.reverse()
+        } else if (byteorder != "little") {
+            throw _b_.ValueError.$factory(
+                "byteorder must be either 'little' or 'big'")
+        }
+        var num = _bytes[0]
+        if (signed && num >= 128) {
+            num = num - 256
+        }
+        var _mult = 256
+        for (var i = 1; i < _len; i++) {
+            num = $B.add($B.mul(_mult, _bytes[i]), num)
+            _mult = $B.mul(_mult, 256)
+        }
+        if (!signed) {
+            return num
+        }
+        if (_bytes[_len - 1] < 128) {
+            return num
+        }
+        return $B.sub(num, _mult)
+    }
+    int.to_bytes = function() {
+        var $ = $B.args("to_bytes", 3, {
+                self: null,
+                len: null,
+                byteorder: null,
+                signed: null
+            }, ["self", "len", "byteorder", "*", "signed"], arguments, {
+                signed: false
+            }, null, null),
+            self = $.self,
+            len = $.len,
+            byteorder = $.byteorder,
+            signed = $.signed
+        if (!_b_.isinstance(len, _b_.int)) {
+            throw _b_.TypeError.$factory("integer argument expected, got " +
+                $B.class_name(len))
+        }
+        if (["little", "big"].indexOf(byteorder) == -1) {
+            throw _b_.ValueError.$factory(
+                "byteorder must be either 'little' or 'big'")
+        }
+        if (_b_.isinstance(self, $B.long_int)) {
+            return $B.long_int.to_bytes(self, len, byteorder, signed)
+        }
+        if (self < 0) {
+            if (!signed) {
+                throw _b_.OverflowError.$factory(
+                    "can't convert negative int to unsigned")
+            }
+            self = Math.pow(256, len) + self
+        }
+        var res = [],
+            value = self
+        while (value > 0) {
+            var quotient = Math.floor(value / 256),
+                rest = value - 256 * quotient
+            res.push(rest)
+            if (res.length > len) {
+                throw _b_.OverflowError.$factory("int too big to convert")
+            }
+            value = quotient
+        }
+        while (res.length < len) {
+            res.push(0)
+        }
+        if (byteorder == "big") {
+            res.reverse()
+        }
+        return {
+            __class__: _b_.bytes,
+            source: res
+        }
+    }
+    int.__abs__ = function(self) {
+        return _b_.abs(self)
+    }
+    int.__add__ = function(self, other) {
+        self = int_value(self)
+        if (_b_.isinstance(other, int)) {
+            if (other.__class__ == $B.long_int) {
+                return $B.long_int.__add__($B.long_int.$factory(self), $B.long_int.$factory(other))
+            }
+            other = int_value(other)
+            var res = self + other
+            if (res > $B.min_int && res < $B.max_int) {
+                return res
+            } else {
+                return $B.long_int.__add__($B.long_int.$factory(self), $B.long_int.$factory(other))
+            }
+        }
+        return _b_.NotImplemented
+    }
+    int.__bool__ = function(self) {
+        return int_value(self).valueOf() == 0 ? false : true
+    }
+    int.__ceil__ = function(self) {
+        return Math.ceil(int_value(self))
+    }
+    int.__divmod__ = function(self, other) {
+        if (!_b_.isinstance(other, int)) {
+            return _b_.NotImplemented
+        }
+        return $B.fast_tuple([int.__floordiv__(self, other), int.__mod__(self, other)])
+    }
+    int.__eq__ = function(self, other) {
+        if (_b_.isinstance(other, int)) {
+            return self.valueOf() == int_value(other).valueOf()
+        }
+        if (_b_.isinstance(other, _b_.float)) {
+            return self.valueOf() == other.valueOf()
+        }
+        if (_b_.isinstance(other, _b_.complex)) {
+            if (other.$imag != 0) {
+                return _b_.False
+            }
+            return self.valueOf() == other.$real
+        }
+        return _b_.NotImplemented
+    }
+    int.__float__ = function(self) {
+        return new Number(self)
+    }
+
+    function preformat(self, fmt) {
+        if (fmt.empty) {
+            return _b_.str.$factory(self)
+        }
+        if (fmt.type && 'bcdoxXn'.indexOf(fmt.type) == -1) {
+            throw _b_.ValueError.$factory("Unknown format code '" + fmt.type +
+                "' for object of type 'int'")
+        }
+        var res
+        switch (fmt.type) {
+            case undefined:
+            case "d":
+                res = self.toString()
+                break
+            case "b":
+                res = (fmt.alternate ? "0b" : "") + self.toString(2)
+                break
+            case "c":
+                res = _b_.chr(self)
+                break
+            case "o":
+                res = (fmt.alternate ? "0o" : "") + self.toString(8)
+                break
+            case "x":
+                res = (fmt.alternate ? "0x" : "") + self.toString(16)
+                break
+            case "X":
+                res = (fmt.alternate ? "0X" : "") + self.toString(16).toUpperCase()
+                break
+            case "n":
+                return self
+        }
+        if (fmt.sign !== undefined) {
+            if ((fmt.sign == " " || fmt.sign == "+") && self >= 0) {
+                res = fmt.sign + res
+            }
+        }
+        return res
+    }
+    int.__format__ = function(self, format_spec) {
+        var fmt = new $B.parse_format_spec(format_spec)
+        if (fmt.type && 'eEfFgG%'.indexOf(fmt.type) != -1) {
+            return _b_.float.__format__(self, format_spec)
+        }
+        fmt.align = fmt.align || ">"
+        var res = preformat(self, fmt)
+        if (fmt.comma) {
+            var sign = res[0] == "-" ? "-" : "",
+                rest = res.substr(sign.length),
+                len = rest.length,
+                nb = Math.ceil(rest.length / 3),
+                chunks = []
+            for (var i = 0; i < nb; i++) {
+                chunks.push(rest.substring(len - 3 * i - 3, len - 3 * i))
+            }
+            chunks.reverse()
+            res = sign + chunks.join(",")
+        }
+        return $B.format_width(res, fmt)
+    }
+    int.__floordiv__ = function(self, other) {
+        if (other.__class__ === $B.long_int) {
+            return $B.long_int.__floordiv__($B.long_int.$factory(self), other)
+        }
+        if (_b_.isinstance(other, int)) {
+            other = int_value(other)
+            if (other == 0) {
+                throw _b_.ZeroDivisionError.$factory("division by zero")
+            }
+            return Math.floor(self / other)
+        }
+        return _b_.NotImplemented
+    }
+    int.__hash__ = function(self) {
+        if (self.$brython_value) {
+            var hash_method = $B.$getattr(self.__class__, '__hash__')
+            if (hash_method === int.__hash__) {
+                if (typeof self.$brython_value == "number") {
+                    return self.$brython_value
+                } else {
+                    return $B.long_int.__hash__(self.$brython_value)
+                }
+            } else {
+                return hash_method(self)
+            }
+        }
+        return self.valueOf()
+    }
+    int.__index__ = function(self) {
+        return int_value(self)
+    }
+    int.__init__ = function(self, value) {
+        if (value === undefined) {
+            value = 0
+        }
+        self.toString = function() {
+            return value
+        }
+        return _b_.None
+    }
+    int.__int__ = function(self) {
+        return self
+    }
+    int.__invert__ = function(self) {
+        return ~self
+    }
+    int.__lshift__ = function(self, other) {
+        self = int_value(self)
+        if (_b_.isinstance(other, int)) {
+            other = int_value(other)
+            try {
+                return int.$factory($B.long_int.__lshift__($B.long_int.$factory(self), $B.long_int.$factory(other)))
+            } catch (err) {
+                console.log('err in lshift', self, other)
+                throw err
+            }
+        }
+        return _b_.NotImplemented
+    }
+    int.__mod__ = function(self, other) {
+        if (_b_.isinstance(other, _b_.tuple) && other.length == 1) {
+            other = other[0]
+        }
+        if (other.__class__ === $B.long_int) {
+            return $B.long_int.__mod__($B.long_int.$factory(self), other)
+        }
+        if (_b_.isinstance(other, int)) {
+            other = int_value(other)
+            if (other === false) {
+                other = 0
+            } else if (other === true) {
+                other = 1
+            }
+            if (other == 0) {
+                throw _b_.ZeroDivisionError.$factory(
+                    "integer division or modulo by zero")
+            }
+            return (self % other + other) % other
+        }
+        return _b_.NotImplemented
+    }
+    int.__mul__ = function(self, other) {
+        self = int_value(self)
+        if (_b_.isinstance(other, int)) {
+            if (other.__class__ == $B.long_int) {
+                return $B.long_int.__mul__($B.long_int.$factory(self), $B.long_int.$factory(other))
+            }
+            other = int_value(other)
+            var res = self * other
+            if (res > $B.min_int && res < $B.max_int) {
+                return res
+            } else {
+                return int.$factory($B.long_int.__mul__($B.long_int.$factory(self), $B.long_int.$factory(other)))
+            }
+        }
+        return _b_.NotImplemented
+    }
+    int.__ne__ = function(self, other) {
+        var res = int.__eq__(self, other)
+        return (res === _b_.NotImplemented) ? res : !res
+    }
+    int.__neg__ = function(self) {
+        return -self
+    }
+    int.__new__ = function(cls, value) {
+        if (cls === undefined) {
+            throw _b_.TypeError.$factory("int.__new__(): not enough arguments")
+        } else if (!_b_.isinstance(cls, _b_.type)) {
+            throw _b_.TypeError.$factory("int.__new__(X): X is not a type object")
+        }
+        if (cls === int) {
+            return int.$factory(value)
+        }
+        return {
+            __class__: cls,
+            __dict__: $B.empty_dict(),
+            $brython_value: value || 0
+        }
+    }
+    int.__pos__ = function(self) {
+        return self
+    }
+
+    function extended_euclidean(a, b) {
+        var d, u, v
+        if (b == 0) {
+            return [a, 1, 0]
+        } else {
+            [d, u, v] = extended_euclidean(b, a % b)
+            return [d, v, u - Math.floor(a / b) * v]
+        }
+    }
+    int.__pow__ = function(self, other, z) {
+        if (!_b_.isinstance(other, int)) {
+            return _b_.NotImplemented
+        }
+        if (typeof other == "number" || _b_.isinstance(other, int)) {
+            other = int_value(other)
+            switch (other.valueOf()) {
+                case 0:
+                    return int.$factory(1)
+                case 1:
+                    return int.$factory(self.valueOf())
+            }
+            if (z !== undefined && z !== _b_.None) {
+                if (z == 1) {
+                    return 0
+                }
+                var result = 1,
+                    base = self % z,
+                    exponent = other,
+                    long_int = $B.long_int
+                if (exponent < 0) {
+                    var gcd, inv, _[gcd, inv, _] = extended_euclidean(self, z)
+                    if (gcd !== 1) {
+                        throw _b_.ValueError.$factory("not relative primes: " +
+                            self + ' and ' + z)
+                    }
+                    return int.__pow__(inv, -exponent, z)
+                }
+                while (exponent > 0) {
+                    if (exponent % 2 == 1) {
+                        if (result * base > $B.max_int) {
+                            result = long_int.__mul__(
+                                long_int.$factory(result), long_int.$factory(base))
+                            result = long_int.__mod__(result, z)
+                        } else {
+                            result = (result * base) % z
+                        }
+                    }
+                    exponent = exponent >> 1
+                    if (base * base > $B.max_int) {
+                        base = long_int.__mul__(long_int.$factory(base), long_int.$factory(base))
+                        base = long_int.__mod__(base, z)
+                    } else {
+                        base = (base * base) % z
+                    }
+                }
+                return result
+            }
+            var res = Math.pow(self.valueOf(), other.valueOf())
+            if (res > $B.min_int && res < $B.max_int) {
+                return other > 0 ? res : new Number(res)
+            } else if (res !== Infinity && !isFinite(res)) {
+                return res
+            } else {
+                if ($B.BigInt) {
+                    return {
+                        __class__: $B.long_int,
+                        value: ($B.BigInt(self) ** $B.BigInt(other)).toString(),
+                        pos: true
+                    }
+                }
+                return $B.long_int.__pow__($B.long_int.$from_int(self), $B.long_int.$from_int(other))
+            }
+        }
+        if (_b_.isinstance(other, _b_.float)) {
+            other = _b_.float.numerator(other)
+            if (self >= 0) {
+                return new Number(Math.pow(self, other))
+            } else {
+                return _b_.complex.__pow__($B.make_complex(self, 0), other)
+            }
+        } else if (_b_.isinstance(other, _b_.complex)) {
+            var preal = Math.pow(self, other.$real),
+                ln = Math.log(self)
+            return $B.make_complex(preal * Math.cos(ln), preal * Math.sin(ln))
+        }
+        var rpow = $B.$getattr(other, "__rpow__", _b_.None)
+        if (rpow !== _b_.None) {
+            return rpow(self)
+        }
+        $err("**", other)
+    }
+
+    function __newobj__() {
+        var $ = $B.args('__newobj__', 0, {}, [], arguments, {}, 'args', null),
+            args = $.args
+        var res = args.slice(1)
+        res.__class__ = args[0]
+        return res
+    }
+    int.__reduce_ex__ = function(self) {
+        return $B.fast_tuple([__newobj__, $B.fast_tuple([self.__class__ || int, int_value(self)]), _b_.None, _b_.None, _b_.None])
+    }
+    int.__repr__ = function(self) {
+        $B.builtins_repr_check(int, arguments)
+        return int_value(self).toString()
+    }
+    int.__rshift__ = function(self, other) {
+        self = int_value(self)
+        if (typeof other == "number" || _b_.isinstance(other, int)) {
+            other = int_value(other)
+            return int.$factory($B.long_int.__rshift__($B.long_int.$factory(self), $B.long_int.$factory(other)))
+        }
+        return _b_.NotImplemented
+    }
+    int.__setattr__ = function(self, attr, value) {
+        if (typeof self == "number" || typeof self == "boolean") {
+            var cl_name = $B.class_name(self)
+            if (_b_.dir(self).indexOf(attr) > -1) {
+                var msg = "attribute '" + attr + `' of '${cl_name}'` +
+                    "objects is not writable"
+            } else {
+                var msg = `'${cl_name}' object has no attribute '${attr}'`
+            }
+            throw _b_.AttributeError.$factory(msg)
+        }
+        _b_.dict.$setitem(self.__dict__, attr, value)
+        return _b_.None
+    }
+    int.__sub__ = function(self, other) {
+        self = int_value(self)
+        if (_b_.isinstance(other, int)) {
+            if (other.__class__ == $B.long_int) {
+                return $B.long_int.__sub__($B.long_int.$factory(self), $B.long_int.$factory(other))
+            }
+            other = int_value(other)
+            var res = self - other
+            if (res > $B.min_int && res < $B.max_int) {
+                return res
+            } else {
+                return $B.long_int.__sub__($B.long_int.$factory(self), $B.long_int.$factory(other))
+            }
+        }
+        return _b_.NotImplemented
+    }
+    int.__truediv__ = function(self, other) {
+        if (_b_.isinstance(other, int)) {
+            other = int_value(other)
+            if (other == 0) {
+                throw _b_.ZeroDivisionError.$factory("division by zero")
+            }
+            if (other.__class__ === $B.long_int) {
+                return new Number(self / parseInt(other.value))
+            }
+            return new Number(self / other)
+        }
+        return _b_.NotImplemented
+    }
+    int.bit_length = function(self) {
+        s = _b_.bin(self)
+        s = $B.$getattr(s, "lstrip")("-0b")
+        return s.length
+    }
+    int.numerator = function(self) {
+        return int_value(self)
+    }
+    int.denominator = function(self) {
+        return int.$factory(1)
+    }
+    int.imag = function(self) {
+        return int.$factory(0)
+    }
+    int.real = function(self) {
+        return self
+    }
+    for (var attr of ['numerator', 'denominator', 'imag', 'real']) {
+        int[attr].setter = (function(x) {
+            return function(self, value) {
+                throw _b_.AttributeError.$factory(`attribute '${x}' of ` +
+                    `'${$B.class_name(self)}' objects is not writable`)
+            }
+        })(attr)
+    }
+    $B.max_int32 = (1 << 30) * 2 - 1
+    $B.min_int32 = -$B.max_int32
+    var $op_func = function(self, other) {
+        self = int_value(self)
+        if (typeof other == "number" || _b_.isinstance(other, int)) {
+            if (other.__class__ === $B.long_int) {
+                return $B.long_int.__sub__($B.long_int.$factory(self), $B.long_int.$factory(other))
+            }
+            other = int_value(other)
+            if (self > $B.max_int32 || self < $B.min_int32 ||
+                other > $B.max_int32 || other < $B.min_int32) {
+                return $B.long_int.__sub__($B.long_int.$factory(self), $B.long_int.$factory(other))
+            }
+            return self - other
+        }
+        return _b_.NotImplemented
+    }
+    $op_func += ""
+    var $ops = {
+        "&": "and",
+        "|": "or",
+        "^": "xor"
+    }
+    for (var $op in $ops) {
+        var opf = $op_func.replace(/-/gm, $op)
+        opf = opf.replace(new RegExp("sub", "gm"), $ops[$op])
+        eval("int.__" + $ops[$op] + "__ = " + opf)
+    }
+    var $comp_func = function(self, other) {
+        if (other.__class__ === $B.long_int) {
+            return $B.long_int.__lt__(other, $B.long_int.$factory(self))
+        }
+        if (_b_.isinstance(other, int)) {
+            other = int_value(other)
+            return self.valueOf() > other.valueOf()
+        } else if (_b_.isinstance(other, _b_.float)) {
+            return self.valueOf() > _b_.float.numerator(other)
+        } else if (_b_.isinstance(other, _b_.bool)) {
+            return self.valueOf() > _b_.bool.__hash__(other)
+        }
+        if (_b_.hasattr(other, "__int__") || _b_.hasattr(other, "__index__")) {
+            return int.__gt__(self, $B.$GetInt(other))
+        }
+        return _b_.NotImplemented
+    }
+    $comp_func += ""
+    for (var $op in $B.$comps) {
+        eval("int.__" + $B.$comps[$op] + "__ = " +
+            $comp_func.replace(/>/gm, $op).replace(/__gt__/gm, "__" + $B.$comps[$op] + "__").replace(/__lt__/, "__" + $B.$inv_comps[$op] + "__"))
+    }
+    var r_opnames = ["add", "sub", "mul", "truediv", "floordiv", "mod", "pow", "lshift", "rshift", "and", "xor", "or", "divmod"]
+    for (var r_opname of r_opnames) {
+        if (int["__r" + r_opname + "__"] === undefined &&
+            int['__' + r_opname + '__']) {
+            int["__r" + r_opname + "__"] = (function(name) {
+                return function(self, other) {
+                    if (_b_.isinstance(other, int)) {
+                        other = int_value(other)
+                        return int["__" + name + "__"](other, self)
+                    }
+                    return _b_.NotImplemented
+                }
+            })(r_opname)
+        }
+    }
+    var $valid_digits = function(base) {
+        var digits = ""
+        if (base === 0) {
+            return "0"
+        }
+        if (base < 10) {
+            for (var i = 0; i < base; i++) {
+                digits += String.fromCharCode(i + 48)
+            }
+            return digits
+        }
+        var digits = "0123456789"
+        for (var i = 10; i < base; i++) {
+            digits += String.fromCharCode(i + 55)
+        }
+        return digits
+    }
+    int.$factory = function(value, base) {
+        if (value === undefined) {
+            return 0
+        }
+        if (typeof value == "number" &&
+            (base === undefined || base == 10)) {
+            return parseInt(value)
+        }
+        if (_b_.isinstance(value, _b_.complex)) {
+            throw _b_.TypeError.$factory("can't convert complex to int")
+        }
+        var $ns = $B.args("int", 2, {
+                x: null,
+                base: null
+            }, ["x", "base"], arguments, {
+                "base": 10
+            }, null, null),
+            value = $ns["x"],
+            base = $ns["base"]
+        if (_b_.isinstance(value, _b_.float) && base == 10) {
+            value = _b_.float.numerator(value)
+            if (value < $B.min_int || value > $B.max_int) {
+                return $B.long_int.$from_float(value)
+            } else {
+                return value > 0 ? Math.floor(value) : Math.ceil(value)
+            }
+        }
+        if (!(base >= 2 && base <= 36)) {
+            if (base != 0) {
+                throw _b_.ValueError.$factory("invalid base")
+            }
+        }
+        if (typeof value == "number") {
+            if (base == 10) {
+                if (value < $B.min_int || value > $B.max_int) {
+                    return $B.long_int.$factory(value)
+                }
+                return value
+            } else if (value.toString().search("e") > -1) {
+                throw _b_.OverflowError.$factory("can't convert to base " + base)
+            } else {
+                var res = parseInt(value, base)
+                if (value < $B.min_int || value > $B.max_int) {
+                    return $B.long_int.$factory(value, base)
+                }
+                return res
+            }
+        }
+        if (value === true) {
+            return Number(1)
+        }
+        if (value === false) {
+            return Number(0)
+        }
+        if (value.__class__ === $B.long_int) {
+            var z = parseInt(value.value)
+            if (z > $B.min_int && z < $B.max_int) {
+                return z
+            } else {
+                return value
+            }
+        }
+        base = $B.$GetInt(base)
+
+        function invalid(value, base) {
+            throw _b_.ValueError.$factory("invalid literal for int() with base " +
+                base + ": '" + _b_.str.$factory(value) + "'")
+        }
+        if (_b_.isinstance(value, _b_.str)) {
+            value = value.valueOf()
+        }
+        if (typeof value == "string") {
+            var _value = value.trim()
+            if (_value.length == 2 && base == 0 &&
+                (_value == "0b" || _value == "0o" || _value == "0x")) {
+                throw _b_.ValueError.$factory("invalid value")
+            }
+            if (_value.length > 2) {
+                var _pre = _value.substr(0, 2).toUpperCase()
+                if (base == 0) {
+                    if (_pre == "0B") {
+                        base = 2
+                    }
+                    if (_pre == "0O") {
+                        base = 8
+                    }
+                    if (_pre == "0X") {
+                        base = 16
+                    }
+                } else if (_pre == "0X" && base != 16) {
+                    invalid(_value, base)
+                } else if (_pre == "0O" && base != 8) {
+                    invalid(_value, base)
+                }
+                if ((_pre == "0B" && base == 2) || _pre == "0O" || _pre == "0X") {
+                    _value = _value.substr(2)
+                    while (_value.startsWith("_")) {
+                        _value = _value.substr(1)
+                    }
+                }
+            } else if (base == 0) {
+                base = 10
+            }
+            var _digits = $valid_digits(base),
+                _re = new RegExp("^[+-]?[" + _digits + "]" +
+                    "[" + _digits + "_]*$", "i"),
+                match = _re.exec(_value)
+            if (match === null) {
+                invalid(value, base)
+            } else {
+                value = _value.replace(/_/g, "")
+            }
+            if (base <= 10 && !isFinite(value)) {
+                invalid(_value, base)
+            }
+            var res = parseInt(value, base)
+            if (res < $B.min_int || res > $B.max_int) {
+                return $B.long_int.$factory(value, base)
+            }
+            return res
+        }
+        if (_b_.isinstance(value, [_b_.bytes, _b_.bytearray])) {
+            return int.$factory($B.$getattr(value, "decode")("latin-1"), base)
+        }
+        for (var special_method of ["__int__", "__index__", "__trunc__"]) {
+            var num_value = $B.$getattr(value.__class__ || $B.get_class(value), special_method, _b_.None)
+            if (num_value !== _b_.None) {
+                return $B.$call(num_value)(value)
+            }
+        }
+        throw _b_.TypeError.$factory(
+            "int() argument must be a string, a bytes-like " +
+            "object or a number, not '" + $B.class_name(value) + "'")
+    }
+    $B.set_func_names(int, "builtins")
+    _b_.int = int
+    $B.$bool = function(obj) {
+        if (obj === null || obj === undefined) {
+            return false
+        }
+        switch (typeof obj) {
+            case "boolean":
+                return obj
+            case "number":
+            case "string":
+                if (obj) {
+                    return true
+                }
+                return false
+            default:
+                if (obj.$is_class) {
+                    return true
+                }
+                var klass = obj.__class__ || $B.get_class(obj),
+                    missing = {},
+                    bool_method = $B.$getattr(klass, "__bool__", missing)
+                if (bool_method === missing) {
+                    try {
+                        return _b_.len(obj) > 0
+                    } catch (err) {
+                        return true
+                    }
+                } else {
+                    var res = $B.$call(bool_method)(obj)
+                    if (res !== true && res !== false) {
+                        throw _b_.TypeError.$factory("__bool__ should return " +
+                            "bool, returned " + $B.class_name(res))
+                    }
+                    return res
+                }
+        }
+    }
+    var bool = {
+        __bases__: [int],
+        __class__: _b_.type,
+        __mro__: [int, _b_.object],
+        $infos: {
+            __name__: "bool",
+            __module__: "builtins"
+        },
+        $is_class: true,
+        $native: true,
+        $descriptors: {
+            "numerator": true,
+            "denominator": true,
+            "imag": true,
+            "real": true
+        }
+    }
+    bool.__and__ = function(self, other) {
+        if (_b_.isinstance(other, bool)) {
+            return self && other
+        } else if (_b_.isinstance(other, int)) {
+            return int.__and__(bool.__index__(self), int.__index__(other))
+        }
+        return _b_.NotImplemented
+    }
+    bool.__float__ = function(self) {
+        return self ? new Number(1) : new Number(0)
+    }
+    bool.__hash__ = bool.__index__ = bool.__int__ = function(self) {
+        if (self.valueOf()) return 1
+        return 0
+    }
+    bool.__neg__ = function(self) {
+        return -$B.int_or_bool(self)
+    }
+    bool.__or__ = function(self, other) {
+        if (_b_.isinstance(other, bool)) {
+            return self || other
+        } else if (_b_.isinstance(other, int)) {
+            return int.__or__(bool.__index__(self), int.__index__(other))
+        }
+        return _b_.NotImplemented
+    }
+    bool.__pos__ = $B.int_or_bool
+    bool.__repr__ = function(self) {
+        $B.builtins_repr_check(bool, arguments)
+        return self ? "True" : "False"
+    }
+    bool.__xor__ = function(self, other) {
+        if (_b_.isinstance(other, bool)) {
+            return self ^ other ? true : false
+        } else if (_b_.isinstance(other, int)) {
+            return int.__xor__(bool.__index__(self), int.__index__(other))
+        }
+        return _b_.NotImplemented
+    }
+    bool.$factory = function() {
+        var $ = $B.args("bool", 1, {
+            x: null
+        }, ["x"], arguments, {
+            x: false
+        }, null, null)
+        return $B.$bool($.x)
+    }
+    bool.numerator = int.numerator
+    bool.denominator = int.denominator
+    bool.real = int.real
+    bool.imag = int.imag
+    _b_.bool = bool
+    $B.set_func_names(bool, "builtins")
+})(__BRYTHON__);;
+(function($B) {
+    var _b_ = $B.builtins
+    try {
+        eval("window")
+    } catch (err) {
+        window = self
+    }
+    var long_int = {
+        __class__: _b_.type,
+        __mro__: [_b_.int, _b_.object],
+        $infos: {
+            __module__: "builtins",
+            __name__: "int"
+        },
+        $is_class: true,
+        $native: true,
+        $descriptors: {
+            "numerator": true,
+            "denominator": true,
+            "imag": true,
+            "real": true
+        }
+    }
+    var max_safe_divider = $B.max_int / 9
+
+    function add_pos(v1, v2) {
+        if (window.BigInt) {
+            return {
+                __class__: long_int,
+                value: (BigInt(v1) + BigInt(v2)).toString(),
+                pos: true
+            }
+        }
+        var res = "",
+            carry = 0,
+            iself = v1.length,
+            sv = 0,
+            x
+        for (var i = v2.length - 1; i >= 0; i--) {
+            iself--
+            if (iself < 0) {
+                sv = 0
+            } else {
+                sv = parseInt(v1.charAt(iself))
+            }
+            x = (carry + sv + parseInt(v2.charAt(i))).toString()
+            if (x.length == 2) {
+                res = x.charAt(1) + res
+                carry = parseInt(x.charAt(0))
+            } else {
+                res = x + res;
+                carry = 0
+            }
+        }
+        while (iself > 0) {
+            iself--
+            x = (carry + parseInt(v1.charAt(iself))).toString()
+            if (x.length == 2) {
+                res = x.charAt(1) + res
+                carry = parseInt(x.charAt(0))
+            } else {
+                res = x + res;
+                carry = 0
+            }
+        }
+        if (carry) {
+            res = carry + res
+        }
+        return {
+            __class__: long_int,
+            value: res,
+            pos: true
+        }
+    }
+    var len = ((Math.pow(2, 53) - 1) + '').length - 1
+
+    function binary_pos(t) {
+        var nb_chunks = Math.ceil(t.length / len),
+            chunks = [],
+            pos, start, nb, bin = []
+        for (var i = 0; i < nb_chunks; i++) {
+            pos = t.length - (i + 1) * len
+            start = Math.max(0, pos)
+            nb = pos - start
+            chunks.push(t.substr(start, len + nb))
+        }
+        chunks = chunks.reverse()
+        chunks.forEach(function(chunk, i) {
+            chunks[i] = parseInt(chunk)
+        })
+        var rest
+        var carry = Math.pow(10, 15)
+        while (chunks[chunks.length - 1] > 0) {
+            chunks.forEach(function(chunk, i) {
+                rest = chunk % 2
+                chunks[i] = Math.floor(chunk / 2)
+                if (rest && i < chunks.length - 1) {
+                    chunks[i + 1] += carry
+                }
+            })
+            bin.push(rest)
+            if (chunks[0] == 0) {
+                chunks.shift()
+            }
+        }
+        bin = bin.reverse().join('')
+        return bin
+    }
+
+    function binary(obj) {
+        var bpos = binary_pos(obj.value)
+        if (obj.pos) {
+            return bpos
+        }
+        var res = ''
+        for (var i = 0, len = bpos.length; i < len; i++) {
+            res += bpos.charAt(i) == "0" ? "1" : "0"
+        }
+        var add1 = add_pos(res, "1").value
+        add1 = res.substr(0, res.length - add1.length) + add1
+        return add1
+    }
+
+    function check_shift(shift) {
+        if (!_b_.isinstance(shift, long_int)) {
+            throw _b_.TypeError.$factory("shift must be int, not '" +
+                $B.class_name(shift) + "'")
+        }
+        if (!shift.pos) {
+            throw _b_.ValueError.$factory("negative shift count")
+        }
+    }
+
+    function clone(obj) {
+        var obj1 = {}
+        for (var attr in obj) {
+            obj1[attr] = obj[attr]
+        }
+        return obj1
+    }
+
+    function comp_pos(v1, v2) {
+        if (v1.length > v2.length) {
+            return 1
+        } else if (v1.length < v2.length) {
+            return -1
+        } else {
+            if (v1 > v2) {
+                return 1
+            } else if (v1 < v2) {
+                return -1
+            }
+        }
+        return 0
+    }
+
+    function divmod_by_safe_int(t, n) {
+        if (n == 1) {
+            return [t, 0]
+        }
+        var T = t.toString(),
+            L = n.toString().length,
+            a = parseInt(T.substr(0, L)),
+            next_pos = L - 1,
+            quotient = '',
+            q, rest
+        while (true) {
+            q = Math.floor(a / n)
+            rest = a - q * n
+            quotient += q
+            next_pos++
+            if (next_pos >= T.length) {
+                return [quotient, rest]
+            }
+            a = 10 * rest + parseInt(T[next_pos])
+        }
+    }
+
+    function divmod_pos(v1, v2) {
+        if ($B.BigInt) {
+            var a = {
+                    __class__: long_int,
+                    value: (BigInt(v1) / BigInt(v2)).toString(),
+                    pos: true
+                },
+                b = {
+                    __class__: long_int,
+                    value: (BigInt(v1) % BigInt(v2)).toString(),
+                    pos: true
+                }
+            return [a, b]
+        }
+        var iv1 = parseInt(v1),
+            iv2 = parseInt(v2),
+            res1
+        if (iv1 < $B.max_int && iv2 < $B.max_int) {
+            var rest = iv1 % iv2,
+                quot = Math.floor(iv1 / iv2).toString()
+            var res1 = [{
+                __class__: long_int,
+                value: quot.toString(),
+                pos: true
+            }, {
+                __class__: long_int,
+                value: rest.toString(),
+                pos: true
+            }]
+            return res1
+        } else if (iv2 < max_safe_divider) {
+            var res_safe = divmod_by_safe_int(v1, iv2)
+            return [long_int.$factory(res_safe[0]), long_int.$factory(res_safe[1])]
+        }
+        var quotient, mod
+        if (comp_pos(v1, v2) == -1) {
+            quotient = "0"
+            mod = long_int.$factory(v1)
+        } else if (v2 == v1) {
+            quotient = "1"
+            mod = long_int.$factory("0")
+        } else {
+            var quotient = "",
+                left = v1.substr(0, v2.length)
+            if (v1 < v2) {
+                left = v1.substr(0, v2.length + 1)
+            }
+            var right = v1.substr(left.length)
+            var mv2 = {}
+            while (true) {
+                var candidate = Math.floor(parseInt(left) / parseInt(v2)) + ""
+                if (candidate == "10") {
+                    candidate = "9"
+                }
+                if (mv2[candidate] === undefined) {
+                    mv2[candidate] = mul_pos(v2, candidate).value
+                }
+                if (comp_pos(left, mv2[candidate]) == -1) {
+                    candidate--
+                    if (mv2[candidate] === undefined) {
+                        mv2[candidate] = mul_pos(v2, candidate).value
+                    }
+                }
+                quotient += candidate
+                left = sub_pos(left, mv2[candidate]).value
+                if (right.length == 0) {
+                    break
+                }
+                left += right.charAt(0)
+                right = right.substr(1)
+            }
+            mod = sub_pos(v1, mul_pos(quotient, v2).value)
+        }
+        return [long_int.$factory(quotient), mod]
+    }
+
+    function split_chunks(s, size) {
+        var nb = Math.ceil(s.length / size),
+            chunks = [],
+            len = s.length
+        for (var i = 0; i < nb; i++) {
+            var pos = len - size * (i + 1)
+            if (pos < 0) {
+                size += pos;
+                pos = 0
+            }
+            chunks.push(parseInt(s.substr(pos, size)))
+        }
+        return chunks
+    }
+
+    function mul_pos(x, y) {
+        if ($B.BigInt) {
+            return long_int.$factory(from_BigInt(BigInt(x) * BigInt(y)))
+        }
+        var ix = parseInt(x),
+            iy = parseInt(y),
+            z = ix * iy
+        if (z < $B.max_int) {
+            return {
+                __class__: long_int,
+                value: z.toString(),
+                pos: true
+            }
+        }
+        var chunk_size = 6,
+            cx = split_chunks(x, chunk_size),
+            cy = split_chunks(y, chunk_size)
+        var products = {},
+            len = cx.length + cy.length
+        for (var i = 0; i < len - 1; i++) {
+            products[i] = 0
+        }
+        for (var i = 0; i < cx.length; i++) {
+            for (var j = 0; j < cy.length; j++) {
+                products[i + j] += cx[i] * cy[j]
+            }
+        }
+        var nb = len - 1,
+            pos
+        for (var i = 0; i < len - 1; i++) {
+            var chunks = split_chunks(products[i].toString(), chunk_size)
+            for (var j = 1; j < chunks.length; j++) {
+                pos = i + j
+                if (products[pos] === undefined) {
+                    products[pos] = parseInt(chunks[j])
+                    nb = pos
+                } else {
+                    products[pos] += parseInt(chunks[j])
+                }
+            }
+            products[i] = chunks[0]
+        }
+        var result = "",
+            i = 0,
+            s
+        while (products[i] !== undefined) {
+            s = products[i].toString()
+            if (products[i + 1] !== undefined) {
+                s = "0".repeat(chunk_size - s.length) + s
+            }
+            result = s + result
+            i++
+        }
+        try {
+            return long_int.$factory(result)
+        } catch (err) {
+            console.log(x, y, products, result)
+            throw err
+        }
+    }
+
+    function sub_pos(v1, v2) {
+        if (window.BigInt) {
+            return {
+                __class__: long_int,
+                value: (BigInt(v1) - BigInt(v2)).toString(),
+                pos: true
+            }
+        }
+        var res = "",
+            carry = 0,
+            i1 = v1.length,
+            sv = 0,
+            x
+        for (var i = v2.length - 1; i >= 0; i--) {
+            i1--
+            sv = parseInt(v1.charAt(i1))
+            x = (sv - carry - parseInt(v2.charAt(i)))
+            if (isNaN(x)) {
+                console.log("x is NaN", v1.length, v2.length, i, i1, sv, carry, i, v2.charAt(i))
+            }
+            if (x < 0) {
+                res = (10 + x) + res;
+                carry = 1
+            } else {
+                res = x + res;
+                carry = 0
+            }
+        }
+        if (res.startsWith("NaN")) {
+            alert(res)
+        }
+        while (i1 > 0) {
+            i1--
+            x = (parseInt(v1.charAt(i1)) - carry)
+            if (x < 0) {
+                res = (10 + x) + res;
+                carry = 1
+            } else {
+                res = x + res;
+                carry = 0
+            }
+        }
+        while (res.charAt(0) == "0" && res.length > 1) {
+            res = res.substr(1)
+        }
+        if (res.startsWith("NaN")) {
+            console.log("hoho !!", v1, v2, v1 >= v2, res)
+        }
+        return {
+            __class__: long_int,
+            value: res,
+            pos: true
+        }
+    }
+
+    function to_BigInt(x) {
+        var res = $B.BigInt(x.value)
+        if (x.pos) {
+            return res
+        }
+        return -res
+    }
+
+    function to_int(long_int) {
+        return long_int.pos ? parseInt(long_int.value) : -parseInt(long_int.value)
+    }
+
+    function from_BigInt(y) {
+        var pos = y >= 0
+        y = y.toString()
+        y = y.endsWith("n") ? y.substr(0, y.length - 1) : y
+        y = y.startsWith('-') ? y.substr(1) : y
+        return intOrLong({
+            __class__: long_int,
+            value: y,
+            pos: pos
+        })
+    }
+    long_int.$from_float = function(value) {
+        var s = Math.abs(value).toString(),
+            v = s
+        if (s.search("e") > -1) {
+            var t = /-?(\d)(\.\d+)?e([+-])(\d*)/.exec(s),
+                n1 = t[1],
+                n2 = t[2],
+                pos = t[3],
+                exp = t[4]
+            if (pos == "+") {
+                if (n2 === undefined) {
+                    v = n1 + "0".repeat(exp - 1)
+                } else {
+                    v = n1 + n2 + "0".repeat(exp - 1 - n2.length)
+                }
+            }
+        }
+        return {
+            __class__: long_int,
+            value: v,
+            pos: value >= 0
+        }
+    }
+
+    function preformat(self, fmt) {
+        if (fmt.empty) {
+            return _b_.str.$factory(self)
+        }
+        if (fmt.type && 'bcdoxXn'.indexOf(fmt.type) == -1) {
+            throw _b_.ValueError.$factory("Unknown format code '" + fmt.type +
+                "' for object of type 'int'")
+        }
+        var res
+        switch (fmt.type) {
+            case undefined:
+            case "d":
+                res = self.toString()
+                break
+            case "b":
+                res = (fmt.alternate ? "0b" : "") + BigInt(self.value).toString(2)
+                break
+            case "c":
+                res = _b_.chr(self)
+                break
+            case "o":
+                res = (fmt.alternate ? "0o" : "") + BigInt(self.value).toString(8)
+                break
+            case "x":
+                res = (fmt.alternate ? "0x" : "") + BigInt(self.value).toString(16)
+                break
+            case "X":
+                res = (fmt.alternate ? "0X" : "") + BigInt(self.value).toString(16).toUpperCase()
+                break
+            case "n":
+                return self
+        }
+        if (fmt.sign !== undefined) {
+            if ((fmt.sign == " " || fmt.sign == "+") && self >= 0) {
+                res = fmt.sign + res
+            }
+        }
+        return res
+    }
+    long_int.__format__ = function(self, format_spec) {
+        var fmt = new $B.parse_format_spec(format_spec)
+        if (fmt.type && 'eEfFgG%'.indexOf(fmt.type) != -1) {
+            return _b_.float.__format__(self, format_spec)
+        }
+        fmt.align = fmt.align || ">"
+        var res = preformat(self, fmt)
+        if (fmt.comma) {
+            var sign = res[0] == "-" ? "-" : "",
+                rest = res.substr(sign.length),
+                len = rest.length,
+                nb = Math.ceil(rest.length / 3),
+                chunks = []
+            for (var i = 0; i < nb; i++) {
+                chunks.push(rest.substring(len - 3 * i - 3, len - 3 * i))
+            }
+            chunks.reverse()
+            res = sign + chunks.join(",")
+        }
+        return $B.format_width(res, fmt)
+    }
+    long_int.__abs__ = function(self) {
+        return {
+            __class__: long_int,
+            value: self.value,
+            pos: true
+        }
+    }
+    long_int.__add__ = function(self, other) {
+        if (_b_.isinstance(other, _b_.float)) {
+            return _b_.float.$factory(to_int(self) + other)
+        }
+        if (typeof other == "number") {
+            other = long_int.$factory(_b_.str.$factory(other))
+        } else if (other.__class__ !== long_int) {
+            if (_b_.isinstance(other, _b_.bool)) {
+                other = long_int.$factory(other ? 1 : 0)
+            } else if (_b_.isinstance(other, _b_.int)) {
+                other = long_int.$factory(_b_.str.$factory(_b_.int.__index__(other)))
+            } else {
+                return _b_.NotImplemented
+            }
+        }
+        if ($B.BigInt) {
+            return from_BigInt(to_BigInt(self) + to_BigInt(other))
+        }
+        var res
+        if (self.pos && other.pos) {
+            return add_pos(self.value, other.value)
+        } else if (!self.pos && !other.pos) {
+            res = add_pos(self.value, other.value)
+            res.pos = false
+            return intOrLong(res)
+        } else if (self.pos && !other.pos) {
+            switch (comp_pos(self.value, other.value)) {
+                case 1:
+                    res = sub_pos(self.value, other.value)
+                    break
+                case 0:
+                    res = {
+                        __class__: long_int,
+                        value: 0,
+                        pos: true
+                    }
+                    break
+                case -1:
+                    res = sub_pos(other.value, self.value)
+                    res.pos = false
+                    break
+            }
+            return intOrLong(res)
+        } else {
+            switch (comp_pos(self.value, other.value)) {
+                case 1:
+                    res = sub_pos(self.value, other.value)
+                    res.pos = false
+                    break
+                case 0:
+                    res = {
+                        __class__: long_int,
+                        value: 0,
+                        pos: true
+                    }
+                    break
+                case -1:
+                    res = sub_pos(other.value, self.value)
+                    break
+            }
+            return intOrLong(res)
+        }
+    }
+    long_int.__and__ = function(self, other) {
+        if (typeof other == "number") {
+            other = long_int.$factory(_b_.str.$factory(other))
+        }
+        if ($B.BigInt) {
+            return from_BigInt(to_BigInt(self) & to_BigInt(other))
+        }
+        var v1 = self.value,
+            v2 = other.value,
+            temp1, temp2, res = ""
+        var neg = (!self.pos) && (!other.pos)
+        if (neg) {
+            self = long_int.__neg__(self)
+            other = long_int.__neg__(other)
+        }
+        var b1 = binary(self),
+            len1 = b1.length,
+            b2 = binary(other),
+            len2 = b2.length,
+            i = 1,
+            res = '',
+            x1, x2
+        while (true) {
+            if (i > len1 && i > len2) {
+                break
+            }
+            if (i > len1) {
+                x1 = self.pos ? "0" : "1"
+            } else {
+                x1 = b1.charAt(len1 - i)
+            }
+            if (i > len2) {
+                x2 = other.pos ? "0" : "1"
+            } else {
+                x2 = b2.charAt(len2 - i)
+            }
+            if (x1 == "1" && x2 == "1") {
+                res = "1" + res
+            } else {
+                res = "0" + res
+            }
+            i++
+        }
+        while (res.charAt(0) == "0") {
+            res = res.substr(1)
+        }
+        res = $B.long_int.$factory(res, 2)
+        if (neg) {
+            res.pos = false
+        }
+        return intOrLong(res)
+    }
+    long_int.__divmod__ = function(self, other) {
+        if (typeof other == "number") {
+            other = long_int.$factory(_b_.str.$factory(other))
+        }
+        var dm = divmod_pos(self.value, other.value)
+        if (self.pos !== other.pos) {
+            if (dm[0].value != "0") {
+                dm[0].pos = false
+            }
+            if (dm[1].value != "0") {
+                dm[0] = long_int.__sub__(dm[0], long_int.$factory("1"))
+                dm[1] = long_int.__sub__(self, long_int.__mul__(other, long_int.$factory(dm[0])))
+            }
+        }
+        return $B.fast_tuple([intOrLong(dm[0]), intOrLong(dm[1])])
+    }
+    long_int.__eq__ = function(self, other) {
+        if (typeof other == "number") {
+            other = long_int.$factory(_b_.str.$factory(other))
+        }
+        return self.value == other.value && self.pos == other.pos
+    }
+    long_int.__float__ = function(self) {
+        if (!isFinite(parseFloat(self.value))) {
+            throw _b_.OverflowError.$factory("int too big to convert to float")
+        }
+        return new Number(parseFloat(self.value))
+    }
+    long_int.__floordiv__ = function(self, other) {
+        if (_b_.isinstance(other, _b_.float)) {
+            return _b_.float.$factory(to_int(self) / other)
+        }
+        if (typeof other == "number" && Math.abs(other) < $B.max_safe_divider) {
+            var t = self.value,
+                res = divmod_by_safe_int(t, other),
+                pos = other > 0 ? self.pos : !self.pos
+            return {
+                __class__: long_int,
+                value: res[0],
+                pos: pos
+            }
+        }
+        var res = intOrLong(long_int.__divmod__(self, other)[0])
+        return res
+    }
+    long_int.__ge__ = function(self, other) {
+        if (typeof other == "number") {
+            other = long_int.$factory(_b_.str.$factory(other))
+        }
+        if (self.pos != other.pos) {
+            return !other.pos
+        }
+        if (self.value.length > other.value.length) {
+            return self.pos
+        } else if (self.value.length < other.value.length) {
+            return !self.pos
+        } else {
+            return self.pos ? self.value >= other.value :
+                self.value <= other.value
+        }
+    }
+    long_int.__gt__ = function(self, other) {
+        return !long_int.__le__(self, other)
+    }
+    long_int.__hash__ = function(self) {
+        var modulus = $B.fast_long_int("2305843009213693951", true),
+            self_pos = $B.fast_long_int(self.value, true)
+        var _hash = $B.long_int.__mod__(self_pos, modulus)
+        if (typeof _hash == "number") {
+            _hash = self.pos ? _hash : -_hash
+        } else {
+            _hash.pos = self.pos
+        }
+        return self.__hashvalue__ = _hash
+    }
+    long_int.__index__ = function(self) {
+        var res = '',
+            temp = self.value,
+            d
+        while (true) {
+            d = divmod_pos(temp, "2")
+            res = d[1].value + res
+            temp = d[0].value
+            if (temp == "0") {
+                break
+            }
+        }
+        if (!self.pos) {
+            var nres = "",
+                flag = false
+            for (var len = res.length - 1, i = len; i >= 0; i--) {
+                var bit = res.charAt(i)
+                if (bit == "0") {
+                    if (flag) {
+                        nres = "1" + nres
+                    } else {
+                        nres = "0" + nres
+                    }
+                } else {
+                    if (flag) {
+                        nres = "0" + nres
+                    } else {
+                        flag = true;
+                        nres = "1" + nres
+                    }
+                }
+            }
+            nres = "1" + nres
+            res = nres
+        } else {
+            res = "0" + res
+        }
+        return intOrLong(res)
+    }
+    long_int.__invert__ = function(self) {
+        return long_int.__sub__(long_int.$factory("-1"), self)
+    }
+    long_int.__le__ = function(self, other) {
+        if (typeof other == "number") {
+            other = long_int.$factory(_b_.str.$factory(other))
+        }
+        if (self.pos !== other.pos) {
+            return !self.pos
+        }
+        if (self.value.length > other.value.length) {
+            return !self.pos
+        } else if (self.value.length < other.value.length) {
+            return self.pos
+        } else {
+            return self.pos ? self.value <= other.value :
+                self.value >= other.value
+        }
+    }
+    long_int.__lt__ = function(self, other) {
+        return !long_int.__ge__(self, other)
+    }
+    long_int.__lshift__ = function(self, shift) {
+        if (window.BigInt) {
+            if (shift.__class__ == long_int) {
+                shift = shift.value
+            }
+            return intOrLong({
+                __class__: long_int,
+                value: (BigInt(self.value) << BigInt(shift)).toString(),
+                pos: self.pos
+            })
+        }
+        var is_long = shift.__class__ === long_int,
+            shift_safe
+        if (is_long) {
+            var shift_value = parseInt(shift.value)
+            if (shift_value < 0) {
+                throw _b_.ValueError.$factory('negative shift count')
+            }
+            if (shift_value < $B.max_int) {
+                shift_safe = true
+                shift = shift_value
+            }
+        }
+        if (shift_safe) {
+            if (shift_value == 0) {
+                return self
+            }
+        } else {
+            shift = long_int.$factory(shift)
+            if (shift.value == "0") {
+                return self
+            }
+        }
+        var res = self.value
+        while (true) {
+            var x, carry = 0,
+                res1 = ""
+            for (var i = res.length - 1; i >= 0; i--) {
+                x = (carry + parseInt(res.charAt(i)) * 2).toString()
+                if (x.length == 2) {
+                    res1 = x.charAt(1) + res1
+                    carry = parseInt(x.charAt(0))
+                } else {
+                    res1 = x + res1
+                    carry = 0
+                }
+            }
+            if (carry) {
+                res1 = carry + res1
+            }
+            res = res1
+            if (shift_safe) {
+                shift--
+                if (shift == 0) {
+                    break
+                }
+            } else {
+                shift = sub_pos(shift.value, "1")
+                if (shift.value == "0") {
+                    break
+                }
+            }
+        }
+        return intOrLong({
+            __class__: long_int,
+            value: res,
+            pos: self.pos
+        })
+    }
+    long_int.__mod__ = function(self, other) {
+        return intOrLong(long_int.__divmod__(self, other)[1])
+    }
+    long_int.__mro__ = [_b_.int, _b_.object]
+    long_int.__mul__ = function(self, other) {
+        switch (self) {
+            case Number.NEGATIVE_INFINITY:
+            case Number.POSITIVE_INFINITY:
+                if ($B.rich_comp("__eq__", other, 0)) {
+                    return NaN
+                } else if (_b_.getattr(other, "__gt__")(0)) {
+                    return self
+                } else {
+                    return -self
+                }
+        }
+        if (_b_.isinstance(other, _b_.float)) {
+            return _b_.float.$factory(to_int(self) * other)
+        }
+        if (typeof other == "number") {
+            other = long_int.$factory(other)
+        }
+        other_value = other.value
+        other_pos = other.pos
+        if (other.__class__ !== long_int && _b_.isinstance(other, _b_.int)) {
+            var value = _b_.int.__index__(other)
+            other_value = _b_.str.$factory(value)
+            other_pos = value > 0
+        }
+        if ($B.BigInt) {
+            return from_BigInt(to_BigInt(self) * to_BigInt(other))
+        }
+        var res = mul_pos(self.value, other_value)
+        if (self.pos == other_pos) {
+            return intOrLong(res)
+        }
+        res.pos = false
+        return intOrLong(res)
+    }
+    long_int.__ne__ = function(self, other) {
+        var res = long_int.__eq__(self, other)
+        return res === _b_.NotImplemented ? res : !res
+    }
+    long_int.__neg__ = function(obj) {
+        return {
+            __class__: long_int,
+            value: obj.value,
+            pos: !obj.pos
+        }
+    }
+    long_int.__or__ = function(self, other) {
+        other = long_int.$factory(other)
+        var v1 = long_int.__index__(self)
+        var v2 = long_int.__index__(other)
+        if (v1.length < v2.length) {
+            var temp = v2;
+            v2 = v1;
+            v1 = temp
+        }
+        var start = v1.length - v2.length
+        var res = v1.substr(0, start)
+        for (var i = 0; i < v2.length; i++) {
+            if (v1.charAt(start + i) == "1" || v2.charAt(i) == "1") {
+                res += "1"
+            } else {
+                res += "0"
+            }
+        }
+        return intOrLong(long_int.$factory(res, 2))
+    }
+    long_int.__pos__ = function(self) {
+        return self
+    }
+    long_int.__pow__ = function(self, power, z) {
+        if (typeof power == "number") {
+            power = long_int.$from_int(power)
+        } else if (_b_.isinstance(power, _b_.int)) {
+            power = long_int.$factory(_b_.str.$factory(_b_.int.__index__(power)))
+        } else if (!_b_.isinstance(power, long_int)) {
+            var msg = "power must be an integer, not '"
+            throw _b_.TypeError.$factory(msg + $B.class_name(power) + "'")
+        }
+        if (!power.pos) {
+            if (self.value == "1") {
+                return self
+            }
+            return long_int.$factory("0")
+        } else if (power.value == "0") {
+            return long_int.$factory("1")
+        }
+        if ($B.BigInt) {
+            var s = $B.BigInt(self.value),
+                b = $B.BigInt(1),
+                x = $B.BigInt(power.value),
+                z = z === undefined ? z : typeof z == "number" ? $B.BigInt(z) :
+                $B.BigInt(z.value)
+            if (z === undefined) {
+                return {
+                    __class__: long_int,
+                    value: (s ** x).toString(),
+                    pos: true
+                }
+            }
+            while (x > 0) {
+                if (x % $B.BigInt(2) == 1) {
+                    b = b * s
+                }
+                x = x / $B.BigInt(2)
+                if (x > 0) {
+                    s = s * s
+                }
+                if (z !== undefined) {
+                    b = b % z
+                }
+            }
+            return {
+                __class__: long_int,
+                value: b.toString(),
+                pos: true
+            }
+        }
+        var b = {
+                __class__: long_int,
+                value: "1",
+                pos: true
+            },
+            s = self,
+            pow = power.value,
+            temp
+        while (true) {
+            if (typeof pow == "string" && parseInt(pow) < $B.max_int) {
+                pow = parseInt(pow)
+            }
+            if (pow == 0) {
+                break
+            } else if (typeof pow == "string") {
+                if (parseInt(pow.charAt(pow.length - 1)) % 2 == 1) {
+                    b = long_int.__mul__(b, s)
+                }
+                pow = long_int.__floordiv__(pow, 2)
+            } else {
+                if (pow % 2 == 1) {
+                    if (typeof b == "number" && typeof s == "number" &&
+                        (temp = b * s) < $B.max_int) {
+                        b = temp
+                    } else {
+                        b = long_int.__mul__(long_int.$factory(b), long_int.$factory(s))
+                    }
+                }
+                pow = Math.floor(pow / 2)
+            }
+            if (pow > 0) {
+                if (typeof s == "number" && (temp = s * s) < $B.max_int) {
+                    s = temp
+                } else {
+                    s = long_int.$factory(s)
+                    s = long_int.__mul__(s, s)
+                }
+            }
+            if (z !== undefined) {
+                b = long_int.__mod__(b, z)
+            }
+        }
+        return intOrLong(b)
+    }
+    long_int.__rshift__ = function(self, shift) {
+        if (window.BigInt) {
+            if (shift.__class__ === long_int) {
+                shift = shift.value
+            }
+            return intOrLong({
+                __class__: long_int,
+                value: (BigInt(self.value) >> BigInt(shift)).toString(),
+                pos: self.pos
+            })
+        }
+        if (typeof shift == "number") {
+            var pow2 = Math.pow(2, shift)
+            if (pow2 < $B.max_int) {
+                var res = divmod_by_safe_int(self.value, pow2)
+                return intOrLong({
+                    __class__: long_int,
+                    value: res[0],
+                    pos: self.pos
+                })
+            }
+        }
+        shift = long_int.$factory(shift)
+        if (shift.value == "0") {
+            return self
+        }
+        var res = self.value
+        while (true) {
+            res = divmod_pos(res, "2")[0].value
+            if (res.value == "0") {
+                break
+            }
+            shift = sub_pos(shift.value, "1")
+            if (shift.value == "0") {
+                break
+            }
+        }
+        return intOrLong({
+            __class__: long_int,
+            value: res,
+            pos: self.pos
+        })
+    }
+    long_int.__str__ = long_int.__repr__ = function(self) {
+        var res = ""
+        if (!self.pos) {
+            res += '-'
+        }
+        return res + self.value
+    }
+    long_int.__sub__ = function(self, other) {
+        if (_b_.isinstance(other, _b_.float)) {
+            other = other instanceof Number ? other : other.$brython_value
+            return _b_.float.$factory(to_int(self) - other)
+        }
+        if (typeof other == "number") {
+            other = long_int.$factory(_b_.str.$factory(other))
+        }
+        if ($B.BigInt) {}
+        var res
+        if (self.pos && other.pos) {
+            switch (comp_pos(self.value, other.value)) {
+                case 1:
+                    res = sub_pos(self.value, other.value)
+                    break
+                case 0:
+                    res = {
+                        __class__: long_int,
+                        value: "0",
+                        pos: true
+                    }
+                    break
+                case -1:
+                    res = sub_pos(other.value, self.value)
+                    res.pos = false
+                    break
+            }
+            return intOrLong(res)
+        } else if (!self.pos && !other.pos) {
+            switch (comp_pos(self.value, other.value)) {
+                case 1:
+                    res = sub_pos(self.value, other.value)
+                    res.pos = false
+                    break
+                case 0:
+                    res = {
+                        __class__: long_int,
+                        value: "0",
+                        pos: true
+                    }
+                    break
+                case -1:
+                    res = sub_pos(other.value, self.value)
+                    break
+            }
+            return intOrLong(res)
+        } else if (self.pos && !other.pos) {
+            return intOrLong(add_pos(self.value, other.value))
+        } else {
+            res = add_pos(self.value, other.value)
+            res.pos = false
+            return intOrLong(res)
+        }
+    }
+    long_int.__truediv__ = function(self, other) {
+        if (_b_.isinstance(other, long_int)) {
+            return _b_.float.$factory(to_int(self) / to_int(other))
+        } else if (_b_.isinstance(other, _b_.int)) {
+            return _b_.float.$factory(to_int(self) / other)
+        } else if (_b_.isinstance(other, _b_.float)) {
+            return _b_.float.$factory(to_int(self) / other)
+        } else {
+            throw _b_.TypeError.$factory(
+                "unsupported operand type(s) for /: 'int' and '" +
+                $B.class_name(other) + "'")
+        }
+    }
+    long_int.__xor__ = function(self, other) {
+        other = long_int.$factory(other)
+        var v1 = long_int.__index__(self),
+            v2 = long_int.__index__(other)
+        if (v1.length < v2.length) {
+            var temp = v2;
+            v2 = v1;
+            v1 = temp
+        }
+        var start = v1.length - v2.length
+        var res = v1.substr(0, start)
+        for (var i = 0; i < v2.length; i++) {
+            if (v1.charAt(start + i) == "1" && v2.charAt(i) == "0") {
+                res += "1"
+            } else if (v1.charAt(start + i) == "0" && v2.charAt(i) == "1") {
+                res += "1"
+            } else {
+                res += "0"
+            }
+        }
+        return intOrLong(long_int.$factory(res, 2))
+    }
+    long_int.bit_length = function(self) {
+        return binary(self).length
+    }
+    long_int.numerator = function(self) {
+        return self
+    }
+    long_int.denominator = function(self) {
+        return _b_.int.$factory(1)
+    }
+    long_int.imag = function(self) {
+        return _b_.int.$factory(0)
+    }
+    long_int.real = function(self) {
+        return self
+    }
+    long_int.to_base = function(self, base) {
+        if (base == 2) {
+            return binary_pos(self.value)
+        }
+        var res = "",
+            v = self.value
+        while (v > 0) {
+            var dm = divmod_pos(v, base.toString())
+            res = parseInt(dm[1].value).toString(base) + res
+            v = dm[0].value
+            if (v == 0) {
+                break
+            }
+        }
+        return res
+    }
+    long_int.to_bytes = function(self, len, byteorder, signed) {
+        var res = [],
+            v = self.value
+        if (!$B.$bool(signed) && !self.pos) {
+            throw _b_.OverflowError.$factory("can't convert negative int to unsigned")
+        }
+        while (v > 0) {
+            var dm = divmod_pos(v, 256)
+            v = parseInt(dm[0].value)
+            res.push(parseInt(dm[1].value))
+            if (res.length > len) {
+                throw _b_.OverflowError.$factory("int too big to convert")
+            }
+        }
+        while (res.length < len) {
+            res.push(0)
+        }
+        if (byteorder == 'big') {
+            res.reverse()
+        }
+        return _b_.bytes.$factory(res)
+    }
+
+    function digits(base) {
+        var is_digits = {}
+        for (var i = 0; i < base; i++) {
+            if (i == 10) {
+                break
+            }
+            is_digits[i] = true
+        }
+        if (base > 10) {
+            for (var i = 0; i < base - 10; i++) {
+                is_digits[String.fromCharCode(65 + i)] = true
+                is_digits[String.fromCharCode(97 + i)] = true
+            }
+        }
+        return is_digits
+    }
+    var MAX_SAFE_INTEGER = Math.pow(2, 53) - 1
+    var MIN_SAFE_INTEGER = -MAX_SAFE_INTEGER
+
+    function isSafeInteger(n) {
+        return (typeof n === "number" &&
+            Math.round(n) === n &&
+            MIN_SAFE_INTEGER <= n &&
+            n <= MAX_SAFE_INTEGER)
+    }
+
+    function intOrLong(long) {
+        var v = parseInt(long.value) * (long.pos ? 1 : -1)
+        if (v > MIN_SAFE_INTEGER && v < MAX_SAFE_INTEGER) {
+            return v
+        }
+        return long
+    }
+    long_int.$from_int = function(value) {
+        return {
+            __class__: long_int,
+            value: value.toString(),
+            pos: value > 0
+        }
+    }
+    long_int.$factory = function(value, base) {
+        if (arguments.length > 2) {
+            throw _b_.TypeError.$factory("long_int takes at most 2 arguments (" +
+                arguments.length + " given)")
+        }
+        if (base === undefined) {
+            base = 10
+        } else if (!_b_.isinstance(base, _b_.int)) {
+            throw _b_.TypeError.$factory("'" + $B.class_name(base) +
+                "' object cannot be interpreted as an integer")
+        }
+        if (base < 0 || base == 1 || base > 36) {
+            throw _b_.ValueError.$factory(
+                "long_int.$factory() base must be >= 2 and <= 36")
+        }
+        if (typeof value == "number") {
+            var pos = value >= 0,
+                value = Math.abs(value),
+                res
+            if (isSafeInteger(value)) {
+                res = long_int.$from_int(value)
+            } else if (value.constructor == Number) {
+                var s = value.toString(),
+                    pos_exp = s.search("e")
+                if (pos_exp > -1) {
+                    var mant = s.substr(0, pos_exp),
+                        exp = parseInt(s.substr(pos_exp + 1)),
+                        point = mant.search(/\./)
+                    if (point > -1) {
+                        var nb_dec = mant.substr(point + 1).length
+                        if (nb_dec > exp) {
+                            var res = mant.substr(0, point) +
+                                mant.substr(point + 1).substr(0, exp)
+                            res = long_int.$from_int(res)
+                        } else {
+                            var res = mant.substr(0, point) +
+                                mant.substr(point + 1) + '0'.repeat(exp - nb_dec)
+                            res = long_int.$from_int(res)
+                        }
+                    } else {
+                        res = long_int.$from_int(mant + '0'.repeat(exp))
+                    }
+                } else {
+                    var point = s.search(/\./)
+                    if (point > -1) {
+                        res = long_int.$from_int(s.substr(0, point))
+                    } else {
+                        res = long_int.$from_int(s)
+                    }
+                }
+            } else {
+                throw _b_.ValueError.$factory(
+                    "argument of long_int is not a safe integer")
+            }
+            res.pos = pos
+            return res
+        } else if (_b_.isinstance(value, _b_.float)) {
+            if (value === Number.POSITIVE_INFINITY ||
+                value === Number.NEGATIVE_INFINITY) {
+                return value
+            }
+            if (value >= 0) {
+                value = new Number(Math.round(value.value))
+            } else {
+                value = new Number(Math.ceil(value.value))
+            }
+        } else if (_b_.isinstance(value, _b_.bool)) {
+            if (value.valueOf()) {
+                return _b_.int.$factory(1)
+            }
+            return _b_.int.$factory(0)
+        } else if (value.__class__ === long_int) {
+            return value
+        } else if (_b_.isinstance(value, _b_.int)) {
+            value = value.$brython_value + ""
+        } else if (_b_.isinstance(value, _b_.bool)) {
+            value = _b_.bool.__int__(value) + ""
+        } else if (typeof value != "string") {
+            throw _b_.ValueError.$factory(
+                "argument of long_int must be a string, not " +
+                $B.class_name(value))
+        }
+        var has_prefix = false,
+            pos = true,
+            start = 0
+        while (value.charAt(0) == " " && value.length) {
+            value = value.substr(1)
+        }
+        while (value.charAt(value.length - 1) == " " && value.length) {
+            value = value.substr(0, value.length - 1)
+        }
+        if (value.charAt(0) == "+") {
+            has_prefix = true
+        } else if (value.charAt(0) == "-") {
+            has_prefix = true;
+            pos = false
+        }
+        if (has_prefix) {
+            if (value.length == 1) {
+                throw _b_.ValueError.$factory(
+                    'long_int argument is not a valid number: "' + value + '"')
+            } else {
+                value = value.substr(1)
+            }
+        }
+        while (start < value.length - 1 && value.charAt(start) == "0") {
+            start++
+        }
+        value = value.substr(start)
+        var is_digits = digits(base),
+            point = -1
+        for (var i = 0; i < value.length; i++) {
+            if (value.charAt(i) == "." && point == -1) {
+                point = i
+            } else if (false) {
+                var mant = value.substr(0, i)
+                if (/^[+-]?\d+$/.exec(value.substr(i + 1))) {
+                    exp = parseInt(value.substr(i + 1))
+                } else {
+                    throw Error("wrong exp " + value.substr(i + 1))
+                }
+                if (point != -1) {
+                    mant = mant.substr(0, point) + mant.substr(point + 1)
+                    exp = exp + point - 1
+                }
+                point = -1
+                value = mant + "0".repeat(exp - mant.length)
+                break
+            } else if (!is_digits[value.charAt(i)]) {
+                throw _b_.ValueError.$factory(
+                    'long_int argument is not a valid number: "' + value + '"')
+            }
+        }
+        if (point != -1) {
+            value = value.substr(0, point)
+        }
+        if (base != 10) {
+            var coef = "1",
+                v10 = long_int.$factory(0),
+                ix = value.length
+            while (ix--) {
+                var digit_base10 = parseInt(value.charAt(ix), base).toString(),
+                    digit_by_coef = mul_pos(coef, digit_base10).value
+                v10 = add_pos(v10.value, digit_by_coef)
+                coef = mul_pos(coef, base.toString()).value
+            }
+            return v10
+        }
+        return {
+            __class__: long_int,
+            value: value,
+            pos: pos
+        }
+    }
+
+    function extended_euclidean_algorithm(a, b) {
+        var s = 0,
+            old_s = 1,
+            t = 1,
+            old_t = 0,
+            r = b,
+            old_r = a,
+            quotient, tmp
+        while ($B.rich_comp('__ne__', r, 0)) {
+            quotient = $B.rich_op('floordiv', old_r, r)
+            tmp = $B.rich_op('sub', old_r, $B.rich_op('mul', quotient, r))
+            old_r = r
+            r = tmp
+            tmp = $B.rich_op('sub', old_s, $B.rich_op('mul', quotient, s))
+            old_s = s
+            s = tmp
+            tmp = $B.rich_op('sub', old_t, $B.rich_op('mul', quotient, t))
+            old_t = t
+            t = tmp
+        }
+        return [old_r, old_s, old_t]
+    }
+
+    function inverse_of(n, p) {
+        var gcd, x, y[gcd, x, y] = extended_euclidean_algorithm(n, p)
+        if ($B.rich_comp('__ne__', gcd, 1)) {
+            throw Error(
+                `${n} has no multiplicative inverse '
+            'modulo ${p}`)
+        } else {
+            return $B.rich_op('mod', x, p)
+        }
+    }
+    $B.inverse_of = inverse_of
+    $B.set_func_names(long_int, "builtins")
+    $B.long_int = long_int
+    $B.fast_long_int = function(value, pos) {
+        return {
+            __class__: $B.long_int,
+            value: value,
+            pos: pos
+        }
+    }
+})(__BRYTHON__);;
+(function($B) {
+    var _b_ = $B.builtins
+    var object = _b_.object
+
+    function $err(op, other) {
+        var msg = "unsupported operand type(s) for " + op +
+            ": 'float' and '" + $B.class_name(other) + "'"
+        throw _b_.TypeError.$factory(msg)
+    }
+
+    function float_value(obj) {
+        return obj.$brython_value !== undefined ? obj.$brython_value : obj
+    }
+    var float = {
+        __class__: _b_.type,
+        __dir__: object.__dir__,
+        $infos: {
+            __module__: "builtins",
+            __name__: "float"
+        },
+        $is_class: true,
+        $native: true,
+        $descriptors: {
+            "numerator": true,
+            "denominator": true,
+            "imag": true,
+            "real": true
+        }
+    }
+    float.numerator = function(self) {
+        return float_value(self)
+    }
+    float.denominator = function(self) {
+        return _b_.int.$factory(1)
+    }
+    float.imag = function(self) {
+        return _b_.int.$factory(0)
+    }
+    float.real = function(self) {
+        return float_value(self)
+    }
+    float.__float__ = function(self) {
+        return float_value(self)
+    }
+    $B.shift1_cache = {}
+    float.as_integer_ratio = function(self) {
+        self = float_value(self)
+        if (self.valueOf() == Number.POSITIVE_INFINITY ||
+            self.valueOf() == Number.NEGATIVE_INFINITY) {
+            throw _b_.OverflowError.$factory("Cannot pass infinity to " +
+                "float.as_integer_ratio.")
+        }
+        if (!Number.isFinite(self.valueOf())) {
+            throw _b_.ValueError.$factory("Cannot pass NaN to " +
+                "float.as_integer_ratio.")
+        }
+        var tmp = _b_.$frexp(self.valueOf()),
+            fp = tmp[0],
+            exponent = tmp[1]
+        for (var i = 0; i < 300; i++) {
+            if (fp == Math.floor(fp)) {
+                break
+            } else {
+                fp *= 2
+                exponent--
+            }
+        }
+        numerator = _b_.int.$factory(fp)
+        py_exponent = _b_.abs(exponent)
+        denominator = 1
+        var x
+        if ($B.shift1_cache[py_exponent] !== undefined) {
+            x = $B.shift1_cache[py_exponent]
+        } else {
+            x = $B.$getattr(1, "__lshift__")(py_exponent)
+            $B.shift1_cache[py_exponent] = x
+        }
+        py_exponent = x
+        if (exponent > 0) {
+            numerator = $B.rich_op("mul", numerator, py_exponent)
+        } else {
+            denominator = py_exponent
+        }
+        return $B.fast_tuple([_b_.int.$factory(numerator), _b_.int.$factory(denominator)])
+    }
+    float.__abs__ = function(self) {
+        return new Number(Math.abs(float_value(self)))
+    }
+    float.__bool__ = function(self) {
+        self = float_value(self)
+        return _b_.bool.$factory(self.valueOf())
+    }
+    float.__divmod__ = function(self, other) {
+        if (!_b_.isinstance(other, [_b_.int, float])) {
+            return _b_.NotImplemented
+        }
+        return $B.fast_tuple([float.__floordiv__(self, other), float.__mod__(self, other)])
+    }
+    float.__eq__ = function(self, other) {
+        self = float_value(self)
+        other = float_value(other)
+        if (isNaN(self) && isNaN(other)) {
+            return false
+        }
+        if (_b_.isinstance(other, _b_.int)) {
+            return self == other
+        }
+        if (_b_.isinstance(other, float)) {
+            return self.valueOf() == other.valueOf()
+        }
+        if (_b_.isinstance(other, _b_.complex)) {
+            if (other.$imag != 0) {
+                return false
+            }
+            return self == other.$real
+        }
+        return _b_.NotImplemented
+    }
+    float.__floordiv__ = function(self, other) {
+        self = float_value(self)
+        other = float_value(other)
+        if (_b_.isinstance(other, [_b_.int, float])) {
+            if (other.valueOf() == 0) {
+                throw _b_.ZeroDivisionError.$factory('division by zero')
+            }
+            return float.$factory(Math.floor(self / other))
+        }
+        return _b_.NotImplemented
+    }
+    float.fromhex = function(arg) {
+        if (!_b_.isinstance(arg, _b_.str)) {
+            throw _b_.ValueError.$factory("argument must be a string")
+        }
+        var value = arg.trim()
+        switch (value.toLowerCase()) {
+            case "+inf":
+            case "inf":
+            case "+infinity":
+            case "infinity":
+                return $FloatClass(Infinity)
+            case "-inf":
+            case "-infinity":
+                return $FloatClass(-Infinity)
+            case "+nan":
+            case "nan":
+                return $FloatClass(Number.NaN)
+            case "-nan":
+                return $FloatClass(-Number.NaN)
+            case "":
+                throw _b_.ValueError.$factory("could not convert string to float")
+        }
+        var mo = /^(\d*)(\.?)(\d*)$/.exec(value)
+        if (mo !== null) {
+            var res = parseFloat(mo[1]),
+                coef = 16
+            if (mo[2]) {
+                for (var digit of mo[3]) {
+                    res += parseInt(digit, 16) / coef
+                    coef *= 16
+                }
+            }
+            return $FloatClass(res)
+        }
+        var _m = /^(\+|-)?(0x)?([0-9A-F]+\.?)?(\.[0-9A-F]+)?(p(\+|-)?\d+)?$/i.exec(value)
+        if (_m == null) {
+            throw _b_.ValueError.$factory("invalid hexadecimal floating-point string")
+        }
+        var _sign = _m[1],
+            _int = parseInt(_m[3] || '0', 16),
+            _fraction = _m[4] || '.0',
+            _exponent = _m[5] || 'p0'
+        if (_sign == "-") {
+            _sign = -1
+        } else {
+            _sign = 1
+        }
+        var _sum = _int
+        for (var i = 1, len = _fraction.length; i < len; i++) {
+            _sum += parseInt(_fraction.charAt(i), 16) / Math.pow(16, i)
+        }
+        return new Number(_sign * _sum * Math.pow(2, parseInt(_exponent.substring(1))))
+    }
+    float.__getformat__ = function(arg) {
+        if (arg == "double" || arg == "float") {
+            return "IEEE, little-endian"
+        }
+        throw _b_.ValueError.$factory("__getformat__() argument 1 must be " +
+            "'double' or 'float'")
+    }
+
+    function preformat(self, fmt) {
+        if (fmt.empty) {
+            return _b_.str.$factory(self)
+        }
+        if (fmt.type && 'eEfFgGn%'.indexOf(fmt.type) == -1) {
+            throw _b_.ValueError.$factory("Unknown format code '" + fmt.type +
+                "' for object of type 'float'")
+        }
+        if (isNaN(self)) {
+            if (fmt.type == "f" || fmt.type == "g") {
+                return "nan"
+            } else {
+                return "NAN"
+            }
+        }
+        if (self == Number.POSITIVE_INFINITY) {
+            if (fmt.type == "f" || fmt.type == "g") {
+                return "inf"
+            } else {
+                return "INF"
+            }
+        }
+        if (fmt.precision === undefined && fmt.type !== undefined) {
+            fmt.precision = 6
+        }
+        if (fmt.type == "%") {
+            self *= 100
+        }
+        if (fmt.type == "e") {
+            var res = self.toExponential(fmt.precision),
+                exp = parseInt(res.substr(res.search("e") + 1))
+            if (Math.abs(exp) < 10) {
+                res = res.substr(0, res.length - 1) + "0" +
+                    res.charAt(res.length - 1)
+            }
+            return res
+        }
+        if (fmt.precision !== undefined) {
+            var prec = fmt.precision
+            if (prec == 0) {
+                return Math.round(self) + ""
+            }
+            var res = self.toFixed(prec),
+                pt_pos = res.indexOf(".")
+            if (fmt.type !== undefined &&
+                (fmt.type == "%" || fmt.type.toLowerCase() == "f")) {
+                if (pt_pos == -1) {
+                    res += "." + "0".repeat(fmt.precision)
+                } else {
+                    var missing = fmt.precision - res.length + pt_pos + 1
+                    if (missing > 0) {
+                        res += "0".repeat(missing)
+                    }
+                }
+            } else if (fmt.type && fmt.type.toLowerCase() == "g") {
+                var exp_fmt = preformat(self, {
+                        type: "e"
+                    }).split("e"),
+                    exp = parseInt(exp_fmt[1])
+                if (-4 <= exp && exp < fmt.precision) {
+                    res = preformat(self, {
+                        type: "f",
+                        precision: fmt.precision - 1 - exp
+                    })
+                } else {
+                    res = preformat(self, {
+                        type: "e",
+                        precision: fmt.precision - 1
+                    })
+                }
+                var parts = res.split("e")
+                if (fmt.alternate) {
+                    if (parts[0].search(/\./) == -1) {
+                        parts[0] += '.'
+                    }
+                } else {
+                    if (parts[1]) {
+                        var signif = parts[0]
+                        while (signif.endsWith("0")) {
+                            signif = signif.substr(0, signif.length - 1)
+                        }
+                        if (signif.endsWith(".")) {
+                            signif = signif.substr(0, signif.length - 1)
+                        }
+                        parts[0] = signif
+                    }
+                }
+                res = parts.join("e")
+                if (fmt.type == "G") {
+                    res = res.toUpperCase()
+                }
+                return res
+            } else if (fmt.type === undefined) {
+                fmt.type = "g"
+                res = preformat(self, fmt)
+                fmt.type = undefined
+            } else {
+                var res1 = self.toExponential(fmt.precision - 1),
+                    exp = parseInt(res1.substr(res1.search("e") + 1))
+                if (exp < -4 || exp >= fmt.precision - 1) {
+                    var elts = res1.split("e")
+                    while (elts[0].endsWith("0")) {
+                        elts[0] = elts[0].substr(0, elts[0].length - 1)
+                    }
+                    res = elts.join("e")
+                }
+            }
+        } else {
+            var res = _b_.str.$factory(self)
+        }
+        if (fmt.type === undefined || "gGn".indexOf(fmt.type) != -1) {
+            if (res.search("e") == -1) {
+                while (res.charAt(res.length - 1) == "0") {
+                    res = res.substr(0, res.length - 1)
+                }
+            }
+            if (res.charAt(res.length - 1) == ".") {
+                if (fmt.type === undefined) {
+                    res += "0"
+                } else {
+                    res = res.substr(0, res.length - 1)
+                }
+            }
+        }
+        if (fmt.sign !== undefined) {
+            if ((fmt.sign == " " || fmt.sign == "+") && self > 0) {
+                res = fmt.sign + res
+            }
+        }
+        if (fmt.type == "%") {
+            res += "%"
+        }
+        return res
+    }
+    float.__format__ = function(self, format_spec) {
+        self = float_value(self)
+        var fmt = new $B.parse_format_spec(format_spec)
+        fmt.align = fmt.align || ">"
+        var raw = preformat(self, fmt).split('.'),
+            _int = raw[0]
+        if (fmt.comma) {
+            var len = _int.length,
+                nb = Math.ceil(_int.length / 3),
+                chunks = []
+            for (var i = 0; i < nb; i++) {
+                chunks.push(_int.substring(len - 3 * i - 3, len - 3 * i))
+            }
+            chunks.reverse()
+            raw[0] = chunks.join(",")
+        }
+        return $B.format_width(raw.join("."), fmt)
+    }
+    float.__hash__ = function(self) {
+        if (self === undefined) {
+            return float.__hashvalue__ || $B.$py_next_hash--
+        }
+        var _v = self.valueOf()
+        if (_v === Infinity) {
+            return 314159
+        }
+        if (_v === -Infinity) {
+            return -271828
+        }
+        if (isNaN(_v)) {
+            return 0
+        }
+        if (_v == Math.round(_v)) {
+            return Math.round(_v)
+        }
+        var r = _b_.$frexp(_v)
+        r[0] *= Math.pow(2, 31)
+        var hipart = _b_.int.$factory(r[0])
+        r[0] = (r[0] - hipart) * Math.pow(2, 31)
+        var x = hipart + _b_.int.$factory(r[0]) + (r[1] << 15)
+        return x & 0xFFFFFFFF
+    }
+    _b_.$isninf = function(x) {
+        var x1 = x
+        if (_b_.isinstance(x, float)) {
+            x1 = float.numerator(x)
+        }
+        return x1 == -Infinity || x1 == Number.NEGATIVE_INFINITY
+    }
+    _b_.$isinf = function(x) {
+        var x1 = x
+        if ((!x instanceof Number) && _b_.isinstance(x, float)) {
+            x1 = float.numerator(x)
+        }
+        return x1 == Infinity || x1 == -Infinity ||
+            x1 == Number.POSITIVE_INFINITY || x1 == Number.NEGATIVE_INFINITY
+    }
+    _b_.$isnan = function(x) {
+        var x1 = x
+        if (_b_.isinstance(x, float)) {
+            x1 = float.numerator(x)
+        }
+        return isNaN(x1)
+    }
+    _b_.$fabs = function(x) {
+        if (x == 0) {
+            return new Number(0)
+        }
+        return x > 0 ? float.$factory(x) : float.$factory(-x)
+    }
+    _b_.$frexp = function(x) {
+        var x1 = x
+        if (_b_.isinstance(x, float)) {
+            x1 = x.valueOf()
+        }
+        if (isNaN(x1) || _b_.$isinf(x1)) {
+            return [x1, -1]
+        } else if (x1 == 0) {
+            return [0, 0]
+        }
+        var sign = 1,
+            ex = 0,
+            man = x1
+        if (man < 0.) {
+            sign = -sign
+            man = -man
+        }
+        while (man < 0.5) {
+            man *= 2.0
+            ex--
+        }
+        while (man >= 1.0) {
+            man *= 0.5
+            ex++
+        }
+        man *= sign
+        return [man, ex]
+    }
+    _b_.$ldexp = function(x, i) {
+        if (_b_.$isninf(x)) {
+            return float.$factory('-inf')
+        }
+        if (_b_.$isinf(x)) {
+            return float.$factory('inf')
+        }
+        var y = x
+        if (_b_.isinstance(x, float)) {
+            y = x.valueOf()
+        }
+        if (y == 0) {
+            return y
+        }
+        var j = i
+        if (_b_.isinstance(i, float)) {
+            j = i.valueOf()
+        }
+        return y * Math.pow(2, j)
+    }
+    float.hex = function(self) {
+        self = float_value(self)
+        var DBL_MANT_DIG = 53,
+            TOHEX_NBITS = DBL_MANT_DIG + 3 - (DBL_MANT_DIG + 2) % 4
+        switch (self.valueOf()) {
+            case Infinity:
+            case -Infinity:
+            case Number.NaN:
+            case -Number.NaN:
+                return self
+            case -0:
+                return "-0x0.0p0"
+            case 0:
+                return "0x0.0p0"
+        }
+        var _a = _b_.$frexp(_b_.$fabs(self.valueOf())),
+            _m = _a[0],
+            _e = _a[1],
+            _shift = 1 - Math.max(-1021 - _e, 0)
+        _m = _b_.$ldexp(_m, _shift)
+        _e -= _shift
+        var _int2hex = "0123456789ABCDEF".split(""),
+            _s = _int2hex[Math.floor(_m)]
+        _s += '.'
+        _m -= Math.floor(_m)
+        for (var i = 0; i < (TOHEX_NBITS - 1) / 4; i++) {
+            _m *= 16.0
+            _s += _int2hex[Math.floor(_m)]
+            _m -= Math.floor(_m)
+        }
+        var _esign = "+"
+        if (_e < 0) {
+            _esign = "-"
+            _e = -_e
+        }
+        if (self.value < 0) {
+            return "-0x" + _s + "p" + _esign + _e
+        }
+        return "0x" + _s + "p" + _esign + _e
+    }
+    float.__init__ = function(self, value) {
+        return _b_.None
+    }
+    float.__int__ = function(self) {
+        return parseInt(self)
+    }
+    float.is_integer = function(self) {
+        return _b_.int.$factory(self) == self
+    }
+    float.__mod__ = function(self, other) {
+        self = float_value(self)
+        other = float_value(other)
+        if (other == 0) {
+            throw _b_.ZeroDivisionError.$factory("float modulo")
+        }
+        if (_b_.isinstance(other, _b_.int)) {
+            other = _b_.int.numerator(other)
+            return new Number((self % other + other) % other)
+        }
+        if (_b_.isinstance(other, float)) {
+            var q = Math.floor(self / other),
+                r = self - other * q
+            return new Number(r)
+        }
+        return _b_.NotImplemented
+    }
+    float.__mro__ = [object]
+    float.__mul__ = function(self, other) {
+        self = float_value(self)
+        other = float_value(other)
+        if (_b_.isinstance(other, _b_.int)) {
+            if (other.__class__ == $B.long_int) {
+                return new Number(self * parseFloat(other.value))
+            }
+            other = _b_.int.numerator(other)
+            return new Number(self * other)
+        }
+        if (_b_.isinstance(other, float)) {
+            return new Number(self * float_value(other))
+        }
+        return _b_.NotImplemented
+    }
+    float.__ne__ = function(self, other) {
+        var res = float.__eq__(self, other)
+        return res === _b_.NotImplemented ? res : !res
+    }
+    float.__neg__ = function(self) {
+        return new Number(-float_value(self))
+    }
+    float.__new__ = function(cls, value) {
+        if (cls === undefined) {
+            throw _b_.TypeError.$factory("float.__new__(): not enough arguments")
+        } else if (!_b_.isinstance(cls, _b_.type)) {
+            throw _b_.TypeError.$factory("float.__new__(X): X is not a type object")
+        }
+        if (cls === float) {
+            return float.$factory(value)
+        }
+        return {
+            __class__: cls,
+            __dict__: $B.empty_dict(),
+            $brython_value: value || 0
+        }
+    }
+    float.__pos__ = function(self) {
+        return float_value(self)
+    }
+    float.__pow__ = function(self, other) {
+        self = float_value(self)
+        other = float_value(other)
+        var other_int = _b_.isinstance(other, _b_.int)
+        if (other_int || _b_.isinstance(other, float)) {
+            if (self == 1) {
+                return self
+            }
+            if (other == 0) {
+                return new Number(1)
+            }
+            if (self == -1 &&
+                (!isFinite(other) || other.__class__ === $B.long_int ||
+                    !$B.is_safe_int(other)) &&
+                !isNaN(other)) {
+                return new Number(1)
+            } else if (self == 0 && isFinite(other) && other < 0) {
+                throw _b_.ZeroDivisionError.$factory("0.0 cannot be raised " +
+                    "to a negative power")
+            } else if (self == Number.NEGATIVE_INFINITY && !isNaN(other)) {
+                if (other < 0 && other % 2 == 1) {
+                    return new Number(-0.0)
+                } else if (other < 0) {
+                    return new Number(0)
+                } else if (other > 0 && other % 2 == 1) {
+                    return Number.NEGATIVE_INFINITY
+                } else {
+                    return Number.POSITIVE_INFINITY
+                }
+            } else if (self == Number.POSITIVE_INFINITY && !isNaN(other)) {
+                return other > 0 ? self : new Number(0)
+            }
+            if (other == Number.NEGATIVE_INFINITY && !isNaN(self)) {
+                return Math.abs(self) < 1 ? Number.POSITIVE_INFINITY :
+                    new Number(0)
+            } else if (other == Number.POSITIVE_INFINITY && !isNaN(self)) {
+                return Math.abs(self) < 1 ? new Number(0) :
+                    Number.POSITIVE_INFINITY
+            }
+            if (self < 0 &&
+                !$B.$getattr(other, "__eq__")(_b_.int.$factory(other))) {
+                return _b_.complex.__pow__($B.make_complex(self, 0), other)
+            }
+            return float.$factory(Math.pow(self, other))
+        }
+        return _b_.NotImplemented
+    }
+
+    function __newobj__() {
+        var $ = $B.args('__newobj__', 0, {}, [], arguments, {}, 'args', null),
+            args = $.args
+        var res = args.slice(1)
+        res.__class__ = args[0]
+        return res
+    }
+    float.__reduce_ex__ = function(self) {
+        return $B.fast_tuple([__newobj__, $B.fast_tuple([self.__class__ || _b_.int, float_value(self)]), _b_.None, _b_.None, _b_.None])
+    }
+    float.__repr__ = function(self) {
+        $B.builtins_repr_check(float, arguments)
+        self = float_value(self).valueOf()
+        if (self == Infinity) {
+            return 'inf'
+        } else if (self == -Infinity) {
+            return '-inf'
+        } else if (isNaN(self)) {
+            return 'nan'
+        } else if (self === 0) {
+            if (1 / self === -Infinity) {
+                return '-0.0'
+            }
+            return '0.0'
+        }
+        var res = self + ""
+        if (res.indexOf(".") == -1) {
+            res += ".0"
+        }
+        var split_e = res.split(/e/i)
+        if (split_e.length == 2) {
+            var mant = split_e[0],
+                exp = split_e[1]
+            if (exp.startsWith('-')) {
+                exp_str = parseInt(exp.substr(1)) + ''
+                if (exp_str.length < 2) {
+                    exp_str = '0' + exp_str
+                }
+                return mant + 'e-' + exp_str
+            }
+        }
+        var x, y[x, y] = res.split('.')
+        if (x.length > 16) {
+            var exp = x.length - 1,
+                int_part = x[0],
+                dec_part = x.substr(1) + y
+            while (dec_part.endsWith("0")) {
+                dec_part = dec_part.substr(0, dec_part.length - 1)
+            }
+            var mant = int_part
+            if (dec_part.length > 0) {
+                mant += '.' + dec_part
+            }
+            return mant + 'e+' + exp
+        } else if (x == "0") {
+            var exp = 0
+            while (exp < y.length && y.charAt(exp) == "0") {
+                exp++
+            }
+            if (exp > 3) {
+                var rest = y.substr(exp),
+                    exp = (exp + 1).toString()
+                while (rest.endsWith("0")) {
+                    rest = rest.substr(0, res.length - 1)
+                }
+                var mant = rest[0]
+                if (rest.length > 1) {
+                    mant += '.' + rest.substr(1)
+                }
+                if (exp.length == 1) {
+                    exp = '0' + exp
+                }
+                return mant + 'e-' + exp
+            }
+        }
+        return _b_.str.$factory(res)
+    }
+    float.__setattr__ = function(self, attr, value) {
+        if (self.constructor === Number) {
+            if (float[attr] === undefined) {
+                throw _b_.AttributeError.$factory("'float' object has no attribute '" +
+                    attr + "'")
+            } else {
+                throw _b_.AttributeError.$factory("'float' object attribute '" +
+                    attr + "' is read-only")
+            }
+        }
+        self[attr] = value
+        return _b_.None
+    }
+    float.__truediv__ = function(self, other) {
+        self = float_value(self)
+        other = float_value(other)
+        if (_b_.isinstance(other, [_b_.int, float])) {
+            if (other.valueOf() == 0) {
+                throw _b_.ZeroDivisionError.$factory("division by zero")
+            }
+            return float.$factory(self / other)
+        }
+        return _b_.NotImplemented
+    }
+    var $op_func = function(self, other) {
+        self = float_value(self)
+        other = float_value(other)
+        if (_b_.isinstance(other, _b_.int)) {
+            if (typeof other == "boolean") {
+                return other ? self - 1 : self
+            } else if (other.__class__ === $B.long_int) {
+                return float.$factory(self - parseInt(other.value))
+            } else {
+                return float.$factory(self - other)
+            }
+        }
+        if (_b_.isinstance(other, float)) {
+            return float.$factory(self - other)
+        }
+        return _b_.NotImplemented
+    }
+    $op_func += ""
+    var $ops = {
+        "+": "add",
+        "-": "sub"
+    }
+    for (var $op in $ops) {
+        var $opf = $op_func.replace(/-/gm, $op)
+        $opf = $opf.replace(/__rsub__/gm, "__r" + $ops[$op] + "__")
+        eval("float.__" + $ops[$op] + "__ = " + $opf)
+    }
+    var $comp_func = function(self, other) {
+        self = float_value(self)
+        other = float_value(other)
+        if (_b_.isinstance(other, _b_.int)) {
+            if (other.__class__ === $B.long_int) {
+                return self > parseInt(other.value)
+            }
+            return self > other.valueOf()
+        }
+        if (_b_.isinstance(other, float)) {
+            return self > other
+        }
+        if (_b_.isinstance(other, _b_.bool)) {
+            return self.valueOf() > _b_.bool.__hash__(other)
+        }
+        if (_b_.hasattr(other, "__int__") || _b_.hasattr(other, "__index__")) {
+            return _b_.int.__gt__(self, $B.$GetInt(other))
+        }
+        var inv_op = $B.$getattr(other, "__le__", _b_.None)
+        if (inv_op !== _b_.None) {
+            return inv_op(self)
+        }
+        throw _b_.TypeError.$factory(
+            "unorderable types: float() > " + $B.class_name(other) + "()")
+    }
+    $comp_func += ""
+    for (var $op in $B.$comps) {
+        eval("float.__" + $B.$comps[$op] + "__ = " +
+            $comp_func.replace(/>/gm, $op).replace(/__gt__/gm, "__" + $B.$comps[$op] + "__").replace(/__le__/, "__" + $B.$inv_comps[$op] + "__"))
+    }
+    var r_opnames = ["add", "sub", "mul", "truediv", "floordiv", "mod", "pow", "lshift", "rshift", "and", "xor", "or", "divmod"]
+    for (var r_opname of r_opnames) {
+        if (float["__r" + r_opname + "__"] === undefined &&
+            float['__' + r_opname + '__']) {
+            float["__r" + r_opname + "__"] = (function(name) {
+                return function(self, other) {
+                    if (_b_.isinstance(other, _b_.int)) {
+                        other = float_value(_b_.int.numerator(other))
+                        return float["__" + name + "__"](other, self)
+                    } else if (_b_.isinstance(other, float)) {
+                        other = float_value(other)
+                        return float["__" + name + "__"](other, self)
+                    }
+                    return _b_.NotImplemented
+                }
+            })(r_opname)
+        }
+    }
+
+    function $FloatClass(value) {
+        return new Number(value)
+    }
+
+    function to_digits(s) {
+        var arabic_digits = "\u0660\u0661\u0662\u0663\u0664\u0665\u0666\u0667\u0668\u0669",
+            res = ""
+        for (var i = 0; i < s.length; i++) {
+            var x = arabic_digits.indexOf(s[i])
+            if (x > -1) {
+                res += x
+            } else {
+                res += s[i]
+            }
+        }
+        return res
+    }
+    float.$factory = function(value) {
+        switch (value) {
+            case undefined:
+                return $FloatClass(0.0)
+            case Number.MAX_VALUE:
+                return $FloatClass(Infinity)
+            case -Number.MAX_VALUE:
+                return $FloatClass(-Infinity)
+            case true:
+                return new Number(1)
+            case false:
+                return new Number(0)
+        }
+        if (typeof value == "number") {
+            return new Number(value)
+        }
+        if (_b_.isinstance(value, float)) {
+            return float_value(value)
+        }
+        if (_b_.isinstance(value, _b_.bytes)) {
+            var s = $B.$getattr(value, "decode")("latin-1")
+            return float.$factory($B.$getattr(value, "decode")("latin-1"))
+        }
+        if (typeof value == "string") {
+            value = value.trim()
+            switch (value.toLowerCase()) {
+                case "+inf":
+                case "inf":
+                case "+infinity":
+                case "infinity":
+                    return Number.POSITIVE_INFINITY
+                case "-inf":
+                case "-infinity":
+                    return Number.NEGATIVE_INFINITY
+                case "+nan":
+                case "nan":
+                    return Number.NaN
+                case "-nan":
+                    return -Number.NaN
+                case "":
+                    throw _b_.ValueError.$factory("count not convert string to float")
+                default:
+                    value = value.charAt(0) + value.substr(1).replace(/_/g, "")
+                    value = to_digits(value)
+                    if (isFinite(value)) return $FloatClass(eval(value))
+                    else {
+                        _b_.str.encode(value, "latin-1")
+                        throw _b_.ValueError.$factory(
+                            "Could not convert to float(): '" +
+                            _b_.str.$factory(value) + "'")
+                    }
+            }
+        }
+        var klass = value.__class__ || $B.get_class(value),
+            num_value = $B.to_num(value, ["__float__", "__index__"])
+        if (value !== Number.POSITIVE_INFINITY && !isFinite(num_value)) {
+            throw _b_.OverflowError.$factory('int too large to convert to float')
+        }
+        if (num_value !== null) {
+            return num_value
+        }
+        throw _b_.TypeError.$factory("float() argument must be a string or a " +
+            "number, not '" + $B.class_name(value) + "'")
+    }
+    $B.$FloatClass = $FloatClass
+    $B.set_func_names(float, "builtins")
+    var FloatSubclass = $B.FloatSubclass = {
+        __class__: _b_.type,
+        __mro__: [object],
+        $infos: {
+            __module__: "builtins",
+            __name__: "float"
+        },
+        $is_class: true
+    }
+    for (var $attr in float) {
+        if (typeof float[$attr] == "function") {
+            FloatSubclass[$attr] = (function(attr) {
+                return function() {
+                    var args = [],
+                        pos = 0
+                    if (arguments.length > 0) {
+                        var args = [arguments[0].valueOf()],
+                            pos = 1
+                        for (var i = 1, len = arguments.length; i < len; i++) {
+                            args[pos++] = arguments[i]
+                        }
+                    }
+                    return float[attr].apply(null, args)
+                }
+            })($attr)
+        }
+    }
+    $B.set_func_names(FloatSubclass, "builtins")
+    _b_.float = float
+})(__BRYTHON__);;
+(function($B) {
+    var _b_ = $B.builtins
+
+    function $UnsupportedOpType(op, class1, class2) {
+        throw _b_.TypeError.$factory("unsupported operand type(s) for " +
+            op + ": '" + class1 + "' and '" + class2 + "'")
+    }
+    var complex = {
+        __class__: _b_.type,
+        __dir__: _b_.object.__dir__,
+        $infos: {
+            __module__: "builtins",
+            __name__: "complex"
+        },
+        $is_class: true,
+        $native: true,
+        $descriptors: {
+            real: true,
+            imag: true
+        }
+    }
+    complex.__abs__ = function(self) {
+        var _rf = isFinite(self.$real),
+            _if = isFinite(self.$imag)
+        if ((_rf && isNaN(self.$imag)) || (_if && isNaN(self.$real)) ||
+            (isNaN(self.$imag) && isNaN(self.$real))) {
+            return NaN
+        }
+        if (!_rf || !_if) {
+            return Infinity
+        }
+        var mag = Math.sqrt(Math.pow(self.$real, 2) + Math.pow(self.$imag, 2))
+        if (!isFinite(mag) && _rf && _if) {
+            throw _b_.OverflowError.$factory("absolute value too large")
+        }
+        return mag
+    }
+    complex.__add__ = function(self, other) {
+        if (_b_.isinstance(other, complex)) {
+            return make_complex(self.$real + other.$real, self.$imag + other.$imag)
+        }
+        if (_b_.isinstance(other, _b_.int)) {
+            other = _b_.int.numerator(other)
+            return make_complex($B.add(self.$real, other.valueOf()), self.$imag)
+        }
+        if (_b_.isinstance(other, _b_.float)) {
+            return make_complex(self.$real + other.valueOf(), self.$imag)
+        }
+        return _b_.NotImplemented
+    }
+    complex.__bool__ = function(self) {
+        return (self.$real != 0 || self.$imag != 0)
+    }
+    complex.__complex__ = function(self) {
+        return self
+    }
+    complex.__eq__ = function(self, other) {
+        if (_b_.isinstance(other, complex)) {
+            return self.$real.valueOf() == other.$real.valueOf() &&
+                self.$imag.valueOf() == other.$imag.valueOf()
+        }
+        if (_b_.isinstance(other, _b_.int)) {
+            if (self.$imag != 0) {
+                return false
+            }
+            return self.$real == other.valueOf()
+        }
+        if (_b_.isinstance(other, _b_.float)) {
+            if (self.$imag != 0) {
+                return false
+            }
+            return self.$real == other.valueOf()
+        }
+        return _b_.NotImplemented
+    }
+    complex.__hash__ = function(self) {
+        return self.$imag * 1000003 + self.$real
+    }
+    complex.__init__ = function() {
+        return _b_.None
+    }
+    complex.__invert__ = function(self) {
+        return ~self
+    }
+    complex.__mro__ = [_b_.object]
+    complex.__mul__ = function(self, other) {
+        if (_b_.isinstance(other, complex)) {
+            return make_complex(self.$real * other.$real - self.$imag * other.$imag, self.$imag * other.$real + self.$real * other.$imag)
+        } else if (_b_.isinstance(other, _b_.int)) {
+            return make_complex(self.$real * other.valueOf(), self.$imag * other.valueOf())
+        } else if (_b_.isinstance(other, _b_.float)) {
+            return make_complex(self.$real * other, self.$imag * other)
+        } else if (_b_.isinstance(other, _b_.bool)) {
+            if (other.valueOf()) {
+                return self
+            }
+            return make_complex(0, 0)
+        }
+        $UnsupportedOpType("*", complex, other)
+    }
+    complex.__ne__ = function(self, other) {
+        var res = complex.__eq__(self, other)
+        return res === _b_.NotImplemented ? res : !res
+    }
+    complex.__neg__ = function(self) {
+        return make_complex(-self.$real, -self.$imag)
+    }
+    complex.__new__ = function(cls) {
+        if (cls === undefined) {
+            throw _b_.TypeError.$factory('complex.__new__(): not enough arguments')
+        }
+        var res, missing = {},
+            args = $B.args("complex", 3, {
+                cls: null,
+                real: null,
+                imag: null
+            }, ["cls", "real", "imag"], arguments, {
+                real: 0,
+                imag: missing
+            }, null, null),
+            $real = args.real,
+            $imag = args.imag
+        if (typeof $real == "string") {
+            if ($imag !== missing) {
+                throw _b_.TypeError.$factory("complex() can't take second arg " +
+                    "if first is a string")
+            } else {
+                var arg = $real
+                $real = $real.trim()
+                if ($real.startsWith("(") && $real.endsWith(")")) {
+                    $real = $real.substr(1)
+                    $real = $real.substr(0, $real.length - 1)
+                }
+                var complex_re = /^\s*([\+\-]*[0-9_]*\.?[0-9_]*(e[\+\-]*[0-9_]*)?)([\+\-]?)([0-9_]*\.?[0-9_]*(e[\+\-]*[0-9_]*)?)(j?)\s*$/i
+                var parts = complex_re.exec($real)
+
+                function to_num(s) {
+                    var res = parseFloat(s.charAt(0) + s.substr(1).replace(/_/g, ""))
+                    if (isNaN(res)) {
+                        throw _b_.ValueError.$factory("could not convert string " +
+                            "to complex: '" + arg + "'")
+                    }
+                    return res
+                }
+                if (parts === null) {
+                    throw _b_.ValueError.$factory("complex() arg is a malformed string")
+                } else if (parts[_real] == "." || parts[_imag] == "." ||
+                    parts[_real] == ".e" || parts[_imag] == ".e" ||
+                    parts[_real] == "e" || parts[_imag] == "e") {
+                    throw _b_.ValueError.$factory("complex() arg is a malformed string")
+                } else if (parts[_j] != "") {
+                    if (parts[_sign] == "") {
+                        $real = 0
+                        if (parts[_real] == "+" || parts[_real] == "") {
+                            $imag = 1
+                        } else if (parts[_real] == '-') {
+                            $imag = -1
+                        } else {
+                            $imag = to_num(parts[_real])
+                        }
+                    } else {
+                        $real = to_num(parts[_real])
+                        $imag = parts[_imag] == "" ? 1 : to_num(parts[_imag])
+                        $imag = parts[_sign] == "-" ? -$imag : $imag
+                    }
+                } else {
+                    $real = to_num(parts[_real])
+                    $imag = 0
+                }
+                res = {
+                    __class__: complex,
+                    $real: $real || 0,
+                    $imag: $imag || 0
+                }
+                return res
+            }
+        }
+        $imag = $imag === missing ? 0 : $imag
+        if (arguments.length == 2 && $real.__class__ === complex && $imag == 0) {
+            return $real
+        }
+        if (_b_.isinstance($real, [_b_.float, _b_.int]) &&
+            _b_.isinstance($imag, [_b_.float, _b_.int])) {
+            res = {
+                __class__: complex,
+                $real: $real,
+                $imag: $imag
+            }
+            return res
+        }
+        var real_to_num = $B.to_num($real, ["__complex__", "__float__", "__index__"])
+        if (real_to_num === null) {
+            throw _b_.TypeError.$factory("complex() first argument must be a " +
+                " string or a number, not '" + $B.class_name($real) + "'")
+        }
+        $real = real_to_num
+        $imag = _convert($imag)
+        if (!_b_.isinstance($real, _b_.float) && !_b_.isinstance($real, _b_.int) &&
+            !_b_.isinstance($real, _b_.complex)) {
+            throw _b_.TypeError.$factory("complex() argument must be a string " +
+                "or a number")
+        }
+        if (typeof $imag == "string") {
+            throw _b_.TypeError.$factory("complex() second arg can't be a string")
+        }
+        if (!_b_.isinstance($imag, _b_.float) && !_b_.isinstance($imag, _b_.int) &&
+            !_b_.isinstance($imag, _b_.complex) && $imag !== missing) {
+            throw _b_.TypeError.$factory("complex() argument must be a string " +
+                "or a number")
+        }
+        $imag = complex.__mul__(complex.$factory("1j"), $imag)
+        return complex.__add__($imag, $real)
+    }
+    complex.__pos__ = function(self) {
+        return self
+    }
+
+    function complex2expo(cx) {
+        var norm = Math.sqrt((cx.$real * cx.$real) + (cx.$imag * cx.$imag)),
+            sin = cx.$imag / norm,
+            cos = cx.$real / norm,
+            angle
+        if (cos == 0) {
+            angle = sin == 1 ? Math.PI / 2 : 3 * Math.PI / 2
+        } else if (sin == 0) {
+            angle = cos == 1 ? 0 : Math.PI
+        } else {
+            angle = Math.atan(sin / cos)
+        }
+        return {
+            norm: norm,
+            angle: angle
+        }
+    }
+    complex.__pow__ = function(self, other) {
+        if (other == 1) {
+            return self
+        }
+        var exp = complex2expo(self),
+            angle = exp.angle,
+            res = Math.pow(exp.norm, other)
+        if (_b_.isinstance(other, [_b_.int, _b_.float])) {
+            return make_complex(res * Math.cos(angle * other), res * Math.sin(angle * other))
+        } else if (_b_.isinstance(other, complex)) {
+            var x = other.$real,
+                y = other.$imag
+            var pw = Math.pow(exp.norm, x) * Math.pow(Math.E, -y * angle),
+                theta = y * Math.log(exp.norm) - x * angle
+            return make_complex(pw * Math.cos(theta), pw * Math.sin(theta))
+        } else {
+            throw _b_.TypeError.$factory("unsupported operand type(s) " +
+                "for ** or pow(): 'complex' and '" +
+                $B.class_name(other) + "'")
+        }
+    }
+    complex.__radd__ = function(self, other) {
+        if (_b_.isinstance(other, _b_.bool)) {
+            other = other ? 1 : 0
+        }
+        if (_b_.isinstance(other, [_b_.int, _b_.float])) {
+            return make_complex(other + self.$real, self.$imag)
+        }
+        return _b_.NotImplemented
+    }
+    complex.__repr__ = function(self) {
+        $B.builtins_repr_check(complex, arguments)
+        var real = _b_.str.$factory(self.$real),
+            imag = _b_.str.$factory(self.$imag)
+        if (self.$real instanceof Number && self.$real == parseInt(self.$real)) {
+            real = _b_.str.$factory(parseInt(self.$real))
+        }
+        if (self.$imag instanceof Number && self.$imag == parseInt(self.$imag)) {
+            imag = _b_.str.$factory(parseInt(self.$imag))
+            if (self.$imag == 0 && 1 / self.$imag === -Infinity) {
+                imag = "-0"
+            }
+        }
+        if (self.$real == 0) {
+            if (1 / self.$real < 0) {
+                if (imag.startsWith('-')) {
+                    return "-0" + imag + "j"
+                }
+                return "-0+" + imag + "j"
+            } else {
+                return imag + "j"
+            }
+        }
+        if (self.$imag > 0 || isNaN(self.$imag)) {
+            return "(" + real + "+" + imag + "j)"
+        }
+        if (self.$imag == 0) {
+            if (1 / self.$imag < 0) {
+                return "(" + real + "-0j)"
+            }
+            return "(" + real + "+0j)"
+        }
+        return "(" + real + "-" + _b_.str.$factory(-self.$imag) + "j)"
+    }
+    complex.__rmul__ = function(self, other) {
+        if (_b_.isinstance(other, _b_.bool)) {
+            other = other ? 1 : 0
+        }
+        if (_b_.isinstance(other, [_b_.int, _b_.float])) {
+            return make_complex(other * self.$real, other * self.$imag)
+        }
+        return _b_.NotImplemented
+    }
+    complex.__sqrt__ = function(self) {
+        if (self.$imag == 0) {
+            return complex(Math.sqrt(self.$real))
+        }
+        var r = self.$real,
+            i = self.$imag,
+            _a = Math.sqrt((r + sqrt) / 2),
+            _b = Number.sign(i) * Math.sqrt((-r + sqrt) / 2)
+        return make_complex(_a, _b)
+    }
+    complex.__sub__ = function(self, other) {
+        if (_b_.isinstance(other, complex)) {
+            return make_complex(self.$real - other.$real, self.$imag - other.$imag)
+        }
+        if (_b_.isinstance(other, _b_.int)) {
+            other = _b_.int.numerator(other)
+            return make_complex($B.sub(self.$real, other.valueOf()), self.$imag)
+        }
+        if (_b_.isinstance(other, _b_.float)) {
+            return make_complex(self.$real - other.valueOf(), self.$imag)
+        }
+        return _b_.NotImplemented
+    }
+    complex.__truediv__ = function(self, other) {
+        if (_b_.isinstance(other, complex)) {
+            if (other.$real == 0 && other.$imag == 0) {
+                throw _b_.ZeroDivisionError.$factory("division by zero")
+            }
+            var _num = self.$real * other.$real + self.$imag * other.$imag,
+                _div = other.$real * other.$real + other.$imag * other.$imag
+            var _num2 = self.$imag * other.$real - self.$real * other.$imag
+            return make_complex(_num / _div, _num2 / _div)
+        }
+        if (_b_.isinstance(other, _b_.int)) {
+            if (!other.valueOf()) {
+                throw _b_.ZeroDivisionError.$factory('division by zero')
+            }
+            return complex.__truediv__(self, complex.$factory(other.valueOf()))
+        }
+        if (_b_.isinstance(other, _b_.float)) {
+            if (!other.valueOf()) {
+                throw _b_.ZeroDivisionError.$factory("division by zero")
+            }
+            return complex.__truediv__(self, complex.$factory(other.valueOf()))
+        }
+        $UnsupportedOpType("//", "complex", other.__class__)
+    }
+    complex.conjugate = function(self) {
+        return make_complex(self.$real, -self.$imag)
+    }
+    complex.__ior__ = complex.__or__
+    var r_opnames = ["add", "sub", "mul", "truediv", "floordiv", "mod", "pow", "lshift", "rshift", "and", "xor", "or"]
+    for (var r_opname of r_opnames) {
+        if (complex["__r" + r_opname + "__"] === undefined &&
+            complex['__' + r_opname + '__']) {
+            complex["__r" + r_opname + "__"] = (function(name) {
+                return function(self, other) {
+                    if (_b_.isinstance(other, [_b_.int, _b_.float])) {
+                        other = make_complex(other, 0)
+                        return complex["__" + name + "__"](other, self)
+                    } else if (_b_.isinstance(other, complex)) {
+                        return complex["__" + name + "__"](other, self)
+                    }
+                    return _b_.NotImplemented
+                }
+            })(r_opname)
+        }
+    }
+    var $comp_func = function(self, other) {
+        if (other === undefined || other == _b_.None) {
+            return _b_.NotImplemented
+        }
+        throw _b_.TypeError.$factory("no ordering relation " +
+            "is defined for complex numbers")
+    }
+    $comp_func += ''
+    for (var $op in $B.$comps) {
+        eval("complex.__" + $B.$comps[$op] + "__ = " +
+            $comp_func.replace(/>/gm, $op))
+    }
+    complex.real = function(self) {
+        return new Number(self.$real)
+    }
+    complex.real.setter = function() {
+        throw _b_.AttributeError.$factory("readonly attribute")
+    }
+    complex.imag = function(self) {
+        return new Number(self.$imag)
+    }
+    complex.imag.setter = function() {
+        throw _b_.AttributeError.$factory("readonly attribute")
+    }
+    var _real = 1,
+        _real_mantissa = 2,
+        _sign = 3,
+        _imag = 4,
+        _imag_mantissa = 5,
+        _j = 6
+    var type_conversions = ["__complex__", "__float__", "__index__"]
+    var _convert = function(num) {
+        var klass = num.__class__ || $B.get_class(num)
+        for (var i = 0; i < type_conversions.length; i++) {
+            var missing = {},
+                method = $B.$getattr(klass, type_conversions[i], missing)
+            if (method !== missing) {
+                return method(num)
+            }
+        }
+        return null
+    }
+    var make_complex = $B.make_complex = function(real, imag) {
+        return {
+            __class__: complex,
+            $real: real,
+            $imag: imag
+        }
+    }
+    complex.$factory = function() {
+        return complex.__new__(complex, ...arguments)
+    }
+    $B.set_func_names(complex, "builtins")
+    _b_.complex = complex
+})(__BRYTHON__);;
+(function($B) {
+    var _b_ = $B.builtins
     var str_hash = _b_.str.__hash__,
         $N = _b_.None
     var set_ops = ["eq", "le", "lt", "ge", "gt", "sub", "rsub", "and", "or", "xor"]
 
     function is_sublist(t1, t2) {
         for (var i = 0, ilen = t1.length; i < ilen; i++) {
             var x = t1[i],
@@ -32867,15 +33190,16 @@
         __class__: _b_.type,
         __mro__: [_b_.object],
         $infos: {
             __module__: "builtins",
             __name__: "dict"
         },
         $is_class: true,
-        $native: true
+        $native: true,
+        $match_mapping_pattern: true
     }
     dict.$to_obj = function(d) {
         var res = {}
         for (var key in d.$string_dict) {
             res[key] = d.$string_dict[key][0]
         }
         return res
@@ -32969,17 +33293,14 @@
     dict.__contains__ = function() {
         var $ = $B.args("__contains__", 2, {
                 self: null,
                 key: null
             }, ["self", "key"], arguments, {}, null, null),
             self = $.self,
             key = $.key
-        if (self.$is_namespace) {
-            key = $B.to_alias(key)
-        }
         if (self.$jsobj) {
             return self.$jsobj[key] !== undefined
         }
         switch (typeof key) {
             case "string":
                 return self.$string_dict[key] !== undefined
             case "number":
@@ -33122,37 +33443,33 @@
                 self: null,
                 arg: null
             }, ["self", "arg"], arguments, {}, null, null),
             self = $.self,
             arg = $.arg
         return dict.$getitem(self, arg)
     }
-    $B.string_count = 0
-    $B.num_count = 0
     dict.$getitem = function(self, arg, ignore_missing) {
         if (self.$jsobj) {
             if (self.$jsobj[arg] === undefined) {
                 if (self.$jsobj.hasOwnProperty(arg)) {
                     return $B.Undefined
                 }
                 throw _b_.KeyError.$factory(arg)
             }
             return self.$jsobj[arg]
         }
         switch (typeof arg) {
             case "string":
                 var x = self.$string_dict[arg]
                 if (x !== undefined) {
-                    $B.string_count++
                     return x[0]
                 }
                 break
             case "number":
                 if (self.$numeric_dict[arg] !== undefined) {
-                    $B.num_count++
                     return self.$numeric_dict[arg][0]
                 }
                 break
         }
         var hash = _b_.hash(arg),
             _eq = function(other) {
                 return $B.rich_comp("__eq__", arg, other)
@@ -33176,15 +33493,15 @@
         var ix = rank(self, hash, arg)
         if (ix > -1) {
             return self.$object_dict[hash][ix][1][0]
         }
         if (!ignore_missing) {
             if (self.__class__ !== dict && !ignore_missing) {
                 try {
-                    var missing_method = getattr(self.__class__, "__missing__", _b_.None)
+                    var missing_method = $B.$getattr(self.__class__, "__missing__", _b_.None)
                 } catch (err) {
                     console.log(err)
                 }
                 if (missing_method !== _b_.None) {
                     return missing_method(self, arg)
                 }
             }
@@ -33218,15 +33535,14 @@
                 default:
                     si(self, item[0], item[1])
                     break
             }
         }
     }
     dict.__init__ = function(self, first, second) {
-        var $
         if (first === undefined) {
             return $N
         }
         if (second === undefined) {
             if (first.$nat != 'kw' && $B.get_class(first) === $B.JSObj) {
                 for (var key in first) {
                     self.$string_dict[key] = [first[key], self.$order++]
@@ -33239,15 +33555,15 @@
                 }
                 return $N
             } else if (Array.isArray(first)) {
                 init_from_list(self, first)
                 return $N
             }
         }
-        $ = $ || $B.args("dict", 1, {
+        var $ = $B.args("dict", 1, {
             self: null
         }, ["self"], arguments, {}, "first", "second")
         var args = $.first
         if (args.length > 1) {
             throw _b_.TypeError.$factory("dict expected at most 1 argument" +
                 ", got 2")
         } else if (args.length == 1) {
@@ -33303,15 +33619,15 @@
                     si(self, attr, kw[attr][0])
                     break
             }
         }
         return $N
     }
     dict.__iter__ = function(self) {
-        return _b_.iter(dict.$$keys(self))
+        return _b_.iter(dict.keys(self))
     }
     dict.__ior__ = function(self, other) {
         dict.update(self, other)
         return self
     }
     dict.__len__ = function(self) {
         var _count = 0
@@ -33382,15 +33698,15 @@
         if ($B.repr.enter(self)) {
             return "{...}"
         }
         var res = [],
             items = to_list(self)
         items.forEach(function(item) {
             try {
-                res.push(repr(item[0]) + ": " + repr(item[1]))
+                res.push(_b_.repr(item[0]) + ": " + _b_.repr(item[1]))
             } catch (err) {
                 throw err
             }
         })
         $B.repr.leave(self)
         return "{" + res.join(", ") + "}"
     }
@@ -33421,14 +33737,17 @@
                     self.$jsobj.$factory = $B.$instance_creator(self.$jsobj)
                 }
             } else {
                 self.$jsobj[key] = value
             }
             return $N
         }
+        if (key instanceof String) {
+            key = key.valueOf()
+        }
         switch (typeof key) {
             case "string":
                 if (self.$string_dict === undefined) {
                     console.log("pas de string dict", self, key, value)
                 }
                 if (self.$string_dict[key] !== undefined) {
                     self.$string_dict[key][0] = value
@@ -33578,15 +33897,15 @@
             self: null,
             key: null,
             _default: null
         }, ["self", "key", "_default"], arguments, {
             _default: $N
         }, null, null)
         try {
-            return dict.__getitem__($.self, $.key)
+            return dict.$getitem($.self, $.key, true)
         } catch (err) {
             if (_b_.isinstance(err, _b_.KeyError)) {
                 return $._default
             } else {
                 throw err
             }
         }
@@ -33612,15 +33931,15 @@
         var values = to_list(self)
         var it = dict_items.$factory(self, values, set_like)
         it.dict_version = self.$version
         return it
     }
     var dict_keys = $B.make_view("dict_keys")
     dict_keys.$iterator = $B.make_iterator_class("dict_keyiterator")
-    dict.$$keys = function(self) {
+    dict.keys = function(self) {
         if (arguments.length > 1) {
             var _len = arguments.length - 1,
                 _msg = "keys() takes no arguments (" + _len + " given)"
             throw _b_.TypeError.$factory(_msg)
         }
         var it = dict_keys.$factory(self, to_list(self, 0), true)
         it.dict_version = self.$version
@@ -33702,15 +34021,15 @@
                 if (o.$jsobj) {
                     o = jsobj2dict(o.$jsobj)
                 }
                 $copy_dict(self, o)
             } else if (_b_.hasattr(o, "keys")) {
                 var _keys = _b_.list.$factory($B.$call($B.$getattr(o, "keys"))())
                 for (var i = 0, len = _keys.length; i < len; i++) {
-                    var _value = getattr(o, "__getitem__")(_keys[i])
+                    var _value = $B.$getattr(o, "__getitem__")(_keys[i])
                     dict.$setitem(self, _keys[i], _value)
                 }
             } else {
                 var it = _b_.iter(o),
                     i = 0
                 while (true) {
                     try {
@@ -33795,14 +34114,15 @@
             var res = $B.obj_dict(dict.$to_obj(obj))
         } else {
             var res = $B.obj_dict(obj)
         }
         res.__class__ = mappingproxy
         return res
     })
+    mappingproxy.$match_mapping_pattern = true
     mappingproxy.__setitem__ = function() {
         throw _b_.TypeError.$factory("'mappingproxy' object does not support " +
             "item assignment")
     }
     for (var attr in dict) {
         if (mappingproxy[attr] !== undefined || ["__class__", "__mro__", "__new__", "__init__", "__delitem__", "clear", "fromkeys", "pop", "popitem", "setdefault", "update"].indexOf(attr) > -1) {
             continue
@@ -33847,14 +34167,1231 @@
         res.$from_js = from_js
         return res
     }
 })(__BRYTHON__);;
 (function($B) {
     var _b_ = $B.builtins,
         object = _b_.object,
+        getattr = $B.$getattr,
+        isinstance = _b_.isinstance,
+        $N = _b_.None
+
+    function check_not_tuple(self, attr) {
+        if (self.__class__ === tuple) {
+            throw _b_.AttributeError.$factory(
+                "'tuple' object has no attribute '" + attr + "'")
+        }
+    }
+
+    function $list() {
+        return list.$factory.apply(null, arguments)
+    }
+    var list = {
+        __class__: _b_.type,
+        __mro__: [object],
+        $infos: {
+            __module__: "builtins",
+            __name__: "list"
+        },
+        $is_class: true,
+        $native: true,
+        $match_sequence_pattern: true,
+        __dir__: object.__dir__
+    }
+    list.__add__ = function(self, other) {
+        if ($B.get_class(self) !== $B.get_class(other)) {
+            var this_name = $B.class_name(self)
+            var radd = $B.$getattr(other, '__radd__', null)
+            if (radd === null) {
+                throw _b_.TypeError.$factory('can only concatenate ' +
+                    this_name + ' (not "' + $B.class_name(other) +
+                    '") to ' + this_name)
+            }
+            return _b_.NotImplemented
+        }
+        var res = self.slice(),
+            is_js = other.$brython_class == "js"
+        for (const item of other) {
+            res.push(is_js ? $B.$JS2Py(item) : item)
+        }
+        res.__brython__ = true
+        if (isinstance(self, tuple)) {
+            res = tuple.$factory(res)
+        }
+        return res
+    }
+    list.__class_getitem__ = function(cls, item) {
+        if (!Array.isArray(item)) {
+            item = [item]
+        }
+        return $B.GenericAlias.$factory(cls, item)
+    }
+    list.__contains__ = function(self, item) {
+        var $ = $B.args("__contains__", 2, {
+                self: null,
+                item: null
+            }, ["self", "item"], arguments, {}, null, null),
+            self = $.self,
+            item = $.item
+        var _eq = function(other) {
+            return $B.rich_comp("__eq__", item, other)
+        }
+        var i = 0
+        while (i < self.length) {
+            if (_eq(self[i])) {
+                return true
+            }
+            i++
+        }
+        return false
+    }
+    list.__delitem__ = function(self, arg) {
+        if (isinstance(arg, _b_.int)) {
+            var pos = arg
+            if (arg < 0) {
+                pos = self.length + pos
+            }
+            if (pos >= 0 && pos < self.length) {
+                self.splice(pos, 1)
+                return $N
+            }
+            throw _b_.IndexError.$factory($B.class_name(self) +
+                " index out of range")
+        }
+        if (isinstance(arg, _b_.slice)) {
+            var step = arg.step
+            if (step === $N) {
+                step = 1
+            }
+            var start = arg.start
+            if (start === $N) {
+                start = step > 0 ? 0 : self.length
+            }
+            var stop = arg.stop
+            if (stop === $N) {
+                stop = step > 0 ? self.length : 0
+            }
+            if (start < 0) {
+                start = self.length + start
+            }
+            if (stop < 0) {
+                stop = self.length + stop
+            }
+            var res = [],
+                i = null,
+                pos = 0
+            if (step > 0) {
+                if (stop > start) {
+                    for (var i = start; i < stop; i += step) {
+                        if (self[i] !== undefined) {
+                            res[pos++] = i
+                        }
+                    }
+                }
+            } else {
+                if (stop < start) {
+                    for (var i = start; i > stop; i += step) {
+                        if (self[i] !== undefined) {
+                            res[pos++] = i
+                        }
+                    }
+                    res.reverse()
+                }
+            }
+            var i = res.length
+            while (i--) {
+                self.splice(res[i], 1)
+            }
+            return $N
+        }
+        if (_b_.hasattr(arg, "__int__") || _b_.hasattr(arg, "__index__")) {
+            list.__delitem__(self, _b_.int.$factory(arg))
+            return $N
+        }
+        throw _b_.TypeError.$factory($B.class_name(self) +
+            " indices must be integer, not " + $B.class_name(arg))
+    }
+    list.__eq__ = function(self, other) {
+        if (isinstance(self, list)) {
+            var klass = list
+        } else {
+            var klass = tuple
+        }
+        if (isinstance(other, klass)) {
+            if (other.length == self.length) {
+                var i = self.length
+                while (i--) {
+                    if (!$B.rich_comp("__eq__", self[i], other[i])) {
+                        return false
+                    }
+                }
+                return true
+            }
+        }
+        return _b_.NotImplemented
+    }
+    list.__getitem__ = function(self, key) {
+        $B.check_no_kw("__getitem__", self, key)
+        $B.check_nb_args("__getitem__", 2, arguments)
+        return list.$getitem(self, key)
+    }
+    list.$getitem = function(self, key) {
+        var klass = (self.__class__ || $B.get_class(self))
+        var factory = function(list_res) {
+            list_res.__class__ = klass
+            return list_res
+        }
+        var int_key
+        try {
+            int_key = $B.PyNumber_Index(key)
+        } catch (err) {}
+        if (int_key !== undefined) {
+            var items = self.valueOf(),
+                pos = int_key
+            if (int_key < 0) {
+                pos = items.length + pos
+            }
+            if (pos >= 0 && pos < items.length) {
+                return items[pos]
+            }
+            throw _b_.IndexError.$factory($B.class_name(self) +
+                " index out of range")
+        }
+        if (key.__class__ === _b_.slice || isinstance(key, _b_.slice)) {
+            if (key.start === _b_.None && key.stop === _b_.None &&
+                key.step === _b_.None) {
+                return self.slice()
+            }
+            var s = _b_.slice.$conv_for_seq(key, self.length)
+            var res = [],
+                i = null,
+                items = self.valueOf(),
+                pos = 0,
+                start = s.start,
+                stop = s.stop,
+                step = s.step
+            if (step > 0) {
+                if (stop <= start) {
+                    return factory(res)
+                }
+                for (var i = start; i < stop; i += step) {
+                    res[pos++] = items[i]
+                }
+                return factory(res)
+            } else {
+                if (stop > start) {
+                    return factory(res)
+                }
+                for (var i = start; i > stop; i += step) {
+                    res[pos++] = items[i]
+                }
+                return factory(res)
+            }
+        }
+        throw _b_.TypeError.$factory($B.class_name(self) +
+            " indices must be integer, not " + $B.class_name(key))
+    }
+    list.__ge__ = function(self, other) {
+        if (!isinstance(other, [list, _b_.tuple])) {
+            return _b_.NotImplemented
+        }
+        var i = 0
+        while (i < self.length) {
+            if (i >= other.length) {
+                return true
+            }
+            if ($B.rich_comp("__eq__", self[i], other[i])) {
+                i++
+            } else {
+                res = $B.$getattr(self[i], "__ge__")(other[i])
+                if (res === _b_.NotImplemented) {
+                    throw _b_.TypeError.$factory("unorderable types: " +
+                        $B.class_name(self[i]) + "() >= " +
+                        $B.class_name(other[i]) + "()")
+                } else {
+                    return res
+                }
+            }
+        }
+        return other.length == self.length
+    }
+    list.__gt__ = function(self, other) {
+        if (!isinstance(other, [list, _b_.tuple])) {
+            return _b_.NotImplemented
+        }
+        var i = 0
+        while (i < self.length) {
+            if (i >= other.length) {
+                return true
+            }
+            if ($B.rich_comp("__eq__", self[i], other[i])) {
+                i++
+            } else {
+                res = $B.$getattr(self[i], "__gt__")(other[i])
+                if (res === _b_.NotImplemented) {
+                    throw _b_.TypeError.$factory("unorderable types: " +
+                        $B.class_name(self[i]) + "() > " +
+                        $B.class_name(other[i]) + "()")
+                } else return res
+            }
+        }
+        return false
+    }
+    list.__hash__ = $N
+    list.__iadd__ = function() {
+        var $ = $B.args("__iadd__", 2, {
+            self: null,
+            x: null
+        }, ["self", "x"], arguments, {}, null, null)
+        var x = list.$factory($B.$iter($.x))
+        for (var i = 0; i < x.length; i++) {
+            $.self.push(x[i])
+        }
+        return $.self
+    }
+    list.__imul__ = function() {
+        var $ = $B.args("__imul__", 2, {
+                self: null,
+                x: null
+            }, ["self", "x"], arguments, {}, null, null),
+            x = $B.$GetInt($.x),
+            len = $.self.length,
+            pos = len
+        if (x == 0) {
+            list.clear($.self);
+            return $.self
+        }
+        for (var i = 1; i < x; i++) {
+            for (j = 0; j < len; j++) {
+                $.self[pos++] = $.self[j]
+            }
+        }
+        return $.self
+    }
+    list.__init__ = function(self, arg) {
+        var $ = $B.args('__init__', 1, {
+                self: null
+            }, ['self'], arguments, {}, 'args', null),
+            self = $.self,
+            args = $.args
+        if (args.length > 1) {
+            throw _b_.TypeError.$factory('expected at most 1 argument, got ' +
+                args.length)
+        }
+        var arg = args[0]
+        var len_func = $B.$call($B.$getattr(self, "__len__")),
+            pop_func = $B.$getattr(self, "pop", $N)
+        if (pop_func !== $N) {
+            pop_func = $B.$call(pop_func)
+            while (len_func()) {
+                pop_func()
+            }
+        }
+        if (arg === undefined) {
+            return $N
+        }
+        var arg = $B.$iter(arg),
+            next_func = $B.$call($B.$getattr(arg, "__next__")),
+            pos = len_func()
+        while (1) {
+            try {
+                var res = next_func()
+                self[pos++] = res
+            } catch (err) {
+                if (err.__class__ === _b_.StopIteration) {
+                    break
+                } else {
+                    throw err
+                }
+            }
+        }
+        return $N
+    }
+    var list_iterator = $B.make_iterator_class("list_iterator")
+    list_iterator.__reduce__ = list_iterator.__reduce_ex__ = function(self) {
+        return $B.fast_tuple([_b_.iter, $B.fast_tuple([list.$factory(self)]), 0])
+    }
+    list.__iter__ = function(self) {
+        return list_iterator.$factory(self)
+    }
+    list.__le__ = function(self, other) {
+        var res = list.__ge__(self, other)
+        if (res === _b_.NotImplemented) {
+            return res
+        }
+        return !res
+    }
+    list.__len__ = function(self) {
+        return self.length
+    }
+    list.__lt__ = function(self, other) {
+        if (!isinstance(other, [list, _b_.tuple])) {
+            return _b_.NotImplemented
+        }
+        var i = 0
+        while (i < self.length) {
+            if (i >= other.length) {
+                return false
+            }
+            if ($B.rich_comp("__eq__", self[i], other[i])) {
+                i++
+            } else {
+                res = $B.$getattr(self[i], "__lt__")(other[i])
+                if (res === _b_.NotImplemented) {
+                    throw _b_.TypeError.$factory("unorderable types: " +
+                        $B.class_name(self[i]) + "() >= " +
+                        $B.class_name(other[i]) + "()")
+                } else {
+                    return res
+                }
+            }
+        }
+        return other.length > self.length
+    }
+    list.__mul__ = function(self, other) {
+        if (isinstance(other, _b_.int)) {
+            other = _b_.int.numerator(other)
+            var res = [],
+                $temp = self.slice(),
+                len = $temp.length
+            for (var i = 0; i < other; i++) {
+                for (var j = 0; j < len; j++) {
+                    res.push($temp[j])
+                }
+            }
+            res.__class__ = self.__class__
+            return res
+        }
+        if (_b_.hasattr(other, "__int__") || _b_.hasattr(other, "__index__")) {
+            return list.__mul__(self, _b_.int.$factory(other))
+        }
+        var rmul = $B.$getattr(other, '__rmul__', null)
+        if (rmul === null) {
+            throw _b_.TypeError.$factory(`can't multiply sequence by non-int ` +
+                `of type '${$B.class_name(other)}'`)
+        }
+        return _b_.NotImplemented
+    }
+    list.__new__ = function(cls, ...args) {
+        if (cls === undefined) {
+            throw _b_.TypeError.$factory("list.__new__(): not enough arguments")
+        }
+        var res = []
+        res.__class__ = cls
+        res.__brython__ = true
+        res.__dict__ = $B.empty_dict()
+        return res
+    }
+
+    function __newobj__() {
+        var $ = $B.args('__newobj__', 0, {}, [], arguments, {}, 'args', null),
+            args = $.args
+        var res = args.slice(1)
+        res.__class__ = args[0]
+        return res
+    }
+    list.__reduce_ex__ = function(self) {
+        return $B.fast_tuple([__newobj__, $B.fast_tuple([self.__class__]), _b_.None, _b_.iter(self)])
+    }
+    list.__repr__ = function(self) {
+        $B.builtins_repr_check(list, arguments)
+        return list_repr(self)
+    }
+
+    function list_repr(self) {
+        if ($B.repr.enter(self)) {
+            return '[...]'
+        }
+        var _r = [],
+            res
+        for (var i = 0; i < self.length; i++) {
+            _r.push(_b_.repr(self[i]))
+        }
+        if (_b_.isinstance(self, tuple)) {
+            if (self.length == 1) {
+                res = "(" + _r[0] + ",)"
+            } else {
+                res = "(" + _r.join(", ") + ")"
+            }
+        } else {
+            res = "[" + _r.join(", ") + "]"
+        }
+        $B.repr.leave(self)
+        return res
+    }
+    list.__rmul__ = function(self, other) {
+        return list.__mul__(self, other)
+    }
+    list.__setattr__ = function(self, attr, value) {
+        if (self.__class__ === list || self.__class__ === tuple) {
+            var cl_name = $B.class_name(self)
+            if (list.hasOwnProperty(attr)) {
+                throw _b_.AttributeError.$factory("'" + cl_name +
+                    "' object attribute '" + attr + "' is read-only")
+            } else {
+                throw _b_.AttributeError.$factory(
+                    "'" + cl_name + " object has no attribute '" + attr + "'")
+            }
+        }
+        _b_.dict.$setitem(self.__dict__, attr, value)
+        return $N
+    }
+    list.__setitem__ = function() {
+        var $ = $B.args("__setitem__", 3, {
+                self: null,
+                key: null,
+                value: null
+            }, ["self", "key", "value"], arguments, {}, null, null),
+            self = $.self,
+            arg = $.key,
+            value = $.value
+        list.$setitem(self, arg, value)
+    }
+    list.$setitem = function(self, arg, value) {
+        if (typeof arg == "number" || isinstance(arg, _b_.int)) {
+            var pos = arg
+            if (arg < 0) {
+                pos = self.length + pos
+            }
+            if (pos >= 0 && pos < self.length) {
+                self[pos] = value
+            } else {
+                throw _b_.IndexError.$factory("list index out of range")
+            }
+            return $N
+        }
+        if (isinstance(arg, _b_.slice)) {
+            var s = _b_.slice.$conv_for_seq(arg, self.length)
+            if (arg.step === null) {
+                $B.set_list_slice(self, s.start, s.stop, value)
+            } else {
+                $B.set_list_slice_step(self, s.start, s.stop, s.step, value)
+            }
+            return $N
+        }
+        if (_b_.hasattr(arg, "__int__") || _b_.hasattr(arg, "__index__")) {
+            list.__setitem__(self, _b_.int.$factory(arg), value)
+            return $N
+        }
+        throw _b_.TypeError.$factory("list indices must be integer, not " +
+            $B.class_name(arg))
+    }
+    list.append = function(self, x) {
+        $B.check_no_kw("append", self, x)
+        $B.check_nb_args("append", 2, arguments)
+        self.push(x)
+        return $N
+    }
+    list.clear = function() {
+        var $ = $B.args("clear", 1, {
+            self: null
+        }, ["self"], arguments, {}, null, null)
+        while ($.self.length) {
+            $.self.pop()
+        }
+        return $N
+    }
+    list.copy = function() {
+        var $ = $B.args("copy", 1, {
+            self: null
+        }, ["self"], arguments, {}, null, null)
+        return $.self.slice()
+    }
+    list.count = function() {
+        var $ = $B.args("count", 2, {
+            self: null,
+            x: null
+        }, ["self", "x"], arguments, {}, null, null)
+        var res = 0,
+            _eq = function(other) {
+                return $B.rich_comp("__eq__", $.x, other)
+            },
+            i = $.self.length
+        while (i--) {
+            if (_eq($.self[i])) {
+                res++
+            }
+        }
+        return res
+    }
+    list.extend = function() {
+        var $ = $B.args("extend", 2, {
+            self: null,
+            t: null
+        }, ["self", "t"], arguments, {}, null, null)
+        var other = list.$factory($B.$iter($.t))
+        for (var i = 0; i < other.length; i++) {
+            $.self.push(other[i])
+        }
+        return $N
+    }
+    list.index = function() {
+        var missing = {},
+            $ = $B.args("index", 4, {
+                self: null,
+                x: null,
+                start: null,
+                stop: null
+            }, ["self", "x", "start", "stop"], arguments, {
+                start: 0,
+                stop: missing
+            }, null, null),
+            self = $.self,
+            start = $.start,
+            stop = $.stop
+        var _eq = function(other) {
+            return $B.rich_comp("__eq__", $.x, other)
+        }
+        if (start.__class__ === $B.long_int) {
+            start = parseInt(start.value) * (start.pos ? 1 : -1)
+        }
+        if (start < 0) {
+            start = Math.max(0, start + self.length)
+        }
+        if (stop === missing) {
+            stop = self.length
+        } else {
+            if (stop.__class__ === $B.long_int) {
+                stop = parseInt(stop.value) * (stop.pos ? 1 : -1)
+            }
+            if (stop < 0) {
+                stop = Math.min(self.length, stop + self.length)
+            }
+            stop = Math.min(stop, self.length)
+        }
+        for (var i = start; i < stop; i++) {
+            if (_eq(self[i])) {
+                return i
+            }
+        }
+        throw _b_.ValueError.$factory(_b_.repr($.x) + " is not in " +
+            $B.class_name(self))
+    }
+    list.insert = function() {
+        var $ = $B.args("insert", 3, {
+            self: null,
+            i: null,
+            item: null
+        }, ["self", "i", "item"], arguments, {}, null, null)
+        $.self.splice($.i, 0, $.item)
+        return $N
+    }
+    list.pop = function() {
+        var missing = {}
+        var $ = $B.args("pop", 2, {
+                self: null,
+                pos: null
+            }, ["self", "pos"], arguments, {
+                pos: missing
+            }, null, null),
+            self = $.self,
+            pos = $.pos
+        check_not_tuple(self, "pop")
+        if (pos === missing) {
+            pos = self.length - 1
+        }
+        pos = $B.$GetInt(pos)
+        if (pos < 0) {
+            pos += self.length
+        }
+        var res = self[pos]
+        if (res === undefined) {
+            throw _b_.IndexError.$factory("pop index out of range")
+        }
+        self.splice(pos, 1)
+        return res
+    }
+    list.remove = function() {
+        var $ = $B.args("remove", 2, {
+            self: null,
+            x: null
+        }, ["self", "x"], arguments, {}, null, null)
+        for (var i = 0, len = $.self.length; i < len; i++) {
+            if ($B.rich_comp("__eq__", $.self[i], $.x)) {
+                $.self.splice(i, 1)
+                return $N
+            }
+        }
+        throw _b_.ValueError.$factory(_b_.str.$factory($.x) + " is not in list")
+    }
+    list.reverse = function(self) {
+        var $ = $B.args("reverse", 1, {
+                self: null
+            }, ["self"], arguments, {}, null, null),
+            _len = $.self.length - 1,
+            i = parseInt($.self.length / 2)
+        while (i--) {
+            var buf = $.self[i]
+            $.self[i] = $.self[_len - i]
+            $.self[_len - i] = buf
+        }
+        return $N
+    }
+
+    function $partition(arg, array, begin, end, pivot) {
+        var piv = array[pivot]
+        array = swap(array, pivot, end - 1)
+        var store = begin
+        if (arg === null) {
+            if (array.$cl !== false) {
+                var le_func = _b_.getattr(array.$cl, "__le__")
+                for (var ix = begin; ix < end - 1; ++ix) {
+                    if (le_func(array[ix], piv)) {
+                        array = swap(array, store, ix);
+                        ++store
+                    }
+                }
+            } else {
+                for (var ix = begin; ix < end - 1; ++ix) {
+                    if ($B.$getattr(array[ix], "__le__")(piv)) {
+                        array = swap(array, store, ix)
+                            ++store
+                    }
+                }
+            }
+        } else {
+            var len = array.length
+            for (var ix = begin; ix < end - 1; ++ix) {
+                var x = arg(array[ix])
+                if (array.length !== len) {
+                    throw _b_.ValueError.$factory("list modified during sort")
+                }
+                if ($B.$getattr(x, "__le__")(arg(piv))) {
+                    array = swap(array, store, ix)
+                        ++store
+                }
+            }
+        }
+        array = swap(array, end - 1, store)
+        return store
+    }
+
+    function swap(_array, a, b) {
+        var tmp = _array[a]
+        _array[a] = _array[b]
+        _array[b] = tmp
+        return _array
+    }
+
+    function $qsort(arg, array, begin, end) {
+        if (end - 1 > begin) {
+            var pivot = begin + Math.floor(Math.random() * (end - begin))
+            pivot = $partition(arg, array, begin, end, pivot)
+            $qsort(arg, array, begin, pivot)
+            $qsort(arg, array, pivot + 1, end)
+        }
+    }
+
+    function $elts_class(self) {
+        if (self.length == 0) {
+            return null
+        }
+        var cl = $B.get_class(self[0]),
+            i = self.length
+        while (i--) {
+            if ($B.get_class(self[i]) !== cl) {
+                return false
+            }
+        }
+        return cl
+    }
+    list.sort = function(self) {
+        var $ = $B.args("sort", 1, {
+            self: null
+        }, ["self"], arguments, {}, null, "kw")
+        check_not_tuple(self, "sort")
+        var func = $N,
+            reverse = false,
+            kw_args = $.kw,
+            keys = _b_.list.$factory(_b_.dict.keys(kw_args))
+        for (var i = 0; i < keys.length; i++) {
+            if (keys[i] == "key") {
+                func = kw_args.$string_dict[keys[i]][0]
+            } else if (keys[i] == "reverse") {
+                reverse = kw_args.$string_dict[keys[i]][0]
+            } else {
+                throw _b_.TypeError.$factory("'" + keys[i] +
+                    "' is an invalid keyword argument for this function")
+            }
+        }
+        if (self.length == 0) {
+            return
+        }
+        if (func !== $N) {
+            func = $B.$call(func)
+        }
+        self.$cl = $elts_class(self)
+        var cmp = null;
+        if (func === $N && self.$cl === _b_.str) {
+            if (reverse) {
+                cmp = function(b, a) {
+                    return $B.$AlphabeticalCompare(a, b)
+                }
+            } else {
+                cmp = function(a, b) {
+                    return $B.$AlphabeticalCompare(a, b)
+                }
+            }
+        } else if (func === $N && self.$cl === _b_.int) {
+            if (reverse) {
+                cmp = function(b, a) {
+                    return a - b
+                }
+            } else {
+                cmp = function(a, b) {
+                    return a - b
+                }
+            }
+        } else {
+            if (func === $N) {
+                if (reverse) {
+                    cmp = function(b, a) {
+                        res = $B.$getattr(a, "__lt__")(b)
+                        if (res === _b_.NotImplemented) {
+                            throw _b_.TypeError.$factory("unorderable types: " +
+                                $B.class_name(b) + "() < " +
+                                $B.class_name(a) + "()")
+                        }
+                        if (res) {
+                            if (a == b) {
+                                return 0
+                            }
+                            return -1
+                        }
+                        return 1
+                    }
+                } else {
+                    cmp = function(a, b) {
+                        res = $B.$getattr(a, "__lt__")(b)
+                        if (res === _b_.NotImplemented) {
+                            throw _b_.TypeError.$factory("unorderable types: " +
+                                $B.class_name(a) + "() < " +
+                                $B.class_name(b) + "()")
+                        }
+                        if (res) {
+                            if (a == b) {
+                                return 0
+                            }
+                            return -1
+                        }
+                        return 1
+                    }
+                }
+            } else {
+                if (reverse) {
+                    cmp = function(b, a) {
+                        var _a = func(a),
+                            _b = func(b)
+                        res = $B.$getattr(_a, "__lt__")(_b)
+                        if (res === _b_.NotImplemented) {
+                            throw _b_.TypeError.$factory("unorderable types: " +
+                                $B.class_name(b) + "() < " +
+                                $B.class_name(a) + "()")
+                        }
+                        if (res) {
+                            if (_a == _b) {
+                                return 0
+                            }
+                            return -1
+                        }
+                        return 1
+                    }
+                } else {
+                    cmp = function(a, b) {
+                        var _a = func(a),
+                            _b = func(b)
+                        res = $B.$getattr(_a, "__lt__")(_b)
+                        if (res === _b_.NotImplemented) {
+                            throw _b_.TypeError.$factory("unorderable types: " +
+                                $B.class_name(a) + "() < " +
+                                $B.class_name(b) + "()")
+                        }
+                        if (res) {
+                            if (_a == _b) {
+                                return 0
+                            }
+                            return -1
+                        }
+                        return 1
+                    }
+                }
+            }
+        }
+        $B.$TimSort(self, cmp)
+        return (self.__brython__ ? $N : self)
+    }
+    $B.$list = function(t) {
+        t.__brython__ = true
+        t.__class__ = _b_.list
+        return t
+    }
+    list.$factory = function() {
+        if (arguments.length == 0) {
+            return []
+        }
+        var $ = $B.args("list", 1, {
+                obj: null
+            }, ["obj"], arguments, {}, null, null),
+            obj = $.obj
+        if (Array.isArray(obj)) {
+            obj = obj.slice()
+            obj.__brython__ = true;
+            if (obj.__class__ == tuple) {
+                var res = obj.slice()
+                res.__class__ = list
+                return res
+            }
+            return obj
+        }
+        var res = [],
+            pos = 0,
+            arg = $B.$iter(obj),
+            next_func = $B.$call($B.$getattr(arg, "__next__"))
+        while (1) {
+            try {
+                res[pos++] = next_func()
+            } catch (err) {
+                if (!isinstance(err, _b_.StopIteration)) {
+                    throw err
+                }
+                break
+            }
+        }
+        res.__brython__ = true
+        return res
+    }
+    $B.set_func_names(list, "builtins")
+    list.__class_getitem__ = _b_.classmethod.$factory(list.__class_getitem__)
+    var JSArray = $B.JSArray = $B.make_class("JSArray", function(array) {
+        return {
+            __class__: JSArray,
+            js: array
+        }
+    })
+    JSArray.__repr__ = JSArray.__str__ = function() {
+        return "<JSArray object>"
+    }
+
+    function make_args(args) {
+        var res = [args[0].js]
+        for (var i = 1, len = args.length; i < len; i++) {
+            res.push(args[i])
+        }
+        return res
+    }
+    for (var attr in list) {
+        if ($B.JSArray[attr] !== undefined) {
+            continue
+        }
+        if (typeof list[attr] == "function") {
+            $B.JSArray[attr] = (function(fname) {
+                return function() {
+                    return $B.$JS2Py(list[fname].apply(null, make_args(arguments)))
+                }
+            })(attr)
+        }
+    }
+    $B.set_func_names($B.JSArray, "builtins")
+
+    function $tuple(arg) {
+        return arg
+    }
+    var tuple = {
+        __class__: _b_.type,
+        __mro__: [object],
+        $infos: {
+            __module__: "builtins",
+            __name__: "tuple"
+        },
+        $is_class: true,
+        $native: true,
+        $match_sequence_pattern: true,
+    }
+    var tuple_iterator = $B.make_iterator_class("tuple_iterator")
+    tuple.__iter__ = function(self) {
+        return tuple_iterator.$factory(self)
+    }
+    tuple.$factory = function() {
+        var obj = list.$factory(...arguments)
+        obj.__class__ = tuple
+        return obj
+    }
+    $B.fast_tuple = function(array) {
+        array.__class__ = tuple
+        array.__brython__ = true
+        array.__dict__ = $B.empty_dict()
+        return array
+    }
+    for (var attr in list) {
+        switch (attr) {
+            case "__delitem__":
+            case "__iadd__":
+            case "__imul__":
+            case "__setitem__":
+            case "append":
+            case "extend":
+            case "insert":
+            case "remove":
+            case "reverse":
+                break
+            default:
+                if (tuple[attr] === undefined) {
+                    if (typeof list[attr] == "function") {
+                        tuple[attr] = (function(x) {
+                            return function() {
+                                return list[x].apply(null, arguments)
+                            }
+                        })(attr)
+                    }
+                }
+        }
+    }
+    tuple.__eq__ = function(self, other) {
+        if (other === undefined) {
+            return self === tuple
+        }
+        return list.__eq__(self, other)
+    }
+
+    function c_mul(a, b) {
+        s = ((parseInt(a) * b) & 0xFFFFFFFF).toString(16)
+        return parseInt(s.substr(0, s.length - 1), 16)
+    }
+    tuple.__hash__ = function(self) {
+        var x = 0x3456789
+        for (var i = 0, len = self.length; i < len; i++) {
+            var y = _b_.hash(self[i])
+            x = c_mul(1000003, x) ^ y & 0xFFFFFFFF
+        }
+        return x
+    }
+    tuple.__init__ = function() {
+        return $N
+    }
+    tuple.__new__ = function(cls, ...args) {
+        if (cls === undefined) {
+            throw _b_.TypeError.$factory("list.__new__(): not enough arguments")
+        }
+        var self = []
+        self.__class__ = cls
+        self.__brython__ = true
+        self.__dict__ = $B.empty_dict()
+        var arg = $B.$iter(args[0]),
+            next_func = $B.$call($B.$getattr(arg, "__next__"))
+        while (1) {
+            try {
+                var item = next_func()
+                self.push(item)
+            } catch (err) {
+                if (err.__class__ === _b_.StopIteration) {
+                    break
+                } else {
+                    throw err
+                }
+            }
+        }
+        return self
+    }
+    tuple.__reduce_ex__ = function(self) {
+        return $B.fast_tuple([__newobj__, $B.fast_tuple([self.__class__].concat(self.slice())), _b_.None, _b_.None])
+    }
+    tuple.__repr__ = function(self) {
+        $B.builtins_repr_check(tuple, arguments)
+        return list_repr(self)
+    }
+    $B.set_func_names(tuple, "builtins")
+    _b_.list = list
+    _b_.tuple = tuple
+    _b_.object.__bases__ = tuple.$factory()
+    _b_.type.__bases__ = $B.fast_tuple([_b_.object])
+})(__BRYTHON__);;
+(function($B) {
+    var _b_ = $B.builtins
+    var $GeneratorReturn = {}
+    $B.generator_return = function(value) {
+        return {
+            __class__: $GeneratorReturn,
+            value: value
+        }
+    }
+    $B.generator = $B.make_class("generator", function(func, name) {
+        var res = function() {
+            var gen = func.apply(null, arguments)
+            gen.$name = name || 'generator'
+            gen.$func = func
+            gen.$has_run = false
+            if (func.$has_yield_in_cm) {
+                var locals = $B.last($B.frames_stack)[1]
+                locals.$close_generators = locals.$close_generators || []
+                locals.$close_generators.push(gen)
+            }
+            return {
+                __class__: $B.generator,
+                js_gen: gen
+            }
+        }
+        res.$infos = func.$infos
+        res.$is_genfunc = true
+        res.$name = name
+        return res
+    })
+    $B.generator.__iter__ = function(self) {
+        return self
+    }
+    $B.generator.__next__ = function(self) {
+        return $B.generator.send(self, _b_.None)
+    }
+    $B.generator.__str__ = function(self) {
+        return '<' + self.$name + ' object>'
+    }
+    $B.generator.close = function(self) {
+        try {
+            $B.generator.throw(self, _b_.GeneratorExit.$factory())
+        } catch (err) {
+            if (!$B.is_exc(err, [_b_.GeneratorExit, _b_.StopIteration])) {
+                throw _b_.RuntimeError.$factory("generator ignored GeneratorExit")
+            }
+        }
+    }
+    $B.generator.send = function(self, value) {
+        var gen = self.js_gen
+        gen.$has_run = true
+        if (gen.$finished) {
+            throw _b_.StopIteration.$factory(value)
+        }
+        if (gen.gi_running === true) {
+            throw _b_.ValueError.$factory("generator already executing")
+        }
+        gen.gi_running = true
+        try {
+            var res = gen.next(value)
+        } catch (err) {
+            gen.$finished = true
+            throw err
+        }
+        if (res.value && res.value.__class__ === $GeneratorReturn) {
+            gen.$finished = true
+            throw _b_.StopIteration.$factory(res.value.value)
+        }
+        gen.gi_running = false
+        if (res.done) {
+            throw _b_.StopIteration.$factory(res.value)
+        }
+        return res.value
+    }
+    $B.generator.throw = function(self, type, value, traceback) {
+        var gen = self.js_gen,
+            exc = type
+        if (exc.$is_class) {
+            if (!_b_.issubclass(type, _b_.BaseException)) {
+                throw _b_.TypeError.$factory("exception value must be an " +
+                    "instance of BaseException")
+            } else if (value === undefined) {
+                exc = $B.$call(exc)()
+            } else if (_b_.isinstance(value, type)) {
+                exc = value
+            }
+        } else {
+            if (value === undefined) {
+                value = exc
+            } else {
+                exc = $B.$call(exc)(value)
+            }
+        }
+        if (traceback !== undefined) {
+            exc.$traceback = traceback
+        }
+        var res = gen.throw(exc)
+        if (res.done) {
+            throw _b_.StopIteration.$factory("StopIteration")
+        }
+        return res.value
+    }
+    $B.set_func_names($B.generator, "builtins")
+    $B.async_generator = $B.make_class("async_generator", function(func) {
+        var f = function() {
+            var gen = func.apply(null, arguments)
+            var res = Object.create(null)
+            res.__class__ = $B.async_generator
+            res.js_gen = gen
+            return res
+        }
+        return f
+    })
+    var ag_closed = {}
+    $B.async_generator.__aiter__ = function(self) {
+        return self
+    }
+    $B.async_generator.__anext__ = function(self) {
+        return $B.async_generator.asend(self, _b_.None)
+    }
+    $B.async_generator.aclose = function(self) {
+        self.js_gen.$finished = true
+        return _b_.None
+    }
+    $B.async_generator.asend = async function(self, value) {
+        var gen = self.js_gen
+        if (gen.$finished) {
+            throw _b_.StopAsyncIteration.$factory(value)
+        }
+        if (gen.ag_running === true) {
+            throw _b_.ValueError.$factory("generator already executing")
+        }
+        gen.ag_running = true
+        try {
+            var res = await gen.next(value)
+        } catch (err) {
+            gen.$finished = true
+            throw err
+        }
+        if (res.done) {
+            throw _b_.StopAsyncIteration.$factory(value)
+        }
+        if (res.value.__class__ === $GeneratorReturn) {
+            gen.$finished = true
+            throw _b_.StopAsyncIteration.$factory(res.value.value)
+        }
+        gen.ag_running = false
+        return res.value
+    }
+    $B.async_generator.athrow = async function(self, type, value, traceback) {
+        var gen = self.js_gen,
+            exc = type
+        if (exc.$is_class) {
+            if (!_b_.issubclass(type, _b_.BaseException)) {
+                throw _b_.TypeError.$factory("exception value must be an " +
+                    "instance of BaseException")
+            } else if (value === undefined) {
+                value = $B.$call(exc)()
+            }
+        } else {
+            if (value === undefined) {
+                value = exc
+            } else {
+                exc = $B.$call(exc)(value)
+            }
+        }
+        if (traceback !== undefined) {
+            exc.$traceback = traceback
+        }
+        await gen.throw(value)
+    }
+    $B.set_func_names($B.async_generator, "builtins")
+
+    function rstrip(s, strip_chars) {
+        var _chars = strip_chars || " \t\n";
+        var nstrip = 0,
+            len = s.length;
+        while (nstrip < len && _chars.indexOf(s.charAt(len - 1 - nstrip)) > -1) nstrip++;
+        return s.substr(0, len - nstrip)
+    }
+})(__BRYTHON__);;
+(function($B) {
+    var _b_ = $B.builtins,
+        object = _b_.object,
         _window = self
 
     function $getMouseOffset(target, ev) {
         ev = ev || _window.event;
         var docPos = $getPosition(target);
         var mousePos = $mouseCoords(ev);
         return {
@@ -34095,15 +35632,15 @@
             if (err.__class__ === _b_.KeyError) {
                 return $.deflt
             } else {
                 throw err
             }
         }
     }
-    Attributes.$$keys = function() {
+    Attributes.keys = function() {
         return Attributes.__iter__.apply(null, arguments)
     }
     Attributes.items = function() {
         var $ = $B.args("values", 1, {
                 self: null
             }, ["self"], arguments, {}, null, null),
             attrs = $.self.elt.attributes,
@@ -34251,15 +35788,15 @@
         }
     }
     $B.set_func_names(Clipboard, "<dom>")
 
     function $EventsList(elt, evt, arg) {
         this.elt = elt
         this.evt = evt
-        if (isintance(arg, list)) {
+        if (_b_.isinstance(arg, _b_.list)) {
             this.callbacks = arg
         } else {
             this.callbacks = [arg]
         }
         this.remove = function(callback) {
             var found = false
             for (var i = 0; i < this.callbacks.length; i++) {
@@ -34310,15 +35847,15 @@
             }
             obj.addEventListener(attr.substr(2), callback)
         } else if ("set_" + attr in obj) {
             return obj["set_" + attr](value)
         } else if (attr in obj) {
             obj[attr] = value
         } else {
-            setattr(obj, attr, value)
+            _b_.setattr(obj, attr, value)
         }
     }
     $B.set_func_names(OpenFile, "<dom>")
     var dom = {
         File: function() {},
         FileReader: function() {}
     }
@@ -34328,18 +35865,32 @@
     }
     dom.FileReader.__class__ = _b_.type
     dom.FileReader.__str__ = function() {
         return "<class 'FileReader'>"
     }
     var Options = {
         __class__: _b_.type,
-        __delitem__: function(self, arg) {
-            self.parent.options.remove(arg.elt)
+        __delitem__: function(self, key) {
+            key = $B.PyNumber_Index(key)
+            if (key < 0) {
+                key += self.parent.options.length
+            }
+            if (!self.parent.options[key]) {
+                throw _b_.KeyError.$factory(key)
+            }
+            self.parent.options.remove(key)
         },
         __getitem__: function(self, key) {
+            key = $B.PyNumber_Index(key)
+            if (key < 0) {
+                key += self.parent.options.length
+            }
+            if (!self.parent.options[key]) {
+                throw _b_.KeyError.$factory(key)
+            }
             return DOMNode.$factory(self.parent.options[key])
         },
         __len__: function(self) {
             return self.parent.options.length
         },
         __mro__: [object],
         __setattr__: function(self, attr, value) {
@@ -34348,31 +35899,31 @@
         __setitem__: function(self, attr, value) {
             self.parent.options[attr] = $B.$JS2Py(value)
         },
         __str__: function(self) {
             return "<object Options wraps " + self.parent.options + ">"
         },
         append: function(self, element) {
-            self.parent.options.add(element.elt)
+            self.parent.options.add(element)
         },
         insert: function(self, index, element) {
             if (index === undefined) {
-                self.parent.options.add(element.elt)
+                self.parent.options.add(element)
             } else {
-                self.parent.options.add(element.elt, index)
+                self.parent.options.add(element, index)
             }
         },
         item: function(self, index) {
             return self.parent.options.item(index)
         },
         namedItem: function(self, name) {
             return self.parent.options.namedItem(name)
         },
-        remove: function(self, arg) {
-            self.parent.options.remove(arg.elt)
+        remove: function(self, element) {
+            self.parent.options.remove(element.index)
         },
         $infos: {
             __module__: "<pydom>",
             __name__: "Options"
         }
     }
     Options.$factory = function(parent) {
@@ -34492,17 +36043,14 @@
         res.sort()
         return res
     }
     DOMNode.__eq__ = function(self, other) {
         return self == other
     }
     DOMNode.__getattribute__ = function(self, attr) {
-        if (attr.substr(0, 2) == "$$") {
-            attr = attr.substr(2)
-        }
         switch (attr) {
             case "attrs":
                 return Attributes.$factory(self)
             case "children":
             case "child_nodes":
             case "class_name":
             case "html":
@@ -34557,15 +36105,15 @@
                         }
                         var pos = header.search(":")
                         res.__setitem__(header.substr(0, pos), header.substr(pos + 1).lstrip())
                     }
                     return res
                 }
                 break
-            case "$$location":
+            case "location":
                 attr = "location"
                 break
         }
         if (attr == "select" && self.nodeType == 1 && ["INPUT", "TEXTAREA"].indexOf(self.tagName.toUpperCase()) > -1) {
             return function(selector) {
                 if (selector === undefined) {
                     self.select();
@@ -34594,17 +36142,14 @@
                         res._values[key] = [value]
                     }
                 }
             }
             return res
         }
         var property = self[attr]
-        if (property === undefined && $B.aliased_names[attr]) {
-            property = self["$$" + attr]
-        }
         if (property !== undefined && self.__class__ &&
             self.__class__.__module__ != "browser.html" &&
             self.__class__.__module__ != "browser.svg") {
             var bases = self.__class__.__bases__
             var show_message = true
             for (var base of bases) {
                 if (base.__module__ == "browser.html") {
@@ -34705,15 +36250,15 @@
             }
             return $B.$JS2Py(res)
         }
         return object.__getattribute__(self, attr)
     }
     DOMNode.__getitem__ = function(self, key) {
         if (self.nodeType == 9) {
-            if (typeof key == "string") {
+            if (typeof key.valueOf() == "string") {
                 var res = self.getElementById(key)
                 if (res) {
                     return DOMNode.$factory(res)
                 }
                 throw _b_.KeyError.$factory(key)
             } else {
                 try {
@@ -35534,190 +37079,15 @@
         return _window.postMessage(msg, targetOrigin)
     }
     $B.DOMNode = DOMNode
     $B.win = win
 })(__BRYTHON__);;
 (function($B) {
     var _b_ = $B.builtins
-    var bltns = $B.InjectBuiltins()
-    eval(bltns)
-    var $GeneratorReturn = {}
-    $B.generator_return = function(value) {
-        return {
-            __class__: $GeneratorReturn,
-            value: value
-        }
-    }
-    $B.generator = $B.make_class("generator", function(func, name) {
-        var res = function() {
-            var gen = func.apply(null, arguments)
-            gen.$name = name || 'generator'
-            gen.$func = func
-            gen.$has_run = false
-            gen.__class__ = $B.generator
-            if (func.$has_yield_in_cm) {
-                var locals = $B.last($B.frames_stack)[1]
-                locals.$close_generators = locals.$close_generators || []
-                locals.$close_generators.push(gen)
-            }
-            return gen
-        }
-        res.$infos = func.$infos
-        res.$is_genfunc = true
-        res.$name = name
-        return res
-    })
-    $B.generator.__iter__ = function(self) {
-        return self
-    }
-    $B.generator.__next__ = function(self) {
-        return $B.generator.send(self, _b_.None)
-    }
-    $B.generator.__str__ = function(self) {
-        return '<' + self.$name + ' object>'
-    }
-    $B.generator.close = function(self) {
-        try {
-            $B.generator.$$throw(self, _b_.GeneratorExit.$factory())
-        } catch (err) {
-            if (!$B.is_exc(err, [_b_.GeneratorExit, _b_.StopIteration])) {
-                throw _b_.RuntimeError.$factory("generator ignored GeneratorExit")
-            }
-        }
-    }
-    $B.generator.send = function(self, value) {
-        self.$has_run = true
-        if (self.$finished) {
-            throw _b_.StopIteration.$factory(value)
-        }
-        if (self.gi_running === true) {
-            throw _b_.ValueError.$factory("generator already executing")
-        }
-        self.gi_running = true
-        try {
-            var res = self.next(value)
-        } catch (err) {
-            self.$finished = true
-            throw err
-        }
-        if (res.value && res.value.__class__ === $GeneratorReturn) {
-            self.$finished = true
-            throw _b_.StopIteration.$factory(res.value.value)
-        }
-        self.gi_running = false
-        if (res.done) {
-            throw _b_.StopIteration.$factory(res.value)
-        }
-        return res.value
-    }
-    $B.generator.$$throw = function(self, type, value, traceback) {
-        var exc = type
-        if (exc.$is_class) {
-            if (!_b_.issubclass(type, _b_.BaseException)) {
-                throw _b_.TypeError.$factory("exception value must be an " +
-                    "instance of BaseException")
-            } else if (value === undefined) {
-                exc = $B.$call(exc)()
-            } else if (_b_.isinstance(value, type)) {
-                exc = value
-            }
-        } else {
-            if (value === undefined) {
-                value = exc
-            } else {
-                exc = $B.$call(exc)(value)
-            }
-        }
-        if (traceback !== undefined) {
-            exc.$traceback = traceback
-        }
-        var res = self.throw(exc)
-        if (res.done) {
-            throw _b_.StopIteration.$factory("StopIteration")
-        }
-        return res.value
-    }
-    $B.set_func_names($B.generator, "builtins")
-    $B.async_generator = $B.make_class("async_generator", function(func) {
-        var f = function() {
-            var res = func.apply(null, arguments)
-            res.__class__ = $B.async_generator
-            return res
-        }
-        return f
-    })
-    var ag_closed = {}
-    $B.async_generator.__aiter__ = function(self) {
-        return self
-    }
-    $B.async_generator.__anext__ = function(self) {
-        return $B.async_generator.asend(self, _b_.None)
-    }
-    $B.async_generator.aclose = function(self) {
-        self.$finished = true
-        return _b_.None
-    }
-    $B.async_generator.asend = async function(self, value) {
-        if (self.$finished) {
-            throw _b_.StopAsyncIteration.$factory(value)
-        }
-        if (self.ag_running === true) {
-            throw _b_.ValueError.$factory("generator already executing")
-        }
-        self.ag_running = true
-        try {
-            var res = await self.next(value)
-        } catch (err) {
-            self.$finished = true
-            throw err
-        }
-        if (res.done) {
-            throw _b_.StopAsyncIteration.$factory(value)
-        }
-        if (res.value.__class__ === $GeneratorReturn) {
-            self.$finished = true
-            throw _b_.StopAsyncIteration.$factory(res.value.value)
-        }
-        self.ag_running = false
-        return res.value
-    }
-    $B.async_generator.athrow = async function(self, type, value, traceback) {
-        var exc = type
-        if (exc.$is_class) {
-            if (!_b_.issubclass(type, _b_.BaseException)) {
-                throw _b_.TypeError.$factory("exception value must be an " +
-                    "instance of BaseException")
-            } else if (value === undefined) {
-                value = $B.$call(exc)()
-            }
-        } else {
-            if (value === undefined) {
-                value = exc
-            } else {
-                exc = $B.$call(exc)(value)
-            }
-        }
-        if (traceback !== undefined) {
-            exc.$traceback = traceback
-        }
-        await self.throw(value)
-    }
-    $B.set_func_names($B.async_generator, "builtins")
-
-    function rstrip(s, strip_chars) {
-        var _chars = strip_chars || " \t\n";
-        var nstrip = 0,
-            len = s.length;
-        while (nstrip < len && _chars.indexOf(s.charAt(len - 1 - nstrip)) > -1) nstrip++;
-        return s.substr(0, len - nstrip)
-    }
-})(__BRYTHON__);;
-(function($B) {
-    var _b_ = $B.builtins
-    var update = function(mod, data) {
+    var update = $B.update_obj = function(mod, data) {
         for (attr in data) {
             mod[attr] = data[attr]
         }
     }
     var _window = self;
     var modules = {}
     var browser = {
@@ -35783,33 +37153,33 @@
                 }
                 return callback
             }
         },
         console: self.console && $B.JSObj.$factory(self.console),
         self: $B.win,
         win: $B.win,
-        $$window: $B.win,
+        "window": $B.win,
     }
     browser.__path__ = browser.__file__
     if ($B.isNode) {
-        delete browser.$$window
+        delete browser.window
         delete browser.win
     } else if ($B.isWebWorker) {
         browser.is_webworker = true
-        delete browser.$$window
+        delete browser.window
         delete browser.win
         browser.self.send = self.postMessage
     } else {
         browser.is_webworker = false
         update(browser, {
-            $$alert: function(message) {
+            "alert": function(message) {
                 window.alert($B.builtins.str.$factory(message || ""))
             },
             confirm: $B.JSObj.$factory(window.confirm),
-            $$document: $B.DOMNode.$factory(document),
+            "document": $B.DOMNode.$factory(document),
             doc: $B.DOMNode.$factory(document),
             DOMEvent: $B.DOMEvent,
             DOMNode: $B.DOMNode,
             load: function(script_url) {
                 var file_obj = $B.builtins.open(script_url)
                 var content = $B.$getattr(file_obj, 'read')()
                 eval(content)
@@ -35844,15 +37214,15 @@
             run_script: function() {
                 var $ = $B.args("run_script", 2, {
                     src: null,
                     name: null
                 }, ["src", "name"], arguments, {
                     name: "script_" + $B.UUID()
                 }, null, null)
-                $B.run_script($.src, $.name, true)
+                $B.run_script($.src, $.name, $B.script_path, true)
             },
             URLParameter: function(name) {
                 name = name.replace(/[\[]/, "\\[").replace(/[\]]/, "\\]");
                 var regex = new RegExp("[\\?&]" + name + "=([^&#]*)"),
                     results = regex.exec(location.search);
                 results = results === null ? "" :
                     decodeURIComponent(results[1].replace(/\+/g, " "));
@@ -36012,28 +37382,28 @@
         return "<Javascript undefined>"
     }
     $B.Undefined = {
         __class__: $B.UndefinedClass
     }
     $B.set_func_names($B.UndefinedClass, "javascript")
     var super_class = $B.make_class("JavascriptSuper", function() {
-        var b_super = _b_.$$super.$factory(),
+        var b_super = _b_.super.$factory(),
             b_self = b_super.__self_class__,
             proto = Object.getPrototypeOf(b_self),
             parent = proto.constructor.$parent
         var factory = function() {
             var p = parent.bind(b_self),
                 res
             if (parent.toString().startsWith("class")) {
                 res = new p(...arguments)
             } else {
                 res = p(...arguments)
             }
             for (key in res) {
-                b_self[$B.to_alias(key)] = res[key]
+                b_self[key] = res[key]
             }
             return res
         }
         return {
             __class__: super_class,
             __init__: factory,
             __self_class__: b_self
@@ -36043,22 +37413,22 @@
         if (attr == "__init__" || attr == "__call__") {
             return self.__init__
         }
         return $B.$getattr(self.__self_class__, attr)
     }
     $B.set_func_names(super_class, "javascript")
     modules['javascript'] = {
-        $$this: function() {
+        "this": function() {
             if ($B.js_this === undefined) {
                 return $B.builtins.None
             }
             return $B.JSObj.$factory($B.js_this)
         },
-        $$Date: self.Date && $B.JSObj.$factory(self.Date),
-        $$extends: function(js_constr) {
+        "Date": self.Date && $B.JSObj.$factory(self.Date),
+        "extends": function(js_constr) {
             return function(obj) {
                 if (obj.$is_class) {
                     var factory = function() {
                         var init = $B.$getattr(obj, "__init__", _b_.None)
                         if (init !== _b_.None) {
                             init.bind(this, this).apply(this, arguments)
                         }
@@ -36098,29 +37468,29 @@
         load: function(script_url) {
             console.log('"javascript.load" is deprecrated. ' +
                 'Use browser.load instead.')
             var file_obj = $B.builtins.open(script_url)
             var content = $B.$getattr(file_obj, 'read')()
             eval(content)
         },
-        $$Math: self.Math && $B.JSObj.$factory(self.Math),
+        "Math": self.Math && $B.JSObj.$factory(self.Math),
         NULL: null,
-        $$Number: self.Number && $B.JSObj.$factory(self.Number),
+        "Number": self.Number && $B.JSObj.$factory(self.Number),
         py2js: function(src, module_name) {
             if (module_name === undefined) {
                 module_name = '__main__' + $B.UUID()
             }
             return $B.py2js(src, module_name, module_name, $B.builtins_scope).to_js()
         },
         pyobj2jsobj: function(obj) {
             return $B.pyobj2jsobj(obj)
         },
-        $$RegExp: self.RegExp && $B.JSObj.$factory(self.RegExp),
-        $$String: self.String && $B.JSObj.$factory(self.String),
-        $$super: super_class,
+        "RegExp": self.RegExp && $B.JSObj.$factory(self.RegExp),
+        "String": self.String && $B.JSObj.$factory(self.String),
+        "super": super_class,
         UNDEFINED: $B.Undefined,
         UndefinedType: $B.UndefinedClass
     }
     var arraybuffers = ["Int8Array", "Uint8Array", "Uint8ClampedArray", "Int16Array", "Uint16Array", "Int32Array", "Uint32Array", "Float32Array", "Float64Array", "BigInt64Array", "BigUint64Array"]
     arraybuffers.forEach(function(ab) {
         if (self[ab] !== undefined) {
             modules['javascript'][ab] = $B.JSObj.$factory(self[ab])
@@ -36314,15 +37684,15 @@
                 syntax_error.offset = message.offset
                 syntax_error.line = message.line
                 throw syntax_error
             }
             var frame = $B.imported._sys.Getframe()
             warning_message = {
                 __class__: WarningMessage,
-                $$message: message,
+                message: message,
                 category: message.__class__,
                 filename: message.filename || frame.f_code.co_filename,
                 lineno: message.lineno || frame.f_lineno,
                 file: _b_.None,
                 line: _b_.None,
                 source: _b_.None,
                 _category_name: message.__class__.__name__
@@ -36345,19 +37715,18 @@
 
     function load(name, module_obj) {
         module_obj.__class__ = $B.module
         module_obj.__name__ = name
         $B.imported[name] = module_obj
         for (var attr in module_obj) {
             if (typeof module_obj[attr] == 'function') {
-                var attr1 = $B.from_alias(attr)
                 module_obj[attr].$infos = {
                     __module__: name,
-                    __name__: attr1,
-                    __qualname__: name + '.' + attr1
+                    __name__: attr,
+                    __qualname__: name + '.' + attr
                 }
             }
         }
     }
     for (var attr in modules) {
         load(attr, modules[attr])
     }
@@ -36365,14 +37734,21 @@
         modules['browser'].html = modules['browser.html']
     }
     var _b_ = $B.builtins
     _b_.__builtins__ = $B.module.$factory('__builtins__', 'Python builtins')
     for (var attr in _b_) {
         _b_.__builtins__[attr] = _b_[attr]
         $B.builtins_scope.binding[attr] = true
+        if (_b_[attr].$is_class) {
+            if (_b_[attr].__bases__) {
+                _b_[attr].__bases__.__class__ = _b_.tuple
+            } else {
+                _b_[attr].__bases__ = $B.fast_tuple([_b_.object])
+            }
+        }
     }
     _b_.__builtins__.__setattr__ = function(attr, value) {
         _b_[attr] = value
     }
     $B.method_descriptor.__getattribute__ = $B.Function.__getattribute__
     $B.wrapper_descriptor.__getattribute__ = $B.Function.__getattribute__
     for (var name in _b_) {
@@ -36421,15 +37797,15 @@
     )
     var $comps = Object.values($B.$comps).concat(["eq", "ne"])
     $comps.forEach(function(comp) {
         var op = "__" + comp + "__"
         $B.cell[op] = (function(op) {
             return function(self, other) {
                 if (!_b_.isinstance(other, $B.cell)) {
-                    return NotImplemented
+                    return _b_.NotImplemented
                 }
                 if (self.$cell_contents === null) {
                     if (other.$cell_contents === null) {
                         return op == "__eq__"
                     } else {
                         return ["__ne__", "__lt__", "__le__"].indexOf(op) > -1
                     }
@@ -36437,160 +37813,15 @@
                     return ["__ne__", "__gt__", "__ge__"].indexOf(op) > -1
                 }
                 return $B.rich_comp(op, self.$cell_contents, other.$cell_contents)
             }
         })(op)
     })
     $B.set_func_names($B.cell, "builtins")
-})(__BRYTHON__);
-var docs = {
-    ArithmeticError: "Base class for arithmetic errors.",
-    AssertionError: "Assertion failed.",
-    AttributeError: "Attribute not found.",
-    BaseException: "Common base class for all exceptions",
-    BlockingIOError: "I/O operation would block.",
-    BrokenPipeError: "Broken pipe.",
-    BufferError: "Buffer error.",
-    BytesWarning: "Base class for warnings about bytes and buffer related problems, mostly\nrelated to conversion from str or comparing to str.",
-    ChildProcessError: "Child process error.",
-    ConnectionAbortedError: "Connection aborted.",
-    ConnectionError: "Connection error.",
-    ConnectionRefusedError: "Connection refused.",
-    ConnectionResetError: "Connection reset.",
-    DeprecationWarning: "Base class for warnings about deprecated features.",
-    EOFError: "Read beyond end of file.",
-    Ellipsis: "",
-    EnvironmentError: "Base class for I/O related errors.",
-    Exception: "Common base class for all non-exit exceptions.",
-    False: "bool(x) -> bool\n\nReturns True when the argument x is true, False otherwise.\nThe builtins True and False are the only two instances of the class bool.\nThe class bool is a subclass of the class int, and cannot be subclassed.",
-    FileExistsError: "File already exists.",
-    FileNotFoundError: "File not found.",
-    FloatingPointError: "Floating point operation failed.",
-    FutureWarning: "Base class for warnings about constructs that will change semantically\nin the future.",
-    GeneratorExit: "Request that a generator exit.",
-    IOError: "Base class for I/O related errors.",
-    ImportError: "Import can't find module, or can't find name in module.",
-    ImportWarning: "Base class for warnings about probable mistakes in module imports",
-    IndentationError: "Improper indentation.",
-    IndexError: "Sequence index out of range.",
-    InterruptedError: "Interrupted by signal.",
-    IsADirectoryError: "Operation doesn't work on directories.",
-    KeyError: "Mapping key not found.",
-    KeyboardInterrupt: "Program interrupted by user.",
-    LookupError: "Base class for lookup errors.",
-    MemoryError: "Out of memory.",
-    NameError: "Name not found globally.",
-    None: "",
-    NotADirectoryError: "Operation only works on directories.",
-    NotImplemented: "",
-    NotImplementedError: "Method or function hasn't been implemented yet.",
-    OSError: "Base class for I/O related errors.",
-    OverflowError: "Result too large to be represented.",
-    PendingDeprecationWarning: "Base class for warnings about features which will be deprecated\nin the future.",
-    PermissionError: "Not enough permissions.",
-    ProcessLookupError: "Process not found.",
-    ReferenceError: "Weak ref proxy used after referent went away.",
-    ResourceWarning: "Base class for warnings about resource usage.",
-    RuntimeError: "Unspecified run-time error.",
-    RuntimeWarning: "Base class for warnings about dubious runtime behavior.",
-    StopIteration: "Signal the end from iterator.__next__().",
-    SyntaxError: "Invalid syntax.",
-    SyntaxWarning: "Base class for warnings about dubious syntax.",
-    SystemError: "Internal error in the Python interpreter.\n\nPlease report this to the Python maintainer, along with the traceback,\nthe Python version, and the hardware/OS platform and version.",
-    SystemExit: "Request to exit from the interpreter.",
-    TabError: "Improper mixture of spaces and tabs.",
-    TimeoutError: "Timeout expired.",
-    True: "bool(x) -> bool\n\nReturns True when the argument x is true, False otherwise.\nThe builtins True and False are the only two instances of the class bool.\nThe class bool is a subclass of the class int, and cannot be subclassed.",
-    TypeError: "Inappropriate argument type.",
-    UnboundLocalError: "Local name referenced but not bound to a value.",
-    UnicodeDecodeError: "Unicode decoding error.",
-    UnicodeEncodeError: "Unicode encoding error.",
-    UnicodeError: "Unicode related error.",
-    UnicodeTranslateError: "Unicode translation error.",
-    UnicodeWarning: "Base class for warnings about Unicode related problems, mostly\nrelated to conversion problems.",
-    UserWarning: "Base class for warnings generated by user code.",
-    ValueError: "Inappropriate argument value (of correct type).",
-    Warning: "Base class for warning categories.",
-    WindowsError: "Base class for I/O related errors.",
-    ZeroDivisionError: "Second argument to a division or modulo operation was zero.",
-    __debug__: "bool(x) -> bool\n\nReturns True when the argument x is true, False otherwise.\nThe builtins True and False are the only two instances of the class bool.\nThe class bool is a subclass of the class int, and cannot be subclassed.",
-    abs: "abs(number) -> number\n\nReturn the absolute value of the argument.",
-    all: "all(iterable) -> bool\n\nReturn True if bool(x) is True for all values x in the iterable.\nIf the iterable is empty, return True.",
-    any: "any(iterable) -> bool\n\nReturn True if bool(x) is True for any x in the iterable.\nIf the iterable is empty, return False.",
-    ascii: "ascii(object) -> string\n\nAs repr(), return a string containing a printable representation of an\nobject, but escape the non-ASCII characters in the string returned by\nrepr() using \\x, \\u or \\U escapes.  This generates a string similar\nto that returned by repr() in Python 2.",
-    bin: "bin(number) -> string\n\nReturn the binary representation of an integer.\n\n   >>> bin(2796202)\n   '0b1010101010101010101010'\n",
-    bool: "bool(x) -> bool\n\nReturns True when the argument x is true, False otherwise.\nThe builtins True and False are the only two instances of the class bool.\nThe class bool is a subclass of the class int, and cannot be subclassed.",
-    bytearray: "bytearray(iterable_of_ints) -> bytearray\nbytearray(string, encoding[, errors]) -> bytearray\nbytearray(bytes_or_buffer) -> mutable copy of bytes_or_buffer\nbytearray(int) -> bytes array of size given by the parameter initialized with null bytes\nbytearray() -> empty bytes array\n\nConstruct an mutable bytearray object from:\n  - an iterable yielding integers in range(256)\n  - a text string encoded using the specified encoding\n  - a bytes or a buffer object\n  - any object implementing the buffer API.\n  - an integer",
-    bytes: "bytes(iterable_of_ints) -> bytes\nbytes(string, encoding[, errors]) -> bytes\nbytes(bytes_or_buffer) -> immutable copy of bytes_or_buffer\nbytes(int) -> bytes object of size given by the parameter initialized with null bytes\nbytes() -> empty bytes object\n\nConstruct an immutable array of bytes from:\n  - an iterable yielding integers in range(256)\n  - a text string encoded using the specified encoding\n  - any object implementing the buffer API.\n  - an integer",
-    callable: "callable(object) -> bool\n\nReturn whether the object is callable (i.e., some kind of function).\nNote that classes are callable, as are instances of classes with a\n__call__() method.",
-    chr: "chr(i) -> Unicode character\n\nReturn a Unicode string of one character with ordinal i; 0 <= i <= 0x10ffff.",
-    classmethod: "classmethod(function) -> method\n\nConvert a function to be a class method.\n\nA class method receives the class as implicit first argument,\njust like an instance method receives the instance.\nTo declare a class method, use this idiom:\n\n  class C:\n      def f(cls, arg1, arg2, ...): ...\n      f = classmethod(f)\n\nIt can be called either on the class (e.g. C.f()) or on an instance\n(e.g. C().f()).  The instance is ignored except for its class.\nIf a class method is called for a derived class, the derived class\nobject is passed as the implied first argument.\n\nClass methods are different than C++ or Java static methods.\nIf you want those, see the staticmethod builtin.",
-    compile: "compile(source, filename, mode[, flags[, dont_inherit]]) -> code object\n\nCompile the source (a Python module, statement or expression)\ninto a code object that can be executed by exec() or eval().\nThe filename will be used for run-time error messages.\nThe mode must be 'exec' to compile a module, 'single' to compile a\nsingle (interactive) statement, or 'eval' to compile an expression.\nThe flags argument, if present, controls which future statements influence\nthe compilation of the code.\nThe dont_inherit argument, if non-zero, stops the compilation inheriting\nthe effects of any future statements in effect in the code calling\ncompile; if absent or zero these statements do influence the compilation,\nin addition to any features explicitly specified.",
-    complex: "complex(real[, imag]) -> complex number\n\nCreate a complex number from a real part and an optional imaginary part.\nThis is equivalent to (real + imag*1j) where imag defaults to 0.",
-    copyright: "interactive prompt objects for printing the license text, a list of\n    contributors and the copyright notice.",
-    credits: "interactive prompt objects for printing the license text, a list of\n    contributors and the copyright notice.",
-    delattr: "delattr(object, name)\n\nDelete a named attribute on an object; delattr(x, 'y') is equivalent to\n``del x.y''.",
-    dict: "dict() -> new empty dictionary\ndict(mapping) -> new dictionary initialized from a mapping object's\n    (key, value) pairs\ndict(iterable) -> new dictionary initialized as if via:\n    d = {}\n    for k, v in iterable:\n        d[k] = v\ndict(**kwargs) -> new dictionary initialized with the name=value pairs\n    in the keyword argument list.  For example:  dict(one=1, two=2)",
-    dir: "dir([object]) -> list of strings\n\nIf called without an argument, return the names in the current scope.\nElse, return an alphabetized list of names comprising (some of) the attributes\nof the given object, and of attributes reachable from it.\nIf the object supplies a method named __dir__, it will be used; otherwise\nthe default dir() logic is used and returns:\n  for a module object: the module's attributes.\n  for a class object:  its attributes, and recursively the attributes\n    of its bases.\n  for any other object: its attributes, its class's attributes, and\n    recursively the attributes of its class's base classes.",
-    divmod: "divmod(x, y) -> (div, mod)\n\nReturn the tuple ((x-x%y)/y, x%y).  Invariant: div*y + mod == x.",
-    enumerate: "enumerate(iterable[, start]) -> iterator for index, value of iterable\n\nReturn an enumerate object.  iterable must be another object that supports\niteration.  The enumerate object yields pairs containing a count (from\nstart, which defaults to zero) and a value yielded by the iterable argument.\nenumerate is useful for obtaining an indexed list:\n    (0, seq[0]), (1, seq[1]), (2, seq[2]), ...",
-    eval: "eval(source[, globals[, locals]]) -> value\n\nEvaluate the source in the C of globals and locals.\nThe source may be a string representing a Python expression\nor a code object as returned by compile().\nThe globals must be a dictionary and locals can be any mapping,\ndefaulting to the current globals and locals.\nIf only globals is given, locals defaults to it.\n",
-    exec: "exec(object[, globals[, locals]])\n\nRead and execute code from an object, which can be a string or a code\nobject.\nThe globals and locals are dictionaries, defaulting to the current\nglobals and locals.  If only globals is given, locals defaults to it.",
-    exit: "",
-    filter: "filter(function or None, iterable) --> filter object\n\nReturn an iterator yielding those items of iterable for which function(item)\nis true. If function is None, return the items that are true.",
-    float: "float(x) -> floating point number\n\nConvert a string or number to a floating point number, if possible.",
-    format: "format(value[, format_spec]) -> string\n\nReturns value.__format__(format_spec)\nformat_spec defaults to \"\"",
-    frozenset: "frozenset() -> empty frozenset object\nfrozenset(iterable) -> frozenset object\n\nBuild an immutable unordered collection of unique elements.",
-    getattr: "getattr(object, name[, default]) -> value\n\nGet a named attribute from an object; getattr(x, 'y') is equivalent to x.y.\nWhen a default argument is given, it is returned when the attribute doesn't\nexist; without it, an exception is raised in that case.",
-    globals: "globals() -> dictionary\n\nReturn the dictionary containing the current scope's global variables.",
-    hasattr: "hasattr(object, name) -> bool\n\nReturn whether the object has an attribute with the given name.\n(This is done by calling getattr(object, name) and catching AttributeError.)",
-    hash: "hash(object) -> integer\n\nReturn a hash value for the object.  Two objects with the same value have\nthe same hash value.  The reverse is not necessarily true, but likely.",
-    help: "Define the builtin 'help'.\n\n    This is a wrapper around pydoc.help that provides a helpful message\n    when 'help' is typed at the Python interactive prompt.\n\n    Calling help() at the Python prompt starts an interactive help session.\n    Calling help(thing) prints help for the python object 'thing'.\n    ",
-    hex: "hex(number) -> string\n\nReturn the hexadecimal representation of an integer.\n\n   >>> hex(3735928559)\n   '0xdeadbeef'\n",
-    id: "id(object) -> integer\n\nReturn the identity of an object.  This is guaranteed to be unique among\nsimultaneously existing objects.  (Hint: it's the object's memory address.)",
-    input: "input([prompt]) -> string\n\nRead a string from standard input.  The trailing newline is stripped.\nIf the user hits EOF (Unix: Ctl-D, Windows: Ctl-Z+Return), raise EOFError.\nOn Unix, GNU readline is used if enabled.  The prompt string, if given,\nis printed without a trailing newline before reading.",
-    int: "int(x=0) -> integer\nint(x, base=10) -> integer\n\nConvert a number or string to an integer, or return 0 if no arguments\nare given.  If x is a number, return x.__int__().  For floating point\nnumbers, this truncates towards zero.\n\nIf x is not a number or if base is given, then x must be a string,\nbytes, or bytearray instance representing an integer literal in the\ngiven base.  The literal can be preceded by '+' or '-' and be surrounded\nby whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.\nBase 0 means to interpret the base from the string as an integer literal.\n>>> int('0b100', base=0)\n4",
-    isinstance: "isinstance(object, class-or-type-or-tuple) -> bool\n\nReturn whether an object is an instance of a class or of a subclass thereof.\nWith a type as second argument, return whether that is the object's type.\nThe form using a tuple, isinstance(x, (A, B, ...)), is a shortcut for\nisinstance(x, A) or isinstance(x, B) or ... (etc.).",
-    issubclass: "issubclass(C, B) -> bool\n\nReturn whether class C is a subclass (i.e., a derived class) of class B.\nWhen using a tuple as the second argument issubclass(X, (A, B, ...)),\nis a shortcut for issubclass(X, A) or issubclass(X, B) or ... (etc.).",
-    iter: "iter(iterable) -> iterator\niter(callable, sentinel) -> iterator\n\nGet an iterator from an object.  In the first form, the argument must\nsupply its own iterator, or be a sequence.\nIn the second form, the callable is called until it returns the sentinel.",
-    len: "len(object)\n\nReturn the number of items of a sequence or collection.",
-    license: "interactive prompt objects for printing the license text, a list of\n    contributors and the copyright notice.",
-    list: "list() -> new empty list\nlist(iterable) -> new list initialized from iterable's items",
-    locals: "locals() -> dictionary\n\nUpdate and return a dictionary containing the current scope's local variables.",
-    map: "map(func, *iterables) --> map object\n\nMake an iterator that computes the function using arguments from\neach of the iterables.  Stops when the shortest iterable is exhausted.",
-    max: "max(iterable, *[, default=obj, key=func]) -> value\nmax(arg1, arg2, *args, *[, key=func]) -> value\n\nWith a single iterable argument, return its biggest item. The\ndefault keyword-only argument specifies an object to return if\nthe provided iterable is empty.\nWith two or more arguments, return the largest argument.",
-    memoryview: "memoryview(object)\n\nCreate a new memoryview object which references the given object.",
-    min: "min(iterable, *[, default=obj, key=func]) -> value\nmin(arg1, arg2, *args, *[, key=func]) -> value\n\nWith a single iterable argument, return its smallest item. The\ndefault keyword-only argument specifies an object to return if\nthe provided iterable is empty.\nWith two or more arguments, return the smallest argument.",
-    next: "next(iterator[, default])\n\nReturn the next item from the iterator. If default is given and the iterator\nis exhausted, it is returned instead of raising StopIteration.",
-    object: "The most base type",
-    oct: "oct(number) -> string\n\nReturn the octal representation of an integer.\n\n   >>> oct(342391)\n   '0o1234567'\n",
-    open: "open(file, mode='r', buffering=-1, encoding=None,\n     errors=None, newline=None, closefd=True, opener=None) -> file object\n\nOpen file and return a stream.  Raise IOError upon failure.\n\nfile is either a text or byte string giving the name (and the path\nif the file isn't in the current working directory) of the file to\nbe opened or an integer file descriptor of the file to be\nwrapped. (If a file descriptor is given, it is closed when the\nreturned I/O object is closed, unless closefd is set to False.)\n\nmode is an optional string that specifies the mode in which the file\nis opened. It defaults to 'r' which means open for reading in text\nmode.  Other common values are 'w' for writing (truncating the file if\nit already exists), 'x' for creating and writing to a new file, and\n'a' for appending (which on some Unix systems, means that all writes\nappend to the end of the file regardless of the current seek position).\nIn text mode, if encoding is not specified the encoding used is platform\ndependent: locale.getpreferredencoding(False) is called to get the\ncurrent locale encoding. (For reading and writing raw bytes use binary\nmode and leave encoding unspecified.) The available modes are:\n\n========= ===============================================================\nCharacter Meaning\n--------- ---------------------------------------------------------------\n'r'       open for reading (default)\n'w'       open for writing, truncating the file first\n'x'       create a new file and open it for writing\n'a'       open for writing, appending to the end of the file if it exists\n'b'       binary mode\n't'       text mode (default)\n'+'       open a disk file for updating (reading and writing)\n'U'       universal newline mode (deprecated)\n========= ===============================================================\n\nThe default mode is 'rt' (open for reading text). For binary random\naccess, the mode 'w+b' opens and truncates the file to 0 bytes, while\n'r+b' opens the file without truncation. The 'x' mode implies 'w' and\nraises an `FileExistsError` if the file already exists.\n\nPython distinguishes between files opened in binary and text modes,\neven when the underlying operating system doesn't. Files opened in\nbinary mode (appending 'b' to the mode argument) return contents as\nbytes objects without any decoding. In text mode (the default, or when\n't' is appended to the mode argument), the contents of the file are\nreturned as strings, the bytes having been first decoded using a\nplatform-dependent encoding or using the specified encoding if given.\n\n'U' mode is deprecated and will raise an exception in future versions\nof Python.  It has no effect in Python 3.  Use newline to control\nuniversal newlines mode.\n\nbuffering is an optional integer used to set the buffering policy.\nPass 0 to switch buffering off (only allowed in binary mode), 1 to select\nline buffering (only usable in text mode), and an integer > 1 to indicate\nthe size of a fixed-size chunk buffer.  When no buffering argument is\ngiven, the default buffering policy works as follows:\n\n* Binary files are buffered in fixed-size chunks; the size of the buffer\n  is chosen using a heuristic trying to determine the underlying device's\n  \"block size\" and falling back on `io.DEFAULT_BUFFER_SIZE`.\n  On many systems, the buffer will typically be 4096 or 8192 bytes long.\n\n* \"Interactive\" text files (files for which isatty() returns True)\n  use line buffering.  Other text files use the policy described above\n  for binary files.\n\nencoding is the name of the encoding used to decode or encode the\nfile. This should only be used in text mode. The default encoding is\nplatform dependent, but any encoding supported by Python can be\npassed.  See the codecs module for the list of supported encodings.\n\nerrors is an optional string that specifies how encoding errors are to\nbe handled---this argument should not be used in binary mode. Pass\n'strict' to raise a ValueError exception if there is an encoding error\n(the default of None has the same effect), or pass 'ignore' to ignore\nerrors. (Note that ignoring encoding errors can lead to data loss.)\nSee the documentation for codecs.register or run 'help(codecs.Codec)'\nfor a list of the permitted encoding error strings.\n\nnewline controls how universal newlines works (it only applies to text\nmode). It can be None, '', '\\n', '\\r', and '\\r\\n'.  It works as\nfollows:\n\n* On input, if newline is None, universal newlines mode is\n  enabled. Lines in the input can end in '\\n', '\\r', or '\\r\\n', and\n  these are translated into '\\n' before being returned to the\n  caller. If it is '', universal newline mode is enabled, but line\n  endings are returned to the caller untranslated. If it has any of\n  the other legal values, input lines are only terminated by the given\n  string, and the line ending is returned to the caller untranslated.\n\n* On output, if newline is None, any '\\n' characters written are\n  translated to the system default line separator, os.linesep. If\n  newline is '' or '\\n', no translation takes place. If newline is any\n  of the other legal values, any '\\n' characters written are translated\n  to the given string.\n\nIf closefd is False, the underlying file descriptor will be kept open\nwhen the file is closed. This does not work when a file name is given\nand must be True in that case.\n\nA custom opener can be used by passing a callable as *opener*. The\nunderlying file descriptor for the file object is then obtained by\ncalling *opener* with (*file*, *flags*). *opener* must return an open\nfile descriptor (passing os.open as *opener* results in functionality\nsimilar to passing None).\n\nopen() returns a file object whose type depends on the mode, and\nthrough which the standard file operations such as reading and writing\nare performed. When open() is used to open a file in a text mode ('w',\n'r', 'wt', 'rt', etc.), it returns a TextIOWrapper. When used to open\na file in a binary mode, the returned class varies: in read binary\nmode, it returns a BufferedReader; in write binary and append binary\nmodes, it returns a BufferedWriter, and in read/write mode, it returns\na BufferedRandom.\n\nIt is also possible to use a string or bytearray as a file for both\nreading and writing. For strings StringIO can be used like a file\nopened in a text mode, and for bytes a BytesIO can be used like a file\nopened in a binary mode.\n",
-    ord: "ord(c) -> integer\n\nReturn the integer ordinal of a one-character string.",
-    pow: "pow(x, y[, z]) -> number\n\nWith two arguments, equivalent to x**y.  With three arguments,\nequivalent to (x**y) % z, but may be more efficient (e.g. for ints).",
-    print: "print(value, ..., sep=' ', end='\\n', file=sys.stdout, flush=False)\n\nPrints the values to a stream, or to sys.stdout by default.\nOptional keyword arguments:\nfile:  a file-like object (stream); defaults to the current sys.stdout.\nsep:   string inserted between values, default a space.\nend:   string appended after the last value, default a newline.\nflush: whether to forcibly flush the stream.",
-    property: "property(fget=None, fset=None, fdel=None, doc=None) -> property attribute\n\nfget is a function to be used for getting an attribute value, and likewise\nfset is a function for setting, and fdel a function for del'ing, an\nattribute.  Typical use is to define a managed attribute x:\n\nclass C(object):\n    def getx(self): return self._x\n    def setx(self, value): self._x = value\n    def delx(self): del self._x\n    x = property(getx, setx, delx, \"I'm the 'x' property.\")\n\nDecorators make defining new properties or modifying existing ones easy:\n\nclass C(object):\n    @property\n    def x(self):\n        \"I am the 'x' property.\"\n        return self._x\n    @x.setter\n    def x(self, value):\n        self._x = value\n    @x.deleter\n    def x(self):\n        del self._x\n",
-    quit: "",
-    range: "range(stop) -> range object\nrange(start, stop[, step]) -> range object\n\nReturn a virtual sequence of numbers from start to stop by step.",
-    repr: "repr(object) -> string\n\nReturn the canonical string representation of the object.\nFor most object types, eval(repr(object)) == object.",
-    reversed: "reversed(sequence) -> reverse iterator over values of the sequence\n\nReturn a reverse iterator",
-    round: "round(number[, ndigits]) -> number\n\nRound a number to a given precision in decimal digits (default 0 digits).\nThis returns an int when called with one argument, otherwise the\nsame type as the number. ndigits may be negative.",
-    set: "set() -> new empty set object\nset(iterable) -> new set object\n\nBuild an unordered collection of unique elements.",
-    setattr: "setattr(object, name, value)\n\nSet a named attribute on an object; setattr(x, 'y', v) is equivalent to\n``x.y = v''.",
-    slice: "slice(stop)\nslice(start, stop[, step])\n\nCreate a slice object.  This is used for extended slicing (e.g. a[0:10:2]).",
-    sorted: "sorted(iterable, key=None, reverse=False) --> new sorted list",
-    staticmethod: "staticmethod(function) -> method\n\nConvert a function to be a static method.\n\nA static method does not receive an implicit first argument.\nTo declare a static method, use this idiom:\n\n     class C:\n     def f(arg1, arg2, ...): ...\n     f = staticmethod(f)\n\nIt can be called either on the class (e.g. C.f()) or on an instance\n(e.g. C().f()).  The instance is ignored except for its class.\n\nStatic methods in Python are similar to those found in Java or C++.\nFor a more advanced concept, see the classmethod builtin.",
-    str: "str(object='') -> str\nstr(bytes_or_buffer[, encoding[, errors]]) -> str\n\nCreate a new string object from the given object. If encoding or\nerrors is specified, then the object must expose a data buffer\nthat will be decoded using the given encoding and error handler.\nOtherwise, returns the result of object.__str__() (if defined)\nor repr(object).\nencoding defaults to sys.getdefaultencoding().\nerrors defaults to 'strict'.",
-    sum: "sum(iterable[, start]) -> value\n\nReturn the sum of an iterable of numbers (NOT strings) plus the value\nof parameter 'start' (which defaults to 0).  When the iterable is\nempty, return start.",
-    super: "super() -> same as super(__class__, <first argument>)\nsuper(type) -> unbound super object\nsuper(type, obj) -> bound super object; requires isinstance(obj, type)\nsuper(type, type2) -> bound super object; requires issubclass(type2, type)\nTypical use to call a cooperative superclass method:\nclass C(B):\n    def meth(self, arg):\n        super().meth(arg)\nThis works for class methods too:\nclass C(B):\n    @classmethod\n    def cmeth(cls, arg):\n        super().cmeth(arg)\n",
-    tuple: "tuple() -> empty tuple\ntuple(iterable) -> tuple initialized from iterable's items\n\nIf the argument is a tuple, the return value is the same object.",
-    type: "type(object_or_name, bases, dict)\ntype(object) -> the object's type\ntype(name, bases, dict) -> a new type",
-    vars: "vars([object]) -> dictionary\n\nWithout arguments, equivalent to locals().\nWith an argument, equivalent to object.__dict__.",
-    zip: "zip(iter1 [,iter2 [...]]) --> zip object\n\nReturn a zip object whose .__next__() method returns a tuple where\nthe i-th element comes from the i-th iterable argument.  The .__next__()\nmethod continues until the shortest iterable in the argument sequence\nis exhausted and then it raises StopIteration.",
-}
-__BRYTHON__.builtins_doc = docs;;
+})(__BRYTHON__);;
 (function($B) {
     var _b_ = $B.builtins
     var coroutine = $B.coroutine = $B.make_class("coroutine")
     coroutine.close = function(self) {}
     coroutine.send = function(self) {
         return self.$func.apply(null, self.$args)
     }
```

### Comparing `brython-3.9.5/brython/data/brython_stdlib.js` & `brython-3.9.6/brython/data/brython_stdlib.js`

 * *Files 0% similar despite different names*

#### js-beautify {}

```diff
@@ -1,53 +1,53 @@
 __BRYTHON__.use_VFS = true;
 var scripts = {
-    "$timestamp": 1625476379142,
-    "array": [".js", "var $module = (function($B){\n\nvar _b_ = $B.builtins,\n    $s = [],\n    i\nfor(var $b in _b_){$s.push('var ' + $b +' = _b_[\"'+$b+'\"]')}\neval($s.join(';'))\n\nvar typecodes = {\n    'b': Int8Array,    // signed char, 1 byte\n    'B': Uint8Array,   // unsigned char, 1\n    'u': Uint32Array,  // Py_UNICODE Unicode character, 2 (deprecated)\n    'h': Int16Array,   // signed short, 2\n    'H': Uint16Array,  // unsigned short, 2\n    'i': Int16Array,   //  signed int, 2\n    'I': Uint16Array,  // unsigned int, 2\n    'l': Int32Array,   // signed long, 4\n    'L': Uint32Array,  // unsigned long, 4\n    'q': null,         // signed long, 8 (not implemented)\n    'Q': null,         // unsigned long, 8 (not implemented)\n    'f': Float32Array, // float, 4\n    'd': Float64Array  // double float, 8\n}\n\nvar array = $B.make_class(\"array\",\n    function(){\n        var missing = {},\n            $ = $B.args(\"array\", 2, {typecode: null, initializer: null},\n                [\"typecode\", \"initializer\"], arguments, {initializer: missing},\n                null, null),\n            typecode = $.typecode,\n            initializer = $.initializer\n        if(! typecodes.hasOwnProperty(typecode)){\n            throw _b_.ValueError.$factory(\"bad typecode (must be b, \" +\n                \"B, u, h, H, i, I, l, L, q, Q, f or d)\")\n        }\n        if(typecodes[typecode] === null){\n            console.log(\"array factory, $\", $, typecode)\n            throw _b_.NotImplementedError.$factory(\"type code \" +\n                typecode + \" is not implemented\")\n        }\n        var res = {\n            __class__: array,\n            typecode: typecode,\n            obj: null\n        }\n        if(initializer !== missing){\n            if(Array.isArray(initializer)){\n                array.fromlist(res, initializer)\n            }else if(_b_.isinstance(initializer, _b_.bytes)){\n                array.frombytes(res, initializer)\n            }else{\n                array.extend(res, initializer)\n            }\n        }\n        return res\n    }\n)\n\narray.$buffer_protocol = true\n\narray.__getitem__ = function(self, key){\n    if(self.obj && self.obj[key] !== undefined){\n        return self.obj[key]\n    }\n    throw _b_.IndexError(\"array index out of range\")\n}\n\nvar array_iterator = $B.make_iterator_class(\"array_iterator\")\narray.__iter__ = function(self){\n    return array_iterator.$factory(self.obj === null ? [] : self.obj)\n}\n\narray.__len__ = function(self){\n    return self.obj === null ? 0 : self.obj.length\n}\n\narray.__str__ = function(self){\n    $B.args(\"__str__\", 1, {self: null},\n        [\"self\"], arguments, {}, null, null)\n    var res = \"array('\" + self.typecode + \"'\"\n    if(self.obj !== null){\n        res += \", [\" + self.obj + \"]\"\n    }\n    return res + \")\"\n}\n\nfunction normalize_index(self, i){\n    // return an index i between 0 and self.obj.length - 1\n    if(i < 0){\n        i = self.obj.length + i\n    }\n    if(i < 0){i = 0}\n    else if(i > self.obj.length - 1){\n        i = self.obj.length\n    }\n    return i\n}\n\narray.append = function(self, value){\n    $B.args(\"append\", 2, {self: null, value: null},\n        [\"self\", \"value\"], arguments, {}, null, null)\n    var pos = self.obj === null ? 0 : self.obj.length\n    return array.insert(self, pos, value)\n}\n\narray.count = function(self, x){\n    $B.args(\"count\", 2, {self: null, x: null},\n        [\"self\", \"x\"], arguments, {}, null, null)\n    if(self.obj === null){return 0}\n    return self.obj.filter(function(item){return item == x}).length\n}\n\narray.extend = function(self, iterable){\n    $B.args(\"extend\", 2, {self: null, iterable: null},\n        [\"self\", \"iterable\"], arguments, {}, null, null)\n    if(iterable.__class__ === array){\n        if(iterable.typecode !== self.typecode){\n            throw _b_.TypeError.$factory(\"can only extend with array \" +\n                \"of same kind\")\n        }\n        if(iterable.obj === null){return _b_.None}\n        // create new object with length = sum of lengths\n        var newobj = new typecodes[self.typecode](self.obj.length +\n            iterable.obj.length)\n        // copy self.obj\n        newobj.set(self.obj)\n        // copy iterable.obj\n        newobj.set(iterable.obj, self.obj.length)\n        self.obj = newobj\n    }else{\n        var it = _b_.iter(iterable)\n        while(true){\n            try{\n                var item = _b_.next(it)\n                array.append(self, item)\n            }catch(err){\n                if(err.__class__ !== _b_.StopIteration){\n                    throw err\n                }\n                break\n            }\n        }\n    }\n    return _b_.None\n}\n\narray.frombytes = function(self, s){\n    $B.args(\"frombytes\", 2, {self: null, s: null},\n        [\"self\", \"s\"], arguments, {}, null, null)\n    if(! _b_.isinstance(s, _b_.bytes)){\n        throw _b_.TypeError.$factory(\"a bytes-like object is required, \" +\n            \"not '\" + $B.class_name(s) + \"'\")\n    }\n    self.obj = new typecodes[self.typecode](s.source)\n    return None\n}\n\narray.fromlist = function(self, list){\n    $B.args(\"fromlist\", 2, {self: null, list: null},\n        [\"self\", \"list\"], arguments, {}, null, null)\n    var it = _b_.iter(list)\n    while(true){\n        try{\n            var item = _b_.next(it)\n            try{\n                array.append(self, item)\n            }catch(err){\n                console.log(err)\n                return _b_.None\n            }\n        }catch(err){\n            if(err.__class__ === _b_.StopIteration){\n                return _b_.None\n            }\n            throw err\n        }\n    }\n}\n\narray.fromstring = array.frombytes\n\narray.index = function(self, x){\n    $B.args(\"index\", 2, {self: null, x: null},\n        [\"self\", \"x\"], arguments, {}, null, null)\n    var res = self.obj.findIndex(function(item){return x == item})\n    if(res == -1){\n        throw _b_.ValueError.$factory(\"array.index(x): x not in array\")\n    }\n    return res\n}\n\narray.insert = function(self, i, value){\n    $B.args(\"insert\", 3, {self: null, i: null, value: null},\n        [\"self\", \"i\", \"value\"], arguments, {}, null, null)\n    if(self.obj === null){\n        self.obj = [value]\n    }else{\n        self.obj.splice(i, 0, value)\n    }\n    return _b_.None\n}\n\narray.itemsize = function(self){\n    return typecodes[self.typecode].BYTES_PER_ELEMENT\n}\n\narray.pop = function(self, i){\n    var $ = $B.args(\"count\", 2, {self: null, i: null},\n        [\"self\", \"i\"], arguments, {i: -1}, null, null)\n    i = $.i\n    if(self.obj === null){\n        throw _b_.IndexError.$factory(\"pop from empty array\")\n    }else if(self.obj.length == 1){\n        var res = self.obj[0]\n        self.obj = null\n        return res\n    }\n    i = normalize_index(self, i)\n    // store value to return\n    var res = self.obj[i]\n    // create new array, size = previous size - 1\n    var newobj = new typecodes[self.typecode](self.obj.length - 1)\n    // fill new array with values until i excluded\n    newobj.set(self.obj.slice(0, i))\n    // fill with values after i\n    newobj.set(self.obj.slice(i + 1), i)\n    // set self.obj to new array\n    self.obj = newobj\n    // return stored value\n    return res\n}\n\narray.remove = function(self, x){\n    $B.args(\"remove\", 2, {self: null, x: null},\n        [\"self\", \"x\"], arguments, {}, null, null)\n    var res = self.obj.findIndex(function(item){return x == item})\n    if(res == -1){\n        throw _b_.ValueError.$factory(\"array.remove(x): x not in array\")\n    }\n    array.pop(self, res)\n    return _b_.None\n}\n\narray.reverse = function(self){\n    $B.args(\"reverse\", 1, {self: null},\n        [\"self\"], arguments, {}, null, null)\n    if(self.obj === null){return _b_.None}\n    self.obj.reverse()\n    return _b_.None\n}\n\narray.tobytes = function(self){\n    $B.args(\"tobytes\", 1, {self: null},\n        [\"self\"], arguments, {}, null, null)\n    var items = Array.prototype.slice.call(self.obj),\n        res = []\n    items.forEach(function(item){\n        while(item > 256){\n            res.push(item % 256)\n            item = Math.floor(item / 256)\n        }\n        res.push(item)\n    })\n    return _b_.bytes.$factory(res)\n}\n\narray.tolist = function(self){\n    $B.args(\"tolist\", 1, {self: null},\n        [\"self\"], arguments, {}, null, null)\n    if(self.obj === null){\n        return $B.$list([])\n    }\n    return Array.prototype.slice.call(self.obj)\n}\n\narray.tostring = array.tobytes\n\narray.typecode = function(self){\n    return self.typecode\n}\n\n$B.set_func_names(array, \"array\")\n\nreturn {\n    array: array,\n    typecodes: Object.keys(typecodes).join('')\n}\n\n})(__BRYTHON__)\n"],
+    "$timestamp": 1632733213545,
+    "array": [".js", "var $module = (function($B){\n\nvar _b_ = $B.builtins\n\nvar typecodes = {\n    'b': Int8Array,    // signed char, 1 byte\n    'B': Uint8Array,   // unsigned char, 1\n    'u': Uint32Array,  // Py_UNICODE Unicode character, 2 (deprecated)\n    'h': Int16Array,   // signed short, 2\n    'H': Uint16Array,  // unsigned short, 2\n    'i': Int16Array,   //  signed int, 2\n    'I': Uint16Array,  // unsigned int, 2\n    'l': Int32Array,   // signed long, 4\n    'L': Uint32Array,  // unsigned long, 4\n    'q': null,         // signed long, 8 (not implemented)\n    'Q': null,         // unsigned long, 8 (not implemented)\n    'f': Float32Array, // float, 4\n    'd': Float64Array  // double float, 8\n}\n\nvar array = $B.make_class(\"array\",\n    function(){\n        var missing = {},\n            $ = $B.args(\"array\", 2, {typecode: null, initializer: null},\n                [\"typecode\", \"initializer\"], arguments, {initializer: missing},\n                null, null),\n            typecode = $.typecode,\n            initializer = $.initializer\n        if(! typecodes.hasOwnProperty(typecode)){\n            throw _b_.ValueError.$factory(\"bad typecode (must be b, \" +\n                \"B, u, h, H, i, I, l, L, q, Q, f or d)\")\n        }\n        if(typecodes[typecode] === null){\n            console.log(\"array factory, $\", $, typecode)\n            throw _b_.NotImplementedError.$factory(\"type code \" +\n                typecode + \" is not implemented\")\n        }\n        var res = {\n            __class__: array,\n            typecode: typecode,\n            obj: null\n        }\n        if(initializer !== missing){\n            if(Array.isArray(initializer)){\n                array.fromlist(res, initializer)\n            }else if(_b_.isinstance(initializer, _b_.bytes)){\n                array.frombytes(res, initializer)\n            }else{\n                array.extend(res, initializer)\n            }\n        }\n        return res\n    }\n)\n\narray.$buffer_protocol = true\narray.$match_sequence_pattern = true // for Pattern Matching (PEP 634)\n\narray.__getitem__ = function(self, key){\n    if(self.obj && self.obj[key] !== undefined){\n        return self.obj[key]\n    }\n    throw _b_.IndexError(\"array index out of range\")\n}\n\nvar array_iterator = $B.make_iterator_class(\"array_iterator\")\narray.__iter__ = function(self){\n    return array_iterator.$factory(self.obj === null ? [] : self.obj)\n}\n\narray.__len__ = function(self){\n    return self.obj === null ? 0 : self.obj.length\n}\n\narray.__str__ = function(self){\n    $B.args(\"__str__\", 1, {self: null},\n        [\"self\"], arguments, {}, null, null)\n    var res = \"array('\" + self.typecode + \"'\"\n    if(self.obj !== null){\n        res += \", [\" + self.obj + \"]\"\n    }\n    return res + \")\"\n}\n\nfunction normalize_index(self, i){\n    // return an index i between 0 and self.obj.length - 1\n    if(i < 0){\n        i = self.obj.length + i\n    }\n    if(i < 0){i = 0}\n    else if(i > self.obj.length - 1){\n        i = self.obj.length\n    }\n    return i\n}\n\narray.append = function(self, value){\n    $B.args(\"append\", 2, {self: null, value: null},\n        [\"self\", \"value\"], arguments, {}, null, null)\n    var pos = self.obj === null ? 0 : self.obj.length\n    return array.insert(self, pos, value)\n}\n\narray.count = function(self, x){\n    $B.args(\"count\", 2, {self: null, x: null},\n        [\"self\", \"x\"], arguments, {}, null, null)\n    if(self.obj === null){return 0}\n    return self.obj.filter(function(item){return item == x}).length\n}\n\narray.extend = function(self, iterable){\n    $B.args(\"extend\", 2, {self: null, iterable: null},\n        [\"self\", \"iterable\"], arguments, {}, null, null)\n    if(iterable.__class__ === array){\n        if(iterable.typecode !== self.typecode){\n            throw _b_.TypeError.$factory(\"can only extend with array \" +\n                \"of same kind\")\n        }\n        if(iterable.obj === null){return _b_.None}\n        // create new object with length = sum of lengths\n        var newobj = new typecodes[self.typecode](self.obj.length +\n            iterable.obj.length)\n        // copy self.obj\n        newobj.set(self.obj)\n        // copy iterable.obj\n        newobj.set(iterable.obj, self.obj.length)\n        self.obj = newobj\n    }else{\n        var it = _b_.iter(iterable)\n        while(true){\n            try{\n                var item = _b_.next(it)\n                array.append(self, item)\n            }catch(err){\n                if(err.__class__ !== _b_.StopIteration){\n                    throw err\n                }\n                break\n            }\n        }\n    }\n    return _b_.None\n}\n\narray.frombytes = function(self, s){\n    $B.args(\"frombytes\", 2, {self: null, s: null},\n        [\"self\", \"s\"], arguments, {}, null, null)\n    if(! _b_.isinstance(s, _b_.bytes)){\n        throw _b_.TypeError.$factory(\"a bytes-like object is required, \" +\n            \"not '\" + $B.class_name(s) + \"'\")\n    }\n    self.obj = new typecodes[self.typecode](s.source)\n    return _b_.None\n}\n\narray.fromlist = function(self, list){\n    $B.args(\"fromlist\", 2, {self: null, list: null},\n        [\"self\", \"list\"], arguments, {}, null, null)\n    var it = _b_.iter(list)\n    while(true){\n        try{\n            var item = _b_.next(it)\n            try{\n                array.append(self, item)\n            }catch(err){\n                console.log(err)\n                return _b_.None\n            }\n        }catch(err){\n            if(err.__class__ === _b_.StopIteration){\n                return _b_.None\n            }\n            throw err\n        }\n    }\n}\n\narray.fromstring = array.frombytes\n\narray.index = function(self, x){\n    $B.args(\"index\", 2, {self: null, x: null},\n        [\"self\", \"x\"], arguments, {}, null, null)\n    var res = self.obj.findIndex(function(item){return x == item})\n    if(res == -1){\n        throw _b_.ValueError.$factory(\"array.index(x): x not in array\")\n    }\n    return res\n}\n\narray.insert = function(self, i, value){\n    $B.args(\"insert\", 3, {self: null, i: null, value: null},\n        [\"self\", \"i\", \"value\"], arguments, {}, null, null)\n    if(self.obj === null){\n        self.obj = [value]\n    }else{\n        self.obj.splice(i, 0, value)\n    }\n    return _b_.None\n}\n\narray.itemsize = function(self){\n    return typecodes[self.typecode].BYTES_PER_ELEMENT\n}\n\narray.pop = function(self, i){\n    var $ = $B.args(\"count\", 2, {self: null, i: null},\n        [\"self\", \"i\"], arguments, {i: -1}, null, null)\n    i = $.i\n    if(self.obj === null){\n        throw _b_.IndexError.$factory(\"pop from empty array\")\n    }else if(self.obj.length == 1){\n        var res = self.obj[0]\n        self.obj = null\n        return res\n    }\n    i = normalize_index(self, i)\n    // store value to return\n    var res = self.obj[i]\n    // create new array, size = previous size - 1\n    var newobj = new typecodes[self.typecode](self.obj.length - 1)\n    // fill new array with values until i excluded\n    newobj.set(self.obj.slice(0, i))\n    // fill with values after i\n    newobj.set(self.obj.slice(i + 1), i)\n    // set self.obj to new array\n    self.obj = newobj\n    // return stored value\n    return res\n}\n\narray.remove = function(self, x){\n    $B.args(\"remove\", 2, {self: null, x: null},\n        [\"self\", \"x\"], arguments, {}, null, null)\n    var res = self.obj.findIndex(function(item){return x == item})\n    if(res == -1){\n        throw _b_.ValueError.$factory(\"array.remove(x): x not in array\")\n    }\n    array.pop(self, res)\n    return _b_.None\n}\n\narray.reverse = function(self){\n    $B.args(\"reverse\", 1, {self: null},\n        [\"self\"], arguments, {}, null, null)\n    if(self.obj === null){return _b_.None}\n    self.obj.reverse()\n    return _b_.None\n}\n\narray.tobytes = function(self){\n    $B.args(\"tobytes\", 1, {self: null},\n        [\"self\"], arguments, {}, null, null)\n    var items = Array.prototype.slice.call(self.obj),\n        res = []\n    items.forEach(function(item){\n        while(item > 256){\n            res.push(item % 256)\n            item = Math.floor(item / 256)\n        }\n        res.push(item)\n    })\n    return _b_.bytes.$factory(res)\n}\n\narray.tolist = function(self){\n    $B.args(\"tolist\", 1, {self: null},\n        [\"self\"], arguments, {}, null, null)\n    if(self.obj === null){\n        return $B.$list([])\n    }\n    return Array.prototype.slice.call(self.obj)\n}\n\narray.tostring = array.tobytes\n\narray.typecode = function(self){\n    return self.typecode\n}\n\n$B.set_func_names(array, \"array\")\n\nreturn {\n    array: array,\n    typecodes: Object.keys(typecodes).join('')\n}\n\n})(__BRYTHON__)\n"],
     "bry_re": [".js", "var $module = (function($B){\n\n_b_ = $B.builtins\n\nfunction translate(py_pattern){\n    // Translate Python RE syntax to Javascript's\n    return py_pattern.replace(/\\(\\?P</g, '(?<')\n}\n\nfunction str_or_bytes(string, pattern){\n    if(typeof string == \"string\" || _b_.isinstance(string, _b_.str)){\n        string = string + '' // for string subclasses\n        if(typeof pattern == \"string\" || _b_.isinstance(pattern, _b_.str)){\n            pattern = pattern + ''\n        }else{\n            throw _b_.TypeError.$factory(`cannot use a `+\n                `${$B.class_name(pattern)} pattern on a string-like object`)\n        }\n        return {type: _b_.str, string, pattern}\n    }else if(_b_.isinstance(string, [_b_.bytes, _b_.bytearray, _b_.memoryview])){\n        if(! _b_.isinstance(pattern, [_b_.bytes, _b_.bytearray, _b_.memoryview])){\n            throw _b_.TypeError(`cannot use a ${$B.class_name(pattern)}` +\n                ' pattern on a bytes-like object')\n        }\n        return {\n            type: _b_.bytes,\n            string: _b_.bytes.decode(_b_.bytes.$factory(string), 'latin1'),\n            pattern: _b_.bytes.decode(_b_.bytes.$factory(pattern), 'latin1')\n        }\n    }else{\n        throw _b_.TypeError.$factory(\"invalid string type: \" +\n            $B.class_name(string))\n    }\n}\n\nvar MatchObject = $B.make_class(\"MatchObject\",\n    function(res){\n        return {\n            __class__: MatchObject,\n            res: res\n        }\n    }\n)\n\nMatchObject.__getitem__ = function(){\n    var $ = $B.args(\"__getitem__\", 2, {self: null, group: null},\n                ['self', 'group'], arguments, {group: 0}, null, null)\n    return group($.self.res, $.group)\n}\n\nMatchObject.__iter__ = function(self){\n    return _b_.iter(_b_.list.$factory(MatchObject.groupdict(self)))\n}\n\nMatchObject.__setitem__ = function(){\n    throw _b_.TypeError.$factory(\"MatchObject is readonly\")\n}\n\nMatchObject.__str__ = function(self){\n    var match = self.string.substring(self.start, self.end)\n    return `<re.Match object; span=${_b_.str.$factory(self.span)}, match='${match}'>`\n}\n\nfunction group(res, rank){\n    if(typeof rank == \"number\"){\n        if(rank < 0 || rank >= res.length){\n            throw _b_.IndexError.$factory(\"no such group\")\n        }else if(res[rank] === undefined){\n            return _b_.None\n        }\n        return res[rank]\n    }else if(_b_.isinstance(rank, _b_.int)){\n        if($B.rich_comp('__lt__', rank, 0) ||\n                $B.rich_comp('__ge__', rank, res.length)){\n            throw _b_.IndexError.$factory(\"no such group\")\n        }else if(res[rank] === undefined){\n            return _b_.None\n        }\n        return res[rank]\n    }else if(typeof rank == \"string\"){\n        if(res.groups && Object.keys(res.groups).indexOf(rank) > -1){\n            if(res.groups[rank] === undefined){\n                return _b_.None\n            }else{\n                return res.groups[rank]\n            }\n        }else{\n            throw _b_.IndexError.$factory(\"no such group\")\n        }\n    }else{\n        try{\n            var rank = $B.$GetInt(rank)\n        }catch(err){\n            throw _b_.IndexError.$factory(\"no such group\")\n        }\n        return group(res, rank)\n    }\n}\n\nfunction to_bytes(mo){\n    // Transform strings in a MatchObject to bytes\n    mo.string = _b_.str.encode(mo.string, 'latin1')\n    mo.res.forEach(function(item, rank){\n        if(item !== undefined){\n            mo.res[rank] = _b_.str.encode(item, 'latin1')\n        }\n    })\n}\n\nMatchObject.group = function(){\n    var $ = $B.args(\"group\", 2, {self: null, rank: null}, ['self', 'rank'],\n                    arguments, {rank: 0}, 'ranks', null),\n            self = $.self,\n            rank = $.rank,\n            ranks = $.ranks\n    var first = group(self.res, rank)\n    if(ranks.length == 0){\n        return first\n    }else{\n        var result = [first]\n        for(var rank of ranks){\n            result.push(group(self.res, rank))\n        }\n        return $B.fast_tuple(result)\n    }\n}\n\nMatchObject.groupdict = function(){\n    var $ = $B.args(\"group\", 2, {self: null, default: null}, ['self', 'default'],\n                    arguments, {default: _b_.None}, null, null),\n            self = $.self,\n            _default = $.default\n    var d = $B.empty_dict()\n    if(self.res.groups){\n        for(var key in self.res.groups){\n            if(self.res.groups[key] === undefined){\n                _b_.dict.$setitem(d, key, _default)\n            }else{\n                _b_.dict.$setitem(d, key, self.res.groups[key])\n            }\n        }\n    }\n    return d\n}\n\nMatchObject.groups = function(self, _default){\n    var groups = self.res.slice(1)\n    groups.forEach(function(item, rank){\n        if(item === undefined){\n            groups[rank] = _default === undefined ? _b_.None : _default\n        }\n    })\n    return $B.fast_tuple(groups)\n}\n\nMatchObject.span = function(){\n    var $ = $B.args(\"span\", 2, {self: null, group: null}, ['self', 'group'],\n                    arguments, {group: 0}, null, null),\n            self = $.self,\n            group = $.group\n    if(group == 0){\n        return $B.fast_tuple([self.start, self.end])\n    }\n}\n$B.set_func_names(MatchObject, \"re\")\n\nvar Pattern = $B.make_class(\"Pattern\",\n    function(pattern, flags){\n        return {\n            __class__: Pattern,\n            pattern: pattern,\n            flags: flags\n        }\n    }\n)\n\nPattern.__str__ = function(self){\n    return `<re.Pattern object>`\n}\n\nPattern.match = function(){\n    var $ = $B.args(\"match\", 3,\n                {self: null, string: null, pos: null, endpos: null},\n                ['self', 'string', 'pos', 'endpos'], arguments,\n                {pos: 0, endpos: _b_.None}, null, null),\n        self = $.self,\n        string = $.string,\n        pos = $.pos,\n        endpos = $.endpos\n    return $match(self.pattern, string)\n}\n\n$B.set_func_names(Pattern, \"re\")\n\n\nfunction compile(){\n    var $ = $B.args(\"compile\", 2, {pattern: null, flags: null},\n                    [\"pattern\", \"flags\"], arguments, {flags: 0},\n                    null, null),\n            pattern = $.pattern,\n            flags = $.flags\n    return Pattern.$factory(pattern, flags)\n}\n\nfunction findall(){\n    var $ = $B.args(\"findall\", 3, {pattern: null, string: null, flags: null},\n                    [\"pattern\", \"string\", \"flags\"], arguments, {flags: 0},\n                    null, null),\n            pattern = $.pattern,\n            string = $.string,\n            flags = $.flags\n    var data = str_or_bytes(string, pattern)\n    if(data.type === _b_.str){\n        return $findall(data.pattern, data.string, flags)\n    }else{\n        var res1 = $findall(data.pattern, data.string, flags),\n            res = []\n        for(const item of res1){\n            if(typeof item == \"string\"){\n                res.push(_b_.str.encode(item, \"latin1\"))\n            }else{\n                res.push($B.fast_tuple(item.map(\n                    function(x){return _b_.str.encode(x, 'latin1')})\n                ))\n            }\n        }\n        return res\n    }\n}\n\nfunction $findall(pattern, string, flags){\n    var res = []\n    try{\n        string.matchAll(translate(pattern))\n    }catch(err){\n        console.log(\"error for\", string)\n        throw err\n    }\n    for(const item of string.matchAll(translate(pattern))){\n        /*\n        If one or more groups are present in the pattern, return a list of\n        groups; this will be a list of tuples if the pattern has more than one\n        group\n        */\n        if(item.length == 1){\n            res.push(item[0])\n        }else if(item.length == 2){\n            res.push(item[1])\n        }else{\n            res.push($B.fast_tuple(item.slice(1)))\n        }\n    }\n    return res\n}\n\nfunction match(){\n    var $ = $B.args(\"match\", 3, {pattern: null, string: null, flags: null},\n                    [\"pattern\", \"string\", \"flags\"], arguments, {flags: 0},\n                    null, null),\n            pattern = $.pattern,\n            string = $.string,\n            flags = $.flags\n    var data = str_or_bytes(string, pattern)\n    if(! data.pattern.startsWith('^')){\n        data.pattern = '^' + data.pattern\n    }\n    if(data.type === _b_.str){\n        return $match(data.pattern, data.string, flags)\n    }else{\n        var mo = $match(data.pattern, data.string, flags)\n        if(mo === _b_.None){\n            return mo\n        }\n        to_bytes(mo)\n        return mo\n    }\n}\n\nfunction $match(pattern, string, flags){\n    var js_pattern = translate(pattern),\n        res = string.match(new RegExp(js_pattern))\n    if(res){\n        var mo = MatchObject.$factory(res)\n        mo.string = string\n        mo.start = 0\n        mo.end = res[0].length\n        return mo\n    }else{\n        return _b_.None\n    }\n}\n\nfunction search(){\n    var $ = $B.args(\"search\", 3, {pattern: null, string: null, flags: null},\n                    [\"pattern\", \"string\", \"flags\"], arguments, {flags: 0},\n                    null, null),\n            pattern = $.pattern,\n            string = $.string,\n            flags = $.flags\n    var data = str_or_bytes(string, pattern)\n    if(data.type === _b_.str){\n        return $search(data.pattern, data.string, flags)\n    }else{\n        var mo = $search(data.pattern, data.string, flags)\n        mo.type = _b_.bytes\n        if(mo === _b_.None){\n            return mo\n        }\n        to_bytes(mo)\n        return mo\n    }\n}\n\nfunction $search(pattern, string, flags){\n    var js_pattern = translate(pattern),\n        pos = string.search(new RegExp(js_pattern))\n    if(pos == -1){\n        return _b_.None\n    }else{\n        var mo = $match(pattern, string.substr(pos), flags)\n        mo.string = string\n        mo.start = pos\n        mo.end = pos + mo.res[0].length\n        return mo\n    }\n}\nreturn  {\n    compile: compile,\n    findall: findall,\n    match: match,\n    search: search\n}\n\n})(__BRYTHON__)\n"],
     "builtins": [".js", "var $module = (function(){\n    var obj = {\n        __class__: __BRYTHON__.module,\n        __name__: 'builtins'\n    },\n        builtin_names = ['ArithmeticError', 'AssertionError', 'AttributeError',\n    'BaseException', 'BlockingIOError', 'BrokenPipeError', 'BufferError',\n    'BytesWarning', 'ChildProcessError', 'ConnectionAbortedError',\n    'ConnectionError', 'ConnectionRefusedError', 'ConnectionResetError',\n    'DeprecationWarning', 'EOFError', 'Ellipsis', 'EnvironmentError', 'Exception',\n    'False', 'FileExistsError', 'FileNotFoundError', 'FloatingPointError',\n    'FutureWarning', 'GeneratorExit', 'IOError', 'ImportError', 'ImportWarning',\n    'IndentationError', 'IndexError', 'InterruptedError', 'IsADirectoryError',\n    'KeyError', 'KeyboardInterrupt', 'LookupError', 'MemoryError', 'NameError',\n    'None', 'NotADirectoryError', 'NotImplemented', 'NotImplementedError',\n    'OSError', 'OverflowError', 'PendingDeprecationWarning', 'PermissionError',\n    'ProcessLookupError', 'ReferenceError', 'ResourceWarning', 'RuntimeError',\n    'RuntimeWarning', 'StopIteration', 'SyntaxError', 'SyntaxWarning',\n    'SystemError', 'SystemExit', 'TabError', 'TimeoutError', 'True', 'TypeError',\n    'UnboundLocalError', 'UnicodeDecodeError', 'UnicodeEncodeError',\n    'UnicodeError', 'UnicodeTranslateError', 'UnicodeWarning', 'UserWarning',\n    'ValueError', 'Warning', 'WindowsError', 'ZeroDivisionError', '_',\n    '__build_class__', '__debug__', '__doc__', '__import__', '__name__',\n    '__package__', 'abs', 'all', 'any', 'ascii', 'bin', 'bool', 'bytearray',\n    'bytes','callable', 'chr', 'classmethod', 'compile', 'complex', 'copyright',\n    'credits','delattr', 'dict', 'dir', 'divmod', 'enumerate', 'eval', 'exec',\n    'exit', 'filter', 'float', 'format', 'frozenset', 'getattr', 'globals',\n    'hasattr', 'hash', 'help', 'hex', 'id', 'input', 'int', 'isinstance',\n    'issubclass', 'iter', 'len', 'license', 'list', 'locals', 'map', 'max',\n    'memoryview', 'min', 'next', 'object', 'oct', 'open', 'ord', 'pow', 'print',\n    'property', 'quit', 'range', 'repr', 'reversed', 'round', 'set', 'setattr',\n    'slice', 'sorted', 'staticmethod', 'str', 'sum', 'super', 'tuple', 'type',\n    'vars', 'zip',\n    '__newobj__' // defined in py_objects.js ; required for pickle\n    ]\n    for(var i = 0, len = builtin_names.length; i < len; i++){\n        try{eval(\"obj['\" + builtin_names[i] + \"'] = __BRYTHON__.builtins.\" +\n            builtin_names[i])}\n        catch(err){if (__BRYTHON__.$debug) {console.log(err)}}\n    }\n    return obj\n})()\n"],
     "dis": [".js", "var $module=(function($B){\n\nvar dict = $B.builtins.dict\nvar mod = {\n    dis:function(src){\n        $B.$py_module_path['__main__'] = $B.brython_path\n        return __BRYTHON__.py2js(src,'__main__','__main__',\n            $B.builtins_scope).to_js()\n    },\n    OPTIMIZED: 1,\n    NEWLOCALS: 2,\n    VARARGS: 4,\n    VARKEYWORDS: 8,\n    NESTED: 16,\n    GENERATOR: 32,\n    NOFREE: 64,\n    COROUTINE: 128,\n    ITERABLE_COROUTINE: 256,\n    ASYNC_GENERATOR: 512,\n    COMPILER_FLAG_NAMES: $B.builtins.dict.$factory()\n}\nmod.COMPILER_FLAG_NAMES = dict.$factory([\n     [1, \"OPTIMIZED\"],\n     [2, \"NEWLOCALS\"],\n     [4, \"VARARGS\"],\n     [8, \"VARKEYWORDS\"],\n    [16, \"NESTED\"],\n    [32, \"GENERATOR\"],\n    [64, \"NOFREE\"],\n   [128, \"COROUTINE\"],\n   [256, \"ITERABLE_COROUTINE\"],\n   [512, \"ASYNC_GENERATOR\"]\n])\n\nreturn mod\n\n})(__BRYTHON__)"],
     "encoding_cp932": [".js", "var _table = [0x00, 0x0000,0x01, 0x0001,0x02, 0x0002,0x03, 0x0003,0x04, 0x0004,0x05, 0x0005,0x06, 0x0006,0x07, 0x0007,0x08, 0x0008,0x09, 0x0009,0x0A, 0x000A,0x0B, 0x000B,0x0C, 0x000C,0x0D, 0x000D,0x0E, 0x000E,0x0F, 0x000F,0x10, 0x0010,0x11, 0x0011,0x12, 0x0012,0x13, 0x0013,0x14, 0x0014,0x15, 0x0015,0x16, 0x0016,0x17, 0x0017,0x18, 0x0018,0x19, 0x0019,0x1A, 0x001A,0x1B, 0x001B,0x1C, 0x001C,0x1D, 0x001D,0x1E, 0x001E,0x1F, 0x001F,0x20, 0x0020,0x21, 0x0021,0x22, 0x0022,0x23, 0x0023,0x24, 0x0024,0x25, 0x0025,0x26, 0x0026,0x27, 0x0027,0x28, 0x0028,0x29, 0x0029,0x2A, 0x002A,0x2B, 0x002B,0x2C, 0x002C,0x2D, 0x002D,0x2E, 0x002E,0x2F, 0x002F,0x30, 0x0030,0x31, 0x0031,0x32, 0x0032,0x33, 0x0033,0x34, 0x0034,0x35, 0x0035,0x36, 0x0036,0x37, 0x0037,0x38, 0x0038,0x39, 0x0039,0x3A, 0x003A,0x3B, 0x003B,0x3C, 0x003C,0x3D, 0x003D,0x3E, 0x003E,0x3F, 0x003F,0x40, 0x0040,0x41, 0x0041,0x42, 0x0042,0x43, 0x0043,0x44, 0x0044,0x45, 0x0045,0x46, 0x0046,0x47, 0x0047,0x48, 0x0048,0x49, 0x0049,0x4A, 0x004A,0x4B, 0x004B,0x4C, 0x004C,0x4D, 0x004D,0x4E, 0x004E,0x4F, 0x004F,0x50, 0x0050,0x51, 0x0051,0x52, 0x0052,0x53, 0x0053,0x54, 0x0054,0x55, 0x0055,0x56, 0x0056,0x57, 0x0057,0x58, 0x0058,0x59, 0x0059,0x5A, 0x005A,0x5B, 0x005B,0x5C, 0x005C,0x5D, 0x005D,0x5E, 0x005E,0x5F, 0x005F,0x60, 0x0060,0x61, 0x0061,0x62, 0x0062,0x63, 0x0063,0x64, 0x0064,0x65, 0x0065,0x66, 0x0066,0x67, 0x0067,0x68, 0x0068,0x69, 0x0069,0x6A, 0x006A,0x6B, 0x006B,0x6C, 0x006C,0x6D, 0x006D,0x6E, 0x006E,0x6F, 0x006F,0x70, 0x0070,0x71, 0x0071,0x72, 0x0072,0x73, 0x0073,0x74, 0x0074,0x75, 0x0075,0x76, 0x0076,0x77, 0x0077,0x78, 0x0078,0x79, 0x0079,0x7A, 0x007A,0x7B, 0x007B,0x7C, 0x007C,0x7D, 0x007D,0x7E, 0x007E,0x7F, 0x007F,0x80, -1,0x81, -1,0x82, -1,0x83, -1,0x84, -1,0x85, -1,0x86, -1,0x87, -1,0x88, -1,0x89, -1,0x8A, -1,0x8B, -1,0x8C, -1,0x8D, -1,0x8E, -1,0x8F, -1,0x90, -1,0x91, -1,0x92, -1,0x93, -1,0x94, -1,0x95, -1,0x96, -1,0x97, -1,0x98, -1,0x99, -1,0x9A, -1,0x9B, -1,0x9C, -1,0x9D, -1,0x9E, -1,0x9F, -1,0xA0, -1,0xA1, 0xFF61,0xA2, 0xFF62,0xA3, 0xFF63,0xA4, 0xFF64,0xA5, 0xFF65,0xA6, 0xFF66,0xA7, 0xFF67,0xA8, 0xFF68,0xA9, 0xFF69,0xAA, 0xFF6A,0xAB, 0xFF6B,0xAC, 0xFF6C,0xAD, 0xFF6D,0xAE, 0xFF6E,0xAF, 0xFF6F,0xB0, 0xFF70,0xB1, 0xFF71,0xB2, 0xFF72,0xB3, 0xFF73,0xB4, 0xFF74,0xB5, 0xFF75,0xB6, 0xFF76,0xB7, 0xFF77,0xB8, 0xFF78,0xB9, 0xFF79,0xBA, 0xFF7A,0xBB, 0xFF7B,0xBC, 0xFF7C,0xBD, 0xFF7D,0xBE, 0xFF7E,0xBF, 0xFF7F,0xC0, 0xFF80,0xC1, 0xFF81,0xC2, 0xFF82,0xC3, 0xFF83,0xC4, 0xFF84,0xC5, 0xFF85,0xC6, 0xFF86,0xC7, 0xFF87,0xC8, 0xFF88,0xC9, 0xFF89,0xCA, 0xFF8A,0xCB, 0xFF8B,0xCC, 0xFF8C,0xCD, 0xFF8D,0xCE, 0xFF8E,0xCF, 0xFF8F,0xD0, 0xFF90,0xD1, 0xFF91,0xD2, 0xFF92,0xD3, 0xFF93,0xD4, 0xFF94,0xD5, 0xFF95,0xD6, 0xFF96,0xD7, 0xFF97,0xD8, 0xFF98,0xD9, 0xFF99,0xDA, 0xFF9A,0xDB, 0xFF9B,0xDC, 0xFF9C,0xDD, 0xFF9D,0xDE, 0xFF9E,0xDF, 0xFF9F,0xE0, -1,0xE1, -1,0xE2, -1,0xE3, -1,0xE4, -1,0xE5, -1,0xE6, -1,0xE7, -1,0xE8, -1,0xE9, -1,0xEA, -1,0xEB, -1,0xEC, -1,0xED, -1,0xEE, -1,0xEF, -1,0xF0, -1,0xF1, -1,0xF2, -1,0xF3, -1,0xF4, -1,0xF5, -1,0xF6, -1,0xF7, -1,0xF8, -1,0xF9, -1,0xFA, -1,0xFB, -1,0xFC, -1,0xFD, -1,0xFE, -1,0xFF, -1,0x8140, 0x3000,0x8141, 0x3001,0x8142, 0x3002,0x8143, 0xFF0C,0x8144, 0xFF0E,0x8145, 0x30FB,0x8146, 0xFF1A,0x8147, 0xFF1B,0x8148, 0xFF1F,0x8149, 0xFF01,0x814A, 0x309B,0x814B, 0x309C,0x814C, 0x00B4,0x814D, 0xFF40,0x814E, 0x00A8,0x814F, 0xFF3E,0x8150, 0xFFE3,0x8151, 0xFF3F,0x8152, 0x30FD,0x8153, 0x30FE,0x8154, 0x309D,0x8155, 0x309E,0x8156, 0x3003,0x8157, 0x4EDD,0x8158, 0x3005,0x8159, 0x3006,0x815A, 0x3007,0x815B, 0x30FC,0x815C, 0x2015,0x815D, 0x2010,0x815E, 0xFF0F,0x815F, 0xFF3C,0x8160, 0xFF5E,0x8161, 0x2225,0x8162, 0xFF5C,0x8163, 0x2026,0x8164, 0x2025,0x8165, 0x2018,0x8166, 0x2019,0x8167, 0x201C,0x8168, 0x201D,0x8169, 0xFF08,0x816A, 0xFF09,0x816B, 0x3014,0x816C, 0x3015,0x816D, 0xFF3B,0x816E, 0xFF3D,0x816F, 0xFF5B,0x8170, 0xFF5D,0x8171, 0x3008,0x8172, 0x3009,0x8173, 0x300A,0x8174, 0x300B,0x8175, 0x300C,0x8176, 0x300D,0x8177, 0x300E,0x8178, 0x300F,0x8179, 0x3010,0x817A, 0x3011,0x817B, 0xFF0B,0x817C, 0xFF0D,0x817D, 0x00B1,0x817E, 0x00D7,0x8180, 0x00F7,0x8181, 0xFF1D,0x8182, 0x2260,0x8183, 0xFF1C,0x8184, 0xFF1E,0x8185, 0x2266,0x8186, 0x2267,0x8187, 0x221E,0x8188, 0x2234,0x8189, 0x2642,0x818A, 0x2640,0x818B, 0x00B0,0x818C, 0x2032,0x818D, 0x2033,0x818E, 0x2103,0x818F, 0xFFE5,0x8190, 0xFF04,0x8191, 0xFFE0,0x8192, 0xFFE1,0x8193, 0xFF05,0x8194, 0xFF03,0x8195, 0xFF06,0x8196, 0xFF0A,0x8197, 0xFF20,0x8198, 0x00A7,0x8199, 0x2606,0x819A, 0x2605,0x819B, 0x25CB,0x819C, 0x25CF,0x819D, 0x25CE,0x819E, 0x25C7,0x819F, 0x25C6,0x81A0, 0x25A1,0x81A1, 0x25A0,0x81A2, 0x25B3,0x81A3, 0x25B2,0x81A4, 0x25BD,0x81A5, 0x25BC,0x81A6, 0x203B,0x81A7, 0x3012,0x81A8, 0x2192,0x81A9, 0x2190,0x81AA, 0x2191,0x81AB, 0x2193,0x81AC, 0x3013,0x81B8, 0x2208,0x81B9, 0x220B,0x81BA, 0x2286,0x81BB, 0x2287,0x81BC, 0x2282,0x81BD, 0x2283,0x81BE, 0x222A,0x81BF, 0x2229,0x81C8, 0x2227,0x81C9, 0x2228,0x81CA, 0xFFE2,0x81CB, 0x21D2,0x81CC, 0x21D4,0x81CD, 0x2200,0x81CE, 0x2203,0x81DA, 0x2220,0x81DB, 0x22A5,0x81DC, 0x2312,0x81DD, 0x2202,0x81DE, 0x2207,0x81DF, 0x2261,0x81E0, 0x2252,0x81E1, 0x226A,0x81E2, 0x226B,0x81E3, 0x221A,0x81E4, 0x223D,0x81E5, 0x221D,0x81E6, 0x2235,0x81E7, 0x222B,0x81E8, 0x222C,0x81F0, 0x212B,0x81F1, 0x2030,0x81F2, 0x266F,0x81F3, 0x266D,0x81F4, 0x266A,0x81F5, 0x2020,0x81F6, 0x2021,0x81F7, 0x00B6,0x81FC, 0x25EF,0x824F, 0xFF10,0x8250, 0xFF11,0x8251, 0xFF12,0x8252, 0xFF13,0x8253, 0xFF14,0x8254, 0xFF15,0x8255, 0xFF16,0x8256, 0xFF17,0x8257, 0xFF18,0x8258, 0xFF19,0x8260, 0xFF21,0x8261, 0xFF22,0x8262, 0xFF23,0x8263, 0xFF24,0x8264, 0xFF25,0x8265, 0xFF26,0x8266, 0xFF27,0x8267, 0xFF28,0x8268, 0xFF29,0x8269, 0xFF2A,0x826A, 0xFF2B,0x826B, 0xFF2C,0x826C, 0xFF2D,0x826D, 0xFF2E,0x826E, 0xFF2F,0x826F, 0xFF30,0x8270, 0xFF31,0x8271, 0xFF32,0x8272, 0xFF33,0x8273, 0xFF34,0x8274, 0xFF35,0x8275, 0xFF36,0x8276, 0xFF37,0x8277, 0xFF38,0x8278, 0xFF39,0x8279, 0xFF3A,0x8281, 0xFF41,0x8282, 0xFF42,0x8283, 0xFF43,0x8284, 0xFF44,0x8285, 0xFF45,0x8286, 0xFF46,0x8287, 0xFF47,0x8288, 0xFF48,0x8289, 0xFF49,0x828A, 0xFF4A,0x828B, 0xFF4B,0x828C, 0xFF4C,0x828D, 0xFF4D,0x828E, 0xFF4E,0x828F, 0xFF4F,0x8290, 0xFF50,0x8291, 0xFF51,0x8292, 0xFF52,0x8293, 0xFF53,0x8294, 0xFF54,0x8295, 0xFF55,0x8296, 0xFF56,0x8297, 0xFF57,0x8298, 0xFF58,0x8299, 0xFF59,0x829A, 0xFF5A,0x829F, 0x3041,0x82A0, 0x3042,0x82A1, 0x3043,0x82A2, 0x3044,0x82A3, 0x3045,0x82A4, 0x3046,0x82A5, 0x3047,0x82A6, 0x3048,0x82A7, 0x3049,0x82A8, 0x304A,0x82A9, 0x304B,0x82AA, 0x304C,0x82AB, 0x304D,0x82AC, 0x304E,0x82AD, 0x304F,0x82AE, 0x3050,0x82AF, 0x3051,0x82B0, 0x3052,0x82B1, 0x3053,0x82B2, 0x3054,0x82B3, 0x3055,0x82B4, 0x3056,0x82B5, 0x3057,0x82B6, 0x3058,0x82B7, 0x3059,0x82B8, 0x305A,0x82B9, 0x305B,0x82BA, 0x305C,0x82BB, 0x305D,0x82BC, 0x305E,0x82BD, 0x305F,0x82BE, 0x3060,0x82BF, 0x3061,0x82C0, 0x3062,0x82C1, 0x3063,0x82C2, 0x3064,0x82C3, 0x3065,0x82C4, 0x3066,0x82C5, 0x3067,0x82C6, 0x3068,0x82C7, 0x3069,0x82C8, 0x306A,0x82C9, 0x306B,0x82CA, 0x306C,0x82CB, 0x306D,0x82CC, 0x306E,0x82CD, 0x306F,0x82CE, 0x3070,0x82CF, 0x3071,0x82D0, 0x3072,0x82D1, 0x3073,0x82D2, 0x3074,0x82D3, 0x3075,0x82D4, 0x3076,0x82D5, 0x3077,0x82D6, 0x3078,0x82D7, 0x3079,0x82D8, 0x307A,0x82D9, 0x307B,0x82DA, 0x307C,0x82DB, 0x307D,0x82DC, 0x307E,0x82DD, 0x307F,0x82DE, 0x3080,0x82DF, 0x3081,0x82E0, 0x3082,0x82E1, 0x3083,0x82E2, 0x3084,0x82E3, 0x3085,0x82E4, 0x3086,0x82E5, 0x3087,0x82E6, 0x3088,0x82E7, 0x3089,0x82E8, 0x308A,0x82E9, 0x308B,0x82EA, 0x308C,0x82EB, 0x308D,0x82EC, 0x308E,0x82ED, 0x308F,0x82EE, 0x3090,0x82EF, 0x3091,0x82F0, 0x3092,0x82F1, 0x3093,0x8340, 0x30A1,0x8341, 0x30A2,0x8342, 0x30A3,0x8343, 0x30A4,0x8344, 0x30A5,0x8345, 0x30A6,0x8346, 0x30A7,0x8347, 0x30A8,0x8348, 0x30A9,0x8349, 0x30AA,0x834A, 0x30AB,0x834B, 0x30AC,0x834C, 0x30AD,0x834D, 0x30AE,0x834E, 0x30AF,0x834F, 0x30B0,0x8350, 0x30B1,0x8351, 0x30B2,0x8352, 0x30B3,0x8353, 0x30B4,0x8354, 0x30B5,0x8355, 0x30B6,0x8356, 0x30B7,0x8357, 0x30B8,0x8358, 0x30B9,0x8359, 0x30BA,0x835A, 0x30BB,0x835B, 0x30BC,0x835C, 0x30BD,0x835D, 0x30BE,0x835E, 0x30BF,0x835F, 0x30C0,0x8360, 0x30C1,0x8361, 0x30C2,0x8362, 0x30C3,0x8363, 0x30C4,0x8364, 0x30C5,0x8365, 0x30C6,0x8366, 0x30C7,0x8367, 0x30C8,0x8368, 0x30C9,0x8369, 0x30CA,0x836A, 0x30CB,0x836B, 0x30CC,0x836C, 0x30CD,0x836D, 0x30CE,0x836E, 0x30CF,0x836F, 0x30D0,0x8370, 0x30D1,0x8371, 0x30D2,0x8372, 0x30D3,0x8373, 0x30D4,0x8374, 0x30D5,0x8375, 0x30D6,0x8376, 0x30D7,0x8377, 0x30D8,0x8378, 0x30D9,0x8379, 0x30DA,0x837A, 0x30DB,0x837B, 0x30DC,0x837C, 0x30DD,0x837D, 0x30DE,0x837E, 0x30DF,0x8380, 0x30E0,0x8381, 0x30E1,0x8382, 0x30E2,0x8383, 0x30E3,0x8384, 0x30E4,0x8385, 0x30E5,0x8386, 0x30E6,0x8387, 0x30E7,0x8388, 0x30E8,0x8389, 0x30E9,0x838A, 0x30EA,0x838B, 0x30EB,0x838C, 0x30EC,0x838D, 0x30ED,0x838E, 0x30EE,0x838F, 0x30EF,0x8390, 0x30F0,0x8391, 0x30F1,0x8392, 0x30F2,0x8393, 0x30F3,0x8394, 0x30F4,0x8395, 0x30F5,0x8396, 0x30F6,0x839F, 0x0391,0x83A0, 0x0392,0x83A1, 0x0393,0x83A2, 0x0394,0x83A3, 0x0395,0x83A4, 0x0396,0x83A5, 0x0397,0x83A6, 0x0398,0x83A7, 0x0399,0x83A8, 0x039A,0x83A9, 0x039B,0x83AA, 0x039C,0x83AB, 0x039D,0x83AC, 0x039E,0x83AD, 0x039F,0x83AE, 0x03A0,0x83AF, 0x03A1,0x83B0, 0x03A3,0x83B1, 0x03A4,0x83B2, 0x03A5,0x83B3, 0x03A6,0x83B4, 0x03A7,0x83B5, 0x03A8,0x83B6, 0x03A9,0x83BF, 0x03B1,0x83C0, 0x03B2,0x83C1, 0x03B3,0x83C2, 0x03B4,0x83C3, 0x03B5,0x83C4, 0x03B6,0x83C5, 0x03B7,0x83C6, 0x03B8,0x83C7, 0x03B9,0x83C8, 0x03BA,0x83C9, 0x03BB,0x83CA, 0x03BC,0x83CB, 0x03BD,0x83CC, 0x03BE,0x83CD, 0x03BF,0x83CE, 0x03C0,0x83CF, 0x03C1,0x83D0, 0x03C3,0x83D1, 0x03C4,0x83D2, 0x03C5,0x83D3, 0x03C6,0x83D4, 0x03C7,0x83D5, 0x03C8,0x83D6, 0x03C9,0x8440, 0x0410,0x8441, 0x0411,0x8442, 0x0412,0x8443, 0x0413,0x8444, 0x0414,0x8445, 0x0415,0x8446, 0x0401,0x8447, 0x0416,0x8448, 0x0417,0x8449, 0x0418,0x844A, 0x0419,0x844B, 0x041A,0x844C, 0x041B,0x844D, 0x041C,0x844E, 0x041D,0x844F, 0x041E,0x8450, 0x041F,0x8451, 0x0420,0x8452, 0x0421,0x8453, 0x0422,0x8454, 0x0423,0x8455, 0x0424,0x8456, 0x0425,0x8457, 0x0426,0x8458, 0x0427,0x8459, 0x0428,0x845A, 0x0429,0x845B, 0x042A,0x845C, 0x042B,0x845D, 0x042C,0x845E, 0x042D,0x845F, 0x042E,0x8460, 0x042F,0x8470, 0x0430,0x8471, 0x0431,0x8472, 0x0432,0x8473, 0x0433,0x8474, 0x0434,0x8475, 0x0435,0x8476, 0x0451,0x8477, 0x0436,0x8478, 0x0437,0x8479, 0x0438,0x847A, 0x0439,0x847B, 0x043A,0x847C, 0x043B,0x847D, 0x043C,0x847E, 0x043D,0x8480, 0x043E,0x8481, 0x043F,0x8482, 0x0440,0x8483, 0x0441,0x8484, 0x0442,0x8485, 0x0443,0x8486, 0x0444,0x8487, 0x0445,0x8488, 0x0446,0x8489, 0x0447,0x848A, 0x0448,0x848B, 0x0449,0x848C, 0x044A,0x848D, 0x044B,0x848E, 0x044C,0x848F, 0x044D,0x8490, 0x044E,0x8491, 0x044F,0x849F, 0x2500,0x84A0, 0x2502,0x84A1, 0x250C,0x84A2, 0x2510,0x84A3, 0x2518,0x84A4, 0x2514,0x84A5, 0x251C,0x84A6, 0x252C,0x84A7, 0x2524,0x84A8, 0x2534,0x84A9, 0x253C,0x84AA, 0x2501,0x84AB, 0x2503,0x84AC, 0x250F,0x84AD, 0x2513,0x84AE, 0x251B,0x84AF, 0x2517,0x84B0, 0x2523,0x84B1, 0x2533,0x84B2, 0x252B,0x84B3, 0x253B,0x84B4, 0x254B,0x84B5, 0x2520,0x84B6, 0x252F,0x84B7, 0x2528,0x84B8, 0x2537,0x84B9, 0x253F,0x84BA, 0x251D,0x84BB, 0x2530,0x84BC, 0x2525,0x84BD, 0x2538,0x84BE, 0x2542,0x8740, 0x2460,0x8741, 0x2461,0x8742, 0x2462,0x8743, 0x2463,0x8744, 0x2464,0x8745, 0x2465,0x8746, 0x2466,0x8747, 0x2467,0x8748, 0x2468,0x8749, 0x2469,0x874A, 0x246A,0x874B, 0x246B,0x874C, 0x246C,0x874D, 0x246D,0x874E, 0x246E,0x874F, 0x246F,0x8750, 0x2470,0x8751, 0x2471,0x8752, 0x2472,0x8753, 0x2473,0x8754, 0x2160,0x8755, 0x2161,0x8756, 0x2162,0x8757, 0x2163,0x8758, 0x2164,0x8759, 0x2165,0x875A, 0x2166,0x875B, 0x2167,0x875C, 0x2168,0x875D, 0x2169,0x875F, 0x3349,0x8760, 0x3314,0x8761, 0x3322,0x8762, 0x334D,0x8763, 0x3318,0x8764, 0x3327,0x8765, 0x3303,0x8766, 0x3336,0x8767, 0x3351,0x8768, 0x3357,0x8769, 0x330D,0x876A, 0x3326,0x876B, 0x3323,0x876C, 0x332B,0x876D, 0x334A,0x876E, 0x333B,0x876F, 0x339C,0x8770, 0x339D,0x8771, 0x339E,0x8772, 0x338E,0x8773, 0x338F,0x8774, 0x33C4,0x8775, 0x33A1,0x877E, 0x337B,0x8780, 0x301D,0x8781, 0x301F,0x8782, 0x2116,0x8783, 0x33CD,0x8784, 0x2121,0x8785, 0x32A4,0x8786, 0x32A5,0x8787, 0x32A6,0x8788, 0x32A7,0x8789, 0x32A8,0x878A, 0x3231,0x878B, 0x3232,0x878C, 0x3239,0x878D, 0x337E,0x878E, 0x337D,0x878F, 0x337C,0x8790, 0x2252,0x8791, 0x2261,0x8792, 0x222B,0x8793, 0x222E,0x8794, 0x2211,0x8795, 0x221A,0x8796, 0x22A5,0x8797, 0x2220,0x8798, 0x221F,0x8799, 0x22BF,0x879A, 0x2235,0x879B, 0x2229,0x879C, 0x222A,0x889F, 0x4E9C,0x88A0, 0x5516,0x88A1, 0x5A03,0x88A2, 0x963F,0x88A3, 0x54C0,0x88A4, 0x611B,0x88A5, 0x6328,0x88A6, 0x59F6,0x88A7, 0x9022,0x88A8, 0x8475,0x88A9, 0x831C,0x88AA, 0x7A50,0x88AB, 0x60AA,0x88AC, 0x63E1,0x88AD, 0x6E25,0x88AE, 0x65ED,0x88AF, 0x8466,0x88B0, 0x82A6,0x88B1, 0x9BF5,0x88B2, 0x6893,0x88B3, 0x5727,0x88B4, 0x65A1,0x88B5, 0x6271,0x88B6, 0x5B9B,0x88B7, 0x59D0,0x88B8, 0x867B,0x88B9, 0x98F4,0x88BA, 0x7D62,0x88BB, 0x7DBE,0x88BC, 0x9B8E,0x88BD, 0x6216,0x88BE, 0x7C9F,0x88BF, 0x88B7,0x88C0, 0x5B89,0x88C1, 0x5EB5,0x88C2, 0x6309,0x88C3, 0x6697,0x88C4, 0x6848,0x88C5, 0x95C7,0x88C6, 0x978D,0x88C7, 0x674F,0x88C8, 0x4EE5,0x88C9, 0x4F0A,0x88CA, 0x4F4D,0x88CB, 0x4F9D,0x88CC, 0x5049,0x88CD, 0x56F2,0x88CE, 0x5937,0x88CF, 0x59D4,0x88D0, 0x5A01,0x88D1, 0x5C09,0x88D2, 0x60DF,0x88D3, 0x610F,0x88D4, 0x6170,0x88D5, 0x6613,0x88D6, 0x6905,0x88D7, 0x70BA,0x88D8, 0x754F,0x88D9, 0x7570,0x88DA, 0x79FB,0x88DB, 0x7DAD,0x88DC, 0x7DEF,0x88DD, 0x80C3,0x88DE, 0x840E,0x88DF, 0x8863,0x88E0, 0x8B02,0x88E1, 0x9055,0x88E2, 0x907A,0x88E3, 0x533B,0x88E4, 0x4E95,0x88E5, 0x4EA5,0x88E6, 0x57DF,0x88E7, 0x80B2,0x88E8, 0x90C1,0x88E9, 0x78EF,0x88EA, 0x4E00,0x88EB, 0x58F1,0x88EC, 0x6EA2,0x88ED, 0x9038,0x88EE, 0x7A32,0x88EF, 0x8328,0x88F0, 0x828B,0x88F1, 0x9C2F,0x88F2, 0x5141,0x88F3, 0x5370,0x88F4, 0x54BD,0x88F5, 0x54E1,0x88F6, 0x56E0,0x88F7, 0x59FB,0x88F8, 0x5F15,0x88F9, 0x98F2,0x88FA, 0x6DEB,0x88FB, 0x80E4,0x88FC, 0x852D,0x8940, 0x9662,0x8941, 0x9670,0x8942, 0x96A0,0x8943, 0x97FB,0x8944, 0x540B,0x8945, 0x53F3,0x8946, 0x5B87,0x8947, 0x70CF,0x8948, 0x7FBD,0x8949, 0x8FC2,0x894A, 0x96E8,0x894B, 0x536F,0x894C, 0x9D5C,0x894D, 0x7ABA,0x894E, 0x4E11,0x894F, 0x7893,0x8950, 0x81FC,0x8951, 0x6E26,0x8952, 0x5618,0x8953, 0x5504,0x8954, 0x6B1D,0x8955, 0x851A,0x8956, 0x9C3B,0x8957, 0x59E5,0x8958, 0x53A9,0x8959, 0x6D66,0x895A, 0x74DC,0x895B, 0x958F,0x895C, 0x5642,0x895D, 0x4E91,0x895E, 0x904B,0x895F, 0x96F2,0x8960, 0x834F,0x8961, 0x990C,0x8962, 0x53E1,0x8963, 0x55B6,0x8964, 0x5B30,0x8965, 0x5F71,0x8966, 0x6620,0x8967, 0x66F3,0x8968, 0x6804,0x8969, 0x6C38,0x896A, 0x6CF3,0x896B, 0x6D29,0x896C, 0x745B,0x896D, 0x76C8,0x896E, 0x7A4E,0x896F, 0x9834,0x8970, 0x82F1,0x8971, 0x885B,0x8972, 0x8A60,0x8973, 0x92ED,0x8974, 0x6DB2,0x8975, 0x75AB,0x8976, 0x76CA,0x8977, 0x99C5,0x8978, 0x60A6,0x8979, 0x8B01,0x897A, 0x8D8A,0x897B, 0x95B2,0x897C, 0x698E,0x897D, 0x53AD,0x897E, 0x5186,0x8980, 0x5712,0x8981, 0x5830,0x8982, 0x5944,0x8983, 0x5BB4,0x8984, 0x5EF6,0x8985, 0x6028,0x8986, 0x63A9,0x8987, 0x63F4,0x8988, 0x6CBF,0x8989, 0x6F14,0x898A, 0x708E,0x898B, 0x7114,0x898C, 0x7159,0x898D, 0x71D5,0x898E, 0x733F,0x898F, 0x7E01,0x8990, 0x8276,0x8991, 0x82D1,0x8992, 0x8597,0x8993, 0x9060,0x8994, 0x925B,0x8995, 0x9D1B,0x8996, 0x5869,0x8997, 0x65BC,0x8998, 0x6C5A,0x8999, 0x7525,0x899A, 0x51F9,0x899B, 0x592E,0x899C, 0x5965,0x899D, 0x5F80,0x899E, 0x5FDC,0x899F, 0x62BC,0x89A0, 0x65FA,0x89A1, 0x6A2A,0x89A2, 0x6B27,0x89A3, 0x6BB4,0x89A4, 0x738B,0x89A5, 0x7FC1,0x89A6, 0x8956,0x89A7, 0x9D2C,0x89A8, 0x9D0E,0x89A9, 0x9EC4,0x89AA, 0x5CA1,0x89AB, 0x6C96,0x89AC, 0x837B,0x89AD, 0x5104,0x89AE, 0x5C4B,0x89AF, 0x61B6,0x89B0, 0x81C6,0x89B1, 0x6876,0x89B2, 0x7261,0x89B3, 0x4E59,0x89B4, 0x4FFA,0x89B5, 0x5378,0x89B6, 0x6069,0x89B7, 0x6E29,0x89B8, 0x7A4F,0x89B9, 0x97F3,0x89BA, 0x4E0B,0x89BB, 0x5316,0x89BC, 0x4EEE,0x89BD, 0x4F55,0x89BE, 0x4F3D,0x89BF, 0x4FA1,0x89C0, 0x4F73,0x89C1, 0x52A0,0x89C2, 0x53EF,0x89C3, 0x5609,0x89C4, 0x590F,0x89C5, 0x5AC1,0x89C6, 0x5BB6,0x89C7, 0x5BE1,0x89C8, 0x79D1,0x89C9, 0x6687,0x89CA, 0x679C,0x89CB, 0x67B6,0x89CC, 0x6B4C,0x89CD, 0x6CB3,0x89CE, 0x706B,0x89CF, 0x73C2,0x89D0, 0x798D,0x89D1, 0x79BE,0x89D2, 0x7A3C,0x89D3, 0x7B87,0x89D4, 0x82B1,0x89D5, 0x82DB,0x89D6, 0x8304,0x89D7, 0x8377,0x89D8, 0x83EF,0x89D9, 0x83D3,0x89DA, 0x8766,0x89DB, 0x8AB2,0x89DC, 0x5629,0x89DD, 0x8CA8,0x89DE, 0x8FE6,0x89DF, 0x904E,0x89E0, 0x971E,0x89E1, 0x868A,0x89E2, 0x4FC4,0x89E3, 0x5CE8,0x89E4, 0x6211,0x89E5, 0x7259,0x89E6, 0x753B,0x89E7, 0x81E5,0x89E8, 0x82BD,0x89E9, 0x86FE,0x89EA, 0x8CC0,0x89EB, 0x96C5,0x89EC, 0x9913,0x89ED, 0x99D5,0x89EE, 0x4ECB,0x89EF, 0x4F1A,0x89F0, 0x89E3,0x89F1, 0x56DE,0x89F2, 0x584A,0x89F3, 0x58CA,0x89F4, 0x5EFB,0x89F5, 0x5FEB,0x89F6, 0x602A,0x89F7, 0x6094,0x89F8, 0x6062,0x89F9, 0x61D0,0x89FA, 0x6212,0x89FB, 0x62D0,0x89FC, 0x6539,0x8A40, 0x9B41,0x8A41, 0x6666,0x8A42, 0x68B0,0x8A43, 0x6D77,0x8A44, 0x7070,0x8A45, 0x754C,0x8A46, 0x7686,0x8A47, 0x7D75,0x8A48, 0x82A5,0x8A49, 0x87F9,0x8A4A, 0x958B,0x8A4B, 0x968E,0x8A4C, 0x8C9D,0x8A4D, 0x51F1,0x8A4E, 0x52BE,0x8A4F, 0x5916,0x8A50, 0x54B3,0x8A51, 0x5BB3,0x8A52, 0x5D16,0x8A53, 0x6168,0x8A54, 0x6982,0x8A55, 0x6DAF,0x8A56, 0x788D,0x8A57, 0x84CB,0x8A58, 0x8857,0x8A59, 0x8A72,0x8A5A, 0x93A7,0x8A5B, 0x9AB8,0x8A5C, 0x6D6C,0x8A5D, 0x99A8,0x8A5E, 0x86D9,0x8A5F, 0x57A3,0x8A60, 0x67FF,0x8A61, 0x86CE,0x8A62, 0x920E,0x8A63, 0x5283,0x8A64, 0x5687,0x8A65, 0x5404,0x8A66, 0x5ED3,0x8A67, 0x62E1,0x8A68, 0x64B9,0x8A69, 0x683C,0x8A6A, 0x6838,0x8A6B, 0x6BBB,0x8A6C, 0x7372,0x8A6D, 0x78BA,0x8A6E, 0x7A6B,0x8A6F, 0x899A,0x8A70, 0x89D2,0x8A71, 0x8D6B,0x8A72, 0x8F03,0x8A73, 0x90ED,0x8A74, 0x95A3,0x8A75, 0x9694,0x8A76, 0x9769,0x8A77, 0x5B66,0x8A78, 0x5CB3,0x8A79, 0x697D,0x8A7A, 0x984D,0x8A7B, 0x984E,0x8A7C, 0x639B,0x8A7D, 0x7B20,0x8A7E, 0x6A2B,0x8A80, 0x6A7F,0x8A81, 0x68B6,0x8A82, 0x9C0D,0x8A83, 0x6F5F,0x8A84, 0x5272,0x8A85, 0x559D,0x8A86, 0x6070,0x8A87, 0x62EC,0x8A88, 0x6D3B,0x8A89, 0x6E07,0x8A8A, 0x6ED1,0x8A8B, 0x845B,0x8A8C, 0x8910,0x8A8D, 0x8F44,0x8A8E, 0x4E14,0x8A8F, 0x9C39,0x8A90, 0x53F6,0x8A91, 0x691B,0x8A92, 0x6A3A,0x8A93, 0x9784,0x8A94, 0x682A,0x8A95, 0x515C,0x8A96, 0x7AC3,0x8A97, 0x84B2,0x8A98, 0x91DC,0x8A99, 0x938C,0x8A9A, 0x565B,0x8A9B, 0x9D28,0x8A9C, 0x6822,0x8A9D, 0x8305,0x8A9E, 0x8431,0x8A9F, 0x7CA5,0x8AA0, 0x5208,0x8AA1, 0x82C5,0x8AA2, 0x74E6,0x8AA3, 0x4E7E,0x8AA4, 0x4F83,0x8AA5, 0x51A0,0x8AA6, 0x5BD2,0x8AA7, 0x520A,0x8AA8, 0x52D8,0x8AA9, 0x52E7,0x8AAA, 0x5DFB,0x8AAB, 0x559A,0x8AAC, 0x582A,0x8AAD, 0x59E6,0x8AAE, 0x5B8C,0x8AAF, 0x5B98,0x8AB0, 0x5BDB,0x8AB1, 0x5E72,0x8AB2, 0x5E79,0x8AB3, 0x60A3,0x8AB4, 0x611F,0x8AB5, 0x6163,0x8AB6, 0x61BE,0x8AB7, 0x63DB,0x8AB8, 0x6562,0x8AB9, 0x67D1,0x8ABA, 0x6853,0x8ABB, 0x68FA,0x8ABC, 0x6B3E,0x8ABD, 0x6B53,0x8ABE, 0x6C57,0x8ABF, 0x6F22,0x8AC0, 0x6F97,0x8AC1, 0x6F45,0x8AC2, 0x74B0,0x8AC3, 0x7518,0x8AC4, 0x76E3,0x8AC5, 0x770B,0x8AC6, 0x7AFF,0x8AC7, 0x7BA1,0x8AC8, 0x7C21,0x8AC9, 0x7DE9,0x8ACA, 0x7F36,0x8ACB, 0x7FF0,0x8ACC, 0x809D,0x8ACD, 0x8266,0x8ACE, 0x839E,0x8ACF, 0x89B3,0x8AD0, 0x8ACC,0x8AD1, 0x8CAB,0x8AD2, 0x9084,0x8AD3, 0x9451,0x8AD4, 0x9593,0x8AD5, 0x9591,0x8AD6, 0x95A2,0x8AD7, 0x9665,0x8AD8, 0x97D3,0x8AD9, 0x9928,0x8ADA, 0x8218,0x8ADB, 0x4E38,0x8ADC, 0x542B,0x8ADD, 0x5CB8,0x8ADE, 0x5DCC,0x8ADF, 0x73A9,0x8AE0, 0x764C,0x8AE1, 0x773C,0x8AE2, 0x5CA9,0x8AE3, 0x7FEB,0x8AE4, 0x8D0B,0x8AE5, 0x96C1,0x8AE6, 0x9811,0x8AE7, 0x9854,0x8AE8, 0x9858,0x8AE9, 0x4F01,0x8AEA, 0x4F0E,0x8AEB, 0x5371,0x8AEC, 0x559C,0x8AED, 0x5668,0x8AEE, 0x57FA,0x8AEF, 0x5947,0x8AF0, 0x5B09,0x8AF1, 0x5BC4,0x8AF2, 0x5C90,0x8AF3, 0x5E0C,0x8AF4, 0x5E7E,0x8AF5, 0x5FCC,0x8AF6, 0x63EE,0x8AF7, 0x673A,0x8AF8, 0x65D7,0x8AF9, 0x65E2,0x8AFA, 0x671F,0x8AFB, 0x68CB,0x8AFC, 0x68C4,0x8B40, 0x6A5F,0x8B41, 0x5E30,0x8B42, 0x6BC5,0x8B43, 0x6C17,0x8B44, 0x6C7D,0x8B45, 0x757F,0x8B46, 0x7948,0x8B47, 0x5B63,0x8B48, 0x7A00,0x8B49, 0x7D00,0x8B4A, 0x5FBD,0x8B4B, 0x898F,0x8B4C, 0x8A18,0x8B4D, 0x8CB4,0x8B4E, 0x8D77,0x8B4F, 0x8ECC,0x8B50, 0x8F1D,0x8B51, 0x98E2,0x8B52, 0x9A0E,0x8B53, 0x9B3C,0x8B54, 0x4E80,0x8B55, 0x507D,0x8B56, 0x5100,0x8B57, 0x5993,0x8B58, 0x5B9C,0x8B59, 0x622F,0x8B5A, 0x6280,0x8B5B, 0x64EC,0x8B5C, 0x6B3A,0x8B5D, 0x72A0,0x8B5E, 0x7591,0x8B5F, 0x7947,0x8B60, 0x7FA9,0x8B61, 0x87FB,0x8B62, 0x8ABC,0x8B63, 0x8B70,0x8B64, 0x63AC,0x8B65, 0x83CA,0x8B66, 0x97A0,0x8B67, 0x5409,0x8B68, 0x5403,0x8B69, 0x55AB,0x8B6A, 0x6854,0x8B6B, 0x6A58,0x8B6C, 0x8A70,0x8B6D, 0x7827,0x8B6E, 0x6775,0x8B6F, 0x9ECD,0x8B70, 0x5374,0x8B71, 0x5BA2,0x8B72, 0x811A,0x8B73, 0x8650,0x8B74, 0x9006,0x8B75, 0x4E18,0x8B76, 0x4E45,0x8B77, 0x4EC7,0x8B78, 0x4F11,0x8B79, 0x53CA,0x8B7A, 0x5438,0x8B7B, 0x5BAE,0x8B7C, 0x5F13,0x8B7D, 0x6025,0x8B7E, 0x6551,0x8B80, 0x673D,0x8B81, 0x6C42,0x8B82, 0x6C72,0x8B83, 0x6CE3,0x8B84, 0x7078,0x8B85, 0x7403,0x8B86, 0x7A76,0x8B87, 0x7AAE,0x8B88, 0x7B08,0x8B89, 0x7D1A,0x8B8A, 0x7CFE,0x8B8B, 0x7D66,0x8B8C, 0x65E7,0x8B8D, 0x725B,0x8B8E, 0x53BB,0x8B8F, 0x5C45,0x8B90, 0x5DE8,0x8B91, 0x62D2,0x8B92, 0x62E0,0x8B93, 0x6319,0x8B94, 0x6E20,0x8B95, 0x865A,0x8B96, 0x8A31,0x8B97, 0x8DDD,0x8B98, 0x92F8,0x8B99, 0x6F01,0x8B9A, 0x79A6,0x8B9B, 0x9B5A,0x8B9C, 0x4EA8,0x8B9D, 0x4EAB,0x8B9E, 0x4EAC,0x8B9F, 0x4F9B,0x8BA0, 0x4FA0,0x8BA1, 0x50D1,0x8BA2, 0x5147,0x8BA3, 0x7AF6,0x8BA4, 0x5171,0x8BA5, 0x51F6,0x8BA6, 0x5354,0x8BA7, 0x5321,0x8BA8, 0x537F,0x8BA9, 0x53EB,0x8BAA, 0x55AC,0x8BAB, 0x5883,0x8BAC, 0x5CE1,0x8BAD, 0x5F37,0x8BAE, 0x5F4A,0x8BAF, 0x602F,0x8BB0, 0x6050,0x8BB1, 0x606D,0x8BB2, 0x631F,0x8BB3, 0x6559,0x8BB4, 0x6A4B,0x8BB5, 0x6CC1,0x8BB6, 0x72C2,0x8BB7, 0x72ED,0x8BB8, 0x77EF,0x8BB9, 0x80F8,0x8BBA, 0x8105,0x8BBB, 0x8208,0x8BBC, 0x854E,0x8BBD, 0x90F7,0x8BBE, 0x93E1,0x8BBF, 0x97FF,0x8BC0, 0x9957,0x8BC1, 0x9A5A,0x8BC2, 0x4EF0,0x8BC3, 0x51DD,0x8BC4, 0x5C2D,0x8BC5, 0x6681,0x8BC6, 0x696D,0x8BC7, 0x5C40,0x8BC8, 0x66F2,0x8BC9, 0x6975,0x8BCA, 0x7389,0x8BCB, 0x6850,0x8BCC, 0x7C81,0x8BCD, 0x50C5,0x8BCE, 0x52E4,0x8BCF, 0x5747,0x8BD0, 0x5DFE,0x8BD1, 0x9326,0x8BD2, 0x65A4,0x8BD3, 0x6B23,0x8BD4, 0x6B3D,0x8BD5, 0x7434,0x8BD6, 0x7981,0x8BD7, 0x79BD,0x8BD8, 0x7B4B,0x8BD9, 0x7DCA,0x8BDA, 0x82B9,0x8BDB, 0x83CC,0x8BDC, 0x887F,0x8BDD, 0x895F,0x8BDE, 0x8B39,0x8BDF, 0x8FD1,0x8BE0, 0x91D1,0x8BE1, 0x541F,0x8BE2, 0x9280,0x8BE3, 0x4E5D,0x8BE4, 0x5036,0x8BE5, 0x53E5,0x8BE6, 0x533A,0x8BE7, 0x72D7,0x8BE8, 0x7396,0x8BE9, 0x77E9,0x8BEA, 0x82E6,0x8BEB, 0x8EAF,0x8BEC, 0x99C6,0x8BED, 0x99C8,0x8BEE, 0x99D2,0x8BEF, 0x5177,0x8BF0, 0x611A,0x8BF1, 0x865E,0x8BF2, 0x55B0,0x8BF3, 0x7A7A,0x8BF4, 0x5076,0x8BF5, 0x5BD3,0x8BF6, 0x9047,0x8BF7, 0x9685,0x8BF8, 0x4E32,0x8BF9, 0x6ADB,0x8BFA, 0x91E7,0x8BFB, 0x5C51,0x8BFC, 0x5C48,0x8C40, 0x6398,0x8C41, 0x7A9F,0x8C42, 0x6C93,0x8C43, 0x9774,0x8C44, 0x8F61,0x8C45, 0x7AAA,0x8C46, 0x718A,0x8C47, 0x9688,0x8C48, 0x7C82,0x8C49, 0x6817,0x8C4A, 0x7E70,0x8C4B, 0x6851,0x8C4C, 0x936C,0x8C4D, 0x52F2,0x8C4E, 0x541B,0x8C4F, 0x85AB,0x8C50, 0x8A13,0x8C51, 0x7FA4,0x8C52, 0x8ECD,0x8C53, 0x90E1,0x8C54, 0x5366,0x8C55, 0x8888,0x8C56, 0x7941,0x8C57, 0x4FC2,0x8C58, 0x50BE,0x8C59, 0x5211,0x8C5A, 0x5144,0x8C5B, 0x5553,0x8C5C, 0x572D,0x8C5D, 0x73EA,0x8C5E, 0x578B,0x8C5F, 0x5951,0x8C60, 0x5F62,0x8C61, 0x5F84,0x8C62, 0x6075,0x8C63, 0x6176,0x8C64, 0x6167,0x8C65, 0x61A9,0x8C66, 0x63B2,0x8C67, 0x643A,0x8C68, 0x656C,0x8C69, 0x666F,0x8C6A, 0x6842,0x8C6B, 0x6E13,0x8C6C, 0x7566,0x8C6D, 0x7A3D,0x8C6E, 0x7CFB,0x8C6F, 0x7D4C,0x8C70, 0x7D99,0x8C71, 0x7E4B,0x8C72, 0x7F6B,0x8C73, 0x830E,0x8C74, 0x834A,0x8C75, 0x86CD,0x8C76, 0x8A08,0x8C77, 0x8A63,0x8C78, 0x8B66,0x8C79, 0x8EFD,0x8C7A, 0x981A,0x8C7B, 0x9D8F,0x8C7C, 0x82B8,0x8C7D, 0x8FCE,0x8C7E, 0x9BE8,0x8C80, 0x5287,0x8C81, 0x621F,0x8C82, 0x6483,0x8C83, 0x6FC0,0x8C84, 0x9699,0x8C85, 0x6841,0x8C86, 0x5091,0x8C87, 0x6B20,0x8C88, 0x6C7A,0x8C89, 0x6F54,0x8C8A, 0x7A74,0x8C8B, 0x7D50,0x8C8C, 0x8840,0x8C8D, 0x8A23,0x8C8E, 0x6708,0x8C8F, 0x4EF6,0x8C90, 0x5039,0x8C91, 0x5026,0x8C92, 0x5065,0x8C93, 0x517C,0x8C94, 0x5238,0x8C95, 0x5263,0x8C96, 0x55A7,0x8C97, 0x570F,0x8C98, 0x5805,0x8C99, 0x5ACC,0x8C9A, 0x5EFA,0x8C9B, 0x61B2,0x8C9C, 0x61F8,0x8C9D, 0x62F3,0x8C9E, 0x6372,0x8C9F, 0x691C,0x8CA0, 0x6A29,0x8CA1, 0x727D,0x8CA2, 0x72AC,0x8CA3, 0x732E,0x8CA4, 0x7814,0x8CA5, 0x786F,0x8CA6, 0x7D79,0x8CA7, 0x770C,0x8CA8, 0x80A9,0x8CA9, 0x898B,0x8CAA, 0x8B19,0x8CAB, 0x8CE2,0x8CAC, 0x8ED2,0x8CAD, 0x9063,0x8CAE, 0x9375,0x8CAF, 0x967A,0x8CB0, 0x9855,0x8CB1, 0x9A13,0x8CB2, 0x9E78,0x8CB3, 0x5143,0x8CB4, 0x539F,0x8CB5, 0x53B3,0x8CB6, 0x5E7B,0x8CB7, 0x5F26,0x8CB8, 0x6E1B,0x8CB9, 0x6E90,0x8CBA, 0x7384,0x8CBB, 0x73FE,0x8CBC, 0x7D43,0x8CBD, 0x8237,0x8CBE, 0x8A00,0x8CBF, 0x8AFA,0x8CC0, 0x9650,0x8CC1, 0x4E4E,0x8CC2, 0x500B,0x8CC3, 0x53E4,0x8CC4, 0x547C,0x8CC5, 0x56FA,0x8CC6, 0x59D1,0x8CC7, 0x5B64,0x8CC8, 0x5DF1,0x8CC9, 0x5EAB,0x8CCA, 0x5F27,0x8CCB, 0x6238,0x8CCC, 0x6545,0x8CCD, 0x67AF,0x8CCE, 0x6E56,0x8CCF, 0x72D0,0x8CD0, 0x7CCA,0x8CD1, 0x88B4,0x8CD2, 0x80A1,0x8CD3, 0x80E1,0x8CD4, 0x83F0,0x8CD5, 0x864E,0x8CD6, 0x8A87,0x8CD7, 0x8DE8,0x8CD8, 0x9237,0x8CD9, 0x96C7,0x8CDA, 0x9867,0x8CDB, 0x9F13,0x8CDC, 0x4E94,0x8CDD, 0x4E92,0x8CDE, 0x4F0D,0x8CDF, 0x5348,0x8CE0, 0x5449,0x8CE1, 0x543E,0x8CE2, 0x5A2F,0x8CE3, 0x5F8C,0x8CE4, 0x5FA1,0x8CE5, 0x609F,0x8CE6, 0x68A7,0x8CE7, 0x6A8E,0x8CE8, 0x745A,0x8CE9, 0x7881,0x8CEA, 0x8A9E,0x8CEB, 0x8AA4,0x8CEC, 0x8B77,0x8CED, 0x9190,0x8CEE, 0x4E5E,0x8CEF, 0x9BC9,0x8CF0, 0x4EA4,0x8CF1, 0x4F7C,0x8CF2, 0x4FAF,0x8CF3, 0x5019,0x8CF4, 0x5016,0x8CF5, 0x5149,0x8CF6, 0x516C,0x8CF7, 0x529F,0x8CF8, 0x52B9,0x8CF9, 0x52FE,0x8CFA, 0x539A,0x8CFB, 0x53E3,0x8CFC, 0x5411,0x8D40, 0x540E,0x8D41, 0x5589,0x8D42, 0x5751,0x8D43, 0x57A2,0x8D44, 0x597D,0x8D45, 0x5B54,0x8D46, 0x5B5D,0x8D47, 0x5B8F,0x8D48, 0x5DE5,0x8D49, 0x5DE7,0x8D4A, 0x5DF7,0x8D4B, 0x5E78,0x8D4C, 0x5E83,0x8D4D, 0x5E9A,0x8D4E, 0x5EB7,0x8D4F, 0x5F18,0x8D50, 0x6052,0x8D51, 0x614C,0x8D52, 0x6297,0x8D53, 0x62D8,0x8D54, 0x63A7,0x8D55, 0x653B,0x8D56, 0x6602,0x8D57, 0x6643,0x8D58, 0x66F4,0x8D59, 0x676D,0x8D5A, 0x6821,0x8D5B, 0x6897,0x8D5C, 0x69CB,0x8D5D, 0x6C5F,0x8D5E, 0x6D2A,0x8D5F, 0x6D69,0x8D60, 0x6E2F,0x8D61, 0x6E9D,0x8D62, 0x7532,0x8D63, 0x7687,0x8D64, 0x786C,0x8D65, 0x7A3F,0x8D66, 0x7CE0,0x8D67, 0x7D05,0x8D68, 0x7D18,0x8D69, 0x7D5E,0x8D6A, 0x7DB1,0x8D6B, 0x8015,0x8D6C, 0x8003,0x8D6D, 0x80AF,0x8D6E, 0x80B1,0x8D6F, 0x8154,0x8D70, 0x818F,0x8D71, 0x822A,0x8D72, 0x8352,0x8D73, 0x884C,0x8D74, 0x8861,0x8D75, 0x8B1B,0x8D76, 0x8CA2,0x8D77, 0x8CFC,0x8D78, 0x90CA,0x8D79, 0x9175,0x8D7A, 0x9271,0x8D7B, 0x783F,0x8D7C, 0x92FC,0x8D7D, 0x95A4,0x8D7E, 0x964D,0x8D80, 0x9805,0x8D81, 0x9999,0x8D82, 0x9AD8,0x8D83, 0x9D3B,0x8D84, 0x525B,0x8D85, 0x52AB,0x8D86, 0x53F7,0x8D87, 0x5408,0x8D88, 0x58D5,0x8D89, 0x62F7,0x8D8A, 0x6FE0,0x8D8B, 0x8C6A,0x8D8C, 0x8F5F,0x8D8D, 0x9EB9,0x8D8E, 0x514B,0x8D8F, 0x523B,0x8D90, 0x544A,0x8D91, 0x56FD,0x8D92, 0x7A40,0x8D93, 0x9177,0x8D94, 0x9D60,0x8D95, 0x9ED2,0x8D96, 0x7344,0x8D97, 0x6F09,0x8D98, 0x8170,0x8D99, 0x7511,0x8D9A, 0x5FFD,0x8D9B, 0x60DA,0x8D9C, 0x9AA8,0x8D9D, 0x72DB,0x8D9E, 0x8FBC,0x8D9F, 0x6B64,0x8DA0, 0x9803,0x8DA1, 0x4ECA,0x8DA2, 0x56F0,0x8DA3, 0x5764,0x8DA4, 0x58BE,0x8DA5, 0x5A5A,0x8DA6, 0x6068,0x8DA7, 0x61C7,0x8DA8, 0x660F,0x8DA9, 0x6606,0x8DAA, 0x6839,0x8DAB, 0x68B1,0x8DAC, 0x6DF7,0x8DAD, 0x75D5,0x8DAE, 0x7D3A,0x8DAF, 0x826E,0x8DB0, 0x9B42,0x8DB1, 0x4E9B,0x8DB2, 0x4F50,0x8DB3, 0x53C9,0x8DB4, 0x5506,0x8DB5, 0x5D6F,0x8DB6, 0x5DE6,0x8DB7, 0x5DEE,0x8DB8, 0x67FB,0x8DB9, 0x6C99,0x8DBA, 0x7473,0x8DBB, 0x7802,0x8DBC, 0x8A50,0x8DBD, 0x9396,0x8DBE, 0x88DF,0x8DBF, 0x5750,0x8DC0, 0x5EA7,0x8DC1, 0x632B,0x8DC2, 0x50B5,0x8DC3, 0x50AC,0x8DC4, 0x518D,0x8DC5, 0x6700,0x8DC6, 0x54C9,0x8DC7, 0x585E,0x8DC8, 0x59BB,0x8DC9, 0x5BB0,0x8DCA, 0x5F69,0x8DCB, 0x624D,0x8DCC, 0x63A1,0x8DCD, 0x683D,0x8DCE, 0x6B73,0x8DCF, 0x6E08,0x8DD0, 0x707D,0x8DD1, 0x91C7,0x8DD2, 0x7280,0x8DD3, 0x7815,0x8DD4, 0x7826,0x8DD5, 0x796D,0x8DD6, 0x658E,0x8DD7, 0x7D30,0x8DD8, 0x83DC,0x8DD9, 0x88C1,0x8DDA, 0x8F09,0x8DDB, 0x969B,0x8DDC, 0x5264,0x8DDD, 0x5728,0x8DDE, 0x6750,0x8DDF, 0x7F6A,0x8DE0, 0x8CA1,0x8DE1, 0x51B4,0x8DE2, 0x5742,0x8DE3, 0x962A,0x8DE4, 0x583A,0x8DE5, 0x698A,0x8DE6, 0x80B4,0x8DE7, 0x54B2,0x8DE8, 0x5D0E,0x8DE9, 0x57FC,0x8DEA, 0x7895,0x8DEB, 0x9DFA,0x8DEC, 0x4F5C,0x8DED, 0x524A,0x8DEE, 0x548B,0x8DEF, 0x643E,0x8DF0, 0x6628,0x8DF1, 0x6714,0x8DF2, 0x67F5,0x8DF3, 0x7A84,0x8DF4, 0x7B56,0x8DF5, 0x7D22,0x8DF6, 0x932F,0x8DF7, 0x685C,0x8DF8, 0x9BAD,0x8DF9, 0x7B39,0x8DFA, 0x5319,0x8DFB, 0x518A,0x8DFC, 0x5237,0x8E40, 0x5BDF,0x8E41, 0x62F6,0x8E42, 0x64AE,0x8E43, 0x64E6,0x8E44, 0x672D,0x8E45, 0x6BBA,0x8E46, 0x85A9,0x8E47, 0x96D1,0x8E48, 0x7690,0x8E49, 0x9BD6,0x8E4A, 0x634C,0x8E4B, 0x9306,0x8E4C, 0x9BAB,0x8E4D, 0x76BF,0x8E4E, 0x6652,0x8E4F, 0x4E09,0x8E50, 0x5098,0x8E51, 0x53C2,0x8E52, 0x5C71,0x8E53, 0x60E8,0x8E54, 0x6492,0x8E55, 0x6563,0x8E56, 0x685F,0x8E57, 0x71E6,0x8E58, 0x73CA,0x8E59, 0x7523,0x8E5A, 0x7B97,0x8E5B, 0x7E82,0x8E5C, 0x8695,0x8E5D, 0x8B83,0x8E5E, 0x8CDB,0x8E5F, 0x9178,0x8E60, 0x9910,0x8E61, 0x65AC,0x8E62, 0x66AB,0x8E63, 0x6B8B,0x8E64, 0x4ED5,0x8E65, 0x4ED4,0x8E66, 0x4F3A,0x8E67, 0x4F7F,0x8E68, 0x523A,0x8E69, 0x53F8,0x8E6A, 0x53F2,0x8E6B, 0x55E3,0x8E6C, 0x56DB,0x8E6D, 0x58EB,0x8E6E, 0x59CB,0x8E6F, 0x59C9,0x8E70, 0x59FF,0x8E71, 0x5B50,0x8E72, 0x5C4D,0x8E73, 0x5E02,0x8E74, 0x5E2B,0x8E75, 0x5FD7,0x8E76, 0x601D,0x8E77, 0x6307,0x8E78, 0x652F,0x8E79, 0x5B5C,0x8E7A, 0x65AF,0x8E7B, 0x65BD,0x8E7C, 0x65E8,0x8E7D, 0x679D,0x8E7E, 0x6B62,0x8E80, 0x6B7B,0x8E81, 0x6C0F,0x8E82, 0x7345,0x8E83, 0x7949,0x8E84, 0x79C1,0x8E85, 0x7CF8,0x8E86, 0x7D19,0x8E87, 0x7D2B,0x8E88, 0x80A2,0x8E89, 0x8102,0x8E8A, 0x81F3,0x8E8B, 0x8996,0x8E8C, 0x8A5E,0x8E8D, 0x8A69,0x8E8E, 0x8A66,0x8E8F, 0x8A8C,0x8E90, 0x8AEE,0x8E91, 0x8CC7,0x8E92, 0x8CDC,0x8E93, 0x96CC,0x8E94, 0x98FC,0x8E95, 0x6B6F,0x8E96, 0x4E8B,0x8E97, 0x4F3C,0x8E98, 0x4F8D,0x8E99, 0x5150,0x8E9A, 0x5B57,0x8E9B, 0x5BFA,0x8E9C, 0x6148,0x8E9D, 0x6301,0x8E9E, 0x6642,0x8E9F, 0x6B21,0x8EA0, 0x6ECB,0x8EA1, 0x6CBB,0x8EA2, 0x723E,0x8EA3, 0x74BD,0x8EA4, 0x75D4,0x8EA5, 0x78C1,0x8EA6, 0x793A,0x8EA7, 0x800C,0x8EA8, 0x8033,0x8EA9, 0x81EA,0x8EAA, 0x8494,0x8EAB, 0x8F9E,0x8EAC, 0x6C50,0x8EAD, 0x9E7F,0x8EAE, 0x5F0F,0x8EAF, 0x8B58,0x8EB0, 0x9D2B,0x8EB1, 0x7AFA,0x8EB2, 0x8EF8,0x8EB3, 0x5B8D,0x8EB4, 0x96EB,0x8EB5, 0x4E03,0x8EB6, 0x53F1,0x8EB7, 0x57F7,0x8EB8, 0x5931,0x8EB9, 0x5AC9,0x8EBA, 0x5BA4,0x8EBB, 0x6089,0x8EBC, 0x6E7F,0x8EBD, 0x6F06,0x8EBE, 0x75BE,0x8EBF, 0x8CEA,0x8EC0, 0x5B9F,0x8EC1, 0x8500,0x8EC2, 0x7BE0,0x8EC3, 0x5072,0x8EC4, 0x67F4,0x8EC5, 0x829D,0x8EC6, 0x5C61,0x8EC7, 0x854A,0x8EC8, 0x7E1E,0x8EC9, 0x820E,0x8ECA, 0x5199,0x8ECB, 0x5C04,0x8ECC, 0x6368,0x8ECD, 0x8D66,0x8ECE, 0x659C,0x8ECF, 0x716E,0x8ED0, 0x793E,0x8ED1, 0x7D17,0x8ED2, 0x8005,0x8ED3, 0x8B1D,0x8ED4, 0x8ECA,0x8ED5, 0x906E,0x8ED6, 0x86C7,0x8ED7, 0x90AA,0x8ED8, 0x501F,0x8ED9, 0x52FA,0x8EDA, 0x5C3A,0x8EDB, 0x6753,0x8EDC, 0x707C,0x8EDD, 0x7235,0x8EDE, 0x914C,0x8EDF, 0x91C8,0x8EE0, 0x932B,0x8EE1, 0x82E5,0x8EE2, 0x5BC2,0x8EE3, 0x5F31,0x8EE4, 0x60F9,0x8EE5, 0x4E3B,0x8EE6, 0x53D6,0x8EE7, 0x5B88,0x8EE8, 0x624B,0x8EE9, 0x6731,0x8EEA, 0x6B8A,0x8EEB, 0x72E9,0x8EEC, 0x73E0,0x8EED, 0x7A2E,0x8EEE, 0x816B,0x8EEF, 0x8DA3,0x8EF0, 0x9152,0x8EF1, 0x9996,0x8EF2, 0x5112,0x8EF3, 0x53D7,0x8EF4, 0x546A,0x8EF5, 0x5BFF,0x8EF6, 0x6388,0x8EF7, 0x6A39,0x8EF8, 0x7DAC,0x8EF9, 0x9700,0x8EFA, 0x56DA,0x8EFB, 0x53CE,0x8EFC, 0x5468,0x8F40, 0x5B97,0x8F41, 0x5C31,0x8F42, 0x5DDE,0x8F43, 0x4FEE,0x8F44, 0x6101,0x8F45, 0x62FE,0x8F46, 0x6D32,0x8F47, 0x79C0,0x8F48, 0x79CB,0x8F49, 0x7D42,0x8F4A, 0x7E4D,0x8F4B, 0x7FD2,0x8F4C, 0x81ED,0x8F4D, 0x821F,0x8F4E, 0x8490,0x8F4F, 0x8846,0x8F50, 0x8972,0x8F51, 0x8B90,0x8F52, 0x8E74,0x8F53, 0x8F2F,0x8F54, 0x9031,0x8F55, 0x914B,0x8F56, 0x916C,0x8F57, 0x96C6,0x8F58, 0x919C,0x8F59, 0x4EC0,0x8F5A, 0x4F4F,0x8F5B, 0x5145,0x8F5C, 0x5341,0x8F5D, 0x5F93,0x8F5E, 0x620E,0x8F5F, 0x67D4,0x8F60, 0x6C41,0x8F61, 0x6E0B,0x8F62, 0x7363,0x8F63, 0x7E26,0x8F64, 0x91CD,0x8F65, 0x9283,0x8F66, 0x53D4,0x8F67, 0x5919,0x8F68, 0x5BBF,0x8F69, 0x6DD1,0x8F6A, 0x795D,0x8F6B, 0x7E2E,0x8F6C, 0x7C9B,0x8F6D, 0x587E,0x8F6E, 0x719F,0x8F6F, 0x51FA,0x8F70, 0x8853,0x8F71, 0x8FF0,0x8F72, 0x4FCA,0x8F73, 0x5CFB,0x8F74, 0x6625,0x8F75, 0x77AC,0x8F76, 0x7AE3,0x8F77, 0x821C,0x8F78, 0x99FF,0x8F79, 0x51C6,0x8F7A, 0x5FAA,0x8F7B, 0x65EC,0x8F7C, 0x696F,0x8F7D, 0x6B89,0x8F7E, 0x6DF3,0x8F80, 0x6E96,0x8F81, 0x6F64,0x8F82, 0x76FE,0x8F83, 0x7D14,0x8F84, 0x5DE1,0x8F85, 0x9075,0x8F86, 0x9187,0x8F87, 0x9806,0x8F88, 0x51E6,0x8F89, 0x521D,0x8F8A, 0x6240,0x8F8B, 0x6691,0x8F8C, 0x66D9,0x8F8D, 0x6E1A,0x8F8E, 0x5EB6,0x8F8F, 0x7DD2,0x8F90, 0x7F72,0x8F91, 0x66F8,0x8F92, 0x85AF,0x8F93, 0x85F7,0x8F94, 0x8AF8,0x8F95, 0x52A9,0x8F96, 0x53D9,0x8F97, 0x5973,0x8F98, 0x5E8F,0x8F99, 0x5F90,0x8F9A, 0x6055,0x8F9B, 0x92E4,0x8F9C, 0x9664,0x8F9D, 0x50B7,0x8F9E, 0x511F,0x8F9F, 0x52DD,0x8FA0, 0x5320,0x8FA1, 0x5347,0x8FA2, 0x53EC,0x8FA3, 0x54E8,0x8FA4, 0x5546,0x8FA5, 0x5531,0x8FA6, 0x5617,0x8FA7, 0x5968,0x8FA8, 0x59BE,0x8FA9, 0x5A3C,0x8FAA, 0x5BB5,0x8FAB, 0x5C06,0x8FAC, 0x5C0F,0x8FAD, 0x5C11,0x8FAE, 0x5C1A,0x8FAF, 0x5E84,0x8FB0, 0x5E8A,0x8FB1, 0x5EE0,0x8FB2, 0x5F70,0x8FB3, 0x627F,0x8FB4, 0x6284,0x8FB5, 0x62DB,0x8FB6, 0x638C,0x8FB7, 0x6377,0x8FB8, 0x6607,0x8FB9, 0x660C,0x8FBA, 0x662D,0x8FBB, 0x6676,0x8FBC, 0x677E,0x8FBD, 0x68A2,0x8FBE, 0x6A1F,0x8FBF, 0x6A35,0x8FC0, 0x6CBC,0x8FC1, 0x6D88,0x8FC2, 0x6E09,0x8FC3, 0x6E58,0x8FC4, 0x713C,0x8FC5, 0x7126,0x8FC6, 0x7167,0x8FC7, 0x75C7,0x8FC8, 0x7701,0x8FC9, 0x785D,0x8FCA, 0x7901,0x8FCB, 0x7965,0x8FCC, 0x79F0,0x8FCD, 0x7AE0,0x8FCE, 0x7B11,0x8FCF, 0x7CA7,0x8FD0, 0x7D39,0x8FD1, 0x8096,0x8FD2, 0x83D6,0x8FD3, 0x848B,0x8FD4, 0x8549,0x8FD5, 0x885D,0x8FD6, 0x88F3,0x8FD7, 0x8A1F,0x8FD8, 0x8A3C,0x8FD9, 0x8A54,0x8FDA, 0x8A73,0x8FDB, 0x8C61,0x8FDC, 0x8CDE,0x8FDD, 0x91A4,0x8FDE, 0x9266,0x8FDF, 0x937E,0x8FE0, 0x9418,0x8FE1, 0x969C,0x8FE2, 0x9798,0x8FE3, 0x4E0A,0x8FE4, 0x4E08,0x8FE5, 0x4E1E,0x8FE6, 0x4E57,0x8FE7, 0x5197,0x8FE8, 0x5270,0x8FE9, 0x57CE,0x8FEA, 0x5834,0x8FEB, 0x58CC,0x8FEC, 0x5B22,0x8FED, 0x5E38,0x8FEE, 0x60C5,0x8FEF, 0x64FE,0x8FF0, 0x6761,0x8FF1, 0x6756,0x8FF2, 0x6D44,0x8FF3, 0x72B6,0x8FF4, 0x7573,0x8FF5, 0x7A63,0x8FF6, 0x84B8,0x8FF7, 0x8B72,0x8FF8, 0x91B8,0x8FF9, 0x9320,0x8FFA, 0x5631,0x8FFB, 0x57F4,0x8FFC, 0x98FE,0x9040, 0x62ED,0x9041, 0x690D,0x9042, 0x6B96,0x9043, 0x71ED,0x9044, 0x7E54,0x9045, 0x8077,0x9046, 0x8272,0x9047, 0x89E6,0x9048, 0x98DF,0x9049, 0x8755,0x904A, 0x8FB1,0x904B, 0x5C3B,0x904C, 0x4F38,0x904D, 0x4FE1,0x904E, 0x4FB5,0x904F, 0x5507,0x9050, 0x5A20,0x9051, 0x5BDD,0x9052, 0x5BE9,0x9053, 0x5FC3,0x9054, 0x614E,0x9055, 0x632F,0x9056, 0x65B0,0x9057, 0x664B,0x9058, 0x68EE,0x9059, 0x699B,0x905A, 0x6D78,0x905B, 0x6DF1,0x905C, 0x7533,0x905D, 0x75B9,0x905E, 0x771F,0x905F, 0x795E,0x9060, 0x79E6,0x9061, 0x7D33,0x9062, 0x81E3,0x9063, 0x82AF,0x9064, 0x85AA,0x9065, 0x89AA,0x9066, 0x8A3A,0x9067, 0x8EAB,0x9068, 0x8F9B,0x9069, 0x9032,0x906A, 0x91DD,0x906B, 0x9707,0x906C, 0x4EBA,0x906D, 0x4EC1,0x906E, 0x5203,0x906F, 0x5875,0x9070, 0x58EC,0x9071, 0x5C0B,0x9072, 0x751A,0x9073, 0x5C3D,0x9074, 0x814E,0x9075, 0x8A0A,0x9076, 0x8FC5,0x9077, 0x9663,0x9078, 0x976D,0x9079, 0x7B25,0x907A, 0x8ACF,0x907B, 0x9808,0x907C, 0x9162,0x907D, 0x56F3,0x907E, 0x53A8,0x9080, 0x9017,0x9081, 0x5439,0x9082, 0x5782,0x9083, 0x5E25,0x9084, 0x63A8,0x9085, 0x6C34,0x9086, 0x708A,0x9087, 0x7761,0x9088, 0x7C8B,0x9089, 0x7FE0,0x908A, 0x8870,0x908B, 0x9042,0x908C, 0x9154,0x908D, 0x9310,0x908E, 0x9318,0x908F, 0x968F,0x9090, 0x745E,0x9091, 0x9AC4,0x9092, 0x5D07,0x9093, 0x5D69,0x9094, 0x6570,0x9095, 0x67A2,0x9096, 0x8DA8,0x9097, 0x96DB,0x9098, 0x636E,0x9099, 0x6749,0x909A, 0x6919,0x909B, 0x83C5,0x909C, 0x9817,0x909D, 0x96C0,0x909E, 0x88FE,0x909F, 0x6F84,0x90A0, 0x647A,0x90A1, 0x5BF8,0x90A2, 0x4E16,0x90A3, 0x702C,0x90A4, 0x755D,0x90A5, 0x662F,0x90A6, 0x51C4,0x90A7, 0x5236,0x90A8, 0x52E2,0x90A9, 0x59D3,0x90AA, 0x5F81,0x90AB, 0x6027,0x90AC, 0x6210,0x90AD, 0x653F,0x90AE, 0x6574,0x90AF, 0x661F,0x90B0, 0x6674,0x90B1, 0x68F2,0x90B2, 0x6816,0x90B3, 0x6B63,0x90B4, 0x6E05,0x90B5, 0x7272,0x90B6, 0x751F,0x90B7, 0x76DB,0x90B8, 0x7CBE,0x90B9, 0x8056,0x90BA, 0x58F0,0x90BB, 0x88FD,0x90BC, 0x897F,0x90BD, 0x8AA0,0x90BE, 0x8A93,0x90BF, 0x8ACB,0x90C0, 0x901D,0x90C1, 0x9192,0x90C2, 0x9752,0x90C3, 0x9759,0x90C4, 0x6589,0x90C5, 0x7A0E,0x90C6, 0x8106,0x90C7, 0x96BB,0x90C8, 0x5E2D,0x90C9, 0x60DC,0x90CA, 0x621A,0x90CB, 0x65A5,0x90CC, 0x6614,0x90CD, 0x6790,0x90CE, 0x77F3,0x90CF, 0x7A4D,0x90D0, 0x7C4D,0x90D1, 0x7E3E,0x90D2, 0x810A,0x90D3, 0x8CAC,0x90D4, 0x8D64,0x90D5, 0x8DE1,0x90D6, 0x8E5F,0x90D7, 0x78A9,0x90D8, 0x5207,0x90D9, 0x62D9,0x90DA, 0x63A5,0x90DB, 0x6442,0x90DC, 0x6298,0x90DD, 0x8A2D,0x90DE, 0x7A83,0x90DF, 0x7BC0,0x90E0, 0x8AAC,0x90E1, 0x96EA,0x90E2, 0x7D76,0x90E3, 0x820C,0x90E4, 0x8749,0x90E5, 0x4ED9,0x90E6, 0x5148,0x90E7, 0x5343,0x90E8, 0x5360,0x90E9, 0x5BA3,0x90EA, 0x5C02,0x90EB, 0x5C16,0x90EC, 0x5DDD,0x90ED, 0x6226,0x90EE, 0x6247,0x90EF, 0x64B0,0x90F0, 0x6813,0x90F1, 0x6834,0x90F2, 0x6CC9,0x90F3, 0x6D45,0x90F4, 0x6D17,0x90F5, 0x67D3,0x90F6, 0x6F5C,0x90F7, 0x714E,0x90F8, 0x717D,0x90F9, 0x65CB,0x90FA, 0x7A7F,0x90FB, 0x7BAD,0x90FC, 0x7DDA,0x9140, 0x7E4A,0x9141, 0x7FA8,0x9142, 0x817A,0x9143, 0x821B,0x9144, 0x8239,0x9145, 0x85A6,0x9146, 0x8A6E,0x9147, 0x8CCE,0x9148, 0x8DF5,0x9149, 0x9078,0x914A, 0x9077,0x914B, 0x92AD,0x914C, 0x9291,0x914D, 0x9583,0x914E, 0x9BAE,0x914F, 0x524D,0x9150, 0x5584,0x9151, 0x6F38,0x9152, 0x7136,0x9153, 0x5168,0x9154, 0x7985,0x9155, 0x7E55,0x9156, 0x81B3,0x9157, 0x7CCE,0x9158, 0x564C,0x9159, 0x5851,0x915A, 0x5CA8,0x915B, 0x63AA,0x915C, 0x66FE,0x915D, 0x66FD,0x915E, 0x695A,0x915F, 0x72D9,0x9160, 0x758F,0x9161, 0x758E,0x9162, 0x790E,0x9163, 0x7956,0x9164, 0x79DF,0x9165, 0x7C97,0x9166, 0x7D20,0x9167, 0x7D44,0x9168, 0x8607,0x9169, 0x8A34,0x916A, 0x963B,0x916B, 0x9061,0x916C, 0x9F20,0x916D, 0x50E7,0x916E, 0x5275,0x916F, 0x53CC,0x9170, 0x53E2,0x9171, 0x5009,0x9172, 0x55AA,0x9173, 0x58EE,0x9174, 0x594F,0x9175, 0x723D,0x9176, 0x5B8B,0x9177, 0x5C64,0x9178, 0x531D,0x9179, 0x60E3,0x917A, 0x60F3,0x917B, 0x635C,0x917C, 0x6383,0x917D, 0x633F,0x917E, 0x63BB,0x9180, 0x64CD,0x9181, 0x65E9,0x9182, 0x66F9,0x9183, 0x5DE3,0x9184, 0x69CD,0x9185, 0x69FD,0x9186, 0x6F15,0x9187, 0x71E5,0x9188, 0x4E89,0x9189, 0x75E9,0x918A, 0x76F8,0x918B, 0x7A93,0x918C, 0x7CDF,0x918D, 0x7DCF,0x918E, 0x7D9C,0x918F, 0x8061,0x9190, 0x8349,0x9191, 0x8358,0x9192, 0x846C,0x9193, 0x84BC,0x9194, 0x85FB,0x9195, 0x88C5,0x9196, 0x8D70,0x9197, 0x9001,0x9198, 0x906D,0x9199, 0x9397,0x919A, 0x971C,0x919B, 0x9A12,0x919C, 0x50CF,0x919D, 0x5897,0x919E, 0x618E,0x919F, 0x81D3,0x91A0, 0x8535,0x91A1, 0x8D08,0x91A2, 0x9020,0x91A3, 0x4FC3,0x91A4, 0x5074,0x91A5, 0x5247,0x91A6, 0x5373,0x91A7, 0x606F,0x91A8, 0x6349,0x91A9, 0x675F,0x91AA, 0x6E2C,0x91AB, 0x8DB3,0x91AC, 0x901F,0x91AD, 0x4FD7,0x91AE, 0x5C5E,0x91AF, 0x8CCA,0x91B0, 0x65CF,0x91B1, 0x7D9A,0x91B2, 0x5352,0x91B3, 0x8896,0x91B4, 0x5176,0x91B5, 0x63C3,0x91B6, 0x5B58,0x91B7, 0x5B6B,0x91B8, 0x5C0A,0x91B9, 0x640D,0x91BA, 0x6751,0x91BB, 0x905C,0x91BC, 0x4ED6,0x91BD, 0x591A,0x91BE, 0x592A,0x91BF, 0x6C70,0x91C0, 0x8A51,0x91C1, 0x553E,0x91C2, 0x5815,0x91C3, 0x59A5,0x91C4, 0x60F0,0x91C5, 0x6253,0x91C6, 0x67C1,0x91C7, 0x8235,0x91C8, 0x6955,0x91C9, 0x9640,0x91CA, 0x99C4,0x91CB, 0x9A28,0x91CC, 0x4F53,0x91CD, 0x5806,0x91CE, 0x5BFE,0x91CF, 0x8010,0x91D0, 0x5CB1,0x91D1, 0x5E2F,0x91D2, 0x5F85,0x91D3, 0x6020,0x91D4, 0x614B,0x91D5, 0x6234,0x91D6, 0x66FF,0x91D7, 0x6CF0,0x91D8, 0x6EDE,0x91D9, 0x80CE,0x91DA, 0x817F,0x91DB, 0x82D4,0x91DC, 0x888B,0x91DD, 0x8CB8,0x91DE, 0x9000,0x91DF, 0x902E,0x91E0, 0x968A,0x91E1, 0x9EDB,0x91E2, 0x9BDB,0x91E3, 0x4EE3,0x91E4, 0x53F0,0x91E5, 0x5927,0x91E6, 0x7B2C,0x91E7, 0x918D,0x91E8, 0x984C,0x91E9, 0x9DF9,0x91EA, 0x6EDD,0x91EB, 0x7027,0x91EC, 0x5353,0x91ED, 0x5544,0x91EE, 0x5B85,0x91EF, 0x6258,0x91F0, 0x629E,0x91F1, 0x62D3,0x91F2, 0x6CA2,0x91F3, 0x6FEF,0x91F4, 0x7422,0x91F5, 0x8A17,0x91F6, 0x9438,0x91F7, 0x6FC1,0x91F8, 0x8AFE,0x91F9, 0x8338,0x91FA, 0x51E7,0x91FB, 0x86F8,0x91FC, 0x53EA,0x9240, 0x53E9,0x9241, 0x4F46,0x9242, 0x9054,0x9243, 0x8FB0,0x9244, 0x596A,0x9245, 0x8131,0x9246, 0x5DFD,0x9247, 0x7AEA,0x9248, 0x8FBF,0x9249, 0x68DA,0x924A, 0x8C37,0x924B, 0x72F8,0x924C, 0x9C48,0x924D, 0x6A3D,0x924E, 0x8AB0,0x924F, 0x4E39,0x9250, 0x5358,0x9251, 0x5606,0x9252, 0x5766,0x9253, 0x62C5,0x9254, 0x63A2,0x9255, 0x65E6,0x9256, 0x6B4E,0x9257, 0x6DE1,0x9258, 0x6E5B,0x9259, 0x70AD,0x925A, 0x77ED,0x925B, 0x7AEF,0x925C, 0x7BAA,0x925D, 0x7DBB,0x925E, 0x803D,0x925F, 0x80C6,0x9260, 0x86CB,0x9261, 0x8A95,0x9262, 0x935B,0x9263, 0x56E3,0x9264, 0x58C7,0x9265, 0x5F3E,0x9266, 0x65AD,0x9267, 0x6696,0x9268, 0x6A80,0x9269, 0x6BB5,0x926A, 0x7537,0x926B, 0x8AC7,0x926C, 0x5024,0x926D, 0x77E5,0x926E, 0x5730,0x926F, 0x5F1B,0x9270, 0x6065,0x9271, 0x667A,0x9272, 0x6C60,0x9273, 0x75F4,0x9274, 0x7A1A,0x9275, 0x7F6E,0x9276, 0x81F4,0x9277, 0x8718,0x9278, 0x9045,0x9279, 0x99B3,0x927A, 0x7BC9,0x927B, 0x755C,0x927C, 0x7AF9,0x927D, 0x7B51,0x927E, 0x84C4,0x9280, 0x9010,0x9281, 0x79E9,0x9282, 0x7A92,0x9283, 0x8336,0x9284, 0x5AE1,0x9285, 0x7740,0x9286, 0x4E2D,0x9287, 0x4EF2,0x9288, 0x5B99,0x9289, 0x5FE0,0x928A, 0x62BD,0x928B, 0x663C,0x928C, 0x67F1,0x928D, 0x6CE8,0x928E, 0x866B,0x928F, 0x8877,0x9290, 0x8A3B,0x9291, 0x914E,0x9292, 0x92F3,0x9293, 0x99D0,0x9294, 0x6A17,0x9295, 0x7026,0x9296, 0x732A,0x9297, 0x82E7,0x9298, 0x8457,0x9299, 0x8CAF,0x929A, 0x4E01,0x929B, 0x5146,0x929C, 0x51CB,0x929D, 0x558B,0x929E, 0x5BF5,0x929F, 0x5E16,0x92A0, 0x5E33,0x92A1, 0x5E81,0x92A2, 0x5F14,0x92A3, 0x5F35,0x92A4, 0x5F6B,0x92A5, 0x5FB4,0x92A6, 0x61F2,0x92A7, 0x6311,0x92A8, 0x66A2,0x92A9, 0x671D,0x92AA, 0x6F6E,0x92AB, 0x7252,0x92AC, 0x753A,0x92AD, 0x773A,0x92AE, 0x8074,0x92AF, 0x8139,0x92B0, 0x8178,0x92B1, 0x8776,0x92B2, 0x8ABF,0x92B3, 0x8ADC,0x92B4, 0x8D85,0x92B5, 0x8DF3,0x92B6, 0x929A,0x92B7, 0x9577,0x92B8, 0x9802,0x92B9, 0x9CE5,0x92BA, 0x52C5,0x92BB, 0x6357,0x92BC, 0x76F4,0x92BD, 0x6715,0x92BE, 0x6C88,0x92BF, 0x73CD,0x92C0, 0x8CC3,0x92C1, 0x93AE,0x92C2, 0x9673,0x92C3, 0x6D25,0x92C4, 0x589C,0x92C5, 0x690E,0x92C6, 0x69CC,0x92C7, 0x8FFD,0x92C8, 0x939A,0x92C9, 0x75DB,0x92CA, 0x901A,0x92CB, 0x585A,0x92CC, 0x6802,0x92CD, 0x63B4,0x92CE, 0x69FB,0x92CF, 0x4F43,0x92D0, 0x6F2C,0x92D1, 0x67D8,0x92D2, 0x8FBB,0x92D3, 0x8526,0x92D4, 0x7DB4,0x92D5, 0x9354,0x92D6, 0x693F,0x92D7, 0x6F70,0x92D8, 0x576A,0x92D9, 0x58F7,0x92DA, 0x5B2C,0x92DB, 0x7D2C,0x92DC, 0x722A,0x92DD, 0x540A,0x92DE, 0x91E3,0x92DF, 0x9DB4,0x92E0, 0x4EAD,0x92E1, 0x4F4E,0x92E2, 0x505C,0x92E3, 0x5075,0x92E4, 0x5243,0x92E5, 0x8C9E,0x92E6, 0x5448,0x92E7, 0x5824,0x92E8, 0x5B9A,0x92E9, 0x5E1D,0x92EA, 0x5E95,0x92EB, 0x5EAD,0x92EC, 0x5EF7,0x92ED, 0x5F1F,0x92EE, 0x608C,0x92EF, 0x62B5,0x92F0, 0x633A,0x92F1, 0x63D0,0x92F2, 0x68AF,0x92F3, 0x6C40,0x92F4, 0x7887,0x92F5, 0x798E,0x92F6, 0x7A0B,0x92F7, 0x7DE0,0x92F8, 0x8247,0x92F9, 0x8A02,0x92FA, 0x8AE6,0x92FB, 0x8E44,0x92FC, 0x9013,0x9340, 0x90B8,0x9341, 0x912D,0x9342, 0x91D8,0x9343, 0x9F0E,0x9344, 0x6CE5,0x9345, 0x6458,0x9346, 0x64E2,0x9347, 0x6575,0x9348, 0x6EF4,0x9349, 0x7684,0x934A, 0x7B1B,0x934B, 0x9069,0x934C, 0x93D1,0x934D, 0x6EBA,0x934E, 0x54F2,0x934F, 0x5FB9,0x9350, 0x64A4,0x9351, 0x8F4D,0x9352, 0x8FED,0x9353, 0x9244,0x9354, 0x5178,0x9355, 0x586B,0x9356, 0x5929,0x9357, 0x5C55,0x9358, 0x5E97,0x9359, 0x6DFB,0x935A, 0x7E8F,0x935B, 0x751C,0x935C, 0x8CBC,0x935D, 0x8EE2,0x935E, 0x985B,0x935F, 0x70B9,0x9360, 0x4F1D,0x9361, 0x6BBF,0x9362, 0x6FB1,0x9363, 0x7530,0x9364, 0x96FB,0x9365, 0x514E,0x9366, 0x5410,0x9367, 0x5835,0x9368, 0x5857,0x9369, 0x59AC,0x936A, 0x5C60,0x936B, 0x5F92,0x936C, 0x6597,0x936D, 0x675C,0x936E, 0x6E21,0x936F, 0x767B,0x9370, 0x83DF,0x9371, 0x8CED,0x9372, 0x9014,0x9373, 0x90FD,0x9374, 0x934D,0x9375, 0x7825,0x9376, 0x783A,0x9377, 0x52AA,0x9378, 0x5EA6,0x9379, 0x571F,0x937A, 0x5974,0x937B, 0x6012,0x937C, 0x5012,0x937D, 0x515A,0x937E, 0x51AC,0x9380, 0x51CD,0x9381, 0x5200,0x9382, 0x5510,0x9383, 0x5854,0x9384, 0x5858,0x9385, 0x5957,0x9386, 0x5B95,0x9387, 0x5CF6,0x9388, 0x5D8B,0x9389, 0x60BC,0x938A, 0x6295,0x938B, 0x642D,0x938C, 0x6771,0x938D, 0x6843,0x938E, 0x68BC,0x938F, 0x68DF,0x9390, 0x76D7,0x9391, 0x6DD8,0x9392, 0x6E6F,0x9393, 0x6D9B,0x9394, 0x706F,0x9395, 0x71C8,0x9396, 0x5F53,0x9397, 0x75D8,0x9398, 0x7977,0x9399, 0x7B49,0x939A, 0x7B54,0x939B, 0x7B52,0x939C, 0x7CD6,0x939D, 0x7D71,0x939E, 0x5230,0x939F, 0x8463,0x93A0, 0x8569,0x93A1, 0x85E4,0x93A2, 0x8A0E,0x93A3, 0x8B04,0x93A4, 0x8C46,0x93A5, 0x8E0F,0x93A6, 0x9003,0x93A7, 0x900F,0x93A8, 0x9419,0x93A9, 0x9676,0x93AA, 0x982D,0x93AB, 0x9A30,0x93AC, 0x95D8,0x93AD, 0x50CD,0x93AE, 0x52D5,0x93AF, 0x540C,0x93B0, 0x5802,0x93B1, 0x5C0E,0x93B2, 0x61A7,0x93B3, 0x649E,0x93B4, 0x6D1E,0x93B5, 0x77B3,0x93B6, 0x7AE5,0x93B7, 0x80F4,0x93B8, 0x8404,0x93B9, 0x9053,0x93BA, 0x9285,0x93BB, 0x5CE0,0x93BC, 0x9D07,0x93BD, 0x533F,0x93BE, 0x5F97,0x93BF, 0x5FB3,0x93C0, 0x6D9C,0x93C1, 0x7279,0x93C2, 0x7763,0x93C3, 0x79BF,0x93C4, 0x7BE4,0x93C5, 0x6BD2,0x93C6, 0x72EC,0x93C7, 0x8AAD,0x93C8, 0x6803,0x93C9, 0x6A61,0x93CA, 0x51F8,0x93CB, 0x7A81,0x93CC, 0x6934,0x93CD, 0x5C4A,0x93CE, 0x9CF6,0x93CF, 0x82EB,0x93D0, 0x5BC5,0x93D1, 0x9149,0x93D2, 0x701E,0x93D3, 0x5678,0x93D4, 0x5C6F,0x93D5, 0x60C7,0x93D6, 0x6566,0x93D7, 0x6C8C,0x93D8, 0x8C5A,0x93D9, 0x9041,0x93DA, 0x9813,0x93DB, 0x5451,0x93DC, 0x66C7,0x93DD, 0x920D,0x93DE, 0x5948,0x93DF, 0x90A3,0x93E0, 0x5185,0x93E1, 0x4E4D,0x93E2, 0x51EA,0x93E3, 0x8599,0x93E4, 0x8B0E,0x93E5, 0x7058,0x93E6, 0x637A,0x93E7, 0x934B,0x93E8, 0x6962,0x93E9, 0x99B4,0x93EA, 0x7E04,0x93EB, 0x7577,0x93EC, 0x5357,0x93ED, 0x6960,0x93EE, 0x8EDF,0x93EF, 0x96E3,0x93F0, 0x6C5D,0x93F1, 0x4E8C,0x93F2, 0x5C3C,0x93F3, 0x5F10,0x93F4, 0x8FE9,0x93F5, 0x5302,0x93F6, 0x8CD1,0x93F7, 0x8089,0x93F8, 0x8679,0x93F9, 0x5EFF,0x93FA, 0x65E5,0x93FB, 0x4E73,0x93FC, 0x5165,0x9440, 0x5982,0x9441, 0x5C3F,0x9442, 0x97EE,0x9443, 0x4EFB,0x9444, 0x598A,0x9445, 0x5FCD,0x9446, 0x8A8D,0x9447, 0x6FE1,0x9448, 0x79B0,0x9449, 0x7962,0x944A, 0x5BE7,0x944B, 0x8471,0x944C, 0x732B,0x944D, 0x71B1,0x944E, 0x5E74,0x944F, 0x5FF5,0x9450, 0x637B,0x9451, 0x649A,0x9452, 0x71C3,0x9453, 0x7C98,0x9454, 0x4E43,0x9455, 0x5EFC,0x9456, 0x4E4B,0x9457, 0x57DC,0x9458, 0x56A2,0x9459, 0x60A9,0x945A, 0x6FC3,0x945B, 0x7D0D,0x945C, 0x80FD,0x945D, 0x8133,0x945E, 0x81BF,0x945F, 0x8FB2,0x9460, 0x8997,0x9461, 0x86A4,0x9462, 0x5DF4,0x9463, 0x628A,0x9464, 0x64AD,0x9465, 0x8987,0x9466, 0x6777,0x9467, 0x6CE2,0x9468, 0x6D3E,0x9469, 0x7436,0x946A, 0x7834,0x946B, 0x5A46,0x946C, 0x7F75,0x946D, 0x82AD,0x946E, 0x99AC,0x946F, 0x4FF3,0x9470, 0x5EC3,0x9471, 0x62DD,0x9472, 0x6392,0x9473, 0x6557,0x9474, 0x676F,0x9475, 0x76C3,0x9476, 0x724C,0x9477, 0x80CC,0x9478, 0x80BA,0x9479, 0x8F29,0x947A, 0x914D,0x947B, 0x500D,0x947C, 0x57F9,0x947D, 0x5A92,0x947E, 0x6885,0x9480, 0x6973,0x9481, 0x7164,0x9482, 0x72FD,0x9483, 0x8CB7,0x9484, 0x58F2,0x9485, 0x8CE0,0x9486, 0x966A,0x9487, 0x9019,0x9488, 0x877F,0x9489, 0x79E4,0x948A, 0x77E7,0x948B, 0x8429,0x948C, 0x4F2F,0x948D, 0x5265,0x948E, 0x535A,0x948F, 0x62CD,0x9490, 0x67CF,0x9491, 0x6CCA,0x9492, 0x767D,0x9493, 0x7B94,0x9494, 0x7C95,0x9495, 0x8236,0x9496, 0x8584,0x9497, 0x8FEB,0x9498, 0x66DD,0x9499, 0x6F20,0x949A, 0x7206,0x949B, 0x7E1B,0x949C, 0x83AB,0x949D, 0x99C1,0x949E, 0x9EA6,0x949F, 0x51FD,0x94A0, 0x7BB1,0x94A1, 0x7872,0x94A2, 0x7BB8,0x94A3, 0x8087,0x94A4, 0x7B48,0x94A5, 0x6AE8,0x94A6, 0x5E61,0x94A7, 0x808C,0x94A8, 0x7551,0x94A9, 0x7560,0x94AA, 0x516B,0x94AB, 0x9262,0x94AC, 0x6E8C,0x94AD, 0x767A,0x94AE, 0x9197,0x94AF, 0x9AEA,0x94B0, 0x4F10,0x94B1, 0x7F70,0x94B2, 0x629C,0x94B3, 0x7B4F,0x94B4, 0x95A5,0x94B5, 0x9CE9,0x94B6, 0x567A,0x94B7, 0x5859,0x94B8, 0x86E4,0x94B9, 0x96BC,0x94BA, 0x4F34,0x94BB, 0x5224,0x94BC, 0x534A,0x94BD, 0x53CD,0x94BE, 0x53DB,0x94BF, 0x5E06,0x94C0, 0x642C,0x94C1, 0x6591,0x94C2, 0x677F,0x94C3, 0x6C3E,0x94C4, 0x6C4E,0x94C5, 0x7248,0x94C6, 0x72AF,0x94C7, 0x73ED,0x94C8, 0x7554,0x94C9, 0x7E41,0x94CA, 0x822C,0x94CB, 0x85E9,0x94CC, 0x8CA9,0x94CD, 0x7BC4,0x94CE, 0x91C6,0x94CF, 0x7169,0x94D0, 0x9812,0x94D1, 0x98EF,0x94D2, 0x633D,0x94D3, 0x6669,0x94D4, 0x756A,0x94D5, 0x76E4,0x94D6, 0x78D0,0x94D7, 0x8543,0x94D8, 0x86EE,0x94D9, 0x532A,0x94DA, 0x5351,0x94DB, 0x5426,0x94DC, 0x5983,0x94DD, 0x5E87,0x94DE, 0x5F7C,0x94DF, 0x60B2,0x94E0, 0x6249,0x94E1, 0x6279,0x94E2, 0x62AB,0x94E3, 0x6590,0x94E4, 0x6BD4,0x94E5, 0x6CCC,0x94E6, 0x75B2,0x94E7, 0x76AE,0x94E8, 0x7891,0x94E9, 0x79D8,0x94EA, 0x7DCB,0x94EB, 0x7F77,0x94EC, 0x80A5,0x94ED, 0x88AB,0x94EE, 0x8AB9,0x94EF, 0x8CBB,0x94F0, 0x907F,0x94F1, 0x975E,0x94F2, 0x98DB,0x94F3, 0x6A0B,0x94F4, 0x7C38,0x94F5, 0x5099,0x94F6, 0x5C3E,0x94F7, 0x5FAE,0x94F8, 0x6787,0x94F9, 0x6BD8,0x94FA, 0x7435,0x94FB, 0x7709,0x94FC, 0x7F8E,0x9540, 0x9F3B,0x9541, 0x67CA,0x9542, 0x7A17,0x9543, 0x5339,0x9544, 0x758B,0x9545, 0x9AED,0x9546, 0x5F66,0x9547, 0x819D,0x9548, 0x83F1,0x9549, 0x8098,0x954A, 0x5F3C,0x954B, 0x5FC5,0x954C, 0x7562,0x954D, 0x7B46,0x954E, 0x903C,0x954F, 0x6867,0x9550, 0x59EB,0x9551, 0x5A9B,0x9552, 0x7D10,0x9553, 0x767E,0x9554, 0x8B2C,0x9555, 0x4FF5,0x9556, 0x5F6A,0x9557, 0x6A19,0x9558, 0x6C37,0x9559, 0x6F02,0x955A, 0x74E2,0x955B, 0x7968,0x955C, 0x8868,0x955D, 0x8A55,0x955E, 0x8C79,0x955F, 0x5EDF,0x9560, 0x63CF,0x9561, 0x75C5,0x9562, 0x79D2,0x9563, 0x82D7,0x9564, 0x9328,0x9565, 0x92F2,0x9566, 0x849C,0x9567, 0x86ED,0x9568, 0x9C2D,0x9569, 0x54C1,0x956A, 0x5F6C,0x956B, 0x658C,0x956C, 0x6D5C,0x956D, 0x7015,0x956E, 0x8CA7,0x956F, 0x8CD3,0x9570, 0x983B,0x9571, 0x654F,0x9572, 0x74F6,0x9573, 0x4E0D,0x9574, 0x4ED8,0x9575, 0x57E0,0x9576, 0x592B,0x9577, 0x5A66,0x9578, 0x5BCC,0x9579, 0x51A8,0x957A, 0x5E03,0x957B, 0x5E9C,0x957C, 0x6016,0x957D, 0x6276,0x957E, 0x6577,0x9580, 0x65A7,0x9581, 0x666E,0x9582, 0x6D6E,0x9583, 0x7236,0x9584, 0x7B26,0x9585, 0x8150,0x9586, 0x819A,0x9587, 0x8299,0x9588, 0x8B5C,0x9589, 0x8CA0,0x958A, 0x8CE6,0x958B, 0x8D74,0x958C, 0x961C,0x958D, 0x9644,0x958E, 0x4FAE,0x958F, 0x64AB,0x9590, 0x6B66,0x9591, 0x821E,0x9592, 0x8461,0x9593, 0x856A,0x9594, 0x90E8,0x9595, 0x5C01,0x9596, 0x6953,0x9597, 0x98A8,0x9598, 0x847A,0x9599, 0x8557,0x959A, 0x4F0F,0x959B, 0x526F,0x959C, 0x5FA9,0x959D, 0x5E45,0x959E, 0x670D,0x959F, 0x798F,0x95A0, 0x8179,0x95A1, 0x8907,0x95A2, 0x8986,0x95A3, 0x6DF5,0x95A4, 0x5F17,0x95A5, 0x6255,0x95A6, 0x6CB8,0x95A7, 0x4ECF,0x95A8, 0x7269,0x95A9, 0x9B92,0x95AA, 0x5206,0x95AB, 0x543B,0x95AC, 0x5674,0x95AD, 0x58B3,0x95AE, 0x61A4,0x95AF, 0x626E,0x95B0, 0x711A,0x95B1, 0x596E,0x95B2, 0x7C89,0x95B3, 0x7CDE,0x95B4, 0x7D1B,0x95B5, 0x96F0,0x95B6, 0x6587,0x95B7, 0x805E,0x95B8, 0x4E19,0x95B9, 0x4F75,0x95BA, 0x5175,0x95BB, 0x5840,0x95BC, 0x5E63,0x95BD, 0x5E73,0x95BE, 0x5F0A,0x95BF, 0x67C4,0x95C0, 0x4E26,0x95C1, 0x853D,0x95C2, 0x9589,0x95C3, 0x965B,0x95C4, 0x7C73,0x95C5, 0x9801,0x95C6, 0x50FB,0x95C7, 0x58C1,0x95C8, 0x7656,0x95C9, 0x78A7,0x95CA, 0x5225,0x95CB, 0x77A5,0x95CC, 0x8511,0x95CD, 0x7B86,0x95CE, 0x504F,0x95CF, 0x5909,0x95D0, 0x7247,0x95D1, 0x7BC7,0x95D2, 0x7DE8,0x95D3, 0x8FBA,0x95D4, 0x8FD4,0x95D5, 0x904D,0x95D6, 0x4FBF,0x95D7, 0x52C9,0x95D8, 0x5A29,0x95D9, 0x5F01,0x95DA, 0x97AD,0x95DB, 0x4FDD,0x95DC, 0x8217,0x95DD, 0x92EA,0x95DE, 0x5703,0x95DF, 0x6355,0x95E0, 0x6B69,0x95E1, 0x752B,0x95E2, 0x88DC,0x95E3, 0x8F14,0x95E4, 0x7A42,0x95E5, 0x52DF,0x95E6, 0x5893,0x95E7, 0x6155,0x95E8, 0x620A,0x95E9, 0x66AE,0x95EA, 0x6BCD,0x95EB, 0x7C3F,0x95EC, 0x83E9,0x95ED, 0x5023,0x95EE, 0x4FF8,0x95EF, 0x5305,0x95F0, 0x5446,0x95F1, 0x5831,0x95F2, 0x5949,0x95F3, 0x5B9D,0x95F4, 0x5CF0,0x95F5, 0x5CEF,0x95F6, 0x5D29,0x95F7, 0x5E96,0x95F8, 0x62B1,0x95F9, 0x6367,0x95FA, 0x653E,0x95FB, 0x65B9,0x95FC, 0x670B,0x9640, 0x6CD5,0x9641, 0x6CE1,0x9642, 0x70F9,0x9643, 0x7832,0x9644, 0x7E2B,0x9645, 0x80DE,0x9646, 0x82B3,0x9647, 0x840C,0x9648, 0x84EC,0x9649, 0x8702,0x964A, 0x8912,0x964B, 0x8A2A,0x964C, 0x8C4A,0x964D, 0x90A6,0x964E, 0x92D2,0x964F, 0x98FD,0x9650, 0x9CF3,0x9651, 0x9D6C,0x9652, 0x4E4F,0x9653, 0x4EA1,0x9654, 0x508D,0x9655, 0x5256,0x9656, 0x574A,0x9657, 0x59A8,0x9658, 0x5E3D,0x9659, 0x5FD8,0x965A, 0x5FD9,0x965B, 0x623F,0x965C, 0x66B4,0x965D, 0x671B,0x965E, 0x67D0,0x965F, 0x68D2,0x9660, 0x5192,0x9661, 0x7D21,0x9662, 0x80AA,0x9663, 0x81A8,0x9664, 0x8B00,0x9665, 0x8C8C,0x9666, 0x8CBF,0x9667, 0x927E,0x9668, 0x9632,0x9669, 0x5420,0x966A, 0x982C,0x966B, 0x5317,0x966C, 0x50D5,0x966D, 0x535C,0x966E, 0x58A8,0x966F, 0x64B2,0x9670, 0x6734,0x9671, 0x7267,0x9672, 0x7766,0x9673, 0x7A46,0x9674, 0x91E6,0x9675, 0x52C3,0x9676, 0x6CA1,0x9677, 0x6B86,0x9678, 0x5800,0x9679, 0x5E4C,0x967A, 0x5954,0x967B, 0x672C,0x967C, 0x7FFB,0x967D, 0x51E1,0x967E, 0x76C6,0x9680, 0x6469,0x9681, 0x78E8,0x9682, 0x9B54,0x9683, 0x9EBB,0x9684, 0x57CB,0x9685, 0x59B9,0x9686, 0x6627,0x9687, 0x679A,0x9688, 0x6BCE,0x9689, 0x54E9,0x968A, 0x69D9,0x968B, 0x5E55,0x968C, 0x819C,0x968D, 0x6795,0x968E, 0x9BAA,0x968F, 0x67FE,0x9690, 0x9C52,0x9691, 0x685D,0x9692, 0x4EA6,0x9693, 0x4FE3,0x9694, 0x53C8,0x9695, 0x62B9,0x9696, 0x672B,0x9697, 0x6CAB,0x9698, 0x8FC4,0x9699, 0x4FAD,0x969A, 0x7E6D,0x969B, 0x9EBF,0x969C, 0x4E07,0x969D, 0x6162,0x969E, 0x6E80,0x969F, 0x6F2B,0x96A0, 0x8513,0x96A1, 0x5473,0x96A2, 0x672A,0x96A3, 0x9B45,0x96A4, 0x5DF3,0x96A5, 0x7B95,0x96A6, 0x5CAC,0x96A7, 0x5BC6,0x96A8, 0x871C,0x96A9, 0x6E4A,0x96AA, 0x84D1,0x96AB, 0x7A14,0x96AC, 0x8108,0x96AD, 0x5999,0x96AE, 0x7C8D,0x96AF, 0x6C11,0x96B0, 0x7720,0x96B1, 0x52D9,0x96B2, 0x5922,0x96B3, 0x7121,0x96B4, 0x725F,0x96B5, 0x77DB,0x96B6, 0x9727,0x96B7, 0x9D61,0x96B8, 0x690B,0x96B9, 0x5A7F,0x96BA, 0x5A18,0x96BB, 0x51A5,0x96BC, 0x540D,0x96BD, 0x547D,0x96BE, 0x660E,0x96BF, 0x76DF,0x96C0, 0x8FF7,0x96C1, 0x9298,0x96C2, 0x9CF4,0x96C3, 0x59EA,0x96C4, 0x725D,0x96C5, 0x6EC5,0x96C6, 0x514D,0x96C7, 0x68C9,0x96C8, 0x7DBF,0x96C9, 0x7DEC,0x96CA, 0x9762,0x96CB, 0x9EBA,0x96CC, 0x6478,0x96CD, 0x6A21,0x96CE, 0x8302,0x96CF, 0x5984,0x96D0, 0x5B5F,0x96D1, 0x6BDB,0x96D2, 0x731B,0x96D3, 0x76F2,0x96D4, 0x7DB2,0x96D5, 0x8017,0x96D6, 0x8499,0x96D7, 0x5132,0x96D8, 0x6728,0x96D9, 0x9ED9,0x96DA, 0x76EE,0x96DB, 0x6762,0x96DC, 0x52FF,0x96DD, 0x9905,0x96DE, 0x5C24,0x96DF, 0x623B,0x96E0, 0x7C7E,0x96E1, 0x8CB0,0x96E2, 0x554F,0x96E3, 0x60B6,0x96E4, 0x7D0B,0x96E5, 0x9580,0x96E6, 0x5301,0x96E7, 0x4E5F,0x96E8, 0x51B6,0x96E9, 0x591C,0x96EA, 0x723A,0x96EB, 0x8036,0x96EC, 0x91CE,0x96ED, 0x5F25,0x96EE, 0x77E2,0x96EF, 0x5384,0x96F0, 0x5F79,0x96F1, 0x7D04,0x96F2, 0x85AC,0x96F3, 0x8A33,0x96F4, 0x8E8D,0x96F5, 0x9756,0x96F6, 0x67F3,0x96F7, 0x85AE,0x96F8, 0x9453,0x96F9, 0x6109,0x96FA, 0x6108,0x96FB, 0x6CB9,0x96FC, 0x7652,0x9740, 0x8AED,0x9741, 0x8F38,0x9742, 0x552F,0x9743, 0x4F51,0x9744, 0x512A,0x9745, 0x52C7,0x9746, 0x53CB,0x9747, 0x5BA5,0x9748, 0x5E7D,0x9749, 0x60A0,0x974A, 0x6182,0x974B, 0x63D6,0x974C, 0x6709,0x974D, 0x67DA,0x974E, 0x6E67,0x974F, 0x6D8C,0x9750, 0x7336,0x9751, 0x7337,0x9752, 0x7531,0x9753, 0x7950,0x9754, 0x88D5,0x9755, 0x8A98,0x9756, 0x904A,0x9757, 0x9091,0x9758, 0x90F5,0x9759, 0x96C4,0x975A, 0x878D,0x975B, 0x5915,0x975C, 0x4E88,0x975D, 0x4F59,0x975E, 0x4E0E,0x975F, 0x8A89,0x9760, 0x8F3F,0x9761, 0x9810,0x9762, 0x50AD,0x9763, 0x5E7C,0x9764, 0x5996,0x9765, 0x5BB9,0x9766, 0x5EB8,0x9767, 0x63DA,0x9768, 0x63FA,0x9769, 0x64C1,0x976A, 0x66DC,0x976B, 0x694A,0x976C, 0x69D8,0x976D, 0x6D0B,0x976E, 0x6EB6,0x976F, 0x7194,0x9770, 0x7528,0x9771, 0x7AAF,0x9772, 0x7F8A,0x9773, 0x8000,0x9774, 0x8449,0x9775, 0x84C9,0x9776, 0x8981,0x9777, 0x8B21,0x9778, 0x8E0A,0x9779, 0x9065,0x977A, 0x967D,0x977B, 0x990A,0x977C, 0x617E,0x977D, 0x6291,0x977E, 0x6B32,0x9780, 0x6C83,0x9781, 0x6D74,0x9782, 0x7FCC,0x9783, 0x7FFC,0x9784, 0x6DC0,0x9785, 0x7F85,0x9786, 0x87BA,0x9787, 0x88F8,0x9788, 0x6765,0x9789, 0x83B1,0x978A, 0x983C,0x978B, 0x96F7,0x978C, 0x6D1B,0x978D, 0x7D61,0x978E, 0x843D,0x978F, 0x916A,0x9790, 0x4E71,0x9791, 0x5375,0x9792, 0x5D50,0x9793, 0x6B04,0x9794, 0x6FEB,0x9795, 0x85CD,0x9796, 0x862D,0x9797, 0x89A7,0x9798, 0x5229,0x9799, 0x540F,0x979A, 0x5C65,0x979B, 0x674E,0x979C, 0x68A8,0x979D, 0x7406,0x979E, 0x7483,0x979F, 0x75E2,0x97A0, 0x88CF,0x97A1, 0x88E1,0x97A2, 0x91CC,0x97A3, 0x96E2,0x97A4, 0x9678,0x97A5, 0x5F8B,0x97A6, 0x7387,0x97A7, 0x7ACB,0x97A8, 0x844E,0x97A9, 0x63A0,0x97AA, 0x7565,0x97AB, 0x5289,0x97AC, 0x6D41,0x97AD, 0x6E9C,0x97AE, 0x7409,0x97AF, 0x7559,0x97B0, 0x786B,0x97B1, 0x7C92,0x97B2, 0x9686,0x97B3, 0x7ADC,0x97B4, 0x9F8D,0x97B5, 0x4FB6,0x97B6, 0x616E,0x97B7, 0x65C5,0x97B8, 0x865C,0x97B9, 0x4E86,0x97BA, 0x4EAE,0x97BB, 0x50DA,0x97BC, 0x4E21,0x97BD, 0x51CC,0x97BE, 0x5BEE,0x97BF, 0x6599,0x97C0, 0x6881,0x97C1, 0x6DBC,0x97C2, 0x731F,0x97C3, 0x7642,0x97C4, 0x77AD,0x97C5, 0x7A1C,0x97C6, 0x7CE7,0x97C7, 0x826F,0x97C8, 0x8AD2,0x97C9, 0x907C,0x97CA, 0x91CF,0x97CB, 0x9675,0x97CC, 0x9818,0x97CD, 0x529B,0x97CE, 0x7DD1,0x97CF, 0x502B,0x97D0, 0x5398,0x97D1, 0x6797,0x97D2, 0x6DCB,0x97D3, 0x71D0,0x97D4, 0x7433,0x97D5, 0x81E8,0x97D6, 0x8F2A,0x97D7, 0x96A3,0x97D8, 0x9C57,0x97D9, 0x9E9F,0x97DA, 0x7460,0x97DB, 0x5841,0x97DC, 0x6D99,0x97DD, 0x7D2F,0x97DE, 0x985E,0x97DF, 0x4EE4,0x97E0, 0x4F36,0x97E1, 0x4F8B,0x97E2, 0x51B7,0x97E3, 0x52B1,0x97E4, 0x5DBA,0x97E5, 0x601C,0x97E6, 0x73B2,0x97E7, 0x793C,0x97E8, 0x82D3,0x97E9, 0x9234,0x97EA, 0x96B7,0x97EB, 0x96F6,0x97EC, 0x970A,0x97ED, 0x9E97,0x97EE, 0x9F62,0x97EF, 0x66A6,0x97F0, 0x6B74,0x97F1, 0x5217,0x97F2, 0x52A3,0x97F3, 0x70C8,0x97F4, 0x88C2,0x97F5, 0x5EC9,0x97F6, 0x604B,0x97F7, 0x6190,0x97F8, 0x6F23,0x97F9, 0x7149,0x97FA, 0x7C3E,0x97FB, 0x7DF4,0x97FC, 0x806F,0x9840, 0x84EE,0x9841, 0x9023,0x9842, 0x932C,0x9843, 0x5442,0x9844, 0x9B6F,0x9845, 0x6AD3,0x9846, 0x7089,0x9847, 0x8CC2,0x9848, 0x8DEF,0x9849, 0x9732,0x984A, 0x52B4,0x984B, 0x5A41,0x984C, 0x5ECA,0x984D, 0x5F04,0x984E, 0x6717,0x984F, 0x697C,0x9850, 0x6994,0x9851, 0x6D6A,0x9852, 0x6F0F,0x9853, 0x7262,0x9854, 0x72FC,0x9855, 0x7BED,0x9856, 0x8001,0x9857, 0x807E,0x9858, 0x874B,0x9859, 0x90CE,0x985A, 0x516D,0x985B, 0x9E93,0x985C, 0x7984,0x985D, 0x808B,0x985E, 0x9332,0x985F, 0x8AD6,0x9860, 0x502D,0x9861, 0x548C,0x9862, 0x8A71,0x9863, 0x6B6A,0x9864, 0x8CC4,0x9865, 0x8107,0x9866, 0x60D1,0x9867, 0x67A0,0x9868, 0x9DF2,0x9869, 0x4E99,0x986A, 0x4E98,0x986B, 0x9C10,0x986C, 0x8A6B,0x986D, 0x85C1,0x986E, 0x8568,0x986F, 0x6900,0x9870, 0x6E7E,0x9871, 0x7897,0x9872, 0x8155,0x989F, 0x5F0C,0x98A0, 0x4E10,0x98A1, 0x4E15,0x98A2, 0x4E2A,0x98A3, 0x4E31,0x98A4, 0x4E36,0x98A5, 0x4E3C,0x98A6, 0x4E3F,0x98A7, 0x4E42,0x98A8, 0x4E56,0x98A9, 0x4E58,0x98AA, 0x4E82,0x98AB, 0x4E85,0x98AC, 0x8C6B,0x98AD, 0x4E8A,0x98AE, 0x8212,0x98AF, 0x5F0D,0x98B0, 0x4E8E,0x98B1, 0x4E9E,0x98B2, 0x4E9F,0x98B3, 0x4EA0,0x98B4, 0x4EA2,0x98B5, 0x4EB0,0x98B6, 0x4EB3,0x98B7, 0x4EB6,0x98B8, 0x4ECE,0x98B9, 0x4ECD,0x98BA, 0x4EC4,0x98BB, 0x4EC6,0x98BC, 0x4EC2,0x98BD, 0x4ED7,0x98BE, 0x4EDE,0x98BF, 0x4EED,0x98C0, 0x4EDF,0x98C1, 0x4EF7,0x98C2, 0x4F09,0x98C3, 0x4F5A,0x98C4, 0x4F30,0x98C5, 0x4F5B,0x98C6, 0x4F5D,0x98C7, 0x4F57,0x98C8, 0x4F47,0x98C9, 0x4F76,0x98CA, 0x4F88,0x98CB, 0x4F8F,0x98CC, 0x4F98,0x98CD, 0x4F7B,0x98CE, 0x4F69,0x98CF, 0x4F70,0x98D0, 0x4F91,0x98D1, 0x4F6F,0x98D2, 0x4F86,0x98D3, 0x4F96,0x98D4, 0x5118,0x98D5, 0x4FD4,0x98D6, 0x4FDF,0x98D7, 0x4FCE,0x98D8, 0x4FD8,0x98D9, 0x4FDB,0x98DA, 0x4FD1,0x98DB, 0x4FDA,0x98DC, 0x4FD0,0x98DD, 0x4FE4,0x98DE, 0x4FE5,0x98DF, 0x501A,0x98E0, 0x5028,0x98E1, 0x5014,0x98E2, 0x502A,0x98E3, 0x5025,0x98E4, 0x5005,0x98E5, 0x4F1C,0x98E6, 0x4FF6,0x98E7, 0x5021,0x98E8, 0x5029,0x98E9, 0x502C,0x98EA, 0x4FFE,0x98EB, 0x4FEF,0x98EC, 0x5011,0x98ED, 0x5006,0x98EE, 0x5043,0x98EF, 0x5047,0x98F0, 0x6703,0x98F1, 0x5055,0x98F2, 0x5050,0x98F3, 0x5048,0x98F4, 0x505A,0x98F5, 0x5056,0x98F6, 0x506C,0x98F7, 0x5078,0x98F8, 0x5080,0x98F9, 0x509A,0x98FA, 0x5085,0x98FB, 0x50B4,0x98FC, 0x50B2,0x9940, 0x50C9,0x9941, 0x50CA,0x9942, 0x50B3,0x9943, 0x50C2,0x9944, 0x50D6,0x9945, 0x50DE,0x9946, 0x50E5,0x9947, 0x50ED,0x9948, 0x50E3,0x9949, 0x50EE,0x994A, 0x50F9,0x994B, 0x50F5,0x994C, 0x5109,0x994D, 0x5101,0x994E, 0x5102,0x994F, 0x5116,0x9950, 0x5115,0x9951, 0x5114,0x9952, 0x511A,0x9953, 0x5121,0x9954, 0x513A,0x9955, 0x5137,0x9956, 0x513C,0x9957, 0x513B,0x9958, 0x513F,0x9959, 0x5140,0x995A, 0x5152,0x995B, 0x514C,0x995C, 0x5154,0x995D, 0x5162,0x995E, 0x7AF8,0x995F, 0x5169,0x9960, 0x516A,0x9961, 0x516E,0x9962, 0x5180,0x9963, 0x5182,0x9964, 0x56D8,0x9965, 0x518C,0x9966, 0x5189,0x9967, 0x518F,0x9968, 0x5191,0x9969, 0x5193,0x996A, 0x5195,0x996B, 0x5196,0x996C, 0x51A4,0x996D, 0x51A6,0x996E, 0x51A2,0x996F, 0x51A9,0x9970, 0x51AA,0x9971, 0x51AB,0x9972, 0x51B3,0x9973, 0x51B1,0x9974, 0x51B2,0x9975, 0x51B0,0x9976, 0x51B5,0x9977, 0x51BD,0x9978, 0x51C5,0x9979, 0x51C9,0x997A, 0x51DB,0x997B, 0x51E0,0x997C, 0x8655,0x997D, 0x51E9,0x997E, 0x51ED,0x9980, 0x51F0,0x9981, 0x51F5,0x9982, 0x51FE,0x9983, 0x5204,0x9984, 0x520B,0x9985, 0x5214,0x9986, 0x520E,0x9987, 0x5227,0x9988, 0x522A,0x9989, 0x522E,0x998A, 0x5233,0x998B, 0x5239,0x998C, 0x524F,0x998D, 0x5244,0x998E, 0x524B,0x998F, 0x524C,0x9990, 0x525E,0x9991, 0x5254,0x9992, 0x526A,0x9993, 0x5274,0x9994, 0x5269,0x9995, 0x5273,0x9996, 0x527F,0x9997, 0x527D,0x9998, 0x528D,0x9999, 0x5294,0x999A, 0x5292,0x999B, 0x5271,0x999C, 0x5288,0x999D, 0x5291,0x999E, 0x8FA8,0x999F, 0x8FA7,0x99A0, 0x52AC,0x99A1, 0x52AD,0x99A2, 0x52BC,0x99A3, 0x52B5,0x99A4, 0x52C1,0x99A5, 0x52CD,0x99A6, 0x52D7,0x99A7, 0x52DE,0x99A8, 0x52E3,0x99A9, 0x52E6,0x99AA, 0x98ED,0x99AB, 0x52E0,0x99AC, 0x52F3,0x99AD, 0x52F5,0x99AE, 0x52F8,0x99AF, 0x52F9,0x99B0, 0x5306,0x99B1, 0x5308,0x99B2, 0x7538,0x99B3, 0x530D,0x99B4, 0x5310,0x99B5, 0x530F,0x99B6, 0x5315,0x99B7, 0x531A,0x99B8, 0x5323,0x99B9, 0x532F,0x99BA, 0x5331,0x99BB, 0x5333,0x99BC, 0x5338,0x99BD, 0x5340,0x99BE, 0x5346,0x99BF, 0x5345,0x99C0, 0x4E17,0x99C1, 0x5349,0x99C2, 0x534D,0x99C3, 0x51D6,0x99C4, 0x535E,0x99C5, 0x5369,0x99C6, 0x536E,0x99C7, 0x5918,0x99C8, 0x537B,0x99C9, 0x5377,0x99CA, 0x5382,0x99CB, 0x5396,0x99CC, 0x53A0,0x99CD, 0x53A6,0x99CE, 0x53A5,0x99CF, 0x53AE,0x99D0, 0x53B0,0x99D1, 0x53B6,0x99D2, 0x53C3,0x99D3, 0x7C12,0x99D4, 0x96D9,0x99D5, 0x53DF,0x99D6, 0x66FC,0x99D7, 0x71EE,0x99D8, 0x53EE,0x99D9, 0x53E8,0x99DA, 0x53ED,0x99DB, 0x53FA,0x99DC, 0x5401,0x99DD, 0x543D,0x99DE, 0x5440,0x99DF, 0x542C,0x99E0, 0x542D,0x99E1, 0x543C,0x99E2, 0x542E,0x99E3, 0x5436,0x99E4, 0x5429,0x99E5, 0x541D,0x99E6, 0x544E,0x99E7, 0x548F,0x99E8, 0x5475,0x99E9, 0x548E,0x99EA, 0x545F,0x99EB, 0x5471,0x99EC, 0x5477,0x99ED, 0x5470,0x99EE, 0x5492,0x99EF, 0x547B,0x99F0, 0x5480,0x99F1, 0x5476,0x99F2, 0x5484,0x99F3, 0x5490,0x99F4, 0x5486,0x99F5, 0x54C7,0x99F6, 0x54A2,0x99F7, 0x54B8,0x99F8, 0x54A5,0x99F9, 0x54AC,0x99FA, 0x54C4,0x99FB, 0x54C8,0x99FC, 0x54A8,0x9A40, 0x54AB,0x9A41, 0x54C2,0x9A42, 0x54A4,0x9A43, 0x54BE,0x9A44, 0x54BC,0x9A45, 0x54D8,0x9A46, 0x54E5,0x9A47, 0x54E6,0x9A48, 0x550F,0x9A49, 0x5514,0x9A4A, 0x54FD,0x9A4B, 0x54EE,0x9A4C, 0x54ED,0x9A4D, 0x54FA,0x9A4E, 0x54E2,0x9A4F, 0x5539,0x9A50, 0x5540,0x9A51, 0x5563,0x9A52, 0x554C,0x9A53, 0x552E,0x9A54, 0x555C,0x9A55, 0x5545,0x9A56, 0x5556,0x9A57, 0x5557,0x9A58, 0x5538,0x9A59, 0x5533,0x9A5A, 0x555D,0x9A5B, 0x5599,0x9A5C, 0x5580,0x9A5D, 0x54AF,0x9A5E, 0x558A,0x9A5F, 0x559F,0x9A60, 0x557B,0x9A61, 0x557E,0x9A62, 0x5598,0x9A63, 0x559E,0x9A64, 0x55AE,0x9A65, 0x557C,0x9A66, 0x5583,0x9A67, 0x55A9,0x9A68, 0x5587,0x9A69, 0x55A8,0x9A6A, 0x55DA,0x9A6B, 0x55C5,0x9A6C, 0x55DF,0x9A6D, 0x55C4,0x9A6E, 0x55DC,0x9A6F, 0x55E4,0x9A70, 0x55D4,0x9A71, 0x5614,0x9A72, 0x55F7,0x9A73, 0x5616,0x9A74, 0x55FE,0x9A75, 0x55FD,0x9A76, 0x561B,0x9A77, 0x55F9,0x9A78, 0x564E,0x9A79, 0x5650,0x9A7A, 0x71DF,0x9A7B, 0x5634,0x9A7C, 0x5636,0x9A7D, 0x5632,0x9A7E, 0x5638,0x9A80, 0x566B,0x9A81, 0x5664,0x9A82, 0x562F,0x9A83, 0x566C,0x9A84, 0x566A,0x9A85, 0x5686,0x9A86, 0x5680,0x9A87, 0x568A,0x9A88, 0x56A0,0x9A89, 0x5694,0x9A8A, 0x568F,0x9A8B, 0x56A5,0x9A8C, 0x56AE,0x9A8D, 0x56B6,0x9A8E, 0x56B4,0x9A8F, 0x56C2,0x9A90, 0x56BC,0x9A91, 0x56C1,0x9A92, 0x56C3,0x9A93, 0x56C0,0x9A94, 0x56C8,0x9A95, 0x56CE,0x9A96, 0x56D1,0x9A97, 0x56D3,0x9A98, 0x56D7,0x9A99, 0x56EE,0x9A9A, 0x56F9,0x9A9B, 0x5700,0x9A9C, 0x56FF,0x9A9D, 0x5704,0x9A9E, 0x5709,0x9A9F, 0x5708,0x9AA0, 0x570B,0x9AA1, 0x570D,0x9AA2, 0x5713,0x9AA3, 0x5718,0x9AA4, 0x5716,0x9AA5, 0x55C7,0x9AA6, 0x571C,0x9AA7, 0x5726,0x9AA8, 0x5737,0x9AA9, 0x5738,0x9AAA, 0x574E,0x9AAB, 0x573B,0x9AAC, 0x5740,0x9AAD, 0x574F,0x9AAE, 0x5769,0x9AAF, 0x57C0,0x9AB0, 0x5788,0x9AB1, 0x5761,0x9AB2, 0x577F,0x9AB3, 0x5789,0x9AB4, 0x5793,0x9AB5, 0x57A0,0x9AB6, 0x57B3,0x9AB7, 0x57A4,0x9AB8, 0x57AA,0x9AB9, 0x57B0,0x9ABA, 0x57C3,0x9ABB, 0x57C6,0x9ABC, 0x57D4,0x9ABD, 0x57D2,0x9ABE, 0x57D3,0x9ABF, 0x580A,0x9AC0, 0x57D6,0x9AC1, 0x57E3,0x9AC2, 0x580B,0x9AC3, 0x5819,0x9AC4, 0x581D,0x9AC5, 0x5872,0x9AC6, 0x5821,0x9AC7, 0x5862,0x9AC8, 0x584B,0x9AC9, 0x5870,0x9ACA, 0x6BC0,0x9ACB, 0x5852,0x9ACC, 0x583D,0x9ACD, 0x5879,0x9ACE, 0x5885,0x9ACF, 0x58B9,0x9AD0, 0x589F,0x9AD1, 0x58AB,0x9AD2, 0x58BA,0x9AD3, 0x58DE,0x9AD4, 0x58BB,0x9AD5, 0x58B8,0x9AD6, 0x58AE,0x9AD7, 0x58C5,0x9AD8, 0x58D3,0x9AD9, 0x58D1,0x9ADA, 0x58D7,0x9ADB, 0x58D9,0x9ADC, 0x58D8,0x9ADD, 0x58E5,0x9ADE, 0x58DC,0x9ADF, 0x58E4,0x9AE0, 0x58DF,0x9AE1, 0x58EF,0x9AE2, 0x58FA,0x9AE3, 0x58F9,0x9AE4, 0x58FB,0x9AE5, 0x58FC,0x9AE6, 0x58FD,0x9AE7, 0x5902,0x9AE8, 0x590A,0x9AE9, 0x5910,0x9AEA, 0x591B,0x9AEB, 0x68A6,0x9AEC, 0x5925,0x9AED, 0x592C,0x9AEE, 0x592D,0x9AEF, 0x5932,0x9AF0, 0x5938,0x9AF1, 0x593E,0x9AF2, 0x7AD2,0x9AF3, 0x5955,0x9AF4, 0x5950,0x9AF5, 0x594E,0x9AF6, 0x595A,0x9AF7, 0x5958,0x9AF8, 0x5962,0x9AF9, 0x5960,0x9AFA, 0x5967,0x9AFB, 0x596C,0x9AFC, 0x5969,0x9B40, 0x5978,0x9B41, 0x5981,0x9B42, 0x599D,0x9B43, 0x4F5E,0x9B44, 0x4FAB,0x9B45, 0x59A3,0x9B46, 0x59B2,0x9B47, 0x59C6,0x9B48, 0x59E8,0x9B49, 0x59DC,0x9B4A, 0x598D,0x9B4B, 0x59D9,0x9B4C, 0x59DA,0x9B4D, 0x5A25,0x9B4E, 0x5A1F,0x9B4F, 0x5A11,0x9B50, 0x5A1C,0x9B51, 0x5A09,0x9B52, 0x5A1A,0x9B53, 0x5A40,0x9B54, 0x5A6C,0x9B55, 0x5A49,0x9B56, 0x5A35,0x9B57, 0x5A36,0x9B58, 0x5A62,0x9B59, 0x5A6A,0x9B5A, 0x5A9A,0x9B5B, 0x5ABC,0x9B5C, 0x5ABE,0x9B5D, 0x5ACB,0x9B5E, 0x5AC2,0x9B5F, 0x5ABD,0x9B60, 0x5AE3,0x9B61, 0x5AD7,0x9B62, 0x5AE6,0x9B63, 0x5AE9,0x9B64, 0x5AD6,0x9B65, 0x5AFA,0x9B66, 0x5AFB,0x9B67, 0x5B0C,0x9B68, 0x5B0B,0x9B69, 0x5B16,0x9B6A, 0x5B32,0x9B6B, 0x5AD0,0x9B6C, 0x5B2A,0x9B6D, 0x5B36,0x9B6E, 0x5B3E,0x9B6F, 0x5B43,0x9B70, 0x5B45,0x9B71, 0x5B40,0x9B72, 0x5B51,0x9B73, 0x5B55,0x9B74, 0x5B5A,0x9B75, 0x5B5B,0x9B76, 0x5B65,0x9B77, 0x5B69,0x9B78, 0x5B70,0x9B79, 0x5B73,0x9B7A, 0x5B75,0x9B7B, 0x5B78,0x9B7C, 0x6588,0x9B7D, 0x5B7A,0x9B7E, 0x5B80,0x9B80, 0x5B83,0x9B81, 0x5BA6,0x9B82, 0x5BB8,0x9B83, 0x5BC3,0x9B84, 0x5BC7,0x9B85, 0x5BC9,0x9B86, 0x5BD4,0x9B87, 0x5BD0,0x9B88, 0x5BE4,0x9B89, 0x5BE6,0x9B8A, 0x5BE2,0x9B8B, 0x5BDE,0x9B8C, 0x5BE5,0x9B8D, 0x5BEB,0x9B8E, 0x5BF0,0x9B8F, 0x5BF6,0x9B90, 0x5BF3,0x9B91, 0x5C05,0x9B92, 0x5C07,0x9B93, 0x5C08,0x9B94, 0x5C0D,0x9B95, 0x5C13,0x9B96, 0x5C20,0x9B97, 0x5C22,0x9B98, 0x5C28,0x9B99, 0x5C38,0x9B9A, 0x5C39,0x9B9B, 0x5C41,0x9B9C, 0x5C46,0x9B9D, 0x5C4E,0x9B9E, 0x5C53,0x9B9F, 0x5C50,0x9BA0, 0x5C4F,0x9BA1, 0x5B71,0x9BA2, 0x5C6C,0x9BA3, 0x5C6E,0x9BA4, 0x4E62,0x9BA5, 0x5C76,0x9BA6, 0x5C79,0x9BA7, 0x5C8C,0x9BA8, 0x5C91,0x9BA9, 0x5C94,0x9BAA, 0x599B,0x9BAB, 0x5CAB,0x9BAC, 0x5CBB,0x9BAD, 0x5CB6,0x9BAE, 0x5CBC,0x9BAF, 0x5CB7,0x9BB0, 0x5CC5,0x9BB1, 0x5CBE,0x9BB2, 0x5CC7,0x9BB3, 0x5CD9,0x9BB4, 0x5CE9,0x9BB5, 0x5CFD,0x9BB6, 0x5CFA,0x9BB7, 0x5CED,0x9BB8, 0x5D8C,0x9BB9, 0x5CEA,0x9BBA, 0x5D0B,0x9BBB, 0x5D15,0x9BBC, 0x5D17,0x9BBD, 0x5D5C,0x9BBE, 0x5D1F,0x9BBF, 0x5D1B,0x9BC0, 0x5D11,0x9BC1, 0x5D14,0x9BC2, 0x5D22,0x9BC3, 0x5D1A,0x9BC4, 0x5D19,0x9BC5, 0x5D18,0x9BC6, 0x5D4C,0x9BC7, 0x5D52,0x9BC8, 0x5D4E,0x9BC9, 0x5D4B,0x9BCA, 0x5D6C,0x9BCB, 0x5D73,0x9BCC, 0x5D76,0x9BCD, 0x5D87,0x9BCE, 0x5D84,0x9BCF, 0x5D82,0x9BD0, 0x5DA2,0x9BD1, 0x5D9D,0x9BD2, 0x5DAC,0x9BD3, 0x5DAE,0x9BD4, 0x5DBD,0x9BD5, 0x5D90,0x9BD6, 0x5DB7,0x9BD7, 0x5DBC,0x9BD8, 0x5DC9,0x9BD9, 0x5DCD,0x9BDA, 0x5DD3,0x9BDB, 0x5DD2,0x9BDC, 0x5DD6,0x9BDD, 0x5DDB,0x9BDE, 0x5DEB,0x9BDF, 0x5DF2,0x9BE0, 0x5DF5,0x9BE1, 0x5E0B,0x9BE2, 0x5E1A,0x9BE3, 0x5E19,0x9BE4, 0x5E11,0x9BE5, 0x5E1B,0x9BE6, 0x5E36,0x9BE7, 0x5E37,0x9BE8, 0x5E44,0x9BE9, 0x5E43,0x9BEA, 0x5E40,0x9BEB, 0x5E4E,0x9BEC, 0x5E57,0x9BED, 0x5E54,0x9BEE, 0x5E5F,0x9BEF, 0x5E62,0x9BF0, 0x5E64,0x9BF1, 0x5E47,0x9BF2, 0x5E75,0x9BF3, 0x5E76,0x9BF4, 0x5E7A,0x9BF5, 0x9EBC,0x9BF6, 0x5E7F,0x9BF7, 0x5EA0,0x9BF8, 0x5EC1,0x9BF9, 0x5EC2,0x9BFA, 0x5EC8,0x9BFB, 0x5ED0,0x9BFC, 0x5ECF,0x9C40, 0x5ED6,0x9C41, 0x5EE3,0x9C42, 0x5EDD,0x9C43, 0x5EDA,0x9C44, 0x5EDB,0x9C45, 0x5EE2,0x9C46, 0x5EE1,0x9C47, 0x5EE8,0x9C48, 0x5EE9,0x9C49, 0x5EEC,0x9C4A, 0x5EF1,0x9C4B, 0x5EF3,0x9C4C, 0x5EF0,0x9C4D, 0x5EF4,0x9C4E, 0x5EF8,0x9C4F, 0x5EFE,0x9C50, 0x5F03,0x9C51, 0x5F09,0x9C52, 0x5F5D,0x9C53, 0x5F5C,0x9C54, 0x5F0B,0x9C55, 0x5F11,0x9C56, 0x5F16,0x9C57, 0x5F29,0x9C58, 0x5F2D,0x9C59, 0x5F38,0x9C5A, 0x5F41,0x9C5B, 0x5F48,0x9C5C, 0x5F4C,0x9C5D, 0x5F4E,0x9C5E, 0x5F2F,0x9C5F, 0x5F51,0x9C60, 0x5F56,0x9C61, 0x5F57,0x9C62, 0x5F59,0x9C63, 0x5F61,0x9C64, 0x5F6D,0x9C65, 0x5F73,0x9C66, 0x5F77,0x9C67, 0x5F83,0x9C68, 0x5F82,0x9C69, 0x5F7F,0x9C6A, 0x5F8A,0x9C6B, 0x5F88,0x9C6C, 0x5F91,0x9C6D, 0x5F87,0x9C6E, 0x5F9E,0x9C6F, 0x5F99,0x9C70, 0x5F98,0x9C71, 0x5FA0,0x9C72, 0x5FA8,0x9C73, 0x5FAD,0x9C74, 0x5FBC,0x9C75, 0x5FD6,0x9C76, 0x5FFB,0x9C77, 0x5FE4,0x9C78, 0x5FF8,0x9C79, 0x5FF1,0x9C7A, 0x5FDD,0x9C7B, 0x60B3,0x9C7C, 0x5FFF,0x9C7D, 0x6021,0x9C7E, 0x6060,0x9C80, 0x6019,0x9C81, 0x6010,0x9C82, 0x6029,0x9C83, 0x600E,0x9C84, 0x6031,0x9C85, 0x601B,0x9C86, 0x6015,0x9C87, 0x602B,0x9C88, 0x6026,0x9C89, 0x600F,0x9C8A, 0x603A,0x9C8B, 0x605A,0x9C8C, 0x6041,0x9C8D, 0x606A,0x9C8E, 0x6077,0x9C8F, 0x605F,0x9C90, 0x604A,0x9C91, 0x6046,0x9C92, 0x604D,0x9C93, 0x6063,0x9C94, 0x6043,0x9C95, 0x6064,0x9C96, 0x6042,0x9C97, 0x606C,0x9C98, 0x606B,0x9C99, 0x6059,0x9C9A, 0x6081,0x9C9B, 0x608D,0x9C9C, 0x60E7,0x9C9D, 0x6083,0x9C9E, 0x609A,0x9C9F, 0x6084,0x9CA0, 0x609B,0x9CA1, 0x6096,0x9CA2, 0x6097,0x9CA3, 0x6092,0x9CA4, 0x60A7,0x9CA5, 0x608B,0x9CA6, 0x60E1,0x9CA7, 0x60B8,0x9CA8, 0x60E0,0x9CA9, 0x60D3,0x9CAA, 0x60B4,0x9CAB, 0x5FF0,0x9CAC, 0x60BD,0x9CAD, 0x60C6,0x9CAE, 0x60B5,0x9CAF, 0x60D8,0x9CB0, 0x614D,0x9CB1, 0x6115,0x9CB2, 0x6106,0x9CB3, 0x60F6,0x9CB4, 0x60F7,0x9CB5, 0x6100,0x9CB6, 0x60F4,0x9CB7, 0x60FA,0x9CB8, 0x6103,0x9CB9, 0x6121,0x9CBA, 0x60FB,0x9CBB, 0x60F1,0x9CBC, 0x610D,0x9CBD, 0x610E,0x9CBE, 0x6147,0x9CBF, 0x613E,0x9CC0, 0x6128,0x9CC1, 0x6127,0x9CC2, 0x614A,0x9CC3, 0x613F,0x9CC4, 0x613C,0x9CC5, 0x612C,0x9CC6, 0x6134,0x9CC7, 0x613D,0x9CC8, 0x6142,0x9CC9, 0x6144,0x9CCA, 0x6173,0x9CCB, 0x6177,0x9CCC, 0x6158,0x9CCD, 0x6159,0x9CCE, 0x615A,0x9CCF, 0x616B,0x9CD0, 0x6174,0x9CD1, 0x616F,0x9CD2, 0x6165,0x9CD3, 0x6171,0x9CD4, 0x615F,0x9CD5, 0x615D,0x9CD6, 0x6153,0x9CD7, 0x6175,0x9CD8, 0x6199,0x9CD9, 0x6196,0x9CDA, 0x6187,0x9CDB, 0x61AC,0x9CDC, 0x6194,0x9CDD, 0x619A,0x9CDE, 0x618A,0x9CDF, 0x6191,0x9CE0, 0x61AB,0x9CE1, 0x61AE,0x9CE2, 0x61CC,0x9CE3, 0x61CA,0x9CE4, 0x61C9,0x9CE5, 0x61F7,0x9CE6, 0x61C8,0x9CE7, 0x61C3,0x9CE8, 0x61C6,0x9CE9, 0x61BA,0x9CEA, 0x61CB,0x9CEB, 0x7F79,0x9CEC, 0x61CD,0x9CED, 0x61E6,0x9CEE, 0x61E3,0x9CEF, 0x61F6,0x9CF0, 0x61FA,0x9CF1, 0x61F4,0x9CF2, 0x61FF,0x9CF3, 0x61FD,0x9CF4, 0x61FC,0x9CF5, 0x61FE,0x9CF6, 0x6200,0x9CF7, 0x6208,0x9CF8, 0x6209,0x9CF9, 0x620D,0x9CFA, 0x620C,0x9CFB, 0x6214,0x9CFC, 0x621B,0x9D40, 0x621E,0x9D41, 0x6221,0x9D42, 0x622A,0x9D43, 0x622E,0x9D44, 0x6230,0x9D45, 0x6232,0x9D46, 0x6233,0x9D47, 0x6241,0x9D48, 0x624E,0x9D49, 0x625E,0x9D4A, 0x6263,0x9D4B, 0x625B,0x9D4C, 0x6260,0x9D4D, 0x6268,0x9D4E, 0x627C,0x9D4F, 0x6282,0x9D50, 0x6289,0x9D51, 0x627E,0x9D52, 0x6292,0x9D53, 0x6293,0x9D54, 0x6296,0x9D55, 0x62D4,0x9D56, 0x6283,0x9D57, 0x6294,0x9D58, 0x62D7,0x9D59, 0x62D1,0x9D5A, 0x62BB,0x9D5B, 0x62CF,0x9D5C, 0x62FF,0x9D5D, 0x62C6,0x9D5E, 0x64D4,0x9D5F, 0x62C8,0x9D60, 0x62DC,0x9D61, 0x62CC,0x9D62, 0x62CA,0x9D63, 0x62C2,0x9D64, 0x62C7,0x9D65, 0x629B,0x9D66, 0x62C9,0x9D67, 0x630C,0x9D68, 0x62EE,0x9D69, 0x62F1,0x9D6A, 0x6327,0x9D6B, 0x6302,0x9D6C, 0x6308,0x9D6D, 0x62EF,0x9D6E, 0x62F5,0x9D6F, 0x6350,0x9D70, 0x633E,0x9D71, 0x634D,0x9D72, 0x641C,0x9D73, 0x634F,0x9D74, 0x6396,0x9D75, 0x638E,0x9D76, 0x6380,0x9D77, 0x63AB,0x9D78, 0x6376,0x9D79, 0x63A3,0x9D7A, 0x638F,0x9D7B, 0x6389,0x9D7C, 0x639F,0x9D7D, 0x63B5,0x9D7E, 0x636B,0x9D80, 0x6369,0x9D81, 0x63BE,0x9D82, 0x63E9,0x9D83, 0x63C0,0x9D84, 0x63C6,0x9D85, 0x63E3,0x9D86, 0x63C9,0x9D87, 0x63D2,0x9D88, 0x63F6,0x9D89, 0x63C4,0x9D8A, 0x6416,0x9D8B, 0x6434,0x9D8C, 0x6406,0x9D8D, 0x6413,0x9D8E, 0x6426,0x9D8F, 0x6436,0x9D90, 0x651D,0x9D91, 0x6417,0x9D92, 0x6428,0x9D93, 0x640F,0x9D94, 0x6467,0x9D95, 0x646F,0x9D96, 0x6476,0x9D97, 0x644E,0x9D98, 0x652A,0x9D99, 0x6495,0x9D9A, 0x6493,0x9D9B, 0x64A5,0x9D9C, 0x64A9,0x9D9D, 0x6488,0x9D9E, 0x64BC,0x9D9F, 0x64DA,0x9DA0, 0x64D2,0x9DA1, 0x64C5,0x9DA2, 0x64C7,0x9DA3, 0x64BB,0x9DA4, 0x64D8,0x9DA5, 0x64C2,0x9DA6, 0x64F1,0x9DA7, 0x64E7,0x9DA8, 0x8209,0x9DA9, 0x64E0,0x9DAA, 0x64E1,0x9DAB, 0x62AC,0x9DAC, 0x64E3,0x9DAD, 0x64EF,0x9DAE, 0x652C,0x9DAF, 0x64F6,0x9DB0, 0x64F4,0x9DB1, 0x64F2,0x9DB2, 0x64FA,0x9DB3, 0x6500,0x9DB4, 0x64FD,0x9DB5, 0x6518,0x9DB6, 0x651C,0x9DB7, 0x6505,0x9DB8, 0x6524,0x9DB9, 0x6523,0x9DBA, 0x652B,0x9DBB, 0x6534,0x9DBC, 0x6535,0x9DBD, 0x6537,0x9DBE, 0x6536,0x9DBF, 0x6538,0x9DC0, 0x754B,0x9DC1, 0x6548,0x9DC2, 0x6556,0x9DC3, 0x6555,0x9DC4, 0x654D,0x9DC5, 0x6558,0x9DC6, 0x655E,0x9DC7, 0x655D,0x9DC8, 0x6572,0x9DC9, 0x6578,0x9DCA, 0x6582,0x9DCB, 0x6583,0x9DCC, 0x8B8A,0x9DCD, 0x659B,0x9DCE, 0x659F,0x9DCF, 0x65AB,0x9DD0, 0x65B7,0x9DD1, 0x65C3,0x9DD2, 0x65C6,0x9DD3, 0x65C1,0x9DD4, 0x65C4,0x9DD5, 0x65CC,0x9DD6, 0x65D2,0x9DD7, 0x65DB,0x9DD8, 0x65D9,0x9DD9, 0x65E0,0x9DDA, 0x65E1,0x9DDB, 0x65F1,0x9DDC, 0x6772,0x9DDD, 0x660A,0x9DDE, 0x6603,0x9DDF, 0x65FB,0x9DE0, 0x6773,0x9DE1, 0x6635,0x9DE2, 0x6636,0x9DE3, 0x6634,0x9DE4, 0x661C,0x9DE5, 0x664F,0x9DE6, 0x6644,0x9DE7, 0x6649,0x9DE8, 0x6641,0x9DE9, 0x665E,0x9DEA, 0x665D,0x9DEB, 0x6664,0x9DEC, 0x6667,0x9DED, 0x6668,0x9DEE, 0x665F,0x9DEF, 0x6662,0x9DF0, 0x6670,0x9DF1, 0x6683,0x9DF2, 0x6688,0x9DF3, 0x668E,0x9DF4, 0x6689,0x9DF5, 0x6684,0x9DF6, 0x6698,0x9DF7, 0x669D,0x9DF8, 0x66C1,0x9DF9, 0x66B9,0x9DFA, 0x66C9,0x9DFB, 0x66BE,0x9DFC, 0x66BC,0x9E40, 0x66C4,0x9E41, 0x66B8,0x9E42, 0x66D6,0x9E43, 0x66DA,0x9E44, 0x66E0,0x9E45, 0x663F,0x9E46, 0x66E6,0x9E47, 0x66E9,0x9E48, 0x66F0,0x9E49, 0x66F5,0x9E4A, 0x66F7,0x9E4B, 0x670F,0x9E4C, 0x6716,0x9E4D, 0x671E,0x9E4E, 0x6726,0x9E4F, 0x6727,0x9E50, 0x9738,0x9E51, 0x672E,0x9E52, 0x673F,0x9E53, 0x6736,0x9E54, 0x6741,0x9E55, 0x6738,0x9E56, 0x6737,0x9E57, 0x6746,0x9E58, 0x675E,0x9E59, 0x6760,0x9E5A, 0x6759,0x9E5B, 0x6763,0x9E5C, 0x6764,0x9E5D, 0x6789,0x9E5E, 0x6770,0x9E5F, 0x67A9,0x9E60, 0x677C,0x9E61, 0x676A,0x9E62, 0x678C,0x9E63, 0x678B,0x9E64, 0x67A6,0x9E65, 0x67A1,0x9E66, 0x6785,0x9E67, 0x67B7,0x9E68, 0x67EF,0x9E69, 0x67B4,0x9E6A, 0x67EC,0x9E6B, 0x67B3,0x9E6C, 0x67E9,0x9E6D, 0x67B8,0x9E6E, 0x67E4,0x9E6F, 0x67DE,0x9E70, 0x67DD,0x9E71, 0x67E2,0x9E72, 0x67EE,0x9E73, 0x67B9,0x9E74, 0x67CE,0x9E75, 0x67C6,0x9E76, 0x67E7,0x9E77, 0x6A9C,0x9E78, 0x681E,0x9E79, 0x6846,0x9E7A, 0x6829,0x9E7B, 0x6840,0x9E7C, 0x684D,0x9E7D, 0x6832,0x9E7E, 0x684E,0x9E80, 0x68B3,0x9E81, 0x682B,0x9E82, 0x6859,0x9E83, 0x6863,0x9E84, 0x6877,0x9E85, 0x687F,0x9E86, 0x689F,0x9E87, 0x688F,0x9E88, 0x68AD,0x9E89, 0x6894,0x9E8A, 0x689D,0x9E8B, 0x689B,0x9E8C, 0x6883,0x9E8D, 0x6AAE,0x9E8E, 0x68B9,0x9E8F, 0x6874,0x9E90, 0x68B5,0x9E91, 0x68A0,0x9E92, 0x68BA,0x9E93, 0x690F,0x9E94, 0x688D,0x9E95, 0x687E,0x9E96, 0x6901,0x9E97, 0x68CA,0x9E98, 0x6908,0x9E99, 0x68D8,0x9E9A, 0x6922,0x9E9B, 0x6926,0x9E9C, 0x68E1,0x9E9D, 0x690C,0x9E9E, 0x68CD,0x9E9F, 0x68D4,0x9EA0, 0x68E7,0x9EA1, 0x68D5,0x9EA2, 0x6936,0x9EA3, 0x6912,0x9EA4, 0x6904,0x9EA5, 0x68D7,0x9EA6, 0x68E3,0x9EA7, 0x6925,0x9EA8, 0x68F9,0x9EA9, 0x68E0,0x9EAA, 0x68EF,0x9EAB, 0x6928,0x9EAC, 0x692A,0x9EAD, 0x691A,0x9EAE, 0x6923,0x9EAF, 0x6921,0x9EB0, 0x68C6,0x9EB1, 0x6979,0x9EB2, 0x6977,0x9EB3, 0x695C,0x9EB4, 0x6978,0x9EB5, 0x696B,0x9EB6, 0x6954,0x9EB7, 0x697E,0x9EB8, 0x696E,0x9EB9, 0x6939,0x9EBA, 0x6974,0x9EBB, 0x693D,0x9EBC, 0x6959,0x9EBD, 0x6930,0x9EBE, 0x6961,0x9EBF, 0x695E,0x9EC0, 0x695D,0x9EC1, 0x6981,0x9EC2, 0x696A,0x9EC3, 0x69B2,0x9EC4, 0x69AE,0x9EC5, 0x69D0,0x9EC6, 0x69BF,0x9EC7, 0x69C1,0x9EC8, 0x69D3,0x9EC9, 0x69BE,0x9ECA, 0x69CE,0x9ECB, 0x5BE8,0x9ECC, 0x69CA,0x9ECD, 0x69DD,0x9ECE, 0x69BB,0x9ECF, 0x69C3,0x9ED0, 0x69A7,0x9ED1, 0x6A2E,0x9ED2, 0x6991,0x9ED3, 0x69A0,0x9ED4, 0x699C,0x9ED5, 0x6995,0x9ED6, 0x69B4,0x9ED7, 0x69DE,0x9ED8, 0x69E8,0x9ED9, 0x6A02,0x9EDA, 0x6A1B,0x9EDB, 0x69FF,0x9EDC, 0x6B0A,0x9EDD, 0x69F9,0x9EDE, 0x69F2,0x9EDF, 0x69E7,0x9EE0, 0x6A05,0x9EE1, 0x69B1,0x9EE2, 0x6A1E,0x9EE3, 0x69ED,0x9EE4, 0x6A14,0x9EE5, 0x69EB,0x9EE6, 0x6A0A,0x9EE7, 0x6A12,0x9EE8, 0x6AC1,0x9EE9, 0x6A23,0x9EEA, 0x6A13,0x9EEB, 0x6A44,0x9EEC, 0x6A0C,0x9EED, 0x6A72,0x9EEE, 0x6A36,0x9EEF, 0x6A78,0x9EF0, 0x6A47,0x9EF1, 0x6A62,0x9EF2, 0x6A59,0x9EF3, 0x6A66,0x9EF4, 0x6A48,0x9EF5, 0x6A38,0x9EF6, 0x6A22,0x9EF7, 0x6A90,0x9EF8, 0x6A8D,0x9EF9, 0x6AA0,0x9EFA, 0x6A84,0x9EFB, 0x6AA2,0x9EFC, 0x6AA3,0x9F40, 0x6A97,0x9F41, 0x8617,0x9F42, 0x6ABB,0x9F43, 0x6AC3,0x9F44, 0x6AC2,0x9F45, 0x6AB8,0x9F46, 0x6AB3,0x9F47, 0x6AAC,0x9F48, 0x6ADE,0x9F49, 0x6AD1,0x9F4A, 0x6ADF,0x9F4B, 0x6AAA,0x9F4C, 0x6ADA,0x9F4D, 0x6AEA,0x9F4E, 0x6AFB,0x9F4F, 0x6B05,0x9F50, 0x8616,0x9F51, 0x6AFA,0x9F52, 0x6B12,0x9F53, 0x6B16,0x9F54, 0x9B31,0x9F55, 0x6B1F,0x9F56, 0x6B38,0x9F57, 0x6B37,0x9F58, 0x76DC,0x9F59, 0x6B39,0x9F5A, 0x98EE,0x9F5B, 0x6B47,0x9F5C, 0x6B43,0x9F5D, 0x6B49,0x9F5E, 0x6B50,0x9F5F, 0x6B59,0x9F60, 0x6B54,0x9F61, 0x6B5B,0x9F62, 0x6B5F,0x9F63, 0x6B61,0x9F64, 0x6B78,0x9F65, 0x6B79,0x9F66, 0x6B7F,0x9F67, 0x6B80,0x9F68, 0x6B84,0x9F69, 0x6B83,0x9F6A, 0x6B8D,0x9F6B, 0x6B98,0x9F6C, 0x6B95,0x9F6D, 0x6B9E,0x9F6E, 0x6BA4,0x9F6F, 0x6BAA,0x9F70, 0x6BAB,0x9F71, 0x6BAF,0x9F72, 0x6BB2,0x9F73, 0x6BB1,0x9F74, 0x6BB3,0x9F75, 0x6BB7,0x9F76, 0x6BBC,0x9F77, 0x6BC6,0x9F78, 0x6BCB,0x9F79, 0x6BD3,0x9F7A, 0x6BDF,0x9F7B, 0x6BEC,0x9F7C, 0x6BEB,0x9F7D, 0x6BF3,0x9F7E, 0x6BEF,0x9F80, 0x9EBE,0x9F81, 0x6C08,0x9F82, 0x6C13,0x9F83, 0x6C14,0x9F84, 0x6C1B,0x9F85, 0x6C24,0x9F86, 0x6C23,0x9F87, 0x6C5E,0x9F88, 0x6C55,0x9F89, 0x6C62,0x9F8A, 0x6C6A,0x9F8B, 0x6C82,0x9F8C, 0x6C8D,0x9F8D, 0x6C9A,0x9F8E, 0x6C81,0x9F8F, 0x6C9B,0x9F90, 0x6C7E,0x9F91, 0x6C68,0x9F92, 0x6C73,0x9F93, 0x6C92,0x9F94, 0x6C90,0x9F95, 0x6CC4,0x9F96, 0x6CF1,0x9F97, 0x6CD3,0x9F98, 0x6CBD,0x9F99, 0x6CD7,0x9F9A, 0x6CC5,0x9F9B, 0x6CDD,0x9F9C, 0x6CAE,0x9F9D, 0x6CB1,0x9F9E, 0x6CBE,0x9F9F, 0x6CBA,0x9FA0, 0x6CDB,0x9FA1, 0x6CEF,0x9FA2, 0x6CD9,0x9FA3, 0x6CEA,0x9FA4, 0x6D1F,0x9FA5, 0x884D,0x9FA6, 0x6D36,0x9FA7, 0x6D2B,0x9FA8, 0x6D3D,0x9FA9, 0x6D38,0x9FAA, 0x6D19,0x9FAB, 0x6D35,0x9FAC, 0x6D33,0x9FAD, 0x6D12,0x9FAE, 0x6D0C,0x9FAF, 0x6D63,0x9FB0, 0x6D93,0x9FB1, 0x6D64,0x9FB2, 0x6D5A,0x9FB3, 0x6D79,0x9FB4, 0x6D59,0x9FB5, 0x6D8E,0x9FB6, 0x6D95,0x9FB7, 0x6FE4,0x9FB8, 0x6D85,0x9FB9, 0x6DF9,0x9FBA, 0x6E15,0x9FBB, 0x6E0A,0x9FBC, 0x6DB5,0x9FBD, 0x6DC7,0x9FBE, 0x6DE6,0x9FBF, 0x6DB8,0x9FC0, 0x6DC6,0x9FC1, 0x6DEC,0x9FC2, 0x6DDE,0x9FC3, 0x6DCC,0x9FC4, 0x6DE8,0x9FC5, 0x6DD2,0x9FC6, 0x6DC5,0x9FC7, 0x6DFA,0x9FC8, 0x6DD9,0x9FC9, 0x6DE4,0x9FCA, 0x6DD5,0x9FCB, 0x6DEA,0x9FCC, 0x6DEE,0x9FCD, 0x6E2D,0x9FCE, 0x6E6E,0x9FCF, 0x6E2E,0x9FD0, 0x6E19,0x9FD1, 0x6E72,0x9FD2, 0x6E5F,0x9FD3, 0x6E3E,0x9FD4, 0x6E23,0x9FD5, 0x6E6B,0x9FD6, 0x6E2B,0x9FD7, 0x6E76,0x9FD8, 0x6E4D,0x9FD9, 0x6E1F,0x9FDA, 0x6E43,0x9FDB, 0x6E3A,0x9FDC, 0x6E4E,0x9FDD, 0x6E24,0x9FDE, 0x6EFF,0x9FDF, 0x6E1D,0x9FE0, 0x6E38,0x9FE1, 0x6E82,0x9FE2, 0x6EAA,0x9FE3, 0x6E98,0x9FE4, 0x6EC9,0x9FE5, 0x6EB7,0x9FE6, 0x6ED3,0x9FE7, 0x6EBD,0x9FE8, 0x6EAF,0x9FE9, 0x6EC4,0x9FEA, 0x6EB2,0x9FEB, 0x6ED4,0x9FEC, 0x6ED5,0x9FED, 0x6E8F,0x9FEE, 0x6EA5,0x9FEF, 0x6EC2,0x9FF0, 0x6E9F,0x9FF1, 0x6F41,0x9FF2, 0x6F11,0x9FF3, 0x704C,0x9FF4, 0x6EEC,0x9FF5, 0x6EF8,0x9FF6, 0x6EFE,0x9FF7, 0x6F3F,0x9FF8, 0x6EF2,0x9FF9, 0x6F31,0x9FFA, 0x6EEF,0x9FFB, 0x6F32,0x9FFC, 0x6ECC,0xE040, 0x6F3E,0xE041, 0x6F13,0xE042, 0x6EF7,0xE043, 0x6F86,0xE044, 0x6F7A,0xE045, 0x6F78,0xE046, 0x6F81,0xE047, 0x6F80,0xE048, 0x6F6F,0xE049, 0x6F5B,0xE04A, 0x6FF3,0xE04B, 0x6F6D,0xE04C, 0x6F82,0xE04D, 0x6F7C,0xE04E, 0x6F58,0xE04F, 0x6F8E,0xE050, 0x6F91,0xE051, 0x6FC2,0xE052, 0x6F66,0xE053, 0x6FB3,0xE054, 0x6FA3,0xE055, 0x6FA1,0xE056, 0x6FA4,0xE057, 0x6FB9,0xE058, 0x6FC6,0xE059, 0x6FAA,0xE05A, 0x6FDF,0xE05B, 0x6FD5,0xE05C, 0x6FEC,0xE05D, 0x6FD4,0xE05E, 0x6FD8,0xE05F, 0x6FF1,0xE060, 0x6FEE,0xE061, 0x6FDB,0xE062, 0x7009,0xE063, 0x700B,0xE064, 0x6FFA,0xE065, 0x7011,0xE066, 0x7001,0xE067, 0x700F,0xE068, 0x6FFE,0xE069, 0x701B,0xE06A, 0x701A,0xE06B, 0x6F74,0xE06C, 0x701D,0xE06D, 0x7018,0xE06E, 0x701F,0xE06F, 0x7030,0xE070, 0x703E,0xE071, 0x7032,0xE072, 0x7051,0xE073, 0x7063,0xE074, 0x7099,0xE075, 0x7092,0xE076, 0x70AF,0xE077, 0x70F1,0xE078, 0x70AC,0xE079, 0x70B8,0xE07A, 0x70B3,0xE07B, 0x70AE,0xE07C, 0x70DF,0xE07D, 0x70CB,0xE07E, 0x70DD,0xE080, 0x70D9,0xE081, 0x7109,0xE082, 0x70FD,0xE083, 0x711C,0xE084, 0x7119,0xE085, 0x7165,0xE086, 0x7155,0xE087, 0x7188,0xE088, 0x7166,0xE089, 0x7162,0xE08A, 0x714C,0xE08B, 0x7156,0xE08C, 0x716C,0xE08D, 0x718F,0xE08E, 0x71FB,0xE08F, 0x7184,0xE090, 0x7195,0xE091, 0x71A8,0xE092, 0x71AC,0xE093, 0x71D7,0xE094, 0x71B9,0xE095, 0x71BE,0xE096, 0x71D2,0xE097, 0x71C9,0xE098, 0x71D4,0xE099, 0x71CE,0xE09A, 0x71E0,0xE09B, 0x71EC,0xE09C, 0x71E7,0xE09D, 0x71F5,0xE09E, 0x71FC,0xE09F, 0x71F9,0xE0A0, 0x71FF,0xE0A1, 0x720D,0xE0A2, 0x7210,0xE0A3, 0x721B,0xE0A4, 0x7228,0xE0A5, 0x722D,0xE0A6, 0x722C,0xE0A7, 0x7230,0xE0A8, 0x7232,0xE0A9, 0x723B,0xE0AA, 0x723C,0xE0AB, 0x723F,0xE0AC, 0x7240,0xE0AD, 0x7246,0xE0AE, 0x724B,0xE0AF, 0x7258,0xE0B0, 0x7274,0xE0B1, 0x727E,0xE0B2, 0x7282,0xE0B3, 0x7281,0xE0B4, 0x7287,0xE0B5, 0x7292,0xE0B6, 0x7296,0xE0B7, 0x72A2,0xE0B8, 0x72A7,0xE0B9, 0x72B9,0xE0BA, 0x72B2,0xE0BB, 0x72C3,0xE0BC, 0x72C6,0xE0BD, 0x72C4,0xE0BE, 0x72CE,0xE0BF, 0x72D2,0xE0C0, 0x72E2,0xE0C1, 0x72E0,0xE0C2, 0x72E1,0xE0C3, 0x72F9,0xE0C4, 0x72F7,0xE0C5, 0x500F,0xE0C6, 0x7317,0xE0C7, 0x730A,0xE0C8, 0x731C,0xE0C9, 0x7316,0xE0CA, 0x731D,0xE0CB, 0x7334,0xE0CC, 0x732F,0xE0CD, 0x7329,0xE0CE, 0x7325,0xE0CF, 0x733E,0xE0D0, 0x734E,0xE0D1, 0x734F,0xE0D2, 0x9ED8,0xE0D3, 0x7357,0xE0D4, 0x736A,0xE0D5, 0x7368,0xE0D6, 0x7370,0xE0D7, 0x7378,0xE0D8, 0x7375,0xE0D9, 0x737B,0xE0DA, 0x737A,0xE0DB, 0x73C8,0xE0DC, 0x73B3,0xE0DD, 0x73CE,0xE0DE, 0x73BB,0xE0DF, 0x73C0,0xE0E0, 0x73E5,0xE0E1, 0x73EE,0xE0E2, 0x73DE,0xE0E3, 0x74A2,0xE0E4, 0x7405,0xE0E5, 0x746F,0xE0E6, 0x7425,0xE0E7, 0x73F8,0xE0E8, 0x7432,0xE0E9, 0x743A,0xE0EA, 0x7455,0xE0EB, 0x743F,0xE0EC, 0x745F,0xE0ED, 0x7459,0xE0EE, 0x7441,0xE0EF, 0x745C,0xE0F0, 0x7469,0xE0F1, 0x7470,0xE0F2, 0x7463,0xE0F3, 0x746A,0xE0F4, 0x7476,0xE0F5, 0x747E,0xE0F6, 0x748B,0xE0F7, 0x749E,0xE0F8, 0x74A7,0xE0F9, 0x74CA,0xE0FA, 0x74CF,0xE0FB, 0x74D4,0xE0FC, 0x73F1,0xE140, 0x74E0,0xE141, 0x74E3,0xE142, 0x74E7,0xE143, 0x74E9,0xE144, 0x74EE,0xE145, 0x74F2,0xE146, 0x74F0,0xE147, 0x74F1,0xE148, 0x74F8,0xE149, 0x74F7,0xE14A, 0x7504,0xE14B, 0x7503,0xE14C, 0x7505,0xE14D, 0x750C,0xE14E, 0x750E,0xE14F, 0x750D,0xE150, 0x7515,0xE151, 0x7513,0xE152, 0x751E,0xE153, 0x7526,0xE154, 0x752C,0xE155, 0x753C,0xE156, 0x7544,0xE157, 0x754D,0xE158, 0x754A,0xE159, 0x7549,0xE15A, 0x755B,0xE15B, 0x7546,0xE15C, 0x755A,0xE15D, 0x7569,0xE15E, 0x7564,0xE15F, 0x7567,0xE160, 0x756B,0xE161, 0x756D,0xE162, 0x7578,0xE163, 0x7576,0xE164, 0x7586,0xE165, 0x7587,0xE166, 0x7574,0xE167, 0x758A,0xE168, 0x7589,0xE169, 0x7582,0xE16A, 0x7594,0xE16B, 0x759A,0xE16C, 0x759D,0xE16D, 0x75A5,0xE16E, 0x75A3,0xE16F, 0x75C2,0xE170, 0x75B3,0xE171, 0x75C3,0xE172, 0x75B5,0xE173, 0x75BD,0xE174, 0x75B8,0xE175, 0x75BC,0xE176, 0x75B1,0xE177, 0x75CD,0xE178, 0x75CA,0xE179, 0x75D2,0xE17A, 0x75D9,0xE17B, 0x75E3,0xE17C, 0x75DE,0xE17D, 0x75FE,0xE17E, 0x75FF,0xE180, 0x75FC,0xE181, 0x7601,0xE182, 0x75F0,0xE183, 0x75FA,0xE184, 0x75F2,0xE185, 0x75F3,0xE186, 0x760B,0xE187, 0x760D,0xE188, 0x7609,0xE189, 0x761F,0xE18A, 0x7627,0xE18B, 0x7620,0xE18C, 0x7621,0xE18D, 0x7622,0xE18E, 0x7624,0xE18F, 0x7634,0xE190, 0x7630,0xE191, 0x763B,0xE192, 0x7647,0xE193, 0x7648,0xE194, 0x7646,0xE195, 0x765C,0xE196, 0x7658,0xE197, 0x7661,0xE198, 0x7662,0xE199, 0x7668,0xE19A, 0x7669,0xE19B, 0x766A,0xE19C, 0x7667,0xE19D, 0x766C,0xE19E, 0x7670,0xE19F, 0x7672,0xE1A0, 0x7676,0xE1A1, 0x7678,0xE1A2, 0x767C,0xE1A3, 0x7680,0xE1A4, 0x7683,0xE1A5, 0x7688,0xE1A6, 0x768B,0xE1A7, 0x768E,0xE1A8, 0x7696,0xE1A9, 0x7693,0xE1AA, 0x7699,0xE1AB, 0x769A,0xE1AC, 0x76B0,0xE1AD, 0x76B4,0xE1AE, 0x76B8,0xE1AF, 0x76B9,0xE1B0, 0x76BA,0xE1B1, 0x76C2,0xE1B2, 0x76CD,0xE1B3, 0x76D6,0xE1B4, 0x76D2,0xE1B5, 0x76DE,0xE1B6, 0x76E1,0xE1B7, 0x76E5,0xE1B8, 0x76E7,0xE1B9, 0x76EA,0xE1BA, 0x862F,0xE1BB, 0x76FB,0xE1BC, 0x7708,0xE1BD, 0x7707,0xE1BE, 0x7704,0xE1BF, 0x7729,0xE1C0, 0x7724,0xE1C1, 0x771E,0xE1C2, 0x7725,0xE1C3, 0x7726,0xE1C4, 0x771B,0xE1C5, 0x7737,0xE1C6, 0x7738,0xE1C7, 0x7747,0xE1C8, 0x775A,0xE1C9, 0x7768,0xE1CA, 0x776B,0xE1CB, 0x775B,0xE1CC, 0x7765,0xE1CD, 0x777F,0xE1CE, 0x777E,0xE1CF, 0x7779,0xE1D0, 0x778E,0xE1D1, 0x778B,0xE1D2, 0x7791,0xE1D3, 0x77A0,0xE1D4, 0x779E,0xE1D5, 0x77B0,0xE1D6, 0x77B6,0xE1D7, 0x77B9,0xE1D8, 0x77BF,0xE1D9, 0x77BC,0xE1DA, 0x77BD,0xE1DB, 0x77BB,0xE1DC, 0x77C7,0xE1DD, 0x77CD,0xE1DE, 0x77D7,0xE1DF, 0x77DA,0xE1E0, 0x77DC,0xE1E1, 0x77E3,0xE1E2, 0x77EE,0xE1E3, 0x77FC,0xE1E4, 0x780C,0xE1E5, 0x7812,0xE1E6, 0x7926,0xE1E7, 0x7820,0xE1E8, 0x792A,0xE1E9, 0x7845,0xE1EA, 0x788E,0xE1EB, 0x7874,0xE1EC, 0x7886,0xE1ED, 0x787C,0xE1EE, 0x789A,0xE1EF, 0x788C,0xE1F0, 0x78A3,0xE1F1, 0x78B5,0xE1F2, 0x78AA,0xE1F3, 0x78AF,0xE1F4, 0x78D1,0xE1F5, 0x78C6,0xE1F6, 0x78CB,0xE1F7, 0x78D4,0xE1F8, 0x78BE,0xE1F9, 0x78BC,0xE1FA, 0x78C5,0xE1FB, 0x78CA,0xE1FC, 0x78EC,0xE240, 0x78E7,0xE241, 0x78DA,0xE242, 0x78FD,0xE243, 0x78F4,0xE244, 0x7907,0xE245, 0x7912,0xE246, 0x7911,0xE247, 0x7919,0xE248, 0x792C,0xE249, 0x792B,0xE24A, 0x7940,0xE24B, 0x7960,0xE24C, 0x7957,0xE24D, 0x795F,0xE24E, 0x795A,0xE24F, 0x7955,0xE250, 0x7953,0xE251, 0x797A,0xE252, 0x797F,0xE253, 0x798A,0xE254, 0x799D,0xE255, 0x79A7,0xE256, 0x9F4B,0xE257, 0x79AA,0xE258, 0x79AE,0xE259, 0x79B3,0xE25A, 0x79B9,0xE25B, 0x79BA,0xE25C, 0x79C9,0xE25D, 0x79D5,0xE25E, 0x79E7,0xE25F, 0x79EC,0xE260, 0x79E1,0xE261, 0x79E3,0xE262, 0x7A08,0xE263, 0x7A0D,0xE264, 0x7A18,0xE265, 0x7A19,0xE266, 0x7A20,0xE267, 0x7A1F,0xE268, 0x7980,0xE269, 0x7A31,0xE26A, 0x7A3B,0xE26B, 0x7A3E,0xE26C, 0x7A37,0xE26D, 0x7A43,0xE26E, 0x7A57,0xE26F, 0x7A49,0xE270, 0x7A61,0xE271, 0x7A62,0xE272, 0x7A69,0xE273, 0x9F9D,0xE274, 0x7A70,0xE275, 0x7A79,0xE276, 0x7A7D,0xE277, 0x7A88,0xE278, 0x7A97,0xE279, 0x7A95,0xE27A, 0x7A98,0xE27B, 0x7A96,0xE27C, 0x7AA9,0xE27D, 0x7AC8,0xE27E, 0x7AB0,0xE280, 0x7AB6,0xE281, 0x7AC5,0xE282, 0x7AC4,0xE283, 0x7ABF,0xE284, 0x9083,0xE285, 0x7AC7,0xE286, 0x7ACA,0xE287, 0x7ACD,0xE288, 0x7ACF,0xE289, 0x7AD5,0xE28A, 0x7AD3,0xE28B, 0x7AD9,0xE28C, 0x7ADA,0xE28D, 0x7ADD,0xE28E, 0x7AE1,0xE28F, 0x7AE2,0xE290, 0x7AE6,0xE291, 0x7AED,0xE292, 0x7AF0,0xE293, 0x7B02,0xE294, 0x7B0F,0xE295, 0x7B0A,0xE296, 0x7B06,0xE297, 0x7B33,0xE298, 0x7B18,0xE299, 0x7B19,0xE29A, 0x7B1E,0xE29B, 0x7B35,0xE29C, 0x7B28,0xE29D, 0x7B36,0xE29E, 0x7B50,0xE29F, 0x7B7A,0xE2A0, 0x7B04,0xE2A1, 0x7B4D,0xE2A2, 0x7B0B,0xE2A3, 0x7B4C,0xE2A4, 0x7B45,0xE2A5, 0x7B75,0xE2A6, 0x7B65,0xE2A7, 0x7B74,0xE2A8, 0x7B67,0xE2A9, 0x7B70,0xE2AA, 0x7B71,0xE2AB, 0x7B6C,0xE2AC, 0x7B6E,0xE2AD, 0x7B9D,0xE2AE, 0x7B98,0xE2AF, 0x7B9F,0xE2B0, 0x7B8D,0xE2B1, 0x7B9C,0xE2B2, 0x7B9A,0xE2B3, 0x7B8B,0xE2B4, 0x7B92,0xE2B5, 0x7B8F,0xE2B6, 0x7B5D,0xE2B7, 0x7B99,0xE2B8, 0x7BCB,0xE2B9, 0x7BC1,0xE2BA, 0x7BCC,0xE2BB, 0x7BCF,0xE2BC, 0x7BB4,0xE2BD, 0x7BC6,0xE2BE, 0x7BDD,0xE2BF, 0x7BE9,0xE2C0, 0x7C11,0xE2C1, 0x7C14,0xE2C2, 0x7BE6,0xE2C3, 0x7BE5,0xE2C4, 0x7C60,0xE2C5, 0x7C00,0xE2C6, 0x7C07,0xE2C7, 0x7C13,0xE2C8, 0x7BF3,0xE2C9, 0x7BF7,0xE2CA, 0x7C17,0xE2CB, 0x7C0D,0xE2CC, 0x7BF6,0xE2CD, 0x7C23,0xE2CE, 0x7C27,0xE2CF, 0x7C2A,0xE2D0, 0x7C1F,0xE2D1, 0x7C37,0xE2D2, 0x7C2B,0xE2D3, 0x7C3D,0xE2D4, 0x7C4C,0xE2D5, 0x7C43,0xE2D6, 0x7C54,0xE2D7, 0x7C4F,0xE2D8, 0x7C40,0xE2D9, 0x7C50,0xE2DA, 0x7C58,0xE2DB, 0x7C5F,0xE2DC, 0x7C64,0xE2DD, 0x7C56,0xE2DE, 0x7C65,0xE2DF, 0x7C6C,0xE2E0, 0x7C75,0xE2E1, 0x7C83,0xE2E2, 0x7C90,0xE2E3, 0x7CA4,0xE2E4, 0x7CAD,0xE2E5, 0x7CA2,0xE2E6, 0x7CAB,0xE2E7, 0x7CA1,0xE2E8, 0x7CA8,0xE2E9, 0x7CB3,0xE2EA, 0x7CB2,0xE2EB, 0x7CB1,0xE2EC, 0x7CAE,0xE2ED, 0x7CB9,0xE2EE, 0x7CBD,0xE2EF, 0x7CC0,0xE2F0, 0x7CC5,0xE2F1, 0x7CC2,0xE2F2, 0x7CD8,0xE2F3, 0x7CD2,0xE2F4, 0x7CDC,0xE2F5, 0x7CE2,0xE2F6, 0x9B3B,0xE2F7, 0x7CEF,0xE2F8, 0x7CF2,0xE2F9, 0x7CF4,0xE2FA, 0x7CF6,0xE2FB, 0x7CFA,0xE2FC, 0x7D06,0xE340, 0x7D02,0xE341, 0x7D1C,0xE342, 0x7D15,0xE343, 0x7D0A,0xE344, 0x7D45,0xE345, 0x7D4B,0xE346, 0x7D2E,0xE347, 0x7D32,0xE348, 0x7D3F,0xE349, 0x7D35,0xE34A, 0x7D46,0xE34B, 0x7D73,0xE34C, 0x7D56,0xE34D, 0x7D4E,0xE34E, 0x7D72,0xE34F, 0x7D68,0xE350, 0x7D6E,0xE351, 0x7D4F,0xE352, 0x7D63,0xE353, 0x7D93,0xE354, 0x7D89,0xE355, 0x7D5B,0xE356, 0x7D8F,0xE357, 0x7D7D,0xE358, 0x7D9B,0xE359, 0x7DBA,0xE35A, 0x7DAE,0xE35B, 0x7DA3,0xE35C, 0x7DB5,0xE35D, 0x7DC7,0xE35E, 0x7DBD,0xE35F, 0x7DAB,0xE360, 0x7E3D,0xE361, 0x7DA2,0xE362, 0x7DAF,0xE363, 0x7DDC,0xE364, 0x7DB8,0xE365, 0x7D9F,0xE366, 0x7DB0,0xE367, 0x7DD8,0xE368, 0x7DDD,0xE369, 0x7DE4,0xE36A, 0x7DDE,0xE36B, 0x7DFB,0xE36C, 0x7DF2,0xE36D, 0x7DE1,0xE36E, 0x7E05,0xE36F, 0x7E0A,0xE370, 0x7E23,0xE371, 0x7E21,0xE372, 0x7E12,0xE373, 0x7E31,0xE374, 0x7E1F,0xE375, 0x7E09,0xE376, 0x7E0B,0xE377, 0x7E22,0xE378, 0x7E46,0xE379, 0x7E66,0xE37A, 0x7E3B,0xE37B, 0x7E35,0xE37C, 0x7E39,0xE37D, 0x7E43,0xE37E, 0x7E37,0xE380, 0x7E32,0xE381, 0x7E3A,0xE382, 0x7E67,0xE383, 0x7E5D,0xE384, 0x7E56,0xE385, 0x7E5E,0xE386, 0x7E59,0xE387, 0x7E5A,0xE388, 0x7E79,0xE389, 0x7E6A,0xE38A, 0x7E69,0xE38B, 0x7E7C,0xE38C, 0x7E7B,0xE38D, 0x7E83,0xE38E, 0x7DD5,0xE38F, 0x7E7D,0xE390, 0x8FAE,0xE391, 0x7E7F,0xE392, 0x7E88,0xE393, 0x7E89,0xE394, 0x7E8C,0xE395, 0x7E92,0xE396, 0x7E90,0xE397, 0x7E93,0xE398, 0x7E94,0xE399, 0x7E96,0xE39A, 0x7E8E,0xE39B, 0x7E9B,0xE39C, 0x7E9C,0xE39D, 0x7F38,0xE39E, 0x7F3A,0xE39F, 0x7F45,0xE3A0, 0x7F4C,0xE3A1, 0x7F4D,0xE3A2, 0x7F4E,0xE3A3, 0x7F50,0xE3A4, 0x7F51,0xE3A5, 0x7F55,0xE3A6, 0x7F54,0xE3A7, 0x7F58,0xE3A8, 0x7F5F,0xE3A9, 0x7F60,0xE3AA, 0x7F68,0xE3AB, 0x7F69,0xE3AC, 0x7F67,0xE3AD, 0x7F78,0xE3AE, 0x7F82,0xE3AF, 0x7F86,0xE3B0, 0x7F83,0xE3B1, 0x7F88,0xE3B2, 0x7F87,0xE3B3, 0x7F8C,0xE3B4, 0x7F94,0xE3B5, 0x7F9E,0xE3B6, 0x7F9D,0xE3B7, 0x7F9A,0xE3B8, 0x7FA3,0xE3B9, 0x7FAF,0xE3BA, 0x7FB2,0xE3BB, 0x7FB9,0xE3BC, 0x7FAE,0xE3BD, 0x7FB6,0xE3BE, 0x7FB8,0xE3BF, 0x8B71,0xE3C0, 0x7FC5,0xE3C1, 0x7FC6,0xE3C2, 0x7FCA,0xE3C3, 0x7FD5,0xE3C4, 0x7FD4,0xE3C5, 0x7FE1,0xE3C6, 0x7FE6,0xE3C7, 0x7FE9,0xE3C8, 0x7FF3,0xE3C9, 0x7FF9,0xE3CA, 0x98DC,0xE3CB, 0x8006,0xE3CC, 0x8004,0xE3CD, 0x800B,0xE3CE, 0x8012,0xE3CF, 0x8018,0xE3D0, 0x8019,0xE3D1, 0x801C,0xE3D2, 0x8021,0xE3D3, 0x8028,0xE3D4, 0x803F,0xE3D5, 0x803B,0xE3D6, 0x804A,0xE3D7, 0x8046,0xE3D8, 0x8052,0xE3D9, 0x8058,0xE3DA, 0x805A,0xE3DB, 0x805F,0xE3DC, 0x8062,0xE3DD, 0x8068,0xE3DE, 0x8073,0xE3DF, 0x8072,0xE3E0, 0x8070,0xE3E1, 0x8076,0xE3E2, 0x8079,0xE3E3, 0x807D,0xE3E4, 0x807F,0xE3E5, 0x8084,0xE3E6, 0x8086,0xE3E7, 0x8085,0xE3E8, 0x809B,0xE3E9, 0x8093,0xE3EA, 0x809A,0xE3EB, 0x80AD,0xE3EC, 0x5190,0xE3ED, 0x80AC,0xE3EE, 0x80DB,0xE3EF, 0x80E5,0xE3F0, 0x80D9,0xE3F1, 0x80DD,0xE3F2, 0x80C4,0xE3F3, 0x80DA,0xE3F4, 0x80D6,0xE3F5, 0x8109,0xE3F6, 0x80EF,0xE3F7, 0x80F1,0xE3F8, 0x811B,0xE3F9, 0x8129,0xE3FA, 0x8123,0xE3FB, 0x812F,0xE3FC, 0x814B,0xE440, 0x968B,0xE441, 0x8146,0xE442, 0x813E,0xE443, 0x8153,0xE444, 0x8151,0xE445, 0x80FC,0xE446, 0x8171,0xE447, 0x816E,0xE448, 0x8165,0xE449, 0x8166,0xE44A, 0x8174,0xE44B, 0x8183,0xE44C, 0x8188,0xE44D, 0x818A,0xE44E, 0x8180,0xE44F, 0x8182,0xE450, 0x81A0,0xE451, 0x8195,0xE452, 0x81A4,0xE453, 0x81A3,0xE454, 0x815F,0xE455, 0x8193,0xE456, 0x81A9,0xE457, 0x81B0,0xE458, 0x81B5,0xE459, 0x81BE,0xE45A, 0x81B8,0xE45B, 0x81BD,0xE45C, 0x81C0,0xE45D, 0x81C2,0xE45E, 0x81BA,0xE45F, 0x81C9,0xE460, 0x81CD,0xE461, 0x81D1,0xE462, 0x81D9,0xE463, 0x81D8,0xE464, 0x81C8,0xE465, 0x81DA,0xE466, 0x81DF,0xE467, 0x81E0,0xE468, 0x81E7,0xE469, 0x81FA,0xE46A, 0x81FB,0xE46B, 0x81FE,0xE46C, 0x8201,0xE46D, 0x8202,0xE46E, 0x8205,0xE46F, 0x8207,0xE470, 0x820A,0xE471, 0x820D,0xE472, 0x8210,0xE473, 0x8216,0xE474, 0x8229,0xE475, 0x822B,0xE476, 0x8238,0xE477, 0x8233,0xE478, 0x8240,0xE479, 0x8259,0xE47A, 0x8258,0xE47B, 0x825D,0xE47C, 0x825A,0xE47D, 0x825F,0xE47E, 0x8264,0xE480, 0x8262,0xE481, 0x8268,0xE482, 0x826A,0xE483, 0x826B,0xE484, 0x822E,0xE485, 0x8271,0xE486, 0x8277,0xE487, 0x8278,0xE488, 0x827E,0xE489, 0x828D,0xE48A, 0x8292,0xE48B, 0x82AB,0xE48C, 0x829F,0xE48D, 0x82BB,0xE48E, 0x82AC,0xE48F, 0x82E1,0xE490, 0x82E3,0xE491, 0x82DF,0xE492, 0x82D2,0xE493, 0x82F4,0xE494, 0x82F3,0xE495, 0x82FA,0xE496, 0x8393,0xE497, 0x8303,0xE498, 0x82FB,0xE499, 0x82F9,0xE49A, 0x82DE,0xE49B, 0x8306,0xE49C, 0x82DC,0xE49D, 0x8309,0xE49E, 0x82D9,0xE49F, 0x8335,0xE4A0, 0x8334,0xE4A1, 0x8316,0xE4A2, 0x8332,0xE4A3, 0x8331,0xE4A4, 0x8340,0xE4A5, 0x8339,0xE4A6, 0x8350,0xE4A7, 0x8345,0xE4A8, 0x832F,0xE4A9, 0x832B,0xE4AA, 0x8317,0xE4AB, 0x8318,0xE4AC, 0x8385,0xE4AD, 0x839A,0xE4AE, 0x83AA,0xE4AF, 0x839F,0xE4B0, 0x83A2,0xE4B1, 0x8396,0xE4B2, 0x8323,0xE4B3, 0x838E,0xE4B4, 0x8387,0xE4B5, 0x838A,0xE4B6, 0x837C,0xE4B7, 0x83B5,0xE4B8, 0x8373,0xE4B9, 0x8375,0xE4BA, 0x83A0,0xE4BB, 0x8389,0xE4BC, 0x83A8,0xE4BD, 0x83F4,0xE4BE, 0x8413,0xE4BF, 0x83EB,0xE4C0, 0x83CE,0xE4C1, 0x83FD,0xE4C2, 0x8403,0xE4C3, 0x83D8,0xE4C4, 0x840B,0xE4C5, 0x83C1,0xE4C6, 0x83F7,0xE4C7, 0x8407,0xE4C8, 0x83E0,0xE4C9, 0x83F2,0xE4CA, 0x840D,0xE4CB, 0x8422,0xE4CC, 0x8420,0xE4CD, 0x83BD,0xE4CE, 0x8438,0xE4CF, 0x8506,0xE4D0, 0x83FB,0xE4D1, 0x846D,0xE4D2, 0x842A,0xE4D3, 0x843C,0xE4D4, 0x855A,0xE4D5, 0x8484,0xE4D6, 0x8477,0xE4D7, 0x846B,0xE4D8, 0x84AD,0xE4D9, 0x846E,0xE4DA, 0x8482,0xE4DB, 0x8469,0xE4DC, 0x8446,0xE4DD, 0x842C,0xE4DE, 0x846F,0xE4DF, 0x8479,0xE4E0, 0x8435,0xE4E1, 0x84CA,0xE4E2, 0x8462,0xE4E3, 0x84B9,0xE4E4, 0x84BF,0xE4E5, 0x849F,0xE4E6, 0x84D9,0xE4E7, 0x84CD,0xE4E8, 0x84BB,0xE4E9, 0x84DA,0xE4EA, 0x84D0,0xE4EB, 0x84C1,0xE4EC, 0x84C6,0xE4ED, 0x84D6,0xE4EE, 0x84A1,0xE4EF, 0x8521,0xE4F0, 0x84FF,0xE4F1, 0x84F4,0xE4F2, 0x8517,0xE4F3, 0x8518,0xE4F4, 0x852C,0xE4F5, 0x851F,0xE4F6, 0x8515,0xE4F7, 0x8514,0xE4F8, 0x84FC,0xE4F9, 0x8540,0xE4FA, 0x8563,0xE4FB, 0x8558,0xE4FC, 0x8548,0xE540, 0x8541,0xE541, 0x8602,0xE542, 0x854B,0xE543, 0x8555,0xE544, 0x8580,0xE545, 0x85A4,0xE546, 0x8588,0xE547, 0x8591,0xE548, 0x858A,0xE549, 0x85A8,0xE54A, 0x856D,0xE54B, 0x8594,0xE54C, 0x859B,0xE54D, 0x85EA,0xE54E, 0x8587,0xE54F, 0x859C,0xE550, 0x8577,0xE551, 0x857E,0xE552, 0x8590,0xE553, 0x85C9,0xE554, 0x85BA,0xE555, 0x85CF,0xE556, 0x85B9,0xE557, 0x85D0,0xE558, 0x85D5,0xE559, 0x85DD,0xE55A, 0x85E5,0xE55B, 0x85DC,0xE55C, 0x85F9,0xE55D, 0x860A,0xE55E, 0x8613,0xE55F, 0x860B,0xE560, 0x85FE,0xE561, 0x85FA,0xE562, 0x8606,0xE563, 0x8622,0xE564, 0x861A,0xE565, 0x8630,0xE566, 0x863F,0xE567, 0x864D,0xE568, 0x4E55,0xE569, 0x8654,0xE56A, 0x865F,0xE56B, 0x8667,0xE56C, 0x8671,0xE56D, 0x8693,0xE56E, 0x86A3,0xE56F, 0x86A9,0xE570, 0x86AA,0xE571, 0x868B,0xE572, 0x868C,0xE573, 0x86B6,0xE574, 0x86AF,0xE575, 0x86C4,0xE576, 0x86C6,0xE577, 0x86B0,0xE578, 0x86C9,0xE579, 0x8823,0xE57A, 0x86AB,0xE57B, 0x86D4,0xE57C, 0x86DE,0xE57D, 0x86E9,0xE57E, 0x86EC,0xE580, 0x86DF,0xE581, 0x86DB,0xE582, 0x86EF,0xE583, 0x8712,0xE584, 0x8706,0xE585, 0x8708,0xE586, 0x8700,0xE587, 0x8703,0xE588, 0x86FB,0xE589, 0x8711,0xE58A, 0x8709,0xE58B, 0x870D,0xE58C, 0x86F9,0xE58D, 0x870A,0xE58E, 0x8734,0xE58F, 0x873F,0xE590, 0x8737,0xE591, 0x873B,0xE592, 0x8725,0xE593, 0x8729,0xE594, 0x871A,0xE595, 0x8760,0xE596, 0x875F,0xE597, 0x8778,0xE598, 0x874C,0xE599, 0x874E,0xE59A, 0x8774,0xE59B, 0x8757,0xE59C, 0x8768,0xE59D, 0x876E,0xE59E, 0x8759,0xE59F, 0x8753,0xE5A0, 0x8763,0xE5A1, 0x876A,0xE5A2, 0x8805,0xE5A3, 0x87A2,0xE5A4, 0x879F,0xE5A5, 0x8782,0xE5A6, 0x87AF,0xE5A7, 0x87CB,0xE5A8, 0x87BD,0xE5A9, 0x87C0,0xE5AA, 0x87D0,0xE5AB, 0x96D6,0xE5AC, 0x87AB,0xE5AD, 0x87C4,0xE5AE, 0x87B3,0xE5AF, 0x87C7,0xE5B0, 0x87C6,0xE5B1, 0x87BB,0xE5B2, 0x87EF,0xE5B3, 0x87F2,0xE5B4, 0x87E0,0xE5B5, 0x880F,0xE5B6, 0x880D,0xE5B7, 0x87FE,0xE5B8, 0x87F6,0xE5B9, 0x87F7,0xE5BA, 0x880E,0xE5BB, 0x87D2,0xE5BC, 0x8811,0xE5BD, 0x8816,0xE5BE, 0x8815,0xE5BF, 0x8822,0xE5C0, 0x8821,0xE5C1, 0x8831,0xE5C2, 0x8836,0xE5C3, 0x8839,0xE5C4, 0x8827,0xE5C5, 0x883B,0xE5C6, 0x8844,0xE5C7, 0x8842,0xE5C8, 0x8852,0xE5C9, 0x8859,0xE5CA, 0x885E,0xE5CB, 0x8862,0xE5CC, 0x886B,0xE5CD, 0x8881,0xE5CE, 0x887E,0xE5CF, 0x889E,0xE5D0, 0x8875,0xE5D1, 0x887D,0xE5D2, 0x88B5,0xE5D3, 0x8872,0xE5D4, 0x8882,0xE5D5, 0x8897,0xE5D6, 0x8892,0xE5D7, 0x88AE,0xE5D8, 0x8899,0xE5D9, 0x88A2,0xE5DA, 0x888D,0xE5DB, 0x88A4,0xE5DC, 0x88B0,0xE5DD, 0x88BF,0xE5DE, 0x88B1,0xE5DF, 0x88C3,0xE5E0, 0x88C4,0xE5E1, 0x88D4,0xE5E2, 0x88D8,0xE5E3, 0x88D9,0xE5E4, 0x88DD,0xE5E5, 0x88F9,0xE5E6, 0x8902,0xE5E7, 0x88FC,0xE5E8, 0x88F4,0xE5E9, 0x88E8,0xE5EA, 0x88F2,0xE5EB, 0x8904,0xE5EC, 0x890C,0xE5ED, 0x890A,0xE5EE, 0x8913,0xE5EF, 0x8943,0xE5F0, 0x891E,0xE5F1, 0x8925,0xE5F2, 0x892A,0xE5F3, 0x892B,0xE5F4, 0x8941,0xE5F5, 0x8944,0xE5F6, 0x893B,0xE5F7, 0x8936,0xE5F8, 0x8938,0xE5F9, 0x894C,0xE5FA, 0x891D,0xE5FB, 0x8960,0xE5FC, 0x895E,0xE640, 0x8966,0xE641, 0x8964,0xE642, 0x896D,0xE643, 0x896A,0xE644, 0x896F,0xE645, 0x8974,0xE646, 0x8977,0xE647, 0x897E,0xE648, 0x8983,0xE649, 0x8988,0xE64A, 0x898A,0xE64B, 0x8993,0xE64C, 0x8998,0xE64D, 0x89A1,0xE64E, 0x89A9,0xE64F, 0x89A6,0xE650, 0x89AC,0xE651, 0x89AF,0xE652, 0x89B2,0xE653, 0x89BA,0xE654, 0x89BD,0xE655, 0x89BF,0xE656, 0x89C0,0xE657, 0x89DA,0xE658, 0x89DC,0xE659, 0x89DD,0xE65A, 0x89E7,0xE65B, 0x89F4,0xE65C, 0x89F8,0xE65D, 0x8A03,0xE65E, 0x8A16,0xE65F, 0x8A10,0xE660, 0x8A0C,0xE661, 0x8A1B,0xE662, 0x8A1D,0xE663, 0x8A25,0xE664, 0x8A36,0xE665, 0x8A41,0xE666, 0x8A5B,0xE667, 0x8A52,0xE668, 0x8A46,0xE669, 0x8A48,0xE66A, 0x8A7C,0xE66B, 0x8A6D,0xE66C, 0x8A6C,0xE66D, 0x8A62,0xE66E, 0x8A85,0xE66F, 0x8A82,0xE670, 0x8A84,0xE671, 0x8AA8,0xE672, 0x8AA1,0xE673, 0x8A91,0xE674, 0x8AA5,0xE675, 0x8AA6,0xE676, 0x8A9A,0xE677, 0x8AA3,0xE678, 0x8AC4,0xE679, 0x8ACD,0xE67A, 0x8AC2,0xE67B, 0x8ADA,0xE67C, 0x8AEB,0xE67D, 0x8AF3,0xE67E, 0x8AE7,0xE680, 0x8AE4,0xE681, 0x8AF1,0xE682, 0x8B14,0xE683, 0x8AE0,0xE684, 0x8AE2,0xE685, 0x8AF7,0xE686, 0x8ADE,0xE687, 0x8ADB,0xE688, 0x8B0C,0xE689, 0x8B07,0xE68A, 0x8B1A,0xE68B, 0x8AE1,0xE68C, 0x8B16,0xE68D, 0x8B10,0xE68E, 0x8B17,0xE68F, 0x8B20,0xE690, 0x8B33,0xE691, 0x97AB,0xE692, 0x8B26,0xE693, 0x8B2B,0xE694, 0x8B3E,0xE695, 0x8B28,0xE696, 0x8B41,0xE697, 0x8B4C,0xE698, 0x8B4F,0xE699, 0x8B4E,0xE69A, 0x8B49,0xE69B, 0x8B56,0xE69C, 0x8B5B,0xE69D, 0x8B5A,0xE69E, 0x8B6B,0xE69F, 0x8B5F,0xE6A0, 0x8B6C,0xE6A1, 0x8B6F,0xE6A2, 0x8B74,0xE6A3, 0x8B7D,0xE6A4, 0x8B80,0xE6A5, 0x8B8C,0xE6A6, 0x8B8E,0xE6A7, 0x8B92,0xE6A8, 0x8B93,0xE6A9, 0x8B96,0xE6AA, 0x8B99,0xE6AB, 0x8B9A,0xE6AC, 0x8C3A,0xE6AD, 0x8C41,0xE6AE, 0x8C3F,0xE6AF, 0x8C48,0xE6B0, 0x8C4C,0xE6B1, 0x8C4E,0xE6B2, 0x8C50,0xE6B3, 0x8C55,0xE6B4, 0x8C62,0xE6B5, 0x8C6C,0xE6B6, 0x8C78,0xE6B7, 0x8C7A,0xE6B8, 0x8C82,0xE6B9, 0x8C89,0xE6BA, 0x8C85,0xE6BB, 0x8C8A,0xE6BC, 0x8C8D,0xE6BD, 0x8C8E,0xE6BE, 0x8C94,0xE6BF, 0x8C7C,0xE6C0, 0x8C98,0xE6C1, 0x621D,0xE6C2, 0x8CAD,0xE6C3, 0x8CAA,0xE6C4, 0x8CBD,0xE6C5, 0x8CB2,0xE6C6, 0x8CB3,0xE6C7, 0x8CAE,0xE6C8, 0x8CB6,0xE6C9, 0x8CC8,0xE6CA, 0x8CC1,0xE6CB, 0x8CE4,0xE6CC, 0x8CE3,0xE6CD, 0x8CDA,0xE6CE, 0x8CFD,0xE6CF, 0x8CFA,0xE6D0, 0x8CFB,0xE6D1, 0x8D04,0xE6D2, 0x8D05,0xE6D3, 0x8D0A,0xE6D4, 0x8D07,0xE6D5, 0x8D0F,0xE6D6, 0x8D0D,0xE6D7, 0x8D10,0xE6D8, 0x9F4E,0xE6D9, 0x8D13,0xE6DA, 0x8CCD,0xE6DB, 0x8D14,0xE6DC, 0x8D16,0xE6DD, 0x8D67,0xE6DE, 0x8D6D,0xE6DF, 0x8D71,0xE6E0, 0x8D73,0xE6E1, 0x8D81,0xE6E2, 0x8D99,0xE6E3, 0x8DC2,0xE6E4, 0x8DBE,0xE6E5, 0x8DBA,0xE6E6, 0x8DCF,0xE6E7, 0x8DDA,0xE6E8, 0x8DD6,0xE6E9, 0x8DCC,0xE6EA, 0x8DDB,0xE6EB, 0x8DCB,0xE6EC, 0x8DEA,0xE6ED, 0x8DEB,0xE6EE, 0x8DDF,0xE6EF, 0x8DE3,0xE6F0, 0x8DFC,0xE6F1, 0x8E08,0xE6F2, 0x8E09,0xE6F3, 0x8DFF,0xE6F4, 0x8E1D,0xE6F5, 0x8E1E,0xE6F6, 0x8E10,0xE6F7, 0x8E1F,0xE6F8, 0x8E42,0xE6F9, 0x8E35,0xE6FA, 0x8E30,0xE6FB, 0x8E34,0xE6FC, 0x8E4A,0xE740, 0x8E47,0xE741, 0x8E49,0xE742, 0x8E4C,0xE743, 0x8E50,0xE744, 0x8E48,0xE745, 0x8E59,0xE746, 0x8E64,0xE747, 0x8E60,0xE748, 0x8E2A,0xE749, 0x8E63,0xE74A, 0x8E55,0xE74B, 0x8E76,0xE74C, 0x8E72,0xE74D, 0x8E7C,0xE74E, 0x8E81,0xE74F, 0x8E87,0xE750, 0x8E85,0xE751, 0x8E84,0xE752, 0x8E8B,0xE753, 0x8E8A,0xE754, 0x8E93,0xE755, 0x8E91,0xE756, 0x8E94,0xE757, 0x8E99,0xE758, 0x8EAA,0xE759, 0x8EA1,0xE75A, 0x8EAC,0xE75B, 0x8EB0,0xE75C, 0x8EC6,0xE75D, 0x8EB1,0xE75E, 0x8EBE,0xE75F, 0x8EC5,0xE760, 0x8EC8,0xE761, 0x8ECB,0xE762, 0x8EDB,0xE763, 0x8EE3,0xE764, 0x8EFC,0xE765, 0x8EFB,0xE766, 0x8EEB,0xE767, 0x8EFE,0xE768, 0x8F0A,0xE769, 0x8F05,0xE76A, 0x8F15,0xE76B, 0x8F12,0xE76C, 0x8F19,0xE76D, 0x8F13,0xE76E, 0x8F1C,0xE76F, 0x8F1F,0xE770, 0x8F1B,0xE771, 0x8F0C,0xE772, 0x8F26,0xE773, 0x8F33,0xE774, 0x8F3B,0xE775, 0x8F39,0xE776, 0x8F45,0xE777, 0x8F42,0xE778, 0x8F3E,0xE779, 0x8F4C,0xE77A, 0x8F49,0xE77B, 0x8F46,0xE77C, 0x8F4E,0xE77D, 0x8F57,0xE77E, 0x8F5C,0xE780, 0x8F62,0xE781, 0x8F63,0xE782, 0x8F64,0xE783, 0x8F9C,0xE784, 0x8F9F,0xE785, 0x8FA3,0xE786, 0x8FAD,0xE787, 0x8FAF,0xE788, 0x8FB7,0xE789, 0x8FDA,0xE78A, 0x8FE5,0xE78B, 0x8FE2,0xE78C, 0x8FEA,0xE78D, 0x8FEF,0xE78E, 0x9087,0xE78F, 0x8FF4,0xE790, 0x9005,0xE791, 0x8FF9,0xE792, 0x8FFA,0xE793, 0x9011,0xE794, 0x9015,0xE795, 0x9021,0xE796, 0x900D,0xE797, 0x901E,0xE798, 0x9016,0xE799, 0x900B,0xE79A, 0x9027,0xE79B, 0x9036,0xE79C, 0x9035,0xE79D, 0x9039,0xE79E, 0x8FF8,0xE79F, 0x904F,0xE7A0, 0x9050,0xE7A1, 0x9051,0xE7A2, 0x9052,0xE7A3, 0x900E,0xE7A4, 0x9049,0xE7A5, 0x903E,0xE7A6, 0x9056,0xE7A7, 0x9058,0xE7A8, 0x905E,0xE7A9, 0x9068,0xE7AA, 0x906F,0xE7AB, 0x9076,0xE7AC, 0x96A8,0xE7AD, 0x9072,0xE7AE, 0x9082,0xE7AF, 0x907D,0xE7B0, 0x9081,0xE7B1, 0x9080,0xE7B2, 0x908A,0xE7B3, 0x9089,0xE7B4, 0x908F,0xE7B5, 0x90A8,0xE7B6, 0x90AF,0xE7B7, 0x90B1,0xE7B8, 0x90B5,0xE7B9, 0x90E2,0xE7BA, 0x90E4,0xE7BB, 0x6248,0xE7BC, 0x90DB,0xE7BD, 0x9102,0xE7BE, 0x9112,0xE7BF, 0x9119,0xE7C0, 0x9132,0xE7C1, 0x9130,0xE7C2, 0x914A,0xE7C3, 0x9156,0xE7C4, 0x9158,0xE7C5, 0x9163,0xE7C6, 0x9165,0xE7C7, 0x9169,0xE7C8, 0x9173,0xE7C9, 0x9172,0xE7CA, 0x918B,0xE7CB, 0x9189,0xE7CC, 0x9182,0xE7CD, 0x91A2,0xE7CE, 0x91AB,0xE7CF, 0x91AF,0xE7D0, 0x91AA,0xE7D1, 0x91B5,0xE7D2, 0x91B4,0xE7D3, 0x91BA,0xE7D4, 0x91C0,0xE7D5, 0x91C1,0xE7D6, 0x91C9,0xE7D7, 0x91CB,0xE7D8, 0x91D0,0xE7D9, 0x91D6,0xE7DA, 0x91DF,0xE7DB, 0x91E1,0xE7DC, 0x91DB,0xE7DD, 0x91FC,0xE7DE, 0x91F5,0xE7DF, 0x91F6,0xE7E0, 0x921E,0xE7E1, 0x91FF,0xE7E2, 0x9214,0xE7E3, 0x922C,0xE7E4, 0x9215,0xE7E5, 0x9211,0xE7E6, 0x925E,0xE7E7, 0x9257,0xE7E8, 0x9245,0xE7E9, 0x9249,0xE7EA, 0x9264,0xE7EB, 0x9248,0xE7EC, 0x9295,0xE7ED, 0x923F,0xE7EE, 0x924B,0xE7EF, 0x9250,0xE7F0, 0x929C,0xE7F1, 0x9296,0xE7F2, 0x9293,0xE7F3, 0x929B,0xE7F4, 0x925A,0xE7F5, 0x92CF,0xE7F6, 0x92B9,0xE7F7, 0x92B7,0xE7F8, 0x92E9,0xE7F9, 0x930F,0xE7FA, 0x92FA,0xE7FB, 0x9344,0xE7FC, 0x932E,0xE840, 0x9319,0xE841, 0x9322,0xE842, 0x931A,0xE843, 0x9323,0xE844, 0x933A,0xE845, 0x9335,0xE846, 0x933B,0xE847, 0x935C,0xE848, 0x9360,0xE849, 0x937C,0xE84A, 0x936E,0xE84B, 0x9356,0xE84C, 0x93B0,0xE84D, 0x93AC,0xE84E, 0x93AD,0xE84F, 0x9394,0xE850, 0x93B9,0xE851, 0x93D6,0xE852, 0x93D7,0xE853, 0x93E8,0xE854, 0x93E5,0xE855, 0x93D8,0xE856, 0x93C3,0xE857, 0x93DD,0xE858, 0x93D0,0xE859, 0x93C8,0xE85A, 0x93E4,0xE85B, 0x941A,0xE85C, 0x9414,0xE85D, 0x9413,0xE85E, 0x9403,0xE85F, 0x9407,0xE860, 0x9410,0xE861, 0x9436,0xE862, 0x942B,0xE863, 0x9435,0xE864, 0x9421,0xE865, 0x943A,0xE866, 0x9441,0xE867, 0x9452,0xE868, 0x9444,0xE869, 0x945B,0xE86A, 0x9460,0xE86B, 0x9462,0xE86C, 0x945E,0xE86D, 0x946A,0xE86E, 0x9229,0xE86F, 0x9470,0xE870, 0x9475,0xE871, 0x9477,0xE872, 0x947D,0xE873, 0x945A,0xE874, 0x947C,0xE875, 0x947E,0xE876, 0x9481,0xE877, 0x947F,0xE878, 0x9582,0xE879, 0x9587,0xE87A, 0x958A,0xE87B, 0x9594,0xE87C, 0x9596,0xE87D, 0x9598,0xE87E, 0x9599,0xE880, 0x95A0,0xE881, 0x95A8,0xE882, 0x95A7,0xE883, 0x95AD,0xE884, 0x95BC,0xE885, 0x95BB,0xE886, 0x95B9,0xE887, 0x95BE,0xE888, 0x95CA,0xE889, 0x6FF6,0xE88A, 0x95C3,0xE88B, 0x95CD,0xE88C, 0x95CC,0xE88D, 0x95D5,0xE88E, 0x95D4,0xE88F, 0x95D6,0xE890, 0x95DC,0xE891, 0x95E1,0xE892, 0x95E5,0xE893, 0x95E2,0xE894, 0x9621,0xE895, 0x9628,0xE896, 0x962E,0xE897, 0x962F,0xE898, 0x9642,0xE899, 0x964C,0xE89A, 0x964F,0xE89B, 0x964B,0xE89C, 0x9677,0xE89D, 0x965C,0xE89E, 0x965E,0xE89F, 0x965D,0xE8A0, 0x965F,0xE8A1, 0x9666,0xE8A2, 0x9672,0xE8A3, 0x966C,0xE8A4, 0x968D,0xE8A5, 0x9698,0xE8A6, 0x9695,0xE8A7, 0x9697,0xE8A8, 0x96AA,0xE8A9, 0x96A7,0xE8AA, 0x96B1,0xE8AB, 0x96B2,0xE8AC, 0x96B0,0xE8AD, 0x96B4,0xE8AE, 0x96B6,0xE8AF, 0x96B8,0xE8B0, 0x96B9,0xE8B1, 0x96CE,0xE8B2, 0x96CB,0xE8B3, 0x96C9,0xE8B4, 0x96CD,0xE8B5, 0x894D,0xE8B6, 0x96DC,0xE8B7, 0x970D,0xE8B8, 0x96D5,0xE8B9, 0x96F9,0xE8BA, 0x9704,0xE8BB, 0x9706,0xE8BC, 0x9708,0xE8BD, 0x9713,0xE8BE, 0x970E,0xE8BF, 0x9711,0xE8C0, 0x970F,0xE8C1, 0x9716,0xE8C2, 0x9719,0xE8C3, 0x9724,0xE8C4, 0x972A,0xE8C5, 0x9730,0xE8C6, 0x9739,0xE8C7, 0x973D,0xE8C8, 0x973E,0xE8C9, 0x9744,0xE8CA, 0x9746,0xE8CB, 0x9748,0xE8CC, 0x9742,0xE8CD, 0x9749,0xE8CE, 0x975C,0xE8CF, 0x9760,0xE8D0, 0x9764,0xE8D1, 0x9766,0xE8D2, 0x9768,0xE8D3, 0x52D2,0xE8D4, 0x976B,0xE8D5, 0x9771,0xE8D6, 0x9779,0xE8D7, 0x9785,0xE8D8, 0x977C,0xE8D9, 0x9781,0xE8DA, 0x977A,0xE8DB, 0x9786,0xE8DC, 0x978B,0xE8DD, 0x978F,0xE8DE, 0x9790,0xE8DF, 0x979C,0xE8E0, 0x97A8,0xE8E1, 0x97A6,0xE8E2, 0x97A3,0xE8E3, 0x97B3,0xE8E4, 0x97B4,0xE8E5, 0x97C3,0xE8E6, 0x97C6,0xE8E7, 0x97C8,0xE8E8, 0x97CB,0xE8E9, 0x97DC,0xE8EA, 0x97ED,0xE8EB, 0x9F4F,0xE8EC, 0x97F2,0xE8ED, 0x7ADF,0xE8EE, 0x97F6,0xE8EF, 0x97F5,0xE8F0, 0x980F,0xE8F1, 0x980C,0xE8F2, 0x9838,0xE8F3, 0x9824,0xE8F4, 0x9821,0xE8F5, 0x9837,0xE8F6, 0x983D,0xE8F7, 0x9846,0xE8F8, 0x984F,0xE8F9, 0x984B,0xE8FA, 0x986B,0xE8FB, 0x986F,0xE8FC, 0x9870,0xE940, 0x9871,0xE941, 0x9874,0xE942, 0x9873,0xE943, 0x98AA,0xE944, 0x98AF,0xE945, 0x98B1,0xE946, 0x98B6,0xE947, 0x98C4,0xE948, 0x98C3,0xE949, 0x98C6,0xE94A, 0x98E9,0xE94B, 0x98EB,0xE94C, 0x9903,0xE94D, 0x9909,0xE94E, 0x9912,0xE94F, 0x9914,0xE950, 0x9918,0xE951, 0x9921,0xE952, 0x991D,0xE953, 0x991E,0xE954, 0x9924,0xE955, 0x9920,0xE956, 0x992C,0xE957, 0x992E,0xE958, 0x993D,0xE959, 0x993E,0xE95A, 0x9942,0xE95B, 0x9949,0xE95C, 0x9945,0xE95D, 0x9950,0xE95E, 0x994B,0xE95F, 0x9951,0xE960, 0x9952,0xE961, 0x994C,0xE962, 0x9955,0xE963, 0x9997,0xE964, 0x9998,0xE965, 0x99A5,0xE966, 0x99AD,0xE967, 0x99AE,0xE968, 0x99BC,0xE969, 0x99DF,0xE96A, 0x99DB,0xE96B, 0x99DD,0xE96C, 0x99D8,0xE96D, 0x99D1,0xE96E, 0x99ED,0xE96F, 0x99EE,0xE970, 0x99F1,0xE971, 0x99F2,0xE972, 0x99FB,0xE973, 0x99F8,0xE974, 0x9A01,0xE975, 0x9A0F,0xE976, 0x9A05,0xE977, 0x99E2,0xE978, 0x9A19,0xE979, 0x9A2B,0xE97A, 0x9A37,0xE97B, 0x9A45,0xE97C, 0x9A42,0xE97D, 0x9A40,0xE97E, 0x9A43,0xE980, 0x9A3E,0xE981, 0x9A55,0xE982, 0x9A4D,0xE983, 0x9A5B,0xE984, 0x9A57,0xE985, 0x9A5F,0xE986, 0x9A62,0xE987, 0x9A65,0xE988, 0x9A64,0xE989, 0x9A69,0xE98A, 0x9A6B,0xE98B, 0x9A6A,0xE98C, 0x9AAD,0xE98D, 0x9AB0,0xE98E, 0x9ABC,0xE98F, 0x9AC0,0xE990, 0x9ACF,0xE991, 0x9AD1,0xE992, 0x9AD3,0xE993, 0x9AD4,0xE994, 0x9ADE,0xE995, 0x9ADF,0xE996, 0x9AE2,0xE997, 0x9AE3,0xE998, 0x9AE6,0xE999, 0x9AEF,0xE99A, 0x9AEB,0xE99B, 0x9AEE,0xE99C, 0x9AF4,0xE99D, 0x9AF1,0xE99E, 0x9AF7,0xE99F, 0x9AFB,0xE9A0, 0x9B06,0xE9A1, 0x9B18,0xE9A2, 0x9B1A,0xE9A3, 0x9B1F,0xE9A4, 0x9B22,0xE9A5, 0x9B23,0xE9A6, 0x9B25,0xE9A7, 0x9B27,0xE9A8, 0x9B28,0xE9A9, 0x9B29,0xE9AA, 0x9B2A,0xE9AB, 0x9B2E,0xE9AC, 0x9B2F,0xE9AD, 0x9B32,0xE9AE, 0x9B44,0xE9AF, 0x9B43,0xE9B0, 0x9B4F,0xE9B1, 0x9B4D,0xE9B2, 0x9B4E,0xE9B3, 0x9B51,0xE9B4, 0x9B58,0xE9B5, 0x9B74,0xE9B6, 0x9B93,0xE9B7, 0x9B83,0xE9B8, 0x9B91,0xE9B9, 0x9B96,0xE9BA, 0x9B97,0xE9BB, 0x9B9F,0xE9BC, 0x9BA0,0xE9BD, 0x9BA8,0xE9BE, 0x9BB4,0xE9BF, 0x9BC0,0xE9C0, 0x9BCA,0xE9C1, 0x9BB9,0xE9C2, 0x9BC6,0xE9C3, 0x9BCF,0xE9C4, 0x9BD1,0xE9C5, 0x9BD2,0xE9C6, 0x9BE3,0xE9C7, 0x9BE2,0xE9C8, 0x9BE4,0xE9C9, 0x9BD4,0xE9CA, 0x9BE1,0xE9CB, 0x9C3A,0xE9CC, 0x9BF2,0xE9CD, 0x9BF1,0xE9CE, 0x9BF0,0xE9CF, 0x9C15,0xE9D0, 0x9C14,0xE9D1, 0x9C09,0xE9D2, 0x9C13,0xE9D3, 0x9C0C,0xE9D4, 0x9C06,0xE9D5, 0x9C08,0xE9D6, 0x9C12,0xE9D7, 0x9C0A,0xE9D8, 0x9C04,0xE9D9, 0x9C2E,0xE9DA, 0x9C1B,0xE9DB, 0x9C25,0xE9DC, 0x9C24,0xE9DD, 0x9C21,0xE9DE, 0x9C30,0xE9DF, 0x9C47,0xE9E0, 0x9C32,0xE9E1, 0x9C46,0xE9E2, 0x9C3E,0xE9E3, 0x9C5A,0xE9E4, 0x9C60,0xE9E5, 0x9C67,0xE9E6, 0x9C76,0xE9E7, 0x9C78,0xE9E8, 0x9CE7,0xE9E9, 0x9CEC,0xE9EA, 0x9CF0,0xE9EB, 0x9D09,0xE9EC, 0x9D08,0xE9ED, 0x9CEB,0xE9EE, 0x9D03,0xE9EF, 0x9D06,0xE9F0, 0x9D2A,0xE9F1, 0x9D26,0xE9F2, 0x9DAF,0xE9F3, 0x9D23,0xE9F4, 0x9D1F,0xE9F5, 0x9D44,0xE9F6, 0x9D15,0xE9F7, 0x9D12,0xE9F8, 0x9D41,0xE9F9, 0x9D3F,0xE9FA, 0x9D3E,0xE9FB, 0x9D46,0xE9FC, 0x9D48,0xEA40, 0x9D5D,0xEA41, 0x9D5E,0xEA42, 0x9D64,0xEA43, 0x9D51,0xEA44, 0x9D50,0xEA45, 0x9D59,0xEA46, 0x9D72,0xEA47, 0x9D89,0xEA48, 0x9D87,0xEA49, 0x9DAB,0xEA4A, 0x9D6F,0xEA4B, 0x9D7A,0xEA4C, 0x9D9A,0xEA4D, 0x9DA4,0xEA4E, 0x9DA9,0xEA4F, 0x9DB2,0xEA50, 0x9DC4,0xEA51, 0x9DC1,0xEA52, 0x9DBB,0xEA53, 0x9DB8,0xEA54, 0x9DBA,0xEA55, 0x9DC6,0xEA56, 0x9DCF,0xEA57, 0x9DC2,0xEA58, 0x9DD9,0xEA59, 0x9DD3,0xEA5A, 0x9DF8,0xEA5B, 0x9DE6,0xEA5C, 0x9DED,0xEA5D, 0x9DEF,0xEA5E, 0x9DFD,0xEA5F, 0x9E1A,0xEA60, 0x9E1B,0xEA61, 0x9E1E,0xEA62, 0x9E75,0xEA63, 0x9E79,0xEA64, 0x9E7D,0xEA65, 0x9E81,0xEA66, 0x9E88,0xEA67, 0x9E8B,0xEA68, 0x9E8C,0xEA69, 0x9E92,0xEA6A, 0x9E95,0xEA6B, 0x9E91,0xEA6C, 0x9E9D,0xEA6D, 0x9EA5,0xEA6E, 0x9EA9,0xEA6F, 0x9EB8,0xEA70, 0x9EAA,0xEA71, 0x9EAD,0xEA72, 0x9761,0xEA73, 0x9ECC,0xEA74, 0x9ECE,0xEA75, 0x9ECF,0xEA76, 0x9ED0,0xEA77, 0x9ED4,0xEA78, 0x9EDC,0xEA79, 0x9EDE,0xEA7A, 0x9EDD,0xEA7B, 0x9EE0,0xEA7C, 0x9EE5,0xEA7D, 0x9EE8,0xEA7E, 0x9EEF,0xEA80, 0x9EF4,0xEA81, 0x9EF6,0xEA82, 0x9EF7,0xEA83, 0x9EF9,0xEA84, 0x9EFB,0xEA85, 0x9EFC,0xEA86, 0x9EFD,0xEA87, 0x9F07,0xEA88, 0x9F08,0xEA89, 0x76B7,0xEA8A, 0x9F15,0xEA8B, 0x9F21,0xEA8C, 0x9F2C,0xEA8D, 0x9F3E,0xEA8E, 0x9F4A,0xEA8F, 0x9F52,0xEA90, 0x9F54,0xEA91, 0x9F63,0xEA92, 0x9F5F,0xEA93, 0x9F60,0xEA94, 0x9F61,0xEA95, 0x9F66,0xEA96, 0x9F67,0xEA97, 0x9F6C,0xEA98, 0x9F6A,0xEA99, 0x9F77,0xEA9A, 0x9F72,0xEA9B, 0x9F76,0xEA9C, 0x9F95,0xEA9D, 0x9F9C,0xEA9E, 0x9FA0,0xEA9F, 0x582F,0xEAA0, 0x69C7,0xEAA1, 0x9059,0xEAA2, 0x7464,0xEAA3, 0x51DC,0xEAA4, 0x7199,0xED40, 0x7E8A,0xED41, 0x891C,0xED42, 0x9348,0xED43, 0x9288,0xED44, 0x84DC,0xED45, 0x4FC9,0xED46, 0x70BB,0xED47, 0x6631,0xED48, 0x68C8,0xED49, 0x92F9,0xED4A, 0x66FB,0xED4B, 0x5F45,0xED4C, 0x4E28,0xED4D, 0x4EE1,0xED4E, 0x4EFC,0xED4F, 0x4F00,0xED50, 0x4F03,0xED51, 0x4F39,0xED52, 0x4F56,0xED53, 0x4F92,0xED54, 0x4F8A,0xED55, 0x4F9A,0xED56, 0x4F94,0xED57, 0x4FCD,0xED58, 0x5040,0xED59, 0x5022,0xED5A, 0x4FFF,0xED5B, 0x501E,0xED5C, 0x5046,0xED5D, 0x5070,0xED5E, 0x5042,0xED5F, 0x5094,0xED60, 0x50F4,0xED61, 0x50D8,0xED62, 0x514A,0xED63, 0x5164,0xED64, 0x519D,0xED65, 0x51BE,0xED66, 0x51EC,0xED67, 0x5215,0xED68, 0x529C,0xED69, 0x52A6,0xED6A, 0x52C0,0xED6B, 0x52DB,0xED6C, 0x5300,0xED6D, 0x5307,0xED6E, 0x5324,0xED6F, 0x5372,0xED70, 0x5393,0xED71, 0x53B2,0xED72, 0x53DD,0xED73, 0xFA0E,0xED74, 0x549C,0xED75, 0x548A,0xED76, 0x54A9,0xED77, 0x54FF,0xED78, 0x5586,0xED79, 0x5759,0xED7A, 0x5765,0xED7B, 0x57AC,0xED7C, 0x57C8,0xED7D, 0x57C7,0xED7E, 0xFA0F,0xED80, 0xFA10,0xED81, 0x589E,0xED82, 0x58B2,0xED83, 0x590B,0xED84, 0x5953,0xED85, 0x595B,0xED86, 0x595D,0xED87, 0x5963,0xED88, 0x59A4,0xED89, 0x59BA,0xED8A, 0x5B56,0xED8B, 0x5BC0,0xED8C, 0x752F,0xED8D, 0x5BD8,0xED8E, 0x5BEC,0xED8F, 0x5C1E,0xED90, 0x5CA6,0xED91, 0x5CBA,0xED92, 0x5CF5,0xED93, 0x5D27,0xED94, 0x5D53,0xED95, 0xFA11,0xED96, 0x5D42,0xED97, 0x5D6D,0xED98, 0x5DB8,0xED99, 0x5DB9,0xED9A, 0x5DD0,0xED9B, 0x5F21,0xED9C, 0x5F34,0xED9D, 0x5F67,0xED9E, 0x5FB7,0xED9F, 0x5FDE,0xEDA0, 0x605D,0xEDA1, 0x6085,0xEDA2, 0x608A,0xEDA3, 0x60DE,0xEDA4, 0x60D5,0xEDA5, 0x6120,0xEDA6, 0x60F2,0xEDA7, 0x6111,0xEDA8, 0x6137,0xEDA9, 0x6130,0xEDAA, 0x6198,0xEDAB, 0x6213,0xEDAC, 0x62A6,0xEDAD, 0x63F5,0xEDAE, 0x6460,0xEDAF, 0x649D,0xEDB0, 0x64CE,0xEDB1, 0x654E,0xEDB2, 0x6600,0xEDB3, 0x6615,0xEDB4, 0x663B,0xEDB5, 0x6609,0xEDB6, 0x662E,0xEDB7, 0x661E,0xEDB8, 0x6624,0xEDB9, 0x6665,0xEDBA, 0x6657,0xEDBB, 0x6659,0xEDBC, 0xFA12,0xEDBD, 0x6673,0xEDBE, 0x6699,0xEDBF, 0x66A0,0xEDC0, 0x66B2,0xEDC1, 0x66BF,0xEDC2, 0x66FA,0xEDC3, 0x670E,0xEDC4, 0xF929,0xEDC5, 0x6766,0xEDC6, 0x67BB,0xEDC7, 0x6852,0xEDC8, 0x67C0,0xEDC9, 0x6801,0xEDCA, 0x6844,0xEDCB, 0x68CF,0xEDCC, 0xFA13,0xEDCD, 0x6968,0xEDCE, 0xFA14,0xEDCF, 0x6998,0xEDD0, 0x69E2,0xEDD1, 0x6A30,0xEDD2, 0x6A6B,0xEDD3, 0x6A46,0xEDD4, 0x6A73,0xEDD5, 0x6A7E,0xEDD6, 0x6AE2,0xEDD7, 0x6AE4,0xEDD8, 0x6BD6,0xEDD9, 0x6C3F,0xEDDA, 0x6C5C,0xEDDB, 0x6C86,0xEDDC, 0x6C6F,0xEDDD, 0x6CDA,0xEDDE, 0x6D04,0xEDDF, 0x6D87,0xEDE0, 0x6D6F,0xEDE1, 0x6D96,0xEDE2, 0x6DAC,0xEDE3, 0x6DCF,0xEDE4, 0x6DF8,0xEDE5, 0x6DF2,0xEDE6, 0x6DFC,0xEDE7, 0x6E39,0xEDE8, 0x6E5C,0xEDE9, 0x6E27,0xEDEA, 0x6E3C,0xEDEB, 0x6EBF,0xEDEC, 0x6F88,0xEDED, 0x6FB5,0xEDEE, 0x6FF5,0xEDEF, 0x7005,0xEDF0, 0x7007,0xEDF1, 0x7028,0xEDF2, 0x7085,0xEDF3, 0x70AB,0xEDF4, 0x710F,0xEDF5, 0x7104,0xEDF6, 0x715C,0xEDF7, 0x7146,0xEDF8, 0x7147,0xEDF9, 0xFA15,0xEDFA, 0x71C1,0xEDFB, 0x71FE,0xEDFC, 0x72B1,0xEE40, 0x72BE,0xEE41, 0x7324,0xEE42, 0xFA16,0xEE43, 0x7377,0xEE44, 0x73BD,0xEE45, 0x73C9,0xEE46, 0x73D6,0xEE47, 0x73E3,0xEE48, 0x73D2,0xEE49, 0x7407,0xEE4A, 0x73F5,0xEE4B, 0x7426,0xEE4C, 0x742A,0xEE4D, 0x7429,0xEE4E, 0x742E,0xEE4F, 0x7462,0xEE50, 0x7489,0xEE51, 0x749F,0xEE52, 0x7501,0xEE53, 0x756F,0xEE54, 0x7682,0xEE55, 0x769C,0xEE56, 0x769E,0xEE57, 0x769B,0xEE58, 0x76A6,0xEE59, 0xFA17,0xEE5A, 0x7746,0xEE5B, 0x52AF,0xEE5C, 0x7821,0xEE5D, 0x784E,0xEE5E, 0x7864,0xEE5F, 0x787A,0xEE60, 0x7930,0xEE61, 0xFA18,0xEE62, 0xFA19,0xEE63, 0xFA1A,0xEE64, 0x7994,0xEE65, 0xFA1B,0xEE66, 0x799B,0xEE67, 0x7AD1,0xEE68, 0x7AE7,0xEE69, 0xFA1C,0xEE6A, 0x7AEB,0xEE6B, 0x7B9E,0xEE6C, 0xFA1D,0xEE6D, 0x7D48,0xEE6E, 0x7D5C,0xEE6F, 0x7DB7,0xEE70, 0x7DA0,0xEE71, 0x7DD6,0xEE72, 0x7E52,0xEE73, 0x7F47,0xEE74, 0x7FA1,0xEE75, 0xFA1E,0xEE76, 0x8301,0xEE77, 0x8362,0xEE78, 0x837F,0xEE79, 0x83C7,0xEE7A, 0x83F6,0xEE7B, 0x8448,0xEE7C, 0x84B4,0xEE7D, 0x8553,0xEE7E, 0x8559,0xEE80, 0x856B,0xEE81, 0xFA1F,0xEE82, 0x85B0,0xEE83, 0xFA20,0xEE84, 0xFA21,0xEE85, 0x8807,0xEE86, 0x88F5,0xEE87, 0x8A12,0xEE88, 0x8A37,0xEE89, 0x8A79,0xEE8A, 0x8AA7,0xEE8B, 0x8ABE,0xEE8C, 0x8ADF,0xEE8D, 0xFA22,0xEE8E, 0x8AF6,0xEE8F, 0x8B53,0xEE90, 0x8B7F,0xEE91, 0x8CF0,0xEE92, 0x8CF4,0xEE93, 0x8D12,0xEE94, 0x8D76,0xEE95, 0xFA23,0xEE96, 0x8ECF,0xEE97, 0xFA24,0xEE98, 0xFA25,0xEE99, 0x9067,0xEE9A, 0x90DE,0xEE9B, 0xFA26,0xEE9C, 0x9115,0xEE9D, 0x9127,0xEE9E, 0x91DA,0xEE9F, 0x91D7,0xEEA0, 0x91DE,0xEEA1, 0x91ED,0xEEA2, 0x91EE,0xEEA3, 0x91E4,0xEEA4, 0x91E5,0xEEA5, 0x9206,0xEEA6, 0x9210,0xEEA7, 0x920A,0xEEA8, 0x923A,0xEEA9, 0x9240,0xEEAA, 0x923C,0xEEAB, 0x924E,0xEEAC, 0x9259,0xEEAD, 0x9251,0xEEAE, 0x9239,0xEEAF, 0x9267,0xEEB0, 0x92A7,0xEEB1, 0x9277,0xEEB2, 0x9278,0xEEB3, 0x92E7,0xEEB4, 0x92D7,0xEEB5, 0x92D9,0xEEB6, 0x92D0,0xEEB7, 0xFA27,0xEEB8, 0x92D5,0xEEB9, 0x92E0,0xEEBA, 0x92D3,0xEEBB, 0x9325,0xEEBC, 0x9321,0xEEBD, 0x92FB,0xEEBE, 0xFA28,0xEEBF, 0x931E,0xEEC0, 0x92FF,0xEEC1, 0x931D,0xEEC2, 0x9302,0xEEC3, 0x9370,0xEEC4, 0x9357,0xEEC5, 0x93A4,0xEEC6, 0x93C6,0xEEC7, 0x93DE,0xEEC8, 0x93F8,0xEEC9, 0x9431,0xEECA, 0x9445,0xEECB, 0x9448,0xEECC, 0x9592,0xEECD, 0xF9DC,0xEECE, 0xFA29,0xEECF, 0x969D,0xEED0, 0x96AF,0xEED1, 0x9733,0xEED2, 0x973B,0xEED3, 0x9743,0xEED4, 0x974D,0xEED5, 0x974F,0xEED6, 0x9751,0xEED7, 0x9755,0xEED8, 0x9857,0xEED9, 0x9865,0xEEDA, 0xFA2A,0xEEDB, 0xFA2B,0xEEDC, 0x9927,0xEEDD, 0xFA2C,0xEEDE, 0x999E,0xEEDF, 0x9A4E,0xEEE0, 0x9AD9,0xEEE1, 0x9ADC,0xEEE2, 0x9B75,0xEEE3, 0x9B72,0xEEE4, 0x9B8F,0xEEE5, 0x9BB1,0xEEE6, 0x9BBB,0xEEE7, 0x9C00,0xEEE8, 0x9D70,0xEEE9, 0x9D6B,0xEEEA, 0xFA2D,0xEEEB, 0x9E19,0xEEEC, 0x9ED1,0xEEEF, 0x2170,0xEEF0, 0x2171,0xEEF1, 0x2172,0xEEF2, 0x2173,0xEEF3, 0x2174,0xEEF4, 0x2175,0xEEF5, 0x2176,0xEEF6, 0x2177,0xEEF7, 0x2178,0xEEF8, 0x2179,0xEEF9, 0xFFE2,0xEEFA, 0xFFE4,0xEEFB, 0xFF07,0xEEFC, 0xFF02,0xFA40, 0x2170,0xFA41, 0x2171,0xFA42, 0x2172,0xFA43, 0x2173,0xFA44, 0x2174,0xFA45, 0x2175,0xFA46, 0x2176,0xFA47, 0x2177,0xFA48, 0x2178,0xFA49, 0x2179,0xFA4A, 0x2160,0xFA4B, 0x2161,0xFA4C, 0x2162,0xFA4D, 0x2163,0xFA4E, 0x2164,0xFA4F, 0x2165,0xFA50, 0x2166,0xFA51, 0x2167,0xFA52, 0x2168,0xFA53, 0x2169,0xFA54, 0xFFE2,0xFA55, 0xFFE4,0xFA56, 0xFF07,0xFA57, 0xFF02,0xFA58, 0x3231,0xFA59, 0x2116,0xFA5A, 0x2121,0xFA5B, 0x2235,0xFA5C, 0x7E8A,0xFA5D, 0x891C,0xFA5E, 0x9348,0xFA5F, 0x9288,0xFA60, 0x84DC,0xFA61, 0x4FC9,0xFA62, 0x70BB,0xFA63, 0x6631,0xFA64, 0x68C8,0xFA65, 0x92F9,0xFA66, 0x66FB,0xFA67, 0x5F45,0xFA68, 0x4E28,0xFA69, 0x4EE1,0xFA6A, 0x4EFC,0xFA6B, 0x4F00,0xFA6C, 0x4F03,0xFA6D, 0x4F39,0xFA6E, 0x4F56,0xFA6F, 0x4F92,0xFA70, 0x4F8A,0xFA71, 0x4F9A,0xFA72, 0x4F94,0xFA73, 0x4FCD,0xFA74, 0x5040,0xFA75, 0x5022,0xFA76, 0x4FFF,0xFA77, 0x501E,0xFA78, 0x5046,0xFA79, 0x5070,0xFA7A, 0x5042,0xFA7B, 0x5094,0xFA7C, 0x50F4,0xFA7D, 0x50D8,0xFA7E, 0x514A,0xFA80, 0x5164,0xFA81, 0x519D,0xFA82, 0x51BE,0xFA83, 0x51EC,0xFA84, 0x5215,0xFA85, 0x529C,0xFA86, 0x52A6,0xFA87, 0x52C0,0xFA88, 0x52DB,0xFA89, 0x5300,0xFA8A, 0x5307,0xFA8B, 0x5324,0xFA8C, 0x5372,0xFA8D, 0x5393,0xFA8E, 0x53B2,0xFA8F, 0x53DD,0xFA90, 0xFA0E,0xFA91, 0x549C,0xFA92, 0x548A,0xFA93, 0x54A9,0xFA94, 0x54FF,0xFA95, 0x5586,0xFA96, 0x5759,0xFA97, 0x5765,0xFA98, 0x57AC,0xFA99, 0x57C8,0xFA9A, 0x57C7,0xFA9B, 0xFA0F,0xFA9C, 0xFA10,0xFA9D, 0x589E,0xFA9E, 0x58B2,0xFA9F, 0x590B,0xFAA0, 0x5953,0xFAA1, 0x595B,0xFAA2, 0x595D,0xFAA3, 0x5963,0xFAA4, 0x59A4,0xFAA5, 0x59BA,0xFAA6, 0x5B56,0xFAA7, 0x5BC0,0xFAA8, 0x752F,0xFAA9, 0x5BD8,0xFAAA, 0x5BEC,0xFAAB, 0x5C1E,0xFAAC, 0x5CA6,0xFAAD, 0x5CBA,0xFAAE, 0x5CF5,0xFAAF, 0x5D27,0xFAB0, 0x5D53,0xFAB1, 0xFA11,0xFAB2, 0x5D42,0xFAB3, 0x5D6D,0xFAB4, 0x5DB8,0xFAB5, 0x5DB9,0xFAB6, 0x5DD0,0xFAB7, 0x5F21,0xFAB8, 0x5F34,0xFAB9, 0x5F67,0xFABA, 0x5FB7,0xFABB, 0x5FDE,0xFABC, 0x605D,0xFABD, 0x6085,0xFABE, 0x608A,0xFABF, 0x60DE,0xFAC0, 0x60D5,0xFAC1, 0x6120,0xFAC2, 0x60F2,0xFAC3, 0x6111,0xFAC4, 0x6137,0xFAC5, 0x6130,0xFAC6, 0x6198,0xFAC7, 0x6213,0xFAC8, 0x62A6,0xFAC9, 0x63F5,0xFACA, 0x6460,0xFACB, 0x649D,0xFACC, 0x64CE,0xFACD, 0x654E,0xFACE, 0x6600,0xFACF, 0x6615,0xFAD0, 0x663B,0xFAD1, 0x6609,0xFAD2, 0x662E,0xFAD3, 0x661E,0xFAD4, 0x6624,0xFAD5, 0x6665,0xFAD6, 0x6657,0xFAD7, 0x6659,0xFAD8, 0xFA12,0xFAD9, 0x6673,0xFADA, 0x6699,0xFADB, 0x66A0,0xFADC, 0x66B2,0xFADD, 0x66BF,0xFADE, 0x66FA,0xFADF, 0x670E,0xFAE0, 0xF929,0xFAE1, 0x6766,0xFAE2, 0x67BB,0xFAE3, 0x6852,0xFAE4, 0x67C0,0xFAE5, 0x6801,0xFAE6, 0x6844,0xFAE7, 0x68CF,0xFAE8, 0xFA13,0xFAE9, 0x6968,0xFAEA, 0xFA14,0xFAEB, 0x6998,0xFAEC, 0x69E2,0xFAED, 0x6A30,0xFAEE, 0x6A6B,0xFAEF, 0x6A46,0xFAF0, 0x6A73,0xFAF1, 0x6A7E,0xFAF2, 0x6AE2,0xFAF3, 0x6AE4,0xFAF4, 0x6BD6,0xFAF5, 0x6C3F,0xFAF6, 0x6C5C,0xFAF7, 0x6C86,0xFAF8, 0x6C6F,0xFAF9, 0x6CDA,0xFAFA, 0x6D04,0xFAFB, 0x6D87,0xFAFC, 0x6D6F,0xFB40, 0x6D96,0xFB41, 0x6DAC,0xFB42, 0x6DCF,0xFB43, 0x6DF8,0xFB44, 0x6DF2,0xFB45, 0x6DFC,0xFB46, 0x6E39,0xFB47, 0x6E5C,0xFB48, 0x6E27,0xFB49, 0x6E3C,0xFB4A, 0x6EBF,0xFB4B, 0x6F88,0xFB4C, 0x6FB5,0xFB4D, 0x6FF5,0xFB4E, 0x7005,0xFB4F, 0x7007,0xFB50, 0x7028,0xFB51, 0x7085,0xFB52, 0x70AB,0xFB53, 0x710F,0xFB54, 0x7104,0xFB55, 0x715C,0xFB56, 0x7146,0xFB57, 0x7147,0xFB58, 0xFA15,0xFB59, 0x71C1,0xFB5A, 0x71FE,0xFB5B, 0x72B1,0xFB5C, 0x72BE,0xFB5D, 0x7324,0xFB5E, 0xFA16,0xFB5F, 0x7377,0xFB60, 0x73BD,0xFB61, 0x73C9,0xFB62, 0x73D6,0xFB63, 0x73E3,0xFB64, 0x73D2,0xFB65, 0x7407,0xFB66, 0x73F5,0xFB67, 0x7426,0xFB68, 0x742A,0xFB69, 0x7429,0xFB6A, 0x742E,0xFB6B, 0x7462,0xFB6C, 0x7489,0xFB6D, 0x749F,0xFB6E, 0x7501,0xFB6F, 0x756F,0xFB70, 0x7682,0xFB71, 0x769C,0xFB72, 0x769E,0xFB73, 0x769B,0xFB74, 0x76A6,0xFB75, 0xFA17,0xFB76, 0x7746,0xFB77, 0x52AF,0xFB78, 0x7821,0xFB79, 0x784E,0xFB7A, 0x7864,0xFB7B, 0x787A,0xFB7C, 0x7930,0xFB7D, 0xFA18,0xFB7E, 0xFA19,0xFB80, 0xFA1A,0xFB81, 0x7994,0xFB82, 0xFA1B,0xFB83, 0x799B,0xFB84, 0x7AD1,0xFB85, 0x7AE7,0xFB86, 0xFA1C,0xFB87, 0x7AEB,0xFB88, 0x7B9E,0xFB89, 0xFA1D,0xFB8A, 0x7D48,0xFB8B, 0x7D5C,0xFB8C, 0x7DB7,0xFB8D, 0x7DA0,0xFB8E, 0x7DD6,0xFB8F, 0x7E52,0xFB90, 0x7F47,0xFB91, 0x7FA1,0xFB92, 0xFA1E,0xFB93, 0x8301,0xFB94, 0x8362,0xFB95, 0x837F,0xFB96, 0x83C7,0xFB97, 0x83F6,0xFB98, 0x8448,0xFB99, 0x84B4,0xFB9A, 0x8553,0xFB9B, 0x8559,0xFB9C, 0x856B,0xFB9D, 0xFA1F,0xFB9E, 0x85B0,0xFB9F, 0xFA20,0xFBA0, 0xFA21,0xFBA1, 0x8807,0xFBA2, 0x88F5,0xFBA3, 0x8A12,0xFBA4, 0x8A37,0xFBA5, 0x8A79,0xFBA6, 0x8AA7,0xFBA7, 0x8ABE,0xFBA8, 0x8ADF,0xFBA9, 0xFA22,0xFBAA, 0x8AF6,0xFBAB, 0x8B53,0xFBAC, 0x8B7F,0xFBAD, 0x8CF0,0xFBAE, 0x8CF4,0xFBAF, 0x8D12,0xFBB0, 0x8D76,0xFBB1, 0xFA23,0xFBB2, 0x8ECF,0xFBB3, 0xFA24,0xFBB4, 0xFA25,0xFBB5, 0x9067,0xFBB6, 0x90DE,0xFBB7, 0xFA26,0xFBB8, 0x9115,0xFBB9, 0x9127,0xFBBA, 0x91DA,0xFBBB, 0x91D7,0xFBBC, 0x91DE,0xFBBD, 0x91ED,0xFBBE, 0x91EE,0xFBBF, 0x91E4,0xFBC0, 0x91E5,0xFBC1, 0x9206,0xFBC2, 0x9210,0xFBC3, 0x920A,0xFBC4, 0x923A,0xFBC5, 0x9240,0xFBC6, 0x923C,0xFBC7, 0x924E,0xFBC8, 0x9259,0xFBC9, 0x9251,0xFBCA, 0x9239,0xFBCB, 0x9267,0xFBCC, 0x92A7,0xFBCD, 0x9277,0xFBCE, 0x9278,0xFBCF, 0x92E7,0xFBD0, 0x92D7,0xFBD1, 0x92D9,0xFBD2, 0x92D0,0xFBD3, 0xFA27,0xFBD4, 0x92D5,0xFBD5, 0x92E0,0xFBD6, 0x92D3,0xFBD7, 0x9325,0xFBD8, 0x9321,0xFBD9, 0x92FB,0xFBDA, 0xFA28,0xFBDB, 0x931E,0xFBDC, 0x92FF,0xFBDD, 0x931D,0xFBDE, 0x9302,0xFBDF, 0x9370,0xFBE0, 0x9357,0xFBE1, 0x93A4,0xFBE2, 0x93C6,0xFBE3, 0x93DE,0xFBE4, 0x93F8,0xFBE5, 0x9431,0xFBE6, 0x9445,0xFBE7, 0x9448,0xFBE8, 0x9592,0xFBE9, 0xF9DC,0xFBEA, 0xFA29,0xFBEB, 0x969D,0xFBEC, 0x96AF,0xFBED, 0x9733,0xFBEE, 0x973B,0xFBEF, 0x9743,0xFBF0, 0x974D,0xFBF1, 0x974F,0xFBF2, 0x9751,0xFBF3, 0x9755,0xFBF4, 0x9857,0xFBF5, 0x9865,0xFBF6, 0xFA2A,0xFBF7, 0xFA2B,0xFBF8, 0x9927,0xFBF9, 0xFA2C,0xFBFA, 0x999E,0xFBFB, 0x9A4E,0xFBFC, 0x9AD9,0xFC40, 0x9ADC,0xFC41, 0x9B75,0xFC42, 0x9B72,0xFC43, 0x9B8F,0xFC44, 0x9BB1,0xFC45, 0x9BBB,0xFC46, 0x9C00,0xFC47, 0x9D70,0xFC48, 0x9D6B,0xFC49, 0xFA2D,0xFC4A, 0x9E19,0xFC4B, 0x9ED1,]\nvar decoding_table = [],\n    encoding_table = []\nfor(var i = 0, len = _table.length; i < len; i += 2){\nvar value = _table[i + 1]\nif(value !== null){\n    encoding_table[value] = _table[i]\n}\ndecoding_table[_table[i]] = _table[i + 1]\n}\n$module = {encoding_table, decoding_table}\n"],
-    "hashlib": [".js", "var $module=(function($B){\n\nvar _b_ = $B.builtins\n\nvar $s = []\nfor(var $b in _b_){$s.push('var ' + $b +' = _b_[\"'+$b+'\"]')}\neval($s.join(';'))\n\nvar $mod = {\n\n    __getattr__ : function(attr){\n        if(attr == 'new'){return hash.$factory}\n        return this[attr]\n    },\n    md5: function(obj){return hash.$factory('md5', obj)},\n    sha1: function(obj){return hash.$factory('sha1', obj)},\n    sha224: function(obj){return hash.$factory('sha224', obj)},\n    sha256: function(obj){return hash.$factory('sha256', obj)},\n    sha384: function(obj){return hash.$factory('sha384', obj)},\n    sha512: function(obj){return hash.$factory('sha512', obj)},\n\n    algorithms_guaranteed: ['md5', 'sha1', 'sha224', 'sha256', 'sha384', 'sha512'],\n    algorithms_available:  ['md5', 'sha1', 'sha224', 'sha256', 'sha384', 'sha512']\n}\n\n//todo: eventually move this function to a \"utility\" file or use ajax module?\nfunction $get_CryptoJS_lib(alg){\n    if($B.VFS !== undefined && $B.VFS.hashlib){\n        // use file in brython_stdlib.js\n        var lib = $B.VFS[\"crypto_js.rollups.\" + alg]\n        if (lib === undefined){\n            throw _b_.ImportError.$factory(\"can't import hashlib.\" + alg)\n        }\n        var res = lib[1]\n        try{\n            eval(res + \"; $B.CryptoJS = CryptoJS;\")\n            return\n        }catch(err){\n            throw Error(\"JS Eval Error\",\n                \"Cannot eval CryptoJS algorithm '\" + alg + \"' : error:\" + err)\n        }\n    }\n\n    var module = {__name__: 'CryptoJS', $is_package: false}\n    var res = $B.$download_module(module, $B.brython_path + 'libs/crypto_js/rollups/' + alg + '.js');\n\n    try{\n        eval(res + \"; $B.CryptoJS = CryptoJS;\")\n    }catch(err){\n        throw Error(\"JS Eval Error\",\n            \"Cannot eval CryptoJS algorithm '\" + alg + \"' : error:\" + err)\n    }\n}\n\nfunction bytes2WordArray(obj){\n    // Transform a bytes object into an instance of class WordArray\n    // defined in CryptoJS\n    if(!_b_.isinstance(obj, _b_.bytes)){\n        throw _b_.TypeError(\"expected bytes, got \" + $B.class_name(obj))\n    }\n\n    var words = []\n    for(var i = 0; i < obj.source.length; i += 4){\n        var word = obj.source.slice(i, i + 4)\n        while(word.length < 4){word.push(0)}\n        var w = word[3] + (word[2] << 8) + (word[1] << 16) + (word[0] << 24)\n        words.push(w)\n    }\n    return {words: words, sigBytes: obj.source.length}\n}\n\nvar hash = {\n    __class__: _b_.type,\n    __mro__: [_b_.object],\n    $infos:{\n        __name__: 'hash'\n    }\n}\n\nhash.update = function(self, msg){\n    self.hash.update(bytes2WordArray(msg))\n}\n\nhash.copy = function(self){\n    return self.hash.clone()\n}\n\nhash.digest = function(self){\n    var obj = self.hash.clone().finalize().toString(),\n        res = []\n    for(var i = 0; i < obj.length; i += 2){\n        res.push(parseInt(obj.substr(i, 2), 16))\n    }\n    return _b_.bytes.$factory(res)\n}\n\nhash.hexdigest = function(self) {\n    return self.hash.clone().finalize().toString()\n}\n\nhash.$factory = function(alg, obj) {\n    var res = {\n        __class__: hash\n    }\n\n    switch(alg) {\n      case 'md5':\n      case 'sha1':\n      case 'sha224':\n      case 'sha256':\n      case 'sha384':\n      case 'sha512':\n        var ALG = alg.toUpperCase()\n        if($B.Crypto === undefined ||\n            $B.CryptoJS.algo[ALG] === undefined){$get_CryptoJS_lib(alg)}\n\n        res.hash = $B.CryptoJS.algo[ALG].create()\n        if(obj !== undefined){\n            res.hash.update(bytes2WordArray(obj))\n        }\n        break\n      default:\n        throw $B.builtins.AttributeError.$factory('Invalid hash algorithm: ' + alg)\n    }\n\n    return res\n}\n\nreturn $mod\n\n})(__BRYTHON__)\n"],
+    "hashlib": [".js", "var $module=(function($B){\n\nvar _b_ = $B.builtins\n\nvar $mod = {\n\n    __getattr__ : function(attr){\n        if(attr == 'new'){return hash.$factory}\n        return this[attr]\n    },\n    md5: function(obj){return hash.$factory('md5', obj)},\n    sha1: function(obj){return hash.$factory('sha1', obj)},\n    sha224: function(obj){return hash.$factory('sha224', obj)},\n    sha256: function(obj){return hash.$factory('sha256', obj)},\n    sha384: function(obj){return hash.$factory('sha384', obj)},\n    sha512: function(obj){return hash.$factory('sha512', obj)},\n\n    algorithms_guaranteed: ['md5', 'sha1', 'sha224', 'sha256', 'sha384', 'sha512'],\n    algorithms_available:  ['md5', 'sha1', 'sha224', 'sha256', 'sha384', 'sha512']\n}\n\n//todo: eventually move this function to a \"utility\" file or use ajax module?\nfunction $get_CryptoJS_lib(alg){\n    if($B.VFS !== undefined && $B.VFS.hashlib){\n        // use file in brython_stdlib.js\n        var lib = $B.VFS[\"crypto_js.rollups.\" + alg]\n        if (lib === undefined){\n            throw _b_.ImportError.$factory(\"can't import hashlib.\" + alg)\n        }\n        var res = lib[1]\n        try{\n            eval(res + \"; $B.CryptoJS = CryptoJS;\")\n            return\n        }catch(err){\n            throw Error(\"JS Eval Error\",\n                \"Cannot eval CryptoJS algorithm '\" + alg + \"' : error:\" + err)\n        }\n    }\n\n    var module = {__name__: 'CryptoJS', $is_package: false}\n    var res = $B.$download_module(module, $B.brython_path + 'libs/crypto_js/rollups/' + alg + '.js');\n\n    try{\n        eval(res + \"; $B.CryptoJS = CryptoJS;\")\n    }catch(err){\n        throw Error(\"JS Eval Error\",\n            \"Cannot eval CryptoJS algorithm '\" + alg + \"' : error:\" + err)\n    }\n}\n\nfunction bytes2WordArray(obj){\n    // Transform a bytes object into an instance of class WordArray\n    // defined in CryptoJS\n    if(!_b_.isinstance(obj, _b_.bytes)){\n        throw _b_.TypeError(\"expected bytes, got \" + $B.class_name(obj))\n    }\n\n    var words = []\n    for(var i = 0; i < obj.source.length; i += 4){\n        var word = obj.source.slice(i, i + 4)\n        while(word.length < 4){word.push(0)}\n        var w = word[3] + (word[2] << 8) + (word[1] << 16) + (word[0] << 24)\n        words.push(w)\n    }\n    return {words: words, sigBytes: obj.source.length}\n}\n\nvar hash = {\n    __class__: _b_.type,\n    __mro__: [_b_.object],\n    $infos:{\n        __name__: 'hash'\n    }\n}\n\nhash.update = function(self, msg){\n    self.hash.update(bytes2WordArray(msg))\n}\n\nhash.copy = function(self){\n    return self.hash.clone()\n}\n\nhash.digest = function(self){\n    var obj = self.hash.clone().finalize().toString(),\n        res = []\n    for(var i = 0; i < obj.length; i += 2){\n        res.push(parseInt(obj.substr(i, 2), 16))\n    }\n    return _b_.bytes.$factory(res)\n}\n\nhash.hexdigest = function(self) {\n    return self.hash.clone().finalize().toString()\n}\n\nhash.$factory = function(alg, obj) {\n    var res = {\n        __class__: hash\n    }\n\n    switch(alg) {\n      case 'md5':\n      case 'sha1':\n      case 'sha224':\n      case 'sha256':\n      case 'sha384':\n      case 'sha512':\n        var ALG = alg.toUpperCase()\n        if($B.Crypto === undefined ||\n            $B.CryptoJS.algo[ALG] === undefined){$get_CryptoJS_lib(alg)}\n\n        res.hash = $B.CryptoJS.algo[ALG].create()\n        if(obj !== undefined){\n            res.hash.update(bytes2WordArray(obj))\n        }\n        break\n      default:\n        throw $B.builtins.AttributeError.$factory('Invalid hash algorithm: ' + alg)\n    }\n\n    return res\n}\n\nreturn $mod\n\n})(__BRYTHON__)\n"],
     "html_parser": [".js", "var $module = (function($B){\n\n_b_ = $B.builtins\n\nvar ELEMENT_NODE = 1,\n    TEXT_NODE = 3,\n    COMMENT_NODE =\t8,\n    DOCUMENT_TYPE_NODE =\t10\n\nvar HTMLNode = $B.make_class(\"HTMLNode\",\n    function(){\n        return {\n            __class__: HTMLNode,\n            nodeType: TEXT_NODE,\n            text: \"\"\n        }\n    }\n)\n\nHTMLNode.__str__ = function(self){\n    return self.text\n}\n\n$B.set_func_names(HTMLNode, \"_html_parser\")\n\nfunction* tokenize(src){\n    var node = HTMLNode.$factory(),\n        pos = 0,\n        tag = \"\",\n        type = \"text\"\n    while(pos < src.length){\n        var char = src[pos]\n        switch(type){\n            case \"text\":\n                if(char == \"<\"){\n                    // starts a tag if immediately followed by a letter or by /\n                    var tag_mo = /^(\\/?)[a-zA-Z]+/.exec(src.substr(pos + 1))\n                    if(tag_mo){\n                        yield node\n                        node = HTMLNode.$factory()\n                        type = \"tag\"\n                        node.tagName = \"\"\n                        node.nodeType = ELEMENT_NODE\n                        node.closing = tag_mo[1] != \"\"\n                        node.attrs = []\n                    }else{\n                        // doctype declaration\n                        var decl_mo = /^<!doctype\\s+(.*?)>/i.exec(src.substr(pos))\n                        if(decl_mo){\n                            yield node\n                            node = HTMLNode.$factory()\n                            node.text = decl_mo[0]\n                            node.doctype = decl_mo[1]\n                            node.nodeType = DOCUMENT_TYPE_NODE\n                            yield node\n                            node = HTMLNode.$factory()\n                            type = \"text\"\n                            pos += decl_mo[0].length\n                            break\n                        }else{\n                            // comment\n                            var comment_mo = /^\\<!(.*?)>/.exec(src.substr(pos))\n                            if(comment_mo){\n                                yield node\n                                node = HTMLNode.$factory()\n                                node.text = comment_mo[0]\n                                node.comment = comment_mo[1]\n                                node.nodeType = COMMENT_NODE\n                                yield node\n                                node = HTMLNode.$factory()\n                                type = \"text\"\n                                pos += comment_mo[0].length\n                                break\n                            }\n                        }\n                    }\n                }\n                pos++\n                node.text += char\n                break\n            case \"tag\":\n                if(char.search(/[_a-zA-Z]/) > -1){\n                    var mo = /\\w+/.exec(src.substr(pos))\n                    if(mo !== null){\n                        pos += mo[0].length\n                        if(node.tagName == \"\"){\n                            node.tagName = mo[0].toUpperCase()\n                        }\n                        node.text += mo[0]\n                    }else{\n                        pos++\n                    }\n                }else if(char == \">\"){\n                    node.text += char\n                    yield node\n                    node = HTMLNode.$factory()\n                    type = \"text\"\n                    pos++\n                }else if(char == \"=\"){\n                    node.text += char\n                    pos++\n                }else if(char == \"'\" || char == '\"'){\n                    var i = pos + 1\n                    while(i < src.length){\n                        if(src[i] == char){\n                            var nb_escape = 0\n                            while(src[i - 1 - nb_escape] == '/'){\n                                nb_escape++\n                            }\n                            if(nb_escape % 2 == 0){\n                                node.text += src.substr(pos, i + 1 - pos)\n                                pos = i + 1\n                                break\n                            }else{\n                                i++\n                            }\n                        }else{\n                            i++\n                        }\n                    }\n                }else{\n                    node.text += char\n                    pos++\n                }\n                break\n            default:\n                pos++\n        }\n    }\n    yield node\n}\nreturn  {\n    ELEMENT_NODE: 1,\n    TEXT_NODE: 3,\n    COMMENT_NODE:\t8,\n    DOCUMENT_TYPE_NODE:\t10,\n    tokenize: tokenize\n}\n\n})(__BRYTHON__)\n"],
     "long_int": [".js", "/*\nModule to manipulate long integers\n*/\n\nvar $module=(function($B){\n\neval($B.InjectBuiltins())\n\nvar $LongIntDict = {__class__:$B.$type,__name__:'LongInt'}\n\nfunction add_pos(v1, v2){\n    // Add two positive numbers\n    // v1, v2 : strings\n    // Return an instance of LongInt\n\n    var res = '', carry = 0, iself=v1.length, sv=0\n    for(var i=v2.length-1;i>=0;i--){\n        iself--\n        if(iself<0){sv=0}else{sv=parseInt(v1.charAt(iself))}\n        x = (carry+sv+parseInt(v2.charAt(i))).toString()\n        if(x.length==2){res=x.charAt(1)+res;carry=parseInt(x.charAt(0))}\n        else{res=x+res;carry=0}\n    }\n    while(iself>0){\n        iself--\n        x = (carry+parseInt(v1.charAt(iself))).toString()\n        if(x.length==2){res=x.charAt(1)+res;carry=parseInt(x.charAt(0))}\n        else{res=x+res;carry=0}\n    }\n    if(carry){res=carry+res}        \n    return {__class__:$LongIntDict, value:res, pos:true}\n}\n\nfunction check_shift(shift){\n    // Check the argument of >> and <<\n    if(!isinstance(shift, LongInt)){\n        throw TypeError(\"shift must be LongInt, not '\"+\n            $B.get_class(shift).__name__+\"'\")\n    }\n    if(!shift.pos){throw ValueError(\"negative shift count\")}\n}\n\nfunction clone(obj){\n    // Used for traces\n    var obj1 = {}\n    for(var attr in obj){obj1[attr]=obj[attr]}\n    return obj1\n}\n\nfunction comp_pos(v1, v2){\n    // Compare two positive numbers\n    if(v1.length>v2.length){return 1}\n    else if(v1.length<v2.length){return -1}\n    else{\n        if(v1>v2){return 1}\n        else if(v1<v2){return -1}\n    }\n    return 0\n}\n\nfunction divmod_pos(v1, v2){\n    // v1, v2 : strings, represent 2 positive integers A and B\n    // Return [a, b] where a and b are instances of LongInt\n    // a = A // B, b = A % B\n    var v1_init = v1, quotient, mod\n    if(comp_pos(v1, v2)==-1){ // a < b\n        quotient='0'\n        mod = LongInt(v1)\n    }else if(v2==v1){ // a = b\n        quotient = '1';\n        mod = LongInt('0')\n    }else{\n        var quotient = '', v1_init = v1\n        var left = v1.substr(0, v2.length)\n        if(v1<v2){left = v1.substr(0, v2.length+1)}\n        var right = v1.substr(left.length)\n        // mv2 maps integers i from 2 to 9 to i*v2, used as a cache to avoid\n        // having to compute i*v2 each time\n        var mv2 = {}\n        // Javascript \"safe integer\" with the 15 first digits in v2,\n        // used in the algorithm to test candidate values\n        var jsv2 = parseInt(v2.substr(0,15))\n\n        // Division algorithm\n        // At each step in the division, v1 is split into substrings\n        // \"left\" is the left part, with the same length as v2\n        // \"rest\" is the rest of v1 after \"left\"\n        // The algorithm finds the one-digit integer \"candidate\" such\n        // that 0 <= left - candidate*v2 < v2\n        // It stops when right is empty\n        while(true){\n            // Uses JS division to test an approximate result\n            var jsleft = parseInt(left.substr(0,15))\n            var candidate = Math.floor(jsleft/jsv2).toString()\n\n            // Check that candidate is the correct result\n            // Start by computing candidate*v2 : for this, use the table\n            // mv2, which stores the multiples of v2 already calculated\n            if(mv2[candidate]===undefined){\n                mv2[candidate] = mul_pos(v2, candidate).value\n            }\n            if(comp_pos(left, mv2[candidate])==-1){\n                // If left < candidate * v2, use candidate-1\n                candidate--\n                if(mv2[candidate]===undefined){\n                    mv2[candidate] = mul_pos(v2, candidate).value\n                }\n            }\n\n            // Add candidate to the quotient\n            quotient += candidate\n\n            // New value for left : left - v2*candidate\n            left = sub_pos(left, mv2[candidate]).value\n\n            // Stop if all digits in v1 have been used\n            if(right.length==0){break}\n\n            // Else, add next digit to left and remove it from right\n            left += right.charAt(0)\n            right = right.substr(1)\n        }\n        // Modulo is A - (A//B)*B\n        mod = sub_pos(v1, mul_pos(quotient, v2).value)\n    }\n    return [LongInt(quotient), mod]\n}\n\nfunction mul_pos(v1, v2){\n    // Multiply positive numbers v1 by v2\n    // Make v2 smaller than v1\n    if(v1.length<v2.length){var a=v1; v1=v2 ; v2=a}\n    if(v2=='0'){return LongInt('0')}\n    var cols = {}, i=v2.length, j\n    \n    // Built the object \"cols\", indexed by integers from 1 to nb1+nb2-2\n    // where nb1 and nb2 are the number of digits in v1 and v2.\n    // cols[n] is the sum of v1[i]*v2[j] for i+j = n\n    \n    while(i--){\n        var car = v2.charAt(i)\n        if(car==\"0\"){\n            j = v1.length\n            while(j--){\n                if(cols[i+j]===undefined){cols[i+j]=0}\n            }        \n        }else if(car==\"1\"){\n            j = v1.length\n            while(j--){\n                var z = parseInt(v1.charAt(j))\n                if(cols[i+j]===undefined){cols[i+j]=z}\n                else{cols[i+j] += z}\n            }\n        }else{\n            var x = parseInt(car), j = v1.length, y, z\n            while(j--){\n                y = x * parseInt(v1.charAt(j))\n                if(cols[i+j]===undefined){cols[i+j]=y}\n                else{cols[i+j] += y}\n            }\n        }\n    }\n\n    // Transform cols so that cols[x] is a one-digit integers\n    i = v1.length+v2.length-1\n    while(i--){\n        var col = cols[i].toString()\n        if(col.length>1){\n            // If the value in cols[i] has more than one digit, only keep the\n            // last one and report the others at the right index\n            // For instance if cols[i] = 123, keep 3 in cols[i], add 2 to\n            // cols[i-1] and 1 to cols[i-2]\n            cols[i] = parseInt(col.charAt(col.length-1))\n            j = col.length\n            while(j-->1){\n                var report = parseInt(col.charAt(j-1))\n                var pos = i-col.length+j\n                if(cols[pos]===undefined){cols[pos]=report}\n                else{cols[pos] += report}\n            }\n        }\n    }\n\n    // Find minimum index in cols\n    // The previous loop may have introduced negative indices\n    var imin\n    for(var attr in cols){\n        i = parseInt(attr)\n        if(imin===undefined){imin=i}\n        else if(i<imin){imin=i}\n    }\n\n    // Result is the concatenation of digits in cols\n    var res = ''\n    for(var i=imin;i<=v1.length+v2.length-2;i++){res+=cols[i].toString()}\n    return LongInt(res)\n}\n\nfunction sub_pos(v1, v2){\n    // Substraction of positive numbers with v1>=v2\n\n    var res = '', carry = 0, i1=v1.length, sv=0\n    \n    // For all digits in v2, starting by the rightmost, substract it from\n    // the matching digit in v1\n    // This is the equivalent of the manual operation :\n    //    12345678\n    //   -   98765\n    //\n    // We begin by the rightmost operation : 8-5 (3, no carry),\n    // then 7-6 (1, no carry)\n    // then 6-7 (9, carry 1) and so on\n    for(var i=v2.length-1;i>=0;i--){\n        i1--\n        sv = parseInt(v1.charAt(i1))\n        x = (sv-carry-parseInt(v2.charAt(i)))\n        if(x<0){res=(10+x)+res;carry=1}\n        else{res=x+res;carry=0}\n    }\n    \n    // If there are remaining digits in v1, substract the carry, if any\n    while(i1>0){\n        i1--\n        x = (parseInt(v1.charAt(i1))-carry)\n        if(x<0){res=(10+x)+res;carry=1}\n        else{res=x+res;carry=0}\n    }\n\n    // Remove leading zeros and return the result\n    while(res.charAt(0)=='0' && res.length>1){res=res.substr(1)}\n    return {__class__:$LongIntDict, value:res, pos:true}\n}\n\n// Special methods to implement operations on instances of LongInt\n\n$LongIntDict.__abs__ = function(self){\n    return {__class__:$LongIntDict, value: self.value, pos:true}\n}\n\n$LongIntDict.__add__ = function(self, other){\n    if (typeof other == 'number') other=LongInt(_b_.str.$factory(other))\n    // Addition of \"self\" and \"other\"\n    // If both have the same sign (+ or -) we add their absolute values\n    // If they have different sign we use the substraction of their\n    // absolute values\n    var res\n    if(self.pos&&other.pos){  // self > 0, other > 0\n        return add_pos(self.value, other.value)\n    }else if(!self.pos&&!other.pos){ // self < 0, other < 0\n        res = add_pos(self.value, other.value)\n        res.pos = false\n        return res\n    }else if(self.pos && !other.pos){ // self > 0, other < 0\n        switch (comp_pos(self.value, other.value)){\n            case 1:\n                res = sub_pos(self.value, other.value)\n                break\n            case 0:\n                res = {__class__:$LongIntDict, value:0, pos:true}\n                break\n            case -1:\n                res = sub_pos(other.value, self.value)\n                res.pos = false\n                break\n        }\n        return res\n    }else{ // self < 0, other > 0\n        switch(comp_pos(self.value, other.value)){\n            case 1:\n                res = sub_pos(self.value, other.value)\n                res.pos = false\n                break\n            case 0:\n                res = {__class__:$LongIntDict, value:0, pos:true}\n                break\n            case -1:\n                res = sub_pos(other.value, self.value)\n                break\n        }\n        return res\n    }\n}\n\n$LongIntDict.__and__ = function(self, other){\n    if (typeof other == 'number') other=LongInt(_b_.str.$factory(other))\n    // Bitwise \"and\" : build the binary representation of self and other\n    var v1 = $LongIntDict.__index__(self)\n    var v2 = $LongIntDict.__index__(other)\n    // apply \"and\" on zeros and ones\n    if(v1.length<v2.length){var temp=v2;v2=v1;v1=temp}\n    var start = v1.length-v2.length\n    var res = ''\n    for(var i=0;i<v2.length;i++){\n        if(v1.charAt(start+i)=='1' && v2.charAt(i)=='1'){res += '1'}\n        else{res += '0'}\n    }\n    // Return the LongInt instance represented by res in base 2\n    return LongInt(res, 2)\n}\n\n$LongIntDict.__divmod__ = function(self, other){\n    if (typeof other == 'number') other=LongInt(_b_.str.$factory(other))\n\n    var dm = divmod_pos(self.value, other.value)\n    if(self.pos!==other.pos){\n        if(dm[0].value!='0'){dm[0].pos = false}\n        if(dm[1].value!='0'){\n            // If self and other have different signs and self is not a multiple\n            // of other, round to the previous integer\n            dm[0] = $LongIntDict.__sub__(dm[0], LongInt('1'))\n            dm[1] = $LongIntDict.__add__(dm[1], LongInt('1'))\n        }\n    }\n    return dm    \n}\n\n$LongIntDict.__eq__ = function(self, other){\n    if (typeof other == 'number') other=LongInt(_b_.str.$factory(other))\n    return self.value==other.value && self.pos==other.pos\n}\n\n$LongIntDict.__floordiv__ = function(self, other){\n    if (typeof other == 'number') other=LongInt(_b_.str.$factory(other))\n    return $LongIntDict.__divmod__(self, other)[0]\n}\n\n$LongIntDict.__ge__ = function(self, other){\n    if (typeof other == 'number') other=LongInt(_b_.str.$factory(other))\n    if(self.value.length>other.value.length){return true}\n    else if(self.value.length<other.value.length){return false}\n    else{return self.value >= other.value}\n}\n\n$LongIntDict.__gt__ = function(self, other){\n    return !$LongIntDict.__le__(self, other)\n}\n\n$LongIntDict.__index__ = function(self){\n    // Used by bin()\n    // returns a string with the binary value of self\n    // The algorithm computes the result of the floor division of self by 2\n    \n    // XXX to do : negative integers\n    \n    var res = '', pos=self.value.length,\n        temp = self.value, d\n    while(true){\n        d = divmod_pos(temp, '2')\n        res = d[1].value + res\n        temp = d[0].value\n        if(temp=='0'){break}\n    }\n    return res\n}\n\n$LongIntDict.__invert__ = function(self){\n    var bin = $LongIntDict.__index__(self)\n    var res = ''\n    for(var i=0;i<bin.length;i++){\n        res += bin.charAt(i)=='0' ? '1' : '0'\n    }\n    return LongInt(res, 2)\n}\n\n$LongIntDict.__le__ = function(self, other){\n    if (typeof other == 'number') other=LongInt(_b_.str.$factory(other))\n    if(self.value.length>other.value.length){return false}\n    else if(self.value.length<other.value.length){return true}\n    else{return self.value <= other.value}\n}\n\n$LongIntDict.__lt__ = function(self, other){\n    return !$LongIntDict.__ge__(self, other)\n}\n\n$LongIntDict.__lshift__ = function(self, shift){\n    check_shift(shift)\n    var res = self.value\n    while(true){\n        var x, carry=0, res1=''\n        for(var i=res.length-1;i>=0;i--){\n            x = (carry+parseInt(res.charAt(i))*2).toString()\n            if(x.length==2){res1=x.charAt(1)+res1;carry=parseInt(x.charAt(0))}\n            else{res1=x+res1;carry=0}\n        }\n        if(carry){res1=carry+res1}\n        res=res1\n        shift = sub_pos(shift.value, '1')\n        if(shift.value=='0'){break}\n    }\n    return {__class__:$LongIntDict, value:res, pos:self.pos}\n}\n\n$LongIntDict.__mod__ = function(self, other){\n    return $LongIntDict.__divmod__(self, other)[1]\n}\n\n$LongIntDict.__mro__ = [_b_.object]\n\n$LongIntDict.__mul__ = function(self, other){\n    if (typeof other == 'number') other=LongInt(_b_.str.$factory(other))\n    var res = mul_pos(self.value, other.value)\n    if(self.pos==other.pos){return res}\n    res.pos = false\n    return res\n}\n\n$LongIntDict.__neg__ = function(obj){\n    return {__class__:$LongIntDict, value:obj.value, pos:!obj.pos}\n}\n\n$LongIntDict.__or__ = function(self, other){\n    var v1 = $LongIntDict.__index__(self)\n    var v2 = $LongIntDict.__index__(other)\n    if(v1.length<v2.length){var temp=v2;v2=v1;v1=temp}\n    var start = v1.length-v2.length\n    var res = v1.substr(0, start)\n    for(var i=0;i<v2.length;i++){\n        if(v1.charAt(start+i)=='1' || v2.charAt(i)=='1'){res += '1'}\n        else{res += '0'}\n    }\n    return LongInt(res, 2)\n}\n\n\n$LongIntDict.__pow__ = function(self, power){\n    if (typeof power == \"number\") {\n        power=LongInt(_b_.str.$factory(power))\n    }else if(!isinstance(power, LongInt)){\n        var msg = \"power must be a LongDict, not '\"\n        throw TypeError(msg+$B.get_class(power).__name__+\"'\")\n    }\n    if(!power.pos){\n        if(self.value=='1'){return self}\n        // For all other integers, x**-n is 0\n        return LongInt('0')\n    }else if(power.value=='0'){\n        return LongInt('1')\n    }\n    var res = {__class__:$LongIntDict, value:self.value, pos:self.pos}\n    var pow = power.value\n    while(true){\n        pow = sub_pos(pow, '1').value\n        if(pow == '0'){break}\n        res = $LongIntDict.__mul__(res, self)\n    }\n    return res    \n}\n\n$LongIntDict.__rshift__ = function(self, shift){\n    check_shift(shift)\n    var res = self.value\n    while(true){\n        res = divmod_pos(res, '2')[0].value\n        if(res.value=='0'){break}\n        shift = sub_pos(shift.value, '1')\n        if(shift.value=='0'){break}\n    }\n    return {__class__:$LongIntDict, value:res, pos:self.pos}\n}\n\n$LongIntDict.__str__ = $LongIntDict.__repr__ = function(self){\n    var res = \"LongInt('\"\n    if(!self.pos){res += '-'}\n    return res+self.value+\"')\"\n}\n\n$LongIntDict.__sub__ = function(self, other){\n    if (typeof other == 'number') other=LongInt(_b_.str.$factory(other))\n    var res\n    if(self.pos && other.pos){\n        switch(comp_pos(self.value, other.value)){\n            case 1:\n                res = sub_pos(self.value, other.value)\n                break\n            case 0:\n                res = {__class__:$LongIntDict, value:'0', pos:true}\n                break\n            case -1:\n                res = sub_pos(other.value, self.value)\n                res.pos = false\n                break\n        }\n        return res\n    }else if(!self.pos && !other.pos){\n        switch(comp_pos(self.value, other.value)){\n            case 1:\n                res = sub_pos(self.value, other.value)\n                res.pos = false\n                break\n            case 0:\n                res = {__class__:$LongIntDict, value:'0', pos:true}\n                break\n            case -1:\n                res = sub_pos(other.value, self.value)\n                break\n        }\n        return res\n    }else if(self.pos && !other.pos){\n        return add_pos(self.value, other.value)\n    }else{\n        res = add_pos(self.value, other.value)\n        res.pos = false\n        return res\n    }\n}\n\n$LongIntDict.__xor__ = function(self, other){\n    var v1 = $LongIntDict.__index__(self)\n    var v2 = $LongIntDict.__index__(other)\n    if(v1.length<v2.length){var temp=v2;v2=v1;v1=temp}\n    var start = v1.length-v2.length\n    var res = v1.substr(0, start)\n    for(var i=0;i<v2.length;i++){\n        if(v1.charAt(start+i)=='1' && v2.charAt(i)=='0'){res += '1'}\n        else if(v1.charAt(start+i)=='0' && v2.charAt(i)=='1'){res += '1'}\n        else{res += '0'}\n    }\n    return LongInt(res, 2)\n}\n\n$LongIntDict.to_base = function(self, base){\n    // Returns the string representation of self in specified base\n    var res='', v=self.value\n    while(v>0){\n        var dm = divmod_pos(v, base.toString())\n        res = parseInt(dm[1].value).toString(base)+res\n        v = dm[0].value\n        if(v==0){break}\n    }\n    return res\n}\n\nfunction digits(base){\n    // Return an object where keys are all the digits valid in specified base\n    // and value is \"true\"\n    // Used to test if the string passed as first argument to LongInt is valid\n    var is_digits = {}\n    // Number from 0 to base, or from 0 to 9 if base > 10\n    for(var i=0;i<base;i++){\n        if(i==10){break}\n        is_digits[i]=true\n    }\n    if(base>10){\n        // Additional letters\n        // For instance in base 16, add \"abcdefABCDEF\" as keys\n        for(var i=0;i<base-10;i++){\n            is_digits[String.fromCharCode(65+i)]=true\n            is_digits[String.fromCharCode(97+i)]=true\n        }\n    }\n    return is_digits\n}\n\nvar MAX_SAFE_INTEGER = Math.pow(2, 53)-1;\nvar MIN_SAFE_INTEGER = -Number.MAX_SAFE_INTEGER;\n\nfunction isSafeInteger(n) {\n    return (typeof n === 'number' &&\n        Math.round(n) === n &&\n        Number.MIN_SAFE_INTEGER <= n &&\n        n <= Number.MAX_SAFE_INTEGER);\n}\n\nfunction LongInt(value, base){\n    if(arguments.length>2){\n        throw _b_.TypeError(\"LongInt takes at most 2 arguments (\"+\n            arguments.length+\" given)\")\n    }\n    // base defaults to 10\n    if(base===undefined){base = 10}\n    else if(!isinstance(base, int)){\n        throw TypeError(\"'\"+$B.get_class(base).__name__+\"' object cannot be interpreted as an integer\")\n    }\n    if(base<0 || base==1 || base>36){\n        throw ValueError(\"LongInt() base must be >= 2 and <= 36\")\n    }\n    if(isinstance(value, float)){\n        if(value>=0){value=Math.round(value.value)}\n        else{value=Math.ceil(value.value)}\n    }\n    if(typeof value=='number'){\n        if(isSafeInteger(value)){value = value.toString()}\n        else{throw ValueError(\"argument of long_int is not a safe integer\")}\n    }else if(typeof value!='string'){\n        throw ValueError(\"argument of long_int must be a string, not \"+\n            $B.get_class(value).__name__)\n    }\n    var has_prefix = false, pos = true, start = 0\n    // Strip leading and trailing whitespaces\n    while(value.charAt(0)==' ' && value.length){value = value.substr(1)}\n    while(value.charAt(value.length-1)==' ' && value.length){\n        value = value.substr(0, value.length-1)\n    }\n    // Check if string starts with + or -\n    if(value.charAt(0)=='+'){has_prefix=true}\n    else if(value.charAt(0)=='-'){has_prefix=true;pos=false}\n    if(has_prefix){\n        // Remove prefix\n        if(value.length==1){\n            // \"+\" or \"-\" alone are not valid arguments\n            throw ValueError('LongInt argument is not a valid number: \"'+value+'\"')\n        }else{value=value.substr(1)}\n    }\n    // Ignore leading zeros\n    while(start<value.length-1 && value.charAt(start)=='0'){start++}\n    value = value.substr(start)\n\n    // Check if all characters in value are valid in the base\n    var is_digits = digits(base), point = -1\n    for(var i=0;i<value.length;i++){\n        if(value.charAt(i)=='.' && point==-1){point=i}\n        else if(!is_digits[value.charAt(i)]){\n            throw ValueError('LongInt argument is not a valid number: \"'+value+'\"')\n        }\n    }\n    if(point!=-1){value=value.substr(0,point)}\n    if(base!=10){\n        // Conversion to base 10\n        var coef = '1', v10 = LongInt(0),\n            pos = value.length, digit_base10\n        while(pos--){\n            digit_base10 = parseInt(value.charAt(pos), base).toString()\n            digit_by_coef = mul_pos(coef, digit_base10).value\n            v10 = add_pos(v10.value, digit_by_coef)\n            coef = mul_pos(coef, base.toString()).value\n        }\n        return v10\n    }\n    return {__class__:$LongIntDict, value:value, pos:pos}\n}\n\nLongInt.__class__ = $B.$factory\nLongInt.$dict = $LongIntDict\n$LongIntDict.$factory = LongInt\n\nreturn {LongInt:LongInt}\n\n})(__BRYTHON__)\n"],
     "marshal": [".js", "var $module = (function($B){\n\nvar _b_ = $B.builtins\n\nreturn {\n    loads: function(){\n        var $ = $B.args('loads', 1, {obj:null}, ['obj'], arguments, {},\n            null, null)\n        return $B.structuredclone2pyobj(JSON.parse($.obj))\n    },\n    load: function(){\n        var $ = $B.args('load', 1, {file:null}, ['file'], arguments, {},\n            null, null)\n        var content = $B.$call($B.$getattr($.file, \"read\"))()\n        return $module.loads(_b_.bytes.decode(content, \"latin-1\"));\n    },\n    dump: function(){\n        var $ = $B.args('dump', 2, {value:null, file: null},\n            ['value', 'file'], arguments, {}, null, null)\n        var s = JSON.stringify($B.pyobj2structuredclone($.value))\n        $B.$getattr($.file, \"write\")(_b_.str.encode(s, 'latin-1'))\n        var flush = $B.$getattr($.file, \"flush\", null)\n        if(flush !== null){\n            $B.$call(flush)()\n        }\n        return _b_.None\n    },\n    dumps: function(){\n        var $ = $B.args('dumps', 1, {obj:null}, ['obj'], arguments, {},\n            null, null)\n        return JSON.stringify($B.pyobj2structuredclone($.obj))\n    }\n}\n\n})(__BRYTHON__)\n"],
-    "math": [".js", "var $module = (function($B){\n\nvar _b_ = $B.builtins,\n    $s = [],\n    i\nfor(var $b in _b_){$s.push('var ' + $b +' = _b_[\"'+$b+'\"]')}\neval($s.join(';'))\n\n//for(var $py_builtin in _b_){eval(\"var \"+$py_builtin+\"=_b_[$py_builtin]\")}\n\nvar float_check = function(x) {\n    if(x.__class__ === $B.long_int){\n        return parseInt(x.value)\n    }\n    return _b_.float.$factory(x)\n}\n\nfunction check_int(x){\n    if(! _b_.isinstance(x, int)){\n        throw _b_.TypeError.$factory(\"'\" + $B.class_name(x) +\n            \"' object cannot be interpreted as an integer\")\n    }\n}\n\nfunction check_int_or_round_float(x){\n    return (x instanceof Number && x == Math.floor(x)) ||\n            _b_.isinstance(x, int)\n}\n\nvar isWholeNumber = function(x){return (x * 10) % 10 == 0}\n\nvar isOdd = function(x) {return isWholeNumber(x) && 2 * Math.floor(x / 2) != x}\n\nvar isNegZero = function(x) {return x === 0 && Math.atan2(x,x) < 0}\n\nvar EPSILON = Math.pow(2, -52),\n    MAX_VALUE = (2 - EPSILON) * Math.pow(2, 1023),\n    MIN_VALUE = Math.pow(2, -1022);\n\nfunction nextUp(x){\n    if(x !== x){\n        return x\n    }\n    if(_b_.$isinf(x)){\n        if(_b_.$isninf(x)){\n            return -MAX_VALUE\n        }\n        return _mod.inf\n    }\n\n    if(x == +MAX_VALUE){\n        return +1 / 0\n    }\n    if(typeof x == \"number\" || x instanceof Number){\n        var y = x * (x < 0 ? 1 - EPSILON / 2 : 1 + EPSILON)\n        if(y == x){\n            y = MIN_VALUE * EPSILON > 0 ? x + MIN_VALUE * EPSILON : x + MIN_VALUE\n        }\n        if(y === +1 / 0){\n            y = +MAX_VALUE\n        }\n        var b = x + (y - x) / 2\n        if(x < b && b < y){\n            y = b;\n        }\n        var c = (y + x) / 2\n        if(x < c && c < y){\n            y = c;\n        }\n        return y === 0 ? -0 : y\n    }else{\n        var factor = $B.rich_comp('__lt__', x, 0) ? 1 - EPSILON / 2 :\n                                                   1 + EPSILON\n        var y = $B.rich_op(\"mul\", x , factor)\n        if(y == x){\n            y = MIN_VALUE * EPSILON > 0 ?\n                    $B.rich_op('add', x, MIN_VALUE * EPSILON) :\n                    $B.rich_op('add', x, MIN_VALUE)\n        }\n        if(y === +1 / 0){\n            y = +MAX_VALUE\n        }\n        var y_minus_x = $B.rich_op('sub', y, x)\n        var z = $B.rich_op('truediv', y_minus_x, 2) // (y - x) / 2\n\n        var b = $B.rich_op('add', x, z)\n        if($B.rich_comp('__lt__', x, b) && $B.rich_comp('__lt__', b, y)){\n            y = b;\n        }\n        var c = $B.rich_op('truediv', $B.rich_op('add', y, x), 2)\n        if($B.rich_comp('__lt__', x, c) && $B.rich_comp('__lt__', c, y)){\n            y = c;\n        }\n        return y === 0 ? -0 : y\n    }\n}\n\nfunction gcd2(a, b){\n    // GCD of 2 factors\n    if($B.rich_comp(\"__gt__\", b, a)){\n        var temp = a\n        a = b\n        b = temp\n    }\n    while(true){\n        if(b == 0){\n            return a\n        }\n        a = $B.rich_op(\"mod\", a, b)\n        if(a == 0){\n            return b\n        }\n        b = $B.rich_op(\"mod\", b, a)\n    }\n}\n\nvar _mod = {\n    __getattr__: function(attr){\n        $B.check_nb_args('__getattr__ ', 1, arguments)\n        $B.check_no_kw('__getattr__ ', attr)\n\n        var res = this[attr]\n        if(res === undefined){\n            throw _b_.AttributeError.$factory(\n                'module math has no attribute ' + attr)\n        }\n        return res\n    },\n    acos: function(x){\n        $B.check_nb_args('acos', 1, arguments)\n        $B.check_no_kw('acos', x)\n        if(_mod.isinf(x)){\n            throw _b_.ValueError.$factory(\"math domain error\")\n        }else if(_mod.isnan(x)){\n            return _mod.nan\n        }else{\n            x = float_check(x)\n            if(x > 1 || x < -1){\n                throw _b_.ValueError.$factory(\"math domain error\")\n            }\n            return float.$factory(Math.acos(x))\n        }\n    },\n    acosh: function(x){\n        $B.check_nb_args('acosh', 1, arguments)\n        $B.check_no_kw('acosh', x)\n\n        if(_b_.$isinf(x)){\n            if(_b_.$isninf(x)){\n                throw _b_.ValueError.$factory(\"math domain error\")\n            }\n            return _mod.inf\n        }else if(_mod.isnan(x)){\n            return _mod.nan\n        }\n        var y = float_check(x)\n        if(y <= 0){\n            throw _b_.ValueError.$factory(\"math domain error\")\n        }\n        if(y > Math.pow(2, 28)){ // issue 1590\n            return float.$factory(_mod.log(y) + _mod.log(2))\n        }\n        return float.$factory(Math.log(y + Math.sqrt(y * y - 1)))\n    },\n    asin: function(x){\n        $B.check_nb_args('asin', 1, arguments)\n        $B.check_no_kw('asin', x)\n        if(_mod.isinf(x)){\n            throw _b_.ValueError.$factory(\"math domain error\")\n        }else if(_mod.isnan(x)){\n            return _mod.nan\n        }else{\n            x = float_check(x)\n            if(x > 1 || x < -1){\n                throw _b_.ValueError.$factory(\"math domain error\")\n            }\n            return float.$factory(Math.asin(x))\n        }\n    },\n    asinh: function(x){\n        $B.check_nb_args('asinh', 1, arguments)\n        $B.check_no_kw('asinh', x)\n\n        if(_b_.$isninf(x)){return float.$factory('-inf')}\n        if(_b_.$isinf(x)){return float.$factory('inf')}\n        var y = float_check(x)\n        if(y == 0 && 1 / y === -Infinity){\n            return new Number(-0.0)\n        }\n        return float.$factory(Math.asinh(y))\n    },\n    atan: function(x){\n        $B.check_nb_args('atan', 1, arguments)\n        $B.check_no_kw('atan', x)\n\n        if(_b_.$isninf(x)){return float.$factory(-Math.PI / 2)}\n        if(_b_.$isinf(x)){return float.$factory(Math.PI / 2)}\n        return float.$factory(Math.atan(float_check(x)))\n    },\n    atan2: function(y, x){\n        $B.check_nb_args('atan2', 2, arguments)\n        $B.check_no_kw('atan2', y, x)\n\n        return float.$factory(Math.atan2(float_check(y), float_check(x)))\n    },\n    atanh: function(x){\n        $B.check_nb_args('atanh', 1, arguments)\n        $B.check_no_kw('atanh', x)\n        if(_b_.$isinf(x)){\n            throw _b_.ValueError.$factory(\"math domain error\")\n        }\n        var y = float_check(x)\n        if(y == 0){\n            return 0\n        }else if(y <= -1 || y >= 1){\n            throw _b_.ValueError.$factory(\"math domain error\")\n        }\n        return float.$factory(0.5 * Math.log((1 / y + 1)/(1 / y - 1)));\n    },\n    ceil: function(x){\n        $B.check_nb_args('ceil', 1, arguments)\n        $B.check_no_kw('ceil', x)\n\n        var res\n\n        if(x instanceof Number){\n            x = _b_.float.numerator(x)\n            if(_b_.$isinf(x) || _mod.isnan(x)){\n                return x\n            }\n            return _b_.int.$factory(Math.ceil(x))\n        }\n\n        try{\n            // Use attribute of the object's class, not of the object\n            // itself (special method)\n            return $B.$call($B.$getattr(x.__class__, '__ceil__'))(x)\n        }catch(err){\n            if(! $B.is_exc(err, [_b_.AttributeError])){\n                throw err\n            }\n        }\n\n        try{\n            x = $B.$call($B.$getattr(x.__class__, '__float__'))(x)\n        }catch(err){\n            if(! $B.is_exc(err, [_b_.AttributeError])){\n                throw err\n            }else{\n                throw _b_.TypeError.$factory(\"must be real number, not \" +\n                   $B.class_name(x))\n            }\n        }\n        return _mod.ceil(x)\n    },\n    comb: function(n, k){\n        $B.check_nb_args('comb', 2, arguments)\n        $B.check_no_kw('comb', n, k)\n\n        // raise TypeError if n or k is not an integer\n        check_int(n)\n        check_int(k)\n\n        if(k < 0){\n            throw _b_.ValueError.$factory(\"k must be a non-negative integer\")\n        }\n        if(n < 0){\n            throw _b_.ValueError.$factory(\"n must be a non-negative integer\")\n        }\n\n        if(k > n){\n            return 0\n        }\n        // Evaluates to n! / (k! * (n - k)!)\n        var fn = _mod.factorial(n),\n            fk = _mod.factorial(k),\n            fn_k = _mod.factorial(n - k)\n        return $B.floordiv(fn, $B.mul(fk, fn_k))\n    },\n    copysign: function(x, y){\n        $B.check_nb_args('copysign', 2, arguments)\n        $B.check_no_kw('copysign', x,y)\n\n        var x1 = Math.abs(float_check(x))\n        var y1 = float_check(y)\n        var sign = Math.sign(y1)\n        sign = (sign == 1 || Object.is(sign, +0)) ? 1 : - 1\n        return float.$factory(x1 * sign)\n    },\n    cos : function(x){\n        $B.check_nb_args('cos ', 1, arguments)\n        $B.check_no_kw('cos ', x)\n        return float.$factory(Math.cos(float_check(x)))\n    },\n    cosh: function(x){\n        $B.check_nb_args('cosh', 1, arguments)\n        $B.check_no_kw('cosh', x)\n\n        if(_b_.$isinf(x)) {return float.$factory('inf')}\n        var y = float_check(x)\n        if(Math.cosh !== undefined){return float.$factory(Math.cosh(y))}\n        return float.$factory((Math.pow(Math.E, y) +\n            Math.pow(Math.E, -y)) / 2)\n    },\n    degrees: function(x){\n        $B.check_nb_args('degrees', 1, arguments)\n        $B.check_no_kw('degrees', x)\n        return float.$factory(float_check(x) * 180 / Math.PI)\n    },\n    dist: function(p, q){\n        $B.check_nb_args('dist', 2, arguments)\n        $B.check_no_kw('dist', p, q)\n\n        function test(x){\n            if(typeof x === \"number\" || x instanceof Number){\n                return x\n            }\n            var y = $B.$getattr(x, '__float__', null)\n            if(y === null){\n                throw _b_.TypeError.$factory('not a float')\n            }\n            return $B.$call(y)()\n        }\n\n        // build list of differences (as floats) between coordinates of p and q\n        var diffs = [],\n            diff\n\n        if(Array.isArray(p) && Array.isArray(q)){\n            // simple case : p and q are lists of tuples\n            if(p.length != q.length){\n                throw _b_.ValueError.$factory(\"both points must have \" +\n                    \"the same number of dimensions\")\n            }\n            for(var i = 0, len = p.length; i < len; i++){\n                var next_p = test(p[i]),\n                    next_q = test(q[i]),\n                    diff = Math.abs(next_p - next_q)\n                if(_b_.$isinf(diff)){\n                    return _mod.inf\n                }\n                diffs.push(diff)\n            }\n        }else{\n            var itp = _b_.iter(p),\n                itq = _b_.iter(q),\n                res = 0\n\n            while(true){\n                try{\n                    var next_p = _b_.next(itp)\n                }catch(err){\n                    if(err.__class__ === _b_.StopIteration){\n                        // check that the other iterator is also exhausted\n                        try{\n                            var next_q = _b_.next(itq)\n                            throw _b_.ValueError.$factory(\"both points must have \" +\n                                \"the same number of dimensions\")\n                        }catch(err){\n                            if(err.__class__ === _b_.StopIteration){\n                                break\n                            }\n                            throw err\n                        }\n                    }\n                    throw err\n                }\n                next_p = test(next_p)\n                try{\n                    var next_q = _b_.next(itq)\n                }catch(err){\n                    if(err.__class__ === _b_.StopIteration){\n                        throw _b_.ValueError.$factory(\"both points must have \" +\n                            \"the same number of dimensions\")\n                    }\n                    throw err\n                }\n                next_q = test(next_q)\n                diff = Math.abs(next_p - next_q)\n                if(_b_.$isinf(diff)){\n                    return _mod.inf\n                }\n                diffs.push(diff)\n            }\n        }\n\n        var res = 0,\n            scale = 1,\n            max_diff = Math.max(...diffs),\n            min_diff = Math.min(...diffs)\n            max_value = Math.sqrt(Number.MAX_VALUE) / p.length,\n            min_value = Math.sqrt(Number.MIN_VALUE) * p.length\n        if(max_diff > max_value){\n            while(max_diff > max_value){\n                scale *= 2\n                max_diff /= 2\n            }\n            for(var diff of diffs){\n                diff = diff / scale\n                res += diff * diff\n            }\n            return scale * _mod.sqrt(res)\n        }else if(min_diff < min_value){\n            while(min_diff < min_value){\n                scale *= 2\n                min_diff *= 2\n            }\n            for(var diff of diffs){\n                diff = diff * scale\n                res += diff * diff\n            }\n            return _mod.sqrt(res) / scale\n        }else{\n            for(var diff of diffs){\n                res += Math.pow(diff, 2)\n            }\n            return _mod.sqrt(res)\n        }\n    },\n    e: float.$factory(Math.E),\n    erf: function(x){\n        $B.check_nb_args('erf', 1, arguments)\n        $B.check_no_kw('erf', x)\n\n        // inspired from\n        // http://stackoverflow.com/questions/457408/is-there-an-easily-available-implementation-of-erf-for-python\n        var y = float_check(x)\n        var t = 1.0 / (1.0 + 0.5 * Math.abs(y))\n        var ans = 1 - t * Math.exp( -y * y - 1.26551223 +\n                     t * ( 1.00002368 +\n                     t * ( 0.37409196 +\n                     t * ( 0.09678418 +\n                     t * (-0.18628806 +\n                     t * ( 0.27886807 +\n                     t * (-1.13520398 +\n                     t * ( 1.48851587 +\n                     t * (-0.82215223 +\n                     t * 0.17087277)))))))))\n        if(y >= 0.0){return ans}\n        return -ans\n    },\n    erfc: function(x){\n\n        $B.check_nb_args('erfc', 1, arguments)\n        $B.check_no_kw('erfc', x)\n\n        // inspired from\n        // http://stackoverflow.com/questions/457408/is-there-an-easily-available-implementation-of-erf-for-python\n        var y = float_check(x)\n        var t = 1.0 / (1.0 + 0.5 * Math.abs(y))\n        var ans = 1 - t * Math.exp( -y * y - 1.26551223 +\n                     t * ( 1.00002368 +\n                     t * ( 0.37409196 +\n                     t * ( 0.09678418 +\n                     t * (-0.18628806 +\n                     t * ( 0.27886807 +\n                     t * (-1.13520398 +\n                     t * ( 1.48851587 +\n                     t * (-0.82215223 +\n                     t * 0.17087277)))))))))\n        if(y >= 0.0){return 1 - ans}\n        return 1 + ans\n    },\n    exp: function(x){\n        $B.check_nb_args('exp', 1, arguments)\n        $B.check_no_kw('exp', x)\n\n         if(_b_.$isninf(x)){return float.$factory(0)}\n         if(_b_.$isinf(x)){return float.$factory('inf')}\n         var _r = Math.exp(float_check(x))\n         if(_b_.$isinf(_r)){throw _b_.OverflowError.$factory(\"math range error\")}\n         return float.$factory(_r)\n    },\n    expm1: function(x){\n        $B.check_nb_args('expm1', 1, arguments)\n        $B.check_no_kw('expm1', x)\n\n         if(_b_.$isninf(x)){return float.$factory(0)}\n         if(_b_.$isinf(x)){return float.$factory('inf')}\n         var _r = Math.expm1(float_check(x))\n         if(_b_.$isinf(_r)){throw _b_.OverflowError.$factory(\"math range error\")}\n         return float.$factory(_r)\n    },\n    //fabs: function(x){ return x>0?float.$factory(x):float.$factory(-x)},\n    fabs: function(x){\n        $B.check_nb_args('fabs', 1, arguments)\n        $B.check_no_kw('fabs', x)\n        return _b_.$fabs(x) // located in py_float.js\n    },\n    factorial: function(x){\n        $B.check_nb_args('factorial', 1, arguments)\n        $B.check_no_kw('factorial', x)\n\n        if(x instanceof Number || _b_.isinstance(x, float)){\n            var warning = _b_.DeprecationWarning.$factory(\n                \"Using factorial() with floats is deprecated\")\n            // module _warning is in builtin_modules.js\n            $B.imported._warnings.warn(warning)\n         }\n\n        if(! _b_.isinstance(x, [_b_.float, _b_.int])){\n            throw _b_.TypeError.$factory(`'${$B.class_name(x)}' object ` +\n                \"cannot be interpreted as an integer\")\n        }\n\n        //using code from http://stackoverflow.com/questions/3959211/fast-factorial-function-in-javascript\n        if(! check_int_or_round_float(x)){\n            throw _b_.ValueError.$factory(\"factorial() only accepts integral values\")\n        }else if($B.rich_comp(\"__lt__\", x, 0)){\n            throw _b_.ValueError.$factory(\"factorial() not defined for negative values\")\n        }\n        var r = 1\n        for(var i = 2; i <= x; i++){\n            r = $B.mul(r, i)\n        }\n        return r\n    },\n    floor: function(x){\n        $B.check_nb_args('floor', 1, arguments)\n        $B.check_no_kw('floor', x)\n        if(typeof x == \"number\" ||\n                x instanceof Number){\n            return Math.floor(float_check(x))\n        }\n        try{\n            return $B.$call($B.$getattr(x, \"__floor__\"))()\n        }catch(err){\n            if($B.is_exc(err, [_b_.AttributeError])){\n                try{\n                    var f = $B.$call($B.$getattr(x, \"__float__\"))()\n                    return _mod.floor(f)\n                }catch(err){\n                    if($B.is_exc(err, [_b_.AttributeError])){\n                        throw _b_.TypeError.$factory(\"no __float__\")\n                    }\n                    throw err\n                }\n            }\n        }\n    },\n    fmod: function(x,y){\n        $B.check_nb_args('fmod', 2, arguments)\n        $B.check_no_kw('fmod', x,y)\n        return float.$factory(float_check(x) % float_check(y))\n    },\n    frexp: function(x){\n        $B.check_nb_args('frexp', 1, arguments)\n        $B.check_no_kw('frexp', x)\n\n        var _l = _b_.$frexp(x)\n        return _b_.tuple.$factory([float.$factory(_l[0]), _l[1]])\n    },\n    fsum: function(x){\n        $B.check_nb_args('fsum', 1, arguments)\n        $B.check_no_kw('fsum', x)\n\n        /* Translation into Javascript of the function msum in an Active\n           State Cookbook recipe : https://code.activestate.com/recipes/393090/\n           by Raymond Hettinger\n        */\n        var partials = [],\n            res = new Number(),\n            _it = _b_.iter(x)\n        while(true){\n            try{\n                var x = _b_.next(_it),\n                    i = 0\n                for(var j = 0, len = partials.length; j < len; j++){\n                    var y = partials[j]\n                    if(Math.abs(x) < Math.abs(y)){\n                        var z = x\n                        x = y\n                        y = z\n                    }\n                    var hi = x + y,\n                        lo = y - (hi - x)\n                    if(lo){\n                        partials[i] = lo\n                        i++\n                    }\n                    x = hi\n                }\n                partials = partials.slice(0, i).concat([x])\n            }catch(err){\n                if(_b_.isinstance(err, _b_.StopIteration)){break}\n                throw err\n            }\n        }\n        var res = new Number(0)\n        for(var i = 0; i < partials.length; i++){\n            res += new Number(partials[i])\n        }\n        return new Number(res)\n    },\n    gamma: function(x){\n        $B.check_nb_args('gamma', 1, arguments)\n        $B.check_no_kw('gamma', x)\n\n        if(x === Number.POSITIVE_INFINITY){\n            return _mod.inf\n        }else if(x === Number.NEGATIVE_INFINITY){\n            throw _b_.ValueError.$factory(\"math domain error\")\n        }\n        if(_b_.isinstance(x, _b_.int) ||\n                (_b_.isinstance(x, _b_.float) && x == _b_.int.$factory(x))){\n            if(x < 1){\n                throw _b_.ValueError.$factory(\"math domain error\")\n            }\n            var res = 1\n            for(var i = 1; i < x; i++){res *= i}\n            return new Number(res)\n        }\n        // Adapted from https://en.wikipedia.org/wiki/Lanczos_approximation\n        var p = [676.5203681218851,\n            -1259.1392167224028,\n            771.32342877765313,\n            -176.61502916214059,\n            12.507343278686905,\n            -0.13857109526572012,\n            9.9843695780195716e-6,\n            1.5056327351493116e-7\n            ]\n\n        var EPSILON = 1e-07\n        function drop_imag(z){\n            if(Math.abs(z.imag) <= EPSILON){\n                z = z.real\n            }\n            return z\n        }\n        var z = x\n        if(z < 0){\n            // Use formula \u0393(z) = \u0393(z + n + 1) / z (z + 1) ... (z + n)\n            // with n such that z + n + 1 > 0\n            var n = Math.ceil(-z - 1),\n                g = _mod.gamma(new Number(z + n + 1))\n            for(var i = 0; i <= n; i++){\n                g = g / (z + i)\n            }\n            return g\n        }else if(z < 0.5){\n            var y = Math.PI / (Math.sin(Math.PI * z) * _mod.gamma(1-z)) // Reflection formula\n        }else{\n            z -= 1\n            var x = 0.99999999999980993,\n                i = 0\n            for(var i = 0, len = p.length; i < len; i++){\n                var pval = p[i]\n                x += pval / (z + i + 1)\n            }\n            var t = z + p.length - 0.5,\n                sq = Math.sqrt(2 * Math.PI),\n                y = sq * Math.pow(t, (z + 0.5)) * Math.exp(-t) * x\n        }\n        return drop_imag(y)\n    },\n    gcd: function(){\n        var $ = $B.args(\"gcd\", 0, {}, [], arguments, {}, 'args', null)\n        var args = $.args.map($B.PyNumber_Index)\n\n        if(args.length == 0){\n            return 0\n        }else if(args.length == 1){\n            return _b_.abs(args[0])\n        }\n        // https://stackoverflow.com/questions/17445231/js-how-to-find-the-greatest-common-divisor\n        var a = _b_.abs(args[0]),\n            b\n        for(var i = 1, len = args.length; i < len; i++){\n            a = gcd2(a, _b_.abs(args[i]))\n        }\n        return a\n    },\n    hypot: function(x, y){\n        var $ = $B.args(\"hypot\", 2, {x: null, y:null}, ['x', 'y'],\n                    arguments, {}, \"args\", null),\n            args = [x, y].concat($.args),\n            res = 0\n        return float.$factory(Math.hypot(...args))\n    },\n    inf: float.$factory('inf'),\n    isclose: function(){\n        var $ = $B.args(\"isclose\",\n                          4,\n                          {a: null, b: null, rel_tol: null, abs_tol: null},\n                          ['a', 'b', 'rel_tol', 'abs_tol'],\n                          arguments,\n                          {rel_tol: 1e-09, abs_tol: 0.0},\n                          '*',\n                          null)\n        var a = $.a,\n            b = $.b,\n            rel_tol = $.rel_tol,\n            abs_tol = $.abs_tol\n        if(rel_tol < 0.0 || abs_tol < 0.0){\n            throw ValueError.$factory('tolerances must be non-negative')\n        }\n\n        if(a == b){\n            return True\n        }\n        if(_b_.$isinf(a) || _b_.$isinf(b)){\n            return a === b\n        }\n        // isclose(a, b, rel_tol, abs_tol) is the same as\n        // abs_diff = abs(a - b)\n        // max_ab = max(abs(a), abs(b))\n        // abs_diff <= abs_tol or abs_diff / max_ab <= rel_tol\n        // This is more correct than in Python docs:\n        // \"abs(a-b) <= max(rel_tol * max(abs(a), abs(b)), abs_tol)\"\n        // because this fails for Decimal instances, which do not support\n        // multiplication by floats\n\n        var diff = $B.$call($B.$getattr(b, '__sub__'))(a),\n            abs_diff = $B.$call($B.$getattr(diff, \"__abs__\"))()\n        if($B.rich_comp(\"__le__\", abs_diff, abs_tol)){\n            return true\n        }\n        var abs_a = $B.$call($B.$getattr(a, '__abs__'))(),\n            abs_b = $B.$call($B.$getattr(b, '__abs__'))(),\n            max_ab = abs_a\n        if($B.rich_comp(\"__gt__\", abs_b, abs_a)){\n            max_ab = abs_b\n        }\n        return $B.rich_comp(\"__le__\",\n            $B.$call($B.$getattr(abs_diff, \"__truediv__\"))(max_ab),\n            rel_tol)\n    },\n    isfinite: function(x){\n        $B.check_nb_args('isfinite', 1, arguments)\n        $B.check_no_kw('isfinite', x)\n        return isFinite(float_check(x))\n    },\n    isinf: function(x){\n        $B.check_nb_args('isinf', 1, arguments)\n        $B.check_no_kw('isinf', x)\n        return _b_.$isinf(float_check(x))\n    },\n    isnan: function(x){\n        $B.check_nb_args('isnan', 1, arguments)\n        $B.check_no_kw('isnan', x)\n        return isNaN(float_check(x))\n    },\n    isqrt: function(x){\n        $B.check_nb_args('isqrt', 1, arguments)\n        $B.check_no_kw('isqrt', x)\n\n        x = $B.PyNumber_Index(x)\n        if($B.rich_comp(\"__lt__\", x, 0)){\n            throw _b_.ValueError.$factory(\n                \"isqrt() argument must be nonnegative\")\n        }\n        if(typeof x == \"number\"){\n            return Math.floor(Math.sqrt(x))\n        }else{ // big integer\n            var v = parseInt(x.value),\n                candidate = Math.floor(Math.sqrt(v)),\n                c1\n            // Use successive approximations : sqr = (sqr + (x / sqr)) / 2\n            // Limit to 100 iterations\n            for(var i = 0; i < 100; i++){\n                c1 = $B.floordiv($B.add(candidate,\n                    $B.floordiv(x, candidate)), 2)\n                if(c1 === candidate || c1.value === candidate.value){\n                    break\n                }\n                candidate = c1\n            }\n            if($B.rich_comp(\"__gt__\", $B.mul(candidate, candidate), x)){\n                // Result might be greater by 1\n                candidate = $B.sub(candidate, 1)\n            }\n            return candidate\n        }\n    },\n    lcm: function(){\n        var $ = $B.args(\"lcm\", 0, {}, [], arguments, {}, 'args', null),\n            product = 1\n\n        var args = $.args.map($B.PyNumber_Index)\n        if(args.length == 0){\n            return 1\n        }else if(args.length == 1){\n            return _b_.abs(args[0])\n        }\n        var a = _b_.abs(args[0]),\n            b,\n            product, gcd\n        for(var i = 0, len = args.length; i < len; i++){\n            b = _b_.abs(args[i])\n            if(b == 0){\n                return 0\n            }\n            gcd = gcd2(a, b)\n            product = $B.mul(a, b)\n            a = $B.$getattr(product, \"__floordiv__\")(gcd)\n        }\n        return a\n    },\n    ldexp: function(x, i){\n        $B.check_nb_args('ldexp', 2, arguments)\n        $B.check_no_kw('ldexp', x, i)\n        return _b_.$ldexp(x, i)   //located in py_float.js\n    },\n    lgamma: function(x){\n        $B.check_nb_args('lgamma', 1, arguments)\n        $B.check_no_kw('lgamma', x)\n\n        // copied from\n        // https://github.com/czurnieden/ieee745gamma/blob/master/ieee745gamma.js\n        // by Christoph Zurnieden\n        // see \"LICENCE math lgamma.txt\"\n        var double_int = new DataView(new ArrayBuffer(8))\n        var half = 5.00000000000000000000e-01 /* 0x3FE00000, 0x00000000 */\n        var one = 1.00000000000000000000e+00 /* 0x3FF00000, 0x00000000 */\n        var pi = 3.14159265358979311600e+00 /* 0x400921FB, 0x54442D18 */\n        var a0 = 7.72156649015328655494e-02 /* 0x3FB3C467, 0xE37DB0C8 */\n        var a1 = 3.22467033424113591611e-01 /* 0x3FD4A34C, 0xC4A60FAD */\n        var a2 = 6.73523010531292681824e-02 /* 0x3FB13E00, 0x1A5562A7 */\n        var a3 = 2.05808084325167332806e-02 /* 0x3F951322, 0xAC92547B */\n        var a4 = 7.38555086081402883957e-03 /* 0x3F7E404F, 0xB68FEFE8 */\n        var a5 = 2.89051383673415629091e-03 /* 0x3F67ADD8, 0xCCB7926B */\n        var a6 = 1.19270763183362067845e-03 /* 0x3F538A94, 0x116F3F5D */\n        var a7 = 5.10069792153511336608e-04 /* 0x3F40B6C6, 0x89B99C00 */\n        var a8 = 2.20862790713908385557e-04 /* 0x3F2CF2EC, 0xED10E54D */\n        var a9 = 1.08011567247583939954e-04 /* 0x3F1C5088, 0x987DFB07 */\n        var a10 = 2.52144565451257326939e-05 /* 0x3EFA7074, 0x428CFA52 */\n        var a11 = 4.48640949618915160150e-05 /* 0x3F07858E, 0x90A45837 */\n        var tc = 1.46163214496836224576e+00 /* 0x3FF762D8, 0x6356BE3F */\n        var tf = -1.21486290535849611461e-01 /* 0xBFBF19B9, 0xBCC38A42 */\n        /* tt = -(tail of tf) */\n        var tt = -3.63867699703950536541e-18 /* 0xBC50C7CA, 0xA48A971F */\n        var t0 = 4.83836122723810047042e-01 /* 0x3FDEF72B, 0xC8EE38A2 */\n        var t1 = -1.47587722994593911752e-01 /* 0xBFC2E427, 0x8DC6C509 */\n        var t2 = 6.46249402391333854778e-02 /* 0x3FB08B42, 0x94D5419B */\n        var t3 = -3.27885410759859649565e-02 /* 0xBFA0C9A8, 0xDF35B713 */\n        var t4 = 1.79706750811820387126e-02 /* 0x3F9266E7, 0x970AF9EC */\n        var t5 = -1.03142241298341437450e-02 /* 0xBF851F9F, 0xBA91EC6A */\n        var t6 = 6.10053870246291332635e-03 /* 0x3F78FCE0, 0xE370E344 */\n        var t7 = -3.68452016781138256760e-03 /* 0xBF6E2EFF, 0xB3E914D7 */\n        var t8 = 2.25964780900612472250e-03 /* 0x3F6282D3, 0x2E15C915 */\n        var t9 = -1.40346469989232843813e-03 /* 0xBF56FE8E, 0xBF2D1AF1 */\n        var t10 = 8.81081882437654011382e-04 /* 0x3F4CDF0C, 0xEF61A8E9 */\n        var t11 = -5.38595305356740546715e-04 /* 0xBF41A610, 0x9C73E0EC */\n        var t12 = 3.15632070903625950361e-04 /* 0x3F34AF6D, 0x6C0EBBF7 */\n        var t13 = -3.12754168375120860518e-04 /* 0xBF347F24, 0xECC38C38 */\n        var t14 = 3.35529192635519073543e-04 /* 0x3F35FD3E, 0xE8C2D3F4 */\n        var u0 = -7.72156649015328655494e-02 /* 0xBFB3C467, 0xE37DB0C8 */\n        var u1 = 6.32827064025093366517e-01 /* 0x3FE4401E, 0x8B005DFF */\n        var u2 = 1.45492250137234768737e+00 /* 0x3FF7475C, 0xD119BD6F */\n        var u3 = 9.77717527963372745603e-01 /* 0x3FEF4976, 0x44EA8450 */\n        var u4 = 2.28963728064692451092e-01 /* 0x3FCD4EAE, 0xF6010924 */\n        var u5 = 1.33810918536787660377e-02 /* 0x3F8B678B, 0xBF2BAB09 */\n        var v1 = 2.45597793713041134822e+00 /* 0x4003A5D7, 0xC2BD619C */\n        var v2 = 2.12848976379893395361e+00 /* 0x40010725, 0xA42B18F5 */\n        var v3 = 7.69285150456672783825e-01 /* 0x3FE89DFB, 0xE45050AF */\n        var v4 = 1.04222645593369134254e-01 /* 0x3FBAAE55, 0xD6537C88 */\n        var v5 = 3.21709242282423911810e-03 /* 0x3F6A5ABB, 0x57D0CF61 */\n        var s0 = -7.72156649015328655494e-02 /* 0xBFB3C467, 0xE37DB0C8 */\n        var s1 = 2.14982415960608852501e-01 /* 0x3FCB848B, 0x36E20878 */\n        var s2 = 3.25778796408930981787e-01 /* 0x3FD4D98F, 0x4F139F59 */\n        var s3 = 1.46350472652464452805e-01 /* 0x3FC2BB9C, 0xBEE5F2F7 */\n        var s4 = 2.66422703033638609560e-02 /* 0x3F9B481C, 0x7E939961 */\n        var s5 = 1.84028451407337715652e-03 /* 0x3F5E26B6, 0x7368F239 */\n        var s6 = 3.19475326584100867617e-05 /* 0x3F00BFEC, 0xDD17E945 */\n        var r1 = 1.39200533467621045958e+00 /* 0x3FF645A7, 0x62C4AB74 */\n        var r2 = 7.21935547567138069525e-01 /* 0x3FE71A18, 0x93D3DCDC */\n        var r3 = 1.71933865632803078993e-01 /* 0x3FC601ED, 0xCCFBDF27 */\n        var r4 = 1.86459191715652901344e-02 /* 0x3F9317EA, 0x742ED475 */\n        var r5 = 7.77942496381893596434e-04 /* 0x3F497DDA, 0xCA41A95B */\n        var r6 = 7.32668430744625636189e-06 /* 0x3EDEBAF7, 0xA5B38140 */\n        var w0 = 4.18938533204672725052e-01 /* 0x3FDACFE3, 0x90C97D69 */\n        var w1 = 8.33333333333329678849e-02 /* 0x3FB55555, 0x5555553B */\n        var w2 = -2.77777777728775536470e-03 /* 0xBF66C16C, 0x16B02E5C */\n        var w3 = 7.93650558643019558500e-04 /* 0x3F4A019F, 0x98CF38B6 */\n        var w4 = -5.95187557450339963135e-04 /* 0xBF4380CB, 0x8C0FE741 */\n        var w5 = 8.36339918996282139126e-04 /* 0x3F4B67BA, 0x4CDAD5D1 */\n        var w6 = -1.63092934096575273989e-03 /* 0xBF5AB89D, 0x0B9E43E4 */\n        var zero = 0.00000000000000000000e+00\n\n        var t, y, z, nadj = 0,\n          p, p1, p2, p3, q, r, w\n\n        var i = 0 | 0,\n          hx = 0 | 0,\n          lx = 0 | 0,\n          ix = 0 | 0\n\n        double_int.setFloat64(0, x)\n\n        hx = double_int.getInt32(0) /* high word */\n        lx = double_int.getInt32(4) /* low word */\n\n        /* purge off +-inf, NaN, +-0, and negative arguments */\n        lgamma_sign = 1\n        ix = hx & 0x7fffffff\n        if(ix >= 0x7ff00000){\n          return new Number(x * x)\n        }\n        if((ix | lx) == 0){\n          if(hx & 0x80000000){\n            lgamma_sign = -1\n          }\n          return new Number(one / zero)\n        }\n        if(ix < 0x3b900000){ /* |x|<2**-70, return -log(|x|) */\n          if(hx < 0){\n            lgamma_sign = -1\n            return new Number(-Math.log(-x))\n          } else {\n            return new Number(-Math.log(x))\n          }\n        }\n        if(hx < 0){\n          if(ix >= 0x43300000){ /* |x|>=2**52, must be -integer */\n            return new Number(one / zero)\n          }\n          t = sin_pi(x)\n          if(t == zero){\n            return new Number(one / zero)\n          } /* -integer */\n          nadj = Math.log(pi / Math.abs(t * x))\n          if(t < zero){\n            lgamma_sign = -1\n          }\n          x = -x\n        }\n        /* purge off 1 and 2 */\n        if((((ix - 0x3ff00000) | lx) == 0) || (((ix - 0x40000000) | lx) == 0)){\n          r = 0\n        }\n        /* for x < 2.0 */\n        else if(ix < 0x40000000){\n          if(ix <= 0x3feccccc){ /* lgamma(x) = lgamma(x+1)-log(x) */\n            r = -Math.log(x)\n            if(ix >= 0x3FE76944){\n              y = one - x\n              i = 0\n            }else if(ix >= 0x3FCDA661){\n              y = x - (tc - one)\n              i = 1\n            }else{\n              y = x\n              i = 2\n            }\n          }else{\n            r = zero\n            if(ix >= 0x3FFBB4C3){\n              y = 2.0 - x\n              i = 0\n            } /* [1.7316,2] */\n            else if(ix >= 0x3FF3B4C4){\n              y = x - tc\n              i = 1\n            } /* [1.23,1.73] */\n            else{\n              y = x - one\n              i = 2\n            }\n          }\n          switch(i){\n            case 0:\n              z = y * y\n              p1 = a0 + z * (a2 + z * (a4 + z * (a6 + z * (a8 + z * a10))))\n              p2 = z * (a1 + z * (a3 + z * (a5 + z * (a7 + z * (a9 + z * a11)))))\n              p = y * p1 + p2\n              r += (p - 0.5 * y)\n              break\n            case 1:\n              z = y * y\n              w = z * y\n              p1 = t0 + w * (t3 + w * (t6 + w * (t9 + w * t12))) /* parallel comp */\n              p2 = t1 + w * (t4 + w * (t7 + w * (t10 + w * t13)))\n              p3 = t2 + w * (t5 + w * (t8 + w * (t11 + w * t14)))\n              p = z * p1 - (tt - w * (p2 + y * p3))\n              r += (tf + p)\n              break\n            case 2:\n              p1 = y * (u0 + y * (u1 + y * (u2 + y * (u3 + y * (u4 + y * u5)))))\n              p2 = one + y * (v1 + y * (v2 + y * (v3 + y * (v4 + y * v5))))\n              r += (-0.5 * y + p1 / p2)\n          }\n        }else if(ix < 0x40200000){ /* x < 8.0 */\n          i = x | 0\n          t = zero\n          y = x - i\n          p = y * (s0 + y * (s1 + y * (s2 + y * (s3 + y * (s4 + y * (s5 + y *\n            s6))))))\n          q = one + y * (r1 + y * (r2 + y * (r3 + y * (r4 + y * (r5 + y * r6)))))\n          r = half * y + p / q\n          z = one /* lgamma(1+s) = log(s) + lgamma(s) */\n          switch(i){\n            case 7:\n              z *= (y + 6.0) /* FALLTHRU */\n            case 6:\n              z *= (y + 5.0) /* FALLTHRU */\n            case 5:\n              z *= (y + 4.0) /* FALLTHRU */\n            case 4:\n              z *= (y + 3.0) /* FALLTHRU */\n            case 3:\n              z *= (y + 2.0) /* FALLTHRU */\n              r += Math.log(z)\n              break\n          }\n          /* 8.0 <= x < 2**58 */\n        }else if(ix < 0x43900000){\n          t = Math.log(x)\n          z = one / x\n          y = z * z\n          w = w0 + z * (w1 + y * (w2 + y * (w3 + y * (w4 + y * (w5 + y * w6)))))\n          r = (x - half) * (t - one) + w\n        }else{\n          /* 2**58 <= x <= inf */\n          r = x * (Math.log(x) - one)\n        }\n        if(hx < 0){\n          r = nadj - r\n        }\n        return new Number(r)\n    },\n    log: function(x, base){\n        var $ = $B.args(\"log\", 2, {x: null, base: null}, ['x', 'base'],\n            arguments, {base: _b_.None}, null, null),\n            x = $.x,\n            base = $.base\n\n         var x1 = float_check(x)\n         if(base === _b_.None){return float.$factory(Math.log(x1))}\n         return float.$factory(Math.log(x1) / Math.log(float_check(base)))\n    },\n    log1p: function(x){\n        $B.check_nb_args('log1p', 1, arguments)\n        $B.check_no_kw('log1p', x)\n        return float.$factory(Math.log1p(float_check(x)))\n    },\n    log2: function(x){\n        $B.check_nb_args('log2', 1, arguments)\n        $B.check_no_kw('log2', x)\n\n        if(isNaN(x)){return float.$factory('nan')}\n        if(_b_.$isninf(x)) {throw ValueError.$factory('')}\n        var x1 = float_check(x)\n        if(x1 < 0.0){throw ValueError.$factory('')}\n        return float.$factory(Math.log(x1) / Math.LN2)\n    },\n    log10: function(x){\n        $B.check_nb_args('log10', 1, arguments)\n        $B.check_no_kw('log10', x)\n\n        return float.$factory(Math.log10(float_check(x)))\n    },\n    modf: function(x){\n        $B.check_nb_args('modf', 1, arguments)\n        $B.check_no_kw('modf', x)\n\n       if(_b_.$isninf(x)){\n           return _b_.tuple.$factory([0.0, float.$factory('-inf')])\n       }\n       if(_b_.$isinf(x)){\n           return _b_.tuple.$factory([0.0, float.$factory('inf')])\n       }\n       if(isNaN(x)){\n           return _b_.tuple.$factory([float.$factory('nan'),\n               float.$factory('nan')])\n       }\n\n       var x1 = float_check(x)\n       if(x1 > 0){\n          var i = float.$factory(x1 - Math.floor(x1))\n          return _b_.tuple.$factory([i, float.$factory(x1 - i)])\n       }\n\n       var x2 = Math.ceil(x1)\n       var i = float.$factory(x1 - x2)\n       return _b_.tuple.$factory([i, float.$factory(x2)])\n    },\n    nan: float.$factory('nan'),\n    nextafter: function(){\n        var $ = $B.args(\"nextafter\", 2, {x: null, y: null}, ['x', 'y'],\n                    arguments, {}, null, null),\n            x = $.x,\n            y = $.y\n        return y < x ? -nextUp(-x) : (y > x ? nextUp(x) : (x !== x ? x : y))\n    },\n    perm: function(n, k){\n        var $ = $B.args(\"perm\", 2, {n: null, k: null}, ['n', 'k'],\n                        arguments, {k: _b_.None}, null, null),\n            n = $.n,\n            k = $.k\n\n        if(k === _b_.None){\n            check_int(n)\n            return _mod.factorial(n)\n        }\n        // raise TypeError if n or k is not an integer\n        check_int(n)\n        check_int(k)\n\n        if(k < 0){\n            throw _b_.ValueError.$factory(\"k must be a non-negative integer\")\n        }\n        if(n < 0){\n            throw _b_.ValueError.$factory(\"n must be a non-negative integer\")\n        }\n\n        if(k > n){\n            return 0\n        }\n        // Evaluates to n! / (n - k)!\n        var fn = _mod.factorial(n),\n            fn_k = _mod.factorial(n - k)\n        return $B.floordiv(fn, fn_k)\n    },\n    pi : float.$factory(Math.PI),\n    pow: function(){\n        var $ = $B.args(\"pow\", 2, {base: null, exp: null}, ['base', 'exp'],\n                    arguments, {}, null, null),\n            x = $.base,\n            y = $.exp\n\n        var x1 = float_check(x)\n        var y1 = float_check(y)\n        if(y1 == 0){return float.$factory(1)}\n        if(x1 == 0 && y1 < 0){throw _b_.ValueError.$factory('')}\n\n        if(isNaN(y1)){\n            if(x1 == 1){return float.$factory(1)}\n            return float.$factory('nan')\n        }\n        if(x1 == 0){return float.$factory(0)}\n\n        if(_b_.$isninf(y)){\n            if(x1 == 1 || x1 == -1){return float.$factory(1)}\n            if(x1 < 1 && x1 > -1){return float.$factory('inf')}\n            return float.$factory(0)\n        }\n        if(_b_.$isinf(y)){\n            if(x1 == 1 || x1 == -1){return float.$factory(1)}\n            if(x1 < 1 && x1 > -1){return float.$factory(0)}\n            return float.$factory('inf')\n        }\n\n        if(isNaN(x1)){return float.$factory('nan')}\n        if(_b_.$isninf(x)){\n            if(y1 > 0 && isOdd(y1)){return float.$factory('-inf')}\n            if(y1 > 0){return float.$factory('inf')}  // this is even or a float\n            if(y1 < 0){return float.$factory(0)}\n            return float.$factory(1)\n        }\n\n        if(_b_.$isinf(x)){\n            if(y1 > 0){return float.$factory('inf')}\n            if(y1 < 0){return float.$factory(0)}\n            return float.$factory(1)\n        }\n\n        var r = Math.pow(x1, y1)\n        if(isNaN(r)){return float.$factory('nan')}\n        if(_b_.$isninf(r)){return float.$factory('-inf')}\n        if(_b_.$isinf(r)){return float.$factory('inf')}\n\n        return r\n    },\n    prod: function(){\n        var $ = $B.args(\"prod\", 1, {iterable:null, start:null},\n                        [\"iterable\", \"start\"], arguments, {start: 1}, \"*\",\n                        null),\n            iterable = $.iterable,\n            start = $.start\n        var res = start,\n            it = _b_.iter(iterable),\n            x\n        while(true){\n            try{\n                x = _b_.next(it)\n                if(x == 0){\n                    return 0\n                }\n                res = $B.mul(res, x)\n            }catch(err){\n                if(err.__class__ === _b_.StopIteration){\n                    return res\n                }\n                throw err\n            }\n        }\n    },\n    radians: function(x){\n        $B.check_nb_args('radians', 1, arguments)\n        $B.check_no_kw('radians', x)\n\n        return float.$factory(float_check(x) * Math.PI / 180)\n    },\n    remainder: function(x, y){\n        $B.check_nb_args('remainder', 2, arguments)\n        $B.check_no_kw('remainder', x, y)\n        if(_mod.isnan(x) || _mod.isnan(y)){\n            return _mod.nan\n        }\n        if(_b_.$isinf(x) || y == 0){\n            throw _b_.ValueError.$factory(\"math domain error\")\n        }\n        x = float_check(x)\n        y = float_check(y)\n        var quotient = x / y,\n            rounded = _b_.round(quotient)\n        if(rounded == 0){\n            return _b_.float.$factory(x)\n        }\n        var res = _b_.float.$factory(x - rounded * y)\n        if(_b_.$isinf(res)){\n            // happens if rounded * y is infinite\n            res = _b_.float.$factory(rounded * (x / rounded - y))\n        }\n        return res\n    },\n    sin : function(x){\n        $B.check_nb_args('sin ', 1, arguments)\n        $B.check_no_kw('sin ', x)\n        return float.$factory(Math.sin(float_check(x)))},\n    sinh: function(x) {\n        $B.check_nb_args('sinh', 1, arguments)\n        $B.check_no_kw('sinh', x)\n\n        var y = float_check(x)\n        if(Math.sinh !== undefined){return float.$factory(Math.sinh(y))}\n        return float.$factory(\n            (Math.pow(Math.E, y) - Math.pow(Math.E, -y)) / 2)\n    },\n    sqrt: function(x){\n        $B.check_nb_args('sqrt ', 1, arguments)\n        $B.check_no_kw('sqrt ', x)\n\n      var y = float_check(x)\n      if(y < 0){throw ValueError.$factory(\"math range error\")}\n      if(_b_.$isinf(y)){return float.$factory('inf')}\n      var _r = Math.sqrt(y)\n      if(_b_.$isinf(_r)){throw _b_.OverflowError.$factory(\"math range error\")}\n      return float.$factory(_r)\n    },\n    tan: function(x) {\n        $B.check_nb_args('tan', 1, arguments)\n        $B.check_no_kw('tan', x)\n\n        var y = float_check(x)\n        return float.$factory(Math.tan(y))\n    },\n    tanh: function(x) {\n        $B.check_nb_args('tanh', 1, arguments)\n        $B.check_no_kw('tanh', x)\n\n        var y = float_check(x)\n        if(Math.tanh !== undefined){return float.$factory(Math.tanh(y))}\n        return float.$factory((Math.pow(Math.E, y) - Math.pow(Math.E, -y))/\n             (Math.pow(Math.E, y) + Math.pow(Math.E, -y)))\n    },\n    tau: 6.283185307179586,\n    trunc: function(x) {\n        $B.check_nb_args('trunc', 1, arguments)\n        $B.check_no_kw('trunc', x)\n\n       try{return getattr(x, '__trunc__')()}catch(err){}\n       var x1 = float_check(x)\n       if(!isNaN(parseFloat(x1)) && isFinite(x1)){\n          if(Math.trunc !== undefined){return int.$factory(Math.trunc(x1))}\n          if(x1 > 0){return int.$factory(Math.floor(x1))}\n          return int.$factory(Math.ceil(x1))  // x1 < 0\n       }\n       throw _b_.ValueError.$factory(\n           'object is not a number and does not contain __trunc__')\n    },\n    ulp: function(){\n        var $ = $B.args(\"ulp\", 1, {x: null}, ['x'], arguments, {}, null, null),\n            x = $.x\n        if(x == MAX_VALUE){\n            return MAX_VALUE - _mod.nextafter(MAX_VALUE, 0)\n        }else if(_b_.$isinf(x)){\n            return _mod.inf\n        }\n        if(typeof x == \"number\" || x instanceof Number){\n            return x > 0 ? nextUp(x) - x : x - (-nextUp(-x))\n        }else{\n            if($B.rich_comp('__gt__', x, 0)){\n                return $B.rich_op('sub', nextUp(x), x)\n            }else{\n                var neg_x = $B.$call($B.$getattr(x, \"__neg__\"))()\n                return $B.rich_op('sub', x,\n                    $B.$call($B.$getattr(nextUp(neg_x), '__neg__'))())\n            }\n        }\n    }\n}\n\nfor(var $attr in _mod){\n    if(typeof _mod[$attr] === 'function'){\n        _mod[$attr].__class__ = $B.builtin_function\n    }\n}\n\nreturn _mod\n\n})(__BRYTHON__)\n"],
+    "math": [".js", "var $module = (function($B){\n\nvar _b_ = $B.builtins\n\n\nvar float_check = function(x) {\n    if(x.__class__ === $B.long_int){\n        return parseInt(x.value)\n    }\n    return _b_.float.$factory(x)\n}\n\nfunction check_int(x){\n    if(! _b_.isinstance(x, _b_.int)){\n        throw _b_.TypeError.$factory(\"'\" + $B.class_name(x) +\n            \"' object cannot be interpreted as an integer\")\n    }\n}\n\nfunction check_int_or_round_float(x){\n    return (x instanceof Number && x == Math.floor(x)) ||\n            _b_.isinstance(x, _b_.int)\n}\n\nvar isWholeNumber = function(x){return (x * 10) % 10 == 0}\n\nvar isOdd = function(x) {return isWholeNumber(x) && 2 * Math.floor(x / 2) != x}\n\nvar isNegZero = function(x) {return x === 0 && Math.atan2(x,x) < 0}\n\nvar EPSILON = Math.pow(2, -52),\n    MAX_VALUE = (2 - EPSILON) * Math.pow(2, 1023),\n    MIN_VALUE = Math.pow(2, -1022);\n\nfunction nextUp(x){\n    if(x !== x){\n        return x\n    }\n    if(_b_.$isinf(x)){\n        if(_b_.$isninf(x)){\n            return -MAX_VALUE\n        }\n        return _mod.inf\n    }\n\n    if(x == +MAX_VALUE){\n        return +1 / 0\n    }\n    if(typeof x == \"number\" || x instanceof Number){\n        var y = x * (x < 0 ? 1 - EPSILON / 2 : 1 + EPSILON)\n        if(y == x){\n            y = MIN_VALUE * EPSILON > 0 ? x + MIN_VALUE * EPSILON : x + MIN_VALUE\n        }\n        if(y === +1 / 0){\n            y = +MAX_VALUE\n        }\n        var b = x + (y - x) / 2\n        if(x < b && b < y){\n            y = b;\n        }\n        var c = (y + x) / 2\n        if(x < c && c < y){\n            y = c;\n        }\n        return y === 0 ? -0 : y\n    }else{\n        var factor = $B.rich_comp('__lt__', x, 0) ? 1 - EPSILON / 2 :\n                                                   1 + EPSILON\n        var y = $B.rich_op(\"mul\", x , factor)\n        if(y == x){\n            y = MIN_VALUE * EPSILON > 0 ?\n                    $B.rich_op('add', x, MIN_VALUE * EPSILON) :\n                    $B.rich_op('add', x, MIN_VALUE)\n        }\n        if(y === +1 / 0){\n            y = +MAX_VALUE\n        }\n        var y_minus_x = $B.rich_op('sub', y, x)\n        var z = $B.rich_op('truediv', y_minus_x, 2) // (y - x) / 2\n\n        var b = $B.rich_op('add', x, z)\n        if($B.rich_comp('__lt__', x, b) && $B.rich_comp('__lt__', b, y)){\n            y = b;\n        }\n        var c = $B.rich_op('truediv', $B.rich_op('add', y, x), 2)\n        if($B.rich_comp('__lt__', x, c) && $B.rich_comp('__lt__', c, y)){\n            y = c;\n        }\n        return y === 0 ? -0 : y\n    }\n}\n\nfunction gcd2(a, b){\n    // GCD of 2 factors\n    if($B.rich_comp(\"__gt__\", b, a)){\n        var temp = a\n        a = b\n        b = temp\n    }\n    while(true){\n        if(b == 0){\n            return a\n        }\n        a = $B.rich_op(\"mod\", a, b)\n        if(a == 0){\n            return b\n        }\n        b = $B.rich_op(\"mod\", b, a)\n    }\n}\n\nvar _mod = {\n    __getattr__: function(attr){\n        $B.check_nb_args('__getattr__ ', 1, arguments)\n        $B.check_no_kw('__getattr__ ', attr)\n\n        var res = this[attr]\n        if(res === undefined){\n            throw _b_.AttributeError.$factory(\n                'module math has no attribute ' + attr)\n        }\n        return res\n    },\n    acos: function(x){\n        $B.check_nb_args('acos', 1, arguments)\n        $B.check_no_kw('acos', x)\n        if(_mod.isinf(x)){\n            throw _b_.ValueError.$factory(\"math domain error\")\n        }else if(_mod.isnan(x)){\n            return _mod.nan\n        }else{\n            x = float_check(x)\n            if(x > 1 || x < -1){\n                throw _b_.ValueError.$factory(\"math domain error\")\n            }\n            return _b_.float.$factory(Math.acos(x))\n        }\n    },\n    acosh: function(x){\n        $B.check_nb_args('acosh', 1, arguments)\n        $B.check_no_kw('acosh', x)\n\n        if(_b_.$isinf(x)){\n            if(_b_.$isninf(x)){\n                throw _b_.ValueError.$factory(\"math domain error\")\n            }\n            return _mod.inf\n        }else if(_mod.isnan(x)){\n            return _mod.nan\n        }\n        var y = float_check(x)\n        if(y <= 0){\n            throw _b_.ValueError.$factory(\"math domain error\")\n        }\n        if(y > Math.pow(2, 28)){ // issue 1590\n            return _b_.float.$factory(_mod.log(y) + _mod.log(2))\n        }\n        return _b_.float.$factory(Math.log(y + Math.sqrt(y * y - 1)))\n    },\n    asin: function(x){\n        $B.check_nb_args('asin', 1, arguments)\n        $B.check_no_kw('asin', x)\n        if(_mod.isinf(x)){\n            throw _b_.ValueError.$factory(\"math domain error\")\n        }else if(_mod.isnan(x)){\n            return _mod.nan\n        }else{\n            x = float_check(x)\n            if(x > 1 || x < -1){\n                throw _b_.ValueError.$factory(\"math domain error\")\n            }\n            return _b_.float.$factory(Math.asin(x))\n        }\n    },\n    asinh: function(x){\n        $B.check_nb_args('asinh', 1, arguments)\n        $B.check_no_kw('asinh', x)\n\n        if(_b_.$isninf(x)){return _b_.float.$factory('-inf')}\n        if(_b_.$isinf(x)){return _b_.float.$factory('inf')}\n        var y = float_check(x)\n        if(y == 0 && 1 / y === -Infinity){\n            return new Number(-0.0)\n        }\n        return _b_.float.$factory(Math.asinh(y))\n    },\n    atan: function(x){\n        $B.check_nb_args('atan', 1, arguments)\n        $B.check_no_kw('atan', x)\n\n        if(_b_.$isninf(x)){return _b_.float.$factory(-Math.PI / 2)}\n        if(_b_.$isinf(x)){return _b_.float.$factory(Math.PI / 2)}\n        return _b_.float.$factory(Math.atan(float_check(x)))\n    },\n    atan2: function(y, x){\n        $B.check_nb_args('atan2', 2, arguments)\n        $B.check_no_kw('atan2', y, x)\n\n        return _b_.float.$factory(Math.atan2(float_check(y), float_check(x)))\n    },\n    atanh: function(x){\n        $B.check_nb_args('atanh', 1, arguments)\n        $B.check_no_kw('atanh', x)\n        if(_b_.$isinf(x)){\n            throw _b_.ValueError.$factory(\"math domain error\")\n        }\n        var y = float_check(x)\n        if(y == 0){\n            return 0\n        }else if(y <= -1 || y >= 1){\n            throw _b_.ValueError.$factory(\"math domain error\")\n        }\n        return _b_.float.$factory(0.5 * Math.log((1 / y + 1)/(1 / y - 1)));\n    },\n    ceil: function(x){\n        $B.check_nb_args('ceil', 1, arguments)\n        $B.check_no_kw('ceil', x)\n\n        var res\n\n        if(x instanceof Number){\n            x = _b_.float.numerator(x)\n            if(_b_.$isinf(x) || _mod.isnan(x)){\n                return x\n            }\n            return _b_.int.$factory(Math.ceil(x))\n        }\n\n        var klass = x.__class__ || $B.get_class(x)\n\n        try{\n            // Use attribute of the object's class, not of the object\n            // itself (special method)\n            return $B.$call($B.$getattr(klass, '__ceil__'))(x)\n        }catch(err){\n            if(! $B.is_exc(err, [_b_.AttributeError])){\n                throw err\n            }\n        }\n\n        try{\n            x = $B.$call($B.$getattr(klass, '__float__'))(x)\n        }catch(err){\n            if(! $B.is_exc(err, [_b_.AttributeError])){\n                throw err\n            }else{\n                throw _b_.TypeError.$factory(\"must be real number, not \" +\n                   $B.class_name(x))\n            }\n        }\n        return _mod.ceil(x)\n    },\n    comb: function(n, k){\n        $B.check_nb_args('comb', 2, arguments)\n        $B.check_no_kw('comb', n, k)\n\n        // raise TypeError if n or k is not an integer\n        check_int(n)\n        check_int(k)\n\n        if(k < 0){\n            throw _b_.ValueError.$factory(\"k must be a non-negative integer\")\n        }\n        if(n < 0){\n            throw _b_.ValueError.$factory(\"n must be a non-negative integer\")\n        }\n\n        if(k > n){\n            return 0\n        }\n        // Evaluates to n! / (k! * (n - k)!)\n        var fn = _mod.factorial(n),\n            fk = _mod.factorial(k),\n            fn_k = _mod.factorial(n - k)\n        return $B.floordiv(fn, $B.mul(fk, fn_k))\n    },\n    copysign: function(x, y){\n        $B.check_nb_args('copysign', 2, arguments)\n        $B.check_no_kw('copysign', x,y)\n\n        var x1 = Math.abs(float_check(x))\n        var y1 = float_check(y)\n        var sign = Math.sign(y1)\n        sign = (sign == 1 || Object.is(sign, +0)) ? 1 : - 1\n        return _b_.float.$factory(x1 * sign)\n    },\n    cos : function(x){\n        $B.check_nb_args('cos ', 1, arguments)\n        $B.check_no_kw('cos ', x)\n        return _b_.float.$factory(Math.cos(float_check(x)))\n    },\n    cosh: function(x){\n        $B.check_nb_args('cosh', 1, arguments)\n        $B.check_no_kw('cosh', x)\n\n        if(_b_.$isinf(x)){return _b_.float.$factory('inf')}\n        var y = float_check(x)\n        if(Math.cosh !== undefined){return _b_.float.$factory(Math.cosh(y))}\n        return _b_.float.$factory((Math.pow(Math.E, y) +\n            Math.pow(Math.E, -y)) / 2)\n    },\n    degrees: function(x){\n        $B.check_nb_args('degrees', 1, arguments)\n        $B.check_no_kw('degrees', x)\n        return _b_.float.$factory(float_check(x) * 180 / Math.PI)\n    },\n    dist: function(p, q){\n        $B.check_nb_args('dist', 2, arguments)\n        $B.check_no_kw('dist', p, q)\n\n        function test(x){\n            if(typeof x === \"number\" || x instanceof Number){\n                return x\n            }\n            var y = $B.$getattr(x, '__float__', null)\n            if(y === null){\n                throw _b_.TypeError.$factory('not a float')\n            }\n            return $B.$call(y)()\n        }\n\n        // build list of differences (as floats) between coordinates of p and q\n        var diffs = [],\n            diff\n\n        if(Array.isArray(p) && Array.isArray(q)){\n            // simple case : p and q are lists of tuples\n            if(p.length != q.length){\n                throw _b_.ValueError.$factory(\"both points must have \" +\n                    \"the same number of dimensions\")\n            }\n            for(var i = 0, len = p.length; i < len; i++){\n                var next_p = test(p[i]),\n                    next_q = test(q[i]),\n                    diff = Math.abs(next_p - next_q)\n                if(_b_.$isinf(diff)){\n                    return _mod.inf\n                }\n                diffs.push(diff)\n            }\n        }else{\n            var itp = _b_.iter(p),\n                itq = _b_.iter(q),\n                res = 0\n\n            while(true){\n                try{\n                    var next_p = _b_.next(itp)\n                }catch(err){\n                    if(err.__class__ === _b_.StopIteration){\n                        // check that the other iterator is also exhausted\n                        try{\n                            var next_q = _b_.next(itq)\n                            throw _b_.ValueError.$factory(\"both points must have \" +\n                                \"the same number of dimensions\")\n                        }catch(err){\n                            if(err.__class__ === _b_.StopIteration){\n                                break\n                            }\n                            throw err\n                        }\n                    }\n                    throw err\n                }\n                next_p = test(next_p)\n                try{\n                    var next_q = _b_.next(itq)\n                }catch(err){\n                    if(err.__class__ === _b_.StopIteration){\n                        throw _b_.ValueError.$factory(\"both points must have \" +\n                            \"the same number of dimensions\")\n                    }\n                    throw err\n                }\n                next_q = test(next_q)\n                diff = Math.abs(next_p - next_q)\n                if(_b_.$isinf(diff)){\n                    return _mod.inf\n                }\n                diffs.push(diff)\n            }\n        }\n\n        var res = 0,\n            scale = 1,\n            max_diff = Math.max(...diffs),\n            min_diff = Math.min(...diffs)\n            max_value = Math.sqrt(Number.MAX_VALUE) / p.length,\n            min_value = Math.sqrt(Number.MIN_VALUE) * p.length\n        if(max_diff > max_value){\n            while(max_diff > max_value){\n                scale *= 2\n                max_diff /= 2\n            }\n            for(var diff of diffs){\n                diff = diff / scale\n                res += diff * diff\n            }\n            return scale * _mod.sqrt(res)\n        }else if(min_diff !== 0 && min_diff < min_value){\n            while(min_diff < min_value){\n                scale *= 2\n                min_diff *= 2\n            }\n            for(var diff of diffs){\n                diff = diff * scale\n                res += diff * diff\n            }\n            return _mod.sqrt(res) / scale\n        }else{\n            for(var diff of diffs){\n                res += Math.pow(diff, 2)\n            }\n            return _mod.sqrt(res)\n        }\n    },\n    e: _b_.float.$factory(Math.E),\n    erf: function(x){\n        $B.check_nb_args('erf', 1, arguments)\n        $B.check_no_kw('erf', x)\n\n        // inspired from\n        // http://stackoverflow.com/questions/457408/is-there-an-easily-available-implementation-of-erf-for-python\n        var y = float_check(x)\n        var t = 1.0 / (1.0 + 0.5 * Math.abs(y))\n        var ans = 1 - t * Math.exp( -y * y - 1.26551223 +\n                     t * ( 1.00002368 +\n                     t * ( 0.37409196 +\n                     t * ( 0.09678418 +\n                     t * (-0.18628806 +\n                     t * ( 0.27886807 +\n                     t * (-1.13520398 +\n                     t * ( 1.48851587 +\n                     t * (-0.82215223 +\n                     t * 0.17087277)))))))))\n        if(y >= 0.0){return ans}\n        return -ans\n    },\n    erfc: function(x){\n\n        $B.check_nb_args('erfc', 1, arguments)\n        $B.check_no_kw('erfc', x)\n\n        // inspired from\n        // http://stackoverflow.com/questions/457408/is-there-an-easily-available-implementation-of-erf-for-python\n        var y = float_check(x)\n        var t = 1.0 / (1.0 + 0.5 * Math.abs(y))\n        var ans = 1 - t * Math.exp( -y * y - 1.26551223 +\n                     t * ( 1.00002368 +\n                     t * ( 0.37409196 +\n                     t * ( 0.09678418 +\n                     t * (-0.18628806 +\n                     t * ( 0.27886807 +\n                     t * (-1.13520398 +\n                     t * ( 1.48851587 +\n                     t * (-0.82215223 +\n                     t * 0.17087277)))))))))\n        if(y >= 0.0){return 1 - ans}\n        return 1 + ans\n    },\n    exp: function(x){\n        $B.check_nb_args('exp', 1, arguments)\n        $B.check_no_kw('exp', x)\n\n         if(_b_.$isninf(x)){return _b_.float.$factory(0)}\n         if(_b_.$isinf(x)){return _b_.float.$factory('inf')}\n         var _r = Math.exp(float_check(x))\n         if(_b_.$isinf(_r)){throw _b_.OverflowError.$factory(\"math range error\")}\n         return _b_.float.$factory(_r)\n    },\n    expm1: function(x){\n        $B.check_nb_args('expm1', 1, arguments)\n        $B.check_no_kw('expm1', x)\n\n         if(_b_.$isninf(x)){return _b_.float.$factory(0)}\n         if(_b_.$isinf(x)){return _b_.float.$factory('inf')}\n         var _r = Math.expm1(float_check(x))\n         if(_b_.$isinf(_r)){throw _b_.OverflowError.$factory(\"math range error\")}\n         return _b_.float.$factory(_r)\n    },\n    //fabs: function(x){ return x>0?float.$factory(x):float.$factory(-x)},\n    fabs: function(x){\n        $B.check_nb_args('fabs', 1, arguments)\n        $B.check_no_kw('fabs', x)\n        return _b_.$fabs(x) // located in py_float.js\n    },\n    factorial: function(x){\n        $B.check_nb_args('factorial', 1, arguments)\n        $B.check_no_kw('factorial', x)\n\n        if(x instanceof Number || _b_.isinstance(x, _b_.float)){\n            var warning = _b_.DeprecationWarning.$factory(\n                \"Using factorial() with floats is deprecated\")\n            // module _warning is in builtin_modules.js\n            $B.imported._warnings.warn(warning)\n         }\n\n        if(! _b_.isinstance(x, [_b_.float, _b_.int])){\n            throw _b_.TypeError.$factory(`'${$B.class_name(x)}' object ` +\n                \"cannot be interpreted as an integer\")\n        }\n\n        //using code from http://stackoverflow.com/questions/3959211/fast-factorial-function-in-javascript\n        if(! check_int_or_round_float(x)){\n            throw _b_.ValueError.$factory(\"factorial() only accepts integral values\")\n        }else if($B.rich_comp(\"__lt__\", x, 0)){\n            throw _b_.ValueError.$factory(\"factorial() not defined for negative values\")\n        }\n        var r = 1\n        for(var i = 2; i <= x; i++){\n            r = $B.mul(r, i)\n        }\n        return r\n    },\n    floor: function(x){\n        $B.check_nb_args('floor', 1, arguments)\n        $B.check_no_kw('floor', x)\n        if(typeof x == \"number\" ||\n                x instanceof Number){\n            return Math.floor(float_check(x))\n        }\n        try{\n            return $B.$call($B.$getattr(x, \"__floor__\"))()\n        }catch(err){\n            if($B.is_exc(err, [_b_.AttributeError])){\n                try{\n                    var f = $B.$call($B.$getattr(x, \"__float__\"))()\n                    return _mod.floor(f)\n                }catch(err){\n                    if($B.is_exc(err, [_b_.AttributeError])){\n                        throw _b_.TypeError.$factory(\"no __float__\")\n                    }\n                    throw err\n                }\n            }\n        }\n    },\n    fmod: function(x,y){\n        $B.check_nb_args('fmod', 2, arguments)\n        $B.check_no_kw('fmod', x,y)\n        return _b_.float.$factory(float_check(x) % float_check(y))\n    },\n    frexp: function(x){\n        $B.check_nb_args('frexp', 1, arguments)\n        $B.check_no_kw('frexp', x)\n\n        var _l = _b_.$frexp(x)\n        return _b_.tuple.$factory([_b_.float.$factory(_l[0]), _l[1]])\n    },\n    fsum: function(x){\n        $B.check_nb_args('fsum', 1, arguments)\n        $B.check_no_kw('fsum', x)\n\n        /* Translation into Javascript of the function msum in an Active\n           State Cookbook recipe : https://code.activestate.com/recipes/393090/\n           by Raymond Hettinger\n        */\n        var partials = [],\n            res = new Number(),\n            _it = _b_.iter(x)\n        while(true){\n            try{\n                var x = _b_.next(_it),\n                    i = 0\n                for(var j = 0, len = partials.length; j < len; j++){\n                    var y = partials[j]\n                    if(Math.abs(x) < Math.abs(y)){\n                        var z = x\n                        x = y\n                        y = z\n                    }\n                    var hi = x + y,\n                        lo = y - (hi - x)\n                    if(lo){\n                        partials[i] = lo\n                        i++\n                    }\n                    x = hi\n                }\n                partials = partials.slice(0, i).concat([x])\n            }catch(err){\n                if(_b_.isinstance(err, _b_.StopIteration)){break}\n                throw err\n            }\n        }\n        var res = new Number(0)\n        for(var i = 0; i < partials.length; i++){\n            res += new Number(partials[i])\n        }\n        return new Number(res)\n    },\n    gamma: function(x){\n        $B.check_nb_args('gamma', 1, arguments)\n        $B.check_no_kw('gamma', x)\n\n        if(x === Number.POSITIVE_INFINITY){\n            return _mod.inf\n        }else if(x === Number.NEGATIVE_INFINITY){\n            throw _b_.ValueError.$factory(\"math domain error\")\n        }\n        if(_b_.isinstance(x, _b_.int) ||\n                (_b_.isinstance(x, _b_.float) && x == _b_.int.$factory(x))){\n            if(x < 1){\n                throw _b_.ValueError.$factory(\"math domain error\")\n            }\n            var res = 1\n            for(var i = 1; i < x; i++){res *= i}\n            return new Number(res)\n        }\n        // Adapted from https://en.wikipedia.org/wiki/Lanczos_approximation\n        var p = [676.5203681218851,\n            -1259.1392167224028,\n            771.32342877765313,\n            -176.61502916214059,\n            12.507343278686905,\n            -0.13857109526572012,\n            9.9843695780195716e-6,\n            1.5056327351493116e-7\n            ]\n\n        var EPSILON = 1e-07\n        function drop_imag(z){\n            if(Math.abs(z.imag) <= EPSILON){\n                z = z.real\n            }\n            return z\n        }\n        var z = x\n        if(z < 0){\n            // Use formula \u0393(z) = \u0393(z + n + 1) / z (z + 1) ... (z + n)\n            // with n such that z + n + 1 > 0\n            var n = Math.ceil(-z - 1),\n                g = _mod.gamma(new Number(z + n + 1))\n            for(var i = 0; i <= n; i++){\n                g = g / (z + i)\n            }\n            return g\n        }else if(z < 0.5){\n            var y = Math.PI / (Math.sin(Math.PI * z) * _mod.gamma(1-z)) // Reflection formula\n        }else{\n            z -= 1\n            var x = 0.99999999999980993,\n                i = 0\n            for(var i = 0, len = p.length; i < len; i++){\n                var pval = p[i]\n                x += pval / (z + i + 1)\n            }\n            var t = z + p.length - 0.5,\n                sq = Math.sqrt(2 * Math.PI),\n                y = sq * Math.pow(t, (z + 0.5)) * Math.exp(-t) * x\n        }\n        return drop_imag(y)\n    },\n    gcd: function(){\n        var $ = $B.args(\"gcd\", 0, {}, [], arguments, {}, 'args', null)\n        var args = $.args.map($B.PyNumber_Index)\n\n        if(args.length == 0){\n            return 0\n        }else if(args.length == 1){\n            return _b_.abs(args[0])\n        }\n        // https://stackoverflow.com/questions/17445231/js-how-to-find-the-greatest-common-divisor\n        var a = _b_.abs(args[0]),\n            b\n        for(var i = 1, len = args.length; i < len; i++){\n            a = gcd2(a, _b_.abs(args[i]))\n        }\n        return a\n    },\n    hypot: function(x, y){\n        var $ = $B.args(\"hypot\", 2, {x: null, y:null}, ['x', 'y'],\n                    arguments, {}, \"args\", null),\n            args = [x, y].concat($.args),\n            res = 0\n        return _b_.float.$factory(Math.hypot(...args))\n    },\n    inf: _b_.float.$factory('inf'),\n    isclose: function(){\n        var $ = $B.args(\"isclose\",\n                          4,\n                          {a: null, b: null, rel_tol: null, abs_tol: null},\n                          ['a', 'b', 'rel_tol', 'abs_tol'],\n                          arguments,\n                          {rel_tol: 1e-09, abs_tol: 0.0},\n                          '*',\n                          null)\n        var a = $.a,\n            b = $.b,\n            rel_tol = $.rel_tol,\n            abs_tol = $.abs_tol\n        if(rel_tol < 0.0 || abs_tol < 0.0){\n            throw _b_.ValueError.$factory('tolerances must be non-negative')\n        }\n\n        if(a == b){\n            return _b_.True\n        }\n        if(_b_.$isinf(a) || _b_.$isinf(b)){\n            return a === b\n        }\n        // isclose(a, b, rel_tol, abs_tol) is the same as\n        // abs_diff = abs(a - b)\n        // max_ab = max(abs(a), abs(b))\n        // abs_diff <= abs_tol or abs_diff / max_ab <= rel_tol\n        // This is more correct than in Python docs:\n        // \"abs(a-b) <= max(rel_tol * max(abs(a), abs(b)), abs_tol)\"\n        // because this fails for Decimal instances, which do not support\n        // multiplication by floats\n\n        var diff = $B.$call($B.$getattr(b, '__sub__'))(a),\n            abs_diff = $B.$call($B.$getattr(diff, \"__abs__\"))()\n        if($B.rich_comp(\"__le__\", abs_diff, abs_tol)){\n            return true\n        }\n        var abs_a = $B.$call($B.$getattr(a, '__abs__'))(),\n            abs_b = $B.$call($B.$getattr(b, '__abs__'))(),\n            max_ab = abs_a\n        if($B.rich_comp(\"__gt__\", abs_b, abs_a)){\n            max_ab = abs_b\n        }\n        return $B.rich_comp(\"__le__\",\n            $B.$call($B.$getattr(abs_diff, \"__truediv__\"))(max_ab),\n            rel_tol)\n    },\n    isfinite: function(x){\n        $B.check_nb_args('isfinite', 1, arguments)\n        $B.check_no_kw('isfinite', x)\n        return isFinite(float_check(x))\n    },\n    isinf: function(x){\n        $B.check_nb_args('isinf', 1, arguments)\n        $B.check_no_kw('isinf', x)\n        return _b_.$isinf(float_check(x))\n    },\n    isnan: function(x){\n        $B.check_nb_args('isnan', 1, arguments)\n        $B.check_no_kw('isnan', x)\n        return isNaN(float_check(x))\n    },\n    isqrt: function(x){\n        $B.check_nb_args('isqrt', 1, arguments)\n        $B.check_no_kw('isqrt', x)\n\n        x = $B.PyNumber_Index(x)\n        if($B.rich_comp(\"__lt__\", x, 0)){\n            throw _b_.ValueError.$factory(\n                \"isqrt() argument must be nonnegative\")\n        }\n        if(typeof x == \"number\"){\n            return Math.floor(Math.sqrt(x))\n        }else{ // big integer\n            var v = parseInt(x.value),\n                candidate = Math.floor(Math.sqrt(v)),\n                c1\n            // Use successive approximations : sqr = (sqr + (x / sqr)) / 2\n            // Limit to 100 iterations\n            for(var i = 0; i < 100; i++){\n                c1 = $B.floordiv($B.add(candidate,\n                    $B.floordiv(x, candidate)), 2)\n                if(c1 === candidate || c1.value === candidate.value){\n                    break\n                }\n                candidate = c1\n            }\n            if($B.rich_comp(\"__gt__\", $B.mul(candidate, candidate), x)){\n                // Result might be greater by 1\n                candidate = $B.sub(candidate, 1)\n            }\n            return candidate\n        }\n    },\n    lcm: function(){\n        var $ = $B.args(\"lcm\", 0, {}, [], arguments, {}, 'args', null),\n            product = 1\n\n        var args = $.args.map($B.PyNumber_Index)\n        if(args.length == 0){\n            return 1\n        }else if(args.length == 1){\n            return _b_.abs(args[0])\n        }\n        var a = _b_.abs(args[0]),\n            b,\n            product, gcd\n        for(var i = 0, len = args.length; i < len; i++){\n            b = _b_.abs(args[i])\n            if(b == 0){\n                return 0\n            }\n            gcd = gcd2(a, b)\n            product = $B.mul(a, b)\n            a = $B.$getattr(product, \"__floordiv__\")(gcd)\n        }\n        return a\n    },\n    ldexp: function(x, i){\n        $B.check_nb_args('ldexp', 2, arguments)\n        $B.check_no_kw('ldexp', x, i)\n        return _b_.$ldexp(x, i)   //located in py_float.js\n    },\n    lgamma: function(x){\n        $B.check_nb_args('lgamma', 1, arguments)\n        $B.check_no_kw('lgamma', x)\n\n        // copied from\n        // https://github.com/czurnieden/ieee745gamma/blob/master/ieee745gamma.js\n        // by Christoph Zurnieden\n        // see \"LICENCE math lgamma.txt\"\n        var double_int = new DataView(new ArrayBuffer(8))\n        var half = 5.00000000000000000000e-01 /* 0x3FE00000, 0x00000000 */\n        var one = 1.00000000000000000000e+00 /* 0x3FF00000, 0x00000000 */\n        var pi = 3.14159265358979311600e+00 /* 0x400921FB, 0x54442D18 */\n        var a0 = 7.72156649015328655494e-02 /* 0x3FB3C467, 0xE37DB0C8 */\n        var a1 = 3.22467033424113591611e-01 /* 0x3FD4A34C, 0xC4A60FAD */\n        var a2 = 6.73523010531292681824e-02 /* 0x3FB13E00, 0x1A5562A7 */\n        var a3 = 2.05808084325167332806e-02 /* 0x3F951322, 0xAC92547B */\n        var a4 = 7.38555086081402883957e-03 /* 0x3F7E404F, 0xB68FEFE8 */\n        var a5 = 2.89051383673415629091e-03 /* 0x3F67ADD8, 0xCCB7926B */\n        var a6 = 1.19270763183362067845e-03 /* 0x3F538A94, 0x116F3F5D */\n        var a7 = 5.10069792153511336608e-04 /* 0x3F40B6C6, 0x89B99C00 */\n        var a8 = 2.20862790713908385557e-04 /* 0x3F2CF2EC, 0xED10E54D */\n        var a9 = 1.08011567247583939954e-04 /* 0x3F1C5088, 0x987DFB07 */\n        var a10 = 2.52144565451257326939e-05 /* 0x3EFA7074, 0x428CFA52 */\n        var a11 = 4.48640949618915160150e-05 /* 0x3F07858E, 0x90A45837 */\n        var tc = 1.46163214496836224576e+00 /* 0x3FF762D8, 0x6356BE3F */\n        var tf = -1.21486290535849611461e-01 /* 0xBFBF19B9, 0xBCC38A42 */\n        /* tt = -(tail of tf) */\n        var tt = -3.63867699703950536541e-18 /* 0xBC50C7CA, 0xA48A971F */\n        var t0 = 4.83836122723810047042e-01 /* 0x3FDEF72B, 0xC8EE38A2 */\n        var t1 = -1.47587722994593911752e-01 /* 0xBFC2E427, 0x8DC6C509 */\n        var t2 = 6.46249402391333854778e-02 /* 0x3FB08B42, 0x94D5419B */\n        var t3 = -3.27885410759859649565e-02 /* 0xBFA0C9A8, 0xDF35B713 */\n        var t4 = 1.79706750811820387126e-02 /* 0x3F9266E7, 0x970AF9EC */\n        var t5 = -1.03142241298341437450e-02 /* 0xBF851F9F, 0xBA91EC6A */\n        var t6 = 6.10053870246291332635e-03 /* 0x3F78FCE0, 0xE370E344 */\n        var t7 = -3.68452016781138256760e-03 /* 0xBF6E2EFF, 0xB3E914D7 */\n        var t8 = 2.25964780900612472250e-03 /* 0x3F6282D3, 0x2E15C915 */\n        var t9 = -1.40346469989232843813e-03 /* 0xBF56FE8E, 0xBF2D1AF1 */\n        var t10 = 8.81081882437654011382e-04 /* 0x3F4CDF0C, 0xEF61A8E9 */\n        var t11 = -5.38595305356740546715e-04 /* 0xBF41A610, 0x9C73E0EC */\n        var t12 = 3.15632070903625950361e-04 /* 0x3F34AF6D, 0x6C0EBBF7 */\n        var t13 = -3.12754168375120860518e-04 /* 0xBF347F24, 0xECC38C38 */\n        var t14 = 3.35529192635519073543e-04 /* 0x3F35FD3E, 0xE8C2D3F4 */\n        var u0 = -7.72156649015328655494e-02 /* 0xBFB3C467, 0xE37DB0C8 */\n        var u1 = 6.32827064025093366517e-01 /* 0x3FE4401E, 0x8B005DFF */\n        var u2 = 1.45492250137234768737e+00 /* 0x3FF7475C, 0xD119BD6F */\n        var u3 = 9.77717527963372745603e-01 /* 0x3FEF4976, 0x44EA8450 */\n        var u4 = 2.28963728064692451092e-01 /* 0x3FCD4EAE, 0xF6010924 */\n        var u5 = 1.33810918536787660377e-02 /* 0x3F8B678B, 0xBF2BAB09 */\n        var v1 = 2.45597793713041134822e+00 /* 0x4003A5D7, 0xC2BD619C */\n        var v2 = 2.12848976379893395361e+00 /* 0x40010725, 0xA42B18F5 */\n        var v3 = 7.69285150456672783825e-01 /* 0x3FE89DFB, 0xE45050AF */\n        var v4 = 1.04222645593369134254e-01 /* 0x3FBAAE55, 0xD6537C88 */\n        var v5 = 3.21709242282423911810e-03 /* 0x3F6A5ABB, 0x57D0CF61 */\n        var s0 = -7.72156649015328655494e-02 /* 0xBFB3C467, 0xE37DB0C8 */\n        var s1 = 2.14982415960608852501e-01 /* 0x3FCB848B, 0x36E20878 */\n        var s2 = 3.25778796408930981787e-01 /* 0x3FD4D98F, 0x4F139F59 */\n        var s3 = 1.46350472652464452805e-01 /* 0x3FC2BB9C, 0xBEE5F2F7 */\n        var s4 = 2.66422703033638609560e-02 /* 0x3F9B481C, 0x7E939961 */\n        var s5 = 1.84028451407337715652e-03 /* 0x3F5E26B6, 0x7368F239 */\n        var s6 = 3.19475326584100867617e-05 /* 0x3F00BFEC, 0xDD17E945 */\n        var r1 = 1.39200533467621045958e+00 /* 0x3FF645A7, 0x62C4AB74 */\n        var r2 = 7.21935547567138069525e-01 /* 0x3FE71A18, 0x93D3DCDC */\n        var r3 = 1.71933865632803078993e-01 /* 0x3FC601ED, 0xCCFBDF27 */\n        var r4 = 1.86459191715652901344e-02 /* 0x3F9317EA, 0x742ED475 */\n        var r5 = 7.77942496381893596434e-04 /* 0x3F497DDA, 0xCA41A95B */\n        var r6 = 7.32668430744625636189e-06 /* 0x3EDEBAF7, 0xA5B38140 */\n        var w0 = 4.18938533204672725052e-01 /* 0x3FDACFE3, 0x90C97D69 */\n        var w1 = 8.33333333333329678849e-02 /* 0x3FB55555, 0x5555553B */\n        var w2 = -2.77777777728775536470e-03 /* 0xBF66C16C, 0x16B02E5C */\n        var w3 = 7.93650558643019558500e-04 /* 0x3F4A019F, 0x98CF38B6 */\n        var w4 = -5.95187557450339963135e-04 /* 0xBF4380CB, 0x8C0FE741 */\n        var w5 = 8.36339918996282139126e-04 /* 0x3F4B67BA, 0x4CDAD5D1 */\n        var w6 = -1.63092934096575273989e-03 /* 0xBF5AB89D, 0x0B9E43E4 */\n        var zero = 0.00000000000000000000e+00\n\n        var t, y, z, nadj = 0,\n          p, p1, p2, p3, q, r, w\n\n        var i = 0 | 0,\n          hx = 0 | 0,\n          lx = 0 | 0,\n          ix = 0 | 0\n\n        double_int.setFloat64(0, x)\n\n        hx = double_int.getInt32(0) /* high word */\n        lx = double_int.getInt32(4) /* low word */\n\n        /* purge off +-inf, NaN, +-0, and negative arguments */\n        lgamma_sign = 1\n        ix = hx & 0x7fffffff\n        if(ix >= 0x7ff00000){\n          return new Number(x * x)\n        }\n        if((ix | lx) == 0){\n          if(hx & 0x80000000){\n            lgamma_sign = -1\n          }\n          return new Number(one / zero)\n        }\n        if(ix < 0x3b900000){ /* |x|<2**-70, return -log(|x|) */\n          if(hx < 0){\n            lgamma_sign = -1\n            return new Number(-Math.log(-x))\n          } else {\n            return new Number(-Math.log(x))\n          }\n        }\n        if(hx < 0){\n          if(ix >= 0x43300000){ /* |x|>=2**52, must be -integer */\n            return new Number(one / zero)\n          }\n          t = sin_pi(x)\n          if(t == zero){\n            return new Number(one / zero)\n          } /* -integer */\n          nadj = Math.log(pi / Math.abs(t * x))\n          if(t < zero){\n            lgamma_sign = -1\n          }\n          x = -x\n        }\n        /* purge off 1 and 2 */\n        if((((ix - 0x3ff00000) | lx) == 0) || (((ix - 0x40000000) | lx) == 0)){\n          r = 0\n        }\n        /* for x < 2.0 */\n        else if(ix < 0x40000000){\n          if(ix <= 0x3feccccc){ /* lgamma(x) = lgamma(x+1)-log(x) */\n            r = -Math.log(x)\n            if(ix >= 0x3FE76944){\n              y = one - x\n              i = 0\n            }else if(ix >= 0x3FCDA661){\n              y = x - (tc - one)\n              i = 1\n            }else{\n              y = x\n              i = 2\n            }\n          }else{\n            r = zero\n            if(ix >= 0x3FFBB4C3){\n              y = 2.0 - x\n              i = 0\n            } /* [1.7316,2] */\n            else if(ix >= 0x3FF3B4C4){\n              y = x - tc\n              i = 1\n            } /* [1.23,1.73] */\n            else{\n              y = x - one\n              i = 2\n            }\n          }\n          switch(i){\n            case 0:\n              z = y * y\n              p1 = a0 + z * (a2 + z * (a4 + z * (a6 + z * (a8 + z * a10))))\n              p2 = z * (a1 + z * (a3 + z * (a5 + z * (a7 + z * (a9 + z * a11)))))\n              p = y * p1 + p2\n              r += (p - 0.5 * y)\n              break\n            case 1:\n              z = y * y\n              w = z * y\n              p1 = t0 + w * (t3 + w * (t6 + w * (t9 + w * t12))) /* parallel comp */\n              p2 = t1 + w * (t4 + w * (t7 + w * (t10 + w * t13)))\n              p3 = t2 + w * (t5 + w * (t8 + w * (t11 + w * t14)))\n              p = z * p1 - (tt - w * (p2 + y * p3))\n              r += (tf + p)\n              break\n            case 2:\n              p1 = y * (u0 + y * (u1 + y * (u2 + y * (u3 + y * (u4 + y * u5)))))\n              p2 = one + y * (v1 + y * (v2 + y * (v3 + y * (v4 + y * v5))))\n              r += (-0.5 * y + p1 / p2)\n          }\n        }else if(ix < 0x40200000){ /* x < 8.0 */\n          i = x | 0\n          t = zero\n          y = x - i\n          p = y * (s0 + y * (s1 + y * (s2 + y * (s3 + y * (s4 + y * (s5 + y *\n            s6))))))\n          q = one + y * (r1 + y * (r2 + y * (r3 + y * (r4 + y * (r5 + y * r6)))))\n          r = half * y + p / q\n          z = one /* lgamma(1+s) = log(s) + lgamma(s) */\n          switch(i){\n            case 7:\n              z *= (y + 6.0) /* FALLTHRU */\n            case 6:\n              z *= (y + 5.0) /* FALLTHRU */\n            case 5:\n              z *= (y + 4.0) /* FALLTHRU */\n            case 4:\n              z *= (y + 3.0) /* FALLTHRU */\n            case 3:\n              z *= (y + 2.0) /* FALLTHRU */\n              r += Math.log(z)\n              break\n          }\n          /* 8.0 <= x < 2**58 */\n        }else if(ix < 0x43900000){\n          t = Math.log(x)\n          z = one / x\n          y = z * z\n          w = w0 + z * (w1 + y * (w2 + y * (w3 + y * (w4 + y * (w5 + y * w6)))))\n          r = (x - half) * (t - one) + w\n        }else{\n          /* 2**58 <= x <= inf */\n          r = x * (Math.log(x) - one)\n        }\n        if(hx < 0){\n          r = nadj - r\n        }\n        return new Number(r)\n    },\n    log: function(x, base){\n        var $ = $B.args(\"log\", 2, {x: null, base: null}, ['x', 'base'],\n            arguments, {base: _b_.None}, null, null),\n            x = $.x,\n            base = $.base\n\n         var x1 = float_check(x)\n         if(base === _b_.None){return _b_.float.$factory(Math.log(x1))}\n         return _b_.float.$factory(Math.log(x1) / Math.log(float_check(base)))\n    },\n    log1p: function(x){\n        $B.check_nb_args('log1p', 1, arguments)\n        $B.check_no_kw('log1p', x)\n        return _b_.float.$factory(Math.log1p(float_check(x)))\n    },\n    log2: function(x){\n        $B.check_nb_args('log2', 1, arguments)\n        $B.check_no_kw('log2', x)\n\n        if(isNaN(x)){return _b_.float.$factory('nan')}\n        if(_b_.$isninf(x)) {throw _b_.ValueError.$factory('')}\n        var x1 = float_check(x)\n        if(x1 < 0.0){throw _b_.ValueError.$factory('')}\n        return _b_.float.$factory(Math.log(x1) / Math.LN2)\n    },\n    log10: function(x){\n        $B.check_nb_args('log10', 1, arguments)\n        $B.check_no_kw('log10', x)\n\n        return _b_.float.$factory(Math.log10(float_check(x)))\n    },\n    modf: function(x){\n        $B.check_nb_args('modf', 1, arguments)\n        $B.check_no_kw('modf', x)\n\n       if(_b_.$isninf(x)){\n           return _b_.tuple.$factory([0.0, _b_.float.$factory('-inf')])\n       }\n       if(_b_.$isinf(x)){\n           return _b_.tuple.$factory([0.0, _b_.float.$factory('inf')])\n       }\n       if(isNaN(x)){\n           return _b_.tuple.$factory([_b_.float.$factory('nan'),\n               _b_.float.$factory('nan')])\n       }\n\n       var x1 = float_check(x)\n       if(x1 > 0){\n          var i = _b_.float.$factory(x1 - Math.floor(x1))\n          return _b_.tuple.$factory([i, _b_.float.$factory(x1 - i)])\n       }\n\n       var x2 = Math.ceil(x1)\n       var i = _b_.float.$factory(x1 - x2)\n       return _b_.tuple.$factory([i, _b_.float.$factory(x2)])\n    },\n    nan: _b_.float.$factory('nan'),\n    nextafter: function(){\n        var $ = $B.args(\"nextafter\", 2, {x: null, y: null}, ['x', 'y'],\n                    arguments, {}, null, null),\n            x = $.x,\n            y = $.y\n        return y < x ? -nextUp(-x) : (y > x ? nextUp(x) : (x !== x ? x : y))\n    },\n    perm: function(n, k){\n        var $ = $B.args(\"perm\", 2, {n: null, k: null}, ['n', 'k'],\n                        arguments, {k: _b_.None}, null, null),\n            n = $.n,\n            k = $.k\n\n        if(k === _b_.None){\n            check_int(n)\n            return _mod.factorial(n)\n        }\n        // raise TypeError if n or k is not an integer\n        check_int(n)\n        check_int(k)\n\n        if(k < 0){\n            throw _b_.ValueError.$factory(\"k must be a non-negative integer\")\n        }\n        if(n < 0){\n            throw _b_.ValueError.$factory(\"n must be a non-negative integer\")\n        }\n\n        if(k > n){\n            return 0\n        }\n        // Evaluates to n! / (n - k)!\n        var fn = _mod.factorial(n),\n            fn_k = _mod.factorial(n - k)\n        return $B.floordiv(fn, fn_k)\n    },\n    pi : _b_.float.$factory(Math.PI),\n    pow: function(){\n        var $ = $B.args(\"pow\", 2, {base: null, exp: null}, ['base', 'exp'],\n                    arguments, {}, null, null),\n            x = $.base,\n            y = $.exp\n\n        var x1 = float_check(x)\n        var y1 = float_check(y)\n        if(y1 == 0){return _b_.float.$factory(1)}\n        if(x1 == 0 && y1 < 0){throw _b_.ValueError.$factory('')}\n\n        if(isNaN(y1)){\n            if(x1 == 1){return _b_.float.$factory(1)}\n            return _b_.float.$factory('nan')\n        }\n        if(x1 == 0){return _b_.float.$factory(0)}\n\n        if(_b_.$isninf(y)){\n            if(x1 == 1 || x1 == -1){return _b_.float.$factory(1)}\n            if(x1 < 1 && x1 > -1){return _b_.float.$factory('inf')}\n            return _b_.float.$factory(0)\n        }\n        if(_b_.$isinf(y)){\n            if(x1 == 1 || x1 == -1){return _b_.float.$factory(1)}\n            if(x1 < 1 && x1 > -1){return _b_.float.$factory(0)}\n            return _b_.float.$factory('inf')\n        }\n\n        if(isNaN(x1)){return _b_.float.$factory('nan')}\n        if(_b_.$isninf(x)){\n            if(y1 > 0 && isOdd(y1)){return _b_.float.$factory('-inf')}\n            if(y1 > 0){return _b_.float.$factory('inf')}  // this is even or a float\n            if(y1 < 0){return _b_.float.$factory(0)}\n            return _b_.float.$factory(1)\n        }\n\n        if(_b_.$isinf(x)){\n            if(y1 > 0){return _b_.float.$factory('inf')}\n            if(y1 < 0){return _b_.float.$factory(0)}\n            return _b_.float.$factory(1)\n        }\n\n        var r = Math.pow(x1, y1)\n        if(isNaN(r)){return _b_.float.$factory('nan')}\n        if(_b_.$isninf(r)){return _b_.float.$factory('-inf')}\n        if(_b_.$isinf(r)){return _b_.float.$factory('inf')}\n\n        return r\n    },\n    prod: function(){\n        var $ = $B.args(\"prod\", 1, {iterable:null, start:null},\n                        [\"iterable\", \"start\"], arguments, {start: 1}, \"*\",\n                        null),\n            iterable = $.iterable,\n            start = $.start\n        var res = start,\n            it = _b_.iter(iterable),\n            x\n        while(true){\n            try{\n                x = _b_.next(it)\n                if(x == 0){\n                    return 0\n                }\n                res = $B.mul(res, x)\n            }catch(err){\n                if(err.__class__ === _b_.StopIteration){\n                    return res\n                }\n                throw err\n            }\n        }\n    },\n    radians: function(x){\n        $B.check_nb_args('radians', 1, arguments)\n        $B.check_no_kw('radians', x)\n\n        return _b_.float.$factory(float_check(x) * Math.PI / 180)\n    },\n    remainder: function(x, y){\n        $B.check_nb_args('remainder', 2, arguments)\n        $B.check_no_kw('remainder', x, y)\n        if(_mod.isnan(x) || _mod.isnan(y)){\n            return _mod.nan\n        }\n        if(_b_.$isinf(x) || y == 0){\n            throw _b_.ValueError.$factory(\"math domain error\")\n        }\n        x = float_check(x)\n        y = float_check(y)\n        var quotient = x / y,\n            rounded = _b_.round(quotient)\n        if(rounded == 0){\n            return _b_.float.$factory(x)\n        }\n        var res = _b_.float.$factory(x - rounded * y)\n        if(_b_.$isinf(res)){\n            // happens if rounded * y is infinite\n            res = _b_.float.$factory(rounded * (x / rounded - y))\n        }\n        return res\n    },\n    sin : function(x){\n        $B.check_nb_args('sin ', 1, arguments)\n        $B.check_no_kw('sin ', x)\n        return _b_.float.$factory(Math.sin(float_check(x)))},\n    sinh: function(x) {\n        $B.check_nb_args('sinh', 1, arguments)\n        $B.check_no_kw('sinh', x)\n\n        var y = float_check(x)\n        if(Math.sinh !== undefined){return _b_.float.$factory(Math.sinh(y))}\n        return _b_.float.$factory(\n            (Math.pow(Math.E, y) - Math.pow(Math.E, -y)) / 2)\n    },\n    sqrt: function(x){\n        $B.check_nb_args('sqrt ', 1, arguments)\n        $B.check_no_kw('sqrt ', x)\n\n      var y = float_check(x)\n      if(y < 0){throw _b_.ValueError.$factory(\"math range error\")}\n      if(_b_.$isinf(y)){return _b_.float.$factory('inf')}\n      var _r = Math.sqrt(y)\n      if(_b_.$isinf(_r)){throw _b_.OverflowError.$factory(\"math range error\")}\n      return _b_.float.$factory(_r)\n    },\n    tan: function(x) {\n        $B.check_nb_args('tan', 1, arguments)\n        $B.check_no_kw('tan', x)\n\n        var y = float_check(x)\n        return _b_.float.$factory(Math.tan(y))\n    },\n    tanh: function(x) {\n        $B.check_nb_args('tanh', 1, arguments)\n        $B.check_no_kw('tanh', x)\n\n        var y = float_check(x)\n        if(Math.tanh !== undefined){return _b_.float.$factory(Math.tanh(y))}\n        return _b_.float.$factory((Math.pow(Math.E, y) - Math.pow(Math.E, -y))/\n             (Math.pow(Math.E, y) + Math.pow(Math.E, -y)))\n    },\n    tau: 6.283185307179586,\n    trunc: function(x) {\n        $B.check_nb_args('trunc', 1, arguments)\n        $B.check_no_kw('trunc', x)\n\n       try{return $B.$getattr(x, '__trunc__')()}catch(err){}\n       var x1 = float_check(x)\n       if(!isNaN(parseFloat(x1)) && isFinite(x1)){\n          if(Math.trunc !== undefined){return _b_.int.$factory(Math.trunc(x1))}\n          if(x1 > 0){return _b_.int.$factory(Math.floor(x1))}\n          return _b_.int.$factory(Math.ceil(x1))  // x1 < 0\n       }\n       throw _b_.ValueError.$factory(\n           'object is not a number and does not contain __trunc__')\n    },\n    ulp: function(){\n        var $ = $B.args(\"ulp\", 1, {x: null}, ['x'], arguments, {}, null, null),\n            x = $.x\n        if(x == MAX_VALUE){\n            return MAX_VALUE - _mod.nextafter(MAX_VALUE, 0)\n        }else if(_b_.$isinf(x)){\n            return _mod.inf\n        }\n        if(typeof x == \"number\" || x instanceof Number){\n            return x > 0 ? nextUp(x) - x : x - (-nextUp(-x))\n        }else{\n            if($B.rich_comp('__gt__', x, 0)){\n                return $B.rich_op('sub', nextUp(x), x)\n            }else{\n                var neg_x = $B.$call($B.$getattr(x, \"__neg__\"))()\n                return $B.rich_op('sub', x,\n                    $B.$call($B.$getattr(nextUp(neg_x), '__neg__'))())\n            }\n        }\n    }\n}\n\nfor(var $attr in _mod){\n    if(typeof _mod[$attr] === 'function'){\n        _mod[$attr].__class__ = $B.builtin_function\n    }\n}\n\nreturn _mod\n\n})(__BRYTHON__)\n"],
     "modulefinder": [".js", "var $module=(function($B){\n\nvar _b_=$B.builtins\nvar _mod = {}\n\n$ModuleFinderDict = {__class__:_b_.type,__name__:'ModuleFinder'}\n$ModuleFinderDict.__mro__ = [_b_.object]\n\n$ModuleFinderDict.run_script = function(self, pathname){\n    // pathname is the url of a Python script\n    var py_src = _b_.$open(pathname).read()\n    // transform into internal Brython tree structure\n    var root = $B.py2js(py_src)\n    // walk the tree to find occurences of imports\n    function walk(node){\n        var modules = []\n        var ctx = node.context\n        if(ctx && ctx.type=='node'){ctx = ctx.tree[0]}\n\n        if(ctx && ctx.type==\"import\"){\n            for(var i=0, _len_i = ctx.tree.length; i < _len_i;i++){\n                if(modules.indexOf(ctx.tree[i].name)==-1){\n                    modules.push(ctx.tree[i].name)\n                }\n            }\n        }else if(ctx && ctx.type==\"from\"){\n            if(modules.indexOf(ctx.module)==-1){\n                modules.push(ctx.module)\n            }\n        }\n        \n        for(var i=0, _len_i = node.children.length; i < _len_i;i++){\n            mods = walk(node.children[i])\n            for(var j=0, _len_j = mods.length; j < _len_j;j++){\n                if(modules.indexOf(mods[j])==-1){modules.push(mods[j])}\n            }\n        }\n        return modules\n    }\n    self.modules = walk(root)\n}\n\n_mod.ModuleFinder = function(){return {__class__:$ModuleFinderDict}\n}\n_mod.ModuleFinder.$dict = $ModuleFinderDict\n_mod.ModuleFinder.__class__ = $B.$factory\n$ModuleFinderDict.$factory = _mod.ModuleFinder\n\nreturn _mod\n})(__BRYTHON__)\n"],
     "posix": [".js", "/*\nThis module provides access to operating system functionality that is\nstandardized by the C Standard and the POSIX standard (a thinly\ndisguised Unix interface).  Refer to the library manual and\ncorresponding Unix manual entries for more information on calls.\n*/\n\nvar $B = __BRYTHON__,\n    _b_ = $B.builtins\n\nfunction _randint(a, b){\n    return parseInt(Math.random() * (b - a + 1) + a)\n}\n\nvar stat_result = $B.make_class(\"stat_result\",\n    function(filename){\n        // Use $B.files, created by \"python -m brython --make_file_system\"\n        if($B.files && $B.files.hasOwnProperty(filename)){\n            var f = $B.files[filename],\n                res = {\n                    __class__: stat_result,\n                    st_atime: new Date().getTime(),\n                    st_ctime: f.ctime,\n                    st_mtime: f.mtime,\n                    st_uid: -1,\n                    st_gid: -1,\n                    st_ino: -1,\n                    st_mode: 0,\n                    st_size: 1\n                };\n            [\"atime\", \"mtime\", \"ctime\"].\n                forEach(function(item){\n                    res[\"st_\" + item + \"_ns\"] = res[\"st_\" + item] *\n                        1000000\n                });\n        }else{\n            var res = {\n                __class__: stat_result,\n                st_atime: new Date(),\n                st_uid: -1,\n                st_gid: -1,\n                st_ino: -1,\n                st_mode: 0,\n                st_size: 1\n            };\n            [\"mtime\", \"ctime\", \"atime_ns\", \"mtime_ns\", \"ctime_ns\"].\n                forEach(function(item){\n                    res[\"st_\" + item] = res.st_atime\n                });\n        }\n        return res\n    }\n)\n$B.set_func_names(stat_result, \"posix\")\n\nvar $module = {\n    F_OK: 0,\n    O_APPEND: 8,\n    O_BINARY: 32768,\n    O_CREAT: 256,\n    O_EXCL: 1024,\n    O_NOINHERIT: 128,\n    O_RANDOM: 16,\n    O_RDONLY: 0,\n    O_RDWR: 2,\n    O_SEQUENTIAL: 32,\n    O_SHORT_LIVED: 4096,\n    O_TEMPORARY: 64,\n    O_TEXT: 16384,\n    O_TRUNC: 512,\n    O_WRONLY: 1,\n    P_DETACH: 4,\n    P_NOWAIT: 1,\n    P_NOWAITO: 3,\n    P_OVERLAY: 2,\n    P_WAIT: 0,\n    R_OK: 4,\n    TMP_MAX: 32767,\n    W_OK: 2,\n    X_OK: 1,\n    _have_functions: ['MS_WINDOWS'],\n    environ: _b_.dict.$factory(\n        [['PYTHONPATH', $B.brython_path],\n         ['PYTHONUSERBASE', ' ']]),\n    error: _b_.OSError,\n    fspath: function(path){\n        return path\n    },\n    getcwd: function(){return $B.brython_path},\n    getpid: function(){return 0},\n    lstat: function(){return stat_result.$factory()},\n    open: function(path, flags){return _b_.open(path, flags)},\n    stat: function(filename){return stat_result.$factory(filename)},\n    stat_result: function(filename){return stat_result.$factory(filename)},\n    urandom: function(n){\n        var randbytes = []\n        for(var i = 0; i < n; i++){\n            randbytes.push(_randint(0, 255))\n        }\n        return _b_.bytes.$factory(randbytes)\n    },\n    WTERMSIG: function(){return 0},\n    WNOHANG: function(){return _b_.tuple.$factory([0, 0])}\n};\n\n[\"WCOREDUMP\", \"WIFCONTINUED\", \"WIFSTOPPED\", \"WIFSIGNALED\", \"WIFEXITED\"].forEach(function(funcname){\n        $module[funcname] = function(){return false}\n    });\n\n[\"WEXITSTATUS\", \"WSTOPSIG\", \"WTERMSIG\"].\n    forEach(function(funcname){\n        $module[funcname] = function(){return _b_.None}\n    });\n\n[\"_exit\", \"_getdiskusage\", \"_getfileinformation\", \"_getfinalpathname\",\n    \"_getfullpathname\", \"_isdir\", \"abort\", \"access\", \"chdir\", \"chmod\",\n    \"close\", \"closerange\", \"device_encoding\", \"dup\", \"dup2\",\n    \"execv\", \"execve\", \"fsat\", \"fsync\", \"get_terminal_size\", \"getcwdb\",\n    \"getlogin\", \"getppid\", \"isatty\", \"kill\", \"link\", \"listdir\", \"lseek\",\n    \"mkdir\", \"pipe\", \"putenv\", \"read\", \"readlink\", \"remove\", \"rename\",\n    \"replace\", \"rmdir\", \"spawnv\", \"spawnve\", \"startfile\", \"stat_float_times\",\n    \"statvfs_result\", \"strerror\", \"symlink\", \"system\", \"terminal_size\",\n    \"times\", \"times_result\", \"umask\", \"uname_result\", \"unlink\", \"utime\",\n    \"waitpid\", \"write\"].forEach(function(funcname){\n        $module[funcname] = function(){\n            throw _b_.NotImplementedError.$factory(\"posix.\" + funcname +\n                \" is not implemented\")\n        }\n    });\n"],
-    "python_re": [".js", "// Regular expression\n\nvar $B = __BRYTHON__,\n    _b_ = $B.builtins\n\nvar MAXGROUPS = 2147483647,\n    MAXREPEAT = 2147483648\n\nvar is_word = {}\nvar word_gcs = ['Ll', 'Lu', 'Lm', 'Lt', 'Lo',\n                'Nd',\n                'Mc', 'Me', 'Mn',\n                'Pc']\nfor(var word_gc of word_gcs){\n    for(var cp in $B.unicode_tables[word_gc]){\n        is_word[cp] = true\n    }\n}\n\nvar is_ascii_word = {}\n\nfor(var cp = 0; cp <= 127; cp++){\n    if(is_word[cp]){\n        is_ascii_word[cp] = true\n    }\n}\n\nvar is_digit = {}\n\nfor(var cp in $B.unicode_tables['Nd']){\n    is_digit[cp] = true\n}\n\nvar is_ascii_digit = {}\n\nfor(var cp = 0; cp <= 127; cp++){\n    if(is_digit[cp]){\n        is_ascii_digit[cp] = true\n    }\n}\n\nvar $error_2 = {\n    $name: \"error\",\n    $qualname: \"error\",\n    $is_class: true,\n    __module__: \"re\"\n}\n\nvar error = $B.$class_constructor(\"error\", $error_2,\n    _b_.tuple.$factory([_b_.Exception]),[\"_b_.Exception\"],[])\nerror.__doc__ = _b_.None\nerror.$factory = $B.$instance_creator(error)\nerror.__str__ = function(self){\n    var s = self.msg + ' at position ' + self.pos\n    if(self.lineno > 1){\n        s += ` (line ${self.lineno}, column ${self.colno})`\n    }\n    return s\n}\n\n$B.set_func_names(error, \"re\")\n\nfunction $last(t){\n    return t[t.length - 1]\n}\n\nfunction fail(message, pos, pattern){\n    var err = error.$factory(message)\n    err.msg = message\n    err.pos = pos\n    if(pattern){\n        err.pattern = pattern.py_obj // Python object passed to compile()\n        err.lineno = 1\n        var linestart = 0\n        for(var i = 0, len = pattern.string.length; i < pos; i++){\n            if(pattern.string[i] == '\\n'){\n                err.lineno++\n                linestart = i + 1\n            }\n        }\n        err.colno = pos - linestart + 1\n    }\n    throw err\n}\n\nfunction warn(klass, message, pos){\n    var warning = klass.$factory(message)\n    warning.pos = pos\n    // module _warning is in builtin_modules.js\n    $B.imported._warnings.warn(warning)\n}\n\nvar Flag = $B.make_class(\"Flag\",\n    function(value){\n        return {\n            __class__: Flag,\n            value\n        }\n    }\n)\n\nFlag.__index__ = function(self){\n    return self.value\n}\n\nFlag.__invert__ = function(self){\n    return Flag.$factory(~self.value)\n}\n\nFlag.__eq__ = function(self, other){\n    return self.value == other.value\n}\n\nFlag.__or__ = function(self, other){\n    if(other.__class__ === Flag){\n        return Flag.$factory(self.value | other.value)\n    }else if(typeof other == \"number\"){\n        return Flag.$factory(self.value | other)\n    }\n    return _b_.NotImplemented\n}\n\nFlag.__ror__ = function(self, other){\n    if(typeof other == \"number\" || _b_.isinstance(other, int)){\n        if(other == 0){\n            return Flag.$factory(self.value)\n        }\n        return Flag.$factory(self.value | other)\n    }\n    return _b_.NotImplemented\n}\n\nFlag.__repr__ = Flag.__str__ = function(self){\n    if(self.value == 0){\n        return \"re.none\"\n    }\n    var inverted = self.value < 0\n\n    var t = [],\n        value = inverted ? ~self.value : self.value\n    for(var flag in inline_flags){\n        if(value & inline_flags[flag].value){\n            t.push('re.' + flag_names[flag])\n            value &= ~inline_flags[flag].value\n        }\n    }\n    if(value > 0){\n        t.push('0x' + value.toString(16))\n    }\n    var res = t.join('|')\n    if(inverted){\n        if(t.length > 1){\n            return '~(' + res + ')'\n        }else{\n            return '~' + res\n        }\n    }\n    return res\n}\n\nFlag.__xor__ = function(self, other){\n    return Flag.$factory(self.value ^ other.value)\n}\n\n$B.set_func_names(Flag, \"re\")\n\nvar no_flag = {}\n\nvar Scanner = $B.make_class(\"Scanner\",\n    function(pattern, string){\n        return {\n            __class__: Scanner,\n            $string: string,\n            pattern\n        }\n    }\n)\n\nScanner.match = function(self){\n    return BPattern.match(self.pattern, self.$string)\n}\n\nScanner.search = function(self){\n    if(! self.$iterator){\n        self.$iterator = $module.finditer(self.pattern, self.$string)\n    }\n    try{\n        var nxt = _b_.next(self.$iterator)\n    }catch(err){\n        if($B.is_exc(err, [_b_.StopIteration])){\n            return _b_.None\n        }\n        throw err\n    }\n    return nxt\n}\n\nvar BPattern = $B.make_class(\"Pattern\",\n    function(pattern){\n        var nb_groups = 0\n        for(var key in pattern.groups){\n            if(isFinite(key)){\n                nb_groups++\n            }\n        }\n        return {\n            __class__: BPattern,\n            pattern: pattern.text,\n            groups: nb_groups,\n            flags: pattern.flags,\n            $groups: pattern.groups,\n            $pattern: pattern\n        }\n    }\n)\n\nBPattern.__eq__ = function(self, other){\n    if(self.$pattern.type != other.$pattern.$type){\n        // warn(_b_.BytesWarning, \"cannot compare str and bytes pattern\", 1)\n    }\n    return self.pattern == other.pattern &&\n        self.flags.value == other.flags.value\n}\n\nBPattern.__hash__ = function(self){\n    // best effort ;-)\n    return _b_.hash(self.pattern) + self.flags.value\n}\n\nBPattern.__repr__ = BPattern.__str__ = function(self){\n    var text = self.$pattern.text,\n        s = text\n    if(self.$pattern.type == \"bytes\"){\n        s = _b_.str.$factory(_b_.str.encode(s, 'latin-1'))\n    }else{\n        s = _b_.repr(s)\n    }\n    s = s.substr(0, 200)\n    var res = `re.compile(${s}`,\n        flags = self.$pattern.flags\n    if(flags === no_flag){\n        return res + ')'\n    }\n    // mask UNICODE flag\n    if(flags.__class__ === Flag){\n        // copy flag, otherwise U.value would become 0\n        flags = Flag.$factory(flags.value)\n        flags.value &= ~U.value\n    }else if(typeof flags == \"number\"){\n        flags &= ~U.value\n    }\n    if(flags != 0 && flags.value != 0){\n        res += `, ${_b_.str.$factory(flags)}`\n    }\n    return res + ')'\n}\n\nBPattern.findall = function(self){\n    var iter = BPattern.finditer.apply(null, arguments),\n        res = []\n\n    while(true){\n        var next = iter.next()\n        if(next.done){\n            return res\n        }\n        var bmo = next.value,\n            mo = bmo.mo,\n            groups = BMO.groups(bmo)\n\n        // replace None by the empty string\n        for(var i = 0, len = groups.length; i < len; i++){\n            groups[i] = groups[i] === _b_.None ? \"\" : groups[i]\n        }\n        if(groups.length > 0){\n            if(groups.length == 1){\n                res.push(groups[0])\n            }else{\n                res.push($B.fast_tuple(groups))\n            }\n        }else{\n            res.push(mo.string.substring(mo.start, mo.end))\n        }\n    }\n}\n\nBPattern.finditer = function(self){\n    var $ = $B.args(\"finditer\", 4,\n            {self: null, string: null, pos: null, endpos: null},\n            'self string pos endpos'.split(' '), arguments,\n            {pos: 0, endpos: _b_.None}, null, null)\n    var original_string = $.string,\n        data = prepare({string: $.string})\n    var endpos = $.endpos === _b_.None ? data.string.length : $.endpos\n    return $B.generator.$factory(iterator)(self.$pattern, data.string,\n            no_flag, $.string, $.pos, endpos)\n}\n\nBPattern.fullmatch = function(self, string){\n    var $ = $B.args(\"match\", 4,\n                    {self: null, string: null, pos: null, endpos: null},\n                    [\"self\", \"string\", \"pos\", \"endpos\"], arguments,\n                    {pos: 0, endpos: _b_.None}, null, null)\n    if($.endpos === _b_.None){\n        $.endpos = $.string.length\n    }\n    var data = prepare({string: $.string})\n    if(self.$pattern.type != data.string.type){\n        throw _b_.TypeError.$factory(\"not the same type for pattern \" +\n            \"and string\")\n    }\n    var mo = match($.self.$pattern, data.string, $.pos, $.endpos)\n    if(mo && mo.end - mo.start == $.endpos - $.pos){\n        return BMO.$factory(mo)\n    }else{\n        return _b_.None\n    }\n}\nvar GroupIndex = $B.make_class(\"GroupIndex\",\n    function(self, _default){\n        var res = $B.empty_dict()\n        res.__class__ = GroupIndex\n        for(var key in self.$groups){\n            if(isNaN(parseInt(key))){\n                res.$string_dict[key] = [self.$groups[key].num,\n                    res.$version++]\n            }\n        }\n        return res\n    }\n)\nGroupIndex.__mro__ = [_b_.dict, _b_.object]\nGroupIndex.__setitem__ = function(){\n    throw _b_.TypeError.$factory(\"read only\")\n}\n\n$B.set_func_names(GroupIndex, \"re\")\n\nBPattern.groupindex = {\n    __get__: function(self){\n        return GroupIndex.$factory(self)\n    }\n}\n\nBPattern.match = function(self, string){\n    var $ = $B.args(\"match\", 4,\n                    {self: null, string: null, pos: null, endpos: null},\n                    [\"self\", \"string\", \"pos\", \"endpos\"], arguments,\n                    {pos: 0, endpos: _b_.None}, null, null)\n    if($.endpos === _b_.None){\n        $.endpos = $.string.length\n    }\n    var data = prepare({string: $.string})\n    if(self.$pattern.type != data.string.type){\n        throw _b_.TypeError.$factory(\"not the same type for pattern \" +\n            \"and string\")\n    }\n    var mo = match($.self.$pattern, data.string, $.pos,\n        $.endpos)\n    return mo ? BMO.$factory(mo) : _b_.None\n}\n\nBPattern.scanner = function(self, string){\n    return Scanner.$factory(self, string)\n}\n\nBPattern.search = function(self, string){\n    var $ = $B.args(\"match\", 4,\n                    {self: null, string: null, pos: null, endpos: null},\n                    [\"self\", \"string\", \"pos\", \"endpos\"], arguments,\n                    {pos: 0, endpos: _b_.None}, null, null)\n    if($.endpos === _b_.None){\n        $.endpos = $.string.length\n    }\n    var data = prepare({string: $.string})\n    if(self.$pattern.type != data.string.type){\n        throw _b_.TypeError.$factory(\"not the same type for pattern \" +\n            \"and string\")\n    }\n    var pos = $.pos\n    while(pos < $.endpos){\n        var mo = match(self.$pattern, data.string, pos)\n        if(mo){\n            return BMO.$factory(mo)\n        }else{\n            pos++\n        }\n    }\n    return _b_.None\n}\n\nBPattern.split = function(){\n    return $module.split.apply(null, arguments)\n}\n\nBPattern.sub = function(){\n    var $ = $B.args(\"match\", 4,\n                    {self: null, repl: null, string: null, count: null},\n                    \"self repl string count\".split(' '), arguments,\n                    {count: 0}, null, null)\n    var data = prepare({string: $.string})\n    if($.self.$pattern.type != data.string.type){\n        throw _b_.TypeError.$factory(\"not the same type for pattern \" +\n            \"and string\")\n    }\n\n    return $module.sub($.self, $.repl, $.string, $.count)\n}\n\n$B.set_func_names(BPattern, \"re\")\n\nfunction Node(parent){\n    this.parent = parent\n    this.items = []\n}\n\nNode.prototype.add = function(item){\n    this.items.push(item)\n    item.parent = this\n}\n\nNode.prototype.fixed_length = function(){\n    // Return the sum of items lengths if fixed, else undefined\n    if(this.repeat){\n        return false\n    }\n    var len = 0\n    for(var item of this.items){\n        if(item.fixed_length === undefined){\n            console.log(\"pas de fixed length\", item)\n            alert()\n        }\n        var sublen = item.fixed_length()\n        if(sublen === false){\n            return false\n        }\n        len += sublen\n    }\n    return len\n}\n\nfunction get_top(node){\n    var top = node.parent\n    while(top.parent){\n        top = top.parent\n    }\n    return top\n}\n\nvar BackReference = function(pos, type, value){\n    // for \"\\number\"\n    this.name = \"BackReference\"\n    this.pos = pos\n    this.type = type // \"name\" or \"num\"\n    this.value = value\n    this.groups = []\n}\n\nBackReference.prototype.fixed_length = function(){\n    // Return length of referenced group if it is fixed, else undefined\n    if(this.repeat){\n        return undefined\n    }\n    var group = this.get_group()\n    if(group.fixed_length === undefined){\n        console.log(\"group\", group, \"no fixed length\")\n        alert()\n    }\n    return group === undefined ? false : group.fixed_length()\n}\n\nBackReference.prototype.get_group = function(){\n    var top = get_top(this)\n    return top.$groups[this.value]\n}\n\nBackReference.prototype.match = function(string, pos, groups){\n    this.repeat = this.repeat || {min: 1, max: 1}\n\n    var group = groups[this.value]\n    if(group === undefined){\n        if(this.repeat.min == 0){\n            return {\n                nb_min: 0,\n                nb_max: 0\n            }\n        }\n        return false\n    }\n\n    // Get the codepoints matched by the referenced group\n    group_cps = string.codepoints.slice(group.start, group.end)\n\n    // search (repetitions of) the matched group codepoints\n    var _pos = pos,\n        nb = 0,\n        len = string.codepoints.length,\n        group_len = group_cps.length,\n        flag\n    while(_pos < len && nb < this.repeat.max){\n        flag = true\n        for(var i = 0; i < group_len; i++){\n            if(string.codepoints[_pos + i] != group_cps[i]){\n                flag = false\n                break\n            }\n        }\n        if(flag){\n            nb++\n            _pos += group_len\n        }else{\n            break\n        }\n    }\n    if(nb >= this.repeat.min){\n        // Returns the accepted minimum and maximum number of repeats\n        // and the length of each repeat\n        return {\n            nb_min: this.repeat.min,\n            nb_max: nb,\n            group_len\n        }\n    }\n    return false\n}\n\nBackReference.prototype.toString = function(){\n    return \"BackRef to group\" + this.value\n}\n\nvar Case = function(){\n    this.name = \"Case\"\n    this.items = []\n    this.groups = []\n    this.text = 'Case '\n}\n\nCase.prototype.add = function(item){\n    this.items.push(item)\n    item.parent = this\n    this.text += item.toString()\n}\n\nCase.prototype.fixed_length = function(){\n    var len\n    for(var item of this.items){\n        var fl = item.fixed_length()\n        if(fl === false){\n            return false\n        }else if(len === undefined){\n            len = fl\n        }else{\n            len += fl\n        }\n    }\n    return len\n}\n\nCase.prototype.toString = function(){\n    return 'Case ' + this.text\n}\n\nvar Choice = function(){\n    this.type = \"choice\"\n    this.items = []\n    this.groups = []\n}\n\nChoice.prototype.add = Node.prototype.add\n\nChoice.prototype.fixed_length = function(){\n    var len\n    for(var item of this.items){\n        var fl = item.fixed_length()\n        if(fl === false){\n            return false\n        }else if(len === undefined){\n            len = fl\n        }else if(len != fl){\n            return false\n        }\n     }\n     return len\n}\n\nfunction subgroups(item){\n    // Return all the subgroups below item\n    var groups = []\n    if(item.items){\n        for(var subitem of item.items){\n            if(subitem instanceof Group && subitem.num){\n                groups.push(subitem.num)\n                if(subitem.name){\n                    groups.push(subitem.name)\n                }\n            }\n            groups = groups.concat(subgroups(subitem))\n        }\n    }\n    return item.$subgroups = groups\n}\n\nChoice.prototype.toString = function(){\n    return 'Choice'\n}\n\nvar EmptyString = {\n        toString: function(){\n            return ''\n        },\n        match: function(string, pos){\n            return {nb_min: 0, nb_max: 0}\n        },\n        fixed_length: function(){\n            return 1\n        },\n        length: 0\n    },\n    Flags = function(flags){\n        this.flags = flags\n    },\n    GroupEnd = function(pos){\n        this.name = \"GroupEnd\"\n        this.pos = pos\n        this.text = ')'\n        this.toString = function(){\n            return '[end of group #' + this.group.num + ']'\n        }\n    },\n    Or = function(pos){\n        this.name = \"Or\"\n        this.pos = pos\n        this.text = '|'\n        this.toString = function(){\n            return '|'\n        }\n    },\n    Repeater = function(pos, op){\n        this.name = \"Repeater\"\n        this.pos = pos\n        this.op = op\n    }\n\nfunction cased_cps(cp, ignore_case, ascii){\n    // If cp is the codepoint of a cased Unicode character, return the list\n    // of the codepoints that match the character in a case-insensitive way\n\n    // ignore_case = this.flags && this.flags.value & IGNORECASE.value\n    // ascii = this.flags.value & ASCII.value\n    var cps,\n        char = $B.codepoint2jsstring(cp)\n    if(! ignore_case){\n        return [cp]\n    }\n    if(ascii){\n        // only test ASCII letters\n        ignore_case = ignore_case && (\n            (char >= 'a' && char <= 'z') ||\n            (char >= 'A' && char <= 'Z'))\n    }\n    if(ignore_case){\n        var char_up = char.toUpperCase(),\n            char_low = char.toLowerCase(),\n            cps = new Set([cp, $B.jsstring2codepoint(char_low),\n                $B.jsstring2codepoint(char_up)])\n        // special cases\n        if(char.toLowerCase() == \"k\"){\n            cps.add(0x212a) // Kelvin sign\n        }\n        if(cp == 0x212a){\n            cps.add(ord('k'))\n            cps.add(ord('K'))\n        }\n        if(char.toLowerCase() == \"s\"){\n            cps.add(0x017f) //  (Latin small letter long s)\n        }\n        if(cp == 0x017f){\n            cps.add(ord('s'))\n            cps.add(ord('S'))\n        }\n        if(char.toLowerCase() == 'i'){\n            cps.add(0x0130) //  (Latin capital letter I with dot above)\n            cps.add(0x0131) //  (Latin small letter dotless i)\n        }\n        if(cp == 0x0130 || cp == 0x0131){\n            cps.add(ord('i'))\n            cps.add(ord('I'))\n        }\n        return Array.from(cps)\n    }else{\n        cps = [cp]\n    }\n    return cps\n}\n\nvar Char = function(pos, cp, groups){\n    // character in a regular expression or in a character set\n    // pos : position of the character in the pattern string\n    // cp : the character's codepoint\n    // groups (optional) : the groups that contain the character\n    this.pos = pos\n    this.cp = cp\n    this.char = chr(this.cp)\n    this.text = this.char\n}\n\nChar.prototype.fixed_length = function(){\n    if(this.repeat){\n        return this.repeat.min\n    }\n    return this.char === EmptyString ? 0 : 1\n}\n\nChar.prototype.match = function(string, pos){\n    // Returns {pos1, pos2} such that \"this\" matches all the substrings\n    // string[pos:i] with pos1 <= i < pos2, or false if no match\n    this.repeat = this.repeat || {min: 1, max: 1}\n\n    var len = string.codepoints.length,\n        i = 0\n\n    // browse string codepoints until they don't match, or the number of\n    // matches is above the maximum allowed\n    if(this.flags){\n        if(this.flags.value & ASCII.value){\n            if(this.cp > 127){\n                return false\n            }\n        }\n        if(this.flags.value & IGNORECASE.value &&\n                (! this.is_bytes || this.cp <= 127)){\n            // Flag IGNORECASE set\n            // For bytes pattern, case insensitive matching only works\n            // for ASCII characters\n            var char_upper = this.char.toUpperCase(),\n                char_lower = this.char.toLowerCase()\n            while(i < this.repeat.max && pos + i < len){\n                var char = chr(string.codepoints[pos + i])\n                if(char.toUpperCase() != char_upper &&\n                        char.toLowerCase() != char_lower){\n                   break\n                }\n                i++\n            }\n        }else{\n            while(string.codepoints[pos + i] == this.cp &&\n                    i < this.repeat.max){\n                i++\n            }\n        }\n    }else{\n        while(string.codepoints[pos + i] == this.cp && i < this.repeat.max){\n            i++\n        }\n    }\n    var nb = i\n    if(nb >= this.repeat.min){\n        // Number of repeats ok\n        return {\n            nb_min: this.repeat.min,\n            nb_max: nb\n        }\n    }else{\n        return false\n    }\n}\n\nChar.prototype.toString = function(){\n    var res = 'Char ' + this.text\n    if(this.repeat !== undefined){\n        res += ' repeat {' + this.repeat.min + ',' + this.repeat.max + '}'\n        if(this.non_greedy){\n            res += '?'\n        }\n    }\n    return res\n}\n\nfunction CharSeq(chars){\n    // sequence of consecutive characters\n    this.chars = chars\n}\n\nCharSeq.prototype.fixed_length = function(){\n    var len = 0\n    for(var char of this.chars){\n        len += char.fixed_length()\n    }\n    return len\n}\n\nCharSeq.prototype.match = function(string, pos){\n    var mos = [],\n        i = 0,\n        backtrack,\n        nb\n    for(var i = 0, len = this.chars.length; i < len; i++){\n        var char =  this.chars[i],\n            mo = char.match(string, pos) // form {nb_min, nb_max}\n        if(mo){\n            nb = char.non_greedy ? mo.nb_min : mo.nb_max\n            mos.push({nb,\n                      nb_min: mo.nb_min,\n                      nb_max: mo.nb_max,\n                      non_greedy: !!char.non_greedy\n                     })\n            pos += nb\n        }else{\n            // backtrack\n            backtrack = false\n            while(mos.length > 0){\n                i--\n                mo = mos.pop()\n                pos -= mo.nb\n                if(mo.non_greedy && nb + 1 < mo.nb_max){\n                    nb += 1\n                    backtrack = true\n                }else if(! mo.non_greedy && nb - 1 >= mo.nb_min){\n                    nb -= 1\n                    backtrack = true\n                }\n                if(backtrack){\n                    pos += nb\n                    mo.nb = nb\n                    mos.push(mo)\n                    i++\n                    break\n                }\n            }\n            if(mos.length == 0){\n                return false\n            }\n        }\n    }\n    var match_len = 0\n    for(var mo of mos){\n        match_len += mo.nb\n    }\n    return {\n        nb_min: match_len,\n        nb_max: match_len\n    }\n}\n\n\n\n\nCharSeq.prototype.toString = function(){\n    var res = ''\n    for(var char of this.chars){\n        res += char.text\n    }\n    return 'CharSeq ' + res\n}\n\nfunction CharacterClass(pos, cp, length, groups){\n    this.cp = cp\n    this.value = chr(cp)\n    this.length = length\n    this.pos = pos\n\n    var flags = this.flags\n\n    // Test function : test(string, pos) returns:\n    // - true if \"this\" matches 1 character string[pos]\n    // - [true, 0] if \"this\" matches the empty string at pos\n    // - false or undefined if \"this\" doesn't match\n    switch(this.value){\n        case 'A':\n            this.test_func = function(string, pos){\n                if(pos == 0){\n                    return [true, 0]\n                }\n            }\n            break\n        case 's':\n            this.test_func = function(string, pos){\n                var cp = string.codepoints[pos]\n                return $B.unicode_tables.Zs[cp] !== undefined ||\n                    $B.unicode_bidi_whitespace.indexOf(cp) > -1\n            }\n            break\n        case 'S':\n            this.test_func = function(string, pos){\n                var cp = string.codepoints[pos]\n                return $B.unicode_tables.Zs[cp] === undefined &&\n                    $B.unicode_bidi_whitespace.indexOf(cp) == -1\n            }\n            break\n        case '.':\n            this.test_func = function(string, pos){\n                if(string.codepoints[pos] === undefined){\n                    return false\n                }\n                if(this.flags.value & DOTALL.value){\n                    return true\n                }else{\n                    return string.codepoints[pos] != 10\n                }\n            }\n            break\n        case 'd':\n            this.test_func = function(string, pos){\n                if(this.flags === undefined){\n                    console.log(\"\\\\d, no flags\", this)\n                }\n                var cp = string.codepoints[pos],\n                    table = (this.flags.value & ASCII.value) ?\n                        is_ascii_digit : is_digit\n                return table[cp]\n            }\n            break\n        case 'D':\n            this.test_func = function(string, pos){\n                var cp = string.codepoints[pos],\n                    table = (this.flags.value & ASCII.value) ?\n                        is_ascii_digit : is_digit\n                return ! table[cp]\n            }\n            break\n        case 'b':\n            this.test_func = function(string, pos){\n                var table = is_word\n                if(this.is_bytes || (this.flags.value & ASCII.value)){\n                    table = is_ascii_word\n                }\n                var cp = string.codepoints[pos],\n                    len = string.codepoints.length,\n                    ok = {nb_min: 0, nb_max: 0}\n\n                // return true if char at pos is at the beginning or start\n                // of a word\n                if(pos == 0 && table[cp]){\n                    return ok\n                }\n                if(pos == len && table[string.codepoints[pos - 1]]){\n                    return ok\n                }\n                if(pos > 0 && pos < len){\n                    if((table[string.codepoints[pos - 1]]) !==\n                            table[cp]){\n                        return ok\n                    }\n                }\n                return false\n            }\n            break\n        case 'B':\n            this.test_func = function(string, pos){\n                var table = is_word\n                if(this.is_bytes || (this.flags.value & ASCII.value)){\n                    table = is_ascii_word\n                }\n\n                var cp = string.codepoints[pos],\n                    len = string.codepoints.length,\n                    ok = {nb_min: 0, nb_max: 0}\n                // test is true if char at pos is not at the beginning or\n                // start of a word\n                if(pos == 0 && table[cp]){\n                    return false\n                }\n                if(pos == len && table[string.codepoints[pos - 1]]){\n                    return false\n                }\n                if(pos > 0 && pos < len){\n                    if((table[string.codepoints[pos - 1]]) !==\n                            table[cp]){\n                        return false\n                    }\n                }\n                return ok\n            }\n            break\n        case 'w':\n            this.test_func = function(string, pos){\n                var table = is_word\n                if(this.is_bytes || (this.flags.value & ASCII.value)){\n                    table = is_ascii_word\n                }\n                return table[string.codepoints[pos]]\n            }\n            break\n        case 'W':\n            this.test_func = function(string, pos){\n                var table = is_word\n                if(this.is_bytes || (this.flags.value & ASCII.value)){\n                    table = is_ascii_word\n                }\n                return ! table[string.codepoints[pos]]\n            }\n            break\n        case 'Z':\n            this.test_func = function(string, pos){\n                if(pos >= string.codepoints.length){\n                    return {nb_min: 0, nb_max: 0}\n                }\n            }\n            break\n    }\n}\n\nCharacterClass.prototype.fixed_length = function(){\n    return 1\n}\n\nCharacterClass.prototype.match = function(string, pos){\n    // Returns {pos1, pos2} such that \"this\" matches all the substrings\n    // string[pos:i] with pos1 <= i < pos2, or false if no match\n    this.repeat = this.repeat || {min: 1, max: 1}\n    var len = string.codepoints.length,\n        i = 0\n\n    // browse string codepoints until they don't match, or the number of\n    // matches is above the maximum allowed\n    while(pos + i <= len &&\n            this.test_func(string, pos + i, this.flags) &&\n            i < this.repeat.max){\n        i++\n    }\n    var nb = i\n    if(nb >= this.repeat.min){\n        // Number of repeats ok\n        if('bBAZ'.indexOf(this.value) > -1 ){\n            return {nb_min: 0, nb_max: 0}\n        }\n        return {\n            nb_min: this.repeat.min,\n            nb_max: nb\n        }\n    }else{\n        return false\n    }\n}\n\nCharacterClass.prototype.nb_repeats = Char.prototype.nb_repeats\n\nCharacterClass.prototype.toString = function(){\n    return '\\\\' + this.value\n}\n\nvar CharacterSet = function(pos, set, groups){\n    // character set\n    this.pos = pos\n    this.set = set\n    this.neg = set.neg\n}\n\nCharacterSet.prototype.fixed_length = function(){\n    return 1\n}\n\nCharacterSet.prototype.match = function(string, pos){\n    var ignore_case = this.flags && (this.flags.value & IGNORECASE.value),\n        test,\n        match = false,\n        len = string.codepoints.length,\n        i = 0,\n        cp\n\n    this.repeat = this.repeat || {min: 1, max: 1}\n\n    while(i < this.repeat.max && pos + i < len){\n        test = false\n        cp = string.codepoints[pos + i]\n\n        if(pos >= len){\n            cp = EmptyString\n        }\n        try{\n            $B.codepoint2jsstring(cp)\n        }catch(err){\n            console.log(err.message)\n            throw _b_.Exception.$factory('mauvais codepoint')\n        }\n        var char = $B.codepoint2jsstring(cp),\n            cps = cased_cps(cp, ignore_case, this.flags.value & ASCII.value),\n            char_is_cased = cps.length > 1\n\n        for(var cp1 of cps){\n            for(var item of this.set.items){\n                if(Array.isArray(item.ord)){\n                    if(cp1 >= item.ord[0] &&\n                            cp1 <= item.ord[1]){\n                        test = true\n                        break\n                    }else if(ignore_case && char_is_cased){\n                        var start1 = chr(item.ord[0]).toUpperCase(),\n                            end1 = chr(item.ord[1]).toUpperCase(),\n                            char1 = char.toUpperCase()\n                        if(char1 >= start1 && char1 <= end1){\n                            test = true\n                        }\n                        var start1 = chr(item.ord[0]).toLowerCase(),\n                            end1 = chr(item.ord[1]).toLowerCase(),\n                            char1 = char.toLowerCase()\n                        if(char1 >= start1 && char1 <= end1){\n                            test = true\n                        }\n                    }\n                }else if(item instanceof CharacterClass){\n                    test = !! item.match(string, pos) // boolean\n                }else{\n                    if(item.ord == cp1){\n                        test = true\n                        break\n                    }\n                    if(ignore_case && char_is_cased &&\n                            (char.toUpperCase() == chr(item.ord).toUpperCase() ||\n                            char.toLowerCase() == chr(item.ord).toLowerCase())){\n                        test = true\n                        break\n                    }\n                }\n            }\n        }\n        if(this.neg){\n            test = ! test\n        }\n        if(test){\n            i++\n        }else{\n            break\n        }\n    }\n    var nb = i\n    if(nb >= this.repeat.min){\n        // Number of repeats ok\n        return {\n            nb_min: this.repeat.min,\n            nb_max: nb\n        }\n    }else{\n        return false\n    }\n\n}\n\nCharacterSet.prototype.nb_repeats = Char.prototype.nb_repeats\n\nCharacterSet.prototype.toString = function(){\n    return 'CharSet'\n}\n\nvar ConditionalBackref = function(pos, group_ref){\n    this.type = \"conditional backref\"\n    this.pos = pos\n    this.group_ref = group_ref\n    this.chars = []\n    this.match_codepoints = []\n    this.nb_success = 0\n    this.re_if_exists = new Group(pos)\n    this.re_if_not_exists = new Group(pos)\n    this.nb_options = 1\n}\n\nConditionalBackref.prototype.add = function(item){\n    if(this.nb_options == 1){\n        this.re_if_exists.add(item)\n    }else if(this.nb_options == 2){\n        this.re_if_not_exists.add(item)\n    }\n    item.parent = this\n}\n\nConditionalBackref.prototype.fixed_length = function(){\n    var len = this.re_if_exists.fixed_length()\n    if(len !== false && len == this.re_if_not_exists.fixed_length()){\n        return len\n    }\n    return false\n}\n\nConditionalBackref.prototype.match = function(string, pos, groups){\n    var re = groups[this.group_ref] ? this.re_if_exists :\n            this.re_if_not_exists,\n        pattern = {node: re, text: re + ''},\n        mo = match(pattern, string, pos, undefined,\n            false, groups)\n    if(mo){\n        return {nb_min: mo.end - mo.start, nb_max: mo.end - mo.start}\n    }\n    return false\n}\n\nConditionalBackref.prototype.toString = function(){\n    return 'ConditionalBackref'\n}\n\nvar Group = function(pos, extension){\n    this.type = \"group\"\n    this.pos = pos\n    this.items = []\n    this.chars = []\n    this.groups = []\n    for(key in extension){\n        this[key] = extension[key]\n    }\n    if(extension && extension.type){\n        if(extension.type.indexOf('lookahead') > -1){\n            this.is_lookahead = true\n        }else if(extension.type.indexOf('lookbehind') > -1){\n            this.is_lookbehind = true\n        }\n    }\n}\n\nGroup.prototype.add = Node.prototype.add\n\nGroup.prototype.toString = function(){\n    var res = 'Group #' + this.num + ' ' + this.pattern\n    if(this.repeat !== undefined){\n        res += ' repeat {' + this.repeat.min + ',' + this.repeat.max + '}'\n        if(this.non_greedy){\n            res += '?'\n        }\n    }\n    return res\n}\n\nBackReference.prototype.nb_repeats = Group.prototype.nb_repeats\n\nGroup.prototype.fixed_length = Node.prototype.fixed_length\n\nfunction GroupRef(group_num, item){\n    this.num = group_num\n    this.item = item\n}\n\nGroupRef.prototype.fixed_length = function(){\n    return this.item.fixed_length()\n}\n\nfunction Lookbehind(item){\n    this.re = item\n    this.neg = this.re.type == \"negative_lookbehind\"\n}\n\nLookbehind.prototype.match = function(string, pos, groups){\n    var ok = {nb_min: 0, nb_max: 0},\n        pattern = {node: this.re, text: this.re + ''},\n        length = this.re.length,\n        mo\n    if(pos - length < 0){\n        mo = false\n    }else{\n        mo = match(pattern, string, pos - length, undefined,\n            false, groups)\n    }\n    if(mo){\n        return this.neg ? false : ok\n    }else{\n        return this.neg ? ok : false\n    }\n}\n\nLookbehind.prototype.fixed_length = function(){\n    return this.re.fixed_length()\n}\n\nLookbehind.prototype.toString = function(){\n    return \"Lookbehind\"\n}\n\nfunction SetFlags(pos, flags){\n    this.pos = pos\n    this.on_flags = flags.on_flags\n    this.off_flags = flags.off_flags\n    this.items = []\n}\n\nSetFlags.prototype.add = Node.prototype.add\n\nfunction StringStart(pos){\n    this.pos = pos\n}\n\nStringStart.prototype.match = function(string, pos){\n    var ok = {nb_min:0, nb_max: 0}\n    if(this.flags.value & MULTILINE.value){\n        return (pos == 0 || string.codepoints[pos - 1] == 10) ? ok : false\n    }\n    return pos == 0 ? ok : false\n}\n\nStringStart.prototype.fixed_length = function(){\n    return 0\n}\n\nStringStart.prototype.toString = function(){\n    return '^'\n}\n\nfunction StringEnd(pos){\n    this.pos = pos\n}\n\nStringEnd.prototype.match = function(string, pos){\n    var ok = {nb_min:0, nb_max: 0}\n    if(this.flags.value & MULTILINE.value){\n        return (pos > string.codepoints.length - 1 ||\n            string.codepoints[pos] == 10) ? ok : false\n    }\n    return pos > string.codepoints.length - 1 ? ok :\n           (pos == string.codepoints.length - 1 &&\n               string.codepoints[pos] == 10) ? ok : false\n}\n\nStringEnd.prototype.fixed_length = function(){\n    return 0\n}\n\nStringEnd.prototype.toString = function(){\n    return '$<end>'\n}\n\nfunction validate(name){\n    // name is a StringObj\n    sname = name.string\n    name = name.codepoints\n    if(name.length == 0){\n        fail(\"missing group name\")\n    }else if(chr(name[0]).match(/\\d/) || name.indexOf(ord('.')) > - 1){\n        fail(`bad character in group name '${sname}'`)\n    }\n\n    var $B = window.__BRYTHON__,\n        cp = name[0]\n    if($B.unicode_tables.XID_Start[cp]){\n        var pos = 1\n        while(pos < name.length){\n            cp = name[pos]\n            if($B.unicode_tables.XID_Continue[cp]){\n                pos++\n            }else{\n                break\n            }\n        }\n        if(pos != name.length){\n            console.log(\"bad character\", pos, name)\n            fail(`bad character in group name '${sname}'`)\n        }\n    }else{\n        fail(`bad character in group name '${sname}'`)\n    }\n}\n\nvar chr = _b_.chr\n\nvar character_classes = {\n    in_charset: to_codepoint_list('bdDsSwW'),\n    in_re: to_codepoint_list('AbBdDsSwWZ')\n}\n\nfunction escaped_char(args){\n    var cps = args.codepoints,\n        pos = args.pos,\n        in_charset = args.in_charset,\n        is_bytes = args.is_bytes // if pattern is bytes\n    var special = cps[pos + 1]\n    if(special === undefined){\n        fail('bad escape (end of pattern)', pos)\n    }\n    var key = in_charset ? 'in_charset' : 'in_re'\n    if(character_classes[key].indexOf(special) > -1){\n        return new CharacterClass(pos, special, 2)\n    }else if(special == ord('N') && ! is_bytes){\n        if(cps[pos + 2] != ord('{')){\n            fail('missing {', pos)\n        }\n        var i = pos + 3,\n            description = []\n        while(i < cps.length){\n            if(cps[i] == ord('}')){\n                break\n            }\n            description.push(cps[i])\n            i++\n        }\n        if(description.length == 0){\n            fail(\"missing character name\", pos)\n        }\n        if(i == cps.length){\n            fail(\"missing }, unterminated name\", pos)\n        }\n        var cp = validate_named_char(from_codepoint_list(description))\n        return {\n            type: 'N',\n            ord: cp,\n            char: chr(cp),\n            length: i - pos + 1\n        }\n    }else if(special == ord('x')){\n        // \\xhh = character with hex value hh\n        var rest = from_codepoint_list(cps.slice(pos + 2)),\n            mo = /^[0-9a-fA-F]{0,2}/.exec(rest),\n            hh = mo ? mo[0] : ''\n        if(mo && mo[0].length == 2){\n            var cp = eval(\"0x\" + mo[0])\n            return {\n                type: 'x',\n                ord: cp,\n                char: chr(cp),\n                length: 2 + mo[0].length\n            }\n        }\n        fail('incomplete escape \\\\x' + hh, pos)\n    }else if(special == ord('u')){\n        // \\uxxxx = character with 16-bit hex value xxxx\n        var rest = from_codepoint_list(cps.slice(pos + 2)),\n            mo = /^[0-9a-fA-F]{0,4}/.exec(rest),\n            xx = mo ? mo[0] : ''\n        if(mo && mo[0].length == 4){\n            var cp = eval(\"0x\" + mo[0])\n            return {\n                type: 'u',\n                ord: cp,\n                char: chr(cp),\n                length: 2 + mo[0].length\n            }\n        }\n        fail('incomplete escape \\\\u' + xx, pos)\n    }else if(special == ord('U')){\n        // \\Uxxxxxxxx = character with 32-bit hex value xxxxxxxx\n        var rest = from_codepoint_list(cps.slice(pos + 2)),\n            mo = /^[0-9a-fA-F]{0,8}/.exec(rest),\n            xx = mo ? mo[0] : ''\n        if(mo && mo[0].length == 8){\n            var cp = eval(\"0x\" + mo[0])\n            if(cp > 0x10FFFF){\n                fail(`bad escape \\\\U${mo[0]}`)\n            }\n            return {\n                type: 'U',\n                ord: cp,\n                char: chr(cp),\n                length: 2 + mo[0].length\n            }\n        }\n        fail('incomplete escape \\\\U' + xx, pos)\n    }else{\n        // octal ?\n        // If the first digit of number is 0, or number is 3 octal digits\n        // long, it will not be interpreted as a group match, but as the\n        // character with octal value number\n        var rest = from_codepoint_list(cps.slice(pos + 1)),\n            mo = /^[0-7]{3}/.exec(rest)\n        if(mo == null){\n            mo = /^0[0-7]*/.exec(rest)\n        }\n        if(mo){\n            var octal_value = eval('0o' + mo[0])\n            if(octal_value > 0o377){\n                fail(`octal escape value \\\\` +\n                    `${mo[0]} outside of range 0-0o377`, pos)\n            }\n            return {\n                type: 'o',\n                ord: octal_value,\n                char: chr(octal_value),\n                length: 1 + mo[0].length\n            }\n        }\n        var mo = /^\\d+/.exec(rest)\n        if(mo){\n            return {\n                type: 'backref',\n                value: parseInt(mo[0]),\n                length: 1 + mo[0].length\n            }\n        }\n        var trans = {f: '\\f', n: '\\n', r: '\\r', t: '\\t', v: '\\v'},\n            res = trans[chr(special)]\n        if(res){\n            return ord(res)\n        }\n        if(chr(special).match(/[a-zA-Z]/)){\n            fail(\"bad escape \\\\\" + chr(special), pos)\n        }else{\n            return special\n        }\n    }\n}\n\nfunction check_character_range(t, positions){\n    // Check if last 2 items in t are a valid character range\n    var start = t[t.length - 2],\n        end = t[t.length - 1]\n    if(start instanceof CharacterClass || end instanceof CharacterClass){\n        fail(`bad character range ${start}-${end}`,\n            positions[positions.length - 2])\n    }else if(end < start){\n        fail(`bad character range ${start}-${end}`,\n            positions[positions.length - 2])\n    }\n    t.splice(t.length - 2, 2, {\n        type: 'character_range',\n        start: start,\n        end: end,\n        ord: [start.ord, end.ord]\n    })\n}\n\nfunction parse_character_set(text, pos, is_bytes){\n    // Parse character set starting at position \"pos\" in \"text\"\n    // pos is the position of the leading \"[\"\n    var start = pos,\n        result = {items: []},\n        positions = []\n    pos++\n    if(text[pos] == ord('^')){\n        result.neg = true\n        pos++\n    }else if(text[pos] == ord(']')){\n        // a leading ] is the character \"]\", not the set end\n        result.items.push(']')\n        positions.push(pos)\n        pos++\n    }else if(text[pos] == ord('[')){\n        // send FutureWarning\n        warn(_b_.FutureWarning, \"Possible nested set\", pos)\n    }\n    var range = false\n    while(pos < text.length){\n        var cp = text[pos],\n            char = chr(cp)\n        if(char == ']'){\n            if(pos == start + 2 && result.neg){\n                // in \"[^]]\", the first ] is the character \"]\"\n                result.items.push(']')\n            }else{\n                return [result, pos]\n            }\n        }\n        if(char == '\\\\'){\n            var escape = escaped_char({\n                    codepoints: text,\n                    pos,\n                    in_charset: true,\n                    is_bytes\n                })\n            if(typeof escape == \"number\"){\n                escape = {\n                    ord: escape,\n                    length: 2,\n                    toString: function(){\n                        return chr(escape)\n                    }\n                }\n            }\n            if(escape.type == \"num\"){\n                // [\\9] is invalid\n                fail(\"bad escape 1 \\\\\" +\n                    escape.value.toString()[0], pos)\n            }\n            result.items.push(escape)\n            positions.push(pos)\n            if(range){\n                check_character_range(result.items, positions)\n            }\n            range = false\n            pos += escape.length\n        }else if(char == '-'){\n            // Character range, or character \"-\"\n            if(pos == start + 1 ||\n                    (result.neg && pos == start + 2) ||\n                    pos == text.length - 1 ||\n                    range ||\n                    (result.items.length > 0 &&\n                    result.items[result.items.length - 1].type ==\n                        \"character_range\")){\n                result.items.push({\n                    ord: cp,\n                    char,\n                    toString: function(){\n                        return this.char\n                    }\n                })\n                if(text[pos + 1] == cp){\n                    warn(_b_.FutureWarning, \"Possible set difference\", pos)\n                }\n                pos++\n                if(range){\n                    check_character_range(result.items, positions)\n                }\n                range = false\n            }else{\n                range = true\n                if(text[pos + 1] == cp){\n                    warn(_b_.FutureWarning, \"Possible set difference\", pos)\n                }\n                pos++\n            }\n        }else{\n            positions.push(pos)\n            result.items.push({\n                ord: cp,\n                char,\n                toString: function(){\n                    return this.char\n                }\n            })\n            if(range){\n                check_character_range(result.items, positions)\n            }\n            range = false\n            // FutureWarning for consecutive \"&\", \"|\" or \"~\"\n            if(char == \"&\" && text[pos + 1] == cp){\n                warn(_b_.FutureWarning, \"Possible set intersection\", pos)\n            }else if(char == \"|\" && text[pos + 1] == cp){\n                warn(_b_.FutureWarning, \"Possible set union\", pos)\n            }else if(char == \"~\" && text[pos + 1] == cp){\n                warn(_b_.FutureWarning, \"Possible set symmetric difference\",\n                    pos)\n            }\n            pos++\n        }\n    }\n    fail(\"unterminated character set\", start)\n}\n\nfunction open_unicode_db(){\n    if($B.unicodedb === undefined){\n        var xhr = new XMLHttpRequest\n        xhr.open(\"GET\",\n            $B.brython_path + \"unicode.txt?\" + (new Date()).getTime(), false)\n        xhr.onreadystatechange = function(){\n            if(this.readyState == 4){\n                if(this.status == 200){\n                    $B.unicodedb = this.responseText\n                }else{\n                    console.log(\n                        \"Warning - could not load unicode.txt\")\n                }\n            }\n        }\n        xhr.send()\n    }\n}\n\nfunction validate_named_char(description){\n    // validate that \\N{<description>} is in the Unicode db\n    // Load unicode table if not already loaded\n    if(description.length == 0){\n        fail(\"missing character name\")\n    }\n    open_unicode_db()\n    if($B.unicodedb !== undefined){\n        var re = new RegExp(\"^([0-9A-F]+);\" +\n            description.toUpperCase() + \";.*$\", \"m\")\n        search = re.exec($B.unicodedb)\n        if(search === null){\n            fail(`undefined character name '${description}'`)\n        }\n        return eval(\"0x\" + search[1])\n    }else{\n        fail(\"could not load unicode.txt\")\n    }\n}\n\nvar cache = new Map()\n\nfunction compile(pattern, flags){\n    // data has attributes \"pattern\" (instance of StringObj)\n    // and \"type\" (\"str\" or \"bytes\")\n    if(pattern.__class__ === BPattern){\n        if(flags !== no_flag){\n            throw _b_.ValueError.$factory(\"no flags\")\n        }\n        return pattern\n    }\n    if(cache.has(pattern.py_obj)){\n        if(cache.get(pattern.py_obj).has(flags.value || 0)){\n            return cache.get(pattern.py_obj).get(flags.value || 0)\n        }\n    }\n    var original_pattern = pattern,\n        original_flags = flags,\n        type = pattern.type,\n        choices\n    pattern = pattern.codepoints\n    var is_bytes = type !== \"str\"\n    if(is_bytes && flags && (flags.value & U.value)){\n        throw _b_.ValueError.$factory(\"cannot use UNICODE flag with \" +\n            \"a bytes pattern\")\n    }\n    if(flags && (flags.value & U.value) &&\n            (flags.value & ASCII.value)){\n        throw _b_.ValueError.$factory(\"ASCII and UNICODE flags \" +\n            \"are incompatible\")\n    }\n    if(is_bytes){\n        // bytes patterns ignore re.ASCII flag\n        flags = Flag.$factory(flags.value || 0)\n        //flags.value &= ~ASCII.value\n    }\n    var group_num = 0,\n        group_stack = [],\n        groups = {},\n        pos,\n        lookbehind,\n        node = new Node(),\n        accept_inline_flag = true,\n        verbose = (flags.value || 0) & VERBOSE.value\n    node.$groups = groups\n    for(var item of tokenize(pattern, type, verbose)){\n        item.flags = flags\n        item.is_bytes = is_bytes\n        if(lookbehind){\n            item.lookbehind = lookbehind\n            lookbehind.parent = item\n            lookbehind = false\n        }\n        if(item instanceof Group){\n            group_stack.push(item)\n            node.add(item)\n            item.state = \"open\"\n            group_num++\n            item.num = group_num\n            node = item // next items will be stored as group's items\n            pos = item.pos\n            if(item.non_capturing){\n                delete item.num\n                group_num--\n            }else if(item.type == \"name_def\"){\n                var value = item.value\n                validate(value)\n                if(groups[value.string] !== undefined){\n                    fail(`redefinition of group name` +\n                        ` '${value.string}' as group ${group_num}; was group` +\n                        ` ${groups[value.string].num}`, pos)\n                }\n                item.name = value.string\n                groups[value.string] = groups[group_num] =\n                    new GroupRef(group_num, item)\n            }else if(item.is_lookahead){\n                // a lookahead assertion is relative to the previous regexp\n                group_num--\n                while(node.items.length > 0){\n                    item.add(node.items.shift())\n                }\n                node = item\n            }else if(item.is_lookbehind){\n                // a lookbehind assertion is relative to the next regexp\n                node.parent.items.pop() // remove from node items\n                // temporarily create a group\n                groups[group_num] = new GroupRef(group_num, item)\n            }else if(item.type == \"flags\"){\n                // save flags before a group with inline flags, eg \"(?i:a)\"\n                item.flags_before = Flag.$factory(flags.value | 0)\n            }else{\n                groups[group_num] = new GroupRef(group_num, item)\n            }\n        }else if(item instanceof GroupEnd){\n            end_pos = item.pos\n            if(group_stack.length == 0){\n                fail(\"unbalanced parenthesis\", end_pos, original_pattern)\n            }\n            var item = group_stack.pop()\n            item.end_pos = end_pos\n            try{\n                item.pattern = from_codepoint_list(\n                    pattern.slice(item.pos, end_pos + 1))\n            }catch(err){\n                console.log(\"err avec pattern substring\", pattern)\n                throw err\n            }\n            if(item.is_lookbehind){\n                delete groups[group_num]\n                group_num--\n                // check that all elements have a fixed length\n                item.length = item.fixed_length()\n                if(item.length === false){\n                    fail(\"look-behind requires fixed-width pattern\", pos)\n                }\n                item.parent.add(new Lookbehind(item))\n                item.non_capturing = true\n                // store in variable \"lookbehind\", will be applied to next item\n                lookbehind = item\n            }else if(item.is_lookahead){\n                delete item.num\n            }\n            if(item instanceof Group && item.items.length == 0){\n                item.add(new Char(pos, EmptyString, group_stack.concat([item])))\n            }else if(item instanceof ConditionalBackref){\n                if(item.re_if_exists.items.length == 0){\n                    item.re_if_exists.add(EmptyString)\n                }else if(item.re_if_not_exists.items.length == 0){\n                    item.re_if_not_exists.pos = pos\n                    item.re_if_not_exists.add(EmptyString)\n                }\n            }else if(item.type == \"flags\"){\n                // restore flags when entering the group\n                flags = Flag.$factory(item.flags_before.value)\n            }\n            item.state = 'closed'\n            node = item.parent\n        }else if(item instanceof ConditionalBackref){\n            var pos = item.pos,\n                group_ref = item.group_ref\n            if(typeof group_ref == \"number\"){\n                if(group_ref == 0){\n                    fail(`bad group number`, pos + 3)\n                }else if(group_ref >= MAXGROUPS){\n                    fail(`invalid group reference ${group_ref}`, pos + 1)\n                }else if(groups[group_ref] &&\n                        groups[group_ref].item.state == \"open\"){\n                    fail(\"cannot refer to an open group\", pos)\n                }\n            }else if(groups[group_ref] !== undefined){\n                if(groups[group_ref].item.state == \"open\"){\n                    fail(\"cannot refer to an open group\", pos)\n                }\n            }else{\n                fail(`unknown group name '${group_ref}'`, pos)\n            }\n            group_stack.push(item)\n            node.add(item)\n            item.state = \"open\"\n            node = item // next items will be stored as group's items\n        }else if(item instanceof BackReference){\n            pos = item.pos\n            if(item.type == \"num\" && item.value > 99){\n                var head = item.value.toString().substr(0, 2)\n                fail(`invalid group reference ${head}`, pos + 1)\n            }\n            if(groups[item.value] !== undefined){\n                if(groups[item.value].item.state == \"open\"){\n                    fail(\"cannot refer to an open group\", pos)\n                }\n                var ref_item = groups[item.value].item.parent\n                while(ref_item){\n                    if(ref_item.is_lookbehind){\n                        fail(\"cannot refer to group defined in the same lookbehind subpattern\", pos)\n                    }\n                    ref_item = ref_item.parent\n                }\n            }else if(item.type == \"name\"){\n                fail(`unknown group name '${item.value}'`, pos)\n            }else if(item.type == \"num\"){\n                fail(`invalid group reference ${item.value}`, pos)\n            }\n            node.add(item)\n        }else if(item instanceof Char ||\n                item instanceof CharacterClass ||\n                item instanceof CharacterSet){\n            if(item instanceof CharacterSet){\n                for(var elt of item.set.items){\n                    elt.flags = flags\n                }\n            }\n            var added_to_charseq = false\n            if(item instanceof Char){\n                if(node.items && node.items.length > 0){\n                    var previous = $last(node.items)\n                    if(previous instanceof CharSeq){\n                        previous.chars.push(item)\n                        added_to_charseq = true\n                    }else if(previous instanceof Char){\n                        node.items.pop()\n                        node.items.push(new CharSeq([previous, item]))\n                        added_to_charseq = true\n                    }\n                }\n            }\n            if(! added_to_charseq){\n                node.add(item)\n            }\n        }else if(item instanceof Repeater){\n            // check that item is not in a lookbehind group\n            var pnode = node\n            while(pnode){\n                if(pnode.extension && pnode.extension.type &&\n                        pnode.extension.type.indexOf(\"lookbehind\") > -1){\n                    fail(\"look-behind requires fixed-width pattern\", pos)\n                }\n                pnode = pnode.parent\n            }\n            pos = item.pos\n            if(node.items.length == 0){\n                fail(\"nothing to repeat\", pos)\n            }\n            previous = $last(node.items)\n            if(previous instanceof Char ||\n                    previous instanceof CharSeq ||\n                    previous instanceof CharacterClass ||\n                    previous instanceof CharacterSet ||\n                    previous instanceof Group ||\n                    previous instanceof BackReference){\n                if(previous instanceof GroupEnd){\n                    // associate repeat with Group\n                    previous = previous.group\n                }else if(previous instanceof CharSeq){\n                    previous = $last(previous.chars)\n                }\n                if(previous.repeater){\n                    if(item.op == '?' && ! previous.non_greedy){\n                        previous.non_greedy = true\n                        if(previous instanceof CharacterClass &&\n                                previous.value == '.'){\n                            previous.min_repeat_one = true\n                        }\n                    }else{\n                        fail(\"multiple repeat\", pos)\n                    }\n                }else{\n                    // convert to minimum and maximum number of repeats\n                    var min = 1,\n                        max = 1\n                    if(Array.isArray(item.op)){\n                        min = item.op[0]\n                        if(min >= MAXREPEAT){\n                            throw _b_.OverflowError.$factory(\n                                \"the repetition number is too large\")\n                        }\n                        max = item.op[1] === undefined ? min : item.op[1]\n                        if(isFinite(max) && max >= MAXREPEAT){\n                            throw _b_.OverflowError.$factory(\n                                \"the repetition number is too large\")\n                        }\n                        if(max < min){\n                            fail('min repeat greater than max repeat', pos)\n                        }\n                    }else if(item.op == \"?\"){\n                        min = 0\n                        max = 1\n                    }else if(item.op == \"*\"){\n                        min = 0\n                        max = Number.POSITIVE_INFINITY\n                    }else if(item.op == \"+\"){\n                        min = 1\n                        max = Number.POSITIVE_INFINITY\n                    }\n                    previous.repeater = item\n                    previous.repeat = {min, max}\n                    // mark all parents of item as no fixed length\n                    var parent = item\n                    while(parent){\n                        parent.fixed_length = false\n                        parent = parent.parent\n                    }\n                }\n            }else{\n                fail(\"nothing to repeat\", pos)\n            }\n        }else if(item instanceof Or){\n            if(group_stack.length > 0){\n                item.group = group_stack[group_stack.length - 1]\n            }else{\n                item.group = false\n            }\n            pos = item.pos\n            if(node instanceof ConditionalBackref){\n                // case '(?(num)a|'\n                if(node.nb_options == 1){\n                    node.nb_options++\n                }else{\n                    fail('conditional backref with more than ' +\n                       'two branches', pos)\n                }\n            }else if(node.items.length == 0){\n                // token \"|\" in  \"(|...)\" : first option is the empty string\n                var choice = new Choice(),\n                    case1 = new Case()\n                case1.add(new Char(pos, EmptyString))\n                choice.add(case1)\n                node.add(choice)\n                var case2 = new Case()\n                choice.add(case2)\n                node = case2\n            }else if(node instanceof Case){\n                // node.parent is already a Choice\n                var new_case = new Case()\n                node.parent.add(new_case)\n                node = new_case\n            }else{\n                // token \"|\" in \"(ab|...)\"\n                var previous = node.items[node.items.length - 1]\n                if(previous instanceof Case){\n                    var new_case = new Case()\n                    previous.add(new_case)\n                    node = new_case\n                }else{\n                    var choice = new Choice(),\n                        case1 = new Case(),\n                        first_rank = node.items[0].rank\n                    while(node.items.length > 0){\n                        case1.add(node.items.shift())\n                    }\n                    case1.groups = node.$groups\n                    for(var group of group_stack){\n                        choice.groups.push(group)\n                    }\n                    choice.add(case1)\n                    node.add(choice)\n                    var case2 = new Case()\n                    choice.add(case2)\n                    node = case2\n                }\n            }\n        }else if(item instanceof StringStart ||\n                 item instanceof StringEnd){\n            node.add(item)\n        }else if(item instanceof SetFlags){\n            // copy flags, otherwise re.ASCII etc might be modified\n            flags = Flag.$factory(flags.value || U.value)\n            if(item.on_flags.indexOf('u') > -1){\n                if(is_bytes){\n                    fail(\"re.error: bad inline flags: cannot use 'u' flag \" +\n                        \"with a bytes pattern\", pos)\n                }\n                if(flags && flags.value & ASCII.value){\n                    // switch to Unicode\n                    flags.value ^= ASCII.value\n                }\n                if(group_stack.length == 0 &&\n                        original_flags && original_flags.value & ASCII.value){\n                    throw _b_.ValueError.$factory(\"ASCII and UNICODE flags \" +\n                        \"are incompatible\")\n                }\n                if(item.on_flags.indexOf('a') > -1){\n                    throw _b_.ValueError.$factory(\"ASCII and UNICODE flags \" +\n                        \"are incompatible\")\n                }\n            }else if(item.on_flags.indexOf('a') > -1){\n                if(group_stack.length == 0 &&\n                        original_flags && original_flags.value & U.value){\n                    throw _b_.ValueError.$factory(\"ASCII and UNICODE flags \" +\n                        \"are incompatible\")\n                }\n                if(flags && flags.value & U.value){\n                    // switch to ASCII\n                    flags.value ^= U.value\n                }\n                if(item.on_flags.indexOf('u') > -1){\n                    throw _b_.ValueError.$factory(\"ASCII and UNICODE flags \" +\n                        \"are incompatible\")\n                }\n            }\n            if(flags.value === undefined){\n                flags.value = 32\n            }\n            if(item.items.length == 0){\n                if(! accept_inline_flag && group_stack.length == 0){\n                    var s = from_codepoint_list(pattern)\n                    warn(_b_.DeprecationWarning,\n                        `Flags not at the start of the expression '${s}'`,\n                        pos)\n                }\n                for(var on_flag of item.on_flags){\n                    if(! is_bytes || on_flag !== 'a'){\n                        flags.value |= inline_flags[on_flag].value\n                    }\n                }\n                for(var off_flag of item.off_flags){\n                    if(! is_bytes || off_flag !== 'a'){\n                        flags.value ^= inline_flags[off_flag].value\n                    }\n                }\n            }else{\n                node.add(item)\n            }\n        }else{\n            fail(\"unknown item type \" + item, pos)\n        }\n        if(! (item instanceof SetFlags) &&\n                ! (item instanceof Group && item.type == \"flags\")){\n            accept_inline_flag = false\n        }\n    }\n    if(group_stack.length > 0){\n        var last = group_stack[group_stack.length - 1]\n        fail(\"missing ), unterminated subpattern\", last.pos)\n    }\n    while(node.parent){\n        node = node.parent\n    }\n    node.pattern = from_codepoint_list(pattern)\n    node.groups = group_num\n    flags = flags === no_flag ? 32 : flags\n    node.flags = flags\n    var res = {\n        node,\n        groups,\n        flags,\n        original_flags,\n        text: from_codepoint_list(pattern),\n        type, // \"str\" or \"bytes\"\n        fixed_length: node.fixed_length()\n    }\n    if(! cache.has(original_pattern.py_obj)){\n        cache.set(original_pattern.py_obj, new Map())\n    }\n    cache.get(original_pattern.py_obj).set(original_flags.value || 0, res)\n    show(node)\n    return res\n}\n\nfunction show(node, indent){\n    indent = indent === undefined ? 0 : indent\n    if(indent == 0){\n        log('root', node)\n    }\n    log(' '.repeat(indent) + node)\n    if(node.items !== undefined){\n        for(var item of node.items){\n            show(item, indent + 1)\n        }\n    }\n}\n\nfunction ord(char){\n    return char.charCodeAt(0)\n}\n\nfunction* tokenize(pattern, type, _verbose){\n    // pattern is a list of codepoints\n    var is_bytes = type == \"bytes\"\n    // verbose_stack is the stack of verbose state for each group in the regex\n    var verbose_stack = [_verbose],\n        verbose = _verbose\n    var pos = 0\n    while(pos < pattern.length){\n        var cp = pattern[pos],\n            char = String.fromCharCode(cp)\n        if(verbose){\n            // current group is in verbose mode\n            if(char == \"#\"){\n                // skip until next line feed\n                while(pos < pattern.length && pattern[pos] != 10){\n                    pos++\n                }\n                pos++\n                continue\n            }else{\n                while(pos < pattern.length &&\n                        [9, 10, 11, 12, 13, 32].indexOf(pattern[pos]) > -1){\n                    pos++\n                }\n            }\n            cp = pattern[pos]\n            if(cp === undefined){\n                break\n            }\n            char = String.fromCharCode(cp)\n            if(char == '#'){\n                continue\n            }\n        }\n        if(char == '('){\n            if(pattern[pos + 1] == ord('?')){\n                if(pattern[pos + 2] == ord('P')){\n                    if(pattern[pos + 3] == ord('<')){\n                        var name = [],\n                            i = pos + 4\n                        while(i < pattern.length){\n                            if(pattern[i] == ord('>')){\n                                break\n                            }else if(pattern[i] == ord(')')){\n                                fail(\"missing >, unterminated name\", pos)\n                            }\n                            name.push(pattern[i])\n                            i++\n                        }\n                        name = StringObj.from_codepoints(name)\n                        validate(name)\n                        if(i == pattern.length){\n                            fail(\"missing >, unterminated name\", pos)\n                        }\n                        yield new Group(pos, {type: 'name_def', value: name})\n                        verbose_stack.push(verbose)\n                        pos = i + 1\n                        continue\n                    }else if(pattern[pos + 3] == ord('=')){\n                        var name = [],\n                            i = pos + 4\n                        while(i < pattern.length){\n                            if(pattern[i] == ord(')')){\n                                break\n                            }\n                            name.push(pattern[i])\n                            i++\n                        }\n                        name = StringObj.from_codepoints(name)\n                        validate(name)\n                        if(i == pattern.length){\n                            fail(\"missing ), unterminated name\", pos)\n                        }\n                        yield new BackReference(pos, 'name', name.string)\n                        pos = i + 1\n                        continue\n                    }else if(pattern[pos + 3] === undefined){\n                        fail(\"unexpected end of pattern\", pos)\n                    }else{\n                        fail(\"unknown extension ?P\" + chr(pattern[pos + 3]), pos)\n                    }\n                }else if(pattern[pos + 2] == ord('(')){\n                    var ref = [],\n                        i = pos + 3\n                    while(i < pattern.length){\n                        if(pattern[i] == ord(')')){\n                            break\n                        }\n                        ref.push(pattern[i])\n                        i++\n                    }\n                    var sref = StringObj.from_codepoints(ref)\n                    if(sref.string.match(/^\\d+$/)){\n                        ref = parseInt(sref.string)\n                    }else{\n                        validate(sref)\n                        ref = sref.string\n                    }\n                    if(i == pattern.length){\n                        fail(\"missing ), unterminated name\", pos)\n                    }\n                    yield new ConditionalBackref(pos, ref)\n                    pos = i + 1\n                    continue\n                }else if(pattern[pos + 2] == ord('=')){\n                    // (?=...) : lookahead assertion\n                    yield new Group(pos, {type: 'lookahead_assertion'})\n                    verbose_stack.push(verbose)\n                    pos += 3\n                    continue\n                }else if(pattern[pos + 2] == ord('!')){\n                    // (?!...) : negative lookahead assertion\n                    yield new Group(pos, {type: 'negative_lookahead_assertion'})\n                    verbose_stack.push(verbose)\n                    pos += 3\n                    continue\n                }else if(from_codepoint_list(pattern.slice(pos + 2, pos + 4)) == '<!'){\n                    // (?<!...) : negative lookbehind\n                    yield new Group(pos, {type: 'negative_lookbehind'})\n                    verbose_stack.push(verbose)\n                    pos += 4\n                    continue\n                }else if(from_codepoint_list(pattern.slice(pos + 2, pos + 4)) == '<='){\n                    // (?<=...) : positive lookbehind\n                    yield new Group(pos, {type: 'positive_lookbehind'})\n                    verbose_stack.push(verbose)\n                    pos += 4\n                    continue\n                }else if(pattern[pos + 2] == ord('<')){\n                    pos += 3\n                    if(pos == pattern.length){\n                        fail(\"unexpected end of pattern\", pos)\n                    }\n                    fail(\"unknown extension ?<\" + _b_.chr(pattern[pos]), pos)\n                }else if(pattern[pos + 2] == ord(':')){\n                    yield new Group(pos, {non_capturing: true})\n                    verbose_stack.push(verbose)\n                    pos += 3\n                    continue\n                }else if(pattern[pos + 2] === undefined){\n                    fail(\"unexpected end of pattern\", pos)\n                }\n\n                var flags = to_codepoint_list('aiLmsux'),\n                    auL_flags = to_codepoint_list('auL'),\n                    flags_start = pos\n                if(pattern[pos + 2] == ord('-') ||\n                        flags.indexOf(pattern[pos + 2]) > -1){\n                    if(pattern[pos + 2] == ord('-')){\n                        var on_flags = [],\n                            has_off = true,\n                            off_flags = []\n                        pos += 3\n                    }else{\n                        var on_flags = [chr(pattern[pos + 2])],\n                            has_off = false,\n                            off_flags = [],\n                            auL = auL_flags.indexOf(pattern[pos + 2]) > -1 ?\n                                1 : 0,\n                            closed = false\n                        pos += 3\n                        while(pos < pattern.length){\n                            if(flags.indexOf(pattern[pos]) > -1){\n                                if(auL_flags.indexOf(pattern[pos]) > -1){\n                                    auL++\n                                    if(auL > 1){\n                                        fail(\"bad inline flags: flags 'a', 'u'\" +\n                                            \" and 'L' are incompatible\", pos)\n                                    }\n                                }\n                                on_flags.push(chr(pattern[pos]))\n                                pos++\n                            }else if(pattern[pos] == ord('-')){\n                                has_off = true\n                                closed = true\n                                pos++\n                                break\n                            }else if(String.fromCharCode(pattern[pos]).\n                                    match(/[a-zA-Z]/)){\n                                fail(\"unknown flag\", pos)\n                            }else if(pattern[pos] == ord(')')){\n                                closed = true\n                                break\n                            }else if(pattern[pos] == ord(':')){\n                                yield new Group(pos, {name: \"Group\", type: \"flags\"})\n                                verbose_stack.push(verbose)\n                                closed = true\n                                break\n                            }else{\n                                fail(\"missing -, : or )\", pos)\n                            }\n                        }\n                        if(! closed){\n                            fail(\"missing -, : or )\", pos)\n                        }\n                    }\n                    if(has_off){\n                        while(pos < pattern.length){\n                            if(flags.indexOf(pattern[pos]) > -1){\n                                if(auL_flags.indexOf(pattern[pos]) > -1){\n                                    fail(\"bad inline flags: cannot turn off \" +\n                                        \"flags 'a', 'u' and 'L'\", pos)\n                                }\n                                if(on_flags.indexOf(chr(pattern[pos])) > -1){\n                                    fail(\"bad inline flags: flag turned on and off\", pos)\n                                }\n                                off_flags.push(chr(pattern[pos]))\n                                pos++\n                            }else if(pattern[pos] == ord(':')){\n                                yield new Group(pos, {name: \"Group\", type: \"flags\"})\n                                verbose_stack.push(verbose)\n                                break\n                            }else if(String.fromCharCode(pattern[pos]).\n                                    match(/[a-zA-Z]/)){\n                                fail(\"unknown flag\", pos)\n                            }else if(off_flags.length == 0){\n                                fail(\"missing flag\", pos)\n                            }else{\n                                fail(\"missing :\", pos)\n                            }\n                        }\n                        if(off_flags.length == 0){\n                            fail(\"missing flag\", pos)\n                        }\n                    }\n                    if(has_off && pattern[pos] != ord(':')){\n                        fail(\"missing :\", pos)\n                    }\n                    if(on_flags.length == 0 && off_flags.length == 0){\n                        fail(\"missing flag\", pos)\n                    }\n                    var set_flags = new SetFlags(flags_start,\n                        {on_flags, off_flags})\n                    yield set_flags\n                    // reset verbose\n                    if(on_flags.indexOf('x') > -1){\n                        verbose = true\n                    }\n                    if(off_flags.indexOf('x') > -1){\n                        verbose = false\n                    }\n                    if(! closed){\n                        node = set_flags\n                    }\n                    pos++\n                }else if(pattern[pos + 2] == ord('#')){\n                    pos += 3\n                    while(pos < pattern.length){\n                        if(pattern[pos] == ord(')')){\n                            break\n                        }\n                        pos++\n                    }\n                    if(pos == pattern.length){\n                        fail(\"missing ), unterminated comment\", pos)\n                    }\n                    pos++\n                    continue\n                }else{\n                    fail(\"unknown extension ?\" + _b_.chr(pattern[pos + 2]),\n                        pos)\n                }\n            }else{\n                yield new Group(pos)\n                verbose_stack.push(verbose)\n                pos++\n            }\n        }else if(cp == ord(')')){\n            yield new GroupEnd(pos)\n            verbose_stack.pop()\n            verbose = $last(verbose_stack)\n            pos++\n        }else if(cp == ord('\\\\')){\n            var escape = escaped_char({codepoints: pattern, pos, is_bytes})\n            if(escape instanceof CharacterClass){\n                yield escape\n                pos += escape.length\n            }else if(escape.char !== undefined){\n                yield new Char(pos, escape.ord)\n                pos += escape.length\n            }else if(escape.type == \"backref\"){\n                yield new BackReference(pos, \"num\", escape.value)\n                pos += escape.length\n            }else if(typeof escape == \"number\"){\n                // eg \"\\.\"\n                var esc = new Char(pos, escape)\n                esc.escaped = true\n                yield esc\n                pos += 2\n            }else{\n                yield new Char(pos, escape)\n                pos += escape.length\n            }\n        }else if(cp == ord('[')){\n            // Set of characters\n            var set,\n                end_pos\n            [set, end_pos] = parse_character_set(pattern, pos, is_bytes)\n            yield new CharacterSet(pos, set)\n            pos = end_pos + 1\n        }else if('+?*'.indexOf(char) > -1){\n            yield new Repeater(pos, char)\n            pos++\n        }else if(cp == ord('{')){\n            var reps = /\\{(\\d*)((,)(\\d*))?\\}/.exec(\n                    from_codepoint_list(pattern.slice(pos)))\n            if(reps && reps[0] != '{}'){\n                if(reps[1] == \"\"){\n                    var limits = [0]\n                }else{\n                    var limits = [parseInt(reps[1])]\n                }\n                if(reps[4] !== undefined){\n                    if(reps[4] == \"\"){\n                        var max = Number.POSITIVE_INFINITY\n                    }else{\n                        var max = parseInt(reps[4])\n                    }\n                    limits.push(max)\n                }\n                yield new Repeater(pos, limits)\n                pos += reps[0].length\n            }else if(pattern[pos + 1] == ord('}')){\n                // {} is the characters \"{\" and \"}\"\n                yield new Char(pos, ord('{'))\n                pos++\n            }else{\n                yield new Char(pos, ord('{'))\n                pos++\n            }\n        }else if(cp == ord('|')){\n            yield new Or(pos)\n            pos++\n        }else if(cp == ord('.')){\n            yield new CharacterClass(pos, cp, 1)\n            pos++\n        }else if(cp == ord('^')){\n            yield new StringStart(pos)\n            pos++\n        }else if(cp == ord('$')){\n            yield new StringEnd(pos)\n            pos++\n        }else{\n            yield new Char(pos, cp)\n            pos++\n        }\n    }\n}\n\nfunction to_codepoint_list(s){\n    var items = []\n    if(typeof s == \"string\" || _b_.isinstance(s, _b_.str)){\n        if(typeof s != \"string\"){\n            s = s.valueOf()\n        }\n        for(const char of s){\n            items.push(char.codePointAt(0))\n        }\n        items.type = \"unicode\"\n    }else if(_b_.isinstance(s, bytes_like)){\n        if(_b_.isinstance(s, _b_.memoryview)){\n            items = s.obj.source\n        }else{\n            items = s.source\n        }\n        items.type = \"bytes\"\n    }else{\n        throw Error('invalid type ' + $B.class_name(s))\n    }\n    return items\n}\n\nfunction from_codepoint_list(codepoints, type){\n    // Return a string\n    if(type == \"bytes\"){\n        return _b_.bytes.$factory(codepoints)\n    }\n    var s = ''\n    for(const cp of codepoints){\n        s += _b_.chr(cp)\n    }\n    return s\n}\n\nvar GroupDict = $B.make_class(\"GroupDict\")\nGroupDict.__mro__ = [_b_.dict, _b_.object]\nGroupDict.__setitem__ = function(){\n    throw _b_.TypeError.$factory(\"read only\")\n}\n\n\nvar bytes_like = [_b_.bytes, _b_.bytearray, _b_.memoryview]\n\nfunction string2bytes(s){\n    var t = []\n    for(var i = 0, len = s.length; i < len; i++){\n        t.push(s.charCodeAt(i))\n    }\n    return _b_.bytes.$factory(t)\n}\n\nfunction check_pattern_flags(pattern, flags){\n    if(pattern.__class__ === BPattern){\n        if(flags !== no_flag){\n            throw _b_.ValueError.$factory(\n                \"cannot process flags argument with a compiled pattern\")\n        }\n    }\n    return pattern\n}\n\nfunction transform_repl(data, pattern){\n    // data.repl is a StringObj instance\n    var repl = data.repl.string\n    repl = repl.replace(/\\\\n/g, '\\n')\n    repl = repl.replace(/\\\\r/g, '\\r')\n    repl = repl.replace(/\\\\t/g, '\\t')\n    repl = repl.replace(/\\\\b/g, '\\b')\n    repl = repl.replace(/\\\\v/g, '\\v')\n    repl = repl.replace(/\\\\f/g, '\\f')\n    repl = repl.replace(/\\\\a/g, '\\a')\n    // detect backreferences\n    var pos = 0,\n        escaped = false,\n        br = false,\n        repl1 = \"\",\n        has_backref = false\n    while(pos < repl.length){\n        br = false\n        if(repl[pos] == \"\\\\\"){\n            escaped = ! escaped\n            if(escaped){\n                pos++\n                continue\n            }\n        }else if(escaped){\n            escaped = false\n            var mo = /^\\d+/.exec(repl.substr(pos))\n            if(mo){\n                var cps = to_codepoint_list(repl)\n                var escape = escaped_char({\n                        codepoints: cps,\n                        pos: pos - 1,\n                        is_bytes: cps.type == \"bytes\"\n                     })\n                if(escape.type == \"o\"){\n                    if(escape.ord > 0o377){\n                        fail(`octal escape value \\\\${mo[0]} ` +\n                            \" outside of range 0-0o377\", pos)\n                    }\n                    repl1 += escape.char\n                    pos += escape.length - 1\n                    continue\n                }else if(escape.type != \"backref\"){\n                    var group_num = mo[0].substr(0,\n                        Math.min(2, mo[0].length))\n                    fail(`invalid group reference ${group_num}`, pos)\n                }else{\n                    // only keep first 2 digits\n                    var group_num = mo[0].substr(0,\n                        Math.min(2, mo[0].length))\n                    // check that pattern has the specified group num\n                    if(pattern.groups === undefined){\n                        console.log(\"pattern\", pattern)\n                        throw _b_.AttributeError.$factory(\"$groups\")\n                    }\n                    if(pattern.groups[group_num] === undefined){\n                        fail(`invalid group reference ${group_num}`,\n                            pos)\n                    }else{\n                        mo[0] = group_num\n                    }\n                }\n                if(! has_backref){\n                    var parts = [repl.substr(0, pos - 1),\n                            parseInt(mo[0])]\n                }else{\n                    parts.push(repl.substring(next_pos, pos - 1))\n                    parts.push(parseInt(mo[0]))\n                }\n                has_backref = true\n                var next_pos = pos + mo[0].length\n                br = true\n                pos += mo[0].length\n            }else if(repl[pos] == \"g\"){\n                pos++\n                if(repl[pos] != '<'){\n                    fail(\"missing <\", pos)\n                }\n                pos++\n                mo = /(.*?)>/.exec(repl.substr(pos))\n                if(mo){\n                    if(mo[1] == \"\"){\n                        pos += mo[0].length\n                        fail(\"missing group name\", pos - 1)\n                    }\n                    var group_name = mo[1]\n                    if(/^\\d+$/.exec(group_name)){\n                        if(pattern.groups[group_name] === undefined){\n                            fail(`invalid group reference ${group_name}`,\n                                pos)\n                        }\n                    }else{\n                        if(! _b_.str.isidentifier(group_name)){\n                            var cps = to_codepoint_list(group_name)\n                            if($B.unicode_tables.XID_Start[cps[0]] === undefined){\n                                fail(\"bad character in group name '\" +\n                                    group_name + \"'\", pos)\n                            }else{\n                                for(cp of cps.slice(1)){\n                                    if($B.unicode_tables.XID_Continue[cp] === undefined){\n                                        fail(\"bad character in group name '\" +\n                                            group_name + \"'\", pos)\n                                    }\n                                }\n                            }\n                        }\n                        if(pattern.groups[group_name] === undefined){\n                            throw _b_.IndexError.$factory(\n                                `unknown group name '${group_name}'`,\n                                pos)\n                        }\n                    }\n                    if(! has_backref){\n                        var parts = [repl.substr(0, pos - 3),\n                                mo[1]]\n                    }else{\n                        parts.push(repl.substring(next_pos, pos - 3))\n                        parts.push(mo[1])\n                    }\n                    has_backref = true\n                    var next_pos = pos + mo[0].length\n                    br = true\n                    pos = next_pos\n                }else{\n                    if(repl.substr(pos).length > 0){\n                        fail(\"missing >, unterminated name\", pos)\n                    }else{\n                        fail(\"missing group name\", pos)\n                    }\n                }\n            }else{\n                if(/[a-zA-Z]/.exec(repl[pos])){\n                    fail(\"unknown escape\", pos)\n                }\n                pos += repl[pos]\n            }\n        }\n        if(! br){\n            repl1 += repl[pos]\n            pos ++\n        }\n    }\n    data.repl1 = repl1\n    if(has_backref){\n        parts.push(repl.substr(next_pos))\n        data.repl = function(bmo){\n            var mo = bmo.mo,\n                res = parts[0],\n                groups = mo.$groups,\n                s = mo.string,\n                group\n            for(var i = 1, len = parts.length; i < len; i += 2){\n                if(groups[parts[i]] === undefined){\n                    if(mo.node.$groups[parts[i]] !== undefined){\n                        // group is defined in the RE, but didn't contribute\n                        // to the match\n                        // groups[parts[i]] = ''\n                    }else{\n                        // group is not defined in the RE\n                        pos++\n                        group_num = parts[i].toString().substr(0, 2)\n                        fail(`invalid group reference ${group_num}`, pos)\n                    }\n                }else{\n                    group = groups[parts[i]]\n                    res += s.substring(group.start, group.end)\n                }\n                res += parts[i + 1]\n            }\n            return res\n        }\n    }else{\n        data.repl = new StringObj(repl)\n    }\n    return data\n}\n\nfunction StringObj(obj){\n    // A StringObj object is a bridge between a Python string or bytes-like\n    // object and Javascript\n    // obj is the Python object\n    // this.string is a Javascript string\n    this.py_obj = obj\n    this.codepoints = []\n    this.type = \"str\"\n    if(typeof obj == \"string\"){\n        // Python object represented as a Javascript string\n        this.string = obj\n        for(var i = 0, len = obj.length; i < len; i++){\n            var cp = obj.codePointAt(i)\n            this.codepoints.push(cp)\n            if(cp >= 0x10000){\n                i++\n            }\n        }\n    }else if(_b_.isinstance(obj, _b_.str)){ // str subclass\n        var so = new StringObj(obj.valueOf())\n        this.string = so.string\n        this.codepoints = so.codepoints\n    }else if(_b_.isinstance(obj, [_b_.bytes, _b_.bytearray])){\n        this.string = _b_.bytes.decode(obj, 'latin1')\n        this.codepoints = obj.source\n        this.type = \"bytes\"\n    }else if(_b_.isinstance(obj, _b_.memoryview)){\n        this.string = _b_.bytes.decode(obj.obj, 'latin1')\n        this.codepoints = obj.obj.source\n        this.type = \"bytes\"\n    }else if(obj.__class__ && obj.__class__.$buffer_protocol){\n        // eg array.array\n        this.codepoints = _b_.list.$factory(obj)\n        this.string = from_codepoint_list(this.codepoints, \"bytes\")\n        this.type = \"bytes\"\n    }else if(Array.isArray(obj)){\n        // list of codepoints\n        this.codepoints = obj\n    }else{\n        throw _b_.TypeError.$factory(\n            'expected string or bytes-like object')\n    }\n    this.length = this.codepoints.length\n}\n\nStringObj.prototype.substring = function(start, end){\n    // Returns a string\n    var codepoints,\n        res = ''\n    if(end === undefined){\n        codepoints = this.codepoints.slice(start)\n    }else{\n        codepoints = this.codepoints.slice(start, end)\n    }\n    return from_codepoint_list(codepoints, this.type)\n}\n\nStringObj.prototype.to_str = function(){\n    return from_codepoint_list(this.codepoints, this.type)\n}\n\nStringObj.from_codepoints = function(cps){\n    var res = new StringObj('')\n    res.codepoints = cps\n    for(var cp of cps){\n        res.string += _b_.chr(cp)\n    }\n    return res\n}\n\nfunction prepare(args){\n    // Check that all arguments are of the same type (string of bytes-like)\n    // Return an object with all attributes transformed into CodePoints\n    // instances\n    var res = {},\n        keys = Object.keys(args),\n        first = keys[0]\n    res[first] = new StringObj(args[first])\n    res.type = res[first].type\n    for(var key of keys.slice(1)){\n        res[key] = new StringObj(args[key])\n        if(res[key].type != res.type){\n            throw _b_.TypeError.$factory(`not the same type for ${first} and ${key}`)\n        }\n    }\n    return res\n}\n\nfunction subn(pattern, repl, string, count, flags){\n    // string is a StringObj instance\n    // pattern is either a Pattern instance or a StringObj instance\n    var res = '',\n        pos = 0,\n        nb_sub = 0\n\n    if(pattern instanceof StringObj){\n        pattern = compile(pattern, flags)\n    }\n    if(typeof repl != \"function\"){\n        var data1 = transform_repl({repl}, pattern)\n        repl1 = data1.repl1\n    }\n    pos = 0\n    for(var bmo of $module.finditer(BPattern.$factory(pattern), string.to_str())){\n        // finditer yields instances of BMatchObject\n        var mo = bmo.mo // instance of MatchObject\n        res += from_codepoint_list(string.codepoints.slice(pos, mo.start),\n            string.type)\n        if(typeof repl == \"function\"){\n            res += $B.$call(repl)(bmo)\n        }else{\n            res += repl1\n        }\n        nb_sub++\n        pos = mo.end\n        if(pos >= string.length){\n            break\n        }\n        if(count != 0 && nb_sub >= count){\n            break\n        }\n    }\n    res += from_codepoint_list(string.codepoints.slice(pos),\n        string.type)\n    if(pattern.type === \"bytes\"){\n        res = _b_.str.encode(res, \"latin-1\")\n    }\n    return [res, nb_sub]\n}\n\n// escaped chars : '\\t\\n\\x0b\\x0c\\r #$&()*+-.?[\\\\]^{|}~'\nvar escaped = [9, 10, 11, 12, 13, 32, 35, 36, 38, 40, 41, 42, 43, 45, 46, 63,\n               91, 92, 93, 94, 123, 124, 125, 126]\n\nfunction* iterator(pattern, string, flags, original_string, pos, endpos){\n    var result = [],\n        pos = pos | 0\n    while(pos <= string.length){\n        var mo = match(pattern, string, pos, endpos)\n        if(mo){\n            yield BMO.$factory(mo)\n            if(mo.end == mo.start){\n                // If match has zero with, retry at the same position but\n                // with the flag no_zero_width set, to avoid infinite loops\n                mo = match(pattern, string, pos, endpos, true)\n                if(mo){\n                    yield BMO.$factory(mo)\n                    pos = mo.end\n                }else{\n                    pos++ // at least 1, else infinite loop\n                }\n            }else{\n                pos = mo.end\n            }\n        }else{\n            pos++\n        }\n    }\n    delete original_string.in_iteration\n}\n\nvar _debug = {value: false}\n\nfunction MO(node, pos, mo, len){\n    this.node = node\n    this.start = pos\n    this.mo = mo\n    this.nb_min = mo.nb_min\n    this.nb_max = mo.nb_max\n    this.len = len\n    this.nb = this.node.non_greedy ? mo.nb_min : mo.nb_max\n    this.end = pos + len * this.nb\n}\n\nMO.prototype.backtrack = function(string, groups){\n    if(this.node.non_greedy && this.nb < this.nb_max){\n        this.nb++\n        this.end = this.start + this.len * this.nb\n        return true\n    }else if(! this.node.non_greedy && this.nb > this.nb_min){\n        this.nb--\n        this.end = this.start + this.len * this.nb\n        return true\n    }else{\n        return false\n    }\n}\n\nfunction del_groups(groups, node){\n    if(node.num !== undefined){\n        delete groups[node.num]\n        groups.$last.splice(groups.$last.indexOf(node.num), 1)\n        if(node.name !== undefined){\n            delete groups[node.name]\n        }\n    }\n    for(var child of node.items){\n        if(child instanceof Group){\n            del_groups(groups, child)\n        }\n    }\n}\n\nfunction GroupMO(node, start, matches, string, groups, endpos){\n    this.node = node\n    this.start = start\n    this.matches = matches\n    this.string = string\n    this.end = matches.length > 0 ? $last(matches).end : start\n    this.endpos = endpos === undefined ? this.end : endpos\n    this.$groups = groups\n}\n\nGroupMO.prototype.backtrack = function(string, groups){\n    // Try backtracking in the last match\n    if(this.matches.length > 0){\n        var match = $last(this.matches),\n            mos = match.mos,\n            nb0 = mos.length\n        while(mos.length > 0){\n            var mo = mos.pop()\n            if(mo.backtrack()){\n                mos.push(mo)\n                if(this.node.num !== undefined){\n                    groups[this.node.num].end = mo.end\n                }\n                this.end = mo.end\n                return true\n            }\n        }\n    }\n    // Else, remove last match if possible\n    if(this.matches.length > this.node.repeat.min &&\n            this.matches.length >= 1){\n        this.matches.pop()\n        if(this.matches.length > 0){\n            this.end = $last(this.matches).end\n        }else{\n            // remove this group and its children from groups\n            del_groups(groups, this.node)\n            this.end = this.start\n        }\n        return true\n    }\n    return false\n}\n\nGroupMO.prototype.toString = function(){\n    var repr = _b_.repr(this.string.substring(this.start, this.end))\n    repr = repr.substring(0, 50)\n    return '<re.Match object; span=(' + this.start + ', ' + this.end +\n        '), match=' + repr + '>'\n}\n\nGroupMO.prototype.groups = function(_default){\n    var res = [],\n        groupobj = this.$groups\n\n    for(var key in this.node.$groups){\n        if(isFinite(key)){\n            res[key] = groupobj[key] === undefined ? _default :\n                this.string.substring(groupobj[key].start, groupobj[key].end)\n        }\n    }\n    res.shift()\n    return $B.fast_tuple(res)\n}\n\nvar BMO = $B.make_class(\"Match\",\n    function(mo){\n        return {\n            __class__: BMO,\n            mo\n        }\n    }\n)\n\nBMO.__getitem__ = function(){\n    var $ = $B.args(\"__getitem__\", 2, {self: null, key: null},\n                ['self', 'key'], arguments, {}, null, null),\n        self = $.self,\n        key = $.key\n    if(Array.isArray(key)){\n        throw _b_.IndexError.$factory(\"no such group\")\n    }\n    if(key == 0){\n        return self.mo.string.substring(self.mo.start, self.mo.end)\n    }\n    var match = self.mo.$groups[key]\n    if(match !== undefined){\n        return self.mo.string.substring(match.start, match.end)\n    }else if(self.mo.node.$groups[key] !== undefined){\n        return _b_.None\n    }\n    throw _b_.IndexError.$factory(\"no such group\")\n}\n\nBMO.__repr__ = BMO.__str__ =  function(self){\n    return self.mo.toString()\n}\n\nBMO.end = function(self){\n    var $ = $B.args('end', 2, {self: null, group: null}, ['self', 'group'],\n                arguments, {group: 0}, null, null)\n    var group = BMO.group(self, $.group)\n    if(group === _b_.None){\n        return -1\n    }else if($.group == 0){\n        return self.mo.end\n    }else{\n        return self.mo.$groups[$.group].end\n    }\n}\n\nBMO.endpos = {\n    __get__: function(self){\n        return self.mo.endpos\n    }\n}\n\nBMO.expand = function(){\n    var $ = $B.args(\"expand\", 2, {self: null, template: null},\n                ['self', 'template'], arguments, {}, null, null)\n    var data = {\n        repl: new StringObj($.template),\n    }\n    data = transform_repl(data, {groups: $.self.mo.node.$groups})\n    if(typeof data.repl == \"function\"){\n        return $B.$call(data.repl)(BMO.$factory($.self.mo))\n    }else{\n        return data.repl1\n    }\n}\n\nBMO.group = function(self){\n    var $ = $B.args(\"group\", 1, {self: null}, ['self'], arguments,\n                {}, 'args', null),\n            self = $.self,\n            args = $.args\n    if(args.length == 0){\n        args[0] = 0\n    }\n    var groupobj = self.mo.$groups,\n        result = []\n    for(var group_id of args){\n        if(group_id == 0){\n            result.push(self.mo.string.substring(self.mo.start, self.mo.end))\n            continue\n        }\n        try{\n            // Convert group_id to int if possible\n            group_id = $B.PyNumber_Index(group_id) // in py_utils.js\n        }catch(err){\n            // group_id can be an identifier\n        }\n        if(self.mo.node.$groups[group_id] === undefined){\n            throw _b_.IndexError.$factory(\"no such group\")\n        }\n        var group = groupobj[group_id] // found in match\n        result.push(group === undefined ?\n            _b_.None :\n            self.mo.string.substring(group.start, group.end))\n    }\n    if(args.length == 1){\n        return result[0]\n    }\n    return $B.fast_tuple(result)\n}\n\nBMO.groupdict = function(){\n    /*\n    Return a dictionary containing all the named subgroups of the match, keyed\n    by the subgroup name. The default argument is used for groups that did not\n    participate in the match; it defaults to None.\n    */\n    var $ = $B.args(\"groupdict\", 2, {self: null, default: null},\n                ['self', 'default'], arguments, {default: _b_.None},\n                null, null),\n        self = $.self,\n        groupobj = $.self.mo.$groups,\n        d = $B.empty_dict()\n    for(var key in $.self.mo.node.$groups){\n        if(! isFinite(key)){\n            var value = groupobj[key] === undefined ? $.default :\n                    groupobj[key]\n            if(value !== $.default){\n                value = self.mo.string.substring(value.start, value.end)\n            }\n            _b_.dict.$setitem(d, key, value)\n        }\n    }\n    d.__class__ = GroupDict\n    return d\n}\n\nBMO.groups = function(self){\n    var $ = $B.args(\"group\", 2, {self: null, default: null},\n                ['self', 'default'], arguments,\n                {default: _b_.None}, null, null),\n            self = $.self,\n            _default = $.default\n    return self.mo.groups(_default)\n}\n\nBMO.lastindex = {\n    /* The integer index of the last matched capturing group, or None if no\n       group was matched at all.\n    */\n    __get__: function(self){\n        var last = self.mo.$groups.$last\n        if(last.length == 0){\n            return _b_.None\n        }\n        return parseInt($last(last))\n    }\n}\n\nBMO.lastgroup = {\n    /* The name of the last matched capturing group, or None if the group\n       didn't have a name, or if no group was matched at all.\n    */\n    __get__: function(self){\n        var lastindex = BMO.lastindex.__get__(self)\n        if(lastindex === _b_.None){\n            return _b_.None\n        }\n        var group = self.mo.node.$groups[lastindex],\n            name = group.item.name\n        return name === undefined ? _b_.None : name\n    }\n}\n\nBMO.pos = {\n    __get__: function(self){\n        return self.mo.start\n    }\n}\n\nBMO.re = {\n    __get__: function(self){\n        return self.mo.node.pattern\n    }\n}\n\nBMO.regs = {\n    __get__: function(self){\n        var res = [$B.fast_tuple([self.mo.start, self.mo.end])]\n        for(var group_num in self.mo.node.$groups){\n            if(isFinite(group_num)){\n                var group = self.mo.node.$groups[group_num].item\n                // group.pattern includes the opening and closing brackets\n                res.push($B.fast_tuple([group.pos,\n                    group.pos + group.pattern.length - 2]))\n            }\n        }\n        return $B.fast_tuple(res)\n    }\n}\n\nBMO.span = function(){\n    /*\n    Match.span([group])\n\n    For a match m, return the 2-tuple (m.start(group), m.end(group)). Note\n    that if group did not contribute to the match, this is (-1, -1). group\n    defaults to zero, the entire match.\n    */\n    var $ = $B.args(\"span\", 2, {self: null, group: null},\n                ['self', 'group'], arguments,\n                {group: 0}, null, null),\n            self = $.self,\n            group = $.group\n    if(group == 0){\n        return $B.fast_tuple([self.mo.start, self.mo.end])\n    }\n    var span = self.mo.$groups[group]\n    if(span === undefined){\n        return $B.fast_tuple([-1, -1])\n    }\n    return $B.fast_tuple([span.start, span.end])\n}\n\nBMO.start = function(self){\n    var $ = $B.args('end', 2, {self: null, group: null}, ['self', 'group'],\n                arguments, {group: 0}, null, null)\n    var group = BMO.group(self, $.group)\n    if(group === _b_.None){\n        return -1\n    }else if($.group == 0){\n        return self.mo.start\n    }else{\n        return self.mo.$groups[$.group].start\n    }\n}\n\nBMO.string = {\n    __get__: function(self){\n        return self.mo.string.to_str()\n    }\n}\n\n$B.set_func_names(BMO, 're')\n\nfunction test_after_min_repeat_one(items, pattern, string, pos,\n                            endpos, no_zero_width, groups){\n\n}\n\nfunction log(){\n    if(_debug.value){\n        console.log.apply(null, arguments)\n    }\n}\n\nfunction match(pattern, string, pos, endpos, no_zero_width, groups){\n    // Follow the pattern tree structure\n    log('match pattern', pattern.text, 'pos', pos, string.substring(pos))\n    var string1 = string\n    if(endpos !== undefined){\n        if(endpos < pos){\n            return false\n        }else if(endpos < string.length){\n            string1 = new StringObj('')\n            string1.codepoints = string.codepoints.slice(0, endpos)\n            string1.length = endpos\n        }\n    }\n    if(pattern.node instanceof Node){\n        show(pattern.node)\n    }\n    if(groups === undefined){\n        groups = {$last:[]}\n    }\n    if(pattern.text === undefined){\n        console.log('pas de texte', pattern)\n    }\n    var node = pattern.node,\n        mo\n    if(node.items){\n        // node is either a Choice between several items, or a sequence of\n        // items\n        if(node instanceof Choice){\n            for(var subgroup of subgroups(node)){\n                //delete groups[subgroup]\n            }\n            mo = false\n            for(var _case of node.items){\n                mo = match({node: _case, text: _case.text}, string, pos,\n                    endpos, no_zero_width, groups)\n                if(mo){\n                    return mo\n                }\n            }\n            return false\n        }else{\n            // sequence of items\n            node.repeat = node.repeat === undefined ? {min: 1, max: 1} :\n                node.repeat\n            var start = pos,\n                nb_repeat = 0,\n                nb_zerolength_repeat = 0,\n                matches = [],\n                mos,\n                match_start,\n                empty_matches = {}\n            // loop until we get enough repetitions\n            while(true){\n                if(empty_matches[pos]){\n                    // no use trying again\n                    return matches.length == 0 ? false :\n                       new GroupMO(node, start, matches, string, groups,\n                           endpos)\n                }\n                var initial_groups = Object.keys(groups)\n                mos = []\n                match_start = pos\n                log(\"pattern\", pattern.text, \"loop in group match, match start\", match_start)\n                var i = 0\n                while(i < node.items.length){\n                    var item = node.items[i]\n                    log('item', i, '/', node.items.length - 1,\n                        'of pattern', pattern.text)\n                    var mo = match({node: item, text: item + ''}, string, pos,\n                        endpos, no_zero_width, groups)\n                    if(mo){\n                        if(item instanceof Group &&\n                                item.type == \"lookahead_assertion\"){\n                            log(\"lookahead assertion\", item, \"succeeds\")\n                        }else{\n                            mos.push(mo)\n                            log('item ' + item, 'succeeds, mo', mo, mos, 'groups', groups)\n                            pos = mo.end\n                        }\n                        i++\n                    }else if(false && item instanceof Group &&\n                            item.type == \"negative_lookahead_assertion\"){\n                        log(\"negative lookahead assertion\", item, \"fails : ok !\")\n                        i++\n                    }else{\n                        log('item ' + item, 'of group fails, nb_repeat',\n                            nb_repeat, 'node repeat', node.repeat)\n                        var backtrack = false\n                        while(mos.length > 0){\n                            var mo = mos.pop()\n                            if(mo.backtrack === undefined){\n                                log('pas de backtrack pour', mo)\n                            }\n                            log('try backtrack on mo', mo)\n                            if(mo.backtrack(string, groups)){\n                                log('can backtrack, mo', mo)\n                                mos.push(mo)\n                                i = mos.length\n                                log('mos', mos, 'restart at item', i)\n                                pos = mo.end\n                                backtrack = true\n                                break\n                            }\n                        }\n                        if(backtrack){\n                            log('backtrack ok')\n                            continue\n                        }else{\n                            if(node.type == \"negative_lookahead_assertion\"){\n                                // If a negative lookahead assertion fails,\n                                // return a match\n                                return new GroupMO(node, start, matches,\n                                    string, groups, endpos)\n                            }\n                            if(nb_repeat == 0){\n                                // remove the groups introduced before\n                                // reaching this point\n                                for(var key in groups){\n                                    if(initial_groups.indexOf(key) == -1){\n                                        delete groups[key]\n                                    }\n                                }\n                            }\n                            if(nb_repeat >= node.repeat.min){\n                                log(\"enough repetitions for node\", node)\n                                if(node.type == \"negative_lookahead_assertion\"){\n                                    return false\n                                }\n                                return new GroupMO(node, start, matches, string,\n                                    groups, endpos)\n                            }\n                            return false\n                        }\n                    }\n                }\n                if(node.type == \"negative_lookahead_assertion\"){\n                    // If a negative lookahead succeeds, return false\n                    return false\n                }\n                nb_repeat++\n                if(pos > match_start){\n                    nb_zerolength_repeat = 0\n                }else{\n                    nb_zerolength_repeat++\n                    empty_matches[pos] = true\n                }\n                matches.push({start: match_start, end: pos, mos})\n                if(node.num !== undefined){\n                    groups[node.num] = $last(matches)\n                    if(node.name !== undefined){\n                        groups[node.name] = groups[node.num]\n                    }\n                    if(node.num != $last(groups.$last)){\n                        var ix = groups.$last.indexOf(node.num)\n                        if(ix > -1){\n                            groups.$last.splice(ix, 1)\n                        }\n                        groups.$last.push(node.num)\n                    }\n                }\n                if(nb_repeat >= node.repeat.max){\n                    var res = new GroupMO(node, start, matches, string,\n                        groups, endpos)\n                    if(res.start == res.end && no_zero_width){\n                        // no_zero_width is set when previous match in\n                        // iterator() had length 0; avoids infinite loops\n                        return false\n                    }\n                    return res\n                }\n                log('loop on group', pattern.text, 'nb repeats', nb_repeat,\n                    'nb zero length', nb_zerolength_repeat)\n                if(nb_zerolength_repeat == 65535){\n                    return matches.length == 0 ? false :\n                       new GroupMO(node, start, matches, string, groups,\n                           endpos)\n                }\n            }\n        }\n    }else{\n        if(node.match === undefined){\n            console.log('pas de match', node)\n        }\n        var mo = node.match(string1, pos, groups)\n        log(node, \"mo\", mo)\n        if(mo){\n            var len = mo.group_len === undefined ? 1 : mo.group_len,\n                ix = node.non_greedy ? mo.nb_min : mo.nb_max,\n                end = pos + len * ix\n            return new MO(node, pos, mo, len)\n        }else{\n            return false\n        }\n    }\n}\n\nvar $module = {\n    cache: cache,\n    compile: function(){\n        var $ = $B.args(\"compile\", 2, {pattern: null, flags: null},\n                    ['pattern', 'flags'], arguments, {flags: no_flag},\n                    null, null)\n        if($.pattern && $.pattern.__class__ === BPattern){\n            if($.flags !== no_flag){\n                throw _b_.ValueError.$factory(\n                    \"cannot process flags argument with a compiled pattern\")\n            }\n            return $.pattern\n        }\n        $.pattern = check_pattern_flags($.pattern, $.flags)\n        var data = prepare({pattern: $.pattern})\n        if(typeof $.flags == \"number\"){\n            $.flags = Flag.$factory($.flags)\n        }\n        var jspat = compile(data.pattern, $.flags)\n        return BPattern.$factory(jspat)\n    },\n    error: error,\n    escape: function(){\n        var $ = $B.args(\"escape\", 1, {pattern: null}, ['pattern'], arguments,\n                    {}, null, null),\n            data = prepare({pattern: $.pattern}),\n            pattern = data.pattern,\n            res = []\n        for(var cp of pattern.codepoints){\n            if(escaped.indexOf(cp) > -1){\n                res.push(ord('\\\\'))\n            }\n            res.push(cp)\n        }\n        res = from_codepoint_list(res, data.type)\n        if(data.type == \"bytes\"){\n            res = _b_.str.encode(res, 'latin1')\n        }\n        return res\n    },\n    findall: function(){\n        /* Return all non-overlapping matches of pattern in string, as a list\n           of strings. The string is scanned left-to-right, and matches are\n           returned in the order found. If one or more groups are present in\n           the pattern, return a list of groups; this will be a list of tuples\n           if the pattern has more than one group. Empty matches are included\n           in the result.\n        */\n        var $ = $B.args(\"findall\", 3,\n                    {pattern: null, string: null, flags: null},\n                    ['pattern', 'string', 'flags'], arguments,\n                    {flags: no_flag}, null, null),\n                pattern = $.pattern,\n                string = $.string,\n                flags = $.flags,\n                data\n        pattern = check_pattern_flags(pattern, flags)\n        if(pattern.__class__ === BPattern){\n            data = prepare({string})\n        }else{\n            data = prepare({string, pattern})\n            pattern = BPattern.$factory(compile(data.pattern, flags))\n        }\n        if(data.type === \"str\"){\n            function conv(s){\n                return s === EmptyString ? '' : s\n            }\n        }else{\n            function conv(s){\n                return string2bytes(s)\n            }\n        }\n\n        var iter = $module.finditer.apply(null, arguments),\n            res = []\n        while(true){\n            var next = iter.next()\n            if(next.done){\n                return res\n            }\n            var bmo = next.value,\n                mo = bmo.mo,\n                groups = BMO.groups(bmo)\n\n            // replace None by the empty string\n            for(var i = 0, len = groups.length; i < len; i++){\n                groups[i] = groups[i] === _b_.None ? \"\" : groups[i]\n            }\n            if(groups.length > 0){\n                if(groups.length == 1){\n                    res.push(groups[0])\n                }else{\n                    res.push($B.fast_tuple(groups))\n                }\n            }else{\n                res.push(mo.string.substring(mo.start, mo.end))\n            }\n        }\n        console.log(\"end findall\")\n    },\n    finditer: function(){\n        var $ = $B.args(\"finditer\", 3,\n                    {pattern: null, string: null, flags: null},\n                    ['pattern', 'string', 'flags'], arguments,\n                    {flags: no_flag}, null, null),\n                pattern = $.pattern,\n                string = $.string,\n                flags = $.flags\n        if(_b_.isinstance(string, [_b_.bytearray, _b_.memoryview])){\n            string.in_iteration = true\n        }\n        var original_string = string,\n            data\n        pattern = check_pattern_flags(pattern, flags)\n        if(pattern.__class__ === BPattern){\n            data = prepare({string})\n            flags = pattern.flags\n        }else{\n            data = prepare({string, pattern})\n            pattern = BPattern.$factory(compile(data.pattern, flags))\n        }\n        if(pattern.__class__ !== BPattern){\n            throw Error(\"pattern not a Python object\")\n        }\n        return $B.generator.$factory(iterator)(pattern.$pattern, data.string,\n            flags, original_string)\n    },\n    fullmatch: function(){\n        var bmo = $module.match.apply(null, arguments)\n        if(bmo !== _b_.None){\n            if(bmo.mo.string.codepoints.length != bmo.mo.end - bmo.mo.start){\n                return _b_.None\n            }else{\n                return bmo\n            }\n        }\n        return _b_.None\n    },\n    Match: BMO,\n    match: function(){\n        var $ = $B.args(\"match\", 3, {pattern: null, string: null, flags: null},\n                    ['pattern', 'string', 'flags'], arguments,\n                    {flags: no_flag}, null, null),\n                pattern = $.pattern,\n                string = $.string,\n                flags = $.flags\n        pattern = check_pattern_flags(pattern, flags)\n        var data\n        if(pattern.__class__ === BPattern){\n            data = prepare({string})\n            pattern = pattern.$pattern\n        }else{\n            data = prepare({pattern, string})\n            pattern = compile(data.pattern, flags)\n        }\n        var res = match(pattern, data.string, 0)\n        return res === false ? _b_.None : BMO.$factory(res)\n    },\n    Pattern: BPattern,\n    purge: function(){\n        var $ = $B.args(\"purge\", 0, {}, [], arguments, {}, null, null)\n        cache.clear()\n        return _b_.None\n    },\n    search: function(){\n        var $ = $B.args(\"search\", 3, {pattern: null, string: null, flags: null},\n                    ['pattern', 'string', 'flags'], arguments,\n                    {flags: no_flag}, null, null),\n                pattern = $.pattern,\n                string = $.string,\n                flags = $.flags,\n                data\n        pattern = check_pattern_flags(pattern, flags)\n        if(pattern.__class__ === BPattern){\n            data = prepare({string})\n        }else{\n            data = prepare({string, pattern})\n            pattern = BPattern.$factory(compile(data.pattern, flags))\n        }\n        data.pattern = pattern\n        // optimization\n        if(isFinite(pattern.$pattern.fixed_length) &&\n                pattern.pattern.endsWith('$') &&\n                ! (pattern.flags.value & MULTILINE.value)){\n            var mo = match(pattern.$pattern, data.string,\n                data.string.length - pattern.$pattern.fixed_length)\n            return BMO.$factory(mo)\n        }\n        var pos = 0\n        while(pos < data.string.codepoints.length){\n            var mo = match(data.pattern.$pattern, data.string, pos)\n            if(mo){\n                return BMO.$factory(mo)\n            }else{\n                pos++\n            }\n        }\n        return _b_.None\n    },\n    set_debug: function(){\n        _debug.value = true\n    },\n    split: function(){\n        var $ = $B.args(\"split\", 4,\n                    {pattern: null, string: null, maxsplit: null, flags: null},\n                    ['pattern', 'string', 'maxsplit', 'flags'],\n                    arguments, {maxsplit: 0, flags: no_flag}, null, null)\n        var res = [],\n            pattern = $.pattern,\n            string = $.string,\n            flags = $.flags,\n            pos = 0,\n            nb_split = 0,\n            data\n        if(pattern.__class__ !== BPattern){\n            data = prepare({pattern, string})\n            pattern = BPattern.$factory(compile(data.pattern, flags))\n        }else{\n            data = {pattern, string}\n        }\n        for(var bmo of $module.finditer(pattern, $.string)){\n            var mo = bmo.mo, // finditer returns instances of BMO\n                groupobj = mo.$groups\n            res.push(data.string.substring(pos, mo.start))\n            for(var key in mo.node.$groups){\n                if(isFinite(key)){\n                    if(groupobj[key] !== undefined){\n                        res.push(data.string.substring(groupobj[key].start,\n                            groupobj[key].end))\n                    }else{\n                        res.push(_b_.None)\n                    }\n                }\n            }\n            nb_split++\n            pos = mo.end\n            if(pos >= $.string.length){\n                break\n            }\n            if($.maxsplit != 0 && nb_split >= $.maxsplit){\n                break\n            }\n        }\n        res.push(data.string.substring(pos))\n        if(data.type === \"bytes\"){\n            res = res.map(function(x){return _b_.str.encode(x, \"latin-1\")})\n        }\n        return res\n    },\n    sub: function(){\n        var $ = $B.args(\"sub\", 5,\n                {pattern: null, repl: null, string: null, count: null, flags: null},\n                ['pattern', 'repl', 'string', 'count', 'flags'],\n                arguments, {count: 0, flags: no_flag}, null, null),\n            pattern = $.pattern,\n            repl = $.repl,\n            string = $.string,\n            count = $.count,\n            flags = $.flags,\n            data\n        check_pattern_flags(pattern, flags)\n        if(typeof repl != \"function\"){\n            if(pattern.__class__ != BPattern){\n                data = prepare({pattern, string, repl})\n                pattern = compile(data.pattern, flags)\n            }else{\n                data = prepare({string, repl})\n                flags = pattern.flags\n                pattern = pattern.$pattern\n            }\n            data = transform_repl(data, pattern)\n        }else{\n            if(pattern.__class__ != BPattern){\n                data = prepare({pattern, string})\n                pattern = compile(data.pattern, flags)\n            }else{\n                data = prepare({string})\n                flags = pattern.flags\n                pattern = pattern.$pattern\n            }\n            data.repl = repl\n        }\n        return subn(pattern, data.repl, data.string, count, flags)[0]\n    },\n    subn: function(){\n        var $ = $B.args(\"sub\", 5,\n                {pattern: null, repl: null, string: null, count: null, flags: null},\n                ['pattern', 'repl', 'string', 'count', 'flags'],\n                arguments, {count: 0, flags: no_flag}, null, null),\n            pattern = $.pattern,\n            repl = $.repl,\n            string = $.string,\n            count = $.count,\n            flags = $.flags,\n            data\n        if(pattern.__class__ != BPattern){\n            data = prepare({pattern, repl, string})\n        }else{\n            data = prepare({repl, string})\n            data.pattern = pattern.$pattern\n        }\n        return $B.fast_tuple(subn(data.pattern, data.repl, data.string, count,\n            flags))\n    }\n\n}\n\nvar ASCII = $module.A = $module.ASCII = Flag.$factory(256)\nvar IGNORECASE = $module.I = $module.IGNORECASE = Flag.$factory(2)\nvar LOCALE = $module.L = $module.LOCALE = Flag.$factory(4)\nvar MULTILINE = $module.M = $module.MULTILINE = Flag.$factory(8)\nvar DOTALL = $module.S = $module.DOTALL = Flag.$factory(16)\nvar U = $module.U = $module.UNICODE = Flag.$factory(32)\nvar VERBOSE = $module.X = $module.VERBOSE = Flag.$factory(64)\n$module.cache = cache\n\nvar inline_flags = {\n    i: IGNORECASE,\n    L: LOCALE,\n    m: MULTILINE,\n    s: DOTALL,\n    u: U,\n    x: VERBOSE,\n    a: ASCII\n}\n\nvar flag_names = {\n    i: 'IGNORECASE',\n    L: 'LOCALE',\n    m: 'MULTILINE',\n    s: 'DOTALL',\n    u: 'U',\n    x: 'VERBOSE',\n    a: 'ASCII'\n}\n"],
-    "random": [".js", "// Javascript implementation of the random module\n// Based on Ian Bicking's implementation of the Mersenne twister\n\nvar $module = (function($B){\n\nvar _b_ = $B.builtins,\n    i\n\nvar VERSION = 3\n\n// Code copied from https://github.com/ianb/whrandom/blob/master/mersenne.js\n// by Ian Bicking\n\n// this program is a JavaScript version of Mersenne Twister,\n// a straight conversion from the original program, mt19937ar.c,\n// translated by y. okada on july 17, 2006.\n// and modified a little at july 20, 2006, but there are not any substantial differences.\n// modularized by Ian Bicking, March 25, 2013 (found original version at http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/VERSIONS/JAVASCRIPT/java-script.html)\n// in this program, procedure descriptions and comments of original source code were not removed.\n// lines commented with //c// were originally descriptions of c procedure. and a few following lines are appropriate JavaScript descriptions.\n// lines commented with /* and */ are original comments.\n// lines commented with // are additional comments in this JavaScript version.\n/*\n   A C-program for MT19937, with initialization improved 2002/1/26.\n   Coded by Takuji Nishimura and Makoto Matsumoto.\n\n   Before using, initialize the state by using init_genrand(seed)\n   or init_by_array(init_key, key_length).\n\n   Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,\n   All rights reserved.\n\n   Redistribution and use in source and binary forms, with or without\n   modification, are permitted provided that the following conditions\n   are met:\n\n     1. Redistributions of source code must retain the above copyright\n        notice, this list of conditions and the following disclaimer.\n\n     2. Redistributions in binary form must reproduce the above copyright\n        notice, this list of conditions and the following disclaimer in the\n        documentation and/or other materials provided with the distribution.\n\n     3. The names of its contributors may not be used to endorse or promote\n        products derived from this software without specific prior written\n        permission.\n\n   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n   \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n   A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n   CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n   EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n   PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n   PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n\n   Any feedback is very welcome.\n   http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt.html\n   email: m-mat @ math.sci.hiroshima-u.ac.jp (remove space)\n*/\n\nfunction RandomStream(seed) {\n    /*jshint bitwise:false */\n    /* Period parameters */\n    //c//#define N 624\n    //c//#define M 397\n    //c//#define MATRIX_A 0x9908b0dfUL   /* constant vector a */\n    //c//#define UPPER_MASK 0x80000000UL /* most significant w-r bits */\n    //c//#define LOWER_MASK 0x7fffffffUL /* least significant r bits */\n    var N = 624\n    var M = 397\n    var MATRIX_A = 0x9908b0df   /* constant vector a */\n    var UPPER_MASK = 0x80000000 /* most significant w-r bits */\n    var LOWER_MASK = 0x7fffffff /* least significant r bits */\n    //c//static unsigned long mt[N]; /* the array for the state vector  */\n    //c//static int mti=N+1; /* mti==N+1 means mt[N] is not initialized */\n    var mt = new Array(N)   /* the array for the state vector  */\n    var mti = N + 1           /* mti==N+1 means mt[N] is not initialized */\n\n    function unsigned32(n1){\n        // returns a 32-bits unsiged integer from an operand to which applied a\n        // bit operator.\n        return n1 < 0 ? (n1 ^ UPPER_MASK) + UPPER_MASK : n1\n    }\n\n    function subtraction32(n1, n2){\n    // emulates lowerflow of a c 32-bits unsiged integer variable, instead of\n    // the operator -. these both arguments must be non-negative integers\n    // expressible using unsigned 32 bits.\n        return n1 < n2 ? unsigned32((0x100000000 - (n2 - n1)) & 0xffffffff) :\n          n1 - n2\n    }\n\n    function addition32(n1, n2){\n        // emulates overflow of a c 32-bits unsiged integer variable, instead of\n        // the operator +. these both arguments must be non-negative integers\n        // expressible using unsigned 32 bits.\n        return unsigned32((n1 + n2) & 0xffffffff)\n    }\n\n    function multiplication32(n1, n2){\n        // emulates overflow of a c 32-bits unsiged integer variable, instead of the\n        // operator *. these both arguments must be non-negative integers\n        // expressible using unsigned 32 bits.\n        var sum = 0\n        for (var i = 0; i < 32; ++i){\n            if((n1 >>> i) & 0x1){\n                sum = addition32(sum, unsigned32(n2 << i))\n            }\n        }\n        return sum\n    }\n\n    /* initializes mt[N] with a seed */\n    //c//void init_genrand(unsigned long s)\n    function init_genrand(s) {\n        //c//mt[0]= s & 0xffffffff;\n        mt[0] = unsigned32(s & 0xffffffff)\n        for(mti = 1; mti < N; mti++){\n            mt[mti] =\n                //c//(1812433253 * (mt[mti-1] ^ (mt[mti-1] >> 30)) + mti);\n                addition32(multiplication32(1812433253,\n                    unsigned32(mt[mti - 1] ^ (mt[mti - 1] >>> 30))), mti)\n            /* See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier. */\n            /* In the previous versions, MSBs of the seed affect   */\n            /* only MSBs of the array mt[].                        */\n            /* 2002/01/09 modified by Makoto Matsumoto             */\n            //c//mt[mti] &= 0xffffffff;\n            mt[mti] = unsigned32(mt[mti] & 0xffffffff);\n            /* for >32 bit machines */\n        }\n    }\n\n    /* initialize by an array with array-length */\n    /* init_key is the array for initializing keys */\n    /* key_length is its length */\n    /* slight change for C++, 2004/2/26 */\n    //c//void init_by_array(unsigned long init_key[], int key_length)\n    function init_by_array(init_key, key_length) {\n        //c//int i, j, k;\n        var i, j, k\n        init_genrand(19650218)\n        i = 1\n        j = 0\n        k = (N > key_length ? N : key_length)\n        for(; k; k--){\n          //c//mt[i] = (mt[i] ^ ((mt[i-1] ^ (mt[i-1] >> 30)) * 1664525))\n          //c// + init_key[j] + j; /* non linear */\n          mt[i] = addition32(\n              addition32(unsigned32(mt[i] ^\n                  multiplication32(unsigned32(mt[i - 1] ^ (mt[i - 1] >>> 30)),\n                  1664525)),\n              init_key[j]), j)\n          mt[i] =\n              //c//mt[i] &= 0xffffffff; /* for WORDSIZE > 32 machines */\n              unsigned32(mt[i] & 0xffffffff)\n          i++\n          j++\n          if(i >= N){mt[0] = mt[N - 1]; i = 1}\n          if(j >= key_length){j = 0}\n        }\n        for(k = N - 1; k; k--){\n            //c//mt[i] = (mt[i] ^ ((mt[i-1] ^ (mt[i-1] >> 30)) * 1566083941))\n            //c//- i; /* non linear */\n            mt[i] = subtraction32(\n                unsigned32(\n                    (mt[i]) ^\n                        multiplication32(\n                            unsigned32(mt[i - 1] ^ (mt[i - 1] >>> 30)),\n                    1566083941)),\n                i\n            )\n            //c//mt[i] &= 0xffffffff; /* for WORDSIZE > 32 machines */\n            mt[i] = unsigned32(mt[i] & 0xffffffff)\n            i++\n            if(i >= N){mt[0] = mt[N - 1]; i = 1}\n        }\n        mt[0] = 0x80000000; /* MSB is 1; assuring non-zero initial array */\n    }\n\n    /* generates a random number on [0,0xffffffff]-interval */\n    //c//unsigned long genrand_int32(void)\n    function genrand_int32() {\n        //c//unsigned long y;\n        //c//static unsigned long mag01[2]={0x0UL, MATRIX_A};\n        var y;\n        var mag01 = [0x0, MATRIX_A];\n        /* mag01[x] = x * MATRIX_A  for x=0,1 */\n\n        if(mti >= N){ /* generate N words at one time */\n            //c//int kk;\n            var kk\n\n            if(mti == N + 1){   /* if init_genrand() has not been called, */\n              init_genrand(Date.now()) /* a default initial seed is used */\n            }\n\n            for(kk = 0; kk < N - M; kk++){\n              //c//y = (mt[kk]&UPPER_MASK)|(mt[kk+1]&LOWER_MASK);\n              //c//mt[kk] = mt[kk+M] ^ (y >> 1) ^ mag01[y & 0x1];\n              y = unsigned32((mt[kk]&UPPER_MASK) | (mt[kk + 1]&LOWER_MASK))\n              mt[kk] = unsigned32(mt[kk + M] ^ (y >>> 1) ^ mag01[y & 0x1])\n            }\n            for(;kk < N - 1; kk++){\n              //c//y = (mt[kk]&UPPER_MASK)|(mt[kk+1]&LOWER_MASK);\n              //c//mt[kk] = mt[kk+(M-N)] ^ (y >> 1) ^ mag01[y & 0x1];\n              y = unsigned32((mt[kk]&UPPER_MASK) | (mt[kk + 1]&LOWER_MASK))\n              mt[kk] = unsigned32(mt[kk + (M - N)] ^ (y >>> 1) ^ mag01[y & 0x1])\n            }\n            //c//y = (mt[N-1]&UPPER_MASK)|(mt[0]&LOWER_MASK);\n            //c//mt[N-1] = mt[M-1] ^ (y >> 1) ^ mag01[y & 0x1];\n            y = unsigned32((mt[N - 1] & UPPER_MASK) | (mt[0] & LOWER_MASK))\n            mt[N - 1] = unsigned32(mt[M - 1] ^ (y >>> 1) ^ mag01[y & 0x1])\n            mti = 0\n        }\n\n        y = mt[mti++]\n\n        /* Tempering */\n        //c//y ^= (y >> 11);\n        //c//y ^= (y << 7) & 0x9d2c5680;\n        //c//y ^= (y << 15) & 0xefc60000;\n        //c//y ^= (y >> 18);\n        y = unsigned32(y ^ (y >>> 11))\n        y = unsigned32(y ^ ((y << 7) & 0x9d2c5680))\n        y = unsigned32(y ^ ((y << 15) & 0xefc60000))\n        y = unsigned32(y ^ (y >>> 18))\n\n        return y\n    }\n\n    /* generates a random number on [0,0x7fffffff]-interval */\n    //c//long genrand_int31(void)\n    function genrand_int31(){\n        //c//return (genrand_int32()>>1);\n        return (genrand_int32()>>>1)\n    }\n\n    /* generates a random number on [0,1]-real-interval */\n    //c//double genrand_real1(void)\n    function genrand_real1(){\n        return genrand_int32()*(1.0/4294967295.0)\n        /* divided by 2^32-1 */\n    }\n\n    /* generates a random number on [0,1)-real-interval */\n    //c//double genrand_real2(void)\n    function genrand_real2(){\n        return genrand_int32() * (1.0 / 4294967296.0)\n        /* divided by 2^32 */\n    }\n\n    /* generates a random number on (0,1)-real-interval */\n    //c//double genrand_real3(void)\n    function genrand_real3() {\n        return ((genrand_int32()) + 0.5) * (1.0 / 4294967296.0)\n        /* divided by 2^32 */\n    }\n\n    /* generates a random number on [0,1) with 53-bit resolution*/\n    //c//double genrand_res53(void)\n    function genrand_res53() {\n        //c//unsigned long a=genrand_int32()>>5, b=genrand_int32()>>6;\n        var a = genrand_int32() >>> 5,\n            b = genrand_int32() >>> 6\n        return (a * 67108864.0 + b) * (1.0 / 9007199254740992.0)\n    }\n    /* These real versions are due to Isaku Wada, 2002/01/09 added */\n\n    var random = genrand_res53\n\n    random.seed = function(seed){\n        if(seed === undefined){\n            seed = Date.now()\n        }\n        /*\n        if(Array.isArray(seed)){ // Brython-specific, for debugging\n            init_by_array(seed, seed.length)\n            return\n        }\n        */\n        var keys = []\n        if(typeof seed == \"number\" || _b_.isinstance(seed, _b_.int)){\n            var int32 = Math.pow(2, 32),\n                int32_1 = int32 - 1\n            // Transform to long integer\n            seed = $B.long_int.$factory(seed)\n            // Take abs(seed)\n            seed = $B.long_int.__abs__(seed)\n            // decomposition in factors of 2 ** 32\n            while($B.long_int.__ge__(seed, int32_1)){\n                var dm = _b_.divmod(seed, int32)\n                // Rest is a JS number (< 2 ** 32)\n                keys.push(dm[1])\n                // Quotient is either a JS number or a instance of long_int\n                // but seed must be long_int\n                seed = dm[0].value === undefined ?\n                    $B.long_int.$factory(dm[0]) : dm[0]\n            }\n            keys.push(parseInt(seed.value))\n        }else if(typeof seed != \"number\"){\n            seed = parseInt(seed, 10)\n            if((seed !== 0 && ! seed) || isNaN(seed)){\n                throw _b_.ValueError.$factory(\"Bad seed: \" +\n                    _b_.str.$factory(seed))\n            }\n        }\n        init_by_array(keys, keys.length)\n    }\n\n    random.seed(seed)\n\n    random.int31 = genrand_int31\n    random.real1 = genrand_real1\n    random.real2 = genrand_real2\n    random.real3 = genrand_real3\n    random.res53 = genrand_res53\n\n    // Added for compatibility with Python\n    random.getstate = function(){\n        return $B.fast_tuple([VERSION,\n            $B.fast_tuple(mt.concat([mti]))\n            , _b_.None])\n    }\n\n    random.setstate = function(state){\n        mt = state[1].slice(0, state[1].length - 1)\n        mti = state[1][state[1].length - 1]\n    }\n\n    return random\n\n}\n\n// magic constants\n\nvar NV_MAGICCONST = 4 * Math.exp(-0.5)/Math.sqrt(2),\n    gauss_next = null,\n    NV_MAGICCONST = 1.71552776992141,\n    TWOPI = 6.28318530718,\n    LOG4 = 1.38629436111989,\n    SG_MAGICCONST = 2.50407739677627,\n    VERSION = VERSION\n\nvar Random = $B.make_class(\"Random\",\n    function(){\n        return {\n            __class__: Random,\n            _random: RandomStream(Date.now())\n        }\n    }\n)\n\nRandom._randbelow = function(self, x){\n    return Math.floor(x * self._random())\n}\n\nRandom._urandom = function(self, n){\n    /*\n    urandom(n) -> str\n    Return n random bytes suitable for cryptographic use.\n    */\n\n    var randbytes = []\n    for(i = 0; i < n; i++){randbytes.push(parseInt(self._random() * 256))}\n    return _b_.bytes.$factory(randbytes)\n}\n\nRandom.betavariate = function(){\n    /* Beta distribution.\n\n    Conditions on the parameters are alpha > 0 and beta > 0.\n    Returned values range between 0 and 1.\n\n\n    # This version due to Janne Sinkkonen, and matches all the std\n    # texts (e.g., Knuth Vol 2 Ed 3 pg 134 \"the beta distribution\").\n    */\n\n    var $ = $B.args('betavariate', 3, {self: null, alpha:null, beta:null},\n            ['self', 'alpha', 'beta'], arguments, {}, null, null),\n        self = $.self,\n        alpha = $.alpha,\n        beta = $.beta\n\n    var y = Random.gammavariate(self, alpha, 1)\n    if(y == 0){return _b_.float.$factory(0)}\n    else{return y / (y + Random.gammavariate(self, beta, 1))}\n}\n\nRandom.choice = function(){\n    var $ = $B.args(\"choice\", 2,\n        {self: null, seq:null},[\"self\", \"seq\"],arguments, {}, null, null),\n        self = $.self,\n        seq = $.seq\n    var len, rank\n    if(Array.isArray(seq)){len = seq.length}\n    else{len = _b_.getattr(seq,\"__len__\")()}\n    if(len == 0){\n        throw _b_.IndexError.$factory(\"Cannot choose from an empty sequence\")\n    }\n    rank = parseInt(self._random() * len)\n    if(Array.isArray(seq)){return seq[rank]}\n    else{return _b_.getattr(seq, \"__getitem__\")(rank)}\n}\n\nRandom.choices = function(){\n    var $ = $B.args(\"choices\", 3,\n            {self: null,population:null, weights:null, cum_weights:null, k:null},\n            [\"self\", \"population\", \"weights\", \"cum_weights\", \"k\"], arguments,\n            {weights: _b_.None, cum_weights: _b_.None, k: 1}, \"*\", null),\n            self = $.self,\n            population = $.population,\n            weights = $.weights,\n            cum_weights = $.cum_weights,\n            k = $.k\n\n    if(population.length == 0){\n        throw _b_.ValueError.$factory(\"population is empty\")\n    }\n    population = _b_.list.$factory(population) // issue #1268\n    if(weights === _b_.None){\n        weights = []\n        population.forEach(function(){\n            weights.push(1)\n        })\n    }else if(cum_weights !== _b_.None){\n        throw _b_.TypeError.$factory(\"Cannot specify both weights and \" +\n            \"cumulative weights\")\n    }else{\n        if(weights.length != population.length){\n            throw _b_.ValueError.$factory('The number of weights does not ' +\n                'match the population')\n        }\n    }\n    if(cum_weights === _b_.None){\n        var cum_weights = [weights[0]]\n        weights.forEach(function(weight, rank){\n            if(rank > 0){\n                cum_weights.push(cum_weights[rank - 1] + weight)\n            }\n        })\n    }else if(cum_weights.length != population.length){\n        throw _b_.ValueError.$factory('The number of weights does not ' +\n            'match the population')\n    }\n\n    var result = []\n    for(var i = 0; i < k; i++){\n        var rand = self._random() * cum_weights[cum_weights.length - 1]\n        for(var rank = 0, len = population.length; rank < len; rank++){\n            if(cum_weights[rank] > rand){\n                result.push(population[rank])\n                break\n            }\n        }\n    }\n    return result\n}\n\nRandom.expovariate = function(self, lambd){\n    /*\n    Exponential distribution.\n\n    lambd is 1.0 divided by the desired mean.  It should be\n    nonzero.  (The parameter would be called \"lambda\", but that is\n    a reserved word in Python.)  Returned values range from 0 to\n    positive infinity if lambd is positive, and from negative\n    infinity to 0 if lambd is negative.\n\n    */\n    // lambd: rate lambd = 1/mean\n    // ('lambda' is a Python reserved word)\n\n    // we use 1-random() instead of random() to preclude the\n    // possibility of taking the log of zero.\n    return -Math.log(1.0 - self._random()) / lambd\n}\n\nRandom.gammavariate = function(self, alpha, beta){\n    /* Gamma distribution.  Not the gamma function!\n\n    Conditions on the parameters are alpha > 0 and beta > 0.\n\n    The probability distribution function is:\n\n                x ** (alpha - 1) * math.exp(-x / beta)\n      pdf(x) =  --------------------------------------\n                  math.gamma(alpha) * beta ** alpha\n\n    */\n\n    // alpha > 0, beta > 0, mean is alpha*beta, variance is alpha*beta**2\n\n    // Warning: a few older sources define the gamma distribution in terms\n    // of alpha > -1.0\n\n    var $ = $B.args('gammavariate', 3,\n            {self: null, alpha:null, beta:null},\n            ['self', 'alpha', 'beta'],\n            arguments, {}, null, null),\n        self = $.self,\n        alpha = $.alpha,\n        beta = $.beta,\n        LOG4 = Math.log(4),\n        SG_MAGICCONST = 1.0 + Math.log(4.5)\n\n    if(alpha <= 0.0 || beta <= 0.0){\n        throw _b_.ValueError.$factory('gammavariate: alpha and beta must be > 0.0')\n    }\n\n    if(alpha > 1.0){\n\n        // Uses R.C.H. Cheng, \"The generation of Gamma\n        // variables with non-integral shape parameters\",\n        // Applied Statistics, (1977), 26, No. 1, p71-74\n\n        var ainv = Math.sqrt(2.0 * alpha - 1.0),\n            bbb = alpha - LOG4,\n            ccc = alpha + ainv\n\n        while(true){\n            var u1 = self._random()\n            if(!((1e-7 < u1) && (u1 < .9999999))){\n                continue\n            }\n            var u2 = 1.0 - self._random(),\n                v = Math.log(u1 / (1.0 - u1)) / ainv,\n                x = alpha * Math.exp(v),\n                z = u1 * u1 * u2,\n                r = bbb + ccc * v - x\n            if((r + SG_MAGICCONST - 4.5 * z >= 0.0) || r >= Math.log(z)){\n                return x * beta\n            }\n        }\n    }else if(alpha == 1.0){\n        // expovariate(1)\n        var u = self._random()\n        while(u <= 1e-7){u = self._random()}\n        return -Math.log(u) * beta\n    }else{\n        // alpha is between 0 and 1 (exclusive)\n\n        // Uses ALGORITHM GS of Statistical Computing - Kennedy & Gentle\n\n        while(true){\n            var u = self._random(),\n                b = (Math.E + alpha)/Math.E,\n                p = b*u,\n                x\n            if(p <= 1.0){x = Math.pow(p, (1.0/alpha))}\n            else{x = -Math.log((b-p)/alpha)}\n            var u1 = self._random()\n            if(p > 1.0){\n                if(u1 <= Math.pow(x, alpha - 1.0)){\n                    break\n                }\n            }else if(u1 <= Math.exp(-x)){\n                break\n            }\n        }\n        return x * beta\n    }\n}\n\nRandom.gauss = function(){\n\n    /* Gaussian distribution.\n\n    mu is the mean, and sigma is the standard deviation.  This is\n    slightly faster than the normalvariate() function.\n\n    Not thread-safe without a lock around calls.\n\n    # When x and y are two variables from [0, 1), uniformly\n    # distributed, then\n    #\n    #    cos(2*pi*x)*sqrt(-2*log(1-y))\n    #    sin(2*pi*x)*sqrt(-2*log(1-y))\n    #\n    # are two *independent* variables with normal distribution\n    # (mu = 0, sigma = 1).\n    # (Lambert Meertens)\n    # (corrected version; bug discovered by Mike Miller, fixed by LM)\n\n    # Multithreading note: When two threads call this function\n    # simultaneously, it is possible that they will receive the\n    # same return value.  The window is very small though.  To\n    # avoid this, you have to use a lock around all calls.  (I\n    # didn't want to slow this down in the serial case by using a\n    # lock here.)\n    */\n\n    var $ = $B.args('gauss', 3, {self: null, mu:null, sigma:null},\n            ['self', 'mu', 'sigma'], arguments, {}, null, null),\n        self = $.self,\n        mu = $.mu,\n        sigma = $.sigma\n\n    var z = gauss_next\n    gauss_next = null\n    if(z === null){\n        var x2pi = self._random() * Math.PI * 2,\n            g2rad = Math.sqrt(-2.0 * Math.log(1.0 - self._random())),\n            z = Math.cos(x2pi) * g2rad\n        gauss_next = Math.sin(x2pi) * g2rad\n    }\n    return mu + z*sigma\n}\n\nRandom.getrandbits = function(){\n    var $ = $B.args(\"getrandbits\", 2,\n        {self: null, k:null},[\"self\", \"k\"],arguments, {}, null, null),\n        self = $.self,\n        k = $B.$GetInt($.k)\n    // getrandbits(k) -> x.  Generates a long int with k random bits.\n    if(k <= 0){\n        throw _b_.ValueError.$factory('number of bits must be greater than zero')\n    }\n    if(k != _b_.int.$factory(k)){\n        throw _b_.TypeError.$factory('number of bits should be an integer')\n    }\n    var numbytes = (k + 7), // bits / 8 and rounded up\n        x = _b_.int.from_bytes(Random._urandom(self, numbytes), 'big')\n    return _b_.getattr(x, '__rshift__')(\n        _b_.getattr(numbytes*8,'__sub__')(k))\n}\n\nRandom.getstate = function(){\n    // Return internal state; can be passed to setstate() later.\n    var $ = $B.args('getstate', 1, {self: null},\n        [\"self\"], arguments, {}, null, null)\n    return $.self._random.getstate()\n}\n\nRandom.lognormvariate = function(){\n    /*\n    Log normal distribution.\n\n    If you take the natural logarithm of this distribution, you'll get a\n    normal distribution with mean mu and standard deviation sigma.\n    mu can have any value, and sigma must be greater than zero.\n\n    */\n    return Math.exp(Random.normalvariate.apply(null, arguments))\n}\n\nRandom.normalvariate = function(){\n    /*\n    Normal distribution.\n\n    mu is the mean, and sigma is the standard deviation.\n\n    */\n\n    // mu = mean, sigma = standard deviation\n\n    // Uses Kinderman and Monahan method. Reference: Kinderman,\n    // A.J. and Monahan, J.F., \"Computer generation of random\n    // variables using the ratio of uniform deviates\", ACM Trans\n    // Math Software, 3, (1977), pp257-260.\n\n    var $ = $B.args(\"normalvariate\", 3,\n        {self: null, mu:null, sigma:null}, [\"self\", \"mu\", \"sigma\"],\n        arguments, {}, null, null),\n        self = $.self,\n        mu = $.mu,\n        sigma = $.sigma\n\n    while(true){\n        var u1 = self._random(),\n            u2 = 1.0 - self._random(),\n            z = NV_MAGICCONST * (u1 - 0.5) / u2,\n            zz = z * z / 4.0\n        if(zz <= -Math.log(u2)){break}\n    }\n    return mu + z * sigma\n}\n\nRandom.paretovariate = function(){\n    /* Pareto distribution.  alpha is the shape parameter.*/\n    // Jain, pg. 495\n\n    var $ = $B.args(\"paretovariate\", 2, {self: null, alpha:null},\n        [\"self\", \"alpha\"], arguments, {}, null, null)\n\n    var u = 1 - $.self._random()\n    return 1 / Math.pow(u, 1 / $.alpha)\n}\n\nfunction is_integer(x){\n    return _b_.isinstance(x, _b_.int) || (\n        _b_.isinstance(x, _b_.float) &&\n            x.valueOf() == Math.floor(x.valueOf()))\n}\n\nRandom.randint = function(self, a, b){\n    var $ = $B.args('randint', 3,\n        {self: null, a:null, b:null},\n        ['self', 'a', 'b'],\n        arguments, {}, null, null)\n    if(! is_integer($.a)){\n        throw _b_.ValueError.$factory(\"non-integer value for start\")\n    }\n    if(! is_integer($.b)){\n        throw _b_.ValueError.$factory(\"non-integer value for stop\")\n    }\n    return Random.randrange($.self, $.a, $B.add($.b, 1))\n}\n\nRandom.random = function(self){\n    var res = self._random()\n    if(! Number.isInteger(res)){return new Number(res)}\n    return res\n}\n\nRandom.randrange = function(){\n    var $ = $B.args('randrange', 4,\n        {self: null, x:null, stop:null, step:null},\n        ['self', 'x', 'stop', 'step'],\n        arguments, {stop:null, step:null}, null, null),\n        self = $.self,\n        _random = self._random\n\n    if(! is_integer($.x)){\n        throw _b_.ValueError.$factory(\"non-integer arg 1 for randrange()\")\n    }\n    if($.stop !== null && ! is_integer($.stop)){\n        throw _b_.ValueError.$factory(\"non-integer arg 2 for randrange()\")\n    }\n    if($.step !== null && ! is_integer($.step)){\n        throw _b_.ValueError.$factory(\"non-integer arg 3 for randrange()\")\n    }\n\n    if($.stop === null){\n        var start = 0, stop = $.x.valueOf(), step = 1\n    }else{\n        var start = $.x.valueOf(),\n            stop = $.stop.valueOf(),\n            step = $.step === null ? 1 : $.step.valueOf()\n        if(step == 0){throw _b_.ValueError.$factory('step cannot be 0')}\n    }\n\n    if(($B.rich_comp(\"__gt__\", step, 0) &&\n            $B.rich_comp(\"__ge__\", start, stop)) ||\n            ($B.rich_comp(\"__lt__\", step, 0) &&\n             $B.rich_comp(\"__le__\", start, stop))){\n        throw _b_.ValueError.$factory(\"empty range for randrange() (\" +\n            start + \", \" + stop + \", \" + step + \")\")\n    }\n    if(typeof start == 'number' && typeof stop == 'number' &&\n            typeof step == 'number'){\n        return start + step * Math.floor(_random() *\n            Math.ceil((stop - start) / step))\n    }else{\n        var d = _b_.getattr(stop, '__sub__')(start)\n        d = _b_.getattr(d, '__floordiv__')(step)\n        // Force d to be a LongInt\n        d = $B.long_int.$factory(d)\n        // d is a long integer with n digits ; to choose a random number\n        // between 0 and d the most simple is to take a random digit\n        // at each position, except the first one\n        var s = d.value,\n            _len = s.length,\n            res = Math.floor(_random() * (parseInt(s.charAt(0)) +\n                (_len == 1 ? 0 : 1))) + ''\n        var same_start = res.charAt(0) == s.charAt(0)\n        for(var i = 1; i < _len; i++){\n            if(same_start){\n                // If it's the last digit, don't allow stop as valid\n                if(i == _len - 1){\n                    res += Math.floor(_random() * parseInt(s.charAt(i))) + ''\n                }else{\n                    res += Math.floor(_random() *\n                        (parseInt(s.charAt(i)) + 1)) + ''\n                    same_start = res.charAt(i) == s.charAt(i)\n                }\n            }else{\n                res += Math.floor(_random() * 10) + ''\n            }\n        }\n        var offset = {__class__: $B.long_int, value: res,\n            pos: true}\n        d = _b_.getattr(step, '__mul__')(offset)\n        d = _b_.getattr(start, '__add__')(d)\n        return _b_.int.$factory(d)\n    }\n}\n\nRandom.sample = function(){\n    /*\n    Chooses k unique random elements from a population sequence or set.\n\n    Returns a new list containing elements from the population while\n    leaving the original population unchanged.  The resulting list is\n    in selection order so that all sub-slices will also be valid random\n    samples.  This allows raffle winners (the sample) to be partitioned\n    into grand prize and second place winners (the subslices).\n\n    Members of the population need not be hashable or unique.  If the\n    population contains repeats, then each occurrence is a possible\n    selection in the sample.\n\n    To choose a sample in a range of integers, use range as an argument.\n    This is especially fast and space efficient for sampling from a\n    large population:   sample(range(10000000), 60)\n\n    # Sampling without replacement entails tracking either potential\n    # selections (the pool) in a list or previous selections in a set.\n\n    # When the number of selections is small compared to the\n    # population, then tracking selections is efficient, requiring\n    # only a small set and an occasional reselection.  For\n    # a larger number of selections, the pool tracking method is\n    # preferred since the list takes less space than the\n    # set and it doesn't suffer from frequent reselections.'\n\n    */\n    var $ = $B.args('sample', 3, {self: null, population: null,k: null},\n        ['self', 'population','k'], arguments, {}, null, null),\n        self = $.self,\n        population = $.population,\n        k = $.k\n\n    if(!_b_.hasattr(population, '__len__')){\n        throw _b_.TypeError.$factory(\"Population must be a sequence or set. \" +\n            \"For dicts, use list(d).\")\n    }\n    var n = _b_.getattr(population, '__len__')()\n\n    if(k < 0 || k > n){\n        throw _b_.ValueError.$factory(\"Sample larger than population\")\n    }\n    var result = [],\n        setsize = 21        // size of a small set minus size of an empty list\n    if(k > 5){\n        setsize += Math.pow(4, Math.ceil(Math.log(k * 3, 4))) // table size for big sets\n    }\n    if(n <= setsize){\n        // An n-length list is smaller than a k-length set\n        if(Array.isArray(population)){\n            var pool = population.slice()\n        }else{var pool = _b_.list.$factory(population)}\n        for(var i = 0; i < k; i++){ //invariant:  non-selected at [0,n-i)\n            var j = Random._randbelow(self, n - i)\n            result[i] = pool[j]\n            pool[j] = pool[n - i - 1]   // move non-selected item into vacancy\n        }\n    }else{\n        selected = {}\n        for(var i = 0; i < k; i++){\n            var j = Random._randbelow(self, n)\n            while(selected[j] !== undefined){\n                j = Random._randbelow(self, n)\n            }\n            selected[j] = true\n            result[i] = Array.isArray(population) ? population[j] :\n                            _b_.getattr(population, '__getitem__')(j)\n        }\n    }\n    return $B.$list(result) // not \"return result\", cf. issue #1622\n}\n\nRandom.seed = function(){\n    /*\n    Initialize internal state from hashable object.\n\n    None or no argument seeds from current time or from an operating\n    system specific randomness source if available.\n\n    If *a* is an int, all bits are used.\n    */\n    var $ = $B.args('seed', 3, {self: null, a: null, version: null},\n        ['self', 'a', 'version'],\n        arguments, {a: new Date(), version: 2}, null, null),\n        self = $.self,\n        a = $.a,\n        version = $.version\n\n    if(version == 1){a = _b_.hash(a)}\n    else if(version == 2){\n        if(_b_.isinstance(a, _b_.str)){\n            a = _b_.int.from_bytes(_b_.bytes.$factory(a, 'utf-8'), 'big')\n        }else if(_b_.isinstance(a, [_b_.str, _b_.bytes, _b_.bytearray])){\n            $B.$import(\"hashlib\",[\"sha512\"], {}, {}, true);\n            var sha512 = $B.$getattr($B.imported[\"hashlib\"], \"sha512\");\n            if(_b_.isinstance(a, _b_.str)){\n                a = _b_.str.encode(a)\n            }\n            a = $B.add(a, $B.$getattr(sha512(a), 'digest')())\n            a = _b_.int.from_bytes(a, 'big')\n        }else if(false && Array.isArray(a)){\n            // for debugging\n        }else if(!_b_.isinstance(a, _b_.int)){\n            throw _b_.TypeError.$factory('wrong argument')\n        }\n    }else{\n        throw _b_.ValueError.$factory('version can only be 1 or 2')\n    }\n    self._random.seed(a)\n    gauss_next = null\n}\n\nRandom.setstate = function(state){\n    // Restore internal state from object returned by getstate().\n    var $ = $B.args('setstate', 2, {self: null, state:null}, ['self', 'state'],\n        arguments, {}, null, null),\n        self = $.self\n    var state = self._random.getstate()\n    if(! Array.isArray($.state)){\n        throw _b_.TypeError.$factory('state must be a list, not ' +\n            $B.class_name($.state))\n    }\n    if($.state.length < state.length){\n        throw _b_.ValueError.$factory(\"need more than \" + $.state.length +\n            \" values to unpack\")\n    }else if($.state.length > state.length){\n        throw _b_.ValueError.$factory(\"too many values to unpack (expected \" +\n            state.length + \")\")\n    }\n    if($.state[0] != 3){\n        throw _b_.ValueError.$factory(\"ValueError: state with version \" +\n            $.state[0] + \" passed to Random.setstate() of version 3\")\n    }\n    var second = _b_.list.$factory($.state[1])\n    if(second.length !== state[1].length){\n        throw _b_.ValueError.$factory('state vector is the wrong size')\n    }\n    for(var i = 0; i < second.length; i++){\n        if(typeof second[i] != 'number'){\n            throw _b_.ValueError.$factory('state vector items must be integers')\n        }\n    }\n    self._random.setstate($.state)\n}\n\nRandom.shuffle = function(x, random){\n    /*\n    x, random = random.random -> shuffle list x in place; return None.\n\n    Optional arg random is a 0-argument function returning a random\n    float in [0.0, 1.0); by default, the standard random.random.\n    */\n\n    var $ = $B.args('shuffle', 3, {self: null, x: null, random: null},\n        ['self', 'x','random'],\n        arguments, {random: null}, null, null),\n        self = $.self,\n        x = $.x,\n        random = $.random\n\n    if(random === null){random = self._random}\n\n    if(Array.isArray(x)){\n        for(var i = x.length - 1; i >= 0;i--){\n            var j = Math.floor(random() * (i + 1)),\n                temp = x[j]\n            x[j] = x[i]\n            x[i] = temp\n        }\n    }else{\n        var len = _b_.getattr(x, '__len__')(), temp,\n            x_get = _b_.getattr(x, '__getitem__'),\n            x_set = _b_.getattr(x, '__setitem__')\n\n        for(i = len - 1; i >= 0; i--){\n            var j = Math.floor(random() * (i + 1)),\n                temp = x_get(j)\n            x_set(j, x_get(i))\n            x_set(i, temp)\n        }\n    }\n    return _b_.None\n}\n\nRandom.triangular = function(){\n    /*\n    Triangular distribution.\n\n    Continuous distribution bounded by given lower and upper limits,\n    and having a given mode value in-between.\n\n    http://en.wikipedia.org/wiki/Triangular_distribution\n    */\n    var $ = $B.args('triangular', 4,\n        {self: null, low: null, high: null, mode: null},\n        ['self', 'low', 'high', 'mode'],\n        arguments, {low: 0, high: 1, mode: null}, null, null),\n        low = $.low,\n        high = $.high,\n        mode = $.mode\n\n    var u = $.self._random(),\n        c = mode === null ? 0.5 : (mode - low) / (high - low)\n    if(u > c){\n        u = 1 - u\n        c = 1 - c\n        var temp = low\n        low = high\n        high = temp\n    }\n    return low + (high - low) * Math.pow(u * c, 0.5)\n}\n\nRandom.uniform = function(){\n    var $ = $B.args('uniform', 3, {self: null, a: null, b: null},\n        ['self', 'a', 'b'], arguments, {}, null, null),\n        a = $B.$GetInt($.a),\n        b = $B.$GetInt($.b)\n\n    return a + (b - a) * $.self._random()\n}\n\nRandom.vonmisesvariate = function(){\n    /* Circular data distribution.\n\n    mu is the mean angle, expressed in radians between 0 and 2*pi, and\n    kappa is the concentration parameter, which must be greater than or\n    equal to zero.  If kappa is equal to zero, this distribution reduces\n    to a uniform random angle over the range 0 to 2*pi.\n\n    */\n    // mu:    mean angle (in radians between 0 and 2*pi)\n    // kappa: concentration parameter kappa (>= 0)\n    // if kappa = 0 generate uniform random angle\n\n    // Based upon an algorithm published in: Fisher, N.I.,\n    // \"Statistical Analysis of Circular Data\", Cambridge\n    // University Press, 1993.\n\n    // Thanks to Magnus Kessler for a correction to the\n    // implementation of step 4.\n\n    var $ = $B.args('vonmisesvariate', 3,\n            {self: null, mu: null, kappa:null}, ['self', 'mu', 'kappa'],\n            arguments, {}, null, null),\n        self = $.self,\n        mu = $.mu,\n        kappa = $.kappa,\n        TWOPI = 2*Math.PI\n\n    if(kappa <= 1e-6){return TWOPI * self._random()}\n\n    var s = 0.5 / kappa,\n        r = s + Math.sqrt(1.0 + s * s)\n\n    while(true){\n        var u1 = self._random(),\n            z = Math.cos(Math.PI * u1),\n            d = z / (r + z),\n            u2 = self._random()\n        if((u2 < 1.0 - d * d) ||\n            (u2 <= (1.0 - d) * Math.exp(d))){\n                break\n        }\n    }\n    var q = 1.0 / r,\n        f = (q + z) / (1.0 + q * z),\n        u3 = self._random()\n    if(u3 > 0.5){var theta = (mu + Math.acos(f)) % TWOPI}\n    else{var theta = (mu - Math.acos(f)) % TWOPI}\n    return theta\n}\n\nRandom.weibullvariate = function(){\n    /*Weibull distribution.\n\n    alpha is the scale parameter and beta is the shape parameter.\n\n    */\n    // Jain, pg. 499; bug fix courtesy Bill Arms\n    var $ = $B.args(\"weibullvariate\", 3,\n        {self: null, alpha: null, beta: null},\n        [\"self\", \"alpha\", \"beta\"], arguments, {}, null, null)\n\n    var u = 1 - $.self._random()\n    return $.alpha * Math.pow(-Math.log(u), 1 / $.beta)\n}\n\n$B.set_func_names(Random, \"random\")\n\nvar $module = Random.$factory()\nfor(var attr in Random){\n    $module[attr] = (function(x){\n        return function(){return Random[x]($module, ...arguments)}\n    })(attr)\n    $module[attr].$infos = Random[attr].$infos\n}\n\n$module.Random = Random\n\nvar SystemRandom = $B.make_class(\"SystemRandom\",\n    function(){\n        return {__class__: SystemRandom}\n    }\n)\nSystemRandom.__getattribute__ = function(){\n    throw $B.builtins.NotImplementedError.$factory()\n}\n\n$module.SystemRandom = SystemRandom\n\nreturn $module\n\n})(__BRYTHON__)\n\n"],
+    "python_re": [".js", "// Regular expression\n\nvar $B = __BRYTHON__,\n    _b_ = $B.builtins\n\nvar MAXGROUPS = 2147483647,\n    MAXREPEAT = 2147483648\n\nvar is_word = {}\nvar word_gcs = ['Ll', 'Lu', 'Lm', 'Lt', 'Lo',\n                'Nd',\n                'Mc', 'Me', 'Mn',\n                'Pc']\nfor(var word_gc of word_gcs){\n    for(var cp in $B.unicode_tables[word_gc]){\n        is_word[cp] = true\n    }\n}\n\nvar is_ascii_word = {}\n\nfor(var cp = 0; cp <= 127; cp++){\n    if(is_word[cp]){\n        is_ascii_word[cp] = true\n    }\n}\n\nvar is_digit = {}\n\nfor(var cp in $B.unicode_tables['Nd']){\n    is_digit[cp] = true\n}\n\nvar is_ascii_digit = {}\n\nfor(var cp = 0; cp <= 127; cp++){\n    if(is_digit[cp]){\n        is_ascii_digit[cp] = true\n    }\n}\n\nvar $error_2 = {\n    $name: \"error\",\n    $qualname: \"error\",\n    $is_class: true,\n    __module__: \"re\"\n}\n\nvar error = $B.$class_constructor(\"error\", $error_2,\n    _b_.tuple.$factory([_b_.Exception]),[\"_b_.Exception\"],[])\nerror.__doc__ = _b_.None\nerror.$factory = $B.$instance_creator(error)\nerror.__str__ = function(self){\n    var s = self.msg + ' at position ' + self.pos\n    if(self.lineno > 1){\n        s += ` (line ${self.lineno}, column ${self.colno})`\n    }\n    return s\n}\n\n$B.set_func_names(error, \"re\")\n\nfunction $last(t){\n    return t[t.length - 1]\n}\n\nfunction fail(message, pos, pattern){\n    var err = error.$factory(message)\n    err.msg = message\n    err.pos = pos\n    if(pattern){\n        err.pattern = pattern.py_obj // Python object passed to compile()\n        err.lineno = 1\n        var linestart = 0\n        for(var i = 0, len = pattern.string.length; i < pos; i++){\n            if(pattern.string[i] == '\\n'){\n                err.lineno++\n                linestart = i + 1\n            }\n        }\n        err.colno = pos - linestart + 1\n    }\n    throw err\n}\n\nfunction warn(klass, message, pos){\n    var warning = klass.$factory(message)\n    warning.pos = pos\n    // module _warning is in builtin_modules.js\n    $B.imported._warnings.warn(warning)\n}\n\nvar Flag = $B.make_class(\"Flag\",\n    function(value){\n        return {\n            __class__: Flag,\n            value\n        }\n    }\n)\n\nFlag.__index__ = function(self){\n    return self.value\n}\n\nFlag.__invert__ = function(self){\n    return Flag.$factory(~self.value)\n}\n\nFlag.__eq__ = function(self, other){\n    return self.value == other.value\n}\n\nFlag.__or__ = function(self, other){\n    if(other.__class__ === Flag){\n        return Flag.$factory(self.value | other.value)\n    }else if(typeof other == \"number\"){\n        return Flag.$factory(self.value | other)\n    }\n    return _b_.NotImplemented\n}\n\nFlag.__ror__ = function(self, other){\n    if(typeof other == \"number\" || _b_.isinstance(other, _b_.int)){\n        if(other == 0){\n            return Flag.$factory(self.value)\n        }\n        return Flag.$factory(self.value | other)\n    }\n    return _b_.NotImplemented\n}\n\nFlag.__repr__ = Flag.__str__ = function(self){\n    if(self.value == 0){\n        return \"re.none\"\n    }\n    var inverted = self.value < 0\n\n    var t = [],\n        value = inverted ? ~self.value : self.value\n    for(var flag in inline_flags){\n        if(value & inline_flags[flag].value){\n            t.push('re.' + flag_names[flag])\n            value &= ~inline_flags[flag].value\n        }\n    }\n    if(value > 0){\n        t.push('0x' + value.toString(16))\n    }\n    var res = t.join('|')\n    if(inverted){\n        if(t.length > 1){\n            return '~(' + res + ')'\n        }else{\n            return '~' + res\n        }\n    }\n    return res\n}\n\nFlag.__xor__ = function(self, other){\n    return Flag.$factory(self.value ^ other.value)\n}\n\n$B.set_func_names(Flag, \"re\")\n\nvar no_flag = {}\n\nvar Scanner = $B.make_class(\"Scanner\",\n    function(pattern, string){\n        return {\n            __class__: Scanner,\n            $string: string,\n            pattern\n        }\n    }\n)\n\nScanner.match = function(self){\n    return BPattern.match(self.pattern, self.$string)\n}\n\nScanner.search = function(self){\n    if(! self.$iterator){\n        self.$iterator = $module.finditer(self.pattern, self.$string)\n    }\n    try{\n        var nxt = _b_.next(self.$iterator)\n    }catch(err){\n        if($B.is_exc(err, [_b_.StopIteration])){\n            return _b_.None\n        }\n        throw err\n    }\n    return nxt\n}\n\nvar BPattern = $B.make_class(\"Pattern\",\n    function(pattern){\n        var nb_groups = 0\n        for(var key in pattern.groups){\n            if(isFinite(key)){\n                nb_groups++\n            }\n        }\n        return {\n            __class__: BPattern,\n            pattern: pattern.text,\n            groups: nb_groups,\n            flags: pattern.flags,\n            $groups: pattern.groups,\n            $pattern: pattern\n        }\n    }\n)\n\nBPattern.__eq__ = function(self, other){\n    if(other.$pattern && self.$pattern.type != other.$pattern.$type){\n        // warn(_b_.BytesWarning, \"cannot compare str and bytes pattern\", 1)\n    }\n    return self.pattern == other.pattern &&\n        self.flags.value == other.flags.value\n}\n\nBPattern.__hash__ = function(self){\n    // best effort ;-)\n    return _b_.hash(self.pattern) + self.flags.value\n}\n\nBPattern.__repr__ = BPattern.__str__ = function(self){\n    var text = self.$pattern.text,\n        s = text\n    if(self.$pattern.type == \"bytes\"){\n        s = _b_.str.$factory(_b_.str.encode(s, 'latin-1'))\n    }else{\n        s = _b_.repr(s)\n    }\n    s = s.substr(0, 200)\n    var res = `re.compile(${s}`,\n        flags = self.$pattern.flags\n    if(flags === no_flag){\n        return res + ')'\n    }\n    // mask UNICODE flag\n    if(flags.__class__ === Flag){\n        // copy flag, otherwise U.value would become 0\n        flags = Flag.$factory(flags.value)\n        flags.value &= ~U.value\n    }else if(typeof flags == \"number\"){\n        flags &= ~U.value\n    }\n    if(flags != 0 && flags.value != 0){\n        res += `, ${_b_.str.$factory(flags)}`\n    }\n    return res + ')'\n}\n\nBPattern.findall = function(self){\n    var iter = BPattern.finditer.apply(null, arguments).js_gen,\n        res = []\n\n    while(true){\n        var next = iter.next()\n        if(next.done){\n            return res\n        }\n        var bmo = next.value,\n            mo = bmo.mo,\n            groups = BMO.groups(bmo)\n\n        // replace None by the empty string\n        for(var i = 0, len = groups.length; i < len; i++){\n            groups[i] = groups[i] === _b_.None ? \"\" : groups[i]\n        }\n        if(groups.length > 0){\n            if(groups.length == 1){\n                res.push(groups[0])\n            }else{\n                res.push($B.fast_tuple(groups))\n            }\n        }else{\n            res.push(mo.string.substring(mo.start, mo.end))\n        }\n    }\n}\n\nBPattern.finditer = function(self){\n    var $ = $B.args(\"finditer\", 4,\n            {self: null, string: null, pos: null, endpos: null},\n            'self string pos endpos'.split(' '), arguments,\n            {pos: 0, endpos: _b_.None}, null, null)\n    var original_string = $.string,\n        data = prepare({string: $.string})\n    var endpos = $.endpos === _b_.None ? data.string.length : $.endpos\n    return $B.generator.$factory(iterator)(self.$pattern, data.string,\n            no_flag, $.string, $.pos, endpos)\n}\n\nBPattern.fullmatch = function(self, string){\n    var $ = $B.args(\"match\", 4,\n                    {self: null, string: null, pos: null, endpos: null},\n                    [\"self\", \"string\", \"pos\", \"endpos\"], arguments,\n                    {pos: 0, endpos: _b_.None}, null, null)\n    if($.endpos === _b_.None){\n        $.endpos = $.string.length\n    }\n    var data = prepare({string: $.string})\n    if(self.$pattern.type != data.string.type){\n        throw _b_.TypeError.$factory(\"not the same type for pattern \" +\n            \"and string\")\n    }\n    var mo = match($.self.$pattern, data.string, $.pos, $.endpos)\n    if(mo && mo.end - mo.start == $.endpos - $.pos){\n        return BMO.$factory(mo)\n    }else{\n        return _b_.None\n    }\n}\nvar GroupIndex = $B.make_class(\"GroupIndex\",\n    function(self, _default){\n        var res = $B.empty_dict()\n        res.__class__ = GroupIndex\n        for(var key in self.$groups){\n            if(isNaN(parseInt(key))){\n                res.$string_dict[key] = [self.$groups[key].num,\n                    res.$version++]\n            }\n        }\n        return res\n    }\n)\nGroupIndex.__mro__ = [_b_.dict, _b_.object]\nGroupIndex.__setitem__ = function(){\n    throw _b_.TypeError.$factory(\"read only\")\n}\n\n$B.set_func_names(GroupIndex, \"re\")\n\nBPattern.groupindex = {\n    __get__: function(self){\n        return GroupIndex.$factory(self)\n    }\n}\n\nBPattern.match = function(self, string){\n    var $ = $B.args(\"match\", 4,\n                    {self: null, string: null, pos: null, endpos: null},\n                    [\"self\", \"string\", \"pos\", \"endpos\"], arguments,\n                    {pos: 0, endpos: _b_.None}, null, null)\n    if($.endpos === _b_.None){\n        $.endpos = $.string.length\n    }\n    var data = prepare({string: $.string})\n    if(self.$pattern.type != data.string.type){\n        throw _b_.TypeError.$factory(\"not the same type for pattern \" +\n            \"and string\")\n    }\n    var mo = match($.self.$pattern, data.string, $.pos,\n        $.endpos)\n    return mo ? BMO.$factory(mo) : _b_.None\n}\n\nBPattern.scanner = function(self, string){\n    return Scanner.$factory(self, string)\n}\n\nBPattern.search = function(self, string){\n    var $ = $B.args(\"match\", 4,\n                    {self: null, string: null, pos: null, endpos: null},\n                    [\"self\", \"string\", \"pos\", \"endpos\"], arguments,\n                    {pos: 0, endpos: _b_.None}, null, null)\n    if($.endpos === _b_.None){\n        $.endpos = $.string.length\n    }\n    var data = prepare({string: $.string})\n    if(self.$pattern.type != data.string.type){\n        throw _b_.TypeError.$factory(\"not the same type for pattern \" +\n            \"and string\")\n    }\n    var pos = $.pos\n    while(pos < $.endpos){\n        var mo = match(self.$pattern, data.string, pos)\n        if(mo){\n            return BMO.$factory(mo)\n        }else{\n            pos++\n        }\n    }\n    return _b_.None\n}\n\nBPattern.split = function(){\n    return $module.split.apply(null, arguments)\n}\n\nBPattern.sub = function(){\n    var $ = $B.args(\"match\", 4,\n                    {self: null, repl: null, string: null, count: null},\n                    \"self repl string count\".split(' '), arguments,\n                    {count: 0}, null, null)\n    var data = prepare({string: $.string})\n    if($.self.$pattern.type != data.string.type){\n        throw _b_.TypeError.$factory(\"not the same type for pattern \" +\n            \"and string\")\n    }\n\n    return $module.sub($.self, $.repl, $.string, $.count)\n}\n\n$B.set_func_names(BPattern, \"re\")\n\nfunction Node(parent){\n    this.parent = parent\n    this.items = []\n}\n\nNode.prototype.add = function(item){\n    this.items.push(item)\n    item.parent = this\n}\n\nNode.prototype.fixed_length = function(){\n    // Return the sum of items lengths if fixed, else undefined\n    if(this.repeat){\n        return false\n    }\n    var len = 0\n    for(var item of this.items){\n        if(item.fixed_length === undefined){\n            console.log(\"pas de fixed length\", item)\n            alert()\n        }\n        var sublen = item.fixed_length()\n        if(sublen === false){\n            return false\n        }\n        len += sublen\n    }\n    return len\n}\n\nfunction get_top(node){\n    var top = node.parent\n    while(top.parent){\n        top = top.parent\n    }\n    return top\n}\n\nvar BackReference = function(pos, type, value){\n    // for \"\\number\"\n    this.name = \"BackReference\"\n    this.pos = pos\n    this.type = type // \"name\" or \"num\"\n    this.value = value\n    this.groups = []\n}\n\nBackReference.prototype.fixed_length = function(){\n    // Return length of referenced group if it is fixed, else undefined\n    if(this.repeat){\n        return undefined\n    }\n    var group = this.get_group()\n    if(group.fixed_length === undefined){\n        console.log(\"group\", group, \"no fixed length\")\n        alert()\n    }\n    return group === undefined ? false : group.fixed_length()\n}\n\nBackReference.prototype.get_group = function(){\n    var top = get_top(this)\n    return top.$groups[this.value]\n}\n\nBackReference.prototype.match = function(string, pos, groups){\n    this.repeat = this.repeat || {min: 1, max: 1}\n\n    var group = groups[this.value]\n    if(group === undefined){\n        if(this.repeat.min == 0){\n            return {\n                nb_min: 0,\n                nb_max: 0\n            }\n        }\n        return false\n    }\n\n    // Get the codepoints matched by the referenced group\n    group_cps = string.codepoints.slice(group.start, group.end)\n\n    // search (repetitions of) the matched group codepoints\n    var _pos = pos,\n        nb = 0,\n        len = string.codepoints.length,\n        group_len = group_cps.length,\n        flag\n    while(_pos < len && nb < this.repeat.max){\n        flag = true\n        for(var i = 0; i < group_len; i++){\n            if(string.codepoints[_pos + i] != group_cps[i]){\n                flag = false\n                break\n            }\n        }\n        if(flag){\n            nb++\n            _pos += group_len\n        }else{\n            break\n        }\n    }\n    if(nb >= this.repeat.min){\n        // Returns the accepted minimum and maximum number of repeats\n        // and the length of each repeat\n        return {\n            nb_min: this.repeat.min,\n            nb_max: nb,\n            group_len\n        }\n    }\n    return false\n}\n\nBackReference.prototype.toString = function(){\n    return \"BackRef to group\" + this.value\n}\n\nvar Case = function(){\n    this.name = \"Case\"\n    this.items = []\n    this.groups = []\n    this.text = 'Case '\n}\n\nCase.prototype.add = function(item){\n    this.items.push(item)\n    item.parent = this\n    this.text += item.toString()\n}\n\nCase.prototype.fixed_length = function(){\n    var len\n    for(var item of this.items){\n        var fl = item.fixed_length()\n        if(fl === false){\n            return false\n        }else if(len === undefined){\n            len = fl\n        }else{\n            len += fl\n        }\n    }\n    return len\n}\n\nCase.prototype.toString = function(){\n    return 'Case ' + this.text\n}\n\nvar Choice = function(){\n    this.type = \"choice\"\n    this.items = []\n    this.groups = []\n}\n\nChoice.prototype.add = Node.prototype.add\n\nChoice.prototype.fixed_length = function(){\n    var len\n    for(var item of this.items){\n        var fl = item.fixed_length()\n        if(fl === false){\n            return false\n        }else if(len === undefined){\n            len = fl\n        }else if(len != fl){\n            return false\n        }\n     }\n     return len\n}\n\nfunction subgroups(item){\n    // Return all the subgroups below item\n    var groups = []\n    if(item.items){\n        for(var subitem of item.items){\n            if(subitem instanceof Group && subitem.num){\n                groups.push(subitem.num)\n                if(subitem.name){\n                    groups.push(subitem.name)\n                }\n            }\n            groups = groups.concat(subgroups(subitem))\n        }\n    }\n    return item.$subgroups = groups\n}\n\nChoice.prototype.toString = function(){\n    return 'Choice'\n}\n\nvar EmptyString = {\n        toString: function(){\n            return ''\n        },\n        match: function(string, pos){\n            return {nb_min: 0, nb_max: 0}\n        },\n        fixed_length: function(){\n            return 1\n        },\n        length: 0\n    },\n    Flags = function(flags){\n        this.flags = flags\n    },\n    GroupEnd = function(pos){\n        this.name = \"GroupEnd\"\n        this.pos = pos\n        this.text = ')'\n        this.toString = function(){\n            return '[end of group #' + this.group.num + ']'\n        }\n    },\n    Or = function(pos){\n        this.name = \"Or\"\n        this.pos = pos\n        this.text = '|'\n        this.toString = function(){\n            return '|'\n        }\n    },\n    Repeater = function(pos, op){\n        this.name = \"Repeater\"\n        this.pos = pos\n        this.op = op\n    }\n\nfunction cased_cps(cp, ignore_case, ascii){\n    // If cp is the codepoint of a cased Unicode character, return the list\n    // of the codepoints that match the character in a case-insensitive way\n\n    // ignore_case = this.flags && this.flags.value & IGNORECASE.value\n    // ascii = this.flags.value & ASCII.value\n    var cps,\n        char = $B.codepoint2jsstring(cp)\n    if(! ignore_case){\n        return [cp]\n    }\n    if(ascii){\n        // only test ASCII letters\n        ignore_case = ignore_case && (\n            (char >= 'a' && char <= 'z') ||\n            (char >= 'A' && char <= 'Z'))\n    }\n    if(ignore_case){\n        var char_up = char.toUpperCase(),\n            char_low = char.toLowerCase(),\n            cps = new Set([cp, $B.jsstring2codepoint(char_low),\n                $B.jsstring2codepoint(char_up)])\n        // special cases\n        if(char.toLowerCase() == \"k\"){\n            cps.add(0x212a) // Kelvin sign\n        }\n        if(cp == 0x212a){\n            cps.add(ord('k'))\n            cps.add(ord('K'))\n        }\n        if(char.toLowerCase() == \"s\"){\n            cps.add(0x017f) //  (Latin small letter long s)\n        }\n        if(cp == 0x017f){\n            cps.add(ord('s'))\n            cps.add(ord('S'))\n        }\n        if(char.toLowerCase() == 'i'){\n            cps.add(0x0130) //  (Latin capital letter I with dot above)\n            cps.add(0x0131) //  (Latin small letter dotless i)\n        }\n        if(cp == 0x0130 || cp == 0x0131){\n            cps.add(ord('i'))\n            cps.add(ord('I'))\n        }\n        return Array.from(cps)\n    }else{\n        cps = [cp]\n    }\n    return cps\n}\n\nvar Char = function(pos, cp, groups){\n    // character in a regular expression or in a character set\n    // pos : position of the character in the pattern string\n    // cp : the character's codepoint\n    // groups (optional) : the groups that contain the character\n    this.pos = pos\n    this.cp = cp\n    this.char = chr(this.cp)\n    this.text = this.char\n}\n\nChar.prototype.fixed_length = function(){\n    if(this.repeat){\n        return this.repeat.min\n    }\n    return this.char === EmptyString ? 0 : 1\n}\n\nChar.prototype.match = function(string, pos){\n    // Returns {pos1, pos2} such that \"this\" matches all the substrings\n    // string[pos:i] with pos1 <= i < pos2, or false if no match\n    this.repeat = this.repeat || {min: 1, max: 1}\n\n    var len = string.codepoints.length,\n        i = 0\n\n    // browse string codepoints until they don't match, or the number of\n    // matches is above the maximum allowed\n    if(this.flags){\n        if(this.flags.value & ASCII.value){\n            if(this.cp > 127){\n                return false\n            }\n        }\n        if(this.flags.value & IGNORECASE.value &&\n                (! this.is_bytes || this.cp <= 127)){\n            // Flag IGNORECASE set\n            // For bytes pattern, case insensitive matching only works\n            // for ASCII characters\n            var char_upper = this.char.toUpperCase(),\n                char_lower = this.char.toLowerCase()\n            while(i < this.repeat.max && pos + i < len){\n                var char = chr(string.codepoints[pos + i])\n                if(char.toUpperCase() != char_upper &&\n                        char.toLowerCase() != char_lower){\n                   break\n                }\n                i++\n            }\n        }else{\n            while(string.codepoints[pos + i] == this.cp &&\n                    i < this.repeat.max){\n                i++\n            }\n        }\n    }else{\n        while(string.codepoints[pos + i] == this.cp && i < this.repeat.max){\n            i++\n        }\n    }\n    var nb = i\n    if(nb >= this.repeat.min){\n        // Number of repeats ok\n        return {\n            nb_min: this.repeat.min,\n            nb_max: nb\n        }\n    }else{\n        return false\n    }\n}\n\nChar.prototype.toString = function(){\n    var res = 'Char ' + this.text\n    if(this.repeat !== undefined){\n        res += ' repeat {' + this.repeat.min + ',' + this.repeat.max + '}'\n        if(this.non_greedy){\n            res += '?'\n        }\n    }\n    return res\n}\n\nfunction CharSeq(chars){\n    // sequence of consecutive characters\n    this.chars = chars\n}\n\nCharSeq.prototype.fixed_length = function(){\n    var len = 0\n    for(var char of this.chars){\n        len += char.fixed_length()\n    }\n    return len\n}\n\nCharSeq.prototype.match = function(string, pos){\n    var mos = [],\n        i = 0,\n        backtrack,\n        nb\n    for(var i = 0, len = this.chars.length; i < len; i++){\n        var char =  this.chars[i],\n            mo = char.match(string, pos) // form {nb_min, nb_max}\n        if(mo){\n            nb = char.non_greedy ? mo.nb_min : mo.nb_max\n            mos.push({nb,\n                      nb_min: mo.nb_min,\n                      nb_max: mo.nb_max,\n                      non_greedy: !!char.non_greedy\n                     })\n            pos += nb\n        }else{\n            // backtrack\n            backtrack = false\n            while(mos.length > 0){\n                i--\n                mo = mos.pop()\n                pos -= mo.nb\n                if(mo.non_greedy && nb + 1 < mo.nb_max){\n                    nb += 1\n                    backtrack = true\n                }else if(! mo.non_greedy && nb - 1 >= mo.nb_min){\n                    nb -= 1\n                    backtrack = true\n                }\n                if(backtrack){\n                    pos += nb\n                    mo.nb = nb\n                    mos.push(mo)\n                    i++\n                    break\n                }\n            }\n            if(mos.length == 0){\n                return false\n            }\n        }\n    }\n    var match_len = 0\n    for(var mo of mos){\n        match_len += mo.nb\n    }\n    return {\n        nb_min: match_len,\n        nb_max: match_len\n    }\n}\n\n\n\n\nCharSeq.prototype.toString = function(){\n    var res = ''\n    for(var char of this.chars){\n        res += char.text\n    }\n    return 'CharSeq ' + res\n}\n\nfunction CharacterClass(pos, cp, length, groups){\n    this.cp = cp\n    this.value = chr(cp)\n    this.length = length\n    this.pos = pos\n\n    var flags = this.flags\n\n    // Test function : test(string, pos) returns:\n    // - true if \"this\" matches 1 character string[pos]\n    // - [true, 0] if \"this\" matches the empty string at pos\n    // - false or undefined if \"this\" doesn't match\n    switch(this.value){\n        case 'A':\n            this.test_func = function(string, pos){\n                if(pos == 0){\n                    return [true, 0]\n                }\n            }\n            break\n        case 's':\n            this.test_func = function(string, pos){\n                var cp = string.codepoints[pos]\n                return $B.unicode_tables.Zs[cp] !== undefined ||\n                    $B.unicode_bidi_whitespace.indexOf(cp) > -1\n            }\n            break\n        case 'S':\n            this.test_func = function(string, pos){\n                var cp = string.codepoints[pos]\n                return $B.unicode_tables.Zs[cp] === undefined &&\n                    $B.unicode_bidi_whitespace.indexOf(cp) == -1\n            }\n            break\n        case '.':\n            this.test_func = function(string, pos){\n                if(string.codepoints[pos] === undefined){\n                    return false\n                }\n                if(this.flags.value & DOTALL.value){\n                    return true\n                }else{\n                    return string.codepoints[pos] != 10\n                }\n            }\n            break\n        case 'd':\n            this.test_func = function(string, pos){\n                if(this.flags === undefined){\n                    console.log(\"\\\\d, no flags\", this)\n                }\n                var cp = string.codepoints[pos],\n                    table = (this.flags.value & ASCII.value) ?\n                        is_ascii_digit : is_digit\n                return table[cp]\n            }\n            break\n        case 'D':\n            this.test_func = function(string, pos){\n                var cp = string.codepoints[pos],\n                    table = (this.flags.value & ASCII.value) ?\n                        is_ascii_digit : is_digit\n                return ! table[cp]\n            }\n            break\n        case 'b':\n            this.test_func = function(string, pos){\n                var table = is_word\n                if(this.is_bytes || (this.flags.value & ASCII.value)){\n                    table = is_ascii_word\n                }\n                var cp = string.codepoints[pos],\n                    len = string.codepoints.length,\n                    ok = {nb_min: 0, nb_max: 0}\n\n                // return true if char at pos is at the beginning or start\n                // of a word\n                if(pos == 0 && table[cp]){\n                    return ok\n                }\n                if(pos == len && table[string.codepoints[pos - 1]]){\n                    return ok\n                }\n                if(pos > 0 && pos < len){\n                    if((table[string.codepoints[pos - 1]]) !==\n                            table[cp]){\n                        return ok\n                    }\n                }\n                return false\n            }\n            break\n        case 'B':\n            this.test_func = function(string, pos){\n                var table = is_word\n                if(this.is_bytes || (this.flags.value & ASCII.value)){\n                    table = is_ascii_word\n                }\n\n                var cp = string.codepoints[pos],\n                    len = string.codepoints.length,\n                    ok = {nb_min: 0, nb_max: 0}\n                // test is true if char at pos is not at the beginning or\n                // start of a word\n                if(pos == 0 && table[cp]){\n                    return false\n                }\n                if(pos == len && table[string.codepoints[pos - 1]]){\n                    return false\n                }\n                if(pos > 0 && pos < len){\n                    if((table[string.codepoints[pos - 1]]) !==\n                            table[cp]){\n                        return false\n                    }\n                }\n                return ok\n            }\n            break\n        case 'w':\n            this.test_func = function(string, pos){\n                var table = is_word\n                if(this.is_bytes || (this.flags.value & ASCII.value)){\n                    table = is_ascii_word\n                }\n                return table[string.codepoints[pos]]\n            }\n            break\n        case 'W':\n            this.test_func = function(string, pos){\n                var table = is_word\n                if(this.is_bytes || (this.flags.value & ASCII.value)){\n                    table = is_ascii_word\n                }\n                return ! table[string.codepoints[pos]]\n            }\n            break\n        case 'Z':\n            this.test_func = function(string, pos){\n                if(pos >= string.codepoints.length){\n                    return {nb_min: 0, nb_max: 0}\n                }\n            }\n            break\n    }\n}\n\nCharacterClass.prototype.fixed_length = function(){\n    return 1\n}\n\nCharacterClass.prototype.match = function(string, pos){\n    // Returns {pos1, pos2} such that \"this\" matches all the substrings\n    // string[pos:i] with pos1 <= i < pos2, or false if no match\n    this.repeat = this.repeat || {min: 1, max: 1}\n    var len = string.codepoints.length,\n        i = 0\n\n    // browse string codepoints until they don't match, or the number of\n    // matches is above the maximum allowed\n    while(pos + i <= len &&\n            this.test_func(string, pos + i, this.flags) &&\n            i < this.repeat.max){\n        i++\n    }\n    var nb = i\n    if(nb >= this.repeat.min){\n        // Number of repeats ok\n        if('bBAZ'.indexOf(this.value) > -1 ){\n            return {nb_min: 0, nb_max: 0}\n        }\n        return {\n            nb_min: this.repeat.min,\n            nb_max: nb\n        }\n    }else{\n        return false\n    }\n}\n\nCharacterClass.prototype.nb_repeats = Char.prototype.nb_repeats\n\nCharacterClass.prototype.toString = function(){\n    return '\\\\' + this.value\n}\n\nvar CharacterSet = function(pos, set, groups){\n    // character set\n    this.pos = pos\n    this.set = set\n    this.neg = set.neg\n}\n\nCharacterSet.prototype.fixed_length = function(){\n    return 1\n}\n\nCharacterSet.prototype.match = function(string, pos){\n    var ignore_case = this.flags && (this.flags.value & IGNORECASE.value),\n        test,\n        match = false,\n        len = string.codepoints.length,\n        i = 0,\n        cp\n\n    this.repeat = this.repeat || {min: 1, max: 1}\n\n    while(i < this.repeat.max && pos + i < len){\n        test = false\n        cp = string.codepoints[pos + i]\n\n        if(pos >= len){\n            cp = EmptyString\n        }\n        try{\n            $B.codepoint2jsstring(cp)\n        }catch(err){\n            console.log(err.message)\n            throw _b_.Exception.$factory('mauvais codepoint')\n        }\n        var char = $B.codepoint2jsstring(cp),\n            cps = cased_cps(cp, ignore_case, this.flags.value & ASCII.value),\n            char_is_cased = cps.length > 1\n\n        for(var cp1 of cps){\n            for(var item of this.set.items){\n                if(Array.isArray(item.ord)){\n                    if(cp1 >= item.ord[0] &&\n                            cp1 <= item.ord[1]){\n                        test = true\n                        break\n                    }else if(ignore_case && char_is_cased){\n                        var start1 = chr(item.ord[0]).toUpperCase(),\n                            end1 = chr(item.ord[1]).toUpperCase(),\n                            char1 = char.toUpperCase()\n                        if(char1 >= start1 && char1 <= end1){\n                            test = true\n                        }\n                        var start1 = chr(item.ord[0]).toLowerCase(),\n                            end1 = chr(item.ord[1]).toLowerCase(),\n                            char1 = char.toLowerCase()\n                        if(char1 >= start1 && char1 <= end1){\n                            test = true\n                        }\n                    }\n                }else if(item instanceof CharacterClass){\n                    test = !! item.match(string, pos) // boolean\n                }else{\n                    if(item.ord == cp1){\n                        test = true\n                        break\n                    }\n                    if(ignore_case && char_is_cased &&\n                            (char.toUpperCase() == chr(item.ord).toUpperCase() ||\n                            char.toLowerCase() == chr(item.ord).toLowerCase())){\n                        test = true\n                        break\n                    }\n                }\n            }\n        }\n        if(this.neg){\n            test = ! test\n        }\n        if(test){\n            i++\n        }else{\n            break\n        }\n    }\n    var nb = i\n    if(nb >= this.repeat.min){\n        // Number of repeats ok\n        return {\n            nb_min: this.repeat.min,\n            nb_max: nb\n        }\n    }else{\n        return false\n    }\n\n}\n\nCharacterSet.prototype.nb_repeats = Char.prototype.nb_repeats\n\nCharacterSet.prototype.toString = function(){\n    return 'CharSet'\n}\n\nvar ConditionalBackref = function(pos, group_ref){\n    this.type = \"conditional backref\"\n    this.pos = pos\n    this.group_ref = group_ref\n    this.chars = []\n    this.match_codepoints = []\n    this.nb_success = 0\n    this.re_if_exists = new Group(pos)\n    this.re_if_not_exists = new Group(pos)\n    this.nb_options = 1\n}\n\nConditionalBackref.prototype.add = function(item){\n    if(this.nb_options == 1){\n        this.re_if_exists.add(item)\n    }else if(this.nb_options == 2){\n        this.re_if_not_exists.add(item)\n    }\n    item.parent = this\n}\n\nConditionalBackref.prototype.fixed_length = function(){\n    var len = this.re_if_exists.fixed_length()\n    if(len !== false && len == this.re_if_not_exists.fixed_length()){\n        return len\n    }\n    return false\n}\n\nConditionalBackref.prototype.match = function(string, pos, groups){\n    var re = groups[this.group_ref] ? this.re_if_exists :\n            this.re_if_not_exists,\n        pattern = {node: re, text: re + ''},\n        mo = match(pattern, string, pos, undefined,\n            false, groups)\n    if(mo){\n        return {nb_min: mo.end - mo.start, nb_max: mo.end - mo.start}\n    }\n    return false\n}\n\nConditionalBackref.prototype.toString = function(){\n    return 'ConditionalBackref'\n}\n\nvar Group = function(pos, extension){\n    this.type = \"group\"\n    this.pos = pos\n    this.items = []\n    this.chars = []\n    this.groups = []\n    for(key in extension){\n        this[key] = extension[key]\n    }\n    if(extension && extension.type){\n        if(extension.type.indexOf('lookahead') > -1){\n            this.is_lookahead = true\n        }else if(extension.type.indexOf('lookbehind') > -1){\n            this.is_lookbehind = true\n        }\n    }\n}\n\nGroup.prototype.add = Node.prototype.add\n\nGroup.prototype.toString = function(){\n    var res = 'Group #' + this.num + ' ' + this.pattern\n    if(this.repeat !== undefined){\n        res += ' repeat {' + this.repeat.min + ',' + this.repeat.max + '}'\n        if(this.non_greedy){\n            res += '?'\n        }\n    }\n    return res\n}\n\nBackReference.prototype.nb_repeats = Group.prototype.nb_repeats\n\nGroup.prototype.fixed_length = Node.prototype.fixed_length\n\nfunction GroupRef(group_num, item){\n    this.num = group_num\n    this.item = item\n}\n\nGroupRef.prototype.fixed_length = function(){\n    return this.item.fixed_length()\n}\n\nfunction Lookbehind(item){\n    this.re = item\n    this.neg = this.re.type == \"negative_lookbehind\"\n}\n\nLookbehind.prototype.match = function(string, pos, groups){\n    var ok = {nb_min: 0, nb_max: 0},\n        pattern = {node: this.re, text: this.re + ''},\n        length = this.re.length,\n        mo\n    if(pos - length < 0){\n        mo = false\n    }else{\n        mo = match(pattern, string, pos - length, undefined,\n            false, groups)\n    }\n    if(mo){\n        return this.neg ? false : ok\n    }else{\n        return this.neg ? ok : false\n    }\n}\n\nLookbehind.prototype.fixed_length = function(){\n    return this.re.fixed_length()\n}\n\nLookbehind.prototype.toString = function(){\n    return \"Lookbehind\"\n}\n\nfunction SetFlags(pos, flags){\n    this.pos = pos\n    this.on_flags = flags.on_flags\n    this.off_flags = flags.off_flags\n    this.items = []\n}\n\nSetFlags.prototype.add = Node.prototype.add\n\nfunction StringStart(pos){\n    this.pos = pos\n}\n\nStringStart.prototype.match = function(string, pos){\n    var ok = {nb_min:0, nb_max: 0}\n    if(this.flags.value & MULTILINE.value){\n        return (pos == 0 || string.codepoints[pos - 1] == 10) ? ok : false\n    }\n    return pos == 0 ? ok : false\n}\n\nStringStart.prototype.fixed_length = function(){\n    return 0\n}\n\nStringStart.prototype.toString = function(){\n    return '^'\n}\n\nfunction StringEnd(pos){\n    this.pos = pos\n}\n\nStringEnd.prototype.match = function(string, pos){\n    var ok = {nb_min:0, nb_max: 0}\n    if(this.flags.value & MULTILINE.value){\n        return (pos > string.codepoints.length - 1 ||\n            string.codepoints[pos] == 10) ? ok : false\n    }\n    return pos > string.codepoints.length - 1 ? ok :\n           (pos == string.codepoints.length - 1 &&\n               string.codepoints[pos] == 10) ? ok : false\n}\n\nStringEnd.prototype.fixed_length = function(){\n    return 0\n}\n\nStringEnd.prototype.toString = function(){\n    return '$<end>'\n}\n\nfunction validate(name){\n    // name is a StringObj\n    sname = name.string\n    name = name.codepoints\n    if(name.length == 0){\n        fail(\"missing group name\")\n    }else if(chr(name[0]).match(/\\d/) || name.indexOf(ord('.')) > - 1){\n        fail(`bad character in group name '${sname}'`)\n    }\n\n    var $B = window.__BRYTHON__,\n        cp = name[0]\n    if($B.unicode_tables.XID_Start[cp]){\n        var pos = 1\n        while(pos < name.length){\n            cp = name[pos]\n            if($B.unicode_tables.XID_Continue[cp]){\n                pos++\n            }else{\n                break\n            }\n        }\n        if(pos != name.length){\n            console.log(\"bad character\", pos, name)\n            fail(`bad character in group name '${sname}'`)\n        }\n    }else{\n        fail(`bad character in group name '${sname}'`)\n    }\n}\n\nfunction chr(i){\n    if(i < 0 || i > 1114111){\n        throw _b_.ValueError.$factory('Outside valid range')\n    }else if(i >= 0x10000 && i <= 0x10FFFF){\n        var code = (i - 0x10000)\n        return String.fromCodePoint(0xD800 | (code >> 10)) +\n            String.fromCodePoint(0xDC00 | (code & 0x3FF))\n    }else{\n        return String.fromCodePoint(i)\n    }\n}\n\nvar character_classes = {\n    in_charset: to_codepoint_list('bdDsSwW'),\n    in_re: to_codepoint_list('AbBdDsSwWZ')\n}\n\nfunction escaped_char(args){\n    var cps = args.codepoints,\n        pos = args.pos,\n        in_charset = args.in_charset,\n        is_bytes = args.is_bytes // if pattern is bytes\n    var special = cps[pos + 1]\n    if(special === undefined){\n        fail('bad escape (end of pattern)', pos)\n    }\n    var key = in_charset ? 'in_charset' : 'in_re'\n    if(character_classes[key].indexOf(special) > -1){\n        return new CharacterClass(pos, special, 2)\n    }else if(special == ord('N') && ! is_bytes){\n        if(cps[pos + 2] != ord('{')){\n            fail('missing {', pos)\n        }\n        var i = pos + 3,\n            description = []\n        while(i < cps.length){\n            if(cps[i] == ord('}')){\n                break\n            }\n            description.push(cps[i])\n            i++\n        }\n        if(description.length == 0){\n            fail(\"missing character name\", pos)\n        }\n        if(i == cps.length){\n            fail(\"missing }, unterminated name\", pos)\n        }\n        var cp = validate_named_char(from_codepoint_list(description))\n        return {\n            type: 'N',\n            ord: cp,\n            char: chr(cp),\n            length: i - pos + 1\n        }\n    }else if(special == ord('x')){\n        // \\xhh = character with hex value hh\n        var rest = from_codepoint_list(cps.slice(pos + 2)),\n            mo = /^[0-9a-fA-F]{0,2}/.exec(rest),\n            hh = mo ? mo[0] : ''\n        if(mo && mo[0].length == 2){\n            var cp = eval(\"0x\" + mo[0])\n            return {\n                type: 'x',\n                ord: cp,\n                char: chr(cp),\n                length: 2 + mo[0].length\n            }\n        }\n        fail('incomplete escape \\\\x' + hh, pos)\n    }else if(special == ord('u')){\n        // \\uxxxx = character with 16-bit hex value xxxx\n        var rest = from_codepoint_list(cps.slice(pos + 2)),\n            mo = /^[0-9a-fA-F]{0,4}/.exec(rest),\n            xx = mo ? mo[0] : ''\n        if(mo && mo[0].length == 4){\n            var cp = eval(\"0x\" + mo[0])\n            return {\n                type: 'u',\n                ord: cp,\n                char: chr(cp),\n                length: 2 + mo[0].length\n            }\n        }\n        fail('incomplete escape \\\\u' + xx, pos)\n    }else if(special == ord('U')){\n        // \\Uxxxxxxxx = character with 32-bit hex value xxxxxxxx\n        var rest = from_codepoint_list(cps.slice(pos + 2)),\n            mo = /^[0-9a-fA-F]{0,8}/.exec(rest),\n            xx = mo ? mo[0] : ''\n        if(mo && mo[0].length == 8){\n            var cp = eval(\"0x\" + mo[0])\n            if(cp > 0x10FFFF){\n                fail(`bad escape \\\\U${mo[0]}`)\n            }\n            return {\n                type: 'U',\n                ord: cp,\n                char: chr(cp),\n                length: 2 + mo[0].length\n            }\n        }\n        fail('incomplete escape \\\\U' + xx, pos)\n    }else{\n        // octal ?\n        // If the first digit of number is 0, or number is 3 octal digits\n        // long, it will not be interpreted as a group match, but as the\n        // character with octal value number\n        var rest = from_codepoint_list(cps.slice(pos + 1)),\n            mo = /^[0-7]{3}/.exec(rest)\n        if(mo == null){\n            mo = /^0[0-7]*/.exec(rest)\n        }\n        if(mo){\n            var octal_value = eval('0o' + mo[0])\n            if(octal_value > 0o377){\n                fail(`octal escape value \\\\` +\n                    `${mo[0]} outside of range 0-0o377`, pos)\n            }\n            return {\n                type: 'o',\n                ord: octal_value,\n                char: chr(octal_value),\n                length: 1 + mo[0].length\n            }\n        }\n        var mo = /^\\d+/.exec(rest)\n        if(mo){\n            return {\n                type: 'backref',\n                value: parseInt(mo[0]),\n                length: 1 + mo[0].length\n            }\n        }\n        var trans = {f: '\\f', n: '\\n', r: '\\r', t: '\\t', v: '\\v'},\n            res = trans[chr(special)]\n        if(res){\n            return ord(res)\n        }\n        if(chr(special).match(/[a-zA-Z]/)){\n            fail(\"bad escape \\\\\" + chr(special), pos)\n        }else{\n            return special\n        }\n    }\n}\n\nfunction check_character_range(t, positions){\n    // Check if last 2 items in t are a valid character range\n    var start = t[t.length - 2],\n        end = t[t.length - 1]\n    if(start instanceof CharacterClass || end instanceof CharacterClass){\n        fail(`bad character range ${start}-${end}`,\n            positions[positions.length - 2])\n    }else if(end < start){\n        fail(`bad character range ${start}-${end}`,\n            positions[positions.length - 2])\n    }\n    t.splice(t.length - 2, 2, {\n        type: 'character_range',\n        start: start,\n        end: end,\n        ord: [start.ord, end.ord]\n    })\n}\n\nfunction parse_character_set(text, pos, is_bytes){\n    // Parse character set starting at position \"pos\" in \"text\"\n    // pos is the position of the leading \"[\"\n    var start = pos,\n        result = {items: []},\n        positions = []\n    pos++\n    if(text[pos] == ord('^')){\n        result.neg = true\n        pos++\n    }else if(text[pos] == ord(']')){\n        // a leading ] is the character \"]\", not the set end\n        result.items.push(']')\n        positions.push(pos)\n        pos++\n    }else if(text[pos] == ord('[')){\n        // send FutureWarning\n        warn(_b_.FutureWarning, \"Possible nested set\", pos)\n    }\n    var range = false\n    while(pos < text.length){\n        var cp = text[pos],\n            char = chr(cp)\n        if(char == ']'){\n            if(pos == start + 2 && result.neg){\n                // in \"[^]]\", the first ] is the character \"]\"\n                result.items.push(']')\n            }else{\n                return [result, pos]\n            }\n        }\n        if(char == '\\\\'){\n            var escape = escaped_char({\n                    codepoints: text,\n                    pos,\n                    in_charset: true,\n                    is_bytes\n                })\n            if(typeof escape == \"number\"){\n                escape = {\n                    ord: escape,\n                    length: 2,\n                    toString: function(){\n                        return chr(escape)\n                    }\n                }\n            }\n            if(escape.type == \"num\"){\n                // [\\9] is invalid\n                fail(\"bad escape 1 \\\\\" +\n                    escape.value.toString()[0], pos)\n            }\n            result.items.push(escape)\n            positions.push(pos)\n            if(range){\n                check_character_range(result.items, positions)\n            }\n            range = false\n            pos += escape.length\n        }else if(char == '-'){\n            // Character range, or character \"-\"\n            if(pos == start + 1 ||\n                    (result.neg && pos == start + 2) ||\n                    pos == text.length - 1 ||\n                    range ||\n                    (result.items.length > 0 &&\n                    result.items[result.items.length - 1].type ==\n                        \"character_range\")){\n                result.items.push({\n                    ord: cp,\n                    char,\n                    toString: function(){\n                        return this.char\n                    }\n                })\n                if(text[pos + 1] == cp){\n                    warn(_b_.FutureWarning, \"Possible set difference\", pos)\n                }\n                pos++\n                if(range){\n                    check_character_range(result.items, positions)\n                }\n                range = false\n            }else{\n                range = true\n                if(text[pos + 1] == cp){\n                    warn(_b_.FutureWarning, \"Possible set difference\", pos)\n                }\n                pos++\n            }\n        }else{\n            positions.push(pos)\n            result.items.push({\n                ord: cp,\n                char,\n                toString: function(){\n                    return this.char\n                }\n            })\n            if(range){\n                check_character_range(result.items, positions)\n            }\n            range = false\n            // FutureWarning for consecutive \"&\", \"|\" or \"~\"\n            if(char == \"&\" && text[pos + 1] == cp){\n                warn(_b_.FutureWarning, \"Possible set intersection\", pos)\n            }else if(char == \"|\" && text[pos + 1] == cp){\n                warn(_b_.FutureWarning, \"Possible set union\", pos)\n            }else if(char == \"~\" && text[pos + 1] == cp){\n                warn(_b_.FutureWarning, \"Possible set symmetric difference\",\n                    pos)\n            }\n            pos++\n        }\n    }\n    fail(\"unterminated character set\", start)\n}\n\nfunction open_unicode_db(){\n    if($B.unicodedb === undefined){\n        var xhr = new XMLHttpRequest\n        xhr.open(\"GET\",\n            $B.brython_path + \"unicode.txt?\" + (new Date()).getTime(), false)\n        xhr.onreadystatechange = function(){\n            if(this.readyState == 4){\n                if(this.status == 200){\n                    $B.unicodedb = this.responseText\n                }else{\n                    console.log(\n                        \"Warning - could not load unicode.txt\")\n                }\n            }\n        }\n        xhr.send()\n    }\n}\n\nfunction validate_named_char(description){\n    // validate that \\N{<description>} is in the Unicode db\n    // Load unicode table if not already loaded\n    if(description.length == 0){\n        fail(\"missing character name\")\n    }\n    open_unicode_db()\n    if($B.unicodedb !== undefined){\n        var re = new RegExp(\"^([0-9A-F]+);\" +\n            description.toUpperCase() + \";.*$\", \"m\")\n        search = re.exec($B.unicodedb)\n        if(search === null){\n            fail(`undefined character name '${description}'`)\n        }\n        return eval(\"0x\" + search[1])\n    }else{\n        fail(\"could not load unicode.txt\")\n    }\n}\n\nvar cache = new Map()\n\nfunction compile(pattern, flags){\n    // data has attributes \"pattern\" (instance of StringObj)\n    // and \"type\" (\"str\" or \"bytes\")\n    if(pattern.__class__ === BPattern){\n        if(flags !== no_flag){\n            throw _b_.ValueError.$factory(\"no flags\")\n        }\n        return pattern\n    }\n    if(cache.has(pattern.py_obj)){\n        if(cache.get(pattern.py_obj).has(flags.value || 0)){\n            return cache.get(pattern.py_obj).get(flags.value || 0)\n        }\n    }\n    var original_pattern = pattern,\n        original_flags = flags,\n        type = pattern.type,\n        choices\n    pattern = pattern.codepoints\n    var is_bytes = type !== \"str\"\n    if(is_bytes && flags && (flags.value & U.value)){\n        throw _b_.ValueError.$factory(\"cannot use UNICODE flag with \" +\n            \"a bytes pattern\")\n    }\n    if(flags && (flags.value & U.value) &&\n            (flags.value & ASCII.value)){\n        throw _b_.ValueError.$factory(\"ASCII and UNICODE flags \" +\n            \"are incompatible\")\n    }\n    if(is_bytes){\n        // bytes patterns ignore re.ASCII flag\n        flags = Flag.$factory(flags.value || 0)\n        //flags.value &= ~ASCII.value\n    }\n    var group_num = 0,\n        group_stack = [],\n        groups = {},\n        pos,\n        lookbehind,\n        node = new Node(),\n        accept_inline_flag = true,\n        verbose = (flags.value || 0) & VERBOSE.value\n    node.$groups = groups\n    for(var item of tokenize(pattern, type, verbose)){\n        item.flags = flags\n        item.is_bytes = is_bytes\n        if(lookbehind){\n            item.lookbehind = lookbehind\n            lookbehind.parent = item\n            lookbehind = false\n        }\n        if(item instanceof Group){\n            group_stack.push(item)\n            node.add(item)\n            item.state = \"open\"\n            group_num++\n            item.num = group_num\n            node = item // next items will be stored as group's items\n            pos = item.pos\n            if(item.non_capturing){\n                delete item.num\n                group_num--\n            }else if(item.type == \"name_def\"){\n                var value = item.value\n                validate(value)\n                if(groups[value.string] !== undefined){\n                    fail(`redefinition of group name` +\n                        ` '${value.string}' as group ${group_num}; was group` +\n                        ` ${groups[value.string].num}`, pos)\n                }\n                item.name = value.string\n                groups[value.string] = groups[group_num] =\n                    new GroupRef(group_num, item)\n            }else if(item.is_lookahead){\n                // a lookahead assertion is relative to the previous regexp\n                group_num--\n                while(node.items.length > 0){\n                    item.add(node.items.shift())\n                }\n                node = item\n            }else if(item.is_lookbehind){\n                // a lookbehind assertion is relative to the next regexp\n                node.parent.items.pop() // remove from node items\n                // temporarily create a group\n                groups[group_num] = new GroupRef(group_num, item)\n            }else if(item.type == \"flags\"){\n                // save flags before a group with inline flags, eg \"(?i:a)\"\n                item.flags_before = Flag.$factory(flags.value | 0)\n            }else{\n                groups[group_num] = new GroupRef(group_num, item)\n            }\n        }else if(item instanceof GroupEnd){\n            end_pos = item.pos\n            if(group_stack.length == 0){\n                fail(\"unbalanced parenthesis\", end_pos, original_pattern)\n            }\n            var item = group_stack.pop()\n            item.end_pos = end_pos\n            try{\n                item.pattern = from_codepoint_list(\n                    pattern.slice(item.pos, end_pos + 1))\n            }catch(err){\n                console.log(\"err avec pattern substring\", pattern)\n                throw err\n            }\n            if(item.is_lookbehind){\n                delete groups[group_num]\n                group_num--\n                // check that all elements have a fixed length\n                item.length = item.fixed_length()\n                if(item.length === false){\n                    fail(\"look-behind requires fixed-width pattern\", pos)\n                }\n                item.parent.add(new Lookbehind(item))\n                item.non_capturing = true\n                // store in variable \"lookbehind\", will be applied to next item\n                lookbehind = item\n            }else if(item.is_lookahead){\n                delete item.num\n            }\n            if(item instanceof Group && item.items.length == 0){\n                item.add(new Char(pos, EmptyString, group_stack.concat([item])))\n            }else if(item instanceof ConditionalBackref){\n                if(item.re_if_exists.items.length == 0){\n                    item.re_if_exists.add(EmptyString)\n                }else if(item.re_if_not_exists.items.length == 0){\n                    item.re_if_not_exists.pos = pos\n                    item.re_if_not_exists.add(EmptyString)\n                }\n            }else if(item.type == \"flags\"){\n                // restore flags when entering the group\n                flags = Flag.$factory(item.flags_before.value)\n            }\n            item.state = 'closed'\n            node = item.parent\n        }else if(item instanceof ConditionalBackref){\n            var pos = item.pos,\n                group_ref = item.group_ref\n            if(typeof group_ref == \"number\"){\n                if(group_ref == 0){\n                    fail(`bad group number`, pos + 3)\n                }else if(group_ref >= MAXGROUPS){\n                    fail(`invalid group reference ${group_ref}`, pos + 1)\n                }else if(groups[group_ref] &&\n                        groups[group_ref].item.state == \"open\"){\n                    fail(\"cannot refer to an open group\", pos)\n                }\n            }else if(groups[group_ref] !== undefined){\n                if(groups[group_ref].item.state == \"open\"){\n                    fail(\"cannot refer to an open group\", pos)\n                }\n            }else{\n                fail(`unknown group name '${group_ref}'`, pos)\n            }\n            group_stack.push(item)\n            node.add(item)\n            item.state = \"open\"\n            node = item // next items will be stored as group's items\n        }else if(item instanceof BackReference){\n            pos = item.pos\n            if(item.type == \"num\" && item.value > 99){\n                var head = item.value.toString().substr(0, 2)\n                fail(`invalid group reference ${head}`, pos + 1)\n            }\n            if(groups[item.value] !== undefined){\n                if(groups[item.value].item.state == \"open\"){\n                    fail(\"cannot refer to an open group\", pos)\n                }\n                var ref_item = groups[item.value].item.parent\n                while(ref_item){\n                    if(ref_item.is_lookbehind){\n                        fail(\"cannot refer to group defined in the same lookbehind subpattern\", pos)\n                    }\n                    ref_item = ref_item.parent\n                }\n            }else if(item.type == \"name\"){\n                fail(`unknown group name '${item.value}'`, pos)\n            }else if(item.type == \"num\"){\n                fail(`invalid group reference ${item.value}`, pos)\n            }\n            node.add(item)\n        }else if(item instanceof Char ||\n                item instanceof CharacterClass ||\n                item instanceof CharacterSet){\n            if(item instanceof CharacterSet){\n                for(var elt of item.set.items){\n                    elt.flags = flags\n                }\n            }\n            var added_to_charseq = false\n            if(item instanceof Char){\n                if(node.items && node.items.length > 0){\n                    var previous = $last(node.items)\n                    if(previous instanceof CharSeq){\n                        previous.chars.push(item)\n                        added_to_charseq = true\n                    }else if(previous instanceof Char){\n                        node.items.pop()\n                        node.items.push(new CharSeq([previous, item]))\n                        added_to_charseq = true\n                    }\n                }\n            }\n            if(! added_to_charseq){\n                node.add(item)\n            }\n        }else if(item instanceof Repeater){\n            // check that item is not in a lookbehind group\n            var pnode = node\n            while(pnode){\n                if(pnode.extension && pnode.extension.type &&\n                        pnode.extension.type.indexOf(\"lookbehind\") > -1){\n                    fail(\"look-behind requires fixed-width pattern\", pos)\n                }\n                pnode = pnode.parent\n            }\n            pos = item.pos\n            if(node.items.length == 0){\n                fail(\"nothing to repeat\", pos)\n            }\n            previous = $last(node.items)\n            if(previous instanceof Char ||\n                    previous instanceof CharSeq ||\n                    previous instanceof CharacterClass ||\n                    previous instanceof CharacterSet ||\n                    previous instanceof Group ||\n                    previous instanceof BackReference){\n                if(previous instanceof GroupEnd){\n                    // associate repeat with Group\n                    previous = previous.group\n                }else if(previous instanceof CharSeq){\n                    previous = $last(previous.chars)\n                }\n                if(previous.repeater){\n                    if(item.op == '?' && ! previous.non_greedy){\n                        previous.non_greedy = true\n                        if(previous instanceof CharacterClass &&\n                                previous.value == '.'){\n                            previous.min_repeat_one = true\n                        }\n                    }else{\n                        fail(\"multiple repeat\", pos)\n                    }\n                }else{\n                    // convert to minimum and maximum number of repeats\n                    var min = 1,\n                        max = 1\n                    if(Array.isArray(item.op)){\n                        min = item.op[0]\n                        if(min >= MAXREPEAT){\n                            throw _b_.OverflowError.$factory(\n                                \"the repetition number is too large\")\n                        }\n                        max = item.op[1] === undefined ? min : item.op[1]\n                        if(isFinite(max) && max >= MAXREPEAT){\n                            throw _b_.OverflowError.$factory(\n                                \"the repetition number is too large\")\n                        }\n                        if(max < min){\n                            fail('min repeat greater than max repeat', pos)\n                        }\n                    }else if(item.op == \"?\"){\n                        min = 0\n                        max = 1\n                    }else if(item.op == \"*\"){\n                        min = 0\n                        max = Number.POSITIVE_INFINITY\n                    }else if(item.op == \"+\"){\n                        min = 1\n                        max = Number.POSITIVE_INFINITY\n                    }\n                    previous.repeater = item\n                    previous.repeat = {min, max}\n                    // mark all parents of item as no fixed length\n                    var parent = item\n                    while(parent){\n                        parent.fixed_length = false\n                        parent = parent.parent\n                    }\n                }\n            }else{\n                fail(\"nothing to repeat\", pos)\n            }\n        }else if(item instanceof Or){\n            if(group_stack.length > 0){\n                item.group = group_stack[group_stack.length - 1]\n            }else{\n                item.group = false\n            }\n            pos = item.pos\n            if(node instanceof ConditionalBackref){\n                // case '(?(num)a|'\n                if(node.nb_options == 1){\n                    node.nb_options++\n                }else{\n                    fail('conditional backref with more than ' +\n                       'two branches', pos)\n                }\n            }else if(node.items.length == 0){\n                // token \"|\" in  \"(|...)\" : first option is the empty string\n                var choice = new Choice(),\n                    case1 = new Case()\n                case1.add(new Char(pos, EmptyString))\n                choice.add(case1)\n                node.add(choice)\n                var case2 = new Case()\n                choice.add(case2)\n                node = case2\n            }else if(node instanceof Case){\n                // node.parent is already a Choice\n                var new_case = new Case()\n                node.parent.add(new_case)\n                node = new_case\n            }else{\n                // token \"|\" in \"(ab|...)\"\n                var previous = node.items[node.items.length - 1]\n                if(previous instanceof Case){\n                    var new_case = new Case()\n                    previous.add(new_case)\n                    node = new_case\n                }else{\n                    var choice = new Choice(),\n                        case1 = new Case(),\n                        first_rank = node.items[0].rank\n                    while(node.items.length > 0){\n                        case1.add(node.items.shift())\n                    }\n                    case1.groups = node.$groups\n                    for(var group of group_stack){\n                        choice.groups.push(group)\n                    }\n                    choice.add(case1)\n                    node.add(choice)\n                    var case2 = new Case()\n                    choice.add(case2)\n                    node = case2\n                }\n            }\n        }else if(item instanceof StringStart ||\n                 item instanceof StringEnd){\n            node.add(item)\n        }else if(item instanceof SetFlags){\n            // copy flags, otherwise re.ASCII etc might be modified\n            flags = Flag.$factory(flags.value || U.value)\n            if(item.on_flags.indexOf('u') > -1){\n                if(is_bytes){\n                    fail(\"re.error: bad inline flags: cannot use 'u' flag \" +\n                        \"with a bytes pattern\", pos)\n                }\n                if(flags && flags.value & ASCII.value){\n                    // switch to Unicode\n                    flags.value ^= ASCII.value\n                }\n                if(group_stack.length == 0 &&\n                        original_flags && original_flags.value & ASCII.value){\n                    throw _b_.ValueError.$factory(\"ASCII and UNICODE flags \" +\n                        \"are incompatible\")\n                }\n                if(item.on_flags.indexOf('a') > -1){\n                    throw _b_.ValueError.$factory(\"ASCII and UNICODE flags \" +\n                        \"are incompatible\")\n                }\n            }else if(item.on_flags.indexOf('a') > -1){\n                if(group_stack.length == 0 &&\n                        original_flags && original_flags.value & U.value){\n                    throw _b_.ValueError.$factory(\"ASCII and UNICODE flags \" +\n                        \"are incompatible\")\n                }\n                if(flags && flags.value & U.value){\n                    // switch to ASCII\n                    flags.value ^= U.value\n                }\n                if(item.on_flags.indexOf('u') > -1){\n                    throw _b_.ValueError.$factory(\"ASCII and UNICODE flags \" +\n                        \"are incompatible\")\n                }\n            }\n            if(flags.value === undefined){\n                flags.value = 32\n            }\n            if(item.items.length == 0){\n                if(! accept_inline_flag && group_stack.length == 0){\n                    var s = from_codepoint_list(pattern)\n                    warn(_b_.DeprecationWarning,\n                        `Flags not at the start of the expression '${s}'`,\n                        pos)\n                }\n                for(var on_flag of item.on_flags){\n                    if(! is_bytes || on_flag !== 'a'){\n                        flags.value |= inline_flags[on_flag].value\n                    }\n                }\n                for(var off_flag of item.off_flags){\n                    if(! is_bytes || off_flag !== 'a'){\n                        flags.value ^= inline_flags[off_flag].value\n                    }\n                }\n            }else{\n                node.add(item)\n            }\n        }else{\n            fail(\"unknown item type \" + item, pos)\n        }\n        if(! (item instanceof SetFlags) &&\n                ! (item instanceof Group && item.type == \"flags\")){\n            accept_inline_flag = false\n        }\n    }\n    if(group_stack.length > 0){\n        var last = group_stack[group_stack.length - 1]\n        fail(\"missing ), unterminated subpattern\", last.pos)\n    }\n    while(node.parent){\n        node = node.parent\n    }\n    node.pattern = from_codepoint_list(pattern)\n    node.groups = group_num\n    flags = flags === no_flag ? 32 : flags\n    node.flags = flags\n    var res = {\n        node,\n        groups,\n        flags,\n        original_flags,\n        text: from_codepoint_list(pattern),\n        type, // \"str\" or \"bytes\"\n        fixed_length: node.fixed_length()\n    }\n    if(! cache.has(original_pattern.py_obj)){\n        cache.set(original_pattern.py_obj, new Map())\n    }\n    cache.get(original_pattern.py_obj).set(original_flags.value || 0, res)\n    show(node)\n    return res\n}\n\nfunction show(node, indent){\n    indent = indent === undefined ? 0 : indent\n    if(indent == 0){\n        log('root', node)\n    }\n    log(' '.repeat(indent) + node)\n    if(node.items !== undefined){\n        for(var item of node.items){\n            show(item, indent + 1)\n        }\n    }\n}\n\nfunction ord(char){\n    return char.charCodeAt(0)\n}\n\nfunction* tokenize(pattern, type, _verbose){\n    // pattern is a list of codepoints\n    var is_bytes = type == \"bytes\"\n    // verbose_stack is the stack of verbose state for each group in the regex\n    var verbose_stack = [_verbose],\n        verbose = _verbose\n    var pos = 0\n    while(pos < pattern.length){\n        var cp = pattern[pos],\n            char = String.fromCharCode(cp)\n        if(verbose){\n            // current group is in verbose mode\n            if(char == \"#\"){\n                // skip until next line feed\n                while(pos < pattern.length && pattern[pos] != 10){\n                    pos++\n                }\n                pos++\n                continue\n            }else{\n                while(pos < pattern.length &&\n                        [9, 10, 11, 12, 13, 32].indexOf(pattern[pos]) > -1){\n                    pos++\n                }\n            }\n            cp = pattern[pos]\n            if(cp === undefined){\n                break\n            }\n            char = String.fromCharCode(cp)\n            if(char == '#'){\n                continue\n            }\n        }\n        if(char == '('){\n            if(pattern[pos + 1] == ord('?')){\n                if(pattern[pos + 2] == ord('P')){\n                    if(pattern[pos + 3] == ord('<')){\n                        var name = [],\n                            i = pos + 4\n                        while(i < pattern.length){\n                            if(pattern[i] == ord('>')){\n                                break\n                            }else if(pattern[i] == ord(')')){\n                                fail(\"missing >, unterminated name\", pos)\n                            }\n                            name.push(pattern[i])\n                            i++\n                        }\n                        name = StringObj.from_codepoints(name)\n                        validate(name)\n                        if(i == pattern.length){\n                            fail(\"missing >, unterminated name\", pos)\n                        }\n                        yield new Group(pos, {type: 'name_def', value: name})\n                        verbose_stack.push(verbose)\n                        pos = i + 1\n                        continue\n                    }else if(pattern[pos + 3] == ord('=')){\n                        var name = [],\n                            i = pos + 4\n                        while(i < pattern.length){\n                            if(pattern[i] == ord(')')){\n                                break\n                            }\n                            name.push(pattern[i])\n                            i++\n                        }\n                        name = StringObj.from_codepoints(name)\n                        validate(name)\n                        if(i == pattern.length){\n                            fail(\"missing ), unterminated name\", pos)\n                        }\n                        yield new BackReference(pos, 'name', name.string)\n                        pos = i + 1\n                        continue\n                    }else if(pattern[pos + 3] === undefined){\n                        fail(\"unexpected end of pattern\", pos)\n                    }else{\n                        fail(\"unknown extension ?P\" + chr(pattern[pos + 3]), pos)\n                    }\n                }else if(pattern[pos + 2] == ord('(')){\n                    var ref = [],\n                        i = pos + 3\n                    while(i < pattern.length){\n                        if(pattern[i] == ord(')')){\n                            break\n                        }\n                        ref.push(pattern[i])\n                        i++\n                    }\n                    var sref = StringObj.from_codepoints(ref)\n                    if(sref.string.match(/^\\d+$/)){\n                        ref = parseInt(sref.string)\n                    }else{\n                        validate(sref)\n                        ref = sref.string\n                    }\n                    if(i == pattern.length){\n                        fail(\"missing ), unterminated name\", pos)\n                    }\n                    yield new ConditionalBackref(pos, ref)\n                    pos = i + 1\n                    continue\n                }else if(pattern[pos + 2] == ord('=')){\n                    // (?=...) : lookahead assertion\n                    yield new Group(pos, {type: 'lookahead_assertion'})\n                    verbose_stack.push(verbose)\n                    pos += 3\n                    continue\n                }else if(pattern[pos + 2] == ord('!')){\n                    // (?!...) : negative lookahead assertion\n                    yield new Group(pos, {type: 'negative_lookahead_assertion'})\n                    verbose_stack.push(verbose)\n                    pos += 3\n                    continue\n                }else if(from_codepoint_list(pattern.slice(pos + 2, pos + 4)) == '<!'){\n                    // (?<!...) : negative lookbehind\n                    yield new Group(pos, {type: 'negative_lookbehind'})\n                    verbose_stack.push(verbose)\n                    pos += 4\n                    continue\n                }else if(from_codepoint_list(pattern.slice(pos + 2, pos + 4)) == '<='){\n                    // (?<=...) : positive lookbehind\n                    yield new Group(pos, {type: 'positive_lookbehind'})\n                    verbose_stack.push(verbose)\n                    pos += 4\n                    continue\n                }else if(pattern[pos + 2] == ord('<')){\n                    pos += 3\n                    if(pos == pattern.length){\n                        fail(\"unexpected end of pattern\", pos)\n                    }\n                    fail(\"unknown extension ?<\" + _b_.chr(pattern[pos]), pos)\n                }else if(pattern[pos + 2] == ord(':')){\n                    yield new Group(pos, {non_capturing: true})\n                    verbose_stack.push(verbose)\n                    pos += 3\n                    continue\n                }else if(pattern[pos + 2] === undefined){\n                    fail(\"unexpected end of pattern\", pos)\n                }\n\n                var flags = to_codepoint_list('aiLmsux'),\n                    auL_flags = to_codepoint_list('auL'),\n                    flags_start = pos\n                if(pattern[pos + 2] == ord('-') ||\n                        flags.indexOf(pattern[pos + 2]) > -1){\n                    if(pattern[pos + 2] == ord('-')){\n                        var on_flags = [],\n                            has_off = true,\n                            off_flags = []\n                        pos += 3\n                    }else{\n                        var on_flags = [chr(pattern[pos + 2])],\n                            has_off = false,\n                            off_flags = [],\n                            auL = auL_flags.indexOf(pattern[pos + 2]) > -1 ?\n                                1 : 0,\n                            closed = false\n                        pos += 3\n                        while(pos < pattern.length){\n                            if(flags.indexOf(pattern[pos]) > -1){\n                                if(auL_flags.indexOf(pattern[pos]) > -1){\n                                    auL++\n                                    if(auL > 1){\n                                        fail(\"bad inline flags: flags 'a', 'u'\" +\n                                            \" and 'L' are incompatible\", pos)\n                                    }\n                                }\n                                on_flags.push(chr(pattern[pos]))\n                                pos++\n                            }else if(pattern[pos] == ord('-')){\n                                has_off = true\n                                closed = true\n                                pos++\n                                break\n                            }else if(String.fromCharCode(pattern[pos]).\n                                    match(/[a-zA-Z]/)){\n                                fail(\"unknown flag\", pos)\n                            }else if(pattern[pos] == ord(')')){\n                                closed = true\n                                break\n                            }else if(pattern[pos] == ord(':')){\n                                yield new Group(pos, {name: \"Group\", type: \"flags\"})\n                                verbose_stack.push(verbose)\n                                closed = true\n                                break\n                            }else{\n                                fail(\"missing -, : or )\", pos)\n                            }\n                        }\n                        if(! closed){\n                            fail(\"missing -, : or )\", pos)\n                        }\n                    }\n                    if(has_off){\n                        while(pos < pattern.length){\n                            if(flags.indexOf(pattern[pos]) > -1){\n                                if(auL_flags.indexOf(pattern[pos]) > -1){\n                                    fail(\"bad inline flags: cannot turn off \" +\n                                        \"flags 'a', 'u' and 'L'\", pos)\n                                }\n                                if(on_flags.indexOf(chr(pattern[pos])) > -1){\n                                    fail(\"bad inline flags: flag turned on and off\", pos)\n                                }\n                                off_flags.push(chr(pattern[pos]))\n                                pos++\n                            }else if(pattern[pos] == ord(':')){\n                                yield new Group(pos, {name: \"Group\", type: \"flags\"})\n                                verbose_stack.push(verbose)\n                                break\n                            }else if(String.fromCharCode(pattern[pos]).\n                                    match(/[a-zA-Z]/)){\n                                fail(\"unknown flag\", pos)\n                            }else if(off_flags.length == 0){\n                                fail(\"missing flag\", pos)\n                            }else{\n                                fail(\"missing :\", pos)\n                            }\n                        }\n                        if(off_flags.length == 0){\n                            fail(\"missing flag\", pos)\n                        }\n                    }\n                    if(has_off && pattern[pos] != ord(':')){\n                        fail(\"missing :\", pos)\n                    }\n                    if(on_flags.length == 0 && off_flags.length == 0){\n                        fail(\"missing flag\", pos)\n                    }\n                    var set_flags = new SetFlags(flags_start,\n                        {on_flags, off_flags})\n                    yield set_flags\n                    // reset verbose\n                    if(on_flags.indexOf('x') > -1){\n                        verbose = true\n                    }\n                    if(off_flags.indexOf('x') > -1){\n                        verbose = false\n                    }\n                    if(! closed){\n                        node = set_flags\n                    }\n                    pos++\n                }else if(pattern[pos + 2] == ord('#')){\n                    pos += 3\n                    while(pos < pattern.length){\n                        if(pattern[pos] == ord(')')){\n                            break\n                        }\n                        pos++\n                    }\n                    if(pos == pattern.length){\n                        fail(\"missing ), unterminated comment\", pos)\n                    }\n                    pos++\n                    continue\n                }else{\n                    fail(\"unknown extension ?\" + _b_.chr(pattern[pos + 2]),\n                        pos)\n                }\n            }else{\n                yield new Group(pos)\n                verbose_stack.push(verbose)\n                pos++\n            }\n        }else if(cp == ord(')')){\n            yield new GroupEnd(pos)\n            verbose_stack.pop()\n            verbose = $last(verbose_stack)\n            pos++\n        }else if(cp == ord('\\\\')){\n            var escape = escaped_char({codepoints: pattern, pos, is_bytes})\n            if(escape instanceof CharacterClass){\n                yield escape\n                pos += escape.length\n            }else if(escape.char !== undefined){\n                yield new Char(pos, escape.ord)\n                pos += escape.length\n            }else if(escape.type == \"backref\"){\n                yield new BackReference(pos, \"num\", escape.value)\n                pos += escape.length\n            }else if(typeof escape == \"number\"){\n                // eg \"\\.\"\n                var esc = new Char(pos, escape)\n                esc.escaped = true\n                yield esc\n                pos += 2\n            }else{\n                yield new Char(pos, escape)\n                pos += escape.length\n            }\n        }else if(cp == ord('[')){\n            // Set of characters\n            var set,\n                end_pos\n            [set, end_pos] = parse_character_set(pattern, pos, is_bytes)\n            yield new CharacterSet(pos, set)\n            pos = end_pos + 1\n        }else if('+?*'.indexOf(char) > -1){\n            yield new Repeater(pos, char)\n            pos++\n        }else if(cp == ord('{')){\n            var reps = /\\{(\\d*)((,)(\\d*))?\\}/.exec(\n                    from_codepoint_list(pattern.slice(pos)))\n            if(reps && reps[0] != '{}'){\n                if(reps[1] == \"\"){\n                    var limits = [0]\n                }else{\n                    var limits = [parseInt(reps[1])]\n                }\n                if(reps[4] !== undefined){\n                    if(reps[4] == \"\"){\n                        var max = Number.POSITIVE_INFINITY\n                    }else{\n                        var max = parseInt(reps[4])\n                    }\n                    limits.push(max)\n                }\n                yield new Repeater(pos, limits)\n                pos += reps[0].length\n            }else if(pattern[pos + 1] == ord('}')){\n                // {} is the characters \"{\" and \"}\"\n                yield new Char(pos, ord('{'))\n                pos++\n            }else{\n                yield new Char(pos, ord('{'))\n                pos++\n            }\n        }else if(cp == ord('|')){\n            yield new Or(pos)\n            pos++\n        }else if(cp == ord('.')){\n            yield new CharacterClass(pos, cp, 1)\n            pos++\n        }else if(cp == ord('^')){\n            yield new StringStart(pos)\n            pos++\n        }else if(cp == ord('$')){\n            yield new StringEnd(pos)\n            pos++\n        }else{\n            yield new Char(pos, cp)\n            pos++\n        }\n    }\n}\n\nfunction to_codepoint_list(s){\n    var items = []\n    if(typeof s == \"string\" || _b_.isinstance(s, _b_.str)){\n        if(typeof s != \"string\"){\n            s = s.valueOf()\n        }\n        for(const char of s){\n            items.push(char.codePointAt(0))\n        }\n        items.type = \"unicode\"\n    }else if(_b_.isinstance(s, bytes_like)){\n        if(_b_.isinstance(s, _b_.memoryview)){\n            items = s.obj.source\n        }else{\n            items = s.source\n        }\n        items.type = \"bytes\"\n    }else{\n        throw Error('invalid type ' + $B.class_name(s))\n    }\n    return items\n}\n\nfunction from_codepoint_list(codepoints, type){\n    // Return a string\n    if(type == \"bytes\"){\n        return _b_.bytes.$factory(codepoints)\n    }\n    var s = ''\n    for(const cp of codepoints){\n        s += _b_.chr(cp)\n    }\n    return $B.String(s)\n}\n\nvar GroupDict = $B.make_class(\"GroupDict\")\nGroupDict.__mro__ = [_b_.dict, _b_.object]\nGroupDict.__setitem__ = function(){\n    throw _b_.TypeError.$factory(\"read only\")\n}\n\n\nvar bytes_like = [_b_.bytes, _b_.bytearray, _b_.memoryview]\n\nfunction string2bytes(s){\n    var t = []\n    for(var i = 0, len = s.length; i < len; i++){\n        t.push(s.charCodeAt(i))\n    }\n    return _b_.bytes.$factory(t)\n}\n\nfunction check_pattern_flags(pattern, flags){\n    if(pattern.__class__ === BPattern){\n        if(flags !== no_flag){\n            throw _b_.ValueError.$factory(\n                \"cannot process flags argument with a compiled pattern\")\n        }\n    }\n    return pattern\n}\n\nfunction transform_repl(data, pattern){\n    // data.repl is a StringObj instance\n    var repl = data.repl.string\n    repl = repl.replace(/\\\\n/g, '\\n')\n    repl = repl.replace(/\\\\r/g, '\\r')\n    repl = repl.replace(/\\\\t/g, '\\t')\n    repl = repl.replace(/\\\\b/g, '\\b')\n    repl = repl.replace(/\\\\v/g, '\\v')\n    repl = repl.replace(/\\\\f/g, '\\f')\n    repl = repl.replace(/\\\\a/g, '\\a')\n    // detect backreferences\n    var pos = 0,\n        escaped = false,\n        br = false,\n        repl1 = \"\",\n        has_backref = false\n    while(pos < repl.length){\n        br = false\n        if(repl[pos] == \"\\\\\"){\n            escaped = ! escaped\n            if(escaped){\n                pos++\n                continue\n            }\n        }else if(escaped){\n            escaped = false\n            var mo = /^\\d+/.exec(repl.substr(pos))\n            if(mo){\n                var cps = to_codepoint_list(repl)\n                var escape = escaped_char({\n                        codepoints: cps,\n                        pos: pos - 1,\n                        is_bytes: cps.type == \"bytes\"\n                     })\n                if(escape.type == \"o\"){\n                    if(escape.ord > 0o377){\n                        fail(`octal escape value \\\\${mo[0]} ` +\n                            \" outside of range 0-0o377\", pos)\n                    }\n                    repl1 += escape.char\n                    pos += escape.length - 1\n                    continue\n                }else if(escape.type != \"backref\"){\n                    var group_num = mo[0].substr(0,\n                        Math.min(2, mo[0].length))\n                    fail(`invalid group reference ${group_num}`, pos)\n                }else{\n                    // only keep first 2 digits\n                    var group_num = mo[0].substr(0,\n                        Math.min(2, mo[0].length))\n                    // check that pattern has the specified group num\n                    if(pattern.groups === undefined){\n                        console.log(\"pattern\", pattern)\n                        throw _b_.AttributeError.$factory(\"$groups\")\n                    }\n                    if(pattern.groups[group_num] === undefined){\n                        fail(`invalid group reference ${group_num}`,\n                            pos)\n                    }else{\n                        mo[0] = group_num\n                    }\n                }\n                if(! has_backref){\n                    var parts = [repl.substr(0, pos - 1),\n                            parseInt(mo[0])]\n                }else{\n                    parts.push(repl.substring(next_pos, pos - 1))\n                    parts.push(parseInt(mo[0]))\n                }\n                has_backref = true\n                var next_pos = pos + mo[0].length\n                br = true\n                pos += mo[0].length\n            }else if(repl[pos] == \"g\"){\n                pos++\n                if(repl[pos] != '<'){\n                    fail(\"missing <\", pos)\n                }\n                pos++\n                mo = /(.*?)>/.exec(repl.substr(pos))\n                if(mo){\n                    if(mo[1] == \"\"){\n                        pos += mo[0].length\n                        fail(\"missing group name\", pos - 1)\n                    }\n                    var group_name = mo[1]\n                    if(/^\\d+$/.exec(group_name)){\n                        if(pattern.groups[group_name] === undefined){\n                            fail(`invalid group reference ${group_name}`,\n                                pos)\n                        }\n                    }else{\n                        if(! _b_.str.isidentifier(group_name)){\n                            var cps = to_codepoint_list(group_name)\n                            if($B.unicode_tables.XID_Start[cps[0]] === undefined){\n                                fail(\"bad character in group name '\" +\n                                    group_name + \"'\", pos)\n                            }else{\n                                for(cp of cps.slice(1)){\n                                    if($B.unicode_tables.XID_Continue[cp] === undefined){\n                                        fail(\"bad character in group name '\" +\n                                            group_name + \"'\", pos)\n                                    }\n                                }\n                            }\n                        }\n                        if(pattern.groups[group_name] === undefined){\n                            throw _b_.IndexError.$factory(\n                                `unknown group name '${group_name}'`,\n                                pos)\n                        }\n                    }\n                    if(! has_backref){\n                        var parts = [repl.substr(0, pos - 3),\n                                mo[1]]\n                    }else{\n                        parts.push(repl.substring(next_pos, pos - 3))\n                        parts.push(mo[1])\n                    }\n                    has_backref = true\n                    var next_pos = pos + mo[0].length\n                    br = true\n                    pos = next_pos\n                }else{\n                    if(repl.substr(pos).length > 0){\n                        fail(\"missing >, unterminated name\", pos)\n                    }else{\n                        fail(\"missing group name\", pos)\n                    }\n                }\n            }else{\n                if(/[a-zA-Z]/.exec(repl[pos])){\n                    fail(\"unknown escape\", pos)\n                }\n                pos += repl[pos]\n            }\n        }\n        if(! br){\n            repl1 += repl[pos]\n            pos ++\n        }\n    }\n    data.repl1 = repl1\n    if(has_backref){\n        parts.push(repl.substr(next_pos))\n        data.repl = function(bmo){\n            var mo = bmo.mo,\n                res = parts[0],\n                groups = mo.$groups,\n                s = mo.string,\n                group\n            for(var i = 1, len = parts.length; i < len; i += 2){\n                if(groups[parts[i]] === undefined){\n                    if(mo.node.$groups[parts[i]] !== undefined){\n                        // group is defined in the RE, but didn't contribute\n                        // to the match\n                        // groups[parts[i]] = ''\n                    }else{\n                        // group is not defined in the RE\n                        pos++\n                        group_num = parts[i].toString().substr(0, 2)\n                        fail(`invalid group reference ${group_num}`, pos)\n                    }\n                }else{\n                    group = groups[parts[i]]\n                    res += s.substring(group.start, group.end)\n                }\n                res += parts[i + 1]\n            }\n            return res\n        }\n    }else{\n        data.repl = new StringObj(repl)\n    }\n    return data\n}\n\nfunction StringObj(obj){\n    // A StringObj object is a bridge between a Python string or bytes-like\n    // object and Javascript\n    // obj is the Python object\n    // this.string is a Javascript string\n    this.py_obj = obj\n    this.codepoints = []\n    this.type = \"str\"\n    if(typeof obj == \"string\" ||\n            (obj instanceof String && ! obj.codepoints)){\n        // Python object represented as a Javascript string\n        this.string = obj\n        // Maps a position in codepoints to position in string\n        this.index_map = {}\n        for(var i = 0, len = obj.length; i < len; i++){\n            this.index_map[this.codepoints.length] = i\n            var cp = obj.codePointAt(i)\n            this.codepoints.push(cp)\n            if(cp >= 0x10000){\n                i++\n            }\n        }\n        if(obj instanceof String){\n            // store for next use\n            obj.codepoints = this.codepoints\n            obj.index_map = this.index_map\n        }\n    }else if(obj instanceof String){\n        // string with surrogate pairs\n        this.string = obj.string\n        this.codepoints = obj.codepoints\n        this.index_map = obj.index_map\n    }else if(_b_.isinstance(obj, _b_.str)){ // str subclass\n        var so = new StringObj(obj.valueOf())\n        this.string = so.string\n        this.codepoints = so.codepoints\n    }else if(_b_.isinstance(obj, [_b_.bytes, _b_.bytearray])){\n        this.string = _b_.bytes.decode(obj, 'latin1')\n        this.codepoints = obj.source\n        this.type = \"bytes\"\n    }else if(_b_.isinstance(obj, _b_.memoryview)){\n        this.string = _b_.bytes.decode(obj.obj, 'latin1')\n        this.codepoints = obj.obj.source\n        this.type = \"bytes\"\n    }else if(obj.__class__ && obj.__class__.$buffer_protocol){\n        // eg array.array\n        this.codepoints = _b_.list.$factory(obj)\n        this.string = from_codepoint_list(this.codepoints, \"bytes\")\n        this.type = \"bytes\"\n    }else if(Array.isArray(obj)){\n        // list of codepoints\n        this.codepoints = obj\n    }else{\n        throw _b_.TypeError.$factory(\n            'expected string or bytes-like object')\n    }\n    this.length = this.codepoints.length\n}\n\nStringObj.prototype.substring = function(start, end){\n    // Returns a string\n    var s\n    if(this.string && this.index_map){\n        if(this.index_map[start] === undefined){\n            return ''\n        }\n        if(end === undefined){\n            return this.string.substr(this.index_map[start])\n        }\n        return this.string.substring(this.index_map[start],\n            this.index_map[end])\n    }\n    var codepoints,\n        res = ''\n    if(end === undefined){\n        codepoints = this.codepoints.slice(start)\n    }else{\n        codepoints = this.codepoints.slice(start, end)\n    }\n    return from_codepoint_list(codepoints, this.type)\n}\n\nStringObj.prototype.to_str = function(){\n    return from_codepoint_list(this.codepoints, this.type)\n}\n\nStringObj.from_codepoints = function(cps){\n    var res = new StringObj('')\n    res.codepoints = cps\n    for(var cp of cps){\n        res.string += _b_.chr(cp)\n    }\n    return res\n}\n\nfunction prepare(args){\n    // Check that all arguments are of the same type (string of bytes-like)\n    // Return an object with all attributes transformed into CodePoints\n    // instances\n    var res = {},\n        keys = Object.keys(args),\n        first = keys[0]\n    res[first] = new StringObj(args[first])\n    res.type = res[first].type\n    for(var key of keys.slice(1)){\n        res[key] = new StringObj(args[key])\n        if(res[key].type != res.type){\n            throw _b_.TypeError.$factory(`not the same type for ${first} and ${key}`)\n        }\n    }\n    return res\n}\n\nfunction subn(pattern, repl, string, count, flags){\n    // string is a StringObj instance\n    // pattern is either a Pattern instance or a StringObj instance\n    var res = '',\n        pos = 0,\n        nb_sub = 0\n\n    if(pattern instanceof StringObj){\n        pattern = compile(pattern, flags)\n    }\n    if(typeof repl != \"function\"){\n        var data1 = transform_repl({repl}, pattern)\n        repl1 = data1.repl1\n    }\n    pos = 0\n    for(var bmo of $module.finditer(BPattern.$factory(pattern), string.to_str()).js_gen){\n        // finditer yields instances of BMatchObject\n        var mo = bmo.mo // instance of MatchObject\n        res += from_codepoint_list(string.codepoints.slice(pos, mo.start),\n            string.type)\n        if(typeof repl == \"function\"){\n            res += $B.$call(repl)(bmo)\n        }else{\n            res += repl1\n        }\n        nb_sub++\n        pos = mo.end\n        if(pos >= string.length){\n            break\n        }\n        if(count != 0 && nb_sub >= count){\n            break\n        }\n    }\n    res += from_codepoint_list(string.codepoints.slice(pos),\n        string.type)\n    if(pattern.type === \"bytes\"){\n        res = _b_.str.encode(res, \"latin-1\")\n    }\n    return [res, nb_sub]\n}\n\n// escaped chars : '\\t\\n\\x0b\\x0c\\r #$&()*+-.?[\\\\]^{|}~'\nvar escaped = [9, 10, 11, 12, 13, 32, 35, 36, 38, 40, 41, 42, 43, 45, 46, 63,\n               91, 92, 93, 94, 123, 124, 125, 126]\n\nfunction* iterator(pattern, string, flags, original_string, pos, endpos){\n    var result = [],\n        pos = pos | 0\n    while(pos <= string.length){\n        var mo = match(pattern, string, pos, endpos)\n        if(mo){\n            yield BMO.$factory(mo)\n            if(mo.end == mo.start){\n                // If match has zero with, retry at the same position but\n                // with the flag no_zero_width set, to avoid infinite loops\n                mo = match(pattern, string, pos, endpos, true)\n                if(mo){\n                    yield BMO.$factory(mo)\n                    pos = mo.end\n                }else{\n                    pos++ // at least 1, else infinite loop\n                }\n            }else{\n                pos = mo.end\n            }\n        }else{\n            pos++\n        }\n    }\n    delete original_string.in_iteration\n}\n\nvar _debug = {value: false}\n\nfunction MO(node, pos, mo, len){\n    this.node = node\n    this.start = pos\n    this.mo = mo\n    this.nb_min = mo.nb_min\n    this.nb_max = mo.nb_max\n    this.len = len\n    this.nb = this.node.non_greedy ? mo.nb_min : mo.nb_max\n    this.end = pos + len * this.nb\n}\n\nMO.prototype.backtrack = function(string, groups){\n    if(this.node.non_greedy && this.nb < this.nb_max){\n        this.nb++\n        this.end = this.start + this.len * this.nb\n        return true\n    }else if(! this.node.non_greedy && this.nb > this.nb_min){\n        this.nb--\n        this.end = this.start + this.len * this.nb\n        return true\n    }else{\n        return false\n    }\n}\n\nfunction del_groups(groups, node){\n    if(node.num !== undefined){\n        delete groups[node.num]\n        groups.$last.splice(groups.$last.indexOf(node.num), 1)\n        if(node.name !== undefined){\n            delete groups[node.name]\n        }\n    }\n    for(var child of node.items){\n        if(child instanceof Group){\n            del_groups(groups, child)\n        }\n    }\n}\n\nfunction GroupMO(node, start, matches, string, groups, endpos){\n    this.node = node\n    this.start = start\n    this.matches = matches\n    this.string = string\n    this.end = matches.length > 0 ? $last(matches).end : start\n    this.endpos = endpos === undefined ? this.end : endpos\n    this.$groups = groups\n}\n\nGroupMO.prototype.backtrack = function(string, groups){\n    // Try backtracking in the last match\n    if(this.matches.length > 0){\n        var match = $last(this.matches),\n            mos = match.mos,\n            nb0 = mos.length\n        while(mos.length > 0){\n            var mo = mos.pop()\n            if(mo.backtrack()){\n                mos.push(mo)\n                if(this.node.num !== undefined){\n                    groups[this.node.num].end = mo.end\n                }\n                this.end = mo.end\n                return true\n            }\n        }\n    }\n    // Else, remove last match if possible\n    if(this.matches.length > this.node.repeat.min &&\n            this.matches.length >= 1){\n        this.matches.pop()\n        if(this.matches.length > 0){\n            this.end = $last(this.matches).end\n        }else{\n            // remove this group and its children from groups\n            del_groups(groups, this.node)\n            this.end = this.start\n        }\n        return true\n    }\n    return false\n}\n\nGroupMO.prototype.toString = function(){\n    var repr = _b_.repr(this.string.substring(this.start, this.end))\n    repr = repr.substring(0, 50)\n    return '<re.Match object; span=(' + this.start + ', ' + this.end +\n        '), match=' + repr + '>'\n}\n\nGroupMO.prototype.groups = function(_default){\n    var res = [],\n        groupobj = this.$groups\n\n    for(var key in this.node.$groups){\n        if(isFinite(key)){\n            res[key] = groupobj[key] === undefined ? _default :\n                this.string.substring(groupobj[key].start, groupobj[key].end)\n        }\n    }\n    res.shift()\n    return $B.fast_tuple(res)\n}\n\nvar BMO = $B.make_class(\"Match\",\n    function(mo){\n        return {\n            __class__: BMO,\n            mo\n        }\n    }\n)\n\nBMO.__getitem__ = function(){\n    var $ = $B.args(\"__getitem__\", 2, {self: null, key: null},\n                ['self', 'key'], arguments, {}, null, null),\n        self = $.self,\n        key = $.key\n    if(Array.isArray(key)){\n        throw _b_.IndexError.$factory(\"no such group\")\n    }\n    if(key == 0){\n        return self.mo.string.substring(self.mo.start, self.mo.end)\n    }\n    var match = self.mo.$groups[key]\n    if(match !== undefined){\n        return self.mo.string.substring(match.start, match.end)\n    }else if(self.mo.node.$groups[key] !== undefined){\n        return _b_.None\n    }\n    throw _b_.IndexError.$factory(\"no such group\")\n}\n\nBMO.__repr__ = BMO.__str__ =  function(self){\n    return self.mo.toString()\n}\n\nBMO.end = function(self){\n    var $ = $B.args('end', 2, {self: null, group: null}, ['self', 'group'],\n                arguments, {group: 0}, null, null)\n    var group = BMO.group(self, $.group)\n    if(group === _b_.None){\n        return -1\n    }else if($.group == 0){\n        return self.mo.end\n    }else{\n        return self.mo.$groups[$.group].end\n    }\n}\n\nBMO.endpos = {\n    __get__: function(self){\n        return self.mo.endpos\n    }\n}\n\nBMO.expand = function(){\n    var $ = $B.args(\"expand\", 2, {self: null, template: null},\n                ['self', 'template'], arguments, {}, null, null)\n    var data = {\n        repl: new StringObj($.template),\n    }\n    data = transform_repl(data, {groups: $.self.mo.node.$groups})\n    if(typeof data.repl == \"function\"){\n        return $B.$call(data.repl)(BMO.$factory($.self.mo))\n    }else{\n        return data.repl1\n    }\n}\n\nBMO.group = function(self){\n    var $ = $B.args(\"group\", 1, {self: null}, ['self'], arguments,\n                {}, 'args', null),\n            self = $.self,\n            args = $.args\n    if(args.length == 0){\n        args[0] = 0\n    }\n    var groupobj = self.mo.$groups,\n        result = []\n    for(var group_id of args){\n        if(group_id == 0){\n            result.push(self.mo.string.substring(self.mo.start, self.mo.end))\n            continue\n        }\n        try{\n            // Convert group_id to int if possible\n            group_id = $B.PyNumber_Index(group_id) // in py_utils.js\n        }catch(err){\n            // group_id can be an identifier\n        }\n        if(self.mo.node.$groups[group_id] === undefined){\n            throw _b_.IndexError.$factory(\"no such group\")\n        }\n        var group = groupobj[group_id] // found in match\n        result.push(group === undefined ?\n            _b_.None :\n            self.mo.string.substring(group.start, group.end))\n    }\n    if(args.length == 1){\n        return result[0]\n    }\n    return $B.fast_tuple(result)\n}\n\nBMO.groupdict = function(){\n    /*\n    Return a dictionary containing all the named subgroups of the match, keyed\n    by the subgroup name. The default argument is used for groups that did not\n    participate in the match; it defaults to None.\n    */\n    var $ = $B.args(\"groupdict\", 2, {self: null, default: null},\n                ['self', 'default'], arguments, {default: _b_.None},\n                null, null),\n        self = $.self,\n        groupobj = $.self.mo.$groups,\n        d = $B.empty_dict()\n    for(var key in $.self.mo.node.$groups){\n        if(! isFinite(key)){\n            var value = groupobj[key] === undefined ? $.default :\n                    groupobj[key]\n            if(value !== $.default){\n                value = self.mo.string.substring(value.start, value.end)\n            }\n            _b_.dict.$setitem(d, key, value)\n        }\n    }\n    d.__class__ = GroupDict\n    return d\n}\n\nBMO.groups = function(self){\n    var $ = $B.args(\"group\", 2, {self: null, default: null},\n                ['self', 'default'], arguments,\n                {default: _b_.None}, null, null),\n            self = $.self,\n            _default = $.default\n    return self.mo.groups(_default)\n}\n\nBMO.lastindex = {\n    /* The integer index of the last matched capturing group, or None if no\n       group was matched at all.\n    */\n    __get__: function(self){\n        var last = self.mo.$groups.$last\n        if(last.length == 0){\n            return _b_.None\n        }\n        return parseInt($last(last))\n    }\n}\n\nBMO.lastgroup = {\n    /* The name of the last matched capturing group, or None if the group\n       didn't have a name, or if no group was matched at all.\n    */\n    __get__: function(self){\n        var lastindex = BMO.lastindex.__get__(self)\n        if(lastindex === _b_.None){\n            return _b_.None\n        }\n        var group = self.mo.node.$groups[lastindex],\n            name = group.item.name\n        return name === undefined ? _b_.None : name\n    }\n}\n\nBMO.pos = {\n    __get__: function(self){\n        return self.mo.start\n    }\n}\n\nBMO.re = {\n    __get__: function(self){\n        return self.mo.node.pattern\n    }\n}\n\nBMO.regs = {\n    __get__: function(self){\n        var res = [$B.fast_tuple([self.mo.start, self.mo.end])]\n        for(var group_num in self.mo.node.$groups){\n            if(isFinite(group_num)){\n                var group = self.mo.node.$groups[group_num].item\n                // group.pattern includes the opening and closing brackets\n                res.push($B.fast_tuple([group.pos,\n                    group.pos + group.pattern.length - 2]))\n            }\n        }\n        return $B.fast_tuple(res)\n    }\n}\n\nBMO.span = function(){\n    /*\n    Match.span([group])\n\n    For a match m, return the 2-tuple (m.start(group), m.end(group)). Note\n    that if group did not contribute to the match, this is (-1, -1). group\n    defaults to zero, the entire match.\n    */\n    var $ = $B.args(\"span\", 2, {self: null, group: null},\n                ['self', 'group'], arguments,\n                {group: 0}, null, null),\n            self = $.self,\n            group = $.group\n    if(group == 0){\n        return $B.fast_tuple([self.mo.start, self.mo.end])\n    }\n    var span = self.mo.$groups[group]\n    if(span === undefined){\n        return $B.fast_tuple([-1, -1])\n    }\n    return $B.fast_tuple([span.start, span.end])\n}\n\nBMO.start = function(self){\n    var $ = $B.args('end', 2, {self: null, group: null}, ['self', 'group'],\n                arguments, {group: 0}, null, null)\n    var group = BMO.group(self, $.group)\n    if(group === _b_.None){\n        return -1\n    }else if($.group == 0){\n        return self.mo.start\n    }else{\n        return self.mo.$groups[$.group].start\n    }\n}\n\nBMO.string = {\n    __get__: function(self){\n        return self.mo.string.to_str()\n    }\n}\n\n$B.set_func_names(BMO, 're')\n\nfunction test_after_min_repeat_one(items, pattern, string, pos,\n                            endpos, no_zero_width, groups){\n\n}\n\nfunction log(){\n    if(_debug.value){\n        console.log.apply(null, arguments)\n    }\n}\n\nfunction match(pattern, string, pos, endpos, no_zero_width, groups){\n    // Follow the pattern tree structure\n    log('match pattern', pattern.text, 'pos', pos, string.substring(pos))\n    var string1 = string\n    if(endpos !== undefined){\n        if(endpos < pos){\n            return false\n        }else if(endpos < string.length){\n            string1 = new StringObj('')\n            string1.codepoints = string.codepoints.slice(0, endpos)\n            string1.length = endpos\n        }\n    }\n    if(pattern.node instanceof Node){\n        show(pattern.node)\n    }\n    if(groups === undefined){\n        groups = {$last:[]}\n    }\n    if(pattern.text === undefined){\n        console.log('pas de texte', pattern)\n    }\n    var node = pattern.node,\n        mo\n    if(node.items){\n        // node is either a Choice between several items, or a sequence of\n        // items\n        if(node instanceof Choice){\n            for(var subgroup of subgroups(node)){\n                //delete groups[subgroup]\n            }\n            mo = false\n            for(var _case of node.items){\n                mo = match({node: _case, text: _case.text}, string, pos,\n                    endpos, no_zero_width, groups)\n                if(mo){\n                    return mo\n                }\n            }\n            return false\n        }else{\n            // sequence of items\n            node.repeat = node.repeat === undefined ? {min: 1, max: 1} :\n                node.repeat\n            var start = pos,\n                nb_repeat = 0,\n                nb_zerolength_repeat = 0,\n                matches = [],\n                mos,\n                match_start,\n                empty_matches = {}\n            // loop until we get enough repetitions\n            while(true){\n                if(empty_matches[pos]){\n                    // no use trying again\n                    return matches.length == 0 ? false :\n                       new GroupMO(node, start, matches, string, groups,\n                           endpos)\n                }\n                var initial_groups = Object.keys(groups)\n                mos = []\n                match_start = pos\n                log(\"pattern\", pattern.text, \"loop in group match, match start\", match_start)\n                var i = 0\n                while(i < node.items.length){\n                    var item = node.items[i]\n                    log('item', i, '/', node.items.length - 1,\n                        'of pattern', pattern.text)\n                    var mo = match({node: item, text: item + ''}, string, pos,\n                        endpos, no_zero_width, groups)\n                    if(mo){\n                        if(item instanceof Group &&\n                                item.type == \"lookahead_assertion\"){\n                            log(\"lookahead assertion\", item, \"succeeds\")\n                        }else{\n                            mos.push(mo)\n                            log('item ' + item, 'succeeds, mo', mo, mos, 'groups', groups)\n                            pos = mo.end\n                        }\n                        i++\n                    }else if(false && item instanceof Group &&\n                            item.type == \"negative_lookahead_assertion\"){\n                        log(\"negative lookahead assertion\", item, \"fails : ok !\")\n                        i++\n                    }else{\n                        log('item ' + item, 'of group fails, nb_repeat',\n                            nb_repeat, 'node repeat', node.repeat)\n                        var backtrack = false\n                        while(mos.length > 0){\n                            var mo = mos.pop()\n                            if(mo.backtrack === undefined){\n                                log('pas de backtrack pour', mo)\n                            }\n                            log('try backtrack on mo', mo)\n                            if(mo.backtrack(string, groups)){\n                                log('can backtrack, mo', mo)\n                                mos.push(mo)\n                                i = mos.length\n                                log('mos', mos, 'restart at item', i)\n                                pos = mo.end\n                                backtrack = true\n                                break\n                            }\n                        }\n                        if(backtrack){\n                            log('backtrack ok')\n                            continue\n                        }else{\n                            if(node.type == \"negative_lookahead_assertion\"){\n                                // If a negative lookahead assertion fails,\n                                // return a match\n                                return new GroupMO(node, start, matches,\n                                    string, groups, endpos)\n                            }\n                            if(nb_repeat == 0){\n                                // remove the groups introduced before\n                                // reaching this point\n                                for(var key in groups){\n                                    if(initial_groups.indexOf(key) == -1){\n                                        delete groups[key]\n                                    }\n                                }\n                            }\n                            if(nb_repeat >= node.repeat.min){\n                                log(\"enough repetitions for node\", node)\n                                if(node.type == \"negative_lookahead_assertion\"){\n                                    return false\n                                }\n                                return new GroupMO(node, start, matches, string,\n                                    groups, endpos)\n                            }\n                            return false\n                        }\n                    }\n                }\n                if(node.type == \"negative_lookahead_assertion\"){\n                    // If a negative lookahead succeeds, return false\n                    return false\n                }\n                nb_repeat++\n                if(pos > match_start){\n                    nb_zerolength_repeat = 0\n                }else{\n                    nb_zerolength_repeat++\n                    empty_matches[pos] = true\n                }\n                matches.push({start: match_start, end: pos, mos})\n                if(node.num !== undefined){\n                    groups[node.num] = $last(matches)\n                    if(node.name !== undefined){\n                        groups[node.name] = groups[node.num]\n                    }\n                    if(node.num != $last(groups.$last)){\n                        var ix = groups.$last.indexOf(node.num)\n                        if(ix > -1){\n                            groups.$last.splice(ix, 1)\n                        }\n                        groups.$last.push(node.num)\n                    }\n                }\n                if(nb_repeat >= node.repeat.max){\n                    var res = new GroupMO(node, start, matches, string,\n                        groups, endpos)\n                    if(res.start == res.end && no_zero_width){\n                        // no_zero_width is set when previous match in\n                        // iterator() had length 0; avoids infinite loops\n                        return false\n                    }\n                    return res\n                }\n                log('loop on group', pattern.text, 'nb repeats', nb_repeat,\n                    'nb zero length', nb_zerolength_repeat)\n                if(nb_zerolength_repeat == 65535){\n                    return matches.length == 0 ? false :\n                       new GroupMO(node, start, matches, string, groups,\n                           endpos)\n                }\n            }\n        }\n    }else{\n        if(node.match === undefined){\n            console.log('pas de match', node)\n        }\n        var mo = node.match(string1, pos, groups)\n        log(node, \"mo\", mo)\n        if(mo){\n            var len = mo.group_len === undefined ? 1 : mo.group_len,\n                ix = node.non_greedy ? mo.nb_min : mo.nb_max,\n                end = pos + len * ix\n            return new MO(node, pos, mo, len)\n        }else{\n            return false\n        }\n    }\n}\n\nvar $module = {\n    cache: cache,\n    compile: function(){\n        var $ = $B.args(\"compile\", 2, {pattern: null, flags: null},\n                    ['pattern', 'flags'], arguments, {flags: no_flag},\n                    null, null)\n        if($.pattern && $.pattern.__class__ === BPattern){\n            if($.flags !== no_flag){\n                throw _b_.ValueError.$factory(\n                    \"cannot process flags argument with a compiled pattern\")\n            }\n            return $.pattern\n        }\n        $.pattern = check_pattern_flags($.pattern, $.flags)\n        var data = prepare({pattern: $.pattern})\n        if(typeof $.flags == \"number\"){\n            $.flags = Flag.$factory($.flags)\n        }\n        var jspat = compile(data.pattern, $.flags)\n        return BPattern.$factory(jspat)\n    },\n    error: error,\n    escape: function(){\n        var $ = $B.args(\"escape\", 1, {pattern: null}, ['pattern'], arguments,\n                    {}, null, null),\n            data = prepare({pattern: $.pattern}),\n            pattern = data.pattern,\n            res = []\n        for(var cp of pattern.codepoints){\n            if(escaped.indexOf(cp) > -1){\n                res.push(ord('\\\\'))\n            }\n            res.push(cp)\n        }\n        res = from_codepoint_list(res, data.type)\n        if(data.type == \"bytes\"){\n            res = _b_.str.encode(res, 'latin1')\n        }\n        return res\n    },\n    findall: function(){\n        /* Return all non-overlapping matches of pattern in string, as a list\n           of strings. The string is scanned left-to-right, and matches are\n           returned in the order found. If one or more groups are present in\n           the pattern, return a list of groups; this will be a list of tuples\n           if the pattern has more than one group. Empty matches are included\n           in the result.\n        */\n        var $ = $B.args(\"findall\", 3,\n                    {pattern: null, string: null, flags: null},\n                    ['pattern', 'string', 'flags'], arguments,\n                    {flags: no_flag}, null, null),\n                pattern = $.pattern,\n                string = $.string,\n                flags = $.flags,\n                data\n        pattern = check_pattern_flags(pattern, flags)\n        if(pattern.__class__ === BPattern){\n            data = prepare({string})\n        }else{\n            data = prepare({string, pattern})\n            pattern = BPattern.$factory(compile(data.pattern, flags))\n        }\n        if(data.type === \"str\"){\n            function conv(s){\n                return s === EmptyString ? '' : s\n            }\n        }else{\n            function conv(s){\n                return string2bytes(s)\n            }\n        }\n\n        var iter = $module.finditer.apply(null, arguments).js_gen,\n            res = []\n        while(true){\n            var next = iter.next()\n            if(next.done){\n                return res\n            }\n            var bmo = next.value,\n                mo = bmo.mo,\n                groups = BMO.groups(bmo)\n\n            // replace None by the empty string\n            for(var i = 0, len = groups.length; i < len; i++){\n                groups[i] = groups[i] === _b_.None ? \"\" : groups[i]\n            }\n            if(groups.length > 0){\n                if(groups.length == 1){\n                    res.push(groups[0])\n                }else{\n                    res.push($B.fast_tuple(groups))\n                }\n            }else{\n                res.push(mo.string.substring(mo.start, mo.end))\n            }\n        }\n        console.log(\"end findall\")\n    },\n    finditer: function(){\n        var $ = $B.args(\"finditer\", 3,\n                    {pattern: null, string: null, flags: null},\n                    ['pattern', 'string', 'flags'], arguments,\n                    {flags: no_flag}, null, null),\n                pattern = $.pattern,\n                string = $.string,\n                flags = $.flags\n        if(_b_.isinstance(string, [_b_.bytearray, _b_.memoryview])){\n            string.in_iteration = true\n        }\n        var original_string = string,\n            data\n        pattern = check_pattern_flags(pattern, flags)\n        if(pattern.__class__ === BPattern){\n            data = prepare({string})\n            flags = pattern.flags\n        }else{\n            data = prepare({string, pattern})\n            pattern = BPattern.$factory(compile(data.pattern, flags))\n        }\n        if(pattern.__class__ !== BPattern){\n            throw Error(\"pattern not a Python object\")\n        }\n        return $B.generator.$factory(iterator)(pattern.$pattern, data.string,\n            flags, original_string)\n    },\n    fullmatch: function(){\n        var bmo = $module.match.apply(null, arguments)\n        if(bmo !== _b_.None){\n            if(bmo.mo.string.codepoints.length != bmo.mo.end - bmo.mo.start){\n                return _b_.None\n            }else{\n                return bmo\n            }\n        }\n        return _b_.None\n    },\n    Match: BMO,\n    match: function(){\n        var $ = $B.args(\"match\", 3, {pattern: null, string: null, flags: null},\n                    ['pattern', 'string', 'flags'], arguments,\n                    {flags: no_flag}, null, null),\n                pattern = $.pattern,\n                string = $.string,\n                flags = $.flags\n        pattern = check_pattern_flags(pattern, flags)\n        var data\n        if(pattern.__class__ === BPattern){\n            data = prepare({string})\n            pattern = pattern.$pattern\n        }else{\n            data = prepare({pattern, string})\n            pattern = compile(data.pattern, flags)\n        }\n        var res = match(pattern, data.string, 0)\n        return res === false ? _b_.None : BMO.$factory(res)\n    },\n    Pattern: BPattern,\n    purge: function(){\n        var $ = $B.args(\"purge\", 0, {}, [], arguments, {}, null, null)\n        cache.clear()\n        return _b_.None\n    },\n    search: function(){\n        var $ = $B.args(\"search\", 3, {pattern: null, string: null, flags: null},\n                    ['pattern', 'string', 'flags'], arguments,\n                    {flags: no_flag}, null, null),\n                pattern = $.pattern,\n                string = $.string,\n                flags = $.flags,\n                data\n        pattern = check_pattern_flags(pattern, flags)\n        if(pattern.__class__ === BPattern){\n            data = prepare({string})\n        }else{\n            data = prepare({string, pattern})\n            pattern = BPattern.$factory(compile(data.pattern, flags))\n        }\n        data.pattern = pattern\n        // optimization\n        if(pattern.$pattern.fixed_length !== false &&\n                isFinite(pattern.$pattern.fixed_length) &&\n                pattern.pattern.endsWith('$') &&\n                ! (pattern.flags.value & MULTILINE.value)){\n            var mo = match(data.pattern.$pattern, data.string,\n                data.string.length - pattern.$pattern.fixed_length)\n            if(mo){\n                return BMO.$factory(mo)\n            }\n            return _b_.None\n        }\n        var pos = 0\n        while(pos < data.string.codepoints.length){\n            var mo = match(data.pattern.$pattern, data.string, pos)\n            if(mo){\n                return BMO.$factory(mo)\n            }else{\n                pos++\n            }\n        }\n        return _b_.None\n    },\n    set_debug: function(){\n        _debug.value = true\n    },\n    split: function(){\n        var $ = $B.args(\"split\", 4,\n                    {pattern: null, string: null, maxsplit: null, flags: null},\n                    ['pattern', 'string', 'maxsplit', 'flags'],\n                    arguments, {maxsplit: 0, flags: no_flag}, null, null)\n        var res = [],\n            pattern = $.pattern,\n            string = $.string,\n            flags = $.flags,\n            pos = 0,\n            nb_split = 0,\n            data\n        if(pattern.__class__ !== BPattern){\n            data = prepare({pattern, string})\n            pattern = BPattern.$factory(compile(data.pattern, flags))\n        }else{\n            data = {pattern, string}\n        }\n        for(var bmo of $module.finditer(pattern, $.string).js_gen){\n            var mo = bmo.mo, // finditer returns instances of BMO\n                groupobj = mo.$groups\n            res.push(data.string.substring(pos, mo.start))\n            for(var key in mo.node.$groups){\n                if(isFinite(key)){\n                    if(groupobj[key] !== undefined){\n                        res.push(data.string.substring(groupobj[key].start,\n                            groupobj[key].end))\n                    }else{\n                        res.push(_b_.None)\n                    }\n                }\n            }\n            nb_split++\n            pos = mo.end\n            if(pos >= $.string.length){\n                break\n            }\n            if($.maxsplit != 0 && nb_split >= $.maxsplit){\n                break\n            }\n        }\n        res.push(data.string.substring(pos))\n        if(data.type === \"bytes\"){\n            res = res.map(function(x){return _b_.str.encode(x, \"latin-1\")})\n        }\n        return res\n    },\n    sub: function(){\n        var $ = $B.args(\"sub\", 5,\n                {pattern: null, repl: null, string: null, count: null, flags: null},\n                ['pattern', 'repl', 'string', 'count', 'flags'],\n                arguments, {count: 0, flags: no_flag}, null, null),\n            pattern = $.pattern,\n            repl = $.repl,\n            string = $.string,\n            count = $.count,\n            flags = $.flags,\n            data\n        check_pattern_flags(pattern, flags)\n        if(typeof repl != \"function\"){\n            if(pattern.__class__ != BPattern){\n                data = prepare({pattern, string, repl})\n                pattern = compile(data.pattern, flags)\n            }else{\n                data = prepare({string, repl})\n                flags = pattern.flags\n                pattern = pattern.$pattern\n            }\n            data = transform_repl(data, pattern)\n        }else{\n            if(pattern.__class__ != BPattern){\n                data = prepare({pattern, string})\n                pattern = compile(data.pattern, flags)\n            }else{\n                data = prepare({string})\n                flags = pattern.flags\n                pattern = pattern.$pattern\n            }\n            data.repl = repl\n        }\n        return subn(pattern, data.repl, data.string, count, flags)[0]\n    },\n    subn: function(){\n        var $ = $B.args(\"sub\", 5,\n                {pattern: null, repl: null, string: null, count: null, flags: null},\n                ['pattern', 'repl', 'string', 'count', 'flags'],\n                arguments, {count: 0, flags: no_flag}, null, null),\n            pattern = $.pattern,\n            repl = $.repl,\n            string = $.string,\n            count = $.count,\n            flags = $.flags,\n            data\n        if(pattern.__class__ != BPattern){\n            data = prepare({pattern, repl, string})\n        }else{\n            data = prepare({repl, string})\n            data.pattern = pattern.$pattern\n        }\n        return $B.fast_tuple(subn(data.pattern, data.repl, data.string, count,\n            flags))\n    }\n\n}\n\nvar ASCII = $module.A = $module.ASCII = Flag.$factory(256)\nvar IGNORECASE = $module.I = $module.IGNORECASE = Flag.$factory(2)\nvar LOCALE = $module.L = $module.LOCALE = Flag.$factory(4)\nvar MULTILINE = $module.M = $module.MULTILINE = Flag.$factory(8)\nvar DOTALL = $module.S = $module.DOTALL = Flag.$factory(16)\nvar U = $module.U = $module.UNICODE = Flag.$factory(32)\nvar VERBOSE = $module.X = $module.VERBOSE = Flag.$factory(64)\n$module.cache = cache\n\nvar inline_flags = {\n    i: IGNORECASE,\n    L: LOCALE,\n    m: MULTILINE,\n    s: DOTALL,\n    u: U,\n    x: VERBOSE,\n    a: ASCII\n}\n\nvar flag_names = {\n    i: 'IGNORECASE',\n    L: 'LOCALE',\n    m: 'MULTILINE',\n    s: 'DOTALL',\n    u: 'U',\n    x: 'VERBOSE',\n    a: 'ASCII'\n}\n"],
+    "random": [".js", "// Javascript implementation of the random module\n// Based on Ian Bicking's implementation of the Mersenne twister\n\nvar $module = (function($B){\n\nvar _b_ = $B.builtins,\n    i\n\nvar VERSION = 3\n\n// Code copied from https://github.com/ianb/whrandom/blob/master/mersenne.js\n// by Ian Bicking\n\n// this program is a JavaScript version of Mersenne Twister,\n// a straight conversion from the original program, mt19937ar.c,\n// translated by y. okada on july 17, 2006.\n// and modified a little at july 20, 2006, but there are not any substantial differences.\n// modularized by Ian Bicking, March 25, 2013 (found original version at http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/VERSIONS/JAVASCRIPT/java-script.html)\n// in this program, procedure descriptions and comments of original source code were not removed.\n// lines commented with //c// were originally descriptions of c procedure. and a few following lines are appropriate JavaScript descriptions.\n// lines commented with /* and */ are original comments.\n// lines commented with // are additional comments in this JavaScript version.\n/*\n   A C-program for MT19937, with initialization improved 2002/1/26.\n   Coded by Takuji Nishimura and Makoto Matsumoto.\n\n   Before using, initialize the state by using init_genrand(seed)\n   or init_by_array(init_key, key_length).\n\n   Copyright (C) 1997 - 2002, Makoto Matsumoto and Takuji Nishimura,\n   All rights reserved.\n\n   Redistribution and use in source and binary forms, with or without\n   modification, are permitted provided that the following conditions\n   are met:\n\n     1. Redistributions of source code must retain the above copyright\n        notice, this list of conditions and the following disclaimer.\n\n     2. Redistributions in binary form must reproduce the above copyright\n        notice, this list of conditions and the following disclaimer in the\n        documentation and/or other materials provided with the distribution.\n\n     3. The names of its contributors may not be used to endorse or promote\n        products derived from this software without specific prior written\n        permission.\n\n   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n   \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n   A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n   CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n   EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n   PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n   PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\n\n   Any feedback is very welcome.\n   http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt.html\n   email: m-mat @ math.sci.hiroshima-u.ac.jp (remove space)\n*/\n\nfunction RandomStream(seed) {\n    /*jshint bitwise:false */\n    /* Period parameters */\n    //c//#define N 624\n    //c//#define M 397\n    //c//#define MATRIX_A 0x9908b0dfUL   /* constant vector a */\n    //c//#define UPPER_MASK 0x80000000UL /* most significant w-r bits */\n    //c//#define LOWER_MASK 0x7fffffffUL /* least significant r bits */\n    var N = 624\n    var M = 397\n    var MATRIX_A = 0x9908b0df   /* constant vector a */\n    var UPPER_MASK = 0x80000000 /* most significant w-r bits */\n    var LOWER_MASK = 0x7fffffff /* least significant r bits */\n    //c//static unsigned long mt[N]; /* the array for the state vector  */\n    //c//static int mti=N+1; /* mti==N+1 means mt[N] is not initialized */\n    var mt = new Array(N)   /* the array for the state vector  */\n    var mti = N + 1           /* mti==N+1 means mt[N] is not initialized */\n\n    function unsigned32(n1){\n        // returns a 32-bits unsiged integer from an operand to which applied a\n        // bit operator.\n        return n1 < 0 ? (n1 ^ UPPER_MASK) + UPPER_MASK : n1\n    }\n\n    function subtraction32(n1, n2){\n    // emulates lowerflow of a c 32-bits unsiged integer variable, instead of\n    // the operator -. these both arguments must be non-negative integers\n    // expressible using unsigned 32 bits.\n        return n1 < n2 ? unsigned32((0x100000000 - (n2 - n1)) & 0xffffffff) :\n          n1 - n2\n    }\n\n    function addition32(n1, n2){\n        // emulates overflow of a c 32-bits unsiged integer variable, instead of\n        // the operator +. these both arguments must be non-negative integers\n        // expressible using unsigned 32 bits.\n        return unsigned32((n1 + n2) & 0xffffffff)\n    }\n\n    function multiplication32(n1, n2){\n        // emulates overflow of a c 32-bits unsiged integer variable, instead of the\n        // operator *. these both arguments must be non-negative integers\n        // expressible using unsigned 32 bits.\n        var sum = 0\n        for (var i = 0; i < 32; ++i){\n            if((n1 >>> i) & 0x1){\n                sum = addition32(sum, unsigned32(n2 << i))\n            }\n        }\n        return sum\n    }\n\n    /* initializes mt[N] with a seed */\n    //c//void init_genrand(unsigned long s)\n    function init_genrand(s) {\n        //c//mt[0]= s & 0xffffffff;\n        mt[0] = unsigned32(s & 0xffffffff)\n        for(mti = 1; mti < N; mti++){\n            mt[mti] =\n                //c//(1812433253 * (mt[mti-1] ^ (mt[mti-1] >> 30)) + mti);\n                addition32(multiplication32(1812433253,\n                    unsigned32(mt[mti - 1] ^ (mt[mti - 1] >>> 30))), mti)\n            /* See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier. */\n            /* In the previous versions, MSBs of the seed affect   */\n            /* only MSBs of the array mt[].                        */\n            /* 2002/01/09 modified by Makoto Matsumoto             */\n            //c//mt[mti] &= 0xffffffff;\n            mt[mti] = unsigned32(mt[mti] & 0xffffffff);\n            /* for >32 bit machines */\n        }\n    }\n\n    /* initialize by an array with array-length */\n    /* init_key is the array for initializing keys */\n    /* key_length is its length */\n    /* slight change for C++, 2004/2/26 */\n    //c//void init_by_array(unsigned long init_key[], int key_length)\n    function init_by_array(init_key, key_length) {\n        //c//int i, j, k;\n        var i, j, k\n        init_genrand(19650218)\n        i = 1\n        j = 0\n        k = (N > key_length ? N : key_length)\n        for(; k; k--){\n          //c//mt[i] = (mt[i] ^ ((mt[i-1] ^ (mt[i-1] >> 30)) * 1664525))\n          //c// + init_key[j] + j; /* non linear */\n          mt[i] = addition32(\n              addition32(unsigned32(mt[i] ^\n                  multiplication32(unsigned32(mt[i - 1] ^ (mt[i - 1] >>> 30)),\n                  1664525)),\n              init_key[j]), j)\n          mt[i] =\n              //c//mt[i] &= 0xffffffff; /* for WORDSIZE > 32 machines */\n              unsigned32(mt[i] & 0xffffffff)\n          i++\n          j++\n          if(i >= N){mt[0] = mt[N - 1]; i = 1}\n          if(j >= key_length){j = 0}\n        }\n        for(k = N - 1; k; k--){\n            //c//mt[i] = (mt[i] ^ ((mt[i-1] ^ (mt[i-1] >> 30)) * 1566083941))\n            //c//- i; /* non linear */\n            mt[i] = subtraction32(\n                unsigned32(\n                    (mt[i]) ^\n                        multiplication32(\n                            unsigned32(mt[i - 1] ^ (mt[i - 1] >>> 30)),\n                    1566083941)),\n                i\n            )\n            //c//mt[i] &= 0xffffffff; /* for WORDSIZE > 32 machines */\n            mt[i] = unsigned32(mt[i] & 0xffffffff)\n            i++\n            if(i >= N){mt[0] = mt[N - 1]; i = 1}\n        }\n        mt[0] = 0x80000000; /* MSB is 1; assuring non-zero initial array */\n    }\n\n    /* generates a random number on [0,0xffffffff]-interval */\n    //c//unsigned long genrand_int32(void)\n    function genrand_int32() {\n        //c//unsigned long y;\n        //c//static unsigned long mag01[2]={0x0UL, MATRIX_A};\n        var y;\n        var mag01 = [0x0, MATRIX_A];\n        /* mag01[x] = x * MATRIX_A  for x=0,1 */\n\n        if(mti >= N){ /* generate N words at one time */\n            //c//int kk;\n            var kk\n\n            if(mti == N + 1){   /* if init_genrand() has not been called, */\n              init_genrand(Date.now()) /* a default initial seed is used */\n            }\n\n            for(kk = 0; kk < N - M; kk++){\n              //c//y = (mt[kk]&UPPER_MASK)|(mt[kk+1]&LOWER_MASK);\n              //c//mt[kk] = mt[kk+M] ^ (y >> 1) ^ mag01[y & 0x1];\n              y = unsigned32((mt[kk]&UPPER_MASK) | (mt[kk + 1]&LOWER_MASK))\n              mt[kk] = unsigned32(mt[kk + M] ^ (y >>> 1) ^ mag01[y & 0x1])\n            }\n            for(;kk < N - 1; kk++){\n              //c//y = (mt[kk]&UPPER_MASK)|(mt[kk+1]&LOWER_MASK);\n              //c//mt[kk] = mt[kk+(M-N)] ^ (y >> 1) ^ mag01[y & 0x1];\n              y = unsigned32((mt[kk]&UPPER_MASK) | (mt[kk + 1]&LOWER_MASK))\n              mt[kk] = unsigned32(mt[kk + (M - N)] ^ (y >>> 1) ^ mag01[y & 0x1])\n            }\n            //c//y = (mt[N-1]&UPPER_MASK)|(mt[0]&LOWER_MASK);\n            //c//mt[N-1] = mt[M-1] ^ (y >> 1) ^ mag01[y & 0x1];\n            y = unsigned32((mt[N - 1] & UPPER_MASK) | (mt[0] & LOWER_MASK))\n            mt[N - 1] = unsigned32(mt[M - 1] ^ (y >>> 1) ^ mag01[y & 0x1])\n            mti = 0\n        }\n\n        y = mt[mti++]\n\n        /* Tempering */\n        //c//y ^= (y >> 11);\n        //c//y ^= (y << 7) & 0x9d2c5680;\n        //c//y ^= (y << 15) & 0xefc60000;\n        //c//y ^= (y >> 18);\n        y = unsigned32(y ^ (y >>> 11))\n        y = unsigned32(y ^ ((y << 7) & 0x9d2c5680))\n        y = unsigned32(y ^ ((y << 15) & 0xefc60000))\n        y = unsigned32(y ^ (y >>> 18))\n\n        return y\n    }\n\n    /* generates a random number on [0,0x7fffffff]-interval */\n    //c//long genrand_int31(void)\n    function genrand_int31(){\n        //c//return (genrand_int32()>>1);\n        return (genrand_int32()>>>1)\n    }\n\n    /* generates a random number on [0,1]-real-interval */\n    //c//double genrand_real1(void)\n    function genrand_real1(){\n        return genrand_int32()*(1.0/4294967295.0)\n        /* divided by 2^32-1 */\n    }\n\n    /* generates a random number on [0,1)-real-interval */\n    //c//double genrand_real2(void)\n    function genrand_real2(){\n        return genrand_int32() * (1.0 / 4294967296.0)\n        /* divided by 2^32 */\n    }\n\n    /* generates a random number on (0,1)-real-interval */\n    //c//double genrand_real3(void)\n    function genrand_real3() {\n        return ((genrand_int32()) + 0.5) * (1.0 / 4294967296.0)\n        /* divided by 2^32 */\n    }\n\n    /* generates a random number on [0,1) with 53-bit resolution*/\n    //c//double genrand_res53(void)\n    function genrand_res53() {\n        //c//unsigned long a=genrand_int32()>>5, b=genrand_int32()>>6;\n        var a = genrand_int32() >>> 5,\n            b = genrand_int32() >>> 6\n        return (a * 67108864.0 + b) * (1.0 / 9007199254740992.0)\n    }\n    /* These real versions are due to Isaku Wada, 2002/01/09 added */\n\n    var random = genrand_res53\n\n    random.seed = function(seed){\n        if(seed === undefined){\n            seed = Date.now()\n        }\n        /*\n        if(Array.isArray(seed)){ // Brython-specific, for debugging\n            init_by_array(seed, seed.length)\n            return\n        }\n        */\n        var keys = []\n        if(typeof seed == \"number\" || _b_.isinstance(seed, _b_.int)){\n            var int32 = Math.pow(2, 32),\n                int32_1 = int32 - 1\n            // Transform to long integer\n            seed = $B.long_int.$factory(seed)\n            // Take abs(seed)\n            seed = $B.long_int.__abs__(seed)\n            // decomposition in factors of 2 ** 32\n            while($B.long_int.__ge__(seed, int32_1)){\n                var dm = _b_.divmod(seed, int32)\n                // Rest is a JS number (< 2 ** 32)\n                keys.push(dm[1])\n                // Quotient is either a JS number or a instance of long_int\n                // but seed must be long_int\n                seed = dm[0].value === undefined ?\n                    $B.long_int.$factory(dm[0]) : dm[0]\n            }\n            keys.push(parseInt(seed.value))\n        }else if(typeof seed != \"number\"){\n            seed = parseInt(seed, 10)\n            if((seed !== 0 && ! seed) || isNaN(seed)){\n                throw _b_.ValueError.$factory(\"Bad seed: \" +\n                    _b_.str.$factory(seed))\n            }\n        }\n        init_by_array(keys, keys.length)\n    }\n\n    random.seed(seed)\n\n    random.int31 = genrand_int31\n    random.real1 = genrand_real1\n    random.real2 = genrand_real2\n    random.real3 = genrand_real3\n    random.res53 = genrand_res53\n\n    // Added for compatibility with Python\n    random.getstate = function(){\n        return $B.fast_tuple([VERSION,\n            $B.fast_tuple(mt.concat([mti]))\n            , _b_.None])\n    }\n\n    random.setstate = function(state){\n        mt = state[1].slice(0, state[1].length - 1)\n        mti = state[1][state[1].length - 1]\n    }\n\n    return random\n\n}\n\n// magic constants\n\nvar NV_MAGICCONST = 4 * Math.exp(-0.5)/Math.sqrt(2),\n    gauss_next = null,\n    NV_MAGICCONST = 1.71552776992141,\n    TWOPI = 6.28318530718,\n    LOG4 = 1.38629436111989,\n    SG_MAGICCONST = 2.50407739677627,\n    VERSION = VERSION\n\nvar Random = $B.make_class(\"Random\",\n    function(){\n        return {\n            __class__: Random,\n            _random: RandomStream(Date.now())\n        }\n    }\n)\n\nRandom._randbelow = function(self, x){\n    return Math.floor(x * self._random())\n}\n\nRandom._urandom = function(self, n){\n    /*\n    urandom(n) -> str\n    Return n random bytes suitable for cryptographic use.\n    */\n\n    var randbytes = []\n    for(i = 0; i < n; i++){randbytes.push(parseInt(self._random() * 256))}\n    return _b_.bytes.$factory(randbytes)\n}\n\nRandom.betavariate = function(){\n    /* Beta distribution.\n\n    Conditions on the parameters are alpha > 0 and beta > 0.\n    Returned values range between 0 and 1.\n\n\n    # This version due to Janne Sinkkonen, and matches all the std\n    # texts (e.g., Knuth Vol 2 Ed 3 pg 134 \"the beta distribution\").\n    */\n\n    var $ = $B.args('betavariate', 3, {self: null, alpha:null, beta:null},\n            ['self', 'alpha', 'beta'], arguments, {}, null, null),\n        self = $.self,\n        alpha = $.alpha,\n        beta = $.beta\n\n    var y = Random.gammavariate(self, alpha, 1)\n    if(y == 0){return _b_.float.$factory(0)}\n    else{return y / (y + Random.gammavariate(self, beta, 1))}\n}\n\nRandom.choice = function(){\n    var $ = $B.args(\"choice\", 2,\n        {self: null, seq:null},[\"self\", \"seq\"],arguments, {}, null, null),\n        self = $.self,\n        seq = $.seq\n    var len, rank\n    if(Array.isArray(seq)){len = seq.length}\n    else{len = _b_.getattr(seq,\"__len__\")()}\n    if(len == 0){\n        throw _b_.IndexError.$factory(\"Cannot choose from an empty sequence\")\n    }\n    rank = parseInt(self._random() * len)\n    if(Array.isArray(seq)){return seq[rank]}\n    else{return _b_.getattr(seq, \"__getitem__\")(rank)}\n}\n\nRandom.choices = function(){\n    var $ = $B.args(\"choices\", 3,\n            {self: null,population:null, weights:null, cum_weights:null, k:null},\n            [\"self\", \"population\", \"weights\", \"cum_weights\", \"k\"], arguments,\n            {weights: _b_.None, cum_weights: _b_.None, k: 1}, \"*\", null),\n            self = $.self,\n            population = $.population,\n            weights = $.weights,\n            cum_weights = $.cum_weights,\n            k = $.k\n\n    if(population.length == 0){\n        throw _b_.ValueError.$factory(\"population is empty\")\n    }\n    population = _b_.list.$factory(population) // issue #1268\n    if(weights === _b_.None){\n        weights = []\n        population.forEach(function(){\n            weights.push(1)\n        })\n    }else if(cum_weights !== _b_.None){\n        throw _b_.TypeError.$factory(\"Cannot specify both weights and \" +\n            \"cumulative weights\")\n    }else{\n        if(weights.length != population.length){\n            throw _b_.ValueError.$factory('The number of weights does not ' +\n                'match the population')\n        }\n    }\n    if(cum_weights === _b_.None){\n        var cum_weights = [weights[0]]\n        weights.forEach(function(weight, rank){\n            if(rank > 0){\n                cum_weights.push(cum_weights[rank - 1] + weight)\n            }\n        })\n    }else if(cum_weights.length != population.length){\n        throw _b_.ValueError.$factory('The number of weights does not ' +\n            'match the population')\n    }\n\n    var result = []\n    for(var i = 0; i < k; i++){\n        var rand = self._random() * cum_weights[cum_weights.length - 1]\n        for(var rank = 0, len = population.length; rank < len; rank++){\n            if(cum_weights[rank] > rand){\n                result.push(population[rank])\n                break\n            }\n        }\n    }\n    return result\n}\n\nRandom.expovariate = function(self, lambd){\n    /*\n    Exponential distribution.\n\n    lambd is 1.0 divided by the desired mean.  It should be\n    nonzero.  (The parameter would be called \"lambda\", but that is\n    a reserved word in Python.)  Returned values range from 0 to\n    positive infinity if lambd is positive, and from negative\n    infinity to 0 if lambd is negative.\n\n    */\n    // lambd: rate lambd = 1/mean\n    // ('lambda' is a Python reserved word)\n\n    // we use 1-random() instead of random() to preclude the\n    // possibility of taking the log of zero.\n    return -Math.log(1.0 - self._random()) / lambd\n}\n\nRandom.gammavariate = function(self, alpha, beta){\n    /* Gamma distribution.  Not the gamma function!\n\n    Conditions on the parameters are alpha > 0 and beta > 0.\n\n    The probability distribution function is:\n\n                x ** (alpha - 1) * math.exp(-x / beta)\n      pdf(x) =  --------------------------------------\n                  math.gamma(alpha) * beta ** alpha\n\n    */\n\n    // alpha > 0, beta > 0, mean is alpha*beta, variance is alpha*beta**2\n\n    // Warning: a few older sources define the gamma distribution in terms\n    // of alpha > -1.0\n\n    var $ = $B.args('gammavariate', 3,\n            {self: null, alpha:null, beta:null},\n            ['self', 'alpha', 'beta'],\n            arguments, {}, null, null),\n        self = $.self,\n        alpha = $.alpha,\n        beta = $.beta,\n        LOG4 = Math.log(4),\n        SG_MAGICCONST = 1.0 + Math.log(4.5)\n\n    if(alpha <= 0.0 || beta <= 0.0){\n        throw _b_.ValueError.$factory('gammavariate: alpha and beta must be > 0.0')\n    }\n\n    if(alpha > 1.0){\n\n        // Uses R.C.H. Cheng, \"The generation of Gamma\n        // variables with non-integral shape parameters\",\n        // Applied Statistics, (1977), 26, No. 1, p71-74\n\n        var ainv = Math.sqrt(2.0 * alpha - 1.0),\n            bbb = alpha - LOG4,\n            ccc = alpha + ainv\n\n        while(true){\n            var u1 = self._random()\n            if(!((1e-7 < u1) && (u1 < .9999999))){\n                continue\n            }\n            var u2 = 1.0 - self._random(),\n                v = Math.log(u1 / (1.0 - u1)) / ainv,\n                x = alpha * Math.exp(v),\n                z = u1 * u1 * u2,\n                r = bbb + ccc * v - x\n            if((r + SG_MAGICCONST - 4.5 * z >= 0.0) || r >= Math.log(z)){\n                return x * beta\n            }\n        }\n    }else if(alpha == 1.0){\n        // expovariate(1)\n        var u = self._random()\n        while(u <= 1e-7){u = self._random()}\n        return -Math.log(u) * beta\n    }else{\n        // alpha is between 0 and 1 (exclusive)\n\n        // Uses ALGORITHM GS of Statistical Computing - Kennedy & Gentle\n\n        while(true){\n            var u = self._random(),\n                b = (Math.E + alpha)/Math.E,\n                p = b*u,\n                x\n            if(p <= 1.0){x = Math.pow(p, (1.0/alpha))}\n            else{x = -Math.log((b-p)/alpha)}\n            var u1 = self._random()\n            if(p > 1.0){\n                if(u1 <= Math.pow(x, alpha - 1.0)){\n                    break\n                }\n            }else if(u1 <= Math.exp(-x)){\n                break\n            }\n        }\n        return x * beta\n    }\n}\n\nRandom.gauss = function(){\n\n    /* Gaussian distribution.\n\n    mu is the mean, and sigma is the standard deviation.  This is\n    slightly faster than the normalvariate() function.\n\n    Not thread-safe without a lock around calls.\n\n    # When x and y are two variables from [0, 1), uniformly\n    # distributed, then\n    #\n    #    cos(2*pi*x)*sqrt(-2*log(1-y))\n    #    sin(2*pi*x)*sqrt(-2*log(1-y))\n    #\n    # are two *independent* variables with normal distribution\n    # (mu = 0, sigma = 1).\n    # (Lambert Meertens)\n    # (corrected version; bug discovered by Mike Miller, fixed by LM)\n\n    # Multithreading note: When two threads call this function\n    # simultaneously, it is possible that they will receive the\n    # same return value.  The window is very small though.  To\n    # avoid this, you have to use a lock around all calls.  (I\n    # didn't want to slow this down in the serial case by using a\n    # lock here.)\n    */\n\n    var $ = $B.args('gauss', 3, {self: null, mu:null, sigma:null},\n            ['self', 'mu', 'sigma'], arguments, {}, null, null),\n        self = $.self,\n        mu = $.mu,\n        sigma = $.sigma\n\n    var z = gauss_next\n    gauss_next = null\n    if(z === null){\n        var x2pi = self._random() * Math.PI * 2,\n            g2rad = Math.sqrt(-2.0 * Math.log(1.0 - self._random())),\n            z = Math.cos(x2pi) * g2rad\n        gauss_next = Math.sin(x2pi) * g2rad\n    }\n    return mu + z*sigma\n}\n\nRandom.getrandbits = function(){\n    var $ = $B.args(\"getrandbits\", 2,\n        {self: null, k:null},[\"self\", \"k\"],arguments, {}, null, null),\n        self = $.self,\n        k = $B.$GetInt($.k)\n    // getrandbits(k) -> x.  Generates a long int with k random bits.\n    if(k <= 0){\n        throw _b_.ValueError.$factory('number of bits must be greater than zero')\n    }\n    if(k != _b_.int.$factory(k)){\n        throw _b_.TypeError.$factory('number of bits should be an integer')\n    }\n    var numbytes = (k + 7), // bits / 8 and rounded up\n        x = _b_.int.from_bytes(Random._urandom(self, numbytes), 'big')\n    return _b_.getattr(x, '__rshift__')(\n        _b_.getattr(numbytes*8,'__sub__')(k))\n}\n\nRandom.getstate = function(){\n    // Return internal state; can be passed to setstate() later.\n    var $ = $B.args('getstate', 1, {self: null},\n        [\"self\"], arguments, {}, null, null)\n    return $.self._random.getstate()\n}\n\nRandom.lognormvariate = function(){\n    /*\n    Log normal distribution.\n\n    If you take the natural logarithm of this distribution, you'll get a\n    normal distribution with mean mu and standard deviation sigma.\n    mu can have any value, and sigma must be greater than zero.\n\n    */\n    return Math.exp(Random.normalvariate.apply(null, arguments))\n}\n\nRandom.normalvariate = function(){\n    /*\n    Normal distribution.\n\n    mu is the mean, and sigma is the standard deviation.\n\n    */\n\n    // mu = mean, sigma = standard deviation\n\n    // Uses Kinderman and Monahan method. Reference: Kinderman,\n    // A.J. and Monahan, J.F., \"Computer generation of random\n    // variables using the ratio of uniform deviates\", ACM Trans\n    // Math Software, 3, (1977), pp257-260.\n\n    var $ = $B.args(\"normalvariate\", 3,\n        {self: null, mu:null, sigma:null}, [\"self\", \"mu\", \"sigma\"],\n        arguments, {}, null, null),\n        self = $.self,\n        mu = $.mu,\n        sigma = $.sigma\n\n    while(true){\n        var u1 = self._random(),\n            u2 = 1.0 - self._random(),\n            z = NV_MAGICCONST * (u1 - 0.5) / u2,\n            zz = z * z / 4.0\n        if(zz <= -Math.log(u2)){break}\n    }\n    return mu + z * sigma\n}\n\nRandom.paretovariate = function(){\n    /* Pareto distribution.  alpha is the shape parameter.*/\n    // Jain, pg. 495\n\n    var $ = $B.args(\"paretovariate\", 2, {self: null, alpha:null},\n        [\"self\", \"alpha\"], arguments, {}, null, null)\n\n    var u = 1 - $.self._random()\n    return 1 / Math.pow(u, 1 / $.alpha)\n}\n\nfunction is_integer(x){\n    return _b_.isinstance(x, _b_.int) || (\n        _b_.isinstance(x, _b_.float) &&\n            x.valueOf() == Math.floor(x.valueOf()))\n}\n\nRandom.randint = function(self, a, b){\n    var $ = $B.args('randint', 3,\n        {self: null, a:null, b:null},\n        ['self', 'a', 'b'],\n        arguments, {}, null, null)\n    if(! is_integer($.a)){\n        throw _b_.ValueError.$factory(\"non-integer value for start\")\n    }\n    if(! is_integer($.b)){\n        throw _b_.ValueError.$factory(\"non-integer value for stop\")\n    }\n    return Random.randrange($.self, $.a, $B.add($.b, 1))\n}\n\nRandom.random = function(self){\n    var res = self._random()\n    if(! Number.isInteger(res)){return new Number(res)}\n    return res\n}\n\nRandom.randrange = function(){\n    var $ = $B.args('randrange', 4,\n        {self: null, x:null, stop:null, step:null},\n        ['self', 'x', 'stop', 'step'],\n        arguments, {stop:null, step:null}, null, null),\n        self = $.self,\n        _random = self._random\n\n    if(! is_integer($.x)){\n        throw _b_.ValueError.$factory(\"non-integer arg 1 for randrange()\")\n    }\n    if($.stop !== null && ! is_integer($.stop)){\n        throw _b_.ValueError.$factory(\"non-integer arg 2 for randrange()\")\n    }\n    if($.step !== null && ! is_integer($.step)){\n        throw _b_.ValueError.$factory(\"non-integer arg 3 for randrange()\")\n    }\n\n    if($.stop === null){\n        var start = 0, stop = $.x.valueOf(), step = 1\n    }else{\n        var start = $.x.valueOf(),\n            stop = $.stop.valueOf(),\n            step = $.step === null ? 1 : $.step.valueOf()\n        if(step == 0){throw _b_.ValueError.$factory('step cannot be 0')}\n    }\n\n    if(($B.rich_comp(\"__gt__\", step, 0) &&\n            $B.rich_comp(\"__ge__\", start, stop)) ||\n            ($B.rich_comp(\"__lt__\", step, 0) &&\n             $B.rich_comp(\"__le__\", start, stop))){\n        throw _b_.ValueError.$factory(\"empty range for randrange() (\" +\n            start + \", \" + stop + \", \" + step + \")\")\n    }\n    if(typeof start == 'number' && typeof stop == 'number' &&\n            typeof step == 'number'){\n        return start + step * Math.floor(_random() *\n            Math.ceil((stop - start) / step))\n    }else{\n        var d = _b_.getattr(stop, '__sub__')(start)\n        d = _b_.getattr(d, '__floordiv__')(step)\n        // Force d to be a LongInt\n        d = $B.long_int.$factory(d)\n        // d is a long integer with n digits ; to choose a random number\n        // between 0 and d the most simple is to take a random digit\n        // at each position, except the first one\n        var s = d.value,\n            _len = s.length,\n            res = Math.floor(_random() * (parseInt(s.charAt(0)) +\n                (_len == 1 ? 0 : 1))) + ''\n        var same_start = res.charAt(0) == s.charAt(0)\n        for(var i = 1; i < _len; i++){\n            if(same_start){\n                // If it's the last digit, don't allow stop as valid\n                if(i == _len - 1){\n                    res += Math.floor(_random() * parseInt(s.charAt(i))) + ''\n                }else{\n                    res += Math.floor(_random() *\n                        (parseInt(s.charAt(i)) + 1)) + ''\n                    same_start = res.charAt(i) == s.charAt(i)\n                }\n            }else{\n                res += Math.floor(_random() * 10) + ''\n            }\n        }\n        var offset = {__class__: $B.long_int, value: res,\n            pos: true}\n        d = _b_.getattr(step, '__mul__')(offset)\n        d = _b_.getattr(start, '__add__')(d)\n        return _b_.int.$factory(d)\n    }\n}\n\nRandom.sample = function(){\n    /*\n    Chooses k unique random elements from a population sequence or set.\n\n    Returns a new list containing elements from the population while\n    leaving the original population unchanged.  The resulting list is\n    in selection order so that all sub-slices will also be valid random\n    samples.  This allows raffle winners (the sample) to be partitioned\n    into grand prize and second place winners (the subslices).\n\n    Members of the population need not be hashable or unique.  If the\n    population contains repeats, then each occurrence is a possible\n    selection in the sample.\n\n    To choose a sample in a range of integers, use range as an argument.\n    This is especially fast and space efficient for sampling from a\n    large population:   sample(range(10000000), 60)\n\n    # Sampling without replacement entails tracking either potential\n    # selections (the pool) in a list or previous selections in a set.\n\n    # When the number of selections is small compared to the\n    # population, then tracking selections is efficient, requiring\n    # only a small set and an occasional reselection.  For\n    # a larger number of selections, the pool tracking method is\n    # preferred since the list takes less space than the\n    # set and it doesn't suffer from frequent reselections.'\n\n    */\n    var $ = $B.args('sample', 3, {self: null, population: null,k: null},\n        ['self', 'population','k'], arguments, {}, null, null),\n        self = $.self,\n        population = $.population,\n        k = $.k\n\n    if(!_b_.hasattr(population, '__len__')){\n        throw _b_.TypeError.$factory(\"Population must be a sequence or set. \" +\n            \"For dicts, use list(d).\")\n    }\n    var n = _b_.getattr(population, '__len__')()\n\n    if(k < 0 || k > n){\n        throw _b_.ValueError.$factory(\"Sample larger than population\")\n    }\n    var result = [],\n        setsize = 21        // size of a small set minus size of an empty list\n    if(k > 5){\n        setsize += Math.pow(4, Math.ceil(Math.log(k * 3, 4))) // table size for big sets\n    }\n    if(n <= setsize){\n        // An n-length list is smaller than a k-length set\n        if(Array.isArray(population)){\n            var pool = population.slice()\n        }else{var pool = _b_.list.$factory(population)}\n        for(var i = 0; i < k; i++){ //invariant:  non-selected at [0,n-i)\n            var j = Random._randbelow(self, n - i)\n            result[i] = pool[j]\n            pool[j] = pool[n - i - 1]   // move non-selected item into vacancy\n        }\n    }else{\n        selected = {}\n        for(var i = 0; i < k; i++){\n            var j = Random._randbelow(self, n)\n            while(selected[j] !== undefined){\n                j = Random._randbelow(self, n)\n            }\n            selected[j] = true\n            result[i] = Array.isArray(population) ? population[j] :\n                            _b_.getattr(population, '__getitem__')(j)\n        }\n    }\n    return $B.$list(result) // not \"return result\", cf. issue #1622\n}\n\nRandom.seed = function(){\n    /*\n    Initialize internal state from hashable object.\n\n    None or no argument seeds from current time or from an operating\n    system specific randomness source if available.\n\n    If *a* is an int, all bits are used.\n    */\n    var $ = $B.args('seed', 3, {self: null, a: null, version: null},\n        ['self', 'a', 'version'],\n        arguments, {a: new Date(), version: 2}, null, null),\n        self = $.self,\n        a = $.a,\n        version = $.version\n\n    if(version == 1){a = _b_.hash(a)}\n    else if(version == 2){\n        if(_b_.isinstance(a, _b_.str)){\n            a = _b_.int.from_bytes(_b_.bytes.$factory(a, 'utf-8'), 'big')\n        }else if(_b_.isinstance(a, [_b_.str, _b_.bytes, _b_.bytearray])){\n            $B.$import(\"hashlib\",[\"sha512\"], {}, {}, true);\n            var sha512 = $B.$getattr($B.imported[\"hashlib\"], \"sha512\");\n            if(_b_.isinstance(a, _b_.str)){\n                a = _b_.str.encode(a)\n            }\n            a = $B.add(a, $B.$getattr(sha512(a), 'digest')())\n            a = _b_.int.from_bytes(a, 'big')\n        }else if(false && Array.isArray(a)){\n            // for debugging\n        }else if(!_b_.isinstance(a, _b_.int)){\n            throw _b_.TypeError.$factory('wrong argument')\n        }\n    }else{\n        throw _b_.ValueError.$factory('version can only be 1 or 2')\n    }\n    self._random.seed(a)\n    gauss_next = null\n}\n\nRandom.setstate = function(state){\n    // Restore internal state from object returned by getstate().\n    var $ = $B.args('setstate', 2, {self: null, state:null}, ['self', 'state'],\n        arguments, {}, null, null),\n        self = $.self\n    var state = self._random.getstate()\n    if(! Array.isArray($.state)){\n        throw _b_.TypeError.$factory('state must be a list, not ' +\n            $B.class_name($.state))\n    }\n    if($.state.length < state.length){\n        throw _b_.ValueError.$factory(\"need more than \" + $.state.length +\n            \" values to unpack\")\n    }else if($.state.length > state.length){\n        throw _b_.ValueError.$factory(\"too many values to unpack (expected \" +\n            state.length + \")\")\n    }\n    if($.state[0] != 3){\n        throw _b_.ValueError.$factory(\"state with version \" +\n            $.state[0] + \" passed to Random.setstate() of version 3\")\n    }\n    var second = _b_.list.$factory($.state[1])\n    if(second.length !== state[1].length){\n        throw _b_.ValueError.$factory('state vector is the wrong size')\n    }\n    for(var i = 0; i < second.length; i++){\n        if(typeof second[i] != 'number'){\n            throw _b_.ValueError.$factory('state vector items must be integers')\n        }\n    }\n    self._random.setstate($.state)\n}\n\nRandom.shuffle = function(x, random){\n    /*\n    x, random = random.random -> shuffle list x in place; return None.\n\n    Optional arg random is a 0-argument function returning a random\n    float in [0.0, 1.0); by default, the standard random.random.\n    */\n\n    var $ = $B.args('shuffle', 3, {self: null, x: null, random: null},\n        ['self', 'x','random'],\n        arguments, {random: null}, null, null),\n        self = $.self,\n        x = $.x,\n        random = $.random\n\n    if(random === null){random = self._random}\n\n    if(Array.isArray(x)){\n        for(var i = x.length - 1; i >= 0;i--){\n            var j = Math.floor(random() * (i + 1)),\n                temp = x[j]\n            x[j] = x[i]\n            x[i] = temp\n        }\n    }else{\n        var len = _b_.getattr(x, '__len__')(), temp,\n            x_get = _b_.getattr(x, '__getitem__'),\n            x_set = _b_.getattr(x, '__setitem__')\n\n        for(i = len - 1; i >= 0; i--){\n            var j = Math.floor(random() * (i + 1)),\n                temp = x_get(j)\n            x_set(j, x_get(i))\n            x_set(i, temp)\n        }\n    }\n    return _b_.None\n}\n\nRandom.triangular = function(){\n    /*\n    Triangular distribution.\n\n    Continuous distribution bounded by given lower and upper limits,\n    and having a given mode value in-between.\n\n    http://en.wikipedia.org/wiki/Triangular_distribution\n    */\n    var $ = $B.args('triangular', 4,\n        {self: null, low: null, high: null, mode: null},\n        ['self', 'low', 'high', 'mode'],\n        arguments, {low: 0, high: 1, mode: null}, null, null),\n        low = $.low,\n        high = $.high,\n        mode = $.mode\n\n    var u = $.self._random(),\n        c = mode === null ? 0.5 : (mode - low) / (high - low)\n    if(u > c){\n        u = 1 - u\n        c = 1 - c\n        var temp = low\n        low = high\n        high = temp\n    }\n    return low + (high - low) * Math.pow(u * c, 0.5)\n}\n\nRandom.uniform = function(){\n    var $ = $B.args('uniform', 3, {self: null, a: null, b: null},\n        ['self', 'a', 'b'], arguments, {}, null, null),\n        a = $B.$GetInt($.a),\n        b = $B.$GetInt($.b)\n\n    return a + (b - a) * $.self._random()\n}\n\nRandom.vonmisesvariate = function(){\n    /* Circular data distribution.\n\n    mu is the mean angle, expressed in radians between 0 and 2*pi, and\n    kappa is the concentration parameter, which must be greater than or\n    equal to zero.  If kappa is equal to zero, this distribution reduces\n    to a uniform random angle over the range 0 to 2*pi.\n\n    */\n    // mu:    mean angle (in radians between 0 and 2*pi)\n    // kappa: concentration parameter kappa (>= 0)\n    // if kappa = 0 generate uniform random angle\n\n    // Based upon an algorithm published in: Fisher, N.I.,\n    // \"Statistical Analysis of Circular Data\", Cambridge\n    // University Press, 1993.\n\n    // Thanks to Magnus Kessler for a correction to the\n    // implementation of step 4.\n\n    var $ = $B.args('vonmisesvariate', 3,\n            {self: null, mu: null, kappa:null}, ['self', 'mu', 'kappa'],\n            arguments, {}, null, null),\n        self = $.self,\n        mu = $.mu,\n        kappa = $.kappa,\n        TWOPI = 2*Math.PI\n\n    if(kappa <= 1e-6){return TWOPI * self._random()}\n\n    var s = 0.5 / kappa,\n        r = s + Math.sqrt(1.0 + s * s)\n\n    while(true){\n        var u1 = self._random(),\n            z = Math.cos(Math.PI * u1),\n            d = z / (r + z),\n            u2 = self._random()\n        if((u2 < 1.0 - d * d) ||\n            (u2 <= (1.0 - d) * Math.exp(d))){\n                break\n        }\n    }\n    var q = 1.0 / r,\n        f = (q + z) / (1.0 + q * z),\n        u3 = self._random()\n    if(u3 > 0.5){var theta = (mu + Math.acos(f)) % TWOPI}\n    else{var theta = (mu - Math.acos(f)) % TWOPI}\n    return theta\n}\n\nRandom.weibullvariate = function(){\n    /*Weibull distribution.\n\n    alpha is the scale parameter and beta is the shape parameter.\n\n    */\n    // Jain, pg. 499; bug fix courtesy Bill Arms\n    var $ = $B.args(\"weibullvariate\", 3,\n        {self: null, alpha: null, beta: null},\n        [\"self\", \"alpha\", \"beta\"], arguments, {}, null, null)\n\n    var u = 1 - $.self._random()\n    return $.alpha * Math.pow(-Math.log(u), 1 / $.beta)\n}\n\n$B.set_func_names(Random, \"random\")\n\nvar $module = Random.$factory()\nfor(var attr in Random){\n    $module[attr] = (function(x){\n        return function(){return Random[x]($module, ...arguments)}\n    })(attr)\n    $module[attr].$infos = Random[attr].$infos\n}\n\n$module.Random = Random\n\nvar SystemRandom = $B.make_class(\"SystemRandom\",\n    function(){\n        return {__class__: SystemRandom}\n    }\n)\nSystemRandom.__getattribute__ = function(){\n    throw $B.builtins.NotImplementedError.$factory()\n}\n\n$module.SystemRandom = SystemRandom\n\nreturn $module\n\n})(__BRYTHON__)\n\n"],
     "unicodedata": [".js", "// Implementation of unicodedata\n\nvar $module = (function($B){\n\n    var _b_ = $B.builtins\n\n    // Load unicode table if not already loaded\n    if($B.unicodedb === undefined){\n        var xhr = new XMLHttpRequest\n        xhr.open(\"GET\",\n            $B.brython_path + \"unicode.txt\", false)\n        xhr.onreadystatechange = function(){\n            if(this.readyState == 4){\n                if(this.status == 200){\n                    $B.unicodedb = this.responseText\n                }else{\n                    console.log(\"Warning - could not \" +\n                        \"load unicode.txt\")\n                }\n            }\n        }\n        xhr.send()\n    }\n\n    function _info(chr){\n        var ord = _b_.ord(chr),\n            hex = ord.toString(16).toUpperCase()\n        while(hex.length < 4){hex = \"0\" + hex}\n        var re = new RegExp(\"^\" + hex +\";(.+?);(.*?);(.*?);(.*?);(.*?);(.*);(.*);(.*)$\",\n                \"m\"),\n            search = re.exec($B.unicodedb)\n        if(search === null){\n            return null\n        }else{\n            return {\n                name: search[1],\n                category: search[2],\n                combining: search[3],\n                bidirectional: search[4],\n                decomposition: search[5],\n                decimal: search[6],\n                digit: search[7],\n                numeric: search[8]\n            }\n        }\n    }\n\n    function bidirectional(chr){\n        var search = _info(chr)\n        if(search === null){\n            console.log(\"error\", chr, hex)\n            throw _b_.KeyError.$factory(chr)\n        }\n        return search.bidirectional\n    }\n\n    function category(chr){\n        // Returns the general category assigned to the character chr as\n        // string.\n        if($B.is_unicode_cn(chr.codePointAt(0))){ // in unicode_data.js\n            return \"Cn\"\n        }\n        var search = _info(chr)\n        if(search === null){\n            console.log(\"error\", chr)\n            throw _b_.KeyError.$factory(chr)\n        }\n        return search.category\n    }\n\n    function combining(chr){\n        // Returns the general category assigned to the character chr as\n        // string.\n        var search = _info(chr)\n        if(search === null){\n            console.log(\"error\", chr)\n            throw _b_.KeyError.$factory(chr)\n        }\n        return parseInt(search.combining)\n    }\n\n    function decimal(chr, _default){\n        // Returns the decimal value assigned to the character chr as integer.\n        // If no such value is defined, default is returned, or, if not given,\n        // ValueError is raised.\n        var search = _info(chr)\n        if(search === null){\n            console.log(\"error\", chr)\n            throw _b_.KeyError.$factory(chr)\n        }\n        return parseInt(search.decimal)\n    }\n\n    function decomposition(chr, _default){\n        // Returns the decimal value assigned to the character chr as integer.\n        // If no such value is defined, default is returned, or, if not given,\n        // ValueError is raised.\n        var search = _info(chr)\n        if(search === null){\n            console.log(\"error\", chr)\n            throw _b_.KeyError.$factory(chr)\n        }\n        return search.decomposition\n    }\n\n    function digit(chr, _default){\n        // Returns the decimal value assigned to the character chr as integer.\n        // If no such value is defined, default is returned, or, if not given,\n        // ValueError is raised.\n        var search = _info(chr)\n        if(search === null){\n            console.log(\"error\", chr)\n            throw _b_.KeyError.$factory(chr)\n        }\n        return parseInt(search.digit)\n    }\n\n    function lookup(name){\n        // Look up character by name. If a character with the given name is\n        // found, return the corresponding character. If not found, KeyError\n        // is raised.\n        var re = new RegExp(\"^([0-9A-F]+);\" +\n            name + \";(.*)$\", \"m\")\n        search = re.exec($B.unicodedb)\n        if(search === null){\n            throw _b_.KeyError.$factory(\"undefined character name '\" +\n                name + \"'\")\n        }\n        var res = parseInt(search[1], 16)\n        return _b_.chr(res)\n    }\n\n    function name(chr, _default){\n        // Returns the name assigned to the character chr as a string. If no\n        // name is defined, default is returned, or, if not given, ValueError\n        // is raised.\n        var search = _info(chr)\n        if(search === null){\n            if(_default){return _default}\n            throw _b_.KeyError.$factory(\"undefined character name '\" +\n                chr + \"'\")\n        }\n        return search.name\n    }\n\n    function _norm(form, chr){\n        var search = _info(chr)\n        if(search === null){\n            throw _b_.KeyError.$factory(chr)\n        }\n        switch(form){\n            case \"NFC\":\n                return chr\n            case \"NFD\":\n                var decomp = decomposition(chr),\n                    parts = decomp.split(\" \"),\n                    res = \"\"\n                if(parts[0].startsWith(\"<\")){\n                    return chr\n                }\n                parts.forEach(function(part){\n                    if(! part.startsWith(\"<\")){\n                        res += _b_.chr(parseInt(part, 16))\n                    }\n                })\n                return res\n            case \"NFKC\":\n                var decomp = decomposition(chr),\n                    parts = decomp.split(\" \")\n                if(parts[0] == \"<compat>\"){\n                    var res = \"\"\n                    parts.slice(1).forEach(function(part){\n                        res += _b_.chr(parseInt(part, 16))\n                    })\n                    return res\n                }\n                return chr\n            case \"NFKD\":\n                var decomp = decomposition(chr),\n                    parts = decomp.split(\" \")\n                if(parts[0] == \"<compat>\"){\n                    var res = \"\"\n                    parts.slice(1).forEach(function(part){\n                        res += _b_.chr(parseInt(part, 16))\n                    })\n                    return res\n                }\n                return chr\n\n            default:\n                throw _b_.ValueError.$factory(\"invalid normalization form\")\n        }\n    }\n\n    function normalize(form, unistr){\n        var res = \"\"\n        for(var i = 0, len = unistr.length; i < len; i++){\n            res += _norm(form, unistr.charAt(i))\n        }\n        return res\n    }\n\n    function numeric(chr, _default){\n        // Returns the decimal value assigned to the character chr as integer.\n        // If no such value is defined, default is returned, or, if not given,\n        // ValueError is raised.\n        var search = _info(chr)\n        if(search === null){\n            if(_default){return _default}\n            throw _b_.KeyError.$factory(chr)\n        }\n        return new Number(eval(search.numeric))\n    }\n\n    var module = {\n        bidirectional: bidirectional,\n        category: category,\n        combining: combining,\n        decimal: decimal,\n        decomposition: decomposition,\n        digit: digit,\n        lookup: lookup,\n        name: name,\n        normalize: normalize,\n        numeric: numeric,\n        unidata_version: \"11.0.0\"\n    }\n    module.ucd_3_2_0 = {}\n    for(var key in module){\n        if(key == \"unidata_version\"){\n            module.ucd_3_2_0[key] = '3.2.0'\n        }else{\n            module.ucd_3_2_0[key] = module[key] // approximation...\n        }\n    }\n    return module\n\n})(__BRYTHON__)"],
     "_aio": [".js", "// Replacement for asyncio.\n//\n// CPython asyncio can't be implemented for Brython because it relies on\n// blocking function (eg run(), run_until_complete()), and such functions\n// can't be defined in Javascript. It also manages an event loop, and a\n// browser only has its own built-in event loop.\n//\n// This module exposes functions whose result can be \"await\"-ed inside\n// asynchrounous functions defined by \"async def\".\n\nvar $module = (function($B){\n\nvar _b_ = $B.builtins\n\nvar responseType = {\n    \"text\": \"text\",\n    \"binary\": \"arraybuffer\",\n    \"dataURL\": \"arraybuffer\"\n}\n\nfunction handle_kwargs(kw, method){\n    var data,\n        cache = false,\n        format = \"text\",\n        headers = {},\n        timeout = {}\n    for(var key in kw.$string_dict){\n        if(key == \"data\"){\n            var params = kw.$string_dict[key][0]\n            if(typeof params == \"string\"){\n                data = params\n            }else if(_b_.isinstance(params, _b_.bytes)){\n                data = new ArrayBuffer(params.source.length)\n                var array = new Int8Array(data)\n                for(var i = 0, len = params.source.length; i < len; i++){\n                    array[i] = params.source[i]\n                }\n            }else{\n                if(params.__class__ !== _b_.dict){\n                    throw _b_.TypeError.$factory(\"wrong type for data, \" +\n                        \"expected dict, bytes or str, got \" +\n                        $B.class_name(params))\n                }\n                params = params.$string_dict\n                var items = []\n                for(var key in params){\n                    items.push(encodeURIComponent(key) + \"=\" +\n                               encodeURIComponent(params[key][0]))\n                }\n                data = items.join(\"&\")\n            }\n        }else if(key == \"headers\"){\n            headers = _b_.dict.$to_obj(kw.$string_dict[key][0])\n        }else if(key.startsWith(\"on\")){\n            var event = key.substr(2)\n            if(event == \"timeout\"){\n                timeout.func = kw.$string_dict[key][0]\n            }else{\n                ajax.bind(self, event, kw.$string_dict[key][0])\n            }\n        }else if(key == \"timeout\"){\n            timeout.seconds = kw.$string_dict[key][0]\n        }else if(key == \"cache\"){\n            cache = kw.$string_dict[key][0]\n        }else if(key == \"format\"){\n            format = kw.$string_dict[key][0]\n        }\n    }\n    if(method == \"post\"){\n        // For POST requests, set default header\n        if(! headers.hasOwnProperty(\"Content-type\")){\n            headers[\"Content-Type\"] = \"application/x-www-form-urlencoded\"\n        }\n    }\n    return {\n        body: data,\n        cache: cache,\n        format: format,\n        timeout: timeout,\n        headers: headers\n    }\n}\n\nfunction ajax(){\n    var $ = $B.args(\"ajax\", 2, {method: null, url: null},\n            [\"method\", \"url\"], arguments, {},\n            null, \"kw\"),\n        method = $.method.toUpperCase(),\n        url = $.url,\n        kw = $.kw\n    var args = handle_kwargs(kw, \"get\")\n    if(method == \"GET\" && ! args.cache){\n        url = url + \"?ts\" + (new Date()).getTime() + \"=0\"\n    }\n    if(args.body && method == \"GET\"){\n        url = url + (args.cache ? \"?\" : \"&\") + args.body\n    }\n    var func = function(){\n        return new Promise(function(resolve, reject){\n            var xhr = new XMLHttpRequest()\n            xhr.open(method, url, true)\n            for(key in args.headers){\n                xhr.setRequestHeader(key, args.headers[key])\n            }\n            xhr.format = args.format\n            xhr.responseType = responseType[args.format]\n            xhr.onreadystatechange = function(){\n                if(this.readyState == 4){\n                    this.__class__ = HTTPRequest\n                    resolve(this)\n                }\n            }\n            if(args.body &&\n                    ['POST', 'PUT', 'DELETE', 'PATCH'].indexOf(method) > -1){\n                xhr.send(args.body)\n            }else{\n                xhr.send()\n            }\n        })\n    }\n    func.$infos = {\n        __name__: \"ajax_\" + method\n    }\n    return {\n        __class__: $B.coroutine,\n        $args: [url, args],\n        $func: func\n    }\n}\n\nfunction event(){\n    // event(element, *names) is a Promise on the events \"names\" happening on\n    // the element. This promise always resolves (never rejects) with the\n    // first triggered DOM event.\n    var $ = $B.args(\"event\", 1, {element: null},\n            [\"element\"], arguments, {}, \"names\", null),\n        element = $.element,\n        names = $.names\n    return new Promise(function(resolve){\n        var callbacks = []\n        names.forEach(function(name){\n            var callback = function(evt){\n                // When one of the handled events is triggered, all bindings\n                // are removed\n                callbacks.forEach(function(items){\n                    $B.DOMNode.unbind(element, items[0], items[1])\n                })\n                resolve($B.$DOMEvent(evt))\n            }\n            callbacks.push([name, callback])\n            $B.DOMNode.bind(element, name, callback)\n        })\n    })\n}\n\nvar HTTPRequest = $B.make_class(\"Request\")\n\nHTTPRequest.data = _b_.property.$factory(function(self){\n    if(self.format == \"binary\"){\n        var view = new Uint8Array(self.response)\n        return _b_.bytes.$factory(Array.from(view))\n    }else if(self.format == \"text\"){\n        return self.responseText\n    }else if(self.format == \"dataURL\"){\n        var base64String = btoa(String.fromCharCode.apply(null,\n            new Uint8Array(self.response)))\n        return \"data:\" + self.getResponseHeader(\"Content-Type\") +\n            \";base64,\" + base64String\n    }\n})\n\nHTTPRequest.response_headers = _b_.property.$factory(function(self){\n    var headers = self.getAllResponseHeaders()\n    if(headers === null){return _b_.None}\n    var res = $B.empty_dict()\n    if(headers.length > 0){\n        // Convert the header string into an array\n        // of individual headers\n        var lines = headers.trim().split(/[\\r\\n]+/)\n        // Create a map of header names to values\n        lines.forEach(function(line){\n          var parts = line.split(': ')\n          var header = parts.shift()\n          var value = parts.join(': ')\n          _b_.dict.$setitem(res, header, value)\n        })\n    }\n    return res\n})\n\nfunction get(){\n    return ajax.bind(null, \"GET\").apply(null, arguments)\n}\n\nfunction iscoroutine(f){\n    return f.__class__ === $B.coroutine\n}\n\nfunction iscoroutinefunction(f){\n    return (f.$infos.__code__.co_flags & 128) != 0\n}\n\nfunction post(){\n    return ajax.bind(null, \"POST\").apply(null, arguments)\n}\n\nfunction run(coro){\n    var handle_success = function(){\n            $B.leave_frame()\n        },\n        handle_error = function(err){\n            // coro.$stack is a snapshot of the frames stack when the async\n            // function was called. Restore it to get the correct call tree\n            err.$stack = coro.$stack.concat([$B.last(err.$stack)])\n            $B.handle_error(err)\n        }\n\n    var $ = $B.args(\"run\", 3, {coro: null, onsuccess: null, onerror: null},\n            [\"coro\", \"onsuccess\", \"onerror\"], arguments,\n            {onsuccess: handle_success, onerror: handle_error},\n            null, null),\n        coro = $.coro,\n        onsuccess = $.onsuccess,\n        onerror = $.onerror\n\n    if(onerror !== handle_error){\n        function error_func(exc){\n            try{\n                onerror(exc)\n            }catch(err){\n                handle_error(err)\n            }\n        }\n    }else{\n        error_func = handle_error\n    }\n    var save_stack = $B.frames_stack.slice()\n    $B.coroutine.send(coro).then(onsuccess).catch(error_func)\n    $B.frames_stack = save_stack\n    return _b_.None\n}\n\nfunction sleep(seconds){\n    var func = function(){\n        return new Promise(resolve => setTimeout(\n            function(){resolve(_b_.None)}, 1000 * seconds))\n    }\n    func.$infos = {\n        __name__: \"sleep\"\n    }\n    return {\n        __class__: $B.coroutine,\n        $args: [seconds],\n        $func: func\n    }\n}\n\nreturn {\n    ajax: ajax,\n    event: event,\n    get: get,\n    iscoroutine: iscoroutine,\n    iscoroutinefunction: iscoroutinefunction,\n    post: post,\n    run: run,\n    sleep: sleep\n}\n\n})(__BRYTHON__)\n"],
-    "_ajax": [".js", "// ajax\nvar $module = (function($B){\n\neval($B.InjectBuiltins())\nvar $N = $B.builtins.None,\n    _b_ = $B.builtins\n\nvar add_to_res = function(res, key, val) {\n    if(isinstance(val, list)){\n        for (j = 0; j < val.length; j++) {\n            add_to_res(res, key, val[j])\n        }\n    }else if (val instanceof File || val instanceof Blob){\n        res.append(key, val)\n    }else{res.append(key,str.$factory(val))}\n}\n\nfunction set_timeout(self, timeout){\n    if(timeout.seconds !== undefined){\n        self.js.$requestTimer = setTimeout(\n            function() {\n                self.js.abort()\n                if(timeout.func){\n                    timeout.func()\n                }\n            },\n            timeout.seconds * 1000)\n    }\n}\n\nfunction _read(req){\n    var xhr = req.js\n    if(xhr.responseType == \"json\"){\n        return $B.structuredclone2pyobj(xhr.response)\n    }\n    if(typeof xhr.response == \"string\"){\n        // on blocking mode, xhr.response is a string\n        var bytes = []\n        for(var i = 0, len = xhr.response.length; i < len; i++){\n            var cp = xhr.response.codePointAt(i)\n            if(cp > 0xf700){\n                bytes.push(cp - 0xf700)\n            }else{\n                bytes.push(cp)\n            }\n        }\n    }else{\n        // else it's an ArrayBuffer\n        var buf = new Uint8Array(xhr.response),\n            bytes = Array.from(buf.values())\n    }\n    var b = _b_.bytes.$factory(bytes)\n    if(req.mode == \"binary\"){\n        return b\n    }else if(req.mode == \"document\"){\n        return $B.JSObj.$factory(xhr.response)\n    }else{\n        var encoding = req.encoding || \"utf-8\"\n        return _b_.bytes.decode(b, encoding)\n    }\n}\n\nfunction handle_kwargs(self, kw, method){\n    var data,\n        encoding,\n        headers={},\n        cache,\n        mode = \"text\",\n        timeout = {}\n    for(var key in kw.$string_dict){\n        if(key == \"data\"){\n            var params = kw.$string_dict[key][0]\n            if(typeof params == \"string\"){\n                data = params\n            }else if(params.__class__ === _b_.dict){\n                for(var key in params.$numeric_dict){\n                    throw _b_.ValueError.$factory(\n                        'data only supports string keys, got ' + key)\n                }\n                params = params.$string_dict\n                var items = []\n                for(var key in params){\n                    items.push(encodeURIComponent(key) + \"=\" +\n                               encodeURIComponent(params[key][0]))\n                }\n                data = items.join(\"&\")\n            }else{\n                throw _b_.TypeError.$factory(\"wrong type for data: \" +\n                    $B.class_name(params))\n            }\n        }else if(key == \"encoding\"){\n            encoding = kw.$string_dict[key][0]\n        }else if(key == \"headers\"){\n            var value = kw.$string_dict[key][0]\n            if(! _b_.isinstance(value, _b_.dict)){\n                throw _b_.ValueError.$factory(\n                    \"headers must be a dict, not \" + $B.class_name(value))\n            }\n            for(key in value.$string_dict){\n                headers[key.toLowerCase()] = [key, value.$string_dict[key][0]]\n            }\n        }else if(key.startsWith(\"on\")){\n            var event = key.substr(2)\n            if(event == \"timeout\"){\n                timeout.func = kw.$string_dict[key][0]\n            }else{\n                var f = kw.$string_dict[key][0]\n                ajax.bind(self, event, f)\n            }\n        }else if(key == \"mode\"){\n            var mode = kw.$string_dict[key][0]\n        }else if(key == \"timeout\"){\n            timeout.seconds = kw.$string_dict[key][0]\n        }else if(key == \"cache\"){\n            cache = kw.$string_dict[key][0]\n        }\n    }\n    if(encoding && mode != \"text\"){\n        throw _b_.ValueError.$factory(\"encoding not supported for mode \" +\n            mode)\n    }\n    if((method == \"post\" || method == \"put\") && ! headers){\n        // For POST requests, set default header\n        self.js.setRequestHeader(\"Content-type\",\n                                 \"application/x-www-form-urlencoded\")\n    }\n    return {cache, data, encoding, headers, mode, timeout}\n}\n\nvar ajax = {\n    __class__: _b_.type,\n    __mro__: [_b_.object],\n\n    __repr__ : function(self){return '<object Ajax>'},\n    __str__ : function(self){return '<object Ajax>'},\n\n    $infos: {\n        __module__: \"builtins\",\n        __name__: \"ajax\"\n    },\n\n    __getattribute__: function(self, attr){\n        if(ajax[attr] !== undefined){\n            return function(){\n                return ajax[attr].call(null, self, ...arguments)\n            }\n        }else if(attr == \"text\"){\n            return _read(self)\n        }else if(attr == \"json\"){\n            if(self.js.responseType == \"json\"){\n                return _read(self)\n            }else{\n                var resp = _read(self)\n                try{\n                    return $B.structuredclone2pyobj(JSON.parse(resp))\n                }catch(err){\n                    console.log('attr json, invalid resp', resp)\n                    throw err\n                }\n            }\n        }else if(self.js[attr] !== undefined){\n            if(typeof self.js[attr] == \"function\"){\n                return function(){\n                    if(attr == \"setRequestHeader\"){\n                        ajax.set_header.call(null, self, ...arguments)\n                    }else{\n                        if(attr == 'overrideMimeType'){\n                            console.log('override mime type')\n                            self.hasMimeType = true\n                        }\n                        return self.js[attr](...arguments)\n                    }\n                }\n            }else{\n                return self.js[attr]\n            }\n        }else if(attr == \"xml\"){\n            return $B.JSObj.$factory(self.js.responseXML)\n        }\n    },\n\n    bind: function(self, evt, func){\n        // req.bind(evt,func) is the same as req.onevt = func\n        self.js['on' + evt] = function(){\n            try{\n                return func.apply(null, arguments)\n            }catch(err){\n                $B.handle_error(err)\n            }\n        }\n        return _b_.None\n    },\n\n    open: function(){\n        var $ = $B.args('open', 4,\n                {self: null, method: null, url: null, async: null},\n                ['self', 'method', 'url', 'async'], arguments,\n                {async: true}, null, null),\n            self = $.self,\n            method = $.method,\n            url = $.url,\n            async = $.async\n        self.$method = method\n        self.blocking = ! self.async\n        self.js.open(method, url, async)\n    },\n\n    read: function(self){\n        return _read(self)\n    },\n\n    send: function(self, params){\n        // params can be Python dictionary or string\n        var content_type\n        for(var key in self.headers){\n            var header = self.headers[key]\n            self.js.setRequestHeader(header[0], header[1])\n            if(key == 'content-type'){\n                content_type = header[1]\n            }\n        }\n        if((self.encoding || self.blocking) && ! self.hasMimeType){\n            // On blocking mode, or if an encoding has been specified,\n            // override Mime type so that bytes are not processed\n            // (unless the Mime type has been explicitely set)\n            self.js.overrideMimeType('text/plain;charset=x-user-defined')\n        }\n        var res = ''\n        if(! params){\n            self.js.send()\n            return _b_.None\n        }\n        if(isinstance(params, str)){\n            res = params\n        }else if(isinstance(params, dict)){\n            if(content_type == 'multipart/form-data'){\n                // The FormData object serializes the data in the 'multipart/form-data'\n                // content-type so we may as well override that header if it was set\n                // by the user.\n                res = new FormData()\n                var items = _b_.list.$factory(_b_.dict.items(params))\n                for(var i = 0, len = items.length; i < len; i++){\n                    add_to_res(res, str.$factory(items[i][0]), items[i][1])\n                }\n            }else{\n                if(self.$method && self.$method.toUpperCase() == \"POST\" &&\n                        ! content_type){\n                    // Set default Content-Type for POST requests\n                    self.js.setRequestHeader(\"Content-Type\",\n                        \"application/x-www-form-urlencoded\")\n                }\n                var items = _b_.list.$factory(_b_.dict.items(params))\n                for(var i = 0, len = items.length; i < len; i++){\n                    var key = encodeURIComponent(str.$factory(items[i][0]));\n                    if(isinstance(items[i][1], list)){\n                        for (j = 0; j < items[i][1].length; j++) {\n                            res += key +'=' +\n                                encodeURIComponent(str.$factory(items[i][1][j])) + '&'\n                        }\n                    }else{\n                        res += key + '=' +\n                            encodeURIComponent(str.$factory(items[i][1])) + '&'\n                    }\n                }\n                res = res.substr(0, res.length - 1)\n            }\n        }else{\n            throw _b_.TypeError.$factory(\n                \"send() argument must be string or dictionary, not '\" +\n                str.$factory(params.__class__) + \"'\")\n        }\n        self.js.send(res)\n        return _b_.None\n    },\n\n    set_header: function(self, key, value){\n        self.headers[key.toLowerCase()] = [key, value]\n    },\n\n    set_timeout: function(self, seconds, func){\n        self.js.$requestTimer = setTimeout(\n            function() {\n                self.js.abort()\n                func()\n            },\n            seconds * 1000)\n    }\n\n}\n\najax.$factory = function(){\n\n    if(window.XMLHttpRequest){// code for IE7+, Firefox, Chrome, Opera, Safari\n        var xmlhttp = new XMLHttpRequest()\n    }else{// code for IE6, IE5\n        var xmlhttp = new ActiveXObject(\"Microsoft.XMLHTTP\")\n    }\n    xmlhttp.onreadystatechange = function(){\n        // here, \"this\" refers to xmlhttp\n        var state = this.readyState\n        if(this.responseType == \"\" || this.responseType == \"text\"){\n            res.js.text = this.responseText\n        }\n        var timer = this.$requestTimer\n        if(state == 0 && this.onuninitialized){\n            this.onuninitialized(res)\n        }else if(state == 1 && this.onloading){\n            this.onloading(res)\n        }else if(state == 2 && this.onloaded){\n            this.onloaded(res)\n        }else if(state == 3 && this.oninteractive){\n            this.oninteractive(res)\n        }else if(state == 4 && this.oncomplete){\n            if(timer !== null){\n                window.clearTimeout(timer)\n            }\n            this.oncomplete(res)\n        }\n    }\n    var res = {\n        __class__: ajax,\n        js: xmlhttp,\n        headers: {}\n    }\n    return res\n}\n\nfunction _request_without_body(method){\n    var $ = $B.args(method, 3, {method: null, url: null, blocking: null},\n        [\"method\", \"url\", \"blocking\"], arguments, {blocking: false},\n        null, \"kw\"),\n    method = $.method,\n    url = $.url,\n    async = !$.blocking,\n    kw = $.kw\n    var self = ajax.$factory()\n    self.blocking = $.blocking\n    var items = handle_kwargs(self, kw, method),\n        mode = self.mode = items.mode,\n        encoding = self.encoding = items.encoding\n        qs = items.data,\n        timeout = items.timeout\n    set_timeout(self, timeout)\n    if(qs){\n        url += \"?\" + qs\n    }\n    if(! (items.cache === true)){\n        url += (qs ? \"&\" : \"?\") + (new Date()).getTime()\n    }\n    self.js.open(method.toUpperCase(), url, async)\n\n    if(async){\n        if(mode == \"json\" || mode == \"document\"){\n            self.js.responseType = mode\n        }else{\n            self.js.responseType = \"arraybuffer\"\n            if(mode != \"text\" && mode != \"binary\"){\n                throw _b_.ValueError.$factory(\"invalid mode: \" + mode)\n            }\n        }\n    }else{\n        self.js.overrideMimeType('text/plain;charset=x-user-defined')\n    }\n    for(var key in items.headers){\n        var header = items.headers[key]\n        self.js.setRequestHeader(header[0], header[1])\n    }\n    // Add function read() to return str or bytes according to mode\n    self.js.send()\n}\n\nfunction _request_with_body(method){\n    var $ = $B.args(method, 3, {method: null, url: null, blocking: null},\n        [\"method\", \"url\", \"blocking\"], arguments, {blocking: false},\n        null, \"kw\"),\n        method = $.method,\n        url = $.url,\n        async = !$.blocking,\n        kw = $.kw,\n        content_type\n\n    var self = ajax.$factory()\n    self.js.open(method.toUpperCase(), url, async)\n    var items = handle_kwargs(self, kw, method),\n        data = items.data,\n        timeout = items.timeout\n    set_timeout(self, timeout)\n    for(var key in items.headers){\n        var header = items.headers[key]\n        self.js.setRequestHeader(header[0], header[1])\n        if(key == 'content-type'){\n            content_type = header[1]\n        }\n    }\n    if(method.toUpperCase() == 'POST' && !content_type){\n        // set default Content-Type for POST requests\n        self.js.setRequestHeader('Content-Type',\n            'application/x-www-form-urlencoded')\n    }\n\n    // Add function read() to return str or bytes according to mode\n    self.js.read = function(){\n        return _read(self)\n    }\n    self.js.send(data)\n}\n\nfunction connect(){\n    _request_without_body.call(null, \"connect\", ...arguments)\n}\n\nfunction _delete(){\n    _request_without_body.call(null, \"delete\", ...arguments)\n}\n\nfunction get(){\n    _request_without_body.call(null, \"get\", ...arguments)\n}\n\nfunction head(){\n    _request_without_body.call(null, \"head\", ...arguments)\n}\n\nfunction options(){\n    _request_without_body.call(null, \"options\", ...arguments)\n}\n\nfunction patch(){\n    _request_with_body.call(null, \"put\", ...arguments)\n}\n\nfunction post(){\n    _request_with_body.call(null, \"post\", ...arguments)\n}\n\nfunction put(){\n    _request_with_body.call(null, \"put\", ...arguments)\n}\n\nfunction trace(){\n    _request_without_body.call(null, \"trace\", ...arguments)\n}\n\nfunction file_upload(){\n    // ajax.file_upload(url, file, method=\"POST\", **callbacks)\n    var $ = $B.args(\"file_upload\", 2, {url: null, \"file\": file},\n            [\"url\", \"file\"], arguments, {}, null, \"kw\"),\n        url = $.url,\n        file = $.file,\n        kw = $.kw\n\n    var self = ajax.$factory(),\n        method = 'POST',\n        field_name = 'filetosave'\n\n    if(kw.$string_dict.method !== undefined){\n        method = kw.$string_dict.method[0]\n    }\n\n    if(kw.$string_dict.field_name !== undefined){\n        field_name = kw.$string_dict.field_name[0]\n    }\n\n    var formdata = new FormData()\n    formdata.append(field_name, file, file.name)\n\n    self.js.open(method, url, True)\n    self.js.send(formdata)\n\n    for(key in kw.$string_dict){\n        if(key.startsWith(\"on\")){\n            ajax.bind(self, key.substr(2), kw.$string_dict[key][0])\n        }\n    }\n}\n\n$B.set_func_names(ajax)\n\nreturn {\n    ajax: ajax,\n    Ajax: ajax,\n    $$delete: _delete,\n    file_upload: file_upload,\n    connect,\n    get,\n    head,\n    options,\n    patch,\n    post,\n    put,\n    trace\n}\n\n})(__BRYTHON__)\n"],
+    "_ajax": [".js", "// ajax\nvar $module = (function($B){\n\n\nvar $N = $B.builtins.None,\n    _b_ = $B.builtins\n\nvar add_to_res = function(res, key, val) {\n    if(_b_.isinstance(val, _b_.list)){\n        for (j = 0; j < val.length; j++) {\n            add_to_res(res, key, val[j])\n        }\n    }else if (val instanceof File || val instanceof Blob){\n        res.append(key, val)\n    }else{res.append(key, _b_.str.$factory(val))}\n}\n\nfunction set_timeout(self, timeout){\n    if(timeout.seconds !== undefined){\n        self.js.$requestTimer = setTimeout(\n            function() {\n                self.js.abort()\n                if(timeout.func){\n                    timeout.func()\n                }\n            },\n            timeout.seconds * 1000)\n    }\n}\n\nfunction _read(req){\n    var xhr = req.js\n    if(xhr.responseType == \"json\"){\n        return $B.structuredclone2pyobj(xhr.response)\n    }\n    if(typeof xhr.response == \"string\"){\n        // on blocking mode, xhr.response is a string\n        var bytes = []\n        for(var i = 0, len = xhr.response.length; i < len; i++){\n            var cp = xhr.response.codePointAt(i)\n            if(cp > 0xf700){\n                bytes.push(cp - 0xf700)\n            }else{\n                bytes.push(cp)\n            }\n        }\n    }else{\n        // else it's an ArrayBuffer\n        var buf = new Uint8Array(xhr.response),\n            bytes = Array.from(buf.values())\n    }\n    var b = _b_.bytes.$factory(bytes)\n    if(req.mode == \"binary\"){\n        return b\n    }else if(req.mode == \"document\"){\n        return $B.JSObj.$factory(xhr.response)\n    }else{\n        var encoding = req.encoding || \"utf-8\"\n        return _b_.bytes.decode(b, encoding)\n    }\n}\n\nfunction handle_kwargs(self, kw, method){\n    var data,\n        encoding,\n        headers={},\n        cache,\n        mode = \"text\",\n        timeout = {}\n    for(var key in kw.$string_dict){\n        if(key == \"data\"){\n            var params = kw.$string_dict[key][0]\n            if(typeof params == \"string\"){\n                data = params\n            }else if(params.__class__ === _b_.dict){\n                for(var key in params.$numeric_dict){\n                    throw _b_.ValueError.$factory(\n                        'data only supports string keys, got ' + key)\n                }\n                params = params.$string_dict\n                var items = []\n                for(var key in params){\n                    items.push(encodeURIComponent(key) + \"=\" +\n                               encodeURIComponent(params[key][0]))\n                }\n                data = items.join(\"&\")\n            }else{\n                throw _b_.TypeError.$factory(\"wrong type for data: \" +\n                    $B.class_name(params))\n            }\n        }else if(key == \"encoding\"){\n            encoding = kw.$string_dict[key][0]\n        }else if(key == \"headers\"){\n            var value = kw.$string_dict[key][0]\n            if(! _b_.isinstance(value, _b_.dict)){\n                throw _b_.ValueError.$factory(\n                    \"headers must be a dict, not \" + $B.class_name(value))\n            }\n            for(key in value.$string_dict){\n                headers[key.toLowerCase()] = [key, value.$string_dict[key][0]]\n            }\n        }else if(key.startsWith(\"on\")){\n            var event = key.substr(2)\n            if(event == \"timeout\"){\n                timeout.func = kw.$string_dict[key][0]\n            }else{\n                var f = kw.$string_dict[key][0]\n                ajax.bind(self, event, f)\n            }\n        }else if(key == \"mode\"){\n            var mode = kw.$string_dict[key][0]\n        }else if(key == \"timeout\"){\n            timeout.seconds = kw.$string_dict[key][0]\n        }else if(key == \"cache\"){\n            cache = kw.$string_dict[key][0]\n        }\n    }\n    if(encoding && mode != \"text\"){\n        throw _b_.ValueError.$factory(\"encoding not supported for mode \" +\n            mode)\n    }\n    if((method == \"post\" || method == \"put\") && ! headers){\n        // For POST requests, set default header\n        self.js.setRequestHeader(\"Content-type\",\n                                 \"application/x-www-form-urlencoded\")\n    }\n    return {cache, data, encoding, headers, mode, timeout}\n}\n\nvar ajax = {\n    __class__: _b_.type,\n    __mro__: [_b_.object],\n\n    __repr__ : function(self){return '<object Ajax>'},\n    __str__ : function(self){return '<object Ajax>'},\n\n    $infos: {\n        __module__: \"builtins\",\n        __name__: \"ajax\"\n    },\n\n    __getattribute__: function(self, attr){\n        if(ajax[attr] !== undefined){\n            return function(){\n                return ajax[attr].call(null, self, ...arguments)\n            }\n        }else if(attr == \"text\"){\n            return _read(self)\n        }else if(attr == \"json\"){\n            if(self.js.responseType == \"json\"){\n                return _read(self)\n            }else{\n                var resp = _read(self)\n                try{\n                    return $B.structuredclone2pyobj(JSON.parse(resp))\n                }catch(err){\n                    console.log('attr json, invalid resp', resp)\n                    throw err\n                }\n            }\n        }else if(self.js[attr] !== undefined){\n            if(typeof self.js[attr] == \"function\"){\n                return function(){\n                    if(attr == \"setRequestHeader\"){\n                        ajax.set_header.call(null, self, ...arguments)\n                    }else{\n                        if(attr == 'overrideMimeType'){\n                            console.log('override mime type')\n                            self.hasMimeType = true\n                        }\n                        return self.js[attr](...arguments)\n                    }\n                }\n            }else{\n                return self.js[attr]\n            }\n        }else if(attr == \"xml\"){\n            return $B.JSObj.$factory(self.js.responseXML)\n        }\n    },\n\n    bind: function(self, evt, func){\n        // req.bind(evt,func) is the same as req.onevt = func\n        self.js['on' + evt] = function(){\n            try{\n                return func.apply(null, arguments)\n            }catch(err){\n                $B.handle_error(err)\n            }\n        }\n        return _b_.None\n    },\n\n    open: function(){\n        var $ = $B.args('open', 4,\n                {self: null, method: null, url: null, async: null},\n                ['self', 'method', 'url', 'async'], arguments,\n                {async: true}, null, null),\n            self = $.self,\n            method = $.method,\n            url = $.url,\n            async = $.async\n        if(typeof method !== \"string\"){\n            throw _b_.TypeError.$factory(\n                'open() argument method should be string, got ' +\n                $B.class_name(method))\n        }\n        if(typeof url !== \"string\"){\n            throw _b_.TypeError.$factory(\n                'open() argument url should be string, got ' +\n                $B.class_name(url))\n        }\n        self.$method = method\n        self.blocking = ! self.async\n        self.js.open(method, url, async)\n    },\n\n    read: function(self){\n        return _read(self)\n    },\n\n    send: function(self, params){\n        // params can be Python dictionary or string\n        var content_type\n        for(var key in self.headers){\n            var header = self.headers[key]\n            self.js.setRequestHeader(header[0], header[1])\n            if(key == 'content-type'){\n                content_type = header[1]\n            }\n        }\n        if((self.encoding || self.blocking) && ! self.hasMimeType){\n            // On blocking mode, or if an encoding has been specified,\n            // override Mime type so that bytes are not processed\n            // (unless the Mime type has been explicitely set)\n            self.js.overrideMimeType('text/plain;charset=x-user-defined')\n        }\n        var res = ''\n        if(! params){\n            self.js.send()\n            return _b_.None\n        }\n        if(_b_.isinstance(params, _b_.str)){\n            res = params\n        }else if(_b_.isinstance(params, _b_.dict)){\n            if(content_type == 'multipart/form-data'){\n                // The FormData object serializes the data in the 'multipart/form-data'\n                // content-type so we may as well override that header if it was set\n                // by the user.\n                res = new FormData()\n                var items = _b_.list.$factory(_b_.dict.items(params))\n                for(var i = 0, len = items.length; i < len; i++){\n                    add_to_res(res, _b_.str.$factory(items[i][0]), items[i][1])\n                }\n            }else{\n                if(self.$method && self.$method.toUpperCase() == \"POST\" &&\n                        ! content_type){\n                    // Set default Content-Type for POST requests\n                    self.js.setRequestHeader(\"Content-Type\",\n                        \"application/x-www-form-urlencoded\")\n                }\n                var items = _b_.list.$factory(_b_.dict.items(params))\n                for(var i = 0, len = items.length; i < len; i++){\n                    var key = encodeURIComponent(_b_.str.$factory(items[i][0]));\n                    if(_b_.isinstance(items[i][1], _b_.list)){\n                        for (j = 0; j < items[i][1].length; j++) {\n                            res += key +'=' +\n                                encodeURIComponent(_b_.str.$factory(items[i][1][j])) + '&'\n                        }\n                    }else{\n                        res += key + '=' +\n                            encodeURIComponent(_b_.str.$factory(items[i][1])) + '&'\n                    }\n                }\n                res = res.substr(0, res.length - 1)\n            }\n        }else{\n            throw _b_.TypeError.$factory(\n                \"send() argument must be string or dictionary, not '\" +\n                _b_.str.$factory(params.__class__) + \"'\")\n        }\n        self.js.send(res)\n        return _b_.None\n    },\n\n    set_header: function(self, key, value){\n        self.headers[key.toLowerCase()] = [key, value]\n    },\n\n    set_timeout: function(self, seconds, func){\n        self.js.$requestTimer = setTimeout(\n            function() {\n                self.js.abort()\n                func()\n            },\n            seconds * 1000)\n    }\n\n}\n\najax.$factory = function(){\n\n    if(window.XMLHttpRequest){// code for IE7+, Firefox, Chrome, Opera, Safari\n        var xmlhttp = new XMLHttpRequest()\n    }else{// code for IE6, IE5\n        var xmlhttp = new ActiveXObject(\"Microsoft.XMLHTTP\")\n    }\n    xmlhttp.onreadystatechange = function(){\n        // here, \"this\" refers to xmlhttp\n        var state = this.readyState\n        if(this.responseType == \"\" || this.responseType == \"text\"){\n            res.js.text = this.responseText\n        }\n        var timer = this.$requestTimer\n        if(state == 0 && this.onuninitialized){\n            this.onuninitialized(res)\n        }else if(state == 1 && this.onloading){\n            this.onloading(res)\n        }else if(state == 2 && this.onloaded){\n            this.onloaded(res)\n        }else if(state == 3 && this.oninteractive){\n            this.oninteractive(res)\n        }else if(state == 4 && this.oncomplete){\n            if(timer !== null){\n                window.clearTimeout(timer)\n            }\n            this.oncomplete(res)\n        }\n    }\n    var res = {\n        __class__: ajax,\n        js: xmlhttp,\n        headers: {}\n    }\n    return res\n}\n\nfunction _request_without_body(method){\n    var $ = $B.args(method, 3, {method: null, url: null, blocking: null},\n        [\"method\", \"url\", \"blocking\"], arguments, {blocking: false},\n        null, \"kw\"),\n    method = $.method,\n    url = $.url,\n    async = !$.blocking,\n    kw = $.kw\n    var self = ajax.$factory()\n    self.blocking = $.blocking\n    var items = handle_kwargs(self, kw, method),\n        mode = self.mode = items.mode,\n        encoding = self.encoding = items.encoding\n        qs = items.data,\n        timeout = items.timeout\n    set_timeout(self, timeout)\n    if(qs){\n        url += \"?\" + qs\n    }\n    if(! (items.cache === true)){\n        url += (qs ? \"&\" : \"?\") + (new Date()).getTime()\n    }\n    self.js.open(method.toUpperCase(), url, async)\n\n    if(async){\n        if(mode == \"json\" || mode == \"document\"){\n            self.js.responseType = mode\n        }else{\n            self.js.responseType = \"arraybuffer\"\n            if(mode != \"text\" && mode != \"binary\"){\n                throw _b_.ValueError.$factory(\"invalid mode: \" + mode)\n            }\n        }\n    }else{\n        self.js.overrideMimeType('text/plain;charset=x-user-defined')\n    }\n    for(var key in items.headers){\n        var header = items.headers[key]\n        self.js.setRequestHeader(header[0], header[1])\n    }\n    // Add function read() to return str or bytes according to mode\n    self.js.send()\n}\n\nfunction _request_with_body(method){\n    var $ = $B.args(method, 3, {method: null, url: null, blocking: null},\n        [\"method\", \"url\", \"blocking\"], arguments, {blocking: false},\n        null, \"kw\"),\n        method = $.method,\n        url = $.url,\n        async = !$.blocking,\n        kw = $.kw,\n        content_type\n\n    var self = ajax.$factory()\n    self.js.open(method.toUpperCase(), url, async)\n    var items = handle_kwargs(self, kw, method),\n        data = items.data,\n        timeout = items.timeout\n    set_timeout(self, timeout)\n    for(var key in items.headers){\n        var header = items.headers[key]\n        self.js.setRequestHeader(header[0], header[1])\n        if(key == 'content-type'){\n            content_type = header[1]\n        }\n    }\n    if(method.toUpperCase() == 'POST' && !content_type){\n        // set default Content-Type for POST requests\n        self.js.setRequestHeader('Content-Type',\n            'application/x-www-form-urlencoded')\n    }\n\n    // Add function read() to return str or bytes according to mode\n    self.js.read = function(){\n        return _read(self)\n    }\n    self.js.send(data)\n}\n\nfunction connect(){\n    _request_without_body.call(null, \"connect\", ...arguments)\n}\n\nfunction _delete(){\n    _request_without_body.call(null, \"delete\", ...arguments)\n}\n\nfunction get(){\n    _request_without_body.call(null, \"get\", ...arguments)\n}\n\nfunction head(){\n    _request_without_body.call(null, \"head\", ...arguments)\n}\n\nfunction options(){\n    _request_without_body.call(null, \"options\", ...arguments)\n}\n\nfunction patch(){\n    _request_with_body.call(null, \"put\", ...arguments)\n}\n\nfunction post(){\n    _request_with_body.call(null, \"post\", ...arguments)\n}\n\nfunction put(){\n    _request_with_body.call(null, \"put\", ...arguments)\n}\n\nfunction trace(){\n    _request_without_body.call(null, \"trace\", ...arguments)\n}\n\nfunction file_upload(){\n    // ajax.file_upload(url, file, method=\"POST\", **callbacks)\n    var $ = $B.args(\"file_upload\", 2, {url: null, \"file\": file},\n            [\"url\", \"file\"], arguments, {}, null, \"kw\"),\n        url = $.url,\n        file = $.file,\n        kw = $.kw\n\n    var self = ajax.$factory(),\n        method = 'POST',\n        field_name = 'filetosave'\n\n    if(kw.$string_dict.method !== undefined){\n        method = kw.$string_dict.method[0]\n    }\n\n    if(kw.$string_dict.field_name !== undefined){\n        field_name = kw.$string_dict.field_name[0]\n    }\n\n    var formdata = new FormData()\n    formdata.append(field_name, file, file.name)\n\n    self.js.open(method, url, _b_.True)\n    self.js.send(formdata)\n\n    for(key in kw.$string_dict){\n        if(key.startsWith(\"on\")){\n            ajax.bind(self, key.substr(2), kw.$string_dict[key][0])\n        }\n    }\n}\n\n$B.set_func_names(ajax)\n\nreturn {\n    ajax: ajax,\n    Ajax: ajax,\n    delete: _delete,\n    file_upload: file_upload,\n    connect,\n    get,\n    head,\n    options,\n    patch,\n    post,\n    put,\n    trace\n}\n\n})(__BRYTHON__)\n"],
     "_base64": [".js", "var $module=(function($B){\n\nvar _b_ = $B.builtins,\n    _keyStr = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\"\n\nfunction make_alphabet(altchars){\n    var alphabet = _keyStr\n    if(altchars !== undefined && altchars !== _b_.None){\n        // altchars is an instance of Python bytes\n        var source = altchars.source\n        alphabet = alphabet.substr(0,alphabet.length-3) +\n            _b_.chr(source[0]) + _b_.chr(source[1]) + '='\n    }\n    return alphabet\n}\n\nvar Base64 = {\n    error: function(){return 'binascii_error'},\n\n    encode: function(bytes, altchars){\n\n        var input = bytes.source,\n            output = \"\",\n            chr1, chr2, chr3, enc1, enc2, enc3, enc4\n        var i = 0\n\n        var alphabet = make_alphabet(altchars)\n\n        while(i < input.length){\n\n            chr1 = input[i++]\n            chr2 = input[i++]\n            chr3 = input[i++]\n\n            enc1 = chr1 >> 2\n            enc2 = ((chr1 & 3) << 4) | (chr2 >> 4)\n            enc3 = ((chr2 & 15) << 2) | (chr3 >> 6)\n            enc4 = chr3 & 63\n\n            if(isNaN(chr2)){\n                enc3 = enc4 = 64\n            }else if(isNaN(chr3)){\n                enc4 = 64\n            }\n\n            output = output + alphabet.charAt(enc1) +\n                alphabet.charAt(enc2) +\n                alphabet.charAt(enc3) +\n                alphabet.charAt(enc4)\n\n        }\n        return _b_.bytes.$factory(output, 'utf-8', 'strict')\n    },\n\n\n    decode: function(bytes, altchars, validate){\n        var output = [],\n            chr1, chr2, chr3,\n            enc1, enc2, enc3, enc4\n\n        var alphabet = make_alphabet(altchars)\n\n        var input = bytes.source\n\n        // If validate is set, check that all characters in input\n        // are in the alphabet\n        var _input = ''\n        var padding = 0\n        for(var i = 0, len = input.length; i < len; i++){\n            var car = String.fromCharCode(input[i])\n            var char_num = alphabet.indexOf(car)\n            if(char_num == -1){\n                if(validate){throw Base64.error(\"Non-base64 digit found: \" +\n                    car)}\n            }else if(char_num == 64 && i < input.length - 2){\n                if(validate){throw Base64.error(\"Non-base64 digit found: \" +\n                    car)}\n            }else if(char_num == 64 && i >= input.length - 2){\n                padding++\n                _input += car\n            }else{\n                _input += car\n            }\n        }\n        input = _input\n        if(_input.length == padding){return _b_.bytes.$factory([])}\n        if( _input.length % 4 > 0){throw Base64.error(\"Incorrect padding\")}\n\n        var i = 0\n        while(i < input.length){\n\n            enc1 = alphabet.indexOf(input.charAt(i++))\n            enc2 = alphabet.indexOf(input.charAt(i++))\n            enc3 = alphabet.indexOf(input.charAt(i++))\n            enc4 = alphabet.indexOf(input.charAt(i++))\n\n            chr1 = (enc1 << 2) | (enc2 >> 4)\n            chr2 = ((enc2 & 15) << 4) | (enc3 >> 2)\n            chr3 = ((enc3 & 3) << 6) | enc4\n\n            output.push(chr1)\n\n            if(enc3 != 64){output.push(chr2)}\n            if(enc4 != 64){output.push(chr3)}\n\n        }\n        // return Python bytes\n        return _b_.bytes.$factory(output, 'utf-8', 'strict')\n\n    },\n\n    _utf8_encode: function(string) {\n        string = string.replace(/\\r\\n/g, \"\\n\")\n        var utftext = \"\";\n\n        for(var n = 0; n < string.length; n++){\n\n            var c = string.charCodeAt(n)\n\n            if(c < 128){\n                utftext += String.fromCharCode(c)\n            }else if((c > 127) && (c < 2048)){\n                utftext += String.fromCharCode((c >> 6) | 192)\n                utftext += String.fromCharCode((c & 63) | 128)\n            }else{\n                utftext += String.fromCharCode((c >> 12) | 224)\n                utftext += String.fromCharCode(((c >> 6) & 63) | 128)\n                utftext += String.fromCharCode((c & 63) | 128)\n            }\n\n        }\n\n        return utftext\n    },\n\n    _utf8_decode: function(utftext) {\n        var string = \"\",\n            i = 0,\n            c = c1 = c2 = 0\n\n        while(i < utftext.length){\n\n            c = utftext.charCodeAt(i)\n\n            if(c < 128){\n                string += String.fromCharCode(c)\n                i++\n            }else if((c > 191) && (c < 224)){\n                c2 = utftext.charCodeAt(i + 1)\n                string += String.fromCharCode(((c & 31) << 6) | (c2 & 63))\n                i += 2\n            }else{\n                c2 = utftext.charCodeAt(i + 1)\n                c3 = utftext.charCodeAt(i + 2)\n                string += String.fromCharCode(\n                    ((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63))\n                i += 3\n            }\n\n        }\n\n        return string\n    }\n\n}\n\nreturn {Base64:Base64}\n}\n\n)(__BRYTHON__)"],
     "_binascii": [".js", "var $module=(function($B){\n\nvar _b_ = $B.builtins,\n    _keyStr = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\"\n\nvar error = $B.make_class(\"error\", _b_.Exception.$factory)\nerror.__bases__ = [_b_.Exception]\n$B.set_func_names(error, \"binascii\")\n\nfunction decode(bytes, altchars, validate){\n    var output = [],\n        chr1, chr2, chr3,\n        enc1, enc2, enc3, enc4\n\n    var alphabet = make_alphabet(altchars)\n\n    var input = bytes.source\n\n    // If validate is set, check that all characters in input\n    // are in the alphabet\n    var _input = ''\n    var padding = 0\n    for(var i = 0, len = input.length; i < len; i++){\n        var car = String.fromCharCode(input[i])\n        var char_num = alphabet.indexOf(car)\n        if(char_num == -1){\n            if(validate){throw error.$factory(\"Non-base64 digit found: \" +\n                car)}\n        }else if(char_num == 64 && i < input.length - 2){\n            if(validate){throw error.$factory(\"Non-base64 digit found: \" +\n                car)}\n        }else if(char_num == 64 && i >= input.length - 2){\n            padding++\n            _input += car\n        }else{\n            _input += car\n        }\n    }\n    input = _input\n    if(_input.length == padding){return _b_.bytes.$factory([])}\n    if( _input.length % 4 > 0){throw error.$factory(\"Incorrect padding\")}\n\n    var i = 0\n    while(i < input.length){\n\n        enc1 = alphabet.indexOf(input.charAt(i++))\n        enc2 = alphabet.indexOf(input.charAt(i++))\n        enc3 = alphabet.indexOf(input.charAt(i++))\n        enc4 = alphabet.indexOf(input.charAt(i++))\n\n        chr1 = (enc1 << 2) | (enc2 >> 4)\n        chr2 = ((enc2 & 15) << 4) | (enc3 >> 2)\n        chr3 = ((enc3 & 3) << 6) | enc4\n\n        output.push(chr1)\n\n        if(enc3 != 64){output.push(chr2)}\n        if(enc4 != 64){output.push(chr3)}\n\n    }\n    // return Python bytes\n    return _b_.bytes.$factory(output, 'utf-8', 'strict')\n}\n\n\nvar hex2int = {},\n    hex = '0123456789abcdef'\nfor(var i = 0; i < hex.length; i++){\n    hex2int[hex[i]] = i\n    hex2int[hex[i].toUpperCase()] = i\n}\n\nfunction make_alphabet(altchars){\n    var alphabet = _keyStr\n    if(altchars !== undefined && altchars !== _b_.None){\n        // altchars is an instance of Python bytes\n        var source = altchars.source\n        alphabet = alphabet.substr(0,alphabet.length-3) +\n            _b_.chr(source[0]) + _b_.chr(source[1]) + '='\n    }\n    return alphabet\n}\n\nvar module = {\n    a2b_base64: function(){\n        var $ = $B.args(\"a2b_base64\", 1, {s: null}, ['s'],\n                arguments, {}, null, null)\n        return decode(_b_.str.encode($.s, 'ascii'))\n    },\n    a2b_hex: function(){\n        var $ = $B.args(\"a2b_hex\", 1, {s: null}, ['s'],\n                arguments, {}, null, null),\n            s = $.s\n        if(_b_.isinstance(s, _b_.bytes)){\n            s = _b_.bytes.decode(s, 'ascii')\n        }\n        if(typeof s !== \"string\"){\n            throw _b_.TypeError.$factory(\"argument should be bytes, \" +\n                \"buffer or ASCII string, not '\" + $B.class_name(s) + \"'\")\n        }\n    \n        var len = s.length\n        if(len % 2 == 1){\n            throw _b_.TypeError.$factory('Odd-length string')\n        }\n    \n        var res = []\n        for(var i = 0; i < len; i += 2){\n            res.push((hex2int[s.charAt(i)] << 4) + hex2int[s.charAt(i + 1)])\n        }\n        return _b_.bytes.$factory(res)\n    },\n    b2a_base64: function(){\n        var $ = $B.args(\"b2a_base64\", 1, {data: null}, ['data'],\n                arguments, {}, null, \"kw\")\n        var newline = false\n        if($.kw && $.kw.$string_dict.newline){\n            newline = $.kw.$string_dict.newline[0]\n        }\n\n        var string = $B.to_bytes($.data),\n            res = btoa(String.fromCharCode.apply(null, string))\n        if(newline){res += \"\\n\"}\n        return _b_.bytes.$factory(res, \"ascii\")\n    },\n    b2a_hex: function(obj){\n        var string = $B.to_bytes(obj),\n            res = []\n        function conv(c){\n            if(c > 9){\n                c = c + 'a'.charCodeAt(0) - 10\n            }else{\n                c = c + '0'.charCodeAt(0)\n            }\n            return c\n        }\n        string.forEach(function(char){\n            res.push(conv((char >> 4) & 0xf))\n            res.push(conv(char & 0xf))\n        })\n        return _b_.bytes.$factory(res, \"ascii\")\n    },\n    b2a_uu: function(obj){\n        var string = $B.to_bytes(obj)\n        var len = string.length,\n            res = String.fromCharCode((0x20 + len) & 0x3F)\n        while(string.length > 0){\n            var s = string.slice(0, 3)\n            while(s.length < 3){s.push(String.fromCharCode(0))}\n            var A = s[0],\n                B = s[1],\n                C = s[2]\n            var a = (A >> 2) & 0x3F,\n                b = ((A << 4) | ((B >> 4) & 0xF)) & 0x3F,\n                c = (((B << 2) | ((C >> 6) & 0x3)) & 0x3F),\n                d = C & 0x3F\n            res += String.fromCharCode(0x20 + a, 0x20 + b, 0x20 + c, 0x20 + d)\n            string = string.slice(3)\n        }\n        return _b_.bytes.$factory(res + \"\\n\", \"ascii\")\n    },\n    error: error\n}\n\nmodule.hexlify = module.b2a_hex\nmodule.unhexlify = module.a2b_hex\n\nreturn module\n}\n)(__BRYTHON__)"],
     "_io_classes": [".js", "var _b_ = __BRYTHON__.builtins\n\nfunction get_self(name, args){\n    return $B.args(name, 1, {self: null}, [\"self\"], args, {}, null, null).self\n}\n\nvar _IOBase = $B.make_class(\"_IOBase\")\n_IOBase.__mro__ = [_b_.object]\n\n_IOBase.close = function(){\n    get_self(\"close\", arguments).__closed = true\n}\n\n_IOBase.flush = function(){\n    get_self(\"flush\", arguments)\n    return _b_.None\n}\n\n// Base class for binary streams that support some kind of buffering.\nvar _BufferedIOBase = $B.make_class(\"_BufferedIOBase\")\n_BufferedIOBase.__mro__ = [_IOBase, _b_.object]\n\n// Base class for raw binary I/O.\nvar _RawIOBase = $B.make_class(\"_RawIOBase\")\n\n_RawIOBase.__mro__ = [_IOBase, _b_.object]\n\n_RawIOBase.read = function(){\n    var $ = $B.args(\"read\", 2, {self: null, size: null}, [\"self\", \"size\"],\n                    arguments, {size: -1}, null, null),\n        self = $.self,\n        size = $.size,\n        res\n    self.$pos = self.$pos || 0\n    if(size == -1){\n        if(self.$pos == 0){\n            res = self.$content\n        }else{\n            res = _b_.bytes.$factory(self.$content.source.slice(self.$pos))\n        }\n        self.$pos = self.$content.source.length - 1\n    }else{\n        res = _b_.bytes.$factory(self.$content.source.slice(self.$pos, size))\n        self.$pos += size\n    }\n    return res\n}\n\n_RawIOBase.readall = function(){\n    return _RawIOBase.read(get_self(\"readall\", arguments))\n}\n\n// Base class for text streams.\n_TextIOBase = $B.make_class(\"_TextIOBase\")\n_TextIOBase.__mro__ = [_IOBase, _b_.object]\n\nvar StringIO = $B.make_class(\"StringIO\",\n    function(){\n        var $ = $B.args(\"StringIO\", 2, {value: null, newline: null},\n                [\"value\", \"newline\"], arguments, {value: '', newline: \"\\n\"},\n                null, null)\n        return {\n            __class__: StringIO,\n            $counter: 0,\n            $content: $.value\n        }\n    }\n)\nStringIO.__mro__ = [$B.Reader, _b_.object]\n\nStringIO.getvalue = function(){\n    var $ = $B.args(\"getvalue\", 1, {self: null},\n            [\"self\"], arguments, {}, null, null)\n    return $.self.$content\n}\n\nStringIO.write = function(){\n    var $ = $B.args(\"write\", 2, {self: null, data: null},\n            [\"self\", \"data\"], arguments, {}, null, null)\n    if(! _b_.isinstance($.data, _b_.str)){\n        throw _b_.TypeError.$factory('string argument expected, got ' +\n            `'${$B.class_name($.data)}'`)\n    }\n    var text = $.self.$content,\n        position = $.self.$counter\n    text = text.substr(0, position) + $.data +\n        text.substr(position + $.data.length)\n    $.self.$content = text\n    $.self.$counter += $.data.length\n    return $.data.length\n}\n$B.set_func_names(StringIO, \"_io\")\n\nvar BytesIO = $B.make_class(\"BytesIO\",\n    function(){\n        var $ = $B.args(\"BytesIO\", 1, {value: null},\n                [\"value\"], arguments, {value: _b_.bytes.$factory()},\n                null, null)\n        return {\n            __class__: BytesIO,\n            $binary: true,\n            $content: $.value,\n            $counter: 0\n        }\n    }\n)\nBytesIO.__mro__ = [$B.Reader, _b_.object]\n\nBytesIO.getbuffer = function(){\n    var self = get_self(\"getbuffer\", arguments)\n    return self.$content\n}\n\nBytesIO.getvalue = function(){\n    var self = get_self(\"getvalue\", arguments)\n    return self.$content\n}\n\nBytesIO.write = function(){\n    var $ = $B.args(\"write\", 2, {self: null, data: null},\n            [\"self\", \"data\"], arguments, {}, null, null)\n    $.self.$content.source = $.self.$content.source.concat(\n        $.data.source)\n    $.self.$counter += $.data.source.length\n    return _b_.None\n}\n$B.set_func_names(BytesIO, \"_io\")\n\nvar $module = (function($B){\n    return {\n        _BufferedIOBase: _BufferedIOBase,\n        _IOBase: _IOBase,\n        _RawIOBase: _RawIOBase,\n        _TextIOBase: $B.make_class(\"_TextIOBase\",\n            function(){\n                return \"fileio\"\n            }\n        ),\n        BytesIO: BytesIO,\n        FileIO: $B.make_class(\"_TextIOBase\",\n            function(){\n                return \"fileio\"\n            }\n        ),\n        StringIO: StringIO,\n        BufferedReader: $B.BufferedReader,\n        BufferedWriter: $B.make_class(\"_TextIOBase\",\n            function(){\n                return \"fileio\"\n            }\n        ),\n        BufferedRWPair: $B.make_class(\"_TextIOBase\",\n            function(){\n                return \"fileio\"\n            }\n        ),\n        BufferedRandom: $B.make_class(\"_TextIOBase\",\n            function(){\n                return \"fileio\"\n            }\n        ),\n        IncrementalNewlineDecoder: $B.make_class(\"_TextIOBase\",\n            function(){\n                return \"fileio\"\n            }\n        ),\n        TextIOWrapper: $B.TextIOWrapper\n    }\n})(__BRYTHON__)\n$module._IOBase.__doc__ = \"_IOBase\""],
-    "_json": [".js", "var $module=(function($B){\n\nvar _b_ = $B.builtins\n\nfunction simple(obj){\n    switch(typeof obj){\n        case 'string':\n        case 'number':\n        case 'boolean':\n            return true\n    }\n    if(obj instanceof Number ||\n            Array.isArray(obj) ||\n            _b_.isinstance(obj, [_b_.list, _b_.tuple, _b_.dict])){\n        return true\n    }\n    return false\n}\n\nfunction to_json(obj, level){\n    var $defaults = {skipkeys:_b_.False, ensure_ascii:_b_.True,\n            check_circular:_b_.True, allow_nan:_b_.True, cls:_b_.None,\n            indent:_b_.None, separators:_b_.None, \"default\":_b_.None,\n            sort_keys:_b_.False},\n        $ = $B.args(\"to_json\", 2, {obj: null, level: null}, ['obj', 'level'],\n                    arguments, {level: 1}, null, \"kw\"),\n        kw = $.kw.$string_dict\n\n    for(key in $defaults){\n        if(kw[key] === undefined){\n            kw[key] = $defaults[key]\n        }else{\n            kw[key] = kw[key][0]\n        }\n    }\n\n    var indent = kw.indent,\n        ensure_ascii = kw.ensure_ascii,\n        separators = kw.separators === _b_.None ?\n             kw.indent === _b_.None ? [', ', ': '] : [',', ': '] :\n            kw.separators,\n        skipkeys = kw.skipkeys,\n        $$default = kw.default,\n        sort_keys = kw.sort_keys,\n        allow_nan = kw.allow_nan,\n        check_circular = kw.check_circular\n    var item_separator = separators[0],\n        key_separator = separators[1]\n    if(indent !== _b_.None){\n        var indent_str\n        if(typeof indent == \"string\"){\n            indent_str = indent\n        }else if(typeof indent == \"number\" && indent >= 1){\n            indent_str = \" \".repeat(indent)\n        }else{\n            throw _b_.ValueError.$factory(\"invalid indent: \" +\n                _b_.str.$factory(indent))\n        }\n    }\n    var kwarg = {$nat: \"kw\", kw: {}}\n    for(var key in kw){\n        kwarg.kw[key] = kw[key]\n    }\n    switch(typeof obj){\n        case 'string':\n            var res = JSON.stringify(obj)\n            if(ensure_ascii){\n                var escaped = ''\n                for(var i = 0, len = res.length; i < len; i++){\n                    var u = res.codePointAt(i)\n                    if(u > 127){\n                        u = u.toString(16)\n                        while(u.length < 4){\n                            u = \"0\" + u\n                        }\n                        escaped += '\\\\u' + u\n                    }else{\n                        escaped += res.charAt(i)\n                    }\n                }\n                return escaped\n            }\n            return res\n        case 'boolean':\n            return obj.toString()\n        case 'number':\n            if([Infinity, -Infinity].indexOf(obj) > -1 ||\n                    isNaN(obj)){\n                if(! allow_nan){\n                    throw _b_.ValueError.$factory(\n                        'Out of range float values are not JSON compliant')\n                }\n            }\n            return obj.toString()\n    }\n    if(_b_.isinstance(obj, _b_.list)){\n        var res = []\n        var sep = item_separator,\n            first = '[',\n            last = ']'\n        if(indent !== _b_.None){\n            sep += \"\\n\" + indent_str.repeat(level)\n            first = '[' + '\\n' + indent_str.repeat(level)\n            last = '\\n' + indent_str.repeat(level - 1) + ']'\n            level++\n        }\n        for(var i = 0, len = obj.length; i < len; i++){\n            res.push(to_json(obj[i], level, kwarg))\n        }\n        return first + res.join(sep) + last\n    }else if(obj instanceof Number){\n        return obj.valueOf()\n    }else if(obj === _b_.None){\n        return \"null\"\n    }else if(_b_.isinstance(obj, _b_.dict)){\n        var res = [],\n            items = $B.dict_to_list(obj)\n        if(sort_keys){\n            // Sort keys by alphabetical order\n            items.sort()\n        }\n        var sep = item_separator,\n            first = '{',\n            last = '}'\n        if(indent !== _b_.None){\n            sep += \"\\n\" + indent_str.repeat(level)\n            first = '{' + '\\n' + indent_str.repeat(level)\n            last = '\\n' + indent_str.repeat(level - 1) + '}'\n            level++\n        }\n        for(var i = 0, len = items.length; i < len; i++){\n            var item = items[i]\n            if(! simple(item[0])){\n                if(! skipkeys){\n                    throw _b_.TypeError.$factory(\"keys must be str, int, \" +\n                        \"float, bool or None, not \" + $B.class_name(obj))\n                }\n            }else{\n                // In the result, key must be a string\n                var key = _b_.str.$factory(item[0])\n                // Check circular reference\n                if(check_circular && $B.repr.enter(item[1])){\n                    throw _b_.ValueError.$factory(\"Circular reference detected\")\n                }\n                res.push(\n                    [to_json(key, level, kwarg), to_json(item[1], level, kwarg)].\n                    join(key_separator))\n                if(check_circular){\n                    $B.repr.leave(item[1])\n                }\n            }\n        }\n        return first + res.join(sep) + last\n    }\n    // For other types, use function default if provided\n    if($$default == _b_.None){\n        throw _b_.TypeError.$factory(\"Object of type \" + $B.class_name(obj) +\n            \" is not JSON serializable\")\n    }else{\n        return to_json($B.$call($$default)(obj), level, kwarg)\n    }\n}\n\nfunction from_json(s){\n    var $defaults = {cls: _b_.None, object_hook: _b_.None,\n            parse_float: _b_.None, parse_int: _b_.None,\n            parse_constant: _b_.None, object_pairs_hook: _b_.None},\n        $ = $B.args(\"from_json\", 1, {s: null}, ['s'], arguments, {},\n            null, \"kw\"),\n        kw = $.kw.$string_dict\n    if(Object.keys(kw).length == 0){\n        // default\n        return $B.structuredclone2pyobj(JSON.parse(s))\n    }\n    for(key in $defaults){\n        if(kw[key] === undefined){\n            kw[key] = $defaults[key]\n        }else{\n            kw[key] = kw[key][0]\n        }\n    }\n\n    function reviver(key, value){\n        if(typeof value == \"number\"){\n            if(Number.isInteger(value) && kw.parse_int !== _b_.None){\n                return $B.$call(kw.parse_int)(value.toString())\n            }else if(! Number.isInteger(value) && kw.parse_float !== _b_.None){\n                return $B.$call(kw.parse_float)(value.toString())\n            }else if((value === Infinity || value === -Infinity) &&\n                    kw.parse_constant !== _b_.None){\n                return $B.$call(kw.parse_constant)(value)\n            }else{\n                return value\n            }\n        }else if(isNaN(value) && kw.parse_constant !== _b_.None){\n            return $B.$call(kw.parse_constant)(value)\n        }else if(typeof value == \"object\" && !Array.isArray(value) &&\n                (kw.object_hook !== _b_.None ||\n                    kw.object_pairs_hook !== _b_.None)){\n            // Apply Python function object_hook to the Python dictionary\n            // built from the Javascript object \"value\"\n            var py_dict = $B.structuredclone2pyobj(value)\n            if(kw.object_pairs_hook === _b_.None){\n                var res = $B.$call(kw.object_hook)(py_dict)\n            }else{\n                var items = $B.dict_to_list(py_dict),\n                    res = $B.$call(kw.object_pairs_hook)(items)\n            }\n            // Transform the result of the Python function to a Javascript\n            // object\n            return $B.pyobj2structuredclone(res)\n        }else{\n            return value\n        }\n    }\n\n    return $B.structuredclone2pyobj(JSON.parse(s, reviver))\n}\n\nreturn {\n    dumps: function(){\n        return _b_.str.$factory(to_json.apply(null, arguments))\n    },\n    loads: from_json\n}\n\n})(__BRYTHON__)"],
-    "_jsre": [".js", "var $module = (function($B){\n\n    var _b_ = $B.builtins\n    var $s = []\n    for(var $b in _b_) $s.push('var ' + $b +'=_b_[\"' + $b + '\"]')\n    eval($s.join(';'))\n\n    var MatchObject = $B.make_class(\"Match\",\n        function(jsmatch, string, pattern){\n            return {\n                __class__: MatchObject,\n                jsmatch: jsmatch,\n                string: string\n            }\n        }\n    )\n    MatchObject.item = function(self, rank){\n        return self.jsmatch[rank]\n    }\n    MatchObject.group = function(self){\n        var res = []\n        for(var i = 0, _len_i = arguments.length; i < _len_i; i++){\n            if(self.jsmatch[arguments[i]] === undefined){res.push(None)}\n            else{res.push(self.jsmatch[arguments[i]])}\n        }\n        if(arguments.length == 1){return res[0]}\n        return tuple.$factory(res)\n    }\n    MatchObject.groups = function(self, _default){\n        if(_default===undefined){_default=None}\n        var res = []\n        for(var i = 1, _len_i = self.length; i < _len_i; i++){\n            if(self.jsmatch[i] === undefined){res.push(_default)}\n            else{res.push(self.jsmatch[i])}\n        }\n        return tuple.$factory(res)\n    }\n    MatchObject.start = function(self){\n        return self.index\n    }\n    MatchObject.end = function(self){\n        return self.length - self.index\n    }\n\n    $B.set_func_names(MatchObject, '_jsre')\n\n    var obj = {__class__: $module,\n        __str__: function(){return \"<module 're'>\"}\n    }\n    obj.A = obj.ASCII = 256\n    obj.I = obj.IGNORECASE = 2 // 'i'\n    obj.L = obj.LOCALE = 4\n    obj.M = obj.MULTILINE = 8 // 'm'\n    obj.S = obj.DOTALL = 16\n    obj.U = obj.UNICODE = 32\n    obj.X = obj.VERBOSE = 64\n    obj._is_valid = function(pattern) {\n        if ($B.$options.re == 'pyre'){return false}  //force use of python's re module\n        if ($B.$options.re == 'jsre'){return true}   //force use of brythons re module\n        // FIXME: Improve\n\n        if(! isinstance(pattern, str)){\n           // this is probably a SRE_PATTERN, so return false, and let\n           // python's re module handle this.\n           return false\n        }\n        var is_valid = false\n        try{\n            new RegExp(pattern)\n            is_valid = true\n        }\n        catch(e){}\n        if(! is_valid){return false}  //if js won't parse the pattern return false\n\n        // using reference http://www.regular-expressions.info/\n        // to compare python re and javascript regex libraries\n\n        // look for things javascript does not support\n        // check for name capturing group\n        var mylist = ['?P=', '?P<', '(?#', '(?<=', '(?<!', '(?(']\n        for(var i = 0, _len_i = mylist.length; i < _len_i; i++) {\n           if (pattern.indexOf(mylist[i]) > -1) return false\n        }\n\n        var re_list=['\\{,\\d+\\}']\n        for(var i=0, _len_i = re_list.length; i < _len_i; i++) {\n           var _re = new RegExp(re_list[i])\n           if (_re.test(pattern)){return false}\n        }\n\n        // it looks like the pattern has passed all our tests so lets assume\n        // javascript can handle this pattern.\n        return true\n    }\n    var $SRE_PatternDict = {\n        __class__:_b_.type,\n        $infos:{\n            __name__:'SRE_Pattern'\n        }\n    }\n    $SRE_PatternDict.__mro__ = [object]\n    $SRE_PatternDict.findall = function(self, string){\n        return obj.findall(self.pattern, string, self.flags)\n    }\n    $SRE_PatternDict.finditer = function(self, string){\n        return obj.finditer(self.pattern, string, self.flags)\n    }\n    $SRE_PatternDict.match = function(self, string){\n        return obj.match(self.pattern, string, self.flags)\n    }\n    $SRE_PatternDict.search = function(self, string){\n        return obj.search(self.pattern, string, self.flags)\n    }\n    $SRE_PatternDict.sub = function(self,repl,string){\n        return obj.sub(self.pattern,repl,string,self.flags)\n    }\n    $B.set_func_names($SRE_PatternDict, \"_jsre\")\n    // TODO: groups\n    // TODO: groupindex\n    function normflags(flags){\n        return ((flags & obj.I)? 'i' : '') + ((flags & obj.M)? 'm' : '');\n    }\n    // TODO: fullmatch()\n    // TODO: split()\n    // TODO: subn()\n    obj.compile = function(pattern, flags){\n        return {\n            __class__: $SRE_PatternDict,\n            pattern: pattern,\n            flags: normflags(flags)\n        }\n    }\n    obj.escape = function(string){\n        // Escape all the characters in pattern except ASCII letters, numbers\n        // and '_'. This is useful if you want to match an arbitrary literal\n        // string that may have regular expression metacharacters in it.\n        var res = ''\n        var ok = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_'\n        for(var i = 0, _len_i = string.length; i < _len_i; i++){\n            if(ok.search(string.charAt(i))>-1){res += string.charAt(i)}\n        }\n        return res\n    }\n    obj.findall = function(pattern, string, flags){\n        var $ns=$B.args('re.findall', 2,\n            {pattern:null, string:null}, ['pattern', 'string'],\n            arguments,{}, 'args', 'kw') ,\n            args = $ns['args'] ,\n            _flags = 0;\n        if(args.length>0){var flags = args[0]}\n        else{var _flags = getattr($ns['kw'], 'get')('flags', 0)}\n\n        var flags = normflags()\n        flags += 'gm'\n        var jsp = new RegExp(pattern,flags),\n            jsmatch = string.match(jsp)\n        if(jsmatch === null){return []}\n        return jsmatch\n    }\n    obj.finditer = function(pattern, string, flags){\n        var $ns=$B.args('re.finditer', 2,\n            {pattern:null, string:null}, ['pattern', 'string'],\n            arguments,{},'args','kw'),\n            args = $ns['args'],\n            _flags = 0;\n        if(args.length>0){var flags=args[0]}\n        else{var _flags = getattr($ns['kw'], 'get')('flags', 0)}\n\n        var flags = normflags()\n        flags += 'gm'\n        var jsp = new RegExp(pattern, flags),\n            jsmatch = string.match(jsp);\n        if(jsmatch === null){return []}\n\n        var _list = []\n        for(var j = 0, _len_j = jsmatch.length; j < _len_j; j++) {\n            var mo = {}\n            mo._match=jsmatch[j]\n            mo.group = function(){\n               var res = []\n               for(var i=0, _len_i = arguments.length; i < _len_i;i++){\n                   if(jsmatch[arguments[i]] === undefined){res.push(None)}\n                   else{res.push(jsmatch[arguments[i]])}\n               }\n               if(arguments.length == 1){return res[0]}\n               return tuple.$factory(res)\n            }\n            mo.groups = function(_default){\n               if(_default === undefined){_default=None}\n               var res = []\n               for(var i = 1, _len_i = jsmatch.length; i < _len_i; i++){\n                  if(jsmatch[i] === undefined){res.push(_default)}\n                  else{res.push(jsmatch[i])}\n               }\n               return tuple.$factory(res)\n            }\n            mo.start = function(){return mo._match.index}\n            mo.end = function(){return mo._match.length - mo._match.index}\n            mo.string = string\n            _list.push(mo)\n        }\n        return _list\n    }\n    obj.search = function(pattern, string){\n        var $ns = $B.args('re.search', 2,\n            {pattern:null, string:null},['pattern', 'string'],\n            arguments, {}, 'args', 'kw')\n        var args = $ns['args']\n        if(args.length>0){var flags = args[0]}\n        else{var flags = getattr($ns['kw'], 'get')('flags', '')}\n        flags = normflags(flags)\n        var jsp = new RegExp(pattern, flags)\n        var jsmatch = string.match(jsp)\n        if(jsmatch === null){return None}\n        return MatchObject.$factory(jsmatch, string, pattern)\n    }\n    obj.sub = function(pattern, repl, string){\n        var $ns=$B.args('re.search', 3,\n            {pattern: null, repl: null, string: null},\n            ['pattern', 'repl', 'string'],\n            arguments,{}, 'args', 'kw')\n        for($var in $ns){eval(\"var \" + $var + \"=$ns[$var]\")}\n        var args = $ns['args']\n        var count = _b_.dict.get($ns['kw'], 'count', 0)\n        var flags = _b_.dict.get($ns['kw'], 'flags', '')\n        if(args.length > 0){var count = args[0]}\n        if(args.length > 1){var flags = args[1]}\n        flags = normflags(flags)\n        if(typeof repl == \"string\"){\n            // backreferences are \\1, \\2... in Python but $1,$2... in Javascript\n            repl = repl.replace(/\\\\(\\d+)/g, '$$$1')\n        }else if(typeof repl == \"function\"){\n            // the argument passed to the Python function is the match object\n            // the arguments passed to the Javascript function are :\n            // - the matched substring\n            // - the matched groups\n            // - the offset of the matched substring inside the string\n            // - the string being examined\n            var $repl1 = function(){\n                var mo = Object()\n                mo.string = arguments[arguments.length - 1]\n                var matched = arguments[0];\n                var start = arguments[arguments.length - 2]\n                var end = start + matched.length\n                mo.start = function(){return start}\n                mo.end = function(){return end}\n                groups = []\n                for(var i = 1, _len_i = arguments.length-2; i < _len_i; i++){\n                    groups.push(arguments[i])\n                }\n                mo.groups = function(_default){\n                    if(_default === undefined){_default = None}\n                    var res = []\n                    for(var i = 0, _len_i = groups.length; i < _len_i; i++){\n                        if(groups[i] === undefined){res.push(_default)}\n                        else{res.push(groups[i])}\n                    }\n                    return res\n                }\n                mo.group = function(i){\n                    if(i==0){return matched}\n                    return groups[i-1]\n                }\n                return repl(mo)\n            }\n        }\n        if(count == 0){flags += 'g'}\n        var jsp = new RegExp(pattern, flags)\n        if(typeof repl == 'function'){return string.replace(jsp, $repl1)}\n        else{return string.replace(jsp, repl)}\n    }\n    obj.match = (function(search_func){\n        return function(){\n            // match is like search but pattern must start with ^\n            var pattern = arguments[0]\n            if(pattern.charAt(0) != '^'){pattern = '^'+pattern}\n            var args = [pattern]\n            for(var i = 1, _len_i = arguments.length; i < _len_i; i++){\n                args.push(arguments[i])\n            }\n            return search_func.apply(null, args)\n        }\n    })(obj.search)\n\n    return obj\n}\n)(__BRYTHON__)\n"],
+    "_json": [".js", "var $module=(function($B){\n\nvar _b_ = $B.builtins\n\nfunction simple(obj){\n    switch(typeof obj){\n        case 'string':\n        case 'number':\n        case 'boolean':\n            return true\n    }\n    if(obj instanceof Number ||\n            Array.isArray(obj) ||\n            _b_.isinstance(obj, [_b_.list, _b_.tuple, _b_.dict])){\n        return true\n    }\n    return false\n}\n\nfunction to_json(obj, level){\n    var $defaults = {skipkeys:_b_.False, ensure_ascii:_b_.True,\n            check_circular:_b_.True, allow_nan:_b_.True, cls:_b_.None,\n            indent:_b_.None, separators:_b_.None, \"default\":_b_.None,\n            sort_keys:_b_.False},\n        $ = $B.args(\"to_json\", 2, {obj: null, level: null}, ['obj', 'level'],\n                    arguments, {level: 1}, null, \"kw\"),\n        kw = $.kw.$string_dict\n\n    for(key in $defaults){\n        if(kw[key] === undefined){\n            kw[key] = $defaults[key]\n        }else{\n            kw[key] = kw[key][0]\n        }\n    }\n\n    var indent = kw.indent,\n        ensure_ascii = kw.ensure_ascii,\n        separators = kw.separators === _b_.None ?\n             kw.indent === _b_.None ? [', ', ': '] : [',', ': '] :\n            kw.separators,\n        skipkeys = kw.skipkeys,\n        _default = kw.default,\n        sort_keys = kw.sort_keys,\n        allow_nan = kw.allow_nan,\n        check_circular = kw.check_circular\n    var item_separator = separators[0],\n        key_separator = separators[1]\n    if(indent !== _b_.None){\n        var indent_str\n        if(typeof indent == \"string\"){\n            indent_str = indent\n        }else if(typeof indent == \"number\" && indent >= 1){\n            indent_str = \" \".repeat(indent)\n        }else{\n            throw _b_.ValueError.$factory(\"invalid indent: \" +\n                _b_.str.$factory(indent))\n        }\n    }\n    var kwarg = {$nat: \"kw\", kw: {}}\n    for(var key in kw){\n        kwarg.kw[key] = kw[key]\n    }\n    switch(typeof obj){\n        case 'string':\n            var res = JSON.stringify(obj)\n            if(ensure_ascii){\n                var escaped = ''\n                for(var i = 0, len = res.length; i < len; i++){\n                    var u = res.codePointAt(i)\n                    if(u > 127){\n                        u = u.toString(16)\n                        while(u.length < 4){\n                            u = \"0\" + u\n                        }\n                        escaped += '\\\\u' + u\n                    }else{\n                        escaped += res.charAt(i)\n                    }\n                }\n                return escaped\n            }\n            return res\n        case 'boolean':\n            return obj.toString()\n        case 'number':\n            if([Infinity, -Infinity].indexOf(obj) > -1 ||\n                    isNaN(obj)){\n                if(! allow_nan){\n                    throw _b_.ValueError.$factory(\n                        'Out of range float values are not JSON compliant')\n                }\n            }\n            return obj.toString()\n    }\n    if(_b_.isinstance(obj, _b_.list)){\n        var res = []\n        var sep = item_separator,\n            first = '[',\n            last = ']'\n        if(indent !== _b_.None){\n            sep += \"\\n\" + indent_str.repeat(level)\n            first = '[' + '\\n' + indent_str.repeat(level)\n            last = '\\n' + indent_str.repeat(level - 1) + ']'\n            level++\n        }\n        for(var i = 0, len = obj.length; i < len; i++){\n            res.push(to_json(obj[i], level, kwarg))\n        }\n        return first + res.join(sep) + last\n    }else if(obj instanceof Number){\n        return obj.valueOf()\n    }else if(obj === _b_.None){\n        return \"null\"\n    }else if(_b_.isinstance(obj, _b_.dict)){\n        var res = [],\n            items = $B.dict_to_list(obj)\n        if(sort_keys){\n            // Sort keys by alphabetical order\n            items.sort()\n        }\n        var sep = item_separator,\n            first = '{',\n            last = '}'\n        if(indent !== _b_.None){\n            sep += \"\\n\" + indent_str.repeat(level)\n            first = '{' + '\\n' + indent_str.repeat(level)\n            last = '\\n' + indent_str.repeat(level - 1) + '}'\n            level++\n        }\n        for(var i = 0, len = items.length; i < len; i++){\n            var item = items[i]\n            if(! simple(item[0])){\n                if(! skipkeys){\n                    throw _b_.TypeError.$factory(\"keys must be str, int, \" +\n                        \"float, bool or None, not \" + $B.class_name(obj))\n                }\n            }else{\n                // In the result, key must be a string\n                var key = _b_.str.$factory(item[0])\n                // Check circular reference\n                if(check_circular && $B.repr.enter(item[1])){\n                    throw _b_.ValueError.$factory(\"Circular reference detected\")\n                }\n                res.push(\n                    [to_json(key, level, kwarg), to_json(item[1], level, kwarg)].\n                    join(key_separator))\n                if(check_circular){\n                    $B.repr.leave(item[1])\n                }\n            }\n        }\n        return first + res.join(sep) + last\n    }\n    // For other types, use function default if provided\n    if(_default == _b_.None){\n        throw _b_.TypeError.$factory(\"Object of type \" + $B.class_name(obj) +\n            \" is not JSON serializable\")\n    }else{\n        return to_json($B.$call(_default)(obj), level, kwarg)\n    }\n}\n\nfunction from_json(s){\n    var $defaults = {cls: _b_.None, object_hook: _b_.None,\n            parse_float: _b_.None, parse_int: _b_.None,\n            parse_constant: _b_.None, object_pairs_hook: _b_.None},\n        $ = $B.args(\"from_json\", 1, {s: null}, ['s'], arguments, {},\n            null, \"kw\"),\n        kw = $.kw.$string_dict\n    if(Object.keys(kw).length == 0){\n        // default\n        return $B.structuredclone2pyobj(JSON.parse(s))\n    }\n    for(key in $defaults){\n        if(kw[key] === undefined){\n            kw[key] = $defaults[key]\n        }else{\n            kw[key] = kw[key][0]\n        }\n    }\n\n    function reviver(key, value){\n        if(typeof value == \"number\"){\n            if(Number.isInteger(value) && kw.parse_int !== _b_.None){\n                return $B.$call(kw.parse_int)(value.toString())\n            }else if(! Number.isInteger(value) && kw.parse_float !== _b_.None){\n                return $B.$call(kw.parse_float)(value.toString())\n            }else if((value === Infinity || value === -Infinity) &&\n                    kw.parse_constant !== _b_.None){\n                return $B.$call(kw.parse_constant)(value)\n            }else{\n                return value\n            }\n        }else if(isNaN(value) && kw.parse_constant !== _b_.None){\n            return $B.$call(kw.parse_constant)(value)\n        }else if(typeof value == \"object\" && !Array.isArray(value) &&\n                (kw.object_hook !== _b_.None ||\n                    kw.object_pairs_hook !== _b_.None)){\n            // Apply Python function object_hook to the Python dictionary\n            // built from the Javascript object \"value\"\n            var py_dict = $B.structuredclone2pyobj(value)\n            if(kw.object_pairs_hook === _b_.None){\n                var res = $B.$call(kw.object_hook)(py_dict)\n            }else{\n                var items = $B.dict_to_list(py_dict),\n                    res = $B.$call(kw.object_pairs_hook)(items)\n            }\n            // Transform the result of the Python function to a Javascript\n            // object\n            return $B.pyobj2structuredclone(res)\n        }else{\n            return value\n        }\n    }\n\n    return $B.structuredclone2pyobj(JSON.parse(s, reviver))\n}\n\nreturn {\n    dumps: function(){\n        return _b_.str.$factory(to_json.apply(null, arguments))\n    },\n    loads: from_json\n}\n\n})(__BRYTHON__)"],
+    "_jsre": [".js", "var $module = (function($B){\n\n    var _b_ = $B.builtins\n\n    var MatchObject = $B.make_class(\"Match\",\n        function(jsmatch, string, pattern){\n            return {\n                __class__: MatchObject,\n                jsmatch: jsmatch,\n                string: string\n            }\n        }\n    )\n    MatchObject.item = function(self, rank){\n        return self.jsmatch[rank]\n    }\n    MatchObject.group = function(self){\n        var res = []\n        for(var i = 0, _len_i = arguments.length; i < _len_i; i++){\n            if(self.jsmatch[arguments[i]] === undefined){res.push(_b_.None)}\n            else{res.push(self.jsmatch[arguments[i]])}\n        }\n        if(arguments.length == 1){return res[0]}\n        return _b_.tuple.$factory(res)\n    }\n    MatchObject.groups = function(self, _default){\n        if(_default === undefined){_default = _b_.None}\n        var res = []\n        for(var i = 1, _len_i = self.length; i < _len_i; i++){\n            if(self.jsmatch[i] === undefined){res.push(_default)}\n            else{res.push(self.jsmatch[i])}\n        }\n        return _b_.tuple.$factory(res)\n    }\n    MatchObject.start = function(self){\n        return self.index\n    }\n    MatchObject.end = function(self){\n        return self.length - self.index\n    }\n\n    $B.set_func_names(MatchObject, '_jsre')\n\n    var obj = {__class__: $module,\n        __str__: function(){return \"<module 're'>\"}\n    }\n    obj.A = obj.ASCII = 256\n    obj.I = obj.IGNORECASE = 2 // 'i'\n    obj.L = obj.LOCALE = 4\n    obj.M = obj.MULTILINE = 8 // 'm'\n    obj.S = obj.DOTALL = 16\n    obj.U = obj.UNICODE = 32\n    obj.X = obj.VERBOSE = 64\n    obj._is_valid = function(pattern) {\n        if ($B.$options.re == 'pyre'){return false}  //force use of python's re module\n        if ($B.$options.re == 'jsre'){return true}   //force use of brythons re module\n        // FIXME: Improve\n\n        if(! _b_.isinstance(pattern, _b_.str)){\n           // this is probably a SRE_PATTERN, so return false, and let\n           // python's re module handle this.\n           return false\n        }\n        var is_valid = false\n        try{\n            new RegExp(pattern)\n            is_valid = true\n        }\n        catch(e){}\n        if(! is_valid){return false}  //if js won't parse the pattern return false\n\n        // using reference http://www.regular-expressions.info/\n        // to compare python re and javascript regex libraries\n\n        // look for things javascript does not support\n        // check for name capturing group\n        var mylist = ['?P=', '?P<', '(?#', '(?<=', '(?<!', '(?(']\n        for(var i = 0, _len_i = mylist.length; i < _len_i; i++) {\n           if (pattern.indexOf(mylist[i]) > -1) return false\n        }\n\n        var re_list=['\\{,\\d+\\}']\n        for(var i=0, _len_i = re_list.length; i < _len_i; i++) {\n           var _re = new RegExp(re_list[i])\n           if (_re.test(pattern)){return false}\n        }\n\n        // it looks like the pattern has passed all our tests so lets assume\n        // javascript can handle this pattern.\n        return true\n    }\n    var $SRE_PatternDict = {\n        __class__:_b_.type,\n        $infos:{\n            __name__:'SRE_Pattern'\n        }\n    }\n    $SRE_PatternDict.__mro__ = [_b_.object]\n    $SRE_PatternDict.findall = function(self, string){\n        return obj.findall(self.pattern, string, self.flags)\n    }\n    $SRE_PatternDict.finditer = function(self, string){\n        return obj.finditer(self.pattern, string, self.flags)\n    }\n    $SRE_PatternDict.match = function(self, string){\n        return obj.match(self.pattern, string, self.flags)\n    }\n    $SRE_PatternDict.search = function(self, string){\n        return obj.search(self.pattern, string, self.flags)\n    }\n    $SRE_PatternDict.sub = function(self,repl,string){\n        return obj.sub(self.pattern,repl,string,self.flags)\n    }\n    $B.set_func_names($SRE_PatternDict, \"_jsre\")\n    // TODO: groups\n    // TODO: groupindex\n    function normflags(flags){\n        return ((flags & obj.I)? 'i' : '') + ((flags & obj.M)? 'm' : '');\n    }\n    // TODO: fullmatch()\n    // TODO: split()\n    // TODO: subn()\n    obj.compile = function(pattern, flags){\n        return {\n            __class__: $SRE_PatternDict,\n            pattern: pattern,\n            flags: normflags(flags)\n        }\n    }\n    obj.escape = function(string){\n        // Escape all the characters in pattern except ASCII letters, numbers\n        // and '_'. This is useful if you want to match an arbitrary literal\n        // string that may have regular expression metacharacters in it.\n        var res = ''\n        var ok = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_'\n        for(var i = 0, _len_i = string.length; i < _len_i; i++){\n            if(ok.search(string.charAt(i))>-1){res += string.charAt(i)}\n        }\n        return res\n    }\n    obj.findall = function(pattern, string, flags){\n        var $ns=$B.args('re.findall', 2,\n            {pattern:null, string:null}, ['pattern', 'string'],\n            arguments,{}, 'args', 'kw') ,\n            args = $ns['args'] ,\n            _flags = 0;\n        if(args.length>0){var flags = args[0]}\n        else{var _flags = $B.$getattr($ns['kw'], 'get')('flags', 0)}\n\n        var flags = normflags()\n        flags += 'gm'\n        var jsp = new RegExp(pattern,flags),\n            jsmatch = string.match(jsp)\n        if(jsmatch === null){return []}\n        return jsmatch\n    }\n    obj.finditer = function(pattern, string, flags){\n        var $ns=$B.args('re.finditer', 2,\n            {pattern:null, string:null}, ['pattern', 'string'],\n            arguments,{},'args','kw'),\n            args = $ns['args'],\n            _flags = 0;\n        if(args.length>0){var flags=args[0]}\n        else{var _flags = $B.$getattr($ns['kw'], 'get')('flags', 0)}\n\n        var flags = normflags()\n        flags += 'gm'\n        var jsp = new RegExp(pattern, flags),\n            jsmatch = string.match(jsp);\n        if(jsmatch === null){return []}\n\n        var _list = []\n        for(var j = 0, _len_j = jsmatch.length; j < _len_j; j++) {\n            var mo = {}\n            mo._match=jsmatch[j]\n            mo.group = function(){\n               var res = []\n               for(var i=0, _len_i = arguments.length; i < _len_i;i++){\n                   if(jsmatch[arguments[i]] === undefined){res.push(_b_.None)}\n                   else{res.push(jsmatch[arguments[i]])}\n               }\n               if(arguments.length == 1){return res[0]}\n               return _b_.tuple.$factory(res)\n            }\n            mo.groups = function(_default){\n               if(_default === undefined){_default = _b_.None}\n               var res = []\n               for(var i = 1, _len_i = jsmatch.length; i < _len_i; i++){\n                  if(jsmatch[i] === undefined){res.push(_default)}\n                  else{res.push(jsmatch[i])}\n               }\n               return _b_.tuple.$factory(res)\n            }\n            mo.start = function(){return mo._match.index}\n            mo.end = function(){return mo._match.length - mo._match.index}\n            mo.string = string\n            _list.push(mo)\n        }\n        return _list\n    }\n    obj.search = function(pattern, string){\n        var $ns = $B.args('re.search', 2,\n            {pattern:null, string:null},['pattern', 'string'],\n            arguments, {}, 'args', 'kw')\n        var args = $ns['args']\n        if(args.length>0){var flags = args[0]}\n        else{var flags = $B.$getattr($ns['kw'], 'get')('flags', '')}\n        flags = normflags(flags)\n        var jsp = new RegExp(pattern, flags)\n        var jsmatch = string.match(jsp)\n        if(jsmatch === null){return _b_.None}\n        return MatchObject.$factory(jsmatch, string, pattern)\n    }\n    obj.sub = function(pattern, repl, string){\n        var $ns=$B.args('re.search', 3,\n            {pattern: null, repl: null, string: null},\n            ['pattern', 'repl', 'string'],\n            arguments,{}, 'args', 'kw')\n        for($var in $ns){eval(\"var \" + $var + \"=$ns[$var]\")}\n        var args = $ns['args']\n        var count = _b_.dict.get($ns['kw'], 'count', 0)\n        var flags = _b_.dict.get($ns['kw'], 'flags', '')\n        if(args.length > 0){var count = args[0]}\n        if(args.length > 1){var flags = args[1]}\n        flags = normflags(flags)\n        if(typeof repl == \"string\"){\n            // backreferences are \\1, \\2... in Python but $1,$2... in Javascript\n            repl = repl.replace(/\\\\(\\d+)/g, '$$$1')\n        }else if(typeof repl == \"function\"){\n            // the argument passed to the Python function is the match object\n            // the arguments passed to the Javascript function are :\n            // - the matched substring\n            // - the matched groups\n            // - the offset of the matched substring inside the string\n            // - the string being examined\n            var $repl1 = function(){\n                var mo = Object()\n                mo.string = arguments[arguments.length - 1]\n                var matched = arguments[0];\n                var start = arguments[arguments.length - 2]\n                var end = start + matched.length\n                mo.start = function(){return start}\n                mo.end = function(){return end}\n                groups = []\n                for(var i = 1, _len_i = arguments.length-2; i < _len_i; i++){\n                    groups.push(arguments[i])\n                }\n                mo.groups = function(_default){\n                    if(_default === undefined){_default = _b_.None}\n                    var res = []\n                    for(var i = 0, _len_i = groups.length; i < _len_i; i++){\n                        if(groups[i] === undefined){res.push(_default)}\n                        else{res.push(groups[i])}\n                    }\n                    return res\n                }\n                mo.group = function(i){\n                    if(i==0){return matched}\n                    return groups[i-1]\n                }\n                return repl(mo)\n            }\n        }\n        if(count == 0){flags += 'g'}\n        var jsp = new RegExp(pattern, flags)\n        if(typeof repl == 'function'){return string.replace(jsp, $repl1)}\n        else{return string.replace(jsp, repl)}\n    }\n    obj.match = (function(search_func){\n        return function(){\n            // match is like search but pattern must start with ^\n            var pattern = arguments[0]\n            if(pattern.charAt(0) != '^'){pattern = '^'+pattern}\n            var args = [pattern]\n            for(var i = 1, _len_i = arguments.length; i < _len_i; i++){\n                args.push(arguments[i])\n            }\n            return search_func.apply(null, args)\n        }\n    })(obj.search)\n\n    return obj\n}\n)(__BRYTHON__)\n"],
     "_locale": [".js", "var am = {\n    \"C\": \"AM\",\n    \"aa\": \"saaku\",\n    \"ab\": \"AM\",\n    \"ae\": \"AM\",\n    \"af\": \"vm.\",\n    \"ak\": \"AN\",\n    \"am\": \"\\u1325\\u12cb\\u1275\",\n    \"an\": \"AM\",\n    \"ar\": \"\\u0635\",\n    \"as\": \"\\u09f0\\u09be\\u09a4\\u09bf\\u09aa\\u09c1\",\n    \"av\": \"AM\",\n    \"ay\": \"AM\",\n    \"az\": \"AM\",\n    \"ba\": \"\",\n    \"be\": \"\",\n    \"bg\": \"\",\n    \"bh\": \"AM\",\n    \"bi\": \"AM\",\n    \"bm\": \"AM\",\n    \"bn\": \"AM\",\n    \"bo\": \"\\u0f66\\u0f94\\u0f0b\\u0f51\\u0fb2\\u0f7c\",\n    \"br\": \"A.M.\",\n    \"bs\": \"prijepodne\",\n    \"ca\": \"a. m.\",\n    \"ce\": \"AM\",\n    \"ch\": \"AM\",\n    \"co\": \"\",\n    \"cr\": \"AM\",\n    \"cs\": \"dop.\",\n    \"cu\": \"\\u0414\\u041f\",\n    \"cv\": \"AM\",\n    \"cy\": \"yb\",\n    \"da\": \"\",\n    \"de\": \"\",\n    \"dv\": \"\\u0789\\u0786\",\n    \"dz\": \"\\u0f66\\u0f94\\u0f0b\\u0f46\\u0f0b\",\n    \"ee\": \"\\u014bdi\",\n    \"el\": \"\\u03c0\\u03bc\",\n    \"en\": \"AM\",\n    \"eo\": \"atm\",\n    \"es\": \"\",\n    \"et\": \"AM\",\n    \"eu\": \"AM\",\n    \"fa\": \"\\u0642.\\u0638\",\n    \"ff\": \"\",\n    \"fi\": \"ap.\",\n    \"fj\": \"AM\",\n    \"fo\": \"um fyr.\",\n    \"fr\": \"\",\n    \"fy\": \"AM\",\n    \"ga\": \"r.n.\",\n    \"gd\": \"m\",\n    \"gl\": \"a.m.\",\n    \"gn\": \"a.m.\",\n    \"gu\": \"\\u0aaa\\u0ac2\\u0ab0\\u0acd\\u0ab5\\u00a0\\u0aae\\u0aa7\\u0acd\\u0aaf\\u0abe\\u0ab9\\u0acd\\u0aa8\",\n    \"gv\": \"a.m.\",\n    \"ha\": \"AM\",\n    \"he\": \"AM\",\n    \"hi\": \"\\u092a\\u0942\\u0930\\u094d\\u0935\\u093e\\u0939\\u094d\\u0928\",\n    \"ho\": \"AM\",\n    \"hr\": \"\",\n    \"ht\": \"AM\",\n    \"hu\": \"de.\",\n    \"hy\": \"\",\n    \"hz\": \"AM\",\n    \"ia\": \"a.m.\",\n    \"id\": \"AM\",\n    \"ie\": \"AM\",\n    \"ig\": \"A.M.\",\n    \"ii\": \"\\ua0b5\\ua1aa\\ua20c\\ua210\",\n    \"ik\": \"AM\",\n    \"io\": \"AM\",\n    \"is\": \"f.h.\",\n    \"it\": \"\",\n    \"iu\": \"AM\",\n    \"ja\": \"\\u5348\\u524d\",\n    \"jv\": \"\",\n    \"ka\": \"AM\",\n    \"kg\": \"AM\",\n    \"ki\": \"Kiroko\",\n    \"kj\": \"AM\",\n    \"kk\": \"AM\",\n    \"kl\": \"\",\n    \"km\": \"\\u1796\\u17d2\\u179a\\u17b9\\u1780\",\n    \"kn\": \"\\u0caa\\u0cc2\\u0cb0\\u0ccd\\u0cb5\\u0cbe\\u0cb9\\u0ccd\\u0ca8\",\n    \"ko\": \"\\uc624\\uc804\",\n    \"kr\": \"AM\",\n    \"ks\": \"AM\",\n    \"ku\": \"\\u067e.\\u0646\",\n    \"kv\": \"AM\",\n    \"kw\": \"a.m.\",\n    \"ky\": \"\",\n    \"la\": \"\",\n    \"lb\": \"\",\n    \"lg\": \"AM\",\n    \"li\": \"AM\",\n    \"ln\": \"nt\\u0254\\u0301ng\\u0254\\u0301\",\n    \"lo\": \"\\u0e81\\u0ec8\\u0ead\\u0e99\\u0e97\\u0ec8\\u0ebd\\u0e87\",\n    \"lt\": \"prie\\u0161piet\",\n    \"lu\": \"Dinda\",\n    \"lv\": \"priek\\u0161p.\",\n    \"mg\": \"AM\",\n    \"mh\": \"AM\",\n    \"mi\": \"a.m.\",\n    \"mk\": \"\\u043f\\u0440\\u0435\\u0442\\u043f\\u043b.\",\n    \"ml\": \"AM\",\n    \"mn\": \"??\",\n    \"mo\": \"AM\",\n    \"mr\": \"\\u092e.\\u092a\\u0942.\",\n    \"ms\": \"PG\",\n    \"mt\": \"AM\",\n    \"my\": \"\\u1014\\u1036\\u1014\\u1000\\u103a\",\n    \"na\": \"AM\",\n    \"nb\": \"a.m.\",\n    \"nd\": \"AM\",\n    \"ne\": \"\\u092a\\u0942\\u0930\\u094d\\u0935\\u093e\\u0939\\u094d\\u0928\",\n    \"ng\": \"AM\",\n    \"nl\": \"\",\n    \"nn\": \"f.m.\",\n    \"no\": \"a.m.\",\n    \"nr\": \"AM\",\n    \"nv\": \"AM\",\n    \"ny\": \"AM\",\n    \"oc\": \"AM\",\n    \"oj\": \"AM\",\n    \"om\": \"WD\",\n    \"or\": \"AM\",\n    \"os\": \"AM\",\n    \"pa\": \"\\u0a38\\u0a35\\u0a47\\u0a30\",\n    \"pi\": \"AM\",\n    \"pl\": \"AM\",\n    \"ps\": \"\\u063a.\\u0645.\",\n    \"pt\": \"\",\n    \"qu\": \"a.m.\",\n    \"rc\": \"AM\",\n    \"rm\": \"AM\",\n    \"rn\": \"Z.MU.\",\n    \"ro\": \"a.m.\",\n    \"ru\": \"\",\n    \"rw\": \"AM\",\n    \"sa\": \"\\u092e\\u0927\\u094d\\u092f\\u093e\\u0928\\u092a\\u0942\\u0930\\u094d\\u0935\",\n    \"sc\": \"AM\",\n    \"sd\": \"AM\",\n    \"se\": \"i.b.\",\n    \"sg\": \"ND\",\n    \"sh\": \"AM\",\n    \"si\": \"\\u0db4\\u0dd9.\\u0dc0.\",\n    \"sk\": \"AM\",\n    \"sl\": \"dop.\",\n    \"sm\": \"AM\",\n    \"sn\": \"AM\",\n    \"so\": \"sn.\",\n    \"sq\": \"e paradites\",\n    \"sr\": \"pre podne\",\n    \"ss\": \"AM\",\n    \"st\": \"AM\",\n    \"su\": \"AM\",\n    \"sv\": \"\",\n    \"sw\": \"AM\",\n    \"ta\": \"\\u0b95\\u0bbe\\u0bb2\\u0bc8\",\n    \"te\": \"\\u0c2a\\u0c42\\u0c30\\u0c4d\\u0c35\\u0c3e\\u0c39\\u0c4d\\u0c28\",\n    \"tg\": \"\",\n    \"th\": \"AM\",\n    \"ti\": \"\\u1295\\u1309\\u1206 \\u1230\\u12d3\\u1270\",\n    \"tk\": \"\",\n    \"tl\": \"AM\",\n    \"tn\": \"AM\",\n    \"to\": \"AM\",\n    \"tr\": \"\\u00d6\\u00d6\",\n    \"ts\": \"AM\",\n    \"tt\": \"\",\n    \"tw\": \"AM\",\n    \"ty\": \"AM\",\n    \"ug\": \"\\u0686?\\u0634\\u062a\\u0649\\u0646 \\u0628?\\u0631?\\u0646\",\n    \"uk\": \"AM\",\n    \"ur\": \"AM\",\n    \"uz\": \"TO\",\n    \"ve\": \"AM\",\n    \"vi\": \"SA\",\n    \"vo\": \"AM\",\n    \"wa\": \"AM\",\n    \"wo\": \"\",\n    \"xh\": \"AM\",\n    \"yi\": \"\\ua0b5\\ua1aa\\ua20c\\ua210\",\n    \"yo\": \"\\u00c0\\u00e1r?`\",\n    \"za\": \"AM\",\n    \"zh\": \"\\u4e0a\\u5348\",\n    \"zu\": \"AM\"\n}\nvar pm = {\n    \"C\": \"PM\",\n    \"aa\": \"carra\",\n    \"ab\": \"PM\",\n    \"ae\": \"PM\",\n    \"af\": \"nm.\",\n    \"ak\": \"EW\",\n    \"am\": \"\\u12a8\\u1230\\u12d3\\u1275\",\n    \"an\": \"PM\",\n    \"ar\": \"\\u0645\",\n    \"as\": \"\\u0986\\u09ac\\u09c7\\u09b2\\u09bf\",\n    \"av\": \"PM\",\n    \"ay\": \"PM\",\n    \"az\": \"PM\",\n    \"ba\": \"\",\n    \"be\": \"\",\n    \"bg\": \"\",\n    \"bh\": \"PM\",\n    \"bi\": \"PM\",\n    \"bm\": \"PM\",\n    \"bn\": \"PM\",\n    \"bo\": \"\\u0f55\\u0fb1\\u0f72\\u0f0b\\u0f51\\u0fb2\\u0f7c\",\n    \"br\": \"G.M.\",\n    \"bs\": \"popodne\",\n    \"ca\": \"p. m.\",\n    \"ce\": \"PM\",\n    \"ch\": \"PM\",\n    \"co\": \"\",\n    \"cr\": \"PM\",\n    \"cs\": \"odp.\",\n    \"cu\": \"\\u041f\\u041f\",\n    \"cv\": \"PM\",\n    \"cy\": \"yh\",\n    \"da\": \"\",\n    \"de\": \"\",\n    \"dv\": \"\\u0789\\u078a\",\n    \"dz\": \"\\u0f55\\u0fb1\\u0f72\\u0f0b\\u0f46\\u0f0b\",\n    \"ee\": \"\\u0263etr\\u0254\",\n    \"el\": \"\\u03bc\\u03bc\",\n    \"en\": \"PM\",\n    \"eo\": \"ptm\",\n    \"es\": \"\",\n    \"et\": \"PM\",\n    \"eu\": \"PM\",\n    \"fa\": \"\\u0628.\\u0638\",\n    \"ff\": \"\",\n    \"fi\": \"ip.\",\n    \"fj\": \"PM\",\n    \"fo\": \"um sein.\",\n    \"fr\": \"\",\n    \"fy\": \"PM\",\n    \"ga\": \"i.n.\",\n    \"gd\": \"f\",\n    \"gl\": \"p.m.\",\n    \"gn\": \"p.m.\",\n    \"gu\": \"\\u0a89\\u0aa4\\u0acd\\u0aa4\\u0ab0\\u00a0\\u0aae\\u0aa7\\u0acd\\u0aaf\\u0abe\\u0ab9\\u0acd\\u0aa8\",\n    \"gv\": \"p.m.\",\n    \"ha\": \"PM\",\n    \"he\": \"PM\",\n    \"hi\": \"\\u0905\\u092a\\u0930\\u093e\\u0939\\u094d\\u0928\",\n    \"ho\": \"PM\",\n    \"hr\": \"\",\n    \"ht\": \"PM\",\n    \"hu\": \"du.\",\n    \"hy\": \"\",\n    \"hz\": \"PM\",\n    \"ia\": \"p.m.\",\n    \"id\": \"PM\",\n    \"ie\": \"PM\",\n    \"ig\": \"P.M.\",\n    \"ii\": \"\\ua0b5\\ua1aa\\ua20c\\ua248\",\n    \"ik\": \"PM\",\n    \"io\": \"PM\",\n    \"is\": \"e.h.\",\n    \"it\": \"\",\n    \"iu\": \"PM\",\n    \"ja\": \"\\u5348\\u5f8c\",\n    \"jv\": \"\",\n    \"ka\": \"PM\",\n    \"kg\": \"PM\",\n    \"ki\": \"Hwa\\u0129-in\\u0129\",\n    \"kj\": \"PM\",\n    \"kk\": \"PM\",\n    \"kl\": \"\",\n    \"km\": \"\\u179b\\u17d2\\u1784\\u17b6\\u1785\",\n    \"kn\": \"\\u0c85\\u0caa\\u0cb0\\u0cbe\\u0cb9\\u0ccd\\u0ca8\",\n    \"ko\": \"\\uc624\\ud6c4\",\n    \"kr\": \"PM\",\n    \"ks\": \"PM\",\n    \"ku\": \"\\u062f.\\u0646\",\n    \"kv\": \"PM\",\n    \"kw\": \"p.m.\",\n    \"ky\": \"\",\n    \"la\": \"\",\n    \"lb\": \"\",\n    \"lg\": \"PM\",\n    \"li\": \"PM\",\n    \"ln\": \"mp\\u00f3kwa\",\n    \"lo\": \"\\u0eab\\u0ebc\\u0eb1\\u0e87\\u0e97\\u0ec8\\u0ebd\\u0e87\",\n    \"lt\": \"popiet\",\n    \"lu\": \"Dilolo\",\n    \"lv\": \"p\\u0113cp.\",\n    \"mg\": \"PM\",\n    \"mh\": \"PM\",\n    \"mi\": \"p.m.\",\n    \"mk\": \"\\u043f\\u043e\\u043f\\u043b.\",\n    \"ml\": \"PM\",\n    \"mn\": \"?\\u0425\",\n    \"mo\": \"PM\",\n    \"mr\": \"\\u092e.\\u0928\\u0902.\",\n    \"ms\": \"PTG\",\n    \"mt\": \"PM\",\n    \"my\": \"\\u100a\\u1014\\u1031\",\n    \"na\": \"PM\",\n    \"nb\": \"p.m.\",\n    \"nd\": \"PM\",\n    \"ne\": \"\\u0905\\u092a\\u0930\\u093e\\u0939\\u094d\\u0928\",\n    \"ng\": \"PM\",\n    \"nl\": \"\",\n    \"nn\": \"e.m.\",\n    \"no\": \"p.m.\",\n    \"nr\": \"PM\",\n    \"nv\": \"PM\",\n    \"ny\": \"PM\",\n    \"oc\": \"PM\",\n    \"oj\": \"PM\",\n    \"om\": \"WB\",\n    \"or\": \"PM\",\n    \"os\": \"PM\",\n    \"pa\": \"\\u0a36\\u0a3e\\u0a2e\",\n    \"pi\": \"PM\",\n    \"pl\": \"PM\",\n    \"ps\": \"\\u063a.\\u0648.\",\n    \"pt\": \"\",\n    \"qu\": \"p.m.\",\n    \"rc\": \"PM\",\n    \"rm\": \"PM\",\n    \"rn\": \"Z.MW.\",\n    \"ro\": \"p.m.\",\n    \"ru\": \"\",\n    \"rw\": \"PM\",\n    \"sa\": \"\\u092e\\u0927\\u094d\\u092f\\u093e\\u0928\\u092a\\u091a\\u094d\\u092f\\u093e\\u0924\",\n    \"sc\": \"PM\",\n    \"sd\": \"PM\",\n    \"se\": \"e.b.\",\n    \"sg\": \"LK\",\n    \"sh\": \"PM\",\n    \"si\": \"\\u0db4.\\u0dc0.\",\n    \"sk\": \"PM\",\n    \"sl\": \"pop.\",\n    \"sm\": \"PM\",\n    \"sn\": \"PM\",\n    \"so\": \"gn.\",\n    \"sq\": \"e pasdites\",\n    \"sr\": \"po podne\",\n    \"ss\": \"PM\",\n    \"st\": \"PM\",\n    \"su\": \"PM\",\n    \"sv\": \"\",\n    \"sw\": \"PM\",\n    \"ta\": \"\\u0bae\\u0bbe\\u0bb2\\u0bc8\",\n    \"te\": \"\\u0c05\\u0c2a\\u0c30\\u0c3e\\u0c39\\u0c4d\\u0c28\",\n    \"tg\": \"\",\n    \"th\": \"PM\",\n    \"ti\": \"\\u12f5\\u1215\\u122d \\u1230\\u12d3\\u1275\",\n    \"tk\": \"\",\n    \"tl\": \"PM\",\n    \"tn\": \"PM\",\n    \"to\": \"PM\",\n    \"tr\": \"\\u00d6S\",\n    \"ts\": \"PM\",\n    \"tt\": \"\",\n    \"tw\": \"PM\",\n    \"ty\": \"PM\",\n    \"ug\": \"\\u0686?\\u0634\\u062a\\u0649\\u0646 \\u0643?\\u064a\\u0649\\u0646\",\n    \"uk\": \"PM\",\n    \"ur\": \"PM\",\n    \"uz\": \"TK\",\n    \"ve\": \"PM\",\n    \"vi\": \"CH\",\n    \"vo\": \"PM\",\n    \"wa\": \"PM\",\n    \"wo\": \"\",\n    \"xh\": \"PM\",\n    \"yi\": \"\\ua0b5\\ua1aa\\ua20c\\ua248\",\n    \"yo\": \"?`s\\u00e1n\",\n    \"za\": \"PM\",\n    \"zh\": \"\\u4e0b\\u5348\",\n    \"zu\": \"PM\"\n}\n\nvar X_format = {\n    \"%H:%M:%S\": [\n        \"C\",\n        \"ab\",\n        \"ae\",\n        \"af\",\n        \"an\",\n        \"av\",\n        \"ay\",\n        \"az\",\n        \"ba\",\n        \"be\",\n        \"bg\",\n        \"bh\",\n        \"bi\",\n        \"bm\",\n        \"bo\",\n        \"br\",\n        \"bs\",\n        \"ca\",\n        \"ce\",\n        \"ch\",\n        \"co\",\n        \"cr\",\n        \"cs\",\n        \"cu\",\n        \"cv\",\n        \"cy\",\n        \"da\",\n        \"de\",\n        \"dv\",\n        \"eo\",\n        \"es\",\n        \"et\",\n        \"eu\",\n        \"ff\",\n        \"fj\",\n        \"fo\",\n        \"fr\",\n        \"fy\",\n        \"ga\",\n        \"gd\",\n        \"gl\",\n        \"gn\",\n        \"gu\",\n        \"gv\",\n        \"ha\",\n        \"he\",\n        \"hi\",\n        \"ho\",\n        \"hr\",\n        \"ht\",\n        \"hu\",\n        \"hy\",\n        \"hz\",\n        \"ia\",\n        \"ie\",\n        \"ig\",\n        \"ik\",\n        \"io\",\n        \"is\",\n        \"it\",\n        \"ja\",\n        \"ka\",\n        \"kg\",\n        \"ki\",\n        \"kj\",\n        \"kk\",\n        \"kl\",\n        \"km\",\n        \"kn\",\n        \"kv\",\n        \"kw\",\n        \"ky\",\n        \"la\",\n        \"lb\",\n        \"lg\",\n        \"li\",\n        \"ln\",\n        \"lo\",\n        \"lt\",\n        \"lu\",\n        \"lv\",\n        \"mg\",\n        \"mh\",\n        \"mk\",\n        \"mn\",\n        \"mo\",\n        \"mr\",\n        \"mt\",\n        \"my\",\n        \"na\",\n        \"nb\",\n        \"nd\",\n        \"ng\",\n        \"nl\",\n        \"nn\",\n        \"no\",\n        \"nr\",\n        \"nv\",\n        \"ny\",\n        \"oj\",\n        \"or\",\n        \"os\",\n        \"pi\",\n        \"pl\",\n        \"ps\",\n        \"pt\",\n        \"rc\",\n        \"rm\",\n        \"rn\",\n        \"ro\",\n        \"ru\",\n        \"rw\",\n        \"sa\",\n        \"sc\",\n        \"se\",\n        \"sg\",\n        \"sh\",\n        \"sk\",\n        \"sl\",\n        \"sm\",\n        \"sn\",\n        \"sr\",\n        \"ss\",\n        \"st\",\n        \"su\",\n        \"sv\",\n        \"sw\",\n        \"ta\",\n        \"te\",\n        \"tg\",\n        \"th\",\n        \"tk\",\n        \"tl\",\n        \"tn\",\n        \"tr\",\n        \"ts\",\n        \"tt\",\n        \"tw\",\n        \"ty\",\n        \"ug\",\n        \"uk\",\n        \"uz\",\n        \"ve\",\n        \"vo\",\n        \"wa\",\n        \"wo\",\n        \"xh\",\n        \"yo\",\n        \"za\",\n        \"zh\",\n        \"zu\"\n    ],\n    \"%i:%M:%S %p\": [\n        \"aa\",\n        \"ak\",\n        \"am\",\n        \"bn\",\n        \"el\",\n        \"en\",\n        \"iu\",\n        \"kr\",\n        \"ks\",\n        \"mi\",\n        \"ml\",\n        \"ms\",\n        \"ne\",\n        \"om\",\n        \"sd\",\n        \"so\",\n        \"sq\",\n        \"ti\",\n        \"to\",\n        \"ur\",\n        \"vi\"\n    ],\n    \"%I:%M:%S %p\": [\n        \"ar\",\n        \"fa\",\n        \"ku\",\n        \"qu\"\n    ],\n    \"%p %i:%M:%S\": [\n        \"as\",\n        \"ii\",\n        \"ko\",\n        \"yi\"\n    ],\n    \"\\u0f46\\u0f74\\u0f0b\\u0f5a\\u0f7c\\u0f51\\u0f0b%i:%M:%S %p\": [\n        \"dz\"\n    ],\n    \"%p ga %i:%M:%S\": [\n        \"ee\"\n    ],\n    \"%H.%M.%S\": [\n        \"fi\",\n        \"id\",\n        \"jv\",\n        \"oc\",\n        \"si\"\n    ],\n    \"%p %I:%M:%S\": [\n        \"pa\"\n    ]\n}\nvar x_format = {\n    \"%m/%d/%y\": [\n        \"C\"\n    ],\n    \"%d/%m/%Y\": [\n        \"aa\",\n        \"am\",\n        \"bm\",\n        \"bn\",\n        \"ca\",\n        \"co\",\n        \"cy\",\n        \"el\",\n        \"es\",\n        \"ff\",\n        \"fr\",\n        \"ga\",\n        \"gd\",\n        \"gl\",\n        \"gn\",\n        \"gv\",\n        \"ha\",\n        \"he\",\n        \"id\",\n        \"ig\",\n        \"it\",\n        \"iu\",\n        \"jv\",\n        \"ki\",\n        \"kr\",\n        \"kw\",\n        \"la\",\n        \"lg\",\n        \"ln\",\n        \"lo\",\n        \"lu\",\n        \"mi\",\n        \"ml\",\n        \"ms\",\n        \"mt\",\n        \"nd\",\n        \"oc\",\n        \"om\",\n        \"pt\",\n        \"qu\",\n        \"rn\",\n        \"sd\",\n        \"sg\",\n        \"so\",\n        \"sw\",\n        \"ti\",\n        \"to\",\n        \"uk\",\n        \"ur\",\n        \"uz\",\n        \"vi\",\n        \"wo\",\n        \"yo\"\n    ],\n    \"%m/%d/%Y\": [\n        \"ab\",\n        \"ae\",\n        \"an\",\n        \"av\",\n        \"ay\",\n        \"bh\",\n        \"bi\",\n        \"ch\",\n        \"cr\",\n        \"cv\",\n        \"ee\",\n        \"en\",\n        \"fj\",\n        \"ho\",\n        \"ht\",\n        \"hz\",\n        \"ie\",\n        \"ik\",\n        \"io\",\n        \"kg\",\n        \"kj\",\n        \"ks\",\n        \"kv\",\n        \"li\",\n        \"mh\",\n        \"mo\",\n        \"na\",\n        \"ne\",\n        \"ng\",\n        \"nv\",\n        \"ny\",\n        \"oj\",\n        \"pi\",\n        \"rc\",\n        \"sc\",\n        \"sh\",\n        \"sm\",\n        \"su\",\n        \"tl\",\n        \"tw\",\n        \"ty\",\n        \"wa\",\n        \"za\",\n        \"zu\"\n    ],\n    \"%Y-%m-%d\": [\n        \"af\",\n        \"br\",\n        \"ce\",\n        \"dz\",\n        \"eo\",\n        \"ko\",\n        \"lt\",\n        \"mg\",\n        \"nr\",\n        \"rw\",\n        \"se\",\n        \"si\",\n        \"sn\",\n        \"ss\",\n        \"st\",\n        \"sv\",\n        \"tn\",\n        \"ts\",\n        \"ug\",\n        \"ve\",\n        \"vo\",\n        \"xh\"\n    ],\n    \"%Y/%m/%d\": [\n        \"ak\",\n        \"bo\",\n        \"eu\",\n        \"ia\",\n        \"ii\",\n        \"ja\",\n        \"ku\",\n        \"yi\",\n        \"zh\"\n    ],\n    \"null\": [\n        \"ar\",\n        \"fa\",\n        \"ps\",\n        \"th\"\n    ],\n    \"%d-%m-%Y\": [\n        \"as\",\n        \"da\",\n        \"fy\",\n        \"hi\",\n        \"kl\",\n        \"mr\",\n        \"my\",\n        \"nl\",\n        \"rm\",\n        \"sa\",\n        \"ta\"\n    ],\n    \"%d.%m.%Y\": [\n        \"az\",\n        \"cs\",\n        \"de\",\n        \"et\",\n        \"fi\",\n        \"fo\",\n        \"hy\",\n        \"is\",\n        \"ka\",\n        \"kk\",\n        \"lv\",\n        \"mk\",\n        \"nb\",\n        \"nn\",\n        \"no\",\n        \"os\",\n        \"pl\",\n        \"ro\",\n        \"ru\",\n        \"sq\",\n        \"tg\",\n        \"tr\",\n        \"tt\"\n    ],\n    \"%d.%m.%y\": [\n        \"ba\",\n        \"be\",\n        \"lb\"\n    ],\n    \"%d.%m.%Y \\u0433.\": [\n        \"bg\"\n    ],\n    \"%d.%m.%Y.\": [\n        \"bs\",\n        \"hr\",\n        \"sr\"\n    ],\n    \"%Y.%m.%d\": [\n        \"cu\",\n        \"mn\"\n    ],\n    \"%d/%m/%y\": [\n        \"dv\",\n        \"km\"\n    ],\n    \"%d-%m-%y\": [\n        \"gu\",\n        \"kn\",\n        \"or\",\n        \"pa\",\n        \"te\"\n    ],\n    \"%Y. %m. %d.\": [\n        \"hu\"\n    ],\n    \"%d-%b %y\": [\n        \"ky\"\n    ],\n    \"%d. %m. %Y\": [\n        \"sk\",\n        \"sl\"\n    ],\n    \"%d.%m.%y \\u00fd.\": [\n        \"tk\"\n    ]\n}\n\n\nvar $module=(function($B){\n    var _b_ = $B.builtins\n    return {\n        CHAR_MAX: 127,\n        LC_ALL: 6,\n        LC_COLLATE: 3,\n        LC_CTYPE: 0,\n        LC_MESSAGES: 5,\n        LC_MONETARY: 4,\n        LC_NUMERIC: 1,\n        LC_TIME: 2,\n        Error: _b_.ValueError,\n\n        _date_format: function(spec, hour){\n            var t,\n                locale = __BRYTHON__.locale.substr(0, 2)\n\n            if(spec == \"p\"){\n                var res = hours < 12 ? am[locale] : pm[locale]\n                if(res === undefined){\n                    throw _b_.ValueError.$factory(\"no format \" + spec + \" for locale \" +\n                        locale)\n                }\n                return res\n            }\n            else if(spec == \"x\"){\n                t = x_format\n            }else if(spec == \"X\"){\n                t = X_format\n            }else{\n                throw _b_.ValueError.$factory(\"invalid format\", spec)\n            }\n            for(var key in t){\n                if(t[key].indexOf(locale) > -1){\n                    return key\n                }\n            }\n            throw _b_.ValueError.$factory(\"no format \" + spec + \" for locale \" +\n                locale)\n        },\n\n        localeconv: function(){\n            var conv = {'grouping': [127],\n                    'currency_symbol': '',\n                    'n_sign_posn': 127,\n                    'p_cs_precedes': 127,\n                    'n_cs_precedes': 127,\n                    'mon_grouping': [],\n                    'n_sep_by_space': 127,\n                    'decimal_point': '.',\n                    'negative_sign': '',\n                    'positive_sign': '',\n                    'p_sep_by_space': 127,\n                    'int_curr_symbol': '',\n                    'p_sign_posn': 127,\n                    'thousands_sep': '',\n                    'mon_thousands_sep': '',\n                    'frac_digits': 127,\n                    'mon_decimal_point': '',\n                    'int_frac_digits': 127\n             }\n             var res = $B.empty_dict()\n             for(var key in conv){\n                 res.$string_dict[key] = [conv, res.$order++]\n             }\n             return res\n         },\n\n        setlocale : function(){\n            var $ = $B.args(\"setlocale\", 2, {category: null, locale: null},\n                [\"category\", \"locale\"], arguments, {locale: _b_.None},\n                null, null)\n            /// XXX category is currently ignored\n            if($.locale == \"\"){\n                // use browser language setting, if it is set\n                var LANG = ($B.language || \"\").substr(0, 2)\n                if(am.hasOwnProperty(LANG)){\n                    $B.locale = LANG\n                    return LANG\n                }else{\n                    console.log(\"Unknown locale: \" + LANG)\n                }\n            }else if($.locale === _b_.None){\n                // return current locale\n                return $B.locale\n            }else{\n                // Only use 2 first characters\n                try{$.locale.substr(0, 2)}\n                catch(err){\n                    throw $module.Error.$factory(\"Invalid locale: \" + $.locale)\n                }\n                if(am.hasOwnProperty($.locale.substr(0, 2))){\n                    $B.locale = $.locale\n                    return $.locale\n                }else{\n                    throw $module.Error.$factory(\"Unknown locale: \" + $.locale)\n                }\n            }\n        }\n    }\n})(__BRYTHON__)\n"],
-    "_multiprocessing": [".js", "// multiprocessing\nvar $module = (function($B){\n\nvar _b_ = $B.builtins\nvar $s=[]\nfor(var $b in _b_) $s.push('var ' + $b +'=_b_[\"'+$b+'\"]')\neval($s.join(';'))\n\n//for(var $py_builtin in _b_){eval(\"var \"+$py_builtin+\"=_b_[$py_builtin]\")}\n\nvar Process = {\n    __class__:_b_.type,\n    __mro__: [_b_.object],\n    $infos:{\n        __name__:'Process'\n    },\n    $is_class: true\n}\n\nvar $convert_args=function(args) {\n    var _list=[]\n    for(var i=0, _len_i = args.length; i < _len_i; i++) {\n      var _a=args[i]\n      if(isinstance(_a, str)){_list.push(\"'\"+_a+\"'\")} else {_list.push(_a)}\n    }\n\n    return _list.join(',')\n}\n\nProcess.is_alive = function(self){return self.$alive}\n\nProcess.join = function(self, timeout){\n   // need to block until process is complete\n   // could probably use a addEventListener to execute all existing code\n   // after this join statement\n\n   self.$worker.addEventListener('message', function (e) {\n        var data=e.data\n        if (data.stdout != '') { // output stdout from process\n           $B.stdout.write(data.stdout)\n        }\n   }, false);\n}\n\nProcess.run = function(self){\n   //fix me\n}\n\nProcess.start = function(self){\n   self.$worker.postMessage({target: self.$target,\n                             args: $convert_args(self.$args),\n                          //   kwargs: self.$kwargs\n                           })\n   self.$worker.addEventListener('error', function(e) { throw e})\n   self.$alive=true\n}\n\nProcess.terminate = function(self){\n   self.$worker.terminate()\n   self.$alive=false\n}\n\n// variables\n//name\n//daemon\n//pid\n//exitcode\n\nProcess. $factory = function(){\n    //arguments group=None, target=None, name=None, args=(), kwargs=()\n\n    var $ns=$B.args('Process',0,{},[],arguments,{},null,'kw')\n    var kw=$ns['kw']\n\n    var target=_b_.dict.get($ns['kw'],'target',None)\n    var args=_b_.dict.get($ns['kw'],'args',tuple.$factory())\n\n    var worker = new Worker('/src/web_workers/multiprocessing.js')\n\n    var res = {\n        __class__:Process,\n        $worker: worker,\n        name: $ns['name'] || None,\n        $target: target+'',\n        $args: args,\n        //$kwargs: $ns['kw'],\n        $alive: false\n    }\n    return res\n}\n\n$B.set_func_names(Process, \"multiprocessing\")\n\nvar Pool = $B.make_class(\"Pool\")\n\nPool.__enter__ = function(self){}\nPool.__exit__ = function(self){}\n\nPool.__str__ = Pool.toString = Pool.__repr__=function(self){\n   return '<object Pool>'\n}\n\nPool.map = function(){\n\n   var $ns=$B.args('Pool.map', 3,\n       {self:null, func:null, fargs:null}, ['self', 'func', 'fargs'],\n       arguments,{},'args','kw')\n   var func=$ns['func']\n   var fargs=$ns['fargs']\n\n   var _results=[]\n\n   fargs=iter(fargs)\n\n   var _pos=0\n   console.log(self.$processes)\n   _workers=[]\n   for(var i=0; i < self.$processes; i++) {\n       _workers[i] = new Worker('/src/web_workers/multiprocessing.js')\n       var arg\n\n       try{arg=getattr(fargs, '__next__')()}\n       catch(err) {\n          if (err.__class__ !== _b_.StopIteration) throw err\n       }\n       console.log(arg)\n       _workers[i].finished=false\n       _workers[i].postMessage({target: func+'', pos: _pos,\n                             args: $convert_args([arg])})\n       _pos++\n\n       _workers[i].addEventListener('message', function(e) {\n           _results[e.data.pos]=e.data.result\n           if (_results.length == args.length) return _results\n\n           try {\n               arg=getattr(fargs, '__next__')()\n               e.currentTarget.postMessage({target: func+'', pos: _pos,\n                                            args: $convert_args([arg])})\n               _pos++\n           } catch(err) {\n               if (err.__class__ !== _b_.StopIteration) throw err\n               this.finished=true\n           }\n       }, false);\n   }\n}\n\nPool.apply_async = function(){\n\n   var $ns=$B.$MakeArgs('apply_async', 3,\n       {self:null, func:null, fargs:null}, ['self', 'func', 'fargs'],\n       arguments,{},'args','kw')\n   var func=$ns['func']\n   var fargs=$ns['fargs']\n\n   fargs=iter(fargs)\n\n   async_result = {}\n   async_result.get=function(timeout){\n                      console.log(results)\n                      console.log(fargs)\n                      return this.results}\n   async_result.results=[]\n\n   var _pos=0\n\n   _workers=[]\n   for(var i=0; i < self.$processes; i++) {\n       _workers[i] = new Worker('/src/web_workers/multiprocessing.js')\n       var arg\n\n       try{arg=getattr(fargs, '__next__')()}\n       catch(err) {\n          if (err.__class__ !== _b_.StopIteration) throw err\n       }\n       //console.log(arg)\n       //_workers[i].finished=false\n       _workers[i].postMessage({target: func+'', pos: _pos,\n                             args: $convert_args([arg])})\n       _pos++\n\n       _workers[i].addEventListener('message', function(e) {\n           async_result.results[e.data.pos]=e.data.result\n           //if (_results.length == args.length) return _results\n\n           try {\n               arg=getattr(fargs, '__next__')()\n               e.currentTarget.postMessage({target: func+'', pos: _pos,\n                                            args: $convert_args([arg])})\n               _pos++\n           } catch(err) {\n               if (err.__class__ !== _b_.StopIteration) throw err\n               this.finished=true\n           }\n       }, false);\n   }\n\n   console.log(\"return\", async_result)\n   return async_result\n}\n\nPool.$factory = function(){\n    console.log(\"pool\")\n    console.log(arguments)\n    var $ns=$B.args('Pool',1,\n        {processes:null},['processes'],arguments,{},'args','kw')\n    //var kw=$ns['kw']\n\n    var processes=$ns['processes']\n\n    if (processes == None) {\n       // look to see if we have stored cpu_count in local storage\n       // maybe we should create a brython config file with settings,etc..??\n\n       // if not there use a tool such as Core Estimator to calculate number of cpu's\n       // http://eligrey.com/blog/post/cpu-core-estimation-with-javascript\n    }\n\n    console.log(processes)\n    var res = {\n        __class__:Pool,\n        $processes:processes\n    }\n    return res\n}\n\n$B.set_func_names(Pool, \"multiprocessing\")\n\nreturn {Process:Process, Pool:Pool}\n\n})(__BRYTHON__)\n"],
+    "_multiprocessing": [".js", "// multiprocessing\nvar $module = (function($B){\n\nvar _b_ = $B.builtins\n\nvar Process = {\n    __class__:_b_.type,\n    __mro__: [_b_.object],\n    $infos:{\n        __name__:'Process'\n    },\n    $is_class: true\n}\n\nvar $convert_args=function(args) {\n    var _list=[]\n    for(var i=0, _len_i = args.length; i < _len_i; i++) {\n      var _a=args[i]\n      if(_b_.isinstance(_a, _b_.str)){_list.push(\"'\"+_a+\"'\")} else {_list.push(_a)}\n    }\n\n    return _list.join(',')\n}\n\nProcess.is_alive = function(self){return self.$alive}\n\nProcess.join = function(self, timeout){\n   // need to block until process is complete\n   // could probably use a addEventListener to execute all existing code\n   // after this join statement\n\n   self.$worker.addEventListener('message', function (e) {\n        var data=e.data\n        if (data.stdout != '') { // output stdout from process\n           $B.stdout.write(data.stdout)\n        }\n   }, false);\n}\n\nProcess.run = function(self){\n   //fix me\n}\n\nProcess.start = function(self){\n   self.$worker.postMessage({target: self.$target,\n                             args: $convert_args(self.$args),\n                          //   kwargs: self.$kwargs\n                           })\n   self.$worker.addEventListener('error', function(e) { throw e})\n   self.$alive=true\n}\n\nProcess.terminate = function(self){\n   self.$worker.terminate()\n   self.$alive=false\n}\n\n// variables\n//name\n//daemon\n//pid\n//exitcode\n\nProcess. $factory = function(){\n    //arguments group=None, target=None, name=None, args=(), kwargs=()\n\n    var $ns=$B.args('Process',0,{},[],arguments,{},null,'kw')\n    var kw=$ns['kw']\n\n    var target=_b_.dict.get($ns['kw'],'target', _b_.None)\n    var args=_b_.dict.get($ns['kw'],'args', _b_.tuple.$factory())\n\n    var worker = new Worker('/src/web_workers/multiprocessing.js')\n\n    var res = {\n        __class__:Process,\n        $worker: worker,\n        name: $ns['name'] || _b_.None,\n        $target: target+'',\n        $args: args,\n        //$kwargs: $ns['kw'],\n        $alive: false\n    }\n    return res\n}\n\n$B.set_func_names(Process, \"multiprocessing\")\n\nvar Pool = $B.make_class(\"Pool\")\n\nPool.__enter__ = function(self){}\nPool.__exit__ = function(self){}\n\nPool.__str__ = Pool.toString = Pool.__repr__=function(self){\n   return '<object Pool>'\n}\n\nPool.map = function(){\n\n   var $ns=$B.args('Pool.map', 3,\n       {self:null, func:null, fargs:null}, ['self', 'func', 'fargs'],\n       arguments,{},'args','kw')\n   var func = $ns['func']\n   var fargs = $ns['fargs']\n\n   var _results = []\n\n   fargs = _b_.iter(fargs)\n\n   var _pos = 0\n   console.log(self.$processes)\n   _workers =[]\n   for(var i=0; i < self.$processes; i++) {\n       _workers[i] = new Worker('/src/web_workers/multiprocessing.js')\n       var arg\n\n       try{arg = $B.$getattr(fargs, '__next__')()}\n       catch(err) {\n          if (err.__class__ !== _b_.StopIteration) throw err\n       }\n       console.log(arg)\n       _workers[i].finished=false\n       _workers[i].postMessage({target: func+'', pos: _pos,\n                             args: $convert_args([arg])})\n       _pos++\n\n       _workers[i].addEventListener('message', function(e) {\n           _results[e.data.pos]=e.data.result\n           if (_results.length == args.length) return _results\n\n           try {\n               arg = $B.$getattr(fargs, '__next__')()\n               e.currentTarget.postMessage({target: func+'', pos: _pos,\n                                            args: $convert_args([arg])})\n               _pos++\n           } catch(err) {\n               if (err.__class__ !== _b_.StopIteration) throw err\n               this.finished=true\n           }\n       }, false);\n   }\n}\n\nPool.apply_async = function(){\n\n   var $ns=$B.$MakeArgs('apply_async', 3,\n       {self:null, func:null, fargs:null}, ['self', 'func', 'fargs'],\n       arguments,{},'args','kw')\n   var func = $ns['func']\n   var fargs = $ns['fargs']\n\n   fargs = _b_.iter(fargs)\n\n   async_result = {}\n   async_result.get = function(timeout){\n                      console.log(results)\n                      console.log(fargs)\n                      return this.results}\n   async_result.results=[]\n\n   var _pos=0\n\n   _workers=[]\n   for(var i=0; i < self.$processes; i++) {\n       _workers[i] = new Worker('/src/web_workers/multiprocessing.js')\n       var arg\n\n       try{arg = $B.$getattr(fargs, '__next__')()}\n       catch(err) {\n          if (err.__class__ !== _b_.StopIteration) throw err\n       }\n       //console.log(arg)\n       //_workers[i].finished=false\n       _workers[i].postMessage({target: func+'', pos: _pos,\n                             args: $convert_args([arg])})\n       _pos++\n\n       _workers[i].addEventListener('message', function(e) {\n           async_result.results[e.data.pos]=e.data.result\n           //if (_results.length == args.length) return _results\n\n           try {\n               arg = $B.$getattr(fargs, '__next__')()\n               e.currentTarget.postMessage({target: func+'', pos: _pos,\n                                            args: $convert_args([arg])})\n               _pos++\n           } catch(err) {\n               if (err.__class__ !== _b_.StopIteration) throw err\n               this.finished=true\n           }\n       }, false);\n   }\n\n   console.log(\"return\", async_result)\n   return async_result\n}\n\nPool.$factory = function(){\n    console.log(\"pool\")\n    console.log(arguments)\n    var $ns=$B.args('Pool',1,\n        {processes:null},['processes'],arguments,{},'args','kw')\n\n    var processes = $ns['processes']\n\n    if (processes === _b_.None) {\n       // look to see if we have stored cpu_count in local storage\n       // maybe we should create a brython config file with settings,etc..??\n\n       // if not there use a tool such as Core Estimator to calculate number of cpu's\n       // http://eligrey.com/blog/post/cpu-core-estimation-with-javascript\n    }\n\n    console.log(processes)\n    var res = {\n        __class__:Pool,\n        $processes:processes\n    }\n    return res\n}\n\n$B.set_func_names(Pool, \"multiprocessing\")\n\nreturn {Process:Process, Pool:Pool}\n\n})(__BRYTHON__)\n"],
     "_posixsubprocess": [".js", "var $module=(function($B){\n\n    return {\n       cloexec_pipe: function() {}   // fixme\n    }\n})(__BRYTHON__)\n"],
     "_profile": [".js", "// Private interface to the profiling instrumentation implemented in py_utils.js.\n// Uses local a copy of the eval function from py_builtin_functions.js\n\nvar $module=(function($B) {\n    eval($B.InjectBuiltins());\n    return {\n        brython:$B,\n        data:$B.$profile_data,\n        start:$B.$profile.start,\n        stop:$B.$profile.stop,\n        pause:$B.$profile.pause,\n        status:$B.$profile.status,\n        clear:$B.$profile.clear,\n        elapsed:$B.$profile.elapsed,\n        run:function(src,_globals,_locals,nruns) {\n            var current_frame = $B.frames_stack[$B.frames_stack.length-1]\n            if(current_frame!==undefined){\n                var current_locals_id = current_frame[0].replace(/\\./,'_'),\n             current_globals_id = current_frame[2].replace(/\\./,'_')\n            }\n\n            var is_exec = true,\n                leave = false\n\n            // code will be run in a specific block\n            var globals_id = '$profile_'+$B.UUID(),\n             locals_id\n\n             if(_locals===_globals){\n                 locals_id = globals_id\n             }else{\n                 locals_id = '$profile_'+$B.UUID()\n             }\n             // Initialise the object for block namespaces\n             eval('var $locals_'+globals_id+' = {}\\nvar $locals_'+locals_id+' = {}')\n\n             // Initialise block globals\n\n            // A _globals dictionary is provided, set or reuse its attribute\n            // globals_id\n            _globals.globals_id = _globals.globals_id || globals_id\n            globals_id = _globals.globals_id\n\n            if(_locals === _globals || _locals === undefined){\n                locals_id = globals_id\n                parent_scope = $B.builtins_scope\n            }else{\n                // The parent block of locals must be set to globals\n                parent_scope = {\n                    id: globals_id,\n                    parent_block: $B.builtins_scope,\n                    binding: {}\n                }\n                for(var attr in _globals.$string_dict){\n                    parent_scope.binding[attr] = true\n                }\n            }\n\n            // Initialise block globals\n            if(_globals.$jsobj){var items = _globals.$jsobj}\n            else{var items = _globals.$string_dict}\n            for(var item in items){\n                item1 = to_alias(item)\n                try{\n                    eval('$locals_' + globals_id + '[\"' + item1 +\n                        '\"] = items[item]')\n                }catch(err){\n                    console.log(err)\n                    console.log('error setting', item)\n                    break\n                }\n            }\n\n             // Initialise block locals\n            var items = _b_.dict.items(_locals), item\n            if(_locals.$jsobj){var items = _locals.$jsobj}\n            else{var items = _locals.$string_dict}\n            for(var item in items){\n                item1 = to_alias(item)\n                try{\n                    eval('$locals_' + locals_id + '[\"' + item[0] + '\"] = item[1]')\n                }catch(err){\n                    console.log(err)\n                    console.log('error setting', item)\n                    break\n                }\n            }\n             //var nb_modules = Object.keys(__BRYTHON__.modules).length\n             //console.log('before exec', nb_modules)\n\n            console.log(\"call py2js\", src, globals_id, locals_id, parent_scope)\n            var root = $B.py2js(src, globals_id, locals_id, parent_scope),\n                js, gns, lns\n\n             try{\n\n                 var js = root.to_js()\n\n                     var i,res,gns;\n                     for(i=0;i<nruns;i++) {\n                         res = eval(js)\n                         gns = eval('$locals_'+globals_id)\n                     }\n\n                     // Update _locals with the namespace after execution\n                     if(_locals!==undefined){\n                         var lns = eval('$locals_'+locals_id)\n                         var setitem = getattr(_locals,'__setitem__')\n                         for(var attr in lns){\n                             if(attr.charAt(0)=='$'){continue}\n                             setitem(attr, lns[attr])\n                         }\n                     }else{\n                         for(var attr in lns){current_frame[1][attr] = lns[attr]}\n                     }\n\n                     if(_globals!==undefined){\n                         // Update _globals with the namespace after execution\n                         var setitem = getattr(_globals,'__setitem__')\n                         for(var attr in gns){\n                             if(attr.charAt(0)=='$'){continue}\n                             setitem(attr, gns[attr])\n                         }\n                     }else{\n                         for(var attr in gns){\n                             current_frame[3][attr] = gns[attr]\n                         }\n                     }\n\n                     // fixme: some extra variables are bleeding into locals...\n                     /*  This also causes issues for unittests */\n                     if(res===undefined) return _b_.None\n                         return res\n             }catch(err){\n                 if(err.$py_error===undefined){throw $B.exception(err)}\n                 throw err\n             }finally{\n\n                 delete __BRYTHON__.modules[globals_id]\n                 delete __BRYTHON__.modules[locals_id]\n                 $B.clear_ns(globals_id)\n                 $B.clear_ns(locals_id)\n\n                 if(!is_exec && leave_frame){\n                     // For eval(), the finally clause with \"leave_frame\" was removed\n                     // so we must execute it here\n                     $B.frames_stack.pop()\n                 }\n             }\n        }\n    }\n})(__BRYTHON__)\n"],
     "_sre_utils": [".js", "var $module=(function($B){\n\n    function unicode_iscased(cp){\n        // cp : Unicode code point\n        var letter = String.fromCodePoint(cp)\n        return (letter != letter.toLowerCase() ||\n            letter != letter.toUpperCase())\n    }\n\n    function ascii_iscased(cp){\n        if(cp > 255){return false}\n        return unicode_iscased(cp)\n    }\n\n    function unicode_tolower(cp){\n        var letter = String.fromCodePoint(cp),\n            lower = letter.toLowerCase()\n        return lower.charCodeAt(0)\n    }\n\n    function ascii_tolower(cp){\n        return unicode_tolower(cp)\n    }\n\nreturn {\n    unicode_iscased: unicode_iscased,\n    ascii_iscased: ascii_iscased,\n    unicode_tolower: unicode_tolower,\n    ascii_tolower: ascii_tolower\n}\n\n}\n\n)(__BRYTHON__)"],
     "_string": [".js", "var $module=(function($B){\n\nvar _b_ = $B.builtins\n\nfunction parts(format_string){\n    var result = [],\n        _parts = $B.split_format(format_string) // defined in py_string.js\n    for(var i = 0; i < _parts.length; i+= 2){\n        result.push({pre: _parts[i], fmt: _parts[i + 1]})\n    }\n    return result\n}\n\nfunction Tuple(){\n    var args = []\n    for(var i=0, len=arguments.length; i < len; i++){\n        args.push(arguments[i])\n    }\n    return _b_.tuple.$factory(args)\n}\n\nreturn{\n\n    formatter_field_name_split: function(fieldname){\n        // Split the argument as a field name\n        var parsed = $B.parse_format(fieldname),\n            first = parsed.name,\n            rest = []\n        if(first.match(/\\d+/)){first = parseInt(first)}\n        parsed.name_ext.forEach(function(ext){\n            if(ext.startsWith(\"[\")){\n                var item = ext.substr(1, ext.length - 2)\n                if(item.match(/\\d+/)){\n                    rest.push(Tuple(false, parseInt(item)))\n                }else{\n                    rest.push(Tuple(false, item))\n                }\n            }else{\n                rest.push(Tuple(true, ext.substr(1)))\n            }\n        })\n        return Tuple(first, _b_.iter(rest))\n    },\n    formatter_parser: function(format_string){\n        // Parse the argument as a format string\n\n        if(! _b_.isinstance(format_string, _b_.str)){\n            throw _b_.ValueError.$factory(\"Invalid format string type: \" +\n                $B.class_name(format_string))\n        }\n\n        var result  = []\n        parts(format_string).forEach(function(item){\n            var pre = item.pre === undefined ? \"\" : item.pre,\n                fmt = item.fmt\n            if(fmt === undefined){\n               result.push(Tuple(pre, _b_.None, _b_.None, _b_.None))\n            }else if(fmt.string == ''){\n               result.push(Tuple(pre, '', '', _b_.None))\n            }else{\n               result.push(Tuple(pre,\n                   fmt.raw_name + fmt.name_ext.join(\"\"),\n                   fmt.raw_spec,\n                   fmt.conv || _b_.None))\n           }\n        })\n        return result\n    }\n}\n})(__BRYTHON__)"],
-    "_strptime": [".js", "var _b_ = __BRYTHON__.builtins\n\nvar $module = (function($B){\n    return {\n        _strptime_datetime: function(cls, s, fmt){\n            var pos_s = 0,\n                pos_fmt = 0,\n                dt = {}\n            function error(){\n                throw Error(\"no match \" + pos_s + \" \" + s.charAt(pos_s) + \" \"+\n                    pos_fmt + \" \" + fmt.charAt(pos_fmt))\n            }\n\n            var locale = __BRYTHON__.locale,\n                shortdays = [],\n                longdays = [],\n                conv_func = locale == \"C\" ?\n                    function(d){return d.toDateString()} :\n                    function(d, options){\n                        return d.toLocaleDateString(locale, options)\n                    }\n\n            for(var day = 16; day < 23; day++){\n                var d = new Date(Date.UTC(2012, 11, day, 3, 0, 0))\n                shortdays.push(conv_func(d, {weekday: 'short'}))\n                longdays.push(conv_func(d, {weekday: 'long'}))\n            }\n\n            var shortmonths = [],\n                longmonths = []\n\n            for(var month = 0; month < 12; month++){\n                var d = new Date(Date.UTC(2012, month, 1, 3, 0, 0))\n                shortmonths.push(conv_func(d, {month: 'short'}))\n                longmonths.push(conv_func(d, {month: 'long'}))\n            }\n\n            var shortdays_re = new RegExp(shortdays.join(\"|\").replace(\".\", \"\\\\.\")),\n                longdays_re = new RegExp(longdays.join(\"|\")),\n                shortmonths_re = new RegExp(shortmonths.join(\"|\").replace(\".\", \"\\\\.\")),\n                longmonths_re = new RegExp(longmonths.join(\"|\"))\n\n            var regexps = {\n                d: [\"day\", new RegExp(\"0[1-9]|[123][0-9]\")],\n                f: [\"microsecond\", new RegExp(\"(\\\\d{1,6})\")],\n                H: [\"hour\", new RegExp(\"[01][0-9]|2[0-3]|\\\\d\")],\n                I: [\"hour\", new RegExp(\"0[0-9]|1[0-2]\")],\n                m: [\"month\", new RegExp(\"0[1-9]|1[012]\")],\n                M: [\"minute\", new RegExp(\"[0-5][0-9]\")],\n                S: [\"second\", new RegExp(\"([1-5]\\\\d)|(0?\\\\d)\")],\n                y: [\"year\", new RegExp(\"0{0,2}\\\\d{2}\")],\n                Y: [\"year\", new RegExp(\"\\\\d{4}\")],\n                z: [\"tzinfo\", new RegExp(\"Z\")]\n            }\n\n            while(pos_fmt < fmt.length){\n                var car = fmt.charAt(pos_fmt)\n                if(car == \"%\"){\n                    var spec = fmt.charAt(pos_fmt + 1),\n                        regexp = regexps[spec]\n                    if(regexp !== undefined){\n                        var re = regexp[1],\n                            attr = regexp[0],\n                            res = re.exec(s.substr(pos_s))\n                        if(res === null){\n                            error()\n                        }else{\n                            if(dt[attr] !== undefined){\n                                throw Error(attr + \" is defined more than once\")\n                            }else{\n                                dt[attr] = parseInt(res[0])\n                                if(attr == \"microsecond\"){\n                                    while(dt[attr] < 100000){\n                                        dt[attr] *= 10\n                                    }\n                                }else if(attr == \"tzinfo\"){\n                                    // Only value supported for the moment : Z\n                                    // (UTC)\n                                    var dt_module = $B.imported[cls.__module__]\n                                    dt.tzinfo = dt_module.timezone.utc\n                                }\n                                pos_fmt += 2\n                                pos_s += res[0].length\n                            }\n                        }\n                    }else if(spec == \"a\" || spec == \"A\"){\n                        // Locale's abbreviated (a) or full (A) weekday name\n                        var attr = \"weekday\",\n                            re = spec == \"a\" ? shortdays_re : longdays_re,\n                            t = spec == \"a\" ? shortdays : longdays\n                            res = re.exec(s.substr(pos_s))\n                        if(res === null){\n                            error()\n                        }else{\n                            var match = res[0],\n                                ix = t.indexOf(match)\n                        }\n                        if(dt.weekday !== undefined){\n                            throw Error(attr + \" is defined more than once\")\n                        }else{\n                            dt.weekday = ix\n                        }\n                        pos_fmt += 2\n                        pos_s += match.length\n                    }else if(spec == \"b\" || spec == \"B\"){\n                        // Locales's abbreviated (b) or full (B) month\n                        var attr = \"month\",\n                            re = spec == \"b\" ? shortmonths_re : longmonths_re,\n                            t = spec == \"b\" ? shortmonths : longmonths,\n                            res = re.exec(s.substr(pos_s))\n                        if(res === null){\n                            error()\n                        }else{\n                            var match = res[0],\n                                ix = t.indexOf(match)\n                        }\n                        if(dt.month !== undefined){\n                            throw Error(attr + \" is defined more than once\")\n                        }else{\n                            dt.month = ix + 1\n                        }\n                        pos_fmt += 2\n                        pos_s += match.length\n                    }else if(spec == \"c\"){\n                        // Locale's appropriate date and time representation\n                        var fmt1 = fmt.substr(0, pos_fmt - 1) + _locale_c_format() +\n                            fmt.substr(pos_fmt + 2)\n                        fmt = fmt1\n                    }else if(spec == \"%\"){\n                        if(s.charAt(pos_s) == \"%\"){\n                            pos_fmt++\n                            pos_s++\n                        }else{\n                            error()\n                        }\n                    }else{\n                        pos_fmt++\n                    }\n                }else{\n                    if(car == s.charAt(pos_s)){\n                        pos_fmt++\n                        pos_s++\n                    }else{\n                        error()\n                    }\n                }\n            }\n            return $B.$call(cls)(dt.year, dt.month, dt.day,\n                dt.hour || 0, dt.minute || 0, dt.second || 0,\n                dt.microsecond || 0, dt.tzinfo || _b_.None)\n        }\n    }\n})(__BRYTHON__)\n"],
-    "_svg": [".js", "// creation of an HTML element\nvar $module = (function($B){\n\nvar _b_ = $B.builtins\nvar TagSum = $B.TagSum // defined in py_dom.js\n\nvar $s=[]\nfor(var $b in _b_) $s.push('var ' + $b +' = _b_[\"' + $b + '\"]')\neval($s.join(';'))\n\nvar $svgNS = \"http://www.w3.org/2000/svg\"\nvar $xlinkNS = \"http://www.w3.org/1999/xlink\"\n\nfunction makeTagDict(tagName){\n    // return the dictionary for the class associated with tagName\n    var dict = $B.make_class(tagName)\n\n    dict.__init__ = function(){\n        var $ns = $B.args('__init__', 1, {self: null}, ['self'],\n            arguments, {}, 'args', 'kw'),\n            self = $ns['self'],\n            args = $ns['args']\n        if(args.length == 1){\n            var first = args[0]\n            if(isinstance(first, [str, int, float])){\n                self.appendChild(document.createTextNode(str.$factory(first)))\n            }else if(first.__class__ === TagSum){\n                for(var i = 0, len = first.children.length; i < len; i++){\n                    self.appendChild(first.children[i].elt)\n                }\n            }else{ // argument is another DOMNode instance\n                try{self.appendChild(first.elt)}\n                catch(err){throw ValueError.$factory('wrong element ' + first)}\n            }\n        }\n\n        // attributes\n        var items = _b_.list.$factory(_b_.dict.items($ns['kw']))\n        for(var i = 0, len = items.length; i < len; i++){\n            // keyword arguments\n            var arg = items[i][0],\n                value = items[i][1]\n            if(arg.toLowerCase().substr(0,2) == \"on\"){\n                // Event binding passed as argument \"onclick\", \"onfocus\"...\n                // Better use method bind of DOMNode objects\n                var js = '$B.DOMNode.bind(self,\"' +\n                    arg.toLowerCase().substr(2)\n                eval(js+'\",function(){'+value+'})')\n            }else if(arg.toLowerCase() == \"style\"){\n                $B.DOMNode.set_style(self,value)\n            }else if(arg.toLowerCase().indexOf(\"href\") !== -1){ // xlink:href\n                self.setAttributeNS( \"http://www.w3.org/1999/xlink\",\n                    \"href\",value)\n            }else{\n                if(value !== false){\n                    // option.selected=false sets it to true :-)\n                    try{\n                        arg = arg.replace('_', '-')\n                        self.setAttributeNS(null, arg, value)\n                    }catch(err){\n                        throw ValueError.$factory(\"can't set attribute \" + arg)\n                    }\n                }\n            }\n        }\n    }\n\n    dict.__mro__ = [$B.DOMNode, $B.builtins.object]\n\n    dict.__new__ = function(cls){\n        var res = $B.DOMNode.$factory(document.createElementNS($svgNS, tagName))\n        res.__class__ = cls\n        return res\n    }\n\n    dict.$factory = function(){\n        var res = $B.DOMNode.$factory(\n            document.createElementNS($svgNS, tagName))\n        res.__class__ = dict\n        // apply __init__\n        dict.__init__(res, ...arguments)\n        return res\n    }\n\n    $B.set_func_names(dict, \"browser.svg\")\n\n    return dict\n}\n\n\n// SVG\nvar $svg_tags = ['a',\n'altGlyph',\n'altGlyphDef',\n'altGlyphItem',\n'animate',\n'animateColor',\n'animateMotion',\n'animateTransform',\n'circle',\n'clipPath',\n'color_profile', // instead of color-profile\n'cursor',\n'defs',\n'desc',\n'ellipse',\n'feBlend',\n'foreignObject', //patch to enable foreign objects\n'g',\n'image',\n'line',\n'linearGradient',\n'marker',\n'mask',\n'path',\n'pattern',\n'polygon',\n'polyline',\n'radialGradient',\n'rect',\n'set',\n'stop',\n'svg',\n'text',\n'tref',\n'tspan',\n'use']\n\n// create classes\nvar obj = new Object()\nvar dicts = {}\nfor(var i = 0, len = $svg_tags.length; i < len; i++){\n    var tag = $svg_tags[i]\n    obj[tag] = makeTagDict(tag)\n}\n\nreturn obj\n})(__BRYTHON__)\n"],
+    "_strptime": [".js", "var _b_ = __BRYTHON__.builtins\n\nvar $module = (function($B){\n    return {\n        _strptime_datetime: function(cls, s, fmt){\n            var pos_s = 0,\n                pos_fmt = 0,\n                dt = {}\n            function error(){\n                throw Error(\"no match \" + pos_s + \" \" + s.charAt(pos_s) + \" \"+\n                    pos_fmt + \" \" + fmt.charAt(pos_fmt))\n            }\n\n            var locale = __BRYTHON__.locale,\n                shortdays = [],\n                longdays = [],\n                conv_func = locale == \"C\" ?\n                    function(d, options){\n                        return d.toLocaleDateString('en-EN', options)\n                    } :\n                    function(d, options){\n                        return d.toLocaleDateString(locale, options)\n                    }\n\n            for(var day = 16; day < 23; day++){\n                var d = new Date(Date.UTC(2012, 11, day, 3, 0, 0))\n                shortdays.push(conv_func(d, {weekday: 'short'}))\n                longdays.push(conv_func(d, {weekday: 'long'}))\n            }\n\n            var shortmonths = [],\n                longmonths = []\n\n            for(var month = 0; month < 12; month++){\n                var d = new Date(Date.UTC(2012, month, 1, 3, 0, 0))\n                shortmonths.push(conv_func(d, {month: 'short'}))\n                longmonths.push(conv_func(d, {month: 'long'}))\n            }\n\n            var shortdays_re = new RegExp(shortdays.join(\"|\").replace(\".\", \"\\\\.\")),\n                longdays_re = new RegExp(longdays.join(\"|\")),\n                shortmonths_re = new RegExp(shortmonths.join(\"|\").replace(\".\", \"\\\\.\")),\n                longmonths_re = new RegExp(longmonths.join(\"|\"))\n\n            var regexps = {\n                d: [\"day\", new RegExp(\"0[1-9]|[123][0-9]\")],\n                f: [\"microsecond\", new RegExp(\"(\\\\d{1,6})\")],\n                H: [\"hour\", new RegExp(\"[01][0-9]|2[0-3]|\\\\d\")],\n                I: [\"hour\", new RegExp(\"0[0-9]|1[0-2]\")],\n                m: [\"month\", new RegExp(\"0[1-9]|1[012]\")],\n                M: [\"minute\", new RegExp(\"[0-5][0-9]\")],\n                S: [\"second\", new RegExp(\"([1-5]\\\\d)|(0?\\\\d)\")],\n                y: [\"year\", new RegExp(\"0{0,2}\\\\d{2}\")],\n                Y: [\"year\", new RegExp(\"\\\\d{4}\")],\n                z: [\"tzinfo\", new RegExp(\"Z\")]\n            }\n\n            while(pos_fmt < fmt.length){\n                var car = fmt.charAt(pos_fmt)\n                if(car == \"%\"){\n                    var spec = fmt.charAt(pos_fmt + 1),\n                        regexp = regexps[spec]\n                    if(regexp !== undefined){\n                        var re = regexp[1],\n                            attr = regexp[0],\n                            res = re.exec(s.substr(pos_s))\n                        if(res === null){\n                            error()\n                        }else{\n                            if(dt[attr] !== undefined){\n                                throw Error(attr + \" is defined more than once\")\n                            }else{\n                                dt[attr] = parseInt(res[0])\n                                if(attr == \"microsecond\"){\n                                    while(dt[attr] < 100000){\n                                        dt[attr] *= 10\n                                    }\n                                }else if(attr == \"tzinfo\"){\n                                    // Only value supported for the moment : Z\n                                    // (UTC)\n                                    var dt_module = $B.imported[cls.__module__]\n                                    dt.tzinfo = dt_module.timezone.utc\n                                }\n                                pos_fmt += 2\n                                pos_s += res[0].length\n                            }\n                        }\n                    }else if(spec == \"a\" || spec == \"A\"){\n                        // Locale's abbreviated (a) or full (A) weekday name\n                        var attr = \"weekday\",\n                            re = spec == \"a\" ? shortdays_re : longdays_re,\n                            t = spec == \"a\" ? shortdays : longdays\n                            res = re.exec(s.substr(pos_s))\n                        if(res === null){\n                            console.log('error', re, 'string', s.substr(pos_s), 'fmt', fmt)\n                            error()\n                        }else{\n                            var match = res[0],\n                                ix = t.indexOf(match)\n                        }\n                        if(dt.weekday !== undefined){\n                            throw Error(attr + \" is defined more than once\")\n                        }else{\n                            dt.weekday = ix\n                        }\n                        pos_fmt += 2\n                        pos_s += match.length\n                    }else if(spec == \"b\" || spec == \"B\"){\n                        // Locales's abbreviated (b) or full (B) month\n                        var attr = \"month\",\n                            re = spec == \"b\" ? shortmonths_re : longmonths_re,\n                            t = spec == \"b\" ? shortmonths : longmonths,\n                            res = re.exec(s.substr(pos_s))\n                        if(res === null){\n                            error()\n                        }else{\n                            var match = res[0],\n                                ix = t.indexOf(match)\n                        }\n                        if(dt.month !== undefined){\n                            throw Error(attr + \" is defined more than once\")\n                        }else{\n                            dt.month = ix + 1\n                        }\n                        pos_fmt += 2\n                        pos_s += match.length\n                    }else if(spec == \"c\"){\n                        // Locale's appropriate date and time representation\n                        var fmt1 = fmt.substr(0, pos_fmt - 1) + _locale_c_format() +\n                            fmt.substr(pos_fmt + 2)\n                        fmt = fmt1\n                    }else if(spec == \"%\"){\n                        if(s.charAt(pos_s) == \"%\"){\n                            pos_fmt++\n                            pos_s++\n                        }else{\n                            error()\n                        }\n                    }else{\n                        pos_fmt++\n                    }\n                }else{\n                    if(car == s.charAt(pos_s)){\n                        pos_fmt++\n                        pos_s++\n                    }else{\n                        error()\n                    }\n                }\n            }\n            return $B.$call(cls)(dt.year, dt.month, dt.day,\n                dt.hour || 0, dt.minute || 0, dt.second || 0,\n                dt.microsecond || 0, dt.tzinfo || _b_.None)\n        }\n    }\n})(__BRYTHON__)\n"],
+    "_svg": [".js", "// creation of an HTML element\nvar $module = (function($B){\n\nvar _b_ = $B.builtins\nvar TagSum = $B.TagSum // defined in py_dom.js\n\nvar $svgNS = \"http://www.w3.org/2000/svg\"\nvar $xlinkNS = \"http://www.w3.org/1999/xlink\"\n\nfunction makeTagDict(tagName){\n    // return the dictionary for the class associated with tagName\n    var dict = $B.make_class(tagName)\n\n    dict.__init__ = function(){\n        var $ns = $B.args('__init__', 1, {self: null}, ['self'],\n            arguments, {}, 'args', 'kw'),\n            self = $ns['self'],\n            args = $ns['args']\n        if(args.length == 1){\n            var first = args[0]\n            if(_b_.isinstance(first, [_b_.str, _b_.int, _b_.float])){\n                self.appendChild(document.createTextNode(_b_.str.$factory(first)))\n            }else if(first.__class__ === TagSum){\n                for(var i = 0, len = first.children.length; i < len; i++){\n                    self.appendChild(first.children[i].elt)\n                }\n            }else{ // argument is another DOMNode instance\n                try{self.appendChild(first.elt)}\n                catch(err){throw _b_.ValueError.$factory('wrong element ' + first)}\n            }\n        }\n\n        // attributes\n        var items = _b_.list.$factory(_b_.dict.items($ns['kw']))\n        for(var i = 0, len = items.length; i < len; i++){\n            // keyword arguments\n            var arg = items[i][0],\n                value = items[i][1]\n            if(arg.toLowerCase().substr(0,2) == \"on\"){\n                // Event binding passed as argument \"onclick\", \"onfocus\"...\n                // Better use method bind of DOMNode objects\n                var js = '$B.DOMNode.bind(self,\"' +\n                    arg.toLowerCase().substr(2)\n                eval(js+'\",function(){'+value+'})')\n            }else if(arg.toLowerCase() == \"style\"){\n                $B.DOMNode.set_style(self,value)\n            }else if(arg.toLowerCase().indexOf(\"href\") !== -1){ // xlink:href\n                self.setAttributeNS( \"http://www.w3.org/1999/xlink\",\n                    \"href\",value)\n            }else{\n                if(value !== false){\n                    // option.selected=false sets it to true :-)\n                    try{\n                        arg = arg.replace('_', '-')\n                        self.setAttributeNS(null, arg, value)\n                    }catch(err){\n                        throw _b_.ValueError.$factory(\"can't set attribute \" + arg)\n                    }\n                }\n            }\n        }\n    }\n\n    dict.__mro__ = [$B.DOMNode, $B.builtins.object]\n\n    dict.__new__ = function(cls){\n        var res = $B.DOMNode.$factory(document.createElementNS($svgNS, tagName))\n        res.__class__ = cls\n        return res\n    }\n\n    dict.$factory = function(){\n        var res = $B.DOMNode.$factory(\n            document.createElementNS($svgNS, tagName))\n        res.__class__ = dict\n        // apply __init__\n        dict.__init__(res, ...arguments)\n        return res\n    }\n\n    $B.set_func_names(dict, \"browser.svg\")\n\n    return dict\n}\n\n\n// SVG\nvar $svg_tags = ['a',\n'altGlyph',\n'altGlyphDef',\n'altGlyphItem',\n'animate',\n'animateColor',\n'animateMotion',\n'animateTransform',\n'circle',\n'clipPath',\n'color_profile', // instead of color-profile\n'cursor',\n'defs',\n'desc',\n'ellipse',\n'feBlend',\n'foreignObject', //patch to enable foreign objects\n'g',\n'image',\n'line',\n'linearGradient',\n'marker',\n'mask',\n'path',\n'pattern',\n'polygon',\n'polyline',\n'radialGradient',\n'rect',\n'set',\n'stop',\n'svg',\n'text',\n'tref',\n'tspan',\n'use']\n\n// create classes\nvar obj = new Object()\nvar dicts = {}\nfor(var i = 0, len = $svg_tags.length; i < len; i++){\n    var tag = $svg_tags[i]\n    obj[tag] = makeTagDict(tag)\n}\n\nreturn obj\n})(__BRYTHON__)\n"],
     "_webcomponent": [".js", "// module for Web Components\nvar $module = (function($B){\n\nvar _b_ = $B.builtins\n\nfunction define(tag_name, cls){\n    var $ = $B.args(\"define\", 2, {tag_name: null, cls: null},\n            [\"tag_name\", \"cls\"], arguments, {}, null, null),\n        tag_name = $.tag_name,\n        cls = $.cls\n    if(typeof tag_name != \"string\"){\n        throw _b_.TypeError.$factory(\"first argument of define() \" +\n            \"must be a string, not '\" + $B.class_name(tag_name) + \"'\")\n    }else if(tag_name.indexOf(\"-\") == -1){\n        throw _b_.ValueError.$factory(\"custom tag name must \" +\n            \"contain a hyphen (-)\")\n    }\n    if(!_b_.isinstance(cls, _b_.type)){\n        throw _b_.TypeError.$factory(\"second argument of define() \" +\n            \"must be a class, not '\" + $B.class_name(tag_name) + \"'\")\n    }\n\n    // Create the Javascript class used for the component. It must have\n    // the same name as the Python class\n    var src = String.raw`var WebComponent = class extends HTMLElement {\n      constructor(){\n        // Always call super first in constructor\n        super()\n        var init = $B.$getattr(cls, \"__init__\", _b_.None)\n        if(init !== _b_.None){\n            try{\n                var _self = $B.DOMNode.$factory(this),\n                    attrs_before_init = []\n                for(var i = 0, len = _self.attributes.length; i < len; i++){\n                    attrs_before_init.push(_self.attributes.item(i))\n                }\n                _self.__class__ = cls\n                $B.$call(init)(_self)\n                if(WebComponent.initialized){\n                    // Check that init() did not introduce new attributes,\n                    // which is illegal\n                    // cf. https://html.spec.whatwg.org/multipage/custom-elements.html#custom-element-conformance\n                    for(var i = 0, len = _self.attributes.length; i < len; i++){\n                        var item = _self.attributes.item(i)\n                        if(attrs_before_init.indexOf(item) == -1){\n                            throw _b_.TypeError.$factory(\"Custom element \" +\n                                \"must not create attributes, found: \" + \n                                item.name + '=\"' + item.value + '\"')\n                        }\n                    }\n                }\n            }catch(err){\n                $B.handle_error(err)\n            }\n        }\n      }\n        static get observedAttributes(){\n            try{\n                var obs_attr = $B.$getattr(cls, \"observedAttributes\")\n                return $B.$call(obs_attr)(cls)\n            }catch(err){\n                if(! $B.is_exc(err, [_b_.AttributeError])){\n                    throw err\n                }\n                return []\n            }\n        }\n    }\n    `\n    var name = cls.$infos.__name__\n    eval(src.replace(/WebComponent/g, name))\n    var webcomp = eval(name) // JS class for component\n    webcomp.$cls = cls\n\n    // Override __getattribute__ to handle DOMNode attributes such as\n    // attachShadow\n    cls.__getattribute__ = function(self, attr){\n        try{\n            return $B.DOMNode.__getattribute__(self, attr)\n        }catch(err){\n            if(err.__class__ === _b_.AttributeError){\n                var ga = $B.$getattr(cls, \"__getattribute__\")\n                return ga(self, attr)\n            }else{\n                throw err\n            }\n        }\n    }\n\n    var mro = [cls].concat(cls.__mro__)\n    for(var i = 0, len = mro.length - 1; i < len; i++){\n        var pcls = mro[i]\n        for(var key in pcls){\n            if(webcomp.prototype[key] === undefined &&\n                    typeof pcls[key] == \"function\"){\n                webcomp.prototype[key] = (function(attr, klass){\n                    return function(){\n                        return $B.pyobj2jsobj(klass[attr]).call(null,\n                            $B.DOMNode.$factory(this), ...arguments)\n                    }\n                })(key, pcls)\n            }\n        }\n    }\n\n    // define WebComp as the class to use for the specified tag name\n    customElements.define(tag_name, webcomp)\n    webcomp.initialized = true\n}\n\nfunction get(name){\n    var ce = customElements.get(name)\n    if(ce && ce.$cls){return ce.$cls}\n    return _b_.None\n}\n\nreturn {\n    define: define,\n    get: get\n}\n\n})(__BRYTHON__)"],
     "_webworker": [".js", "// Web Worker implementation\n\nvar $module = (function($B){\n\nvar _b_ = $B.builtins\n\nvar brython_scripts = ['brython', 'brython_stdlib']\n\nvar wclass = $B.make_class(\"Worker\",\n    function(worker){\n        var res = worker\n        res.send = res.postMessage\n        return res\n    }\n)\nwclass.__mro__ = [$B.JSObj, _b_.object]\n\n$B.set_func_names(wclass, \"browser.worker\")\n\nvar _Worker = $B.make_class(\"Worker\", function(id, onmessage, onerror){\n    var $ = $B.args(\"__init__\", 3, {id: null, onmessage: null, onerror: null},\n            ['id', 'onmessage', 'onerror'], arguments,\n            {onmessage: _b_.None, onerror: _b_.None}, null, null),\n        id = $.id,\n        src = $B.webworkers[id]\n        if(src === undefined){\n            throw _b_.KeyError.$factory(id)\n        }\n        var script_id = \"worker\" + $B.UUID(),\n            js = __BRYTHON__.imported.javascript.py2js(src,\n                script_id),\n            header = 'var $locals_' + script_id +' = {}\\n';\n        brython_scripts.forEach(function(script){\n            var url = $B.brython_path + script + \".js?\" +\n                (new Date()).getTime()\n            header += 'importScripts(\"' + url + '\")\\n'\n        })\n        // restore brython_path\n        header += '__BRYTHON__.brython_path = \"' + $B.brython_path +\n            '\"\\n'\n        // restore path for imports (cf. issue #1305)\n        header += '__BRYTHON__.path = \"' + $B.path +'\".split(\",\")\\n'\n        // Call brython() to initialize internal Brython values\n        header += 'brython(1)\\n'\n        js = header + js\n        var blob = new Blob([js], {type: \"application/js\"}),\n            url = URL.createObjectURL(blob),\n            w = new Worker(url),\n            res = wclass.$factory(w)\n        return res\n})\n\nreturn {\n    Worker: _Worker\n}\n\n})(__BRYTHON__)\n"],
     "_zlib_utils": [".js", "\nfunction rfind(buf, seq){\n    var buflen = buf.length,\n        len = seq.length\n    for(var i = buflen - len; i >= 0; i--){\n        var chunk = buf.slice(i, i + len),\n            found = true\n        for(var j = 0; j < len; j++){\n            if(chunk[j] != seq[j]){\n                found = false\n                break\n            }\n        }\n        if(found){return i}\n    }\n    return -1\n}\n\n\nvar c;\nvar crcTable = [];\nfor(var n =0; n < 256; n++){\n    c = n;\n    for(var k =0; k < 8; k++){\n        c = ((c&1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));\n    }\n    crcTable[n] = c;\n}\n\nvar $module = (function($B){\n\n    return {\n        crc32: function(str) {\n            var crc = 0 ^ (-1);\n        \n            for (var i = 0; i < str.length; i++ ) {\n                crc = (crc >>> 8) ^ crcTable[(crc ^ str.charCodeAt(i)) & 0xFF];\n            }\n        \n            return (crc ^ (-1)) >>> 0;\n        },\n\n        lz_generator: function(text, size, min_len){\n            /*\n            Returns a list of items based on the LZ algorithm, using the\n            specified window size and a minimum match length.\n            The items are a tuple (length, distance) if a match has been\n            found, and a byte otherwise.\n            */\n            // 'text' is an instance of Python 'bytes' class, the actual\n            // bytes are in text.source\n            text = text.source\n            if(min_len === undefined){\n                min_len = 3\n            }\n            var pos = 0, // position in text\n                items = [] // returned items\n            while(pos < text.length){\n                sequence = text.slice(pos, pos + min_len)\n                if(sequence.length < 3){\n                    for(var i = pos; i < text.length; i++){\n                        items.push(text[i])\n                    }\n                    break\n                }\n                // Search the sequence in the 'size' previous bytes\n                buf = text.slice(pos - size, pos)\n                buf_pos = rfind(buf, sequence)\n                if(buf_pos > -1){\n                    // Match of length 3 found; search a longer one\n                    var len = 1\n                    while(len < 259 &&\n                            buf_pos + len < buf.length &&\n                            pos + len < text.length &&\n                            text[pos + len] == buf[buf_pos + len]){\n                        len += 1\n                    }\n                    match = text.slice(pos, pos + len)\n                    // \"Lazy matching\": search longer match starting at next\n                    // position\n                    longer_match = false\n                    if(pos + len < text.length - 2){\n                        match2 = text.slice(pos + 1, pos + len + 2)\n                        longer_buf_pos = rfind(buf, match2)\n                        if(longer_buf_pos > -1){\n                            // found longer match : emit current byte as\n                            // literal and move 1 byte forward\n                            longer_match = true\n                            char = text[pos]\n                            items.push(char)\n                            pos += 1\n                        }\n                    }\n                    if(! longer_match){\n                        distance = buf.length - buf_pos\n                        items.push($B.fast_tuple([len, distance]))\n                        if(pos + len == text.length){\n                            break\n                        }else{\n                            pos += len\n                            items.push(text[pos])\n                            pos += 1\n                        }\n                    }\n                }else{\n                    char = text[pos]\n                    items.push(char)\n                    pos += 1\n                }\n            }\n            return items\n        }\n    }\n})(__BRYTHON__)"],
     "crypto_js": [".py", "", [], 1],
     "crypto_js.rollups": [".py", "", [], 1],
     "crypto_js.rollups.md5": [".js", "/*\nCryptoJS v3.1.2\ncode.google.com/p/crypto-js\n(c) 2009-2013 by Jeff Mott. All rights reserved.\ncode.google.com/p/crypto-js/wiki/License\n*/\nvar CryptoJS=CryptoJS||function(s,p){var m={},l=m.lib={},n=function(){},r=l.Base={extend:function(b){n.prototype=this;var h=new n;b&&h.mixIn(b);h.hasOwnProperty(\"init\")||(h.init=function(){h.$super.init.apply(this,arguments)});h.init.prototype=h;h.$super=this;return h},create:function(){var b=this.extend();b.init.apply(b,arguments);return b},init:function(){},mixIn:function(b){for(var h in b)b.hasOwnProperty(h)&&(this[h]=b[h]);b.hasOwnProperty(\"toString\")&&(this.toString=b.toString)},clone:function(){return this.init.prototype.extend(this)}},\nq=l.WordArray=r.extend({init:function(b,h){b=this.words=b||[];this.sigBytes=h!=p?h:4*b.length},toString:function(b){return(b||t).stringify(this)},concat:function(b){var h=this.words,a=b.words,j=this.sigBytes;b=b.sigBytes;this.clamp();if(j%4)for(var g=0;g<b;g++)h[j+g>>>2]|=(a[g>>>2]>>>24-8*(g%4)&255)<<24-8*((j+g)%4);else if(65535<a.length)for(g=0;g<b;g+=4)h[j+g>>>2]=a[g>>>2];else h.push.apply(h,a);this.sigBytes+=b;return this},clamp:function(){var b=this.words,h=this.sigBytes;b[h>>>2]&=4294967295<<\n32-8*(h%4);b.length=s.ceil(h/4)},clone:function(){var b=r.clone.call(this);b.words=this.words.slice(0);return b},random:function(b){for(var h=[],a=0;a<b;a+=4)h.push(4294967296*s.random()|0);return new q.init(h,b)}}),v=m.enc={},t=v.Hex={stringify:function(b){var a=b.words;b=b.sigBytes;for(var g=[],j=0;j<b;j++){var k=a[j>>>2]>>>24-8*(j%4)&255;g.push((k>>>4).toString(16));g.push((k&15).toString(16))}return g.join(\"\")},parse:function(b){for(var a=b.length,g=[],j=0;j<a;j+=2)g[j>>>3]|=parseInt(b.substr(j,\n2),16)<<24-4*(j%8);return new q.init(g,a/2)}},a=v.Latin1={stringify:function(b){var a=b.words;b=b.sigBytes;for(var g=[],j=0;j<b;j++)g.push(String.fromCharCode(a[j>>>2]>>>24-8*(j%4)&255));return g.join(\"\")},parse:function(b){for(var a=b.length,g=[],j=0;j<a;j++)g[j>>>2]|=(b.charCodeAt(j)&255)<<24-8*(j%4);return new q.init(g,a)}},u=v.Utf8={stringify:function(b){try{return decodeURIComponent(escape(a.stringify(b)))}catch(g){throw Error(\"Malformed UTF-8 data\");}},parse:function(b){return a.parse(unescape(encodeURIComponent(b)))}},\ng=l.BufferedBlockAlgorithm=r.extend({reset:function(){this._data=new q.init;this._nDataBytes=0},_append:function(b){\"string\"==typeof b&&(b=u.parse(b));this._data.concat(b);this._nDataBytes+=b.sigBytes},_process:function(b){var a=this._data,g=a.words,j=a.sigBytes,k=this.blockSize,m=j/(4*k),m=b?s.ceil(m):s.max((m|0)-this._minBufferSize,0);b=m*k;j=s.min(4*b,j);if(b){for(var l=0;l<b;l+=k)this._doProcessBlock(g,l);l=g.splice(0,b);a.sigBytes-=j}return new q.init(l,j)},clone:function(){var b=r.clone.call(this);\nb._data=this._data.clone();return b},_minBufferSize:0});l.Hasher=g.extend({cfg:r.extend(),init:function(b){this.cfg=this.cfg.extend(b);this.reset()},reset:function(){g.reset.call(this);this._doReset()},update:function(b){this._append(b);this._process();return this},finalize:function(b){b&&this._append(b);return this._doFinalize()},blockSize:16,_createHelper:function(b){return function(a,g){return(new b.init(g)).finalize(a)}},_createHmacHelper:function(b){return function(a,g){return(new k.HMAC.init(b,\ng)).finalize(a)}}});var k=m.algo={};return m}(Math);\n(function(s){function p(a,k,b,h,l,j,m){a=a+(k&b|~k&h)+l+m;return(a<<j|a>>>32-j)+k}function m(a,k,b,h,l,j,m){a=a+(k&h|b&~h)+l+m;return(a<<j|a>>>32-j)+k}function l(a,k,b,h,l,j,m){a=a+(k^b^h)+l+m;return(a<<j|a>>>32-j)+k}function n(a,k,b,h,l,j,m){a=a+(b^(k|~h))+l+m;return(a<<j|a>>>32-j)+k}for(var r=CryptoJS,q=r.lib,v=q.WordArray,t=q.Hasher,q=r.algo,a=[],u=0;64>u;u++)a[u]=4294967296*s.abs(s.sin(u+1))|0;q=q.MD5=t.extend({_doReset:function(){this._hash=new v.init([1732584193,4023233417,2562383102,271733878])},\n_doProcessBlock:function(g,k){for(var b=0;16>b;b++){var h=k+b,w=g[h];g[h]=(w<<8|w>>>24)&16711935|(w<<24|w>>>8)&4278255360}var b=this._hash.words,h=g[k+0],w=g[k+1],j=g[k+2],q=g[k+3],r=g[k+4],s=g[k+5],t=g[k+6],u=g[k+7],v=g[k+8],x=g[k+9],y=g[k+10],z=g[k+11],A=g[k+12],B=g[k+13],C=g[k+14],D=g[k+15],c=b[0],d=b[1],e=b[2],f=b[3],c=p(c,d,e,f,h,7,a[0]),f=p(f,c,d,e,w,12,a[1]),e=p(e,f,c,d,j,17,a[2]),d=p(d,e,f,c,q,22,a[3]),c=p(c,d,e,f,r,7,a[4]),f=p(f,c,d,e,s,12,a[5]),e=p(e,f,c,d,t,17,a[6]),d=p(d,e,f,c,u,22,a[7]),\nc=p(c,d,e,f,v,7,a[8]),f=p(f,c,d,e,x,12,a[9]),e=p(e,f,c,d,y,17,a[10]),d=p(d,e,f,c,z,22,a[11]),c=p(c,d,e,f,A,7,a[12]),f=p(f,c,d,e,B,12,a[13]),e=p(e,f,c,d,C,17,a[14]),d=p(d,e,f,c,D,22,a[15]),c=m(c,d,e,f,w,5,a[16]),f=m(f,c,d,e,t,9,a[17]),e=m(e,f,c,d,z,14,a[18]),d=m(d,e,f,c,h,20,a[19]),c=m(c,d,e,f,s,5,a[20]),f=m(f,c,d,e,y,9,a[21]),e=m(e,f,c,d,D,14,a[22]),d=m(d,e,f,c,r,20,a[23]),c=m(c,d,e,f,x,5,a[24]),f=m(f,c,d,e,C,9,a[25]),e=m(e,f,c,d,q,14,a[26]),d=m(d,e,f,c,v,20,a[27]),c=m(c,d,e,f,B,5,a[28]),f=m(f,c,\nd,e,j,9,a[29]),e=m(e,f,c,d,u,14,a[30]),d=m(d,e,f,c,A,20,a[31]),c=l(c,d,e,f,s,4,a[32]),f=l(f,c,d,e,v,11,a[33]),e=l(e,f,c,d,z,16,a[34]),d=l(d,e,f,c,C,23,a[35]),c=l(c,d,e,f,w,4,a[36]),f=l(f,c,d,e,r,11,a[37]),e=l(e,f,c,d,u,16,a[38]),d=l(d,e,f,c,y,23,a[39]),c=l(c,d,e,f,B,4,a[40]),f=l(f,c,d,e,h,11,a[41]),e=l(e,f,c,d,q,16,a[42]),d=l(d,e,f,c,t,23,a[43]),c=l(c,d,e,f,x,4,a[44]),f=l(f,c,d,e,A,11,a[45]),e=l(e,f,c,d,D,16,a[46]),d=l(d,e,f,c,j,23,a[47]),c=n(c,d,e,f,h,6,a[48]),f=n(f,c,d,e,u,10,a[49]),e=n(e,f,c,d,\nC,15,a[50]),d=n(d,e,f,c,s,21,a[51]),c=n(c,d,e,f,A,6,a[52]),f=n(f,c,d,e,q,10,a[53]),e=n(e,f,c,d,y,15,a[54]),d=n(d,e,f,c,w,21,a[55]),c=n(c,d,e,f,v,6,a[56]),f=n(f,c,d,e,D,10,a[57]),e=n(e,f,c,d,t,15,a[58]),d=n(d,e,f,c,B,21,a[59]),c=n(c,d,e,f,r,6,a[60]),f=n(f,c,d,e,z,10,a[61]),e=n(e,f,c,d,j,15,a[62]),d=n(d,e,f,c,x,21,a[63]);b[0]=b[0]+c|0;b[1]=b[1]+d|0;b[2]=b[2]+e|0;b[3]=b[3]+f|0},_doFinalize:function(){var a=this._data,k=a.words,b=8*this._nDataBytes,h=8*a.sigBytes;k[h>>>5]|=128<<24-h%32;var l=s.floor(b/\n4294967296);k[(h+64>>>9<<4)+15]=(l<<8|l>>>24)&16711935|(l<<24|l>>>8)&4278255360;k[(h+64>>>9<<4)+14]=(b<<8|b>>>24)&16711935|(b<<24|b>>>8)&4278255360;a.sigBytes=4*(k.length+1);this._process();a=this._hash;k=a.words;for(b=0;4>b;b++)h=k[b],k[b]=(h<<8|h>>>24)&16711935|(h<<24|h>>>8)&4278255360;return a},clone:function(){var a=t.clone.call(this);a._hash=this._hash.clone();return a}});r.MD5=t._createHelper(q);r.HmacMD5=t._createHmacHelper(q)})(Math);\n"],
     "crypto_js.rollups.sha1": [".js", "/*\nCryptoJS v3.1.2\ncode.google.com/p/crypto-js\n(c) 2009-2013 by Jeff Mott. All rights reserved.\ncode.google.com/p/crypto-js/wiki/License\n*/\nvar CryptoJS=CryptoJS||function(e,m){var p={},j=p.lib={},l=function(){},f=j.Base={extend:function(a){l.prototype=this;var c=new l;a&&c.mixIn(a);c.hasOwnProperty(\"init\")||(c.init=function(){c.$super.init.apply(this,arguments)});c.init.prototype=c;c.$super=this;return c},create:function(){var a=this.extend();a.init.apply(a,arguments);return a},init:function(){},mixIn:function(a){for(var c in a)a.hasOwnProperty(c)&&(this[c]=a[c]);a.hasOwnProperty(\"toString\")&&(this.toString=a.toString)},clone:function(){return this.init.prototype.extend(this)}},\nn=j.WordArray=f.extend({init:function(a,c){a=this.words=a||[];this.sigBytes=c!=m?c:4*a.length},toString:function(a){return(a||h).stringify(this)},concat:function(a){var c=this.words,q=a.words,d=this.sigBytes;a=a.sigBytes;this.clamp();if(d%4)for(var b=0;b<a;b++)c[d+b>>>2]|=(q[b>>>2]>>>24-8*(b%4)&255)<<24-8*((d+b)%4);else if(65535<q.length)for(b=0;b<a;b+=4)c[d+b>>>2]=q[b>>>2];else c.push.apply(c,q);this.sigBytes+=a;return this},clamp:function(){var a=this.words,c=this.sigBytes;a[c>>>2]&=4294967295<<\n32-8*(c%4);a.length=e.ceil(c/4)},clone:function(){var a=f.clone.call(this);a.words=this.words.slice(0);return a},random:function(a){for(var c=[],b=0;b<a;b+=4)c.push(4294967296*e.random()|0);return new n.init(c,a)}}),b=p.enc={},h=b.Hex={stringify:function(a){var c=a.words;a=a.sigBytes;for(var b=[],d=0;d<a;d++){var f=c[d>>>2]>>>24-8*(d%4)&255;b.push((f>>>4).toString(16));b.push((f&15).toString(16))}return b.join(\"\")},parse:function(a){for(var c=a.length,b=[],d=0;d<c;d+=2)b[d>>>3]|=parseInt(a.substr(d,\n2),16)<<24-4*(d%8);return new n.init(b,c/2)}},g=b.Latin1={stringify:function(a){var c=a.words;a=a.sigBytes;for(var b=[],d=0;d<a;d++)b.push(String.fromCharCode(c[d>>>2]>>>24-8*(d%4)&255));return b.join(\"\")},parse:function(a){for(var c=a.length,b=[],d=0;d<c;d++)b[d>>>2]|=(a.charCodeAt(d)&255)<<24-8*(d%4);return new n.init(b,c)}},r=b.Utf8={stringify:function(a){try{return decodeURIComponent(escape(g.stringify(a)))}catch(c){throw Error(\"Malformed UTF-8 data\");}},parse:function(a){return g.parse(unescape(encodeURIComponent(a)))}},\nk=j.BufferedBlockAlgorithm=f.extend({reset:function(){this._data=new n.init;this._nDataBytes=0},_append:function(a){\"string\"==typeof a&&(a=r.parse(a));this._data.concat(a);this._nDataBytes+=a.sigBytes},_process:function(a){var c=this._data,b=c.words,d=c.sigBytes,f=this.blockSize,h=d/(4*f),h=a?e.ceil(h):e.max((h|0)-this._minBufferSize,0);a=h*f;d=e.min(4*a,d);if(a){for(var g=0;g<a;g+=f)this._doProcessBlock(b,g);g=b.splice(0,a);c.sigBytes-=d}return new n.init(g,d)},clone:function(){var a=f.clone.call(this);\na._data=this._data.clone();return a},_minBufferSize:0});j.Hasher=k.extend({cfg:f.extend(),init:function(a){this.cfg=this.cfg.extend(a);this.reset()},reset:function(){k.reset.call(this);this._doReset()},update:function(a){this._append(a);this._process();return this},finalize:function(a){a&&this._append(a);return this._doFinalize()},blockSize:16,_createHelper:function(a){return function(c,b){return(new a.init(b)).finalize(c)}},_createHmacHelper:function(a){return function(b,f){return(new s.HMAC.init(a,\nf)).finalize(b)}}});var s=p.algo={};return p}(Math);\n(function(){var e=CryptoJS,m=e.lib,p=m.WordArray,j=m.Hasher,l=[],m=e.algo.SHA1=j.extend({_doReset:function(){this._hash=new p.init([1732584193,4023233417,2562383102,271733878,3285377520])},_doProcessBlock:function(f,n){for(var b=this._hash.words,h=b[0],g=b[1],e=b[2],k=b[3],j=b[4],a=0;80>a;a++){if(16>a)l[a]=f[n+a]|0;else{var c=l[a-3]^l[a-8]^l[a-14]^l[a-16];l[a]=c<<1|c>>>31}c=(h<<5|h>>>27)+j+l[a];c=20>a?c+((g&e|~g&k)+1518500249):40>a?c+((g^e^k)+1859775393):60>a?c+((g&e|g&k|e&k)-1894007588):c+((g^e^\nk)-899497514);j=k;k=e;e=g<<30|g>>>2;g=h;h=c}b[0]=b[0]+h|0;b[1]=b[1]+g|0;b[2]=b[2]+e|0;b[3]=b[3]+k|0;b[4]=b[4]+j|0},_doFinalize:function(){var f=this._data,e=f.words,b=8*this._nDataBytes,h=8*f.sigBytes;e[h>>>5]|=128<<24-h%32;e[(h+64>>>9<<4)+14]=Math.floor(b/4294967296);e[(h+64>>>9<<4)+15]=b;f.sigBytes=4*e.length;this._process();return this._hash},clone:function(){var e=j.clone.call(this);e._hash=this._hash.clone();return e}});e.SHA1=j._createHelper(m);e.HmacSHA1=j._createHmacHelper(m)})();\n"],
     "crypto_js.rollups.sha224": [".js", "/*\nCryptoJS v3.1.2\ncode.google.com/p/crypto-js\n(c) 2009-2013 by Jeff Mott. All rights reserved.\ncode.google.com/p/crypto-js/wiki/License\n*/\nvar CryptoJS=CryptoJS||function(g,l){var f={},k=f.lib={},h=function(){},m=k.Base={extend:function(a){h.prototype=this;var c=new h;a&&c.mixIn(a);c.hasOwnProperty(\"init\")||(c.init=function(){c.$super.init.apply(this,arguments)});c.init.prototype=c;c.$super=this;return c},create:function(){var a=this.extend();a.init.apply(a,arguments);return a},init:function(){},mixIn:function(a){for(var c in a)a.hasOwnProperty(c)&&(this[c]=a[c]);a.hasOwnProperty(\"toString\")&&(this.toString=a.toString)},clone:function(){return this.init.prototype.extend(this)}},\nq=k.WordArray=m.extend({init:function(a,c){a=this.words=a||[];this.sigBytes=c!=l?c:4*a.length},toString:function(a){return(a||s).stringify(this)},concat:function(a){var c=this.words,d=a.words,b=this.sigBytes;a=a.sigBytes;this.clamp();if(b%4)for(var e=0;e<a;e++)c[b+e>>>2]|=(d[e>>>2]>>>24-8*(e%4)&255)<<24-8*((b+e)%4);else if(65535<d.length)for(e=0;e<a;e+=4)c[b+e>>>2]=d[e>>>2];else c.push.apply(c,d);this.sigBytes+=a;return this},clamp:function(){var a=this.words,c=this.sigBytes;a[c>>>2]&=4294967295<<\n32-8*(c%4);a.length=g.ceil(c/4)},clone:function(){var a=m.clone.call(this);a.words=this.words.slice(0);return a},random:function(a){for(var c=[],d=0;d<a;d+=4)c.push(4294967296*g.random()|0);return new q.init(c,a)}}),t=f.enc={},s=t.Hex={stringify:function(a){var c=a.words;a=a.sigBytes;for(var d=[],b=0;b<a;b++){var e=c[b>>>2]>>>24-8*(b%4)&255;d.push((e>>>4).toString(16));d.push((e&15).toString(16))}return d.join(\"\")},parse:function(a){for(var c=a.length,d=[],b=0;b<c;b+=2)d[b>>>3]|=parseInt(a.substr(b,\n2),16)<<24-4*(b%8);return new q.init(d,c/2)}},n=t.Latin1={stringify:function(a){var c=a.words;a=a.sigBytes;for(var d=[],b=0;b<a;b++)d.push(String.fromCharCode(c[b>>>2]>>>24-8*(b%4)&255));return d.join(\"\")},parse:function(a){for(var c=a.length,d=[],b=0;b<c;b++)d[b>>>2]|=(a.charCodeAt(b)&255)<<24-8*(b%4);return new q.init(d,c)}},j=t.Utf8={stringify:function(a){try{return decodeURIComponent(escape(n.stringify(a)))}catch(c){throw Error(\"Malformed UTF-8 data\");}},parse:function(a){return n.parse(unescape(encodeURIComponent(a)))}},\nw=k.BufferedBlockAlgorithm=m.extend({reset:function(){this._data=new q.init;this._nDataBytes=0},_append:function(a){\"string\"==typeof a&&(a=j.parse(a));this._data.concat(a);this._nDataBytes+=a.sigBytes},_process:function(a){var c=this._data,d=c.words,b=c.sigBytes,e=this.blockSize,f=b/(4*e),f=a?g.ceil(f):g.max((f|0)-this._minBufferSize,0);a=f*e;b=g.min(4*a,b);if(a){for(var u=0;u<a;u+=e)this._doProcessBlock(d,u);u=d.splice(0,a);c.sigBytes-=b}return new q.init(u,b)},clone:function(){var a=m.clone.call(this);\na._data=this._data.clone();return a},_minBufferSize:0});k.Hasher=w.extend({cfg:m.extend(),init:function(a){this.cfg=this.cfg.extend(a);this.reset()},reset:function(){w.reset.call(this);this._doReset()},update:function(a){this._append(a);this._process();return this},finalize:function(a){a&&this._append(a);return this._doFinalize()},blockSize:16,_createHelper:function(a){return function(c,d){return(new a.init(d)).finalize(c)}},_createHmacHelper:function(a){return function(c,d){return(new v.HMAC.init(a,\nd)).finalize(c)}}});var v=f.algo={};return f}(Math);\n(function(g){for(var l=CryptoJS,f=l.lib,k=f.WordArray,h=f.Hasher,f=l.algo,m=[],q=[],t=function(a){return 4294967296*(a-(a|0))|0},s=2,n=0;64>n;){var j;a:{j=s;for(var w=g.sqrt(j),v=2;v<=w;v++)if(!(j%v)){j=!1;break a}j=!0}j&&(8>n&&(m[n]=t(g.pow(s,0.5))),q[n]=t(g.pow(s,1/3)),n++);s++}var a=[],f=f.SHA256=h.extend({_doReset:function(){this._hash=new k.init(m.slice(0))},_doProcessBlock:function(c,d){for(var b=this._hash.words,e=b[0],f=b[1],g=b[2],k=b[3],h=b[4],l=b[5],m=b[6],n=b[7],p=0;64>p;p++){if(16>p)a[p]=\nc[d+p]|0;else{var j=a[p-15],r=a[p-2];a[p]=((j<<25|j>>>7)^(j<<14|j>>>18)^j>>>3)+a[p-7]+((r<<15|r>>>17)^(r<<13|r>>>19)^r>>>10)+a[p-16]}j=n+((h<<26|h>>>6)^(h<<21|h>>>11)^(h<<7|h>>>25))+(h&l^~h&m)+q[p]+a[p];r=((e<<30|e>>>2)^(e<<19|e>>>13)^(e<<10|e>>>22))+(e&f^e&g^f&g);n=m;m=l;l=h;h=k+j|0;k=g;g=f;f=e;e=j+r|0}b[0]=b[0]+e|0;b[1]=b[1]+f|0;b[2]=b[2]+g|0;b[3]=b[3]+k|0;b[4]=b[4]+h|0;b[5]=b[5]+l|0;b[6]=b[6]+m|0;b[7]=b[7]+n|0},_doFinalize:function(){var a=this._data,d=a.words,b=8*this._nDataBytes,e=8*a.sigBytes;\nd[e>>>5]|=128<<24-e%32;d[(e+64>>>9<<4)+14]=g.floor(b/4294967296);d[(e+64>>>9<<4)+15]=b;a.sigBytes=4*d.length;this._process();return this._hash},clone:function(){var a=h.clone.call(this);a._hash=this._hash.clone();return a}});l.SHA256=h._createHelper(f);l.HmacSHA256=h._createHmacHelper(f)})(Math);\n(function(){var g=CryptoJS,l=g.lib.WordArray,f=g.algo,k=f.SHA256,f=f.SHA224=k.extend({_doReset:function(){this._hash=new l.init([3238371032,914150663,812702999,4144912697,4290775857,1750603025,1694076839,3204075428])},_doFinalize:function(){var f=k._doFinalize.call(this);f.sigBytes-=4;return f}});g.SHA224=k._createHelper(f);g.HmacSHA224=k._createHmacHelper(f)})();\n"],
     "crypto_js.rollups.sha256": [".js", "/*\nCryptoJS v3.1.2\ncode.google.com/p/crypto-js\n(c) 2009-2013 by Jeff Mott. All rights reserved.\ncode.google.com/p/crypto-js/wiki/License\n*/\nvar CryptoJS=CryptoJS||function(h,s){var f={},t=f.lib={},g=function(){},j=t.Base={extend:function(a){g.prototype=this;var c=new g;a&&c.mixIn(a);c.hasOwnProperty(\"init\")||(c.init=function(){c.$super.init.apply(this,arguments)});c.init.prototype=c;c.$super=this;return c},create:function(){var a=this.extend();a.init.apply(a,arguments);return a},init:function(){},mixIn:function(a){for(var c in a)a.hasOwnProperty(c)&&(this[c]=a[c]);a.hasOwnProperty(\"toString\")&&(this.toString=a.toString)},clone:function(){return this.init.prototype.extend(this)}},\nq=t.WordArray=j.extend({init:function(a,c){a=this.words=a||[];this.sigBytes=c!=s?c:4*a.length},toString:function(a){return(a||u).stringify(this)},concat:function(a){var c=this.words,d=a.words,b=this.sigBytes;a=a.sigBytes;this.clamp();if(b%4)for(var e=0;e<a;e++)c[b+e>>>2]|=(d[e>>>2]>>>24-8*(e%4)&255)<<24-8*((b+e)%4);else if(65535<d.length)for(e=0;e<a;e+=4)c[b+e>>>2]=d[e>>>2];else c.push.apply(c,d);this.sigBytes+=a;return this},clamp:function(){var a=this.words,c=this.sigBytes;a[c>>>2]&=4294967295<<\n32-8*(c%4);a.length=h.ceil(c/4)},clone:function(){var a=j.clone.call(this);a.words=this.words.slice(0);return a},random:function(a){for(var c=[],d=0;d<a;d+=4)c.push(4294967296*h.random()|0);return new q.init(c,a)}}),v=f.enc={},u=v.Hex={stringify:function(a){var c=a.words;a=a.sigBytes;for(var d=[],b=0;b<a;b++){var e=c[b>>>2]>>>24-8*(b%4)&255;d.push((e>>>4).toString(16));d.push((e&15).toString(16))}return d.join(\"\")},parse:function(a){for(var c=a.length,d=[],b=0;b<c;b+=2)d[b>>>3]|=parseInt(a.substr(b,\n2),16)<<24-4*(b%8);return new q.init(d,c/2)}},k=v.Latin1={stringify:function(a){var c=a.words;a=a.sigBytes;for(var d=[],b=0;b<a;b++)d.push(String.fromCharCode(c[b>>>2]>>>24-8*(b%4)&255));return d.join(\"\")},parse:function(a){for(var c=a.length,d=[],b=0;b<c;b++)d[b>>>2]|=(a.charCodeAt(b)&255)<<24-8*(b%4);return new q.init(d,c)}},l=v.Utf8={stringify:function(a){try{return decodeURIComponent(escape(k.stringify(a)))}catch(c){throw Error(\"Malformed UTF-8 data\");}},parse:function(a){return k.parse(unescape(encodeURIComponent(a)))}},\nx=t.BufferedBlockAlgorithm=j.extend({reset:function(){this._data=new q.init;this._nDataBytes=0},_append:function(a){\"string\"==typeof a&&(a=l.parse(a));this._data.concat(a);this._nDataBytes+=a.sigBytes},_process:function(a){var c=this._data,d=c.words,b=c.sigBytes,e=this.blockSize,f=b/(4*e),f=a?h.ceil(f):h.max((f|0)-this._minBufferSize,0);a=f*e;b=h.min(4*a,b);if(a){for(var m=0;m<a;m+=e)this._doProcessBlock(d,m);m=d.splice(0,a);c.sigBytes-=b}return new q.init(m,b)},clone:function(){var a=j.clone.call(this);\na._data=this._data.clone();return a},_minBufferSize:0});t.Hasher=x.extend({cfg:j.extend(),init:function(a){this.cfg=this.cfg.extend(a);this.reset()},reset:function(){x.reset.call(this);this._doReset()},update:function(a){this._append(a);this._process();return this},finalize:function(a){a&&this._append(a);return this._doFinalize()},blockSize:16,_createHelper:function(a){return function(c,d){return(new a.init(d)).finalize(c)}},_createHmacHelper:function(a){return function(c,d){return(new w.HMAC.init(a,\nd)).finalize(c)}}});var w=f.algo={};return f}(Math);\n(function(h){for(var s=CryptoJS,f=s.lib,t=f.WordArray,g=f.Hasher,f=s.algo,j=[],q=[],v=function(a){return 4294967296*(a-(a|0))|0},u=2,k=0;64>k;){var l;a:{l=u;for(var x=h.sqrt(l),w=2;w<=x;w++)if(!(l%w)){l=!1;break a}l=!0}l&&(8>k&&(j[k]=v(h.pow(u,0.5))),q[k]=v(h.pow(u,1/3)),k++);u++}var a=[],f=f.SHA256=g.extend({_doReset:function(){this._hash=new t.init(j.slice(0))},_doProcessBlock:function(c,d){for(var b=this._hash.words,e=b[0],f=b[1],m=b[2],h=b[3],p=b[4],j=b[5],k=b[6],l=b[7],n=0;64>n;n++){if(16>n)a[n]=\nc[d+n]|0;else{var r=a[n-15],g=a[n-2];a[n]=((r<<25|r>>>7)^(r<<14|r>>>18)^r>>>3)+a[n-7]+((g<<15|g>>>17)^(g<<13|g>>>19)^g>>>10)+a[n-16]}r=l+((p<<26|p>>>6)^(p<<21|p>>>11)^(p<<7|p>>>25))+(p&j^~p&k)+q[n]+a[n];g=((e<<30|e>>>2)^(e<<19|e>>>13)^(e<<10|e>>>22))+(e&f^e&m^f&m);l=k;k=j;j=p;p=h+r|0;h=m;m=f;f=e;e=r+g|0}b[0]=b[0]+e|0;b[1]=b[1]+f|0;b[2]=b[2]+m|0;b[3]=b[3]+h|0;b[4]=b[4]+p|0;b[5]=b[5]+j|0;b[6]=b[6]+k|0;b[7]=b[7]+l|0},_doFinalize:function(){var a=this._data,d=a.words,b=8*this._nDataBytes,e=8*a.sigBytes;\nd[e>>>5]|=128<<24-e%32;d[(e+64>>>9<<4)+14]=h.floor(b/4294967296);d[(e+64>>>9<<4)+15]=b;a.sigBytes=4*d.length;this._process();return this._hash},clone:function(){var a=g.clone.call(this);a._hash=this._hash.clone();return a}});s.SHA256=g._createHelper(f);s.HmacSHA256=g._createHmacHelper(f)})(Math);\n"],
     "crypto_js.rollups.sha3": [".js", "/*\nCryptoJS v3.1.2\ncode.google.com/p/crypto-js\n(c) 2009-2013 by Jeff Mott. All rights reserved.\ncode.google.com/p/crypto-js/wiki/License\n*/\nvar CryptoJS=CryptoJS||function(v,p){var d={},u=d.lib={},r=function(){},f=u.Base={extend:function(a){r.prototype=this;var b=new r;a&&b.mixIn(a);b.hasOwnProperty(\"init\")||(b.init=function(){b.$super.init.apply(this,arguments)});b.init.prototype=b;b.$super=this;return b},create:function(){var a=this.extend();a.init.apply(a,arguments);return a},init:function(){},mixIn:function(a){for(var b in a)a.hasOwnProperty(b)&&(this[b]=a[b]);a.hasOwnProperty(\"toString\")&&(this.toString=a.toString)},clone:function(){return this.init.prototype.extend(this)}},\ns=u.WordArray=f.extend({init:function(a,b){a=this.words=a||[];this.sigBytes=b!=p?b:4*a.length},toString:function(a){return(a||y).stringify(this)},concat:function(a){var b=this.words,c=a.words,j=this.sigBytes;a=a.sigBytes;this.clamp();if(j%4)for(var n=0;n<a;n++)b[j+n>>>2]|=(c[n>>>2]>>>24-8*(n%4)&255)<<24-8*((j+n)%4);else if(65535<c.length)for(n=0;n<a;n+=4)b[j+n>>>2]=c[n>>>2];else b.push.apply(b,c);this.sigBytes+=a;return this},clamp:function(){var a=this.words,b=this.sigBytes;a[b>>>2]&=4294967295<<\n32-8*(b%4);a.length=v.ceil(b/4)},clone:function(){var a=f.clone.call(this);a.words=this.words.slice(0);return a},random:function(a){for(var b=[],c=0;c<a;c+=4)b.push(4294967296*v.random()|0);return new s.init(b,a)}}),x=d.enc={},y=x.Hex={stringify:function(a){var b=a.words;a=a.sigBytes;for(var c=[],j=0;j<a;j++){var n=b[j>>>2]>>>24-8*(j%4)&255;c.push((n>>>4).toString(16));c.push((n&15).toString(16))}return c.join(\"\")},parse:function(a){for(var b=a.length,c=[],j=0;j<b;j+=2)c[j>>>3]|=parseInt(a.substr(j,\n2),16)<<24-4*(j%8);return new s.init(c,b/2)}},e=x.Latin1={stringify:function(a){var b=a.words;a=a.sigBytes;for(var c=[],j=0;j<a;j++)c.push(String.fromCharCode(b[j>>>2]>>>24-8*(j%4)&255));return c.join(\"\")},parse:function(a){for(var b=a.length,c=[],j=0;j<b;j++)c[j>>>2]|=(a.charCodeAt(j)&255)<<24-8*(j%4);return new s.init(c,b)}},q=x.Utf8={stringify:function(a){try{return decodeURIComponent(escape(e.stringify(a)))}catch(b){throw Error(\"Malformed UTF-8 data\");}},parse:function(a){return e.parse(unescape(encodeURIComponent(a)))}},\nt=u.BufferedBlockAlgorithm=f.extend({reset:function(){this._data=new s.init;this._nDataBytes=0},_append:function(a){\"string\"==typeof a&&(a=q.parse(a));this._data.concat(a);this._nDataBytes+=a.sigBytes},_process:function(a){var b=this._data,c=b.words,j=b.sigBytes,n=this.blockSize,e=j/(4*n),e=a?v.ceil(e):v.max((e|0)-this._minBufferSize,0);a=e*n;j=v.min(4*a,j);if(a){for(var f=0;f<a;f+=n)this._doProcessBlock(c,f);f=c.splice(0,a);b.sigBytes-=j}return new s.init(f,j)},clone:function(){var a=f.clone.call(this);\na._data=this._data.clone();return a},_minBufferSize:0});u.Hasher=t.extend({cfg:f.extend(),init:function(a){this.cfg=this.cfg.extend(a);this.reset()},reset:function(){t.reset.call(this);this._doReset()},update:function(a){this._append(a);this._process();return this},finalize:function(a){a&&this._append(a);return this._doFinalize()},blockSize:16,_createHelper:function(a){return function(b,c){return(new a.init(c)).finalize(b)}},_createHmacHelper:function(a){return function(b,c){return(new w.HMAC.init(a,\nc)).finalize(b)}}});var w=d.algo={};return d}(Math);\n(function(v){var p=CryptoJS,d=p.lib,u=d.Base,r=d.WordArray,p=p.x64={};p.Word=u.extend({init:function(f,s){this.high=f;this.low=s}});p.WordArray=u.extend({init:function(f,s){f=this.words=f||[];this.sigBytes=s!=v?s:8*f.length},toX32:function(){for(var f=this.words,s=f.length,d=[],p=0;p<s;p++){var e=f[p];d.push(e.high);d.push(e.low)}return r.create(d,this.sigBytes)},clone:function(){for(var f=u.clone.call(this),d=f.words=this.words.slice(0),p=d.length,r=0;r<p;r++)d[r]=d[r].clone();return f}})})();\n(function(v){for(var p=CryptoJS,d=p.lib,u=d.WordArray,r=d.Hasher,f=p.x64.Word,d=p.algo,s=[],x=[],y=[],e=1,q=0,t=0;24>t;t++){s[e+5*q]=(t+1)*(t+2)/2%64;var w=(2*e+3*q)%5,e=q%5,q=w}for(e=0;5>e;e++)for(q=0;5>q;q++)x[e+5*q]=q+5*((2*e+3*q)%5);e=1;for(q=0;24>q;q++){for(var a=w=t=0;7>a;a++){if(e&1){var b=(1<<a)-1;32>b?w^=1<<b:t^=1<<b-32}e=e&128?e<<1^113:e<<1}y[q]=f.create(t,w)}for(var c=[],e=0;25>e;e++)c[e]=f.create();d=d.SHA3=r.extend({cfg:r.cfg.extend({outputLength:512}),_doReset:function(){for(var a=this._state=\n[],b=0;25>b;b++)a[b]=new f.init;this.blockSize=(1600-2*this.cfg.outputLength)/32},_doProcessBlock:function(a,b){for(var e=this._state,f=this.blockSize/2,h=0;h<f;h++){var l=a[b+2*h],m=a[b+2*h+1],l=(l<<8|l>>>24)&16711935|(l<<24|l>>>8)&4278255360,m=(m<<8|m>>>24)&16711935|(m<<24|m>>>8)&4278255360,g=e[h];g.high^=m;g.low^=l}for(f=0;24>f;f++){for(h=0;5>h;h++){for(var d=l=0,k=0;5>k;k++)g=e[h+5*k],l^=g.high,d^=g.low;g=c[h];g.high=l;g.low=d}for(h=0;5>h;h++){g=c[(h+4)%5];l=c[(h+1)%5];m=l.high;k=l.low;l=g.high^\n(m<<1|k>>>31);d=g.low^(k<<1|m>>>31);for(k=0;5>k;k++)g=e[h+5*k],g.high^=l,g.low^=d}for(m=1;25>m;m++)g=e[m],h=g.high,g=g.low,k=s[m],32>k?(l=h<<k|g>>>32-k,d=g<<k|h>>>32-k):(l=g<<k-32|h>>>64-k,d=h<<k-32|g>>>64-k),g=c[x[m]],g.high=l,g.low=d;g=c[0];h=e[0];g.high=h.high;g.low=h.low;for(h=0;5>h;h++)for(k=0;5>k;k++)m=h+5*k,g=e[m],l=c[m],m=c[(h+1)%5+5*k],d=c[(h+2)%5+5*k],g.high=l.high^~m.high&d.high,g.low=l.low^~m.low&d.low;g=e[0];h=y[f];g.high^=h.high;g.low^=h.low}},_doFinalize:function(){var a=this._data,\nb=a.words,c=8*a.sigBytes,e=32*this.blockSize;b[c>>>5]|=1<<24-c%32;b[(v.ceil((c+1)/e)*e>>>5)-1]|=128;a.sigBytes=4*b.length;this._process();for(var a=this._state,b=this.cfg.outputLength/8,c=b/8,e=[],h=0;h<c;h++){var d=a[h],f=d.high,d=d.low,f=(f<<8|f>>>24)&16711935|(f<<24|f>>>8)&4278255360,d=(d<<8|d>>>24)&16711935|(d<<24|d>>>8)&4278255360;e.push(d);e.push(f)}return new u.init(e,b)},clone:function(){for(var a=r.clone.call(this),b=a._state=this._state.slice(0),c=0;25>c;c++)b[c]=b[c].clone();return a}});\np.SHA3=r._createHelper(d);p.HmacSHA3=r._createHmacHelper(d)})(Math);\n"],
     "crypto_js.rollups.sha384": [".js", "/*\nCryptoJS v3.1.2\ncode.google.com/p/crypto-js\n(c) 2009-2013 by Jeff Mott. All rights reserved.\ncode.google.com/p/crypto-js/wiki/License\n*/\nvar CryptoJS=CryptoJS||function(a,c){var d={},j=d.lib={},f=function(){},m=j.Base={extend:function(a){f.prototype=this;var b=new f;a&&b.mixIn(a);b.hasOwnProperty(\"init\")||(b.init=function(){b.$super.init.apply(this,arguments)});b.init.prototype=b;b.$super=this;return b},create:function(){var a=this.extend();a.init.apply(a,arguments);return a},init:function(){},mixIn:function(a){for(var b in a)a.hasOwnProperty(b)&&(this[b]=a[b]);a.hasOwnProperty(\"toString\")&&(this.toString=a.toString)},clone:function(){return this.init.prototype.extend(this)}},\nB=j.WordArray=m.extend({init:function(a,b){a=this.words=a||[];this.sigBytes=b!=c?b:4*a.length},toString:function(a){return(a||y).stringify(this)},concat:function(a){var b=this.words,g=a.words,e=this.sigBytes;a=a.sigBytes;this.clamp();if(e%4)for(var k=0;k<a;k++)b[e+k>>>2]|=(g[k>>>2]>>>24-8*(k%4)&255)<<24-8*((e+k)%4);else if(65535<g.length)for(k=0;k<a;k+=4)b[e+k>>>2]=g[k>>>2];else b.push.apply(b,g);this.sigBytes+=a;return this},clamp:function(){var n=this.words,b=this.sigBytes;n[b>>>2]&=4294967295<<\n32-8*(b%4);n.length=a.ceil(b/4)},clone:function(){var a=m.clone.call(this);a.words=this.words.slice(0);return a},random:function(n){for(var b=[],g=0;g<n;g+=4)b.push(4294967296*a.random()|0);return new B.init(b,n)}}),v=d.enc={},y=v.Hex={stringify:function(a){var b=a.words;a=a.sigBytes;for(var g=[],e=0;e<a;e++){var k=b[e>>>2]>>>24-8*(e%4)&255;g.push((k>>>4).toString(16));g.push((k&15).toString(16))}return g.join(\"\")},parse:function(a){for(var b=a.length,g=[],e=0;e<b;e+=2)g[e>>>3]|=parseInt(a.substr(e,\n2),16)<<24-4*(e%8);return new B.init(g,b/2)}},F=v.Latin1={stringify:function(a){var b=a.words;a=a.sigBytes;for(var g=[],e=0;e<a;e++)g.push(String.fromCharCode(b[e>>>2]>>>24-8*(e%4)&255));return g.join(\"\")},parse:function(a){for(var b=a.length,g=[],e=0;e<b;e++)g[e>>>2]|=(a.charCodeAt(e)&255)<<24-8*(e%4);return new B.init(g,b)}},ha=v.Utf8={stringify:function(a){try{return decodeURIComponent(escape(F.stringify(a)))}catch(b){throw Error(\"Malformed UTF-8 data\");}},parse:function(a){return F.parse(unescape(encodeURIComponent(a)))}},\nZ=j.BufferedBlockAlgorithm=m.extend({reset:function(){this._data=new B.init;this._nDataBytes=0},_append:function(a){\"string\"==typeof a&&(a=ha.parse(a));this._data.concat(a);this._nDataBytes+=a.sigBytes},_process:function(n){var b=this._data,g=b.words,e=b.sigBytes,k=this.blockSize,m=e/(4*k),m=n?a.ceil(m):a.max((m|0)-this._minBufferSize,0);n=m*k;e=a.min(4*n,e);if(n){for(var c=0;c<n;c+=k)this._doProcessBlock(g,c);c=g.splice(0,n);b.sigBytes-=e}return new B.init(c,e)},clone:function(){var a=m.clone.call(this);\na._data=this._data.clone();return a},_minBufferSize:0});j.Hasher=Z.extend({cfg:m.extend(),init:function(a){this.cfg=this.cfg.extend(a);this.reset()},reset:function(){Z.reset.call(this);this._doReset()},update:function(a){this._append(a);this._process();return this},finalize:function(a){a&&this._append(a);return this._doFinalize()},blockSize:16,_createHelper:function(a){return function(b,g){return(new a.init(g)).finalize(b)}},_createHmacHelper:function(a){return function(b,g){return(new ia.HMAC.init(a,\ng)).finalize(b)}}});var ia=d.algo={};return d}(Math);\n(function(a){var c=CryptoJS,d=c.lib,j=d.Base,f=d.WordArray,c=c.x64={};c.Word=j.extend({init:function(a,c){this.high=a;this.low=c}});c.WordArray=j.extend({init:function(c,d){c=this.words=c||[];this.sigBytes=d!=a?d:8*c.length},toX32:function(){for(var a=this.words,c=a.length,d=[],j=0;j<c;j++){var F=a[j];d.push(F.high);d.push(F.low)}return f.create(d,this.sigBytes)},clone:function(){for(var a=j.clone.call(this),c=a.words=this.words.slice(0),d=c.length,f=0;f<d;f++)c[f]=c[f].clone();return a}})})();\n(function(){function a(){return f.create.apply(f,arguments)}for(var c=CryptoJS,d=c.lib.Hasher,j=c.x64,f=j.Word,m=j.WordArray,j=c.algo,B=[a(1116352408,3609767458),a(1899447441,602891725),a(3049323471,3964484399),a(3921009573,2173295548),a(961987163,4081628472),a(1508970993,3053834265),a(2453635748,2937671579),a(2870763221,3664609560),a(3624381080,2734883394),a(310598401,1164996542),a(607225278,1323610764),a(1426881987,3590304994),a(1925078388,4068182383),a(2162078206,991336113),a(2614888103,633803317),\na(3248222580,3479774868),a(3835390401,2666613458),a(4022224774,944711139),a(264347078,2341262773),a(604807628,2007800933),a(770255983,1495990901),a(1249150122,1856431235),a(1555081692,3175218132),a(1996064986,2198950837),a(2554220882,3999719339),a(2821834349,766784016),a(2952996808,2566594879),a(3210313671,3203337956),a(3336571891,1034457026),a(3584528711,2466948901),a(113926993,3758326383),a(338241895,168717936),a(666307205,1188179964),a(773529912,1546045734),a(1294757372,1522805485),a(1396182291,\n2643833823),a(1695183700,2343527390),a(1986661051,1014477480),a(2177026350,1206759142),a(2456956037,344077627),a(2730485921,1290863460),a(2820302411,3158454273),a(3259730800,3505952657),a(3345764771,106217008),a(3516065817,3606008344),a(3600352804,1432725776),a(4094571909,1467031594),a(275423344,851169720),a(430227734,3100823752),a(506948616,1363258195),a(659060556,3750685593),a(883997877,3785050280),a(958139571,3318307427),a(1322822218,3812723403),a(1537002063,2003034995),a(1747873779,3602036899),\na(1955562222,1575990012),a(2024104815,1125592928),a(2227730452,2716904306),a(2361852424,442776044),a(2428436474,593698344),a(2756734187,3733110249),a(3204031479,2999351573),a(3329325298,3815920427),a(3391569614,3928383900),a(3515267271,566280711),a(3940187606,3454069534),a(4118630271,4000239992),a(116418474,1914138554),a(174292421,2731055270),a(289380356,3203993006),a(460393269,320620315),a(685471733,587496836),a(852142971,1086792851),a(1017036298,365543100),a(1126000580,2618297676),a(1288033470,\n3409855158),a(1501505948,4234509866),a(1607167915,987167468),a(1816402316,1246189591)],v=[],y=0;80>y;y++)v[y]=a();j=j.SHA512=d.extend({_doReset:function(){this._hash=new m.init([new f.init(1779033703,4089235720),new f.init(3144134277,2227873595),new f.init(1013904242,4271175723),new f.init(2773480762,1595750129),new f.init(1359893119,2917565137),new f.init(2600822924,725511199),new f.init(528734635,4215389547),new f.init(1541459225,327033209)])},_doProcessBlock:function(a,c){for(var d=this._hash.words,\nf=d[0],j=d[1],b=d[2],g=d[3],e=d[4],k=d[5],m=d[6],d=d[7],y=f.high,M=f.low,$=j.high,N=j.low,aa=b.high,O=b.low,ba=g.high,P=g.low,ca=e.high,Q=e.low,da=k.high,R=k.low,ea=m.high,S=m.low,fa=d.high,T=d.low,s=y,p=M,G=$,D=N,H=aa,E=O,W=ba,I=P,t=ca,q=Q,U=da,J=R,V=ea,K=S,X=fa,L=T,u=0;80>u;u++){var z=v[u];if(16>u)var r=z.high=a[c+2*u]|0,h=z.low=a[c+2*u+1]|0;else{var r=v[u-15],h=r.high,w=r.low,r=(h>>>1|w<<31)^(h>>>8|w<<24)^h>>>7,w=(w>>>1|h<<31)^(w>>>8|h<<24)^(w>>>7|h<<25),C=v[u-2],h=C.high,l=C.low,C=(h>>>19|l<<\n13)^(h<<3|l>>>29)^h>>>6,l=(l>>>19|h<<13)^(l<<3|h>>>29)^(l>>>6|h<<26),h=v[u-7],Y=h.high,A=v[u-16],x=A.high,A=A.low,h=w+h.low,r=r+Y+(h>>>0<w>>>0?1:0),h=h+l,r=r+C+(h>>>0<l>>>0?1:0),h=h+A,r=r+x+(h>>>0<A>>>0?1:0);z.high=r;z.low=h}var Y=t&U^~t&V,A=q&J^~q&K,z=s&G^s&H^G&H,ja=p&D^p&E^D&E,w=(s>>>28|p<<4)^(s<<30|p>>>2)^(s<<25|p>>>7),C=(p>>>28|s<<4)^(p<<30|s>>>2)^(p<<25|s>>>7),l=B[u],ka=l.high,ga=l.low,l=L+((q>>>14|t<<18)^(q>>>18|t<<14)^(q<<23|t>>>9)),x=X+((t>>>14|q<<18)^(t>>>18|q<<14)^(t<<23|q>>>9))+(l>>>0<\nL>>>0?1:0),l=l+A,x=x+Y+(l>>>0<A>>>0?1:0),l=l+ga,x=x+ka+(l>>>0<ga>>>0?1:0),l=l+h,x=x+r+(l>>>0<h>>>0?1:0),h=C+ja,z=w+z+(h>>>0<C>>>0?1:0),X=V,L=K,V=U,K=J,U=t,J=q,q=I+l|0,t=W+x+(q>>>0<I>>>0?1:0)|0,W=H,I=E,H=G,E=D,G=s,D=p,p=l+h|0,s=x+z+(p>>>0<l>>>0?1:0)|0}M=f.low=M+p;f.high=y+s+(M>>>0<p>>>0?1:0);N=j.low=N+D;j.high=$+G+(N>>>0<D>>>0?1:0);O=b.low=O+E;b.high=aa+H+(O>>>0<E>>>0?1:0);P=g.low=P+I;g.high=ba+W+(P>>>0<I>>>0?1:0);Q=e.low=Q+q;e.high=ca+t+(Q>>>0<q>>>0?1:0);R=k.low=R+J;k.high=da+U+(R>>>0<J>>>0?1:0);\nS=m.low=S+K;m.high=ea+V+(S>>>0<K>>>0?1:0);T=d.low=T+L;d.high=fa+X+(T>>>0<L>>>0?1:0)},_doFinalize:function(){var a=this._data,c=a.words,d=8*this._nDataBytes,f=8*a.sigBytes;c[f>>>5]|=128<<24-f%32;c[(f+128>>>10<<5)+30]=Math.floor(d/4294967296);c[(f+128>>>10<<5)+31]=d;a.sigBytes=4*c.length;this._process();return this._hash.toX32()},clone:function(){var a=d.clone.call(this);a._hash=this._hash.clone();return a},blockSize:32});c.SHA512=d._createHelper(j);c.HmacSHA512=d._createHmacHelper(j)})();\n(function(){var a=CryptoJS,c=a.x64,d=c.Word,j=c.WordArray,c=a.algo,f=c.SHA512,c=c.SHA384=f.extend({_doReset:function(){this._hash=new j.init([new d.init(3418070365,3238371032),new d.init(1654270250,914150663),new d.init(2438529370,812702999),new d.init(355462360,4144912697),new d.init(1731405415,4290775857),new d.init(2394180231,1750603025),new d.init(3675008525,1694076839),new d.init(1203062813,3204075428)])},_doFinalize:function(){var a=f._doFinalize.call(this);a.sigBytes-=16;return a}});a.SHA384=\nf._createHelper(c);a.HmacSHA384=f._createHmacHelper(c)})();\n"],
     "crypto_js.rollups.sha512": [".js", "/*\nCryptoJS v3.1.2\ncode.google.com/p/crypto-js\n(c) 2009-2013 by Jeff Mott. All rights reserved.\ncode.google.com/p/crypto-js/wiki/License\n*/\nvar CryptoJS=CryptoJS||function(a,m){var r={},f=r.lib={},g=function(){},l=f.Base={extend:function(a){g.prototype=this;var b=new g;a&&b.mixIn(a);b.hasOwnProperty(\"init\")||(b.init=function(){b.$super.init.apply(this,arguments)});b.init.prototype=b;b.$super=this;return b},create:function(){var a=this.extend();a.init.apply(a,arguments);return a},init:function(){},mixIn:function(a){for(var b in a)a.hasOwnProperty(b)&&(this[b]=a[b]);a.hasOwnProperty(\"toString\")&&(this.toString=a.toString)},clone:function(){return this.init.prototype.extend(this)}},\np=f.WordArray=l.extend({init:function(a,b){a=this.words=a||[];this.sigBytes=b!=m?b:4*a.length},toString:function(a){return(a||q).stringify(this)},concat:function(a){var b=this.words,d=a.words,c=this.sigBytes;a=a.sigBytes;this.clamp();if(c%4)for(var j=0;j<a;j++)b[c+j>>>2]|=(d[j>>>2]>>>24-8*(j%4)&255)<<24-8*((c+j)%4);else if(65535<d.length)for(j=0;j<a;j+=4)b[c+j>>>2]=d[j>>>2];else b.push.apply(b,d);this.sigBytes+=a;return this},clamp:function(){var n=this.words,b=this.sigBytes;n[b>>>2]&=4294967295<<\n32-8*(b%4);n.length=a.ceil(b/4)},clone:function(){var a=l.clone.call(this);a.words=this.words.slice(0);return a},random:function(n){for(var b=[],d=0;d<n;d+=4)b.push(4294967296*a.random()|0);return new p.init(b,n)}}),y=r.enc={},q=y.Hex={stringify:function(a){var b=a.words;a=a.sigBytes;for(var d=[],c=0;c<a;c++){var j=b[c>>>2]>>>24-8*(c%4)&255;d.push((j>>>4).toString(16));d.push((j&15).toString(16))}return d.join(\"\")},parse:function(a){for(var b=a.length,d=[],c=0;c<b;c+=2)d[c>>>3]|=parseInt(a.substr(c,\n2),16)<<24-4*(c%8);return new p.init(d,b/2)}},G=y.Latin1={stringify:function(a){var b=a.words;a=a.sigBytes;for(var d=[],c=0;c<a;c++)d.push(String.fromCharCode(b[c>>>2]>>>24-8*(c%4)&255));return d.join(\"\")},parse:function(a){for(var b=a.length,d=[],c=0;c<b;c++)d[c>>>2]|=(a.charCodeAt(c)&255)<<24-8*(c%4);return new p.init(d,b)}},fa=y.Utf8={stringify:function(a){try{return decodeURIComponent(escape(G.stringify(a)))}catch(b){throw Error(\"Malformed UTF-8 data\");}},parse:function(a){return G.parse(unescape(encodeURIComponent(a)))}},\nh=f.BufferedBlockAlgorithm=l.extend({reset:function(){this._data=new p.init;this._nDataBytes=0},_append:function(a){\"string\"==typeof a&&(a=fa.parse(a));this._data.concat(a);this._nDataBytes+=a.sigBytes},_process:function(n){var b=this._data,d=b.words,c=b.sigBytes,j=this.blockSize,l=c/(4*j),l=n?a.ceil(l):a.max((l|0)-this._minBufferSize,0);n=l*j;c=a.min(4*n,c);if(n){for(var h=0;h<n;h+=j)this._doProcessBlock(d,h);h=d.splice(0,n);b.sigBytes-=c}return new p.init(h,c)},clone:function(){var a=l.clone.call(this);\na._data=this._data.clone();return a},_minBufferSize:0});f.Hasher=h.extend({cfg:l.extend(),init:function(a){this.cfg=this.cfg.extend(a);this.reset()},reset:function(){h.reset.call(this);this._doReset()},update:function(a){this._append(a);this._process();return this},finalize:function(a){a&&this._append(a);return this._doFinalize()},blockSize:16,_createHelper:function(a){return function(b,d){return(new a.init(d)).finalize(b)}},_createHmacHelper:function(a){return function(b,d){return(new ga.HMAC.init(a,\nd)).finalize(b)}}});var ga=r.algo={};return r}(Math);\n(function(a){var m=CryptoJS,r=m.lib,f=r.Base,g=r.WordArray,m=m.x64={};m.Word=f.extend({init:function(a,p){this.high=a;this.low=p}});m.WordArray=f.extend({init:function(l,p){l=this.words=l||[];this.sigBytes=p!=a?p:8*l.length},toX32:function(){for(var a=this.words,p=a.length,f=[],q=0;q<p;q++){var G=a[q];f.push(G.high);f.push(G.low)}return g.create(f,this.sigBytes)},clone:function(){for(var a=f.clone.call(this),p=a.words=this.words.slice(0),g=p.length,q=0;q<g;q++)p[q]=p[q].clone();return a}})})();\n(function(){function a(){return g.create.apply(g,arguments)}for(var m=CryptoJS,r=m.lib.Hasher,f=m.x64,g=f.Word,l=f.WordArray,f=m.algo,p=[a(1116352408,3609767458),a(1899447441,602891725),a(3049323471,3964484399),a(3921009573,2173295548),a(961987163,4081628472),a(1508970993,3053834265),a(2453635748,2937671579),a(2870763221,3664609560),a(3624381080,2734883394),a(310598401,1164996542),a(607225278,1323610764),a(1426881987,3590304994),a(1925078388,4068182383),a(2162078206,991336113),a(2614888103,633803317),\na(3248222580,3479774868),a(3835390401,2666613458),a(4022224774,944711139),a(264347078,2341262773),a(604807628,2007800933),a(770255983,1495990901),a(1249150122,1856431235),a(1555081692,3175218132),a(1996064986,2198950837),a(2554220882,3999719339),a(2821834349,766784016),a(2952996808,2566594879),a(3210313671,3203337956),a(3336571891,1034457026),a(3584528711,2466948901),a(113926993,3758326383),a(338241895,168717936),a(666307205,1188179964),a(773529912,1546045734),a(1294757372,1522805485),a(1396182291,\n2643833823),a(1695183700,2343527390),a(1986661051,1014477480),a(2177026350,1206759142),a(2456956037,344077627),a(2730485921,1290863460),a(2820302411,3158454273),a(3259730800,3505952657),a(3345764771,106217008),a(3516065817,3606008344),a(3600352804,1432725776),a(4094571909,1467031594),a(275423344,851169720),a(430227734,3100823752),a(506948616,1363258195),a(659060556,3750685593),a(883997877,3785050280),a(958139571,3318307427),a(1322822218,3812723403),a(1537002063,2003034995),a(1747873779,3602036899),\na(1955562222,1575990012),a(2024104815,1125592928),a(2227730452,2716904306),a(2361852424,442776044),a(2428436474,593698344),a(2756734187,3733110249),a(3204031479,2999351573),a(3329325298,3815920427),a(3391569614,3928383900),a(3515267271,566280711),a(3940187606,3454069534),a(4118630271,4000239992),a(116418474,1914138554),a(174292421,2731055270),a(289380356,3203993006),a(460393269,320620315),a(685471733,587496836),a(852142971,1086792851),a(1017036298,365543100),a(1126000580,2618297676),a(1288033470,\n3409855158),a(1501505948,4234509866),a(1607167915,987167468),a(1816402316,1246189591)],y=[],q=0;80>q;q++)y[q]=a();f=f.SHA512=r.extend({_doReset:function(){this._hash=new l.init([new g.init(1779033703,4089235720),new g.init(3144134277,2227873595),new g.init(1013904242,4271175723),new g.init(2773480762,1595750129),new g.init(1359893119,2917565137),new g.init(2600822924,725511199),new g.init(528734635,4215389547),new g.init(1541459225,327033209)])},_doProcessBlock:function(a,f){for(var h=this._hash.words,\ng=h[0],n=h[1],b=h[2],d=h[3],c=h[4],j=h[5],l=h[6],h=h[7],q=g.high,m=g.low,r=n.high,N=n.low,Z=b.high,O=b.low,$=d.high,P=d.low,aa=c.high,Q=c.low,ba=j.high,R=j.low,ca=l.high,S=l.low,da=h.high,T=h.low,v=q,s=m,H=r,E=N,I=Z,F=O,W=$,J=P,w=aa,t=Q,U=ba,K=R,V=ca,L=S,X=da,M=T,x=0;80>x;x++){var B=y[x];if(16>x)var u=B.high=a[f+2*x]|0,e=B.low=a[f+2*x+1]|0;else{var u=y[x-15],e=u.high,z=u.low,u=(e>>>1|z<<31)^(e>>>8|z<<24)^e>>>7,z=(z>>>1|e<<31)^(z>>>8|e<<24)^(z>>>7|e<<25),D=y[x-2],e=D.high,k=D.low,D=(e>>>19|k<<13)^\n(e<<3|k>>>29)^e>>>6,k=(k>>>19|e<<13)^(k<<3|e>>>29)^(k>>>6|e<<26),e=y[x-7],Y=e.high,C=y[x-16],A=C.high,C=C.low,e=z+e.low,u=u+Y+(e>>>0<z>>>0?1:0),e=e+k,u=u+D+(e>>>0<k>>>0?1:0),e=e+C,u=u+A+(e>>>0<C>>>0?1:0);B.high=u;B.low=e}var Y=w&U^~w&V,C=t&K^~t&L,B=v&H^v&I^H&I,ha=s&E^s&F^E&F,z=(v>>>28|s<<4)^(v<<30|s>>>2)^(v<<25|s>>>7),D=(s>>>28|v<<4)^(s<<30|v>>>2)^(s<<25|v>>>7),k=p[x],ia=k.high,ea=k.low,k=M+((t>>>14|w<<18)^(t>>>18|w<<14)^(t<<23|w>>>9)),A=X+((w>>>14|t<<18)^(w>>>18|t<<14)^(w<<23|t>>>9))+(k>>>0<M>>>\n0?1:0),k=k+C,A=A+Y+(k>>>0<C>>>0?1:0),k=k+ea,A=A+ia+(k>>>0<ea>>>0?1:0),k=k+e,A=A+u+(k>>>0<e>>>0?1:0),e=D+ha,B=z+B+(e>>>0<D>>>0?1:0),X=V,M=L,V=U,L=K,U=w,K=t,t=J+k|0,w=W+A+(t>>>0<J>>>0?1:0)|0,W=I,J=F,I=H,F=E,H=v,E=s,s=k+e|0,v=A+B+(s>>>0<k>>>0?1:0)|0}m=g.low=m+s;g.high=q+v+(m>>>0<s>>>0?1:0);N=n.low=N+E;n.high=r+H+(N>>>0<E>>>0?1:0);O=b.low=O+F;b.high=Z+I+(O>>>0<F>>>0?1:0);P=d.low=P+J;d.high=$+W+(P>>>0<J>>>0?1:0);Q=c.low=Q+t;c.high=aa+w+(Q>>>0<t>>>0?1:0);R=j.low=R+K;j.high=ba+U+(R>>>0<K>>>0?1:0);S=l.low=\nS+L;l.high=ca+V+(S>>>0<L>>>0?1:0);T=h.low=T+M;h.high=da+X+(T>>>0<M>>>0?1:0)},_doFinalize:function(){var a=this._data,f=a.words,h=8*this._nDataBytes,g=8*a.sigBytes;f[g>>>5]|=128<<24-g%32;f[(g+128>>>10<<5)+30]=Math.floor(h/4294967296);f[(g+128>>>10<<5)+31]=h;a.sigBytes=4*f.length;this._process();return this._hash.toX32()},clone:function(){var a=r.clone.call(this);a._hash=this._hash.clone();return a},blockSize:32});m.SHA512=r._createHelper(f);m.HmacSHA512=r._createHmacHelper(f)})();\n"],
-    "abc": [".py", "\n\n\n\"\"\"Abstract Base Classes (ABCs) according to PEP 3119.\"\"\"\n\n\ndef abstractmethod(funcobj):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n funcobj.__isabstractmethod__=True\n return funcobj\n \n \nclass abstractclassmethod(classmethod):\n ''\n\n\n \n \n __isabstractmethod__=True\n \n def __init__(self,callable):\n  callable.__isabstractmethod__=True\n  super().__init__(callable)\n  \n  \nclass abstractstaticmethod(staticmethod):\n ''\n\n\n \n \n __isabstractmethod__=True\n \n def __init__(self,callable):\n  callable.__isabstractmethod__=True\n  super().__init__(callable)\n  \n  \nclass abstractproperty(property):\n ''\n\n\n \n \n __isabstractmethod__=True\n \n \ntry :\n from _abc import (get_cache_token,_abc_init,_abc_register,\n _abc_instancecheck,_abc_subclasscheck,_get_dump,\n _reset_registry,_reset_caches)\nexcept ImportError:\n from _py_abc import ABCMeta,get_cache_token\n ABCMeta.__module__='abc'\nelse :\n class ABCMeta(type):\n  ''\n\n\n\n\n\n\n\n\n\n\n  \n  def __new__(mcls,name,bases,namespace,**kwargs):\n   cls=super().__new__(mcls,name,bases,namespace,**kwargs)\n   _abc_init(cls)\n   return cls\n   \n  def register(cls,subclass):\n   ''\n\n\n   \n   return _abc_register(cls,subclass)\n   \n  def __instancecheck__(cls,instance):\n   ''\n   return _abc_instancecheck(cls,instance)\n   \n  def __subclasscheck__(cls,subclass):\n   ''\n   return _abc_subclasscheck(cls,subclass)\n   \n  def _dump_registry(cls,file=None ):\n   ''\n   print(f\"Class: {cls.__module__}.{cls.__qualname__}\",file=file)\n   print(f\"Inv. counter: {get_cache_token()}\",file=file)\n   (_abc_registry,_abc_cache,_abc_negative_cache,\n   _abc_negative_cache_version)=_get_dump(cls)\n   print(f\"_abc_registry: {_abc_registry!r}\",file=file)\n   print(f\"_abc_cache: {_abc_cache!r}\",file=file)\n   print(f\"_abc_negative_cache: {_abc_negative_cache!r}\",file=file)\n   print(f\"_abc_negative_cache_version: {_abc_negative_cache_version!r}\",\n   file=file)\n   \n  def _abc_registry_clear(cls):\n   ''\n   _reset_registry(cls)\n   \n  def _abc_caches_clear(cls):\n   ''\n   _reset_caches(cls)\n   \n   \nclass ABC(metaclass=ABCMeta):\n ''\n\n \n __slots__=()\n", ["_abc", "_py_abc"]],
+    "abc": [".py", "\n\n\n\"\"\"Abstract Base Classes (ABCs) according to PEP 3119.\"\"\"\n\n\ndef abstractmethod(funcobj):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n funcobj.__isabstractmethod__=True\n return funcobj\n \n \nclass abstractclassmethod(classmethod):\n ''\n\n\n \n \n __isabstractmethod__=True\n \n def __init__(self,callable):\n  callable.__isabstractmethod__=True\n  super().__init__(callable)\n  \n  \nclass abstractstaticmethod(staticmethod):\n ''\n\n\n \n \n __isabstractmethod__=True\n \n def __init__(self,callable):\n  callable.__isabstractmethod__=True\n  super().__init__(callable)\n  \n  \nclass abstractproperty(property):\n ''\n\n\n \n \n __isabstractmethod__=True\n \n \ntry :\n from _abc import (get_cache_token,_abc_init,_abc_register,\n _abc_instancecheck,_abc_subclasscheck,_get_dump,\n _reset_registry,_reset_caches)\nexcept ImportError:\n from _py_abc import ABCMeta,get_cache_token\n ABCMeta.__module__='abc'\nelse :\n class ABCMeta(type):\n  ''\n\n\n\n\n\n\n\n\n\n\n  \n  def __new__(mcls,name,bases,namespace,**kwargs):\n   cls=super().__new__(mcls,name,bases,namespace,**kwargs)\n   _abc_init(cls)\n   return cls\n   \n  def register(cls,subclass):\n   ''\n\n\n   \n   return _abc_register(cls,subclass)\n   \n  def __instancecheck__(cls,instance):\n   ''\n   return _abc_instancecheck(cls,instance)\n   \n  def __subclasscheck__(cls,subclass):\n   ''\n   return _abc_subclasscheck(cls,subclass)\n   \n  def _dump_registry(cls,file=None ):\n   ''\n   print(f\"Class: {cls.__module__}.{cls.__qualname__}\",file=file)\n   print(f\"Inv. counter: {get_cache_token()}\",file=file)\n   (_abc_registry,_abc_cache,_abc_negative_cache,\n   _abc_negative_cache_version)=_get_dump(cls)\n   print(f\"_abc_registry: {_abc_registry!r}\",file=file)\n   print(f\"_abc_cache: {_abc_cache!r}\",file=file)\n   print(f\"_abc_negative_cache: {_abc_negative_cache!r}\",file=file)\n   print(f\"_abc_negative_cache_version: {_abc_negative_cache_version!r}\",\n   file=file)\n   \n  def _abc_registry_clear(cls):\n   ''\n   _reset_registry(cls)\n   \n  def _abc_caches_clear(cls):\n   ''\n   _reset_caches(cls)\n   \n   \ndef update_abstractmethods(cls):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n if not hasattr(cls,'__abstractmethods__'):\n \n \n \n  return cls\n  \n abstracts=set()\n \n \n for scls in cls.__bases__:\n  for name in getattr(scls,'__abstractmethods__',()):\n   value=getattr(cls,name,None )\n   if getattr(value,\"__isabstractmethod__\",False ):\n    abstracts.add(name)\n    \n for name,value in cls.__dict__.items():\n  if getattr(value,\"__isabstractmethod__\",False ):\n   abstracts.add(name)\n cls.__abstractmethods__=frozenset(abstracts)\n return cls\n \n \nclass ABC(metaclass=ABCMeta):\n ''\n\n \n __slots__=()\n \n", ["_abc", "_py_abc"]],
     "antigravity": [".py", "\nimport webbrowser\nimport hashlib\n\nwebbrowser.open(\"https://xkcd.com/353/\")\n\ndef geohash(latitude,longitude,datedow):\n ''\n\n\n\n\n \n \n h=hashlib.md5(datedow,usedforsecurity=False ).hexdigest()\n p,q=[('%f'%float.fromhex('0.'+x))for x in (h[:16],h[16:32])]\n print('%d%s %d%s'%(latitude,p[1:],longitude,q[1:]))\n", ["hashlib", "webbrowser"]],
     "argparse": [".py", "\n\n\n\"\"\"Command-line parsing library\n\nThis module is an optparse-inspired command-line parsing library that:\n\n    - handles both optional and positional arguments\n    - produces highly informative usage messages\n    - supports parsers that dispatch to sub-parsers\n\nThe following is a simple usage example that sums integers from the\ncommand-line and writes the result to a file::\n\n    parser = argparse.ArgumentParser(\n        description='sum the integers at the command line')\n    parser.add_argument(\n        'integers', metavar='int', nargs='+', type=int,\n        help='an integer to be summed')\n    parser.add_argument(\n        '--log', default=sys.stdout, type=argparse.FileType('w'),\n        help='the file where the sum should be written')\n    args = parser.parse_args()\n    args.log.write('%s' % sum(args.integers))\n    args.log.close()\n\nThe module contains the following public classes:\n\n    - ArgumentParser -- The main entry point for command-line parsing. As the\n        example above shows, the add_argument() method is used to populate\n        the parser with actions for optional and positional arguments. Then\n        the parse_args() method is invoked to convert the args at the\n        command-line into an object with attributes.\n\n    - ArgumentError -- The exception raised by ArgumentParser objects when\n        there are errors with the parser's actions. Errors raised while\n        parsing the command-line are caught by ArgumentParser and emitted\n        as command-line messages.\n\n    - FileType -- A factory for defining types of files to be created. As the\n        example above shows, instances of FileType are typically passed as\n        the type= argument of add_argument() calls.\n\n    - Action -- The base class for parser actions. Typically actions are\n        selected by passing strings like 'store_true' or 'append_const' to\n        the action= argument of add_argument(). However, for greater\n        customization of ArgumentParser actions, subclasses of Action may\n        be defined and passed as the action= argument.\n\n    - HelpFormatter, RawDescriptionHelpFormatter, RawTextHelpFormatter,\n        ArgumentDefaultsHelpFormatter -- Formatter classes which\n        may be passed as the formatter_class= argument to the\n        ArgumentParser constructor. HelpFormatter is the default,\n        RawDescriptionHelpFormatter and RawTextHelpFormatter tell the parser\n        not to change the formatting for help text, and\n        ArgumentDefaultsHelpFormatter adds information about argument defaults\n        to the help.\n\nAll other classes in this module are considered implementation details.\n(Also note that HelpFormatter and RawDescriptionHelpFormatter are only\nconsidered public as object names -- the API of the formatter objects is\nstill considered an implementation detail.)\n\"\"\"\n\n__version__='1.1'\n__all__=[\n'ArgumentParser',\n'ArgumentError',\n'ArgumentTypeError',\n'BooleanOptionalAction',\n'FileType',\n'HelpFormatter',\n'ArgumentDefaultsHelpFormatter',\n'RawDescriptionHelpFormatter',\n'RawTextHelpFormatter',\n'MetavarTypeHelpFormatter',\n'Namespace',\n'Action',\n'ONE_OR_MORE',\n'OPTIONAL',\n'PARSER',\n'REMAINDER',\n'SUPPRESS',\n'ZERO_OR_MORE',\n]\n\n\nimport os as _os\nimport re as _re\nimport sys as _sys\n\nfrom gettext import gettext as _,ngettext\n\nSUPPRESS='==SUPPRESS=='\n\nOPTIONAL='?'\nZERO_OR_MORE='*'\nONE_OR_MORE='+'\nPARSER='A...'\nREMAINDER='...'\n_UNRECOGNIZED_ARGS_ATTR='_unrecognized_args'\n\n\n\n\n\nclass _AttributeHolder(object):\n ''\n\n\n\n\n\n \n \n def __repr__(self):\n  type_name=type(self).__name__\n  arg_strings=[]\n  star_args={}\n  for arg in self._get_args():\n   arg_strings.append(repr(arg))\n  for name,value in self._get_kwargs():\n   if name.isidentifier():\n    arg_strings.append('%s=%r'%(name,value))\n   else :\n    star_args[name]=value\n  if star_args:\n   arg_strings.append('**%s'%repr(star_args))\n  return '%s(%s)'%(type_name,', '.join(arg_strings))\n  \n def _get_kwargs(self):\n  return list(self.__dict__.items())\n  \n def _get_args(self):\n  return []\n  \n  \ndef _copy_items(items):\n if items is None :\n  return []\n  \n  \n  \n if type(items)is list:\n  return items[:]\n import copy\n return copy.copy(items)\n \n \n \n \n \n \nclass HelpFormatter(object):\n ''\n\n\n\n \n \n def __init__(self,\n prog,\n indent_increment=2,\n max_help_position=24,\n width=None ):\n \n \n  if width is None :\n   import shutil\n   width=shutil.get_terminal_size().columns\n   width -=2\n   \n  self._prog=prog\n  self._indent_increment=indent_increment\n  self._max_help_position=min(max_help_position,\n  max(width -20,indent_increment *2))\n  self._width=width\n  \n  self._current_indent=0\n  self._level=0\n  self._action_max_length=0\n  \n  self._root_section=self._Section(self,None )\n  self._current_section=self._root_section\n  \n  self._whitespace_matcher=_re.compile(r'\\s+',_re.ASCII)\n  self._long_break_matcher=_re.compile(r'\\n\\n\\n+')\n  \n  \n  \n  \n def _indent(self):\n  self._current_indent +=self._indent_increment\n  self._level +=1\n  \n def _dedent(self):\n  self._current_indent -=self._indent_increment\n  assert self._current_indent >=0,'Indent decreased below 0.'\n  self._level -=1\n  \n class _Section(object):\n \n  def __init__(self,formatter,parent,heading=None ):\n   self.formatter=formatter\n   self.parent=parent\n   self.heading=heading\n   self.items=[]\n   \n  def format_help(self):\n  \n   if self.parent is not None :\n    self.formatter._indent()\n   join=self.formatter._join_parts\n   item_help=join([func(*args)for func,args in self.items])\n   if self.parent is not None :\n    self.formatter._dedent()\n    \n    \n   if not item_help:\n    return ''\n    \n    \n   if self.heading is not SUPPRESS and self.heading is not None :\n    current_indent=self.formatter._current_indent\n    heading='%*s%s:\\n'%(current_indent,'',self.heading)\n   else :\n    heading=''\n    \n    \n   return join(['\\n',heading,item_help,'\\n'])\n   \n def _add_item(self,func,args):\n  self._current_section.items.append((func,args))\n  \n  \n  \n  \n def start_section(self,heading):\n  self._indent()\n  section=self._Section(self,self._current_section,heading)\n  self._add_item(section.format_help,[])\n  self._current_section=section\n  \n def end_section(self):\n  self._current_section=self._current_section.parent\n  self._dedent()\n  \n def add_text(self,text):\n  if text is not SUPPRESS and text is not None :\n   self._add_item(self._format_text,[text])\n   \n def add_usage(self,usage,actions,groups,prefix=None ):\n  if usage is not SUPPRESS:\n   args=usage,actions,groups,prefix\n   self._add_item(self._format_usage,args)\n   \n def add_argument(self,action):\n  if action.help is not SUPPRESS:\n  \n  \n   get_invocation=self._format_action_invocation\n   invocations=[get_invocation(action)]\n   for subaction in self._iter_indented_subactions(action):\n    invocations.append(get_invocation(subaction))\n    \n    \n   invocation_length=max(map(len,invocations))\n   action_length=invocation_length+self._current_indent\n   self._action_max_length=max(self._action_max_length,\n   action_length)\n   \n   \n   self._add_item(self._format_action,[action])\n   \n def add_arguments(self,actions):\n  for action in actions:\n   self.add_argument(action)\n   \n   \n   \n   \n def format_help(self):\n  help=self._root_section.format_help()\n  if help:\n   help=self._long_break_matcher.sub('\\n\\n',help)\n   help=help.strip('\\n')+'\\n'\n  return help\n  \n def _join_parts(self,part_strings):\n  return ''.join([part\n  for part in part_strings\n  if part and part is not SUPPRESS])\n  \n def _format_usage(self,usage,actions,groups,prefix):\n  if prefix is None :\n   prefix=_('usage: ')\n   \n   \n  if usage is not None :\n   usage=usage %dict(prog=self._prog)\n   \n   \n  elif usage is None and not actions:\n   usage='%(prog)s'%dict(prog=self._prog)\n   \n   \n  elif usage is None :\n   prog='%(prog)s'%dict(prog=self._prog)\n   \n   \n   optionals=[]\n   positionals=[]\n   for action in actions:\n    if action.option_strings:\n     optionals.append(action)\n    else :\n     positionals.append(action)\n     \n     \n   format=self._format_actions_usage\n   action_usage=format(optionals+positionals,groups)\n   usage=' '.join([s for s in [prog,action_usage]if s])\n   \n   \n   text_width=self._width -self._current_indent\n   if len(prefix)+len(usage)>text_width:\n   \n   \n    part_regexp=(\n    r'\\(.*?\\)+(?=\\s|$)|'\n    r'\\[.*?\\]+(?=\\s|$)|'\n    r'\\S+'\n    )\n    opt_usage=format(optionals,groups)\n    pos_usage=format(positionals,groups)\n    opt_parts=_re.findall(part_regexp,opt_usage)\n    pos_parts=_re.findall(part_regexp,pos_usage)\n    assert ' '.join(opt_parts)==opt_usage\n    assert ' '.join(pos_parts)==pos_usage\n    \n    \n    def get_lines(parts,indent,prefix=None ):\n     lines=[]\n     line=[]\n     if prefix is not None :\n      line_len=len(prefix)-1\n     else :\n      line_len=len(indent)-1\n     for part in parts:\n      if line_len+1+len(part)>text_width and line:\n       lines.append(indent+' '.join(line))\n       line=[]\n       line_len=len(indent)-1\n      line.append(part)\n      line_len +=len(part)+1\n     if line:\n      lines.append(indent+' '.join(line))\n     if prefix is not None :\n      lines[0]=lines[0][len(indent):]\n     return lines\n     \n     \n    if len(prefix)+len(prog)<=0.75 *text_width:\n     indent=' '*(len(prefix)+len(prog)+1)\n     if opt_parts:\n      lines=get_lines([prog]+opt_parts,indent,prefix)\n      lines.extend(get_lines(pos_parts,indent))\n     elif pos_parts:\n      lines=get_lines([prog]+pos_parts,indent,prefix)\n     else :\n      lines=[prog]\n      \n      \n    else :\n     indent=' '*len(prefix)\n     parts=opt_parts+pos_parts\n     lines=get_lines(parts,indent)\n     if len(lines)>1:\n      lines=[]\n      lines.extend(get_lines(opt_parts,indent))\n      lines.extend(get_lines(pos_parts,indent))\n     lines=[prog]+lines\n     \n     \n    usage='\\n'.join(lines)\n    \n    \n  return '%s%s\\n\\n'%(prefix,usage)\n  \n def _format_actions_usage(self,actions,groups):\n \n  group_actions=set()\n  inserts={}\n  for group in groups:\n   try :\n    start=actions.index(group._group_actions[0])\n   except ValueError:\n    continue\n   else :\n    end=start+len(group._group_actions)\n    if actions[start:end]==group._group_actions:\n     for action in group._group_actions:\n      group_actions.add(action)\n     if not group.required:\n      if start in inserts:\n       inserts[start]+=' ['\n      else :\n       inserts[start]='['\n      if end in inserts:\n       inserts[end]+=']'\n      else :\n       inserts[end]=']'\n     else :\n      if start in inserts:\n       inserts[start]+=' ('\n      else :\n       inserts[start]='('\n      if end in inserts:\n       inserts[end]+=')'\n      else :\n       inserts[end]=')'\n     for i in range(start+1,end):\n      inserts[i]='|'\n      \n      \n  parts=[]\n  for i,action in enumerate(actions):\n  \n  \n  \n   if action.help is SUPPRESS:\n    parts.append(None )\n    if inserts.get(i)=='|':\n     inserts.pop(i)\n    elif inserts.get(i+1)=='|':\n     inserts.pop(i+1)\n     \n     \n   elif not action.option_strings:\n    default=self._get_default_metavar_for_positional(action)\n    part=self._format_args(action,default)\n    \n    \n    if action in group_actions:\n     if part[0]=='['and part[-1]==']':\n      part=part[1:-1]\n      \n      \n    parts.append(part)\n    \n    \n   else :\n    option_string=action.option_strings[0]\n    \n    \n    \n    if action.nargs ==0:\n     part=action.format_usage()\n     \n     \n     \n    else :\n     default=self._get_default_metavar_for_optional(action)\n     args_string=self._format_args(action,default)\n     part='%s %s'%(option_string,args_string)\n     \n     \n    if not action.required and action not in group_actions:\n     part='[%s]'%part\n     \n     \n    parts.append(part)\n    \n    \n  for i in sorted(inserts,reverse=True ):\n   parts[i:i]=[inserts[i]]\n   \n   \n  text=' '.join([item for item in parts if item is not None ])\n  \n  \n  open=r'[\\[(]'\n  close=r'[\\])]'\n  text=_re.sub(r'(%s) '%open,r'\\1',text)\n  text=_re.sub(r' (%s)'%close,r'\\1',text)\n  text=_re.sub(r'%s *%s'%(open,close),r'',text)\n  text=_re.sub(r'\\(([^|]*)\\)',r'\\1',text)\n  text=text.strip()\n  \n  \n  return text\n  \n def _format_text(self,text):\n  if '%(prog)'in text:\n   text=text %dict(prog=self._prog)\n  text_width=max(self._width -self._current_indent,11)\n  indent=' '*self._current_indent\n  return self._fill_text(text,text_width,indent)+'\\n\\n'\n  \n def _format_action(self,action):\n \n  help_position=min(self._action_max_length+2,\n  self._max_help_position)\n  help_width=max(self._width -help_position,11)\n  action_width=help_position -self._current_indent -2\n  action_header=self._format_action_invocation(action)\n  \n  \n  if not action.help:\n   tup=self._current_indent,'',action_header\n   action_header='%*s%s\\n'%tup\n   \n   \n  elif len(action_header)<=action_width:\n   tup=self._current_indent,'',action_width,action_header\n   action_header='%*s%-*s  '%tup\n   indent_first=0\n   \n   \n  else :\n   tup=self._current_indent,'',action_header\n   action_header='%*s%s\\n'%tup\n   indent_first=help_position\n   \n   \n  parts=[action_header]\n  \n  \n  if action.help:\n   help_text=self._expand_help(action)\n   help_lines=self._split_lines(help_text,help_width)\n   parts.append('%*s%s\\n'%(indent_first,'',help_lines[0]))\n   for line in help_lines[1:]:\n    parts.append('%*s%s\\n'%(help_position,'',line))\n    \n    \n  elif not action_header.endswith('\\n'):\n   parts.append('\\n')\n   \n   \n  for subaction in self._iter_indented_subactions(action):\n   parts.append(self._format_action(subaction))\n   \n   \n  return self._join_parts(parts)\n  \n def _format_action_invocation(self,action):\n  if not action.option_strings:\n   default=self._get_default_metavar_for_positional(action)\n   metavar,=self._metavar_formatter(action,default)(1)\n   return metavar\n   \n  else :\n   parts=[]\n   \n   \n   \n   if action.nargs ==0:\n    parts.extend(action.option_strings)\n    \n    \n    \n   else :\n    default=self._get_default_metavar_for_optional(action)\n    args_string=self._format_args(action,default)\n    for option_string in action.option_strings:\n     parts.append('%s %s'%(option_string,args_string))\n     \n   return ', '.join(parts)\n   \n def _metavar_formatter(self,action,default_metavar):\n  if action.metavar is not None :\n   result=action.metavar\n  elif action.choices is not None :\n   choice_strs=[str(choice)for choice in action.choices]\n   result='{%s}'%','.join(choice_strs)\n  else :\n   result=default_metavar\n   \n  def format(tuple_size):\n   if isinstance(result,tuple):\n    return result\n   else :\n    return (result,)*tuple_size\n  return format\n  \n def _format_args(self,action,default_metavar):\n  get_metavar=self._metavar_formatter(action,default_metavar)\n  if action.nargs is None :\n   result='%s'%get_metavar(1)\n  elif action.nargs ==OPTIONAL:\n   result='[%s]'%get_metavar(1)\n  elif action.nargs ==ZERO_OR_MORE:\n   metavar=get_metavar(1)\n   if len(metavar)==2:\n    result='[%s [%s ...]]'%metavar\n   else :\n    result='[%s ...]'%metavar\n  elif action.nargs ==ONE_OR_MORE:\n   result='%s [%s ...]'%get_metavar(2)\n  elif action.nargs ==REMAINDER:\n   result='...'\n  elif action.nargs ==PARSER:\n   result='%s ...'%get_metavar(1)\n  elif action.nargs ==SUPPRESS:\n   result=''\n  else :\n   try :\n    formats=['%s'for _ in range(action.nargs)]\n   except TypeError:\n    raise ValueError(\"invalid nargs value\")from None\n   result=' '.join(formats)%get_metavar(action.nargs)\n  return result\n  \n def _expand_help(self,action):\n  params=dict(vars(action),prog=self._prog)\n  for name in list(params):\n   if params[name]is SUPPRESS:\n    del params[name]\n  for name in list(params):\n   if hasattr(params[name],'__name__'):\n    params[name]=params[name].__name__\n  if params.get('choices')is not None :\n   choices_str=', '.join([str(c)for c in params['choices']])\n   params['choices']=choices_str\n  return self._get_help_string(action)%params\n  \n def _iter_indented_subactions(self,action):\n  try :\n   get_subactions=action._get_subactions\n  except AttributeError:\n   pass\n  else :\n   self._indent()\n   yield from get_subactions()\n   self._dedent()\n   \n def _split_lines(self,text,width):\n  text=self._whitespace_matcher.sub(' ',text).strip()\n  \n  \n  import textwrap\n  return textwrap.wrap(text,width)\n  \n def _fill_text(self,text,width,indent):\n  text=self._whitespace_matcher.sub(' ',text).strip()\n  import textwrap\n  return textwrap.fill(text,width,\n  initial_indent=indent,\n  subsequent_indent=indent)\n  \n def _get_help_string(self,action):\n  return action.help\n  \n def _get_default_metavar_for_optional(self,action):\n  return action.dest.upper()\n  \n def _get_default_metavar_for_positional(self,action):\n  return action.dest\n  \n  \nclass RawDescriptionHelpFormatter(HelpFormatter):\n ''\n\n\n\n \n \n def _fill_text(self,text,width,indent):\n  return ''.join(indent+line for line in text.splitlines(keepends=True ))\n  \n  \nclass RawTextHelpFormatter(RawDescriptionHelpFormatter):\n ''\n\n\n\n \n \n def _split_lines(self,text,width):\n  return text.splitlines()\n  \n  \nclass ArgumentDefaultsHelpFormatter(HelpFormatter):\n ''\n\n\n\n \n \n def _get_help_string(self,action):\n  help=action.help\n  if '%(default)'not in action.help:\n   if action.default is not SUPPRESS:\n    defaulting_nargs=[OPTIONAL,ZERO_OR_MORE]\n    if action.option_strings or action.nargs in defaulting_nargs:\n     help +=' (default: %(default)s)'\n  return help\n  \n  \nclass MetavarTypeHelpFormatter(HelpFormatter):\n ''\n\n\n\n\n \n \n def _get_default_metavar_for_optional(self,action):\n  return action.type.__name__\n  \n def _get_default_metavar_for_positional(self,action):\n  return action.type.__name__\n  \n  \n  \n  \n  \n  \n  \ndef _get_action_name(argument):\n if argument is None :\n  return None\n elif argument.option_strings:\n  return '/'.join(argument.option_strings)\n elif argument.metavar not in (None ,SUPPRESS):\n  return argument.metavar\n elif argument.dest not in (None ,SUPPRESS):\n  return argument.dest\n else :\n  return None\n  \n  \nclass ArgumentError(Exception):\n ''\n\n\n\n \n \n def __init__(self,argument,message):\n  self.argument_name=_get_action_name(argument)\n  self.message=message\n  \n def __str__(self):\n  if self.argument_name is None :\n   format='%(message)s'\n  else :\n   format='argument %(argument_name)s: %(message)s'\n  return format %dict(message=self.message,\n  argument_name=self.argument_name)\n  \n  \nclass ArgumentTypeError(Exception):\n ''\n pass\n \n \n \n \n \n \nclass Action(_AttributeHolder):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n def __init__(self,\n option_strings,\n dest,\n nargs=None ,\n const=None ,\n default=None ,\n type=None ,\n choices=None ,\n required=False ,\n help=None ,\n metavar=None ):\n  self.option_strings=option_strings\n  self.dest=dest\n  self.nargs=nargs\n  self.const=const\n  self.default=default\n  self.type=type\n  self.choices=choices\n  self.required=required\n  self.help=help\n  self.metavar=metavar\n  \n def _get_kwargs(self):\n  names=[\n  'option_strings',\n  'dest',\n  'nargs',\n  'const',\n  'default',\n  'type',\n  'choices',\n  'help',\n  'metavar',\n  ]\n  return [(name,getattr(self,name))for name in names]\n  \n def format_usage(self):\n  return self.option_strings[0]\n  \n def __call__(self,parser,namespace,values,option_string=None ):\n  raise NotImplementedError(_('.__call__() not defined'))\n  \nclass BooleanOptionalAction(Action):\n def __init__(self,\n option_strings,\n dest,\n default=None ,\n type=None ,\n choices=None ,\n required=False ,\n help=None ,\n metavar=None ):\n \n  _option_strings=[]\n  for option_string in option_strings:\n   _option_strings.append(option_string)\n   \n   if option_string.startswith('--'):\n    option_string='--no-'+option_string[2:]\n    _option_strings.append(option_string)\n    \n  if help is not None and default is not None :\n   help +=f\" (default: {default})\"\n   \n  super().__init__(\n  option_strings=_option_strings,\n  dest=dest,\n  nargs=0,\n  default=default,\n  type=type,\n  choices=choices,\n  required=required,\n  help=help,\n  metavar=metavar)\n  \n def __call__(self,parser,namespace,values,option_string=None ):\n  if option_string in self.option_strings:\n   setattr(namespace,self.dest,not option_string.startswith('--no-'))\n   \n def format_usage(self):\n  return ' | '.join(self.option_strings)\n  \n  \nclass _StoreAction(Action):\n\n def __init__(self,\n option_strings,\n dest,\n nargs=None ,\n const=None ,\n default=None ,\n type=None ,\n choices=None ,\n required=False ,\n help=None ,\n metavar=None ):\n  if nargs ==0:\n   raise ValueError('nargs for store actions must be != 0; if you '\n   'have nothing to store, actions such as store '\n   'true or store const may be more appropriate')\n  if const is not None and nargs !=OPTIONAL:\n   raise ValueError('nargs must be %r to supply const'%OPTIONAL)\n  super(_StoreAction,self).__init__(\n  option_strings=option_strings,\n  dest=dest,\n  nargs=nargs,\n  const=const,\n  default=default,\n  type=type,\n  choices=choices,\n  required=required,\n  help=help,\n  metavar=metavar)\n  \n def __call__(self,parser,namespace,values,option_string=None ):\n  setattr(namespace,self.dest,values)\n  \n  \nclass _StoreConstAction(Action):\n\n def __init__(self,\n option_strings,\n dest,\n const,\n default=None ,\n required=False ,\n help=None ,\n metavar=None ):\n  super(_StoreConstAction,self).__init__(\n  option_strings=option_strings,\n  dest=dest,\n  nargs=0,\n  const=const,\n  default=default,\n  required=required,\n  help=help)\n  \n def __call__(self,parser,namespace,values,option_string=None ):\n  setattr(namespace,self.dest,self.const)\n  \n  \nclass _StoreTrueAction(_StoreConstAction):\n\n def __init__(self,\n option_strings,\n dest,\n default=False ,\n required=False ,\n help=None ):\n  super(_StoreTrueAction,self).__init__(\n  option_strings=option_strings,\n  dest=dest,\n  const=True ,\n  default=default,\n  required=required,\n  help=help)\n  \n  \nclass _StoreFalseAction(_StoreConstAction):\n\n def __init__(self,\n option_strings,\n dest,\n default=True ,\n required=False ,\n help=None ):\n  super(_StoreFalseAction,self).__init__(\n  option_strings=option_strings,\n  dest=dest,\n  const=False ,\n  default=default,\n  required=required,\n  help=help)\n  \n  \nclass _AppendAction(Action):\n\n def __init__(self,\n option_strings,\n dest,\n nargs=None ,\n const=None ,\n default=None ,\n type=None ,\n choices=None ,\n required=False ,\n help=None ,\n metavar=None ):\n  if nargs ==0:\n   raise ValueError('nargs for append actions must be != 0; if arg '\n   'strings are not supplying the value to append, '\n   'the append const action may be more appropriate')\n  if const is not None and nargs !=OPTIONAL:\n   raise ValueError('nargs must be %r to supply const'%OPTIONAL)\n  super(_AppendAction,self).__init__(\n  option_strings=option_strings,\n  dest=dest,\n  nargs=nargs,\n  const=const,\n  default=default,\n  type=type,\n  choices=choices,\n  required=required,\n  help=help,\n  metavar=metavar)\n  \n def __call__(self,parser,namespace,values,option_string=None ):\n  items=getattr(namespace,self.dest,None )\n  items=_copy_items(items)\n  items.append(values)\n  setattr(namespace,self.dest,items)\n  \n  \nclass _AppendConstAction(Action):\n\n def __init__(self,\n option_strings,\n dest,\n const,\n default=None ,\n required=False ,\n help=None ,\n metavar=None ):\n  super(_AppendConstAction,self).__init__(\n  option_strings=option_strings,\n  dest=dest,\n  nargs=0,\n  const=const,\n  default=default,\n  required=required,\n  help=help,\n  metavar=metavar)\n  \n def __call__(self,parser,namespace,values,option_string=None ):\n  items=getattr(namespace,self.dest,None )\n  items=_copy_items(items)\n  items.append(self.const)\n  setattr(namespace,self.dest,items)\n  \n  \nclass _CountAction(Action):\n\n def __init__(self,\n option_strings,\n dest,\n default=None ,\n required=False ,\n help=None ):\n  super(_CountAction,self).__init__(\n  option_strings=option_strings,\n  dest=dest,\n  nargs=0,\n  default=default,\n  required=required,\n  help=help)\n  \n def __call__(self,parser,namespace,values,option_string=None ):\n  count=getattr(namespace,self.dest,None )\n  if count is None :\n   count=0\n  setattr(namespace,self.dest,count+1)\n  \n  \nclass _HelpAction(Action):\n\n def __init__(self,\n option_strings,\n dest=SUPPRESS,\n default=SUPPRESS,\n help=None ):\n  super(_HelpAction,self).__init__(\n  option_strings=option_strings,\n  dest=dest,\n  default=default,\n  nargs=0,\n  help=help)\n  \n def __call__(self,parser,namespace,values,option_string=None ):\n  parser.print_help()\n  parser.exit()\n  \n  \nclass _VersionAction(Action):\n\n def __init__(self,\n option_strings,\n version=None ,\n dest=SUPPRESS,\n default=SUPPRESS,\n help=\"show program's version number and exit\"):\n  super(_VersionAction,self).__init__(\n  option_strings=option_strings,\n  dest=dest,\n  default=default,\n  nargs=0,\n  help=help)\n  self.version=version\n  \n def __call__(self,parser,namespace,values,option_string=None ):\n  version=self.version\n  if version is None :\n   version=parser.version\n  formatter=parser._get_formatter()\n  formatter.add_text(version)\n  parser._print_message(formatter.format_help(),_sys.stdout)\n  parser.exit()\n  \n  \nclass _SubParsersAction(Action):\n\n class _ChoicesPseudoAction(Action):\n \n  def __init__(self,name,aliases,help):\n   metavar=dest=name\n   if aliases:\n    metavar +=' (%s)'%', '.join(aliases)\n   sup=super(_SubParsersAction._ChoicesPseudoAction,self)\n   sup.__init__(option_strings=[],dest=dest,help=help,\n   metavar=metavar)\n   \n def __init__(self,\n option_strings,\n prog,\n parser_class,\n dest=SUPPRESS,\n required=False ,\n help=None ,\n metavar=None ):\n \n  self._prog_prefix=prog\n  self._parser_class=parser_class\n  self._name_parser_map={}\n  self._choices_actions=[]\n  \n  super(_SubParsersAction,self).__init__(\n  option_strings=option_strings,\n  dest=dest,\n  nargs=PARSER,\n  choices=self._name_parser_map,\n  required=required,\n  help=help,\n  metavar=metavar)\n  \n def add_parser(self,name,**kwargs):\n \n  if kwargs.get('prog')is None :\n   kwargs['prog']='%s %s'%(self._prog_prefix,name)\n   \n  aliases=kwargs.pop('aliases',())\n  \n  \n  if 'help'in kwargs:\n   help=kwargs.pop('help')\n   choice_action=self._ChoicesPseudoAction(name,aliases,help)\n   self._choices_actions.append(choice_action)\n   \n   \n  parser=self._parser_class(**kwargs)\n  self._name_parser_map[name]=parser\n  \n  \n  for alias in aliases:\n   self._name_parser_map[alias]=parser\n   \n  return parser\n  \n def _get_subactions(self):\n  return self._choices_actions\n  \n def __call__(self,parser,namespace,values,option_string=None ):\n  parser_name=values[0]\n  arg_strings=values[1:]\n  \n  \n  if self.dest is not SUPPRESS:\n   setattr(namespace,self.dest,parser_name)\n   \n   \n  try :\n   parser=self._name_parser_map[parser_name]\n  except KeyError:\n   args={'parser_name':parser_name,\n   'choices':', '.join(self._name_parser_map)}\n   msg=_('unknown parser %(parser_name)r (choices: %(choices)s)')%args\n   raise ArgumentError(self,msg)\n   \n   \n   \n   \n   \n   \n   \n   \n  subnamespace,arg_strings=parser.parse_known_args(arg_strings,None )\n  for key,value in vars(subnamespace).items():\n   setattr(namespace,key,value)\n   \n  if arg_strings:\n   vars(namespace).setdefault(_UNRECOGNIZED_ARGS_ATTR,[])\n   getattr(namespace,_UNRECOGNIZED_ARGS_ATTR).extend(arg_strings)\n   \nclass _ExtendAction(_AppendAction):\n def __call__(self,parser,namespace,values,option_string=None ):\n  items=getattr(namespace,self.dest,None )\n  items=_copy_items(items)\n  items.extend(values)\n  setattr(namespace,self.dest,items)\n  \n  \n  \n  \n  \nclass FileType(object):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n def __init__(self,mode='r',bufsize=-1,encoding=None ,errors=None ):\n  self._mode=mode\n  self._bufsize=bufsize\n  self._encoding=encoding\n  self._errors=errors\n  \n def __call__(self,string):\n \n  if string =='-':\n   if 'r'in self._mode:\n    return _sys.stdin\n   elif 'w'in self._mode:\n    return _sys.stdout\n   else :\n    msg=_('argument \"-\" with mode %r')%self._mode\n    raise ValueError(msg)\n    \n    \n  try :\n   return open(string,self._mode,self._bufsize,self._encoding,\n   self._errors)\n  except OSError as e:\n   args={'filename':string,'error':e}\n   message=_(\"can't open '%(filename)s': %(error)s\")\n   raise ArgumentTypeError(message %args)\n   \n def __repr__(self):\n  args=self._mode,self._bufsize\n  kwargs=[('encoding',self._encoding),('errors',self._errors)]\n  args_str=', '.join([repr(arg)for arg in args if arg !=-1]+\n  ['%s=%r'%(kw,arg)for kw,arg in kwargs\n  if arg is not None ])\n  return '%s(%s)'%(type(self).__name__,args_str)\n  \n  \n  \n  \n  \nclass Namespace(_AttributeHolder):\n ''\n\n\n\n \n \n def __init__(self,**kwargs):\n  for name in kwargs:\n   setattr(self,name,kwargs[name])\n   \n def __eq__(self,other):\n  if not isinstance(other,Namespace):\n   return NotImplemented\n  return vars(self)==vars(other)\n  \n def __contains__(self,key):\n  return key in self.__dict__\n  \n  \nclass _ActionsContainer(object):\n\n def __init__(self,\n description,\n prefix_chars,\n argument_default,\n conflict_handler):\n  super(_ActionsContainer,self).__init__()\n  \n  self.description=description\n  self.argument_default=argument_default\n  self.prefix_chars=prefix_chars\n  self.conflict_handler=conflict_handler\n  \n  \n  self._registries={}\n  \n  \n  self.register('action',None ,_StoreAction)\n  self.register('action','store',_StoreAction)\n  self.register('action','store_const',_StoreConstAction)\n  self.register('action','store_true',_StoreTrueAction)\n  self.register('action','store_false',_StoreFalseAction)\n  self.register('action','append',_AppendAction)\n  self.register('action','append_const',_AppendConstAction)\n  self.register('action','count',_CountAction)\n  self.register('action','help',_HelpAction)\n  self.register('action','version',_VersionAction)\n  self.register('action','parsers',_SubParsersAction)\n  self.register('action','extend',_ExtendAction)\n  \n  \n  self._get_handler()\n  \n  \n  self._actions=[]\n  self._option_string_actions={}\n  \n  \n  self._action_groups=[]\n  self._mutually_exclusive_groups=[]\n  \n  \n  self._defaults={}\n  \n  \n  self._negative_number_matcher=_re.compile(r'^-\\d+$|^-\\d*\\.\\d+$')\n  \n  \n  \n  self._has_negative_number_optionals=[]\n  \n  \n  \n  \n def register(self,registry_name,value,object):\n  registry=self._registries.setdefault(registry_name,{})\n  registry[value]=object\n  \n def _registry_get(self,registry_name,value,default=None ):\n  return self._registries[registry_name].get(value,default)\n  \n  \n  \n  \n def set_defaults(self,**kwargs):\n  self._defaults.update(kwargs)\n  \n  \n  \n  for action in self._actions:\n   if action.dest in kwargs:\n    action.default=kwargs[action.dest]\n    \n def get_default(self,dest):\n  for action in self._actions:\n   if action.dest ==dest and action.default is not None :\n    return action.default\n  return self._defaults.get(dest,None )\n  \n  \n  \n  \n  \n def add_argument(self,*args,**kwargs):\n  ''\n\n\n  \n  \n  \n  \n  \n  chars=self.prefix_chars\n  if not args or len(args)==1 and args[0][0]not in chars:\n   if args and 'dest'in kwargs:\n    raise ValueError('dest supplied twice for positional argument')\n   kwargs=self._get_positional_kwargs(*args,**kwargs)\n   \n   \n  else :\n   kwargs=self._get_optional_kwargs(*args,**kwargs)\n   \n   \n  if 'default'not in kwargs:\n   dest=kwargs['dest']\n   if dest in self._defaults:\n    kwargs['default']=self._defaults[dest]\n   elif self.argument_default is not None :\n    kwargs['default']=self.argument_default\n    \n    \n  action_class=self._pop_action_class(kwargs)\n  if not callable(action_class):\n   raise ValueError('unknown action \"%s\"'%(action_class,))\n  action=action_class(**kwargs)\n  \n  \n  type_func=self._registry_get('type',action.type,action.type)\n  if not callable(type_func):\n   raise ValueError('%r is not callable'%(type_func,))\n   \n  if type_func is FileType:\n   raise ValueError('%r is a FileType class object, instance of it'\n   ' must be passed'%(type_func,))\n   \n   \n  if hasattr(self,\"_get_formatter\"):\n   try :\n    self._get_formatter()._format_args(action,None )\n   except TypeError:\n    raise ValueError(\"length of metavar tuple does not match nargs\")\n    \n  return self._add_action(action)\n  \n def add_argument_group(self,*args,**kwargs):\n  group=_ArgumentGroup(self,*args,**kwargs)\n  self._action_groups.append(group)\n  return group\n  \n def add_mutually_exclusive_group(self,**kwargs):\n  group=_MutuallyExclusiveGroup(self,**kwargs)\n  self._mutually_exclusive_groups.append(group)\n  return group\n  \n def _add_action(self,action):\n \n  self._check_conflict(action)\n  \n  \n  self._actions.append(action)\n  action.container=self\n  \n  \n  for option_string in action.option_strings:\n   self._option_string_actions[option_string]=action\n   \n   \n  for option_string in action.option_strings:\n   if self._negative_number_matcher.match(option_string):\n    if not self._has_negative_number_optionals:\n     self._has_negative_number_optionals.append(True )\n     \n     \n  return action\n  \n def _remove_action(self,action):\n  self._actions.remove(action)\n  \n def _add_container_actions(self,container):\n \n  title_group_map={}\n  for group in self._action_groups:\n   if group.title in title_group_map:\n    msg=_('cannot merge actions - two groups are named %r')\n    raise ValueError(msg %(group.title))\n   title_group_map[group.title]=group\n   \n   \n  group_map={}\n  for group in container._action_groups:\n  \n  \n  \n   if group.title not in title_group_map:\n    title_group_map[group.title]=self.add_argument_group(\n    title=group.title,\n    description=group.description,\n    conflict_handler=group.conflict_handler)\n    \n    \n   for action in group._group_actions:\n    group_map[action]=title_group_map[group.title]\n    \n    \n    \n    \n  for group in container._mutually_exclusive_groups:\n   mutex_group=self.add_mutually_exclusive_group(\n   required=group.required)\n   \n   \n   for action in group._group_actions:\n    group_map[action]=mutex_group\n    \n    \n  for action in container._actions:\n   group_map.get(action,self)._add_action(action)\n   \n def _get_positional_kwargs(self,dest,**kwargs):\n \n  if 'required'in kwargs:\n   msg=_(\"'required' is an invalid argument for positionals\")\n   raise TypeError(msg)\n   \n   \n   \n  if kwargs.get('nargs')not in [OPTIONAL,ZERO_OR_MORE]:\n   kwargs['required']=True\n  if kwargs.get('nargs')==ZERO_OR_MORE and 'default'not in kwargs:\n   kwargs['required']=True\n   \n   \n  return dict(kwargs,dest=dest,option_strings=[])\n  \n def _get_optional_kwargs(self,*args,**kwargs):\n \n  option_strings=[]\n  long_option_strings=[]\n  for option_string in args:\n  \n   if not option_string[0]in self.prefix_chars:\n    args={'option':option_string,\n    'prefix_chars':self.prefix_chars}\n    msg=_('invalid option string %(option)r: '\n    'must start with a character %(prefix_chars)r')\n    raise ValueError(msg %args)\n    \n    \n   option_strings.append(option_string)\n   if len(option_string)>1 and option_string[1]in self.prefix_chars:\n    long_option_strings.append(option_string)\n    \n    \n  dest=kwargs.pop('dest',None )\n  if dest is None :\n   if long_option_strings:\n    dest_option_string=long_option_strings[0]\n   else :\n    dest_option_string=option_strings[0]\n   dest=dest_option_string.lstrip(self.prefix_chars)\n   if not dest:\n    msg=_('dest= is required for options like %r')\n    raise ValueError(msg %option_string)\n   dest=dest.replace('-','_')\n   \n   \n  return dict(kwargs,dest=dest,option_strings=option_strings)\n  \n def _pop_action_class(self,kwargs,default=None ):\n  action=kwargs.pop('action',default)\n  return self._registry_get('action',action,action)\n  \n def _get_handler(self):\n \n  handler_func_name='_handle_conflict_%s'%self.conflict_handler\n  try :\n   return getattr(self,handler_func_name)\n  except AttributeError:\n   msg=_('invalid conflict_resolution value: %r')\n   raise ValueError(msg %self.conflict_handler)\n   \n def _check_conflict(self,action):\n \n \n  confl_optionals=[]\n  for option_string in action.option_strings:\n   if option_string in self._option_string_actions:\n    confl_optional=self._option_string_actions[option_string]\n    confl_optionals.append((option_string,confl_optional))\n    \n    \n  if confl_optionals:\n   conflict_handler=self._get_handler()\n   conflict_handler(action,confl_optionals)\n   \n def _handle_conflict_error(self,action,conflicting_actions):\n  message=ngettext('conflicting option string: %s',\n  'conflicting option strings: %s',\n  len(conflicting_actions))\n  conflict_string=', '.join([option_string\n  for option_string,action\n  in conflicting_actions])\n  raise ArgumentError(action,message %conflict_string)\n  \n def _handle_conflict_resolve(self,action,conflicting_actions):\n \n \n  for option_string,action in conflicting_actions:\n  \n  \n   action.option_strings.remove(option_string)\n   self._option_string_actions.pop(option_string,None )\n   \n   \n   \n   if not action.option_strings:\n    action.container._remove_action(action)\n    \n    \nclass _ArgumentGroup(_ActionsContainer):\n\n def __init__(self,container,title=None ,description=None ,**kwargs):\n \n  update=kwargs.setdefault\n  update('conflict_handler',container.conflict_handler)\n  update('prefix_chars',container.prefix_chars)\n  update('argument_default',container.argument_default)\n  super_init=super(_ArgumentGroup,self).__init__\n  super_init(description=description,**kwargs)\n  \n  \n  self.title=title\n  self._group_actions=[]\n  \n  \n  self._registries=container._registries\n  self._actions=container._actions\n  self._option_string_actions=container._option_string_actions\n  self._defaults=container._defaults\n  self._has_negative_number_optionals=\\\n  container._has_negative_number_optionals\n  self._mutually_exclusive_groups=container._mutually_exclusive_groups\n  \n def _add_action(self,action):\n  action=super(_ArgumentGroup,self)._add_action(action)\n  self._group_actions.append(action)\n  return action\n  \n def _remove_action(self,action):\n  super(_ArgumentGroup,self)._remove_action(action)\n  self._group_actions.remove(action)\n  \n  \nclass _MutuallyExclusiveGroup(_ArgumentGroup):\n\n def __init__(self,container,required=False ):\n  super(_MutuallyExclusiveGroup,self).__init__(container)\n  self.required=required\n  self._container=container\n  \n def _add_action(self,action):\n  if action.required:\n   msg=_('mutually exclusive arguments must be optional')\n   raise ValueError(msg)\n  action=self._container._add_action(action)\n  self._group_actions.append(action)\n  return action\n  \n def _remove_action(self,action):\n  self._container._remove_action(action)\n  self._group_actions.remove(action)\n  \n  \nclass ArgumentParser(_AttributeHolder,_ActionsContainer):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n def __init__(self,\n prog=None ,\n usage=None ,\n description=None ,\n epilog=None ,\n parents=[],\n formatter_class=HelpFormatter,\n prefix_chars='-',\n fromfile_prefix_chars=None ,\n argument_default=None ,\n conflict_handler='error',\n add_help=True ,\n allow_abbrev=True ,\n exit_on_error=True ):\n \n  superinit=super(ArgumentParser,self).__init__\n  superinit(description=description,\n  prefix_chars=prefix_chars,\n  argument_default=argument_default,\n  conflict_handler=conflict_handler)\n  \n  \n  if prog is None :\n   prog=_os.path.basename(_sys.argv[0])\n   \n  self.prog=prog\n  self.usage=usage\n  self.epilog=epilog\n  self.formatter_class=formatter_class\n  self.fromfile_prefix_chars=fromfile_prefix_chars\n  self.add_help=add_help\n  self.allow_abbrev=allow_abbrev\n  self.exit_on_error=exit_on_error\n  \n  add_group=self.add_argument_group\n  self._positionals=add_group(_('positional arguments'))\n  self._optionals=add_group(_('optional arguments'))\n  self._subparsers=None\n  \n  \n  def identity(string):\n   return string\n  self.register('type',None ,identity)\n  \n  \n  \n  default_prefix='-'if '-'in prefix_chars else prefix_chars[0]\n  if self.add_help:\n   self.add_argument(\n   default_prefix+'h',default_prefix *2+'help',\n   action='help',default=SUPPRESS,\n   help=_('show this help message and exit'))\n   \n   \n  for parent in parents:\n   self._add_container_actions(parent)\n   try :\n    defaults=parent._defaults\n   except AttributeError:\n    pass\n   else :\n    self._defaults.update(defaults)\n    \n    \n    \n    \n def _get_kwargs(self):\n  names=[\n  'prog',\n  'usage',\n  'description',\n  'formatter_class',\n  'conflict_handler',\n  'add_help',\n  ]\n  return [(name,getattr(self,name))for name in names]\n  \n  \n  \n  \n def add_subparsers(self,**kwargs):\n  if self._subparsers is not None :\n   self.error(_('cannot have multiple subparser arguments'))\n   \n   \n  kwargs.setdefault('parser_class',type(self))\n  \n  if 'title'in kwargs or 'description'in kwargs:\n   title=_(kwargs.pop('title','subcommands'))\n   description=_(kwargs.pop('description',None ))\n   self._subparsers=self.add_argument_group(title,description)\n  else :\n   self._subparsers=self._positionals\n   \n   \n   \n  if kwargs.get('prog')is None :\n   formatter=self._get_formatter()\n   positionals=self._get_positional_actions()\n   groups=self._mutually_exclusive_groups\n   formatter.add_usage(self.usage,positionals,groups,'')\n   kwargs['prog']=formatter.format_help().strip()\n   \n   \n  parsers_class=self._pop_action_class(kwargs,'parsers')\n  action=parsers_class(option_strings=[],**kwargs)\n  self._subparsers._add_action(action)\n  \n  \n  return action\n  \n def _add_action(self,action):\n  if action.option_strings:\n   self._optionals._add_action(action)\n  else :\n   self._positionals._add_action(action)\n  return action\n  \n def _get_optional_actions(self):\n  return [action\n  for action in self._actions\n  if action.option_strings]\n  \n def _get_positional_actions(self):\n  return [action\n  for action in self._actions\n  if not action.option_strings]\n  \n  \n  \n  \n def parse_args(self,args=None ,namespace=None ):\n  args,argv=self.parse_known_args(args,namespace)\n  if argv:\n   msg=_('unrecognized arguments: %s')\n   self.error(msg %' '.join(argv))\n  return args\n  \n def parse_known_args(self,args=None ,namespace=None ):\n  if args is None :\n  \n   args=_sys.argv[1:]\n  else :\n  \n   args=list(args)\n   \n   \n  if namespace is None :\n   namespace=Namespace()\n   \n   \n  for action in self._actions:\n   if action.dest is not SUPPRESS:\n    if not hasattr(namespace,action.dest):\n     if action.default is not SUPPRESS:\n      setattr(namespace,action.dest,action.default)\n      \n      \n  for dest in self._defaults:\n   if not hasattr(namespace,dest):\n    setattr(namespace,dest,self._defaults[dest])\n    \n    \n  if self.exit_on_error:\n   try :\n    namespace,args=self._parse_known_args(args,namespace)\n   except ArgumentError:\n    err=_sys.exc_info()[1]\n    self.error(str(err))\n  else :\n   namespace,args=self._parse_known_args(args,namespace)\n   \n  if hasattr(namespace,_UNRECOGNIZED_ARGS_ATTR):\n   args.extend(getattr(namespace,_UNRECOGNIZED_ARGS_ATTR))\n   delattr(namespace,_UNRECOGNIZED_ARGS_ATTR)\n  return namespace,args\n  \n def _parse_known_args(self,arg_strings,namespace):\n \n  if self.fromfile_prefix_chars is not None :\n   arg_strings=self._read_args_from_files(arg_strings)\n   \n   \n   \n  action_conflicts={}\n  for mutex_group in self._mutually_exclusive_groups:\n   group_actions=mutex_group._group_actions\n   for i,mutex_action in enumerate(mutex_group._group_actions):\n    conflicts=action_conflicts.setdefault(mutex_action,[])\n    conflicts.extend(group_actions[:i])\n    conflicts.extend(group_actions[i+1:])\n    \n    \n    \n    \n  option_string_indices={}\n  arg_string_pattern_parts=[]\n  arg_strings_iter=iter(arg_strings)\n  for i,arg_string in enumerate(arg_strings_iter):\n  \n  \n   if arg_string =='--':\n    arg_string_pattern_parts.append('-')\n    for arg_string in arg_strings_iter:\n     arg_string_pattern_parts.append('A')\n     \n     \n     \n   else :\n    option_tuple=self._parse_optional(arg_string)\n    if option_tuple is None :\n     pattern='A'\n    else :\n     option_string_indices[i]=option_tuple\n     pattern='O'\n    arg_string_pattern_parts.append(pattern)\n    \n    \n  arg_strings_pattern=''.join(arg_string_pattern_parts)\n  \n  \n  seen_actions=set()\n  seen_non_default_actions=set()\n  \n  def take_action(action,argument_strings,option_string=None ):\n   seen_actions.add(action)\n   argument_values=self._get_values(action,argument_strings)\n   \n   \n   \n   \n   if argument_values is not action.default:\n    seen_non_default_actions.add(action)\n    for conflict_action in action_conflicts.get(action,[]):\n     if conflict_action in seen_non_default_actions:\n      msg=_('not allowed with argument %s')\n      action_name=_get_action_name(conflict_action)\n      raise ArgumentError(action,msg %action_name)\n      \n      \n      \n   if argument_values is not SUPPRESS:\n    action(self,namespace,argument_values,option_string)\n    \n    \n  def consume_optional(start_index):\n  \n  \n   option_tuple=option_string_indices[start_index]\n   action,option_string,explicit_arg=option_tuple\n   \n   \n   \n   match_argument=self._match_argument\n   action_tuples=[]\n   while True :\n   \n   \n    if action is None :\n     extras.append(arg_strings[start_index])\n     return start_index+1\n     \n     \n     \n    if explicit_arg is not None :\n     arg_count=match_argument(action,'A')\n     \n     \n     \n     \n     chars=self.prefix_chars\n     if arg_count ==0 and option_string[1]not in chars:\n      action_tuples.append((action,[],option_string))\n      char=option_string[0]\n      option_string=char+explicit_arg[0]\n      new_explicit_arg=explicit_arg[1:]or None\n      optionals_map=self._option_string_actions\n      if option_string in optionals_map:\n       action=optionals_map[option_string]\n       explicit_arg=new_explicit_arg\n      else :\n       msg=_('ignored explicit argument %r')\n       raise ArgumentError(action,msg %explicit_arg)\n       \n       \n       \n     elif arg_count ==1:\n      stop=start_index+1\n      args=[explicit_arg]\n      action_tuples.append((action,args,option_string))\n      break\n      \n      \n      \n     else :\n      msg=_('ignored explicit argument %r')\n      raise ArgumentError(action,msg %explicit_arg)\n      \n      \n      \n      \n    else :\n     start=start_index+1\n     selected_patterns=arg_strings_pattern[start:]\n     arg_count=match_argument(action,selected_patterns)\n     stop=start+arg_count\n     args=arg_strings[start:stop]\n     action_tuples.append((action,args,option_string))\n     break\n     \n     \n     \n   assert action_tuples\n   for action,args,option_string in action_tuples:\n    take_action(action,args,option_string)\n   return stop\n   \n   \n   \n  positionals=self._get_positional_actions()\n  \n  \n  def consume_positionals(start_index):\n  \n   match_partial=self._match_arguments_partial\n   selected_pattern=arg_strings_pattern[start_index:]\n   arg_counts=match_partial(positionals,selected_pattern)\n   \n   \n   \n   for action,arg_count in zip(positionals,arg_counts):\n    args=arg_strings[start_index:start_index+arg_count]\n    start_index +=arg_count\n    take_action(action,args)\n    \n    \n    \n   positionals[:]=positionals[len(arg_counts):]\n   return start_index\n   \n   \n   \n  extras=[]\n  start_index=0\n  if option_string_indices:\n   max_option_string_index=max(option_string_indices)\n  else :\n   max_option_string_index=-1\n  while start_index <=max_option_string_index:\n  \n  \n   next_option_string_index=min([\n   index\n   for index in option_string_indices\n   if index >=start_index])\n   if start_index !=next_option_string_index:\n    positionals_end_index=consume_positionals(start_index)\n    \n    \n    \n    if positionals_end_index >start_index:\n     start_index=positionals_end_index\n     continue\n    else :\n     start_index=positionals_end_index\n     \n     \n     \n   if start_index not in option_string_indices:\n    strings=arg_strings[start_index:next_option_string_index]\n    extras.extend(strings)\n    start_index=next_option_string_index\n    \n    \n   start_index=consume_optional(start_index)\n   \n   \n  stop_index=consume_positionals(start_index)\n  \n  \n  extras.extend(arg_strings[stop_index:])\n  \n  \n  \n  required_actions=[]\n  for action in self._actions:\n   if action not in seen_actions:\n    if action.required:\n     required_actions.append(_get_action_name(action))\n    else :\n    \n    \n    \n    \n     if (action.default is not None and\n     isinstance(action.default,str)and\n     hasattr(namespace,action.dest)and\n     action.default is getattr(namespace,action.dest)):\n      setattr(namespace,action.dest,\n      self._get_value(action,action.default))\n      \n  if required_actions:\n   self.error(_('the following arguments are required: %s')%\n   ', '.join(required_actions))\n   \n   \n  for group in self._mutually_exclusive_groups:\n   if group.required:\n    for action in group._group_actions:\n     if action in seen_non_default_actions:\n      break\n      \n      \n    else :\n     names=[_get_action_name(action)\n     for action in group._group_actions\n     if action.help is not SUPPRESS]\n     msg=_('one of the arguments %s is required')\n     self.error(msg %' '.join(names))\n     \n     \n  return namespace,extras\n  \n def _read_args_from_files(self,arg_strings):\n \n  new_arg_strings=[]\n  for arg_string in arg_strings:\n  \n  \n   if not arg_string or arg_string[0]not in self.fromfile_prefix_chars:\n    new_arg_strings.append(arg_string)\n    \n    \n   else :\n    try :\n     with open(arg_string[1:])as args_file:\n      arg_strings=[]\n      for arg_line in args_file.read().splitlines():\n       for arg in self.convert_arg_line_to_args(arg_line):\n        arg_strings.append(arg)\n      arg_strings=self._read_args_from_files(arg_strings)\n      new_arg_strings.extend(arg_strings)\n    except OSError:\n     err=_sys.exc_info()[1]\n     self.error(str(err))\n     \n     \n  return new_arg_strings\n  \n def convert_arg_line_to_args(self,arg_line):\n  return [arg_line]\n  \n def _match_argument(self,action,arg_strings_pattern):\n \n  nargs_pattern=self._get_nargs_pattern(action)\n  match=_re.match(nargs_pattern,arg_strings_pattern)\n  \n  \n  if match is None :\n   nargs_errors={\n   None :_('expected one argument'),\n   OPTIONAL:_('expected at most one argument'),\n   ONE_OR_MORE:_('expected at least one argument'),\n   }\n   msg=nargs_errors.get(action.nargs)\n   if msg is None :\n    msg=ngettext('expected %s argument',\n    'expected %s arguments',\n    action.nargs)%action.nargs\n   raise ArgumentError(action,msg)\n   \n   \n  return len(match.group(1))\n  \n def _match_arguments_partial(self,actions,arg_strings_pattern):\n \n \n  result=[]\n  for i in range(len(actions),0,-1):\n   actions_slice=actions[:i]\n   pattern=''.join([self._get_nargs_pattern(action)\n   for action in actions_slice])\n   match=_re.match(pattern,arg_strings_pattern)\n   if match is not None :\n    result.extend([len(string)for string in match.groups()])\n    break\n    \n    \n  return result\n  \n def _parse_optional(self,arg_string):\n \n  if not arg_string:\n   return None\n   \n   \n  if not arg_string[0]in self.prefix_chars:\n   return None\n   \n   \n  if arg_string in self._option_string_actions:\n   action=self._option_string_actions[arg_string]\n   return action,arg_string,None\n   \n   \n  if len(arg_string)==1:\n   return None\n   \n   \n  if '='in arg_string:\n   option_string,explicit_arg=arg_string.split('=',1)\n   if option_string in self._option_string_actions:\n    action=self._option_string_actions[option_string]\n    return action,option_string,explicit_arg\n    \n    \n    \n  option_tuples=self._get_option_tuples(arg_string)\n  \n  \n  if len(option_tuples)>1:\n   options=', '.join([option_string\n   for action,option_string,explicit_arg in option_tuples])\n   args={'option':arg_string,'matches':options}\n   msg=_('ambiguous option: %(option)s could match %(matches)s')\n   self.error(msg %args)\n   \n   \n   \n  elif len(option_tuples)==1:\n   option_tuple,=option_tuples\n   return option_tuple\n   \n   \n   \n   \n  if self._negative_number_matcher.match(arg_string):\n   if not self._has_negative_number_optionals:\n    return None\n    \n    \n  if ' 'in arg_string:\n   return None\n   \n   \n   \n  return None ,arg_string,None\n  \n def _get_option_tuples(self,option_string):\n  result=[]\n  \n  \n  \n  chars=self.prefix_chars\n  if option_string[0]in chars and option_string[1]in chars:\n   if self.allow_abbrev:\n    if '='in option_string:\n     option_prefix,explicit_arg=option_string.split('=',1)\n    else :\n     option_prefix=option_string\n     explicit_arg=None\n    for option_string in self._option_string_actions:\n     if option_string.startswith(option_prefix):\n      action=self._option_string_actions[option_string]\n      tup=action,option_string,explicit_arg\n      result.append(tup)\n      \n      \n      \n      \n  elif option_string[0]in chars and option_string[1]not in chars:\n   option_prefix=option_string\n   explicit_arg=None\n   short_option_prefix=option_string[:2]\n   short_explicit_arg=option_string[2:]\n   \n   for option_string in self._option_string_actions:\n    if option_string ==short_option_prefix:\n     action=self._option_string_actions[option_string]\n     tup=action,option_string,short_explicit_arg\n     result.append(tup)\n    elif option_string.startswith(option_prefix):\n     action=self._option_string_actions[option_string]\n     tup=action,option_string,explicit_arg\n     result.append(tup)\n     \n     \n  else :\n   self.error(_('unexpected option string: %s')%option_string)\n   \n   \n  return result\n  \n def _get_nargs_pattern(self,action):\n \n \n  nargs=action.nargs\n  \n  \n  if nargs is None :\n   nargs_pattern='(-*A-*)'\n   \n   \n  elif nargs ==OPTIONAL:\n   nargs_pattern='(-*A?-*)'\n   \n   \n  elif nargs ==ZERO_OR_MORE:\n   nargs_pattern='(-*[A-]*)'\n   \n   \n  elif nargs ==ONE_OR_MORE:\n   nargs_pattern='(-*A[A-]*)'\n   \n   \n  elif nargs ==REMAINDER:\n   nargs_pattern='([-AO]*)'\n   \n   \n  elif nargs ==PARSER:\n   nargs_pattern='(-*A[-AO]*)'\n   \n   \n  elif nargs ==SUPPRESS:\n   nargs_pattern='(-*-*)'\n   \n   \n  else :\n   nargs_pattern='(-*%s-*)'%'-*'.join('A'*nargs)\n   \n   \n  if action.option_strings:\n   nargs_pattern=nargs_pattern.replace('-*','')\n   nargs_pattern=nargs_pattern.replace('-','')\n   \n   \n  return nargs_pattern\n  \n  \n  \n  \n  \n def parse_intermixed_args(self,args=None ,namespace=None ):\n  args,argv=self.parse_known_intermixed_args(args,namespace)\n  if argv:\n   msg=_('unrecognized arguments: %s')\n   self.error(msg %' '.join(argv))\n  return args\n  \n def parse_known_intermixed_args(self,args=None ,namespace=None ):\n \n \n \n \n \n \n \n \n \n \n \n \n  positionals=self._get_positional_actions()\n  a=[action for action in positionals\n  if action.nargs in [PARSER,REMAINDER]]\n  if a:\n   raise TypeError('parse_intermixed_args: positional arg'\n   ' with nargs=%s'%a[0].nargs)\n   \n  if [action.dest for group in self._mutually_exclusive_groups\n  for action in group._group_actions if action in positionals]:\n   raise TypeError('parse_intermixed_args: positional in'\n   ' mutuallyExclusiveGroup')\n   \n  try :\n   save_usage=self.usage\n   try :\n    if self.usage is None :\n    \n     self.usage=self.format_usage()[7:]\n    for action in positionals:\n    \n     action.save_nargs=action.nargs\n     \n     action.nargs=SUPPRESS\n     action.save_default=action.default\n     action.default=SUPPRESS\n    namespace,remaining_args=self.parse_known_args(args,\n    namespace)\n    for action in positionals:\n    \n     if (hasattr(namespace,action.dest)\n     and getattr(namespace,action.dest)==[]):\n      from warnings import warn\n      warn('Do not expect %s in %s'%(action.dest,namespace))\n      delattr(namespace,action.dest)\n   finally :\n   \n    for action in positionals:\n     action.nargs=action.save_nargs\n     action.default=action.save_default\n   optionals=self._get_optional_actions()\n   try :\n   \n   \n    for action in optionals:\n     action.save_required=action.required\n     action.required=False\n    for group in self._mutually_exclusive_groups:\n     group.save_required=group.required\n     group.required=False\n    namespace,extras=self.parse_known_args(remaining_args,\n    namespace)\n   finally :\n   \n    for action in optionals:\n     action.required=action.save_required\n    for group in self._mutually_exclusive_groups:\n     group.required=group.save_required\n  finally :\n   self.usage=save_usage\n  return namespace,extras\n  \n  \n  \n  \n def _get_values(self,action,arg_strings):\n \n  if action.nargs not in [PARSER,REMAINDER]:\n   try :\n    arg_strings.remove('--')\n   except ValueError:\n    pass\n    \n    \n  if not arg_strings and action.nargs ==OPTIONAL:\n   if action.option_strings:\n    value=action.const\n   else :\n    value=action.default\n   if isinstance(value,str):\n    value=self._get_value(action,value)\n    self._check_value(action,value)\n    \n    \n    \n  elif (not arg_strings and action.nargs ==ZERO_OR_MORE and\n  not action.option_strings):\n   if action.default is not None :\n    value=action.default\n   else :\n    value=arg_strings\n   self._check_value(action,value)\n   \n   \n  elif len(arg_strings)==1 and action.nargs in [None ,OPTIONAL]:\n   arg_string,=arg_strings\n   value=self._get_value(action,arg_string)\n   self._check_value(action,value)\n   \n   \n  elif action.nargs ==REMAINDER:\n   value=[self._get_value(action,v)for v in arg_strings]\n   \n   \n  elif action.nargs ==PARSER:\n   value=[self._get_value(action,v)for v in arg_strings]\n   self._check_value(action,value[0])\n   \n   \n  elif action.nargs ==SUPPRESS:\n   value=SUPPRESS\n   \n   \n  else :\n   value=[self._get_value(action,v)for v in arg_strings]\n   for v in value:\n    self._check_value(action,v)\n    \n    \n  return value\n  \n def _get_value(self,action,arg_string):\n  type_func=self._registry_get('type',action.type,action.type)\n  if not callable(type_func):\n   msg=_('%r is not callable')\n   raise ArgumentError(action,msg %type_func)\n   \n   \n  try :\n   result=type_func(arg_string)\n   \n   \n  except ArgumentTypeError:\n   name=getattr(action.type,'__name__',repr(action.type))\n   msg=str(_sys.exc_info()[1])\n   raise ArgumentError(action,msg)\n   \n   \n  except (TypeError,ValueError):\n   name=getattr(action.type,'__name__',repr(action.type))\n   args={'type':name,'value':arg_string}\n   msg=_('invalid %(type)s value: %(value)r')\n   raise ArgumentError(action,msg %args)\n   \n   \n  return result\n  \n def _check_value(self,action,value):\n \n  if action.choices is not None and value not in action.choices:\n   args={'value':value,\n   'choices':', '.join(map(repr,action.choices))}\n   msg=_('invalid choice: %(value)r (choose from %(choices)s)')\n   raise ArgumentError(action,msg %args)\n   \n   \n   \n   \n def format_usage(self):\n  formatter=self._get_formatter()\n  formatter.add_usage(self.usage,self._actions,\n  self._mutually_exclusive_groups)\n  return formatter.format_help()\n  \n def format_help(self):\n  formatter=self._get_formatter()\n  \n  \n  formatter.add_usage(self.usage,self._actions,\n  self._mutually_exclusive_groups)\n  \n  \n  formatter.add_text(self.description)\n  \n  \n  for action_group in self._action_groups:\n   formatter.start_section(action_group.title)\n   formatter.add_text(action_group.description)\n   formatter.add_arguments(action_group._group_actions)\n   formatter.end_section()\n   \n   \n  formatter.add_text(self.epilog)\n  \n  \n  return formatter.format_help()\n  \n def _get_formatter(self):\n  return self.formatter_class(prog=self.prog)\n  \n  \n  \n  \n def print_usage(self,file=None ):\n  if file is None :\n   file=_sys.stdout\n  self._print_message(self.format_usage(),file)\n  \n def print_help(self,file=None ):\n  if file is None :\n   file=_sys.stdout\n  self._print_message(self.format_help(),file)\n  \n def _print_message(self,message,file=None ):\n  if message:\n   if file is None :\n    file=_sys.stderr\n   file.write(message)\n   \n   \n   \n   \n def exit(self,status=0,message=None ):\n  if message:\n   self._print_message(message,_sys.stderr)\n  _sys.exit(status)\n  \n def error(self,message):\n  ''\n\n\n\n\n\n\n  \n  self.print_usage(_sys.stderr)\n  args={'prog':self.prog,'message':message}\n  self.exit(2,_('%(prog)s: error: %(message)s\\n')%args)\n", ["copy", "gettext", "os", "re", "shutil", "sys", "textwrap", "warnings"]],
     "atexit": [".py", "''\n\n\n\n\n\nclass __loader__(object):\n pass\n \ndef _clear(*args,**kw):\n ''\n \n pass\n \ndef _run_exitfuncs(*args,**kw):\n ''\n \n pass\n \ndef register(*args,**kw):\n ''\n\n\n\n\n\n\n \n pass\n \ndef unregister(*args,**kw):\n ''\n\n\n\n \n pass\n", []],
     "base64": [".py", "#! /usr/bin/env python3\n\n\"\"\"Base16, Base32, Base64 (RFC 3548), Base85 and Ascii85 data encodings\"\"\"\n\n\n\n\n\nimport re\nimport struct\nimport binascii\n\n\n__all__=[\n\n'encode','decode','encodebytes','decodebytes',\n\n'b64encode','b64decode','b32encode','b32decode',\n'b16encode','b16decode',\n\n'b85encode','b85decode','a85encode','a85decode',\n\n'standard_b64encode','standard_b64decode',\n\n\n\n\n'urlsafe_b64encode','urlsafe_b64decode',\n]\n\n\nbytes_types=(bytes,bytearray)\n\ndef _bytes_from_decode_data(s):\n if isinstance(s,str):\n  try :\n   return s.encode('ascii')\n  except UnicodeEncodeError:\n   raise ValueError('string argument should contain only ASCII characters')\n if isinstance(s,bytes_types):\n  return s\n try :\n  return memoryview(s).tobytes()\n except TypeError:\n  raise TypeError(\"argument should be a bytes-like object or ASCII \"\n  \"string, not %r\"%s.__class__.__name__)from None\n  \n  \n  \n  \ndef b64encode(s,altchars=None ):\n ''\n\n\n\n\n \n encoded=binascii.b2a_base64(s,newline=False )\n if altchars is not None :\n  assert len(altchars)==2,repr(altchars)\n  return encoded.translate(bytes.maketrans(b'+/',altchars))\n return encoded\n \n \ndef b64decode(s,altchars=None ,validate=False ):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n \n s=_bytes_from_decode_data(s)\n if altchars is not None :\n  altchars=_bytes_from_decode_data(altchars)\n  assert len(altchars)==2,repr(altchars)\n  s=s.translate(bytes.maketrans(altchars,b'+/'))\n if validate and not re.fullmatch(b'[A-Za-z0-9+/]*={0,2}',s):\n  raise binascii.Error('Non-base64 digit found')\n return binascii.a2b_base64(s)\n \n \ndef standard_b64encode(s):\n ''\n\n\n \n return b64encode(s)\n \ndef standard_b64decode(s):\n ''\n\n\n\n\n\n \n return b64decode(s)\n \n \n_urlsafe_encode_translation=bytes.maketrans(b'+/',b'-_')\n_urlsafe_decode_translation=bytes.maketrans(b'-_',b'+/')\n\ndef urlsafe_b64encode(s):\n ''\n\n\n\n\n \n return b64encode(s).translate(_urlsafe_encode_translation)\n \ndef urlsafe_b64decode(s):\n ''\n\n\n\n\n\n\n\n\n \n s=_bytes_from_decode_data(s)\n s=s.translate(_urlsafe_decode_translation)\n return b64decode(s)\n \n \n \n \n_b32alphabet=b'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'\n_b32tab2=None\n_b32rev=None\n\ndef b32encode(s):\n ''\n \n global _b32tab2\n \n \n if _b32tab2 is None :\n  b32tab=[bytes((i,))for i in _b32alphabet]\n  _b32tab2=[a+b for a in b32tab for b in b32tab]\n  b32tab=None\n  \n if not isinstance(s,bytes_types):\n  s=memoryview(s).tobytes()\n leftover=len(s)%5\n \n if leftover:\n  s=s+b'\\0'*(5 -leftover)\n encoded=bytearray()\n from_bytes=int.from_bytes\n b32tab2=_b32tab2\n for i in range(0,len(s),5):\n  c=from_bytes(s[i:i+5],'big')\n  encoded +=(b32tab2[c >>30]+\n  b32tab2[(c >>20)&0x3ff]+\n  b32tab2[(c >>10)&0x3ff]+\n  b32tab2[c&0x3ff]\n  )\n  \n if leftover ==1:\n  encoded[-6:]=b'======'\n elif leftover ==2:\n  encoded[-4:]=b'===='\n elif leftover ==3:\n  encoded[-3:]=b'==='\n elif leftover ==4:\n  encoded[-1:]=b'='\n return bytes(encoded)\n \ndef b32decode(s,casefold=False ,map01=None ):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n global _b32rev\n \n \n if _b32rev is None :\n  _b32rev={v:k for k,v in enumerate(_b32alphabet)}\n s=_bytes_from_decode_data(s)\n if len(s)%8:\n  raise binascii.Error('Incorrect padding')\n  \n  \n  \n if map01 is not None :\n  map01=_bytes_from_decode_data(map01)\n  assert len(map01)==1,repr(map01)\n  s=s.translate(bytes.maketrans(b'01',b'O'+map01))\n if casefold:\n  s=s.upper()\n  \n  \n  \n l=len(s)\n s=s.rstrip(b'=')\n padchars=l -len(s)\n \n decoded=bytearray()\n b32rev=_b32rev\n for i in range(0,len(s),8):\n  quanta=s[i:i+8]\n  acc=0\n  try :\n   for c in quanta:\n    acc=(acc <<5)+b32rev[c]\n  except KeyError:\n   raise binascii.Error('Non-base32 digit found')from None\n  decoded +=acc.to_bytes(5,'big')\n  \n if l %8 or padchars not in {0,1,3,4,6}:\n  raise binascii.Error('Incorrect padding')\n if padchars and decoded:\n  acc <<=5 *padchars\n  last=acc.to_bytes(5,'big')\n  leftover=(43 -5 *padchars)//8\n  decoded[-5:]=last[:leftover]\n return bytes(decoded)\n \n \n \n \n \ndef b16encode(s):\n ''\n \n return binascii.hexlify(s).upper()\n \n \ndef b16decode(s,casefold=False ):\n ''\n\n\n\n\n\n\n\n \n s=_bytes_from_decode_data(s)\n if casefold:\n  s=s.upper()\n if re.search(b'[^0-9A-F]',s):\n  raise binascii.Error('Non-base16 digit found')\n return binascii.unhexlify(s)\n \n \n \n \n \n_a85chars=None\n_a85chars2=None\n_A85START=b\"<~\"\n_A85END=b\"~>\"\n\ndef _85encode(b,chars,chars2,pad=False ,foldnuls=False ,foldspaces=False ):\n\n if not isinstance(b,bytes_types):\n  b=memoryview(b).tobytes()\n  \n padding=(-len(b))%4\n if padding:\n  b=b+b'\\0'*padding\n words=struct.Struct('!%dI'%(len(b)//4)).unpack(b)\n \n chunks=[b'z'if foldnuls and not word else\n b'y'if foldspaces and word ==0x20202020 else\n (chars2[word //614125]+\n chars2[word //85 %7225]+\n chars[word %85])\n for word in words]\n \n if padding and not pad:\n  if chunks[-1]==b'z':\n   chunks[-1]=chars[0]*5\n  chunks[-1]=chunks[-1][:-padding]\n  \n return b''.join(chunks)\n \ndef a85encode(b,*,foldspaces=False ,wrapcol=0,pad=False ,adobe=False ):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n global _a85chars,_a85chars2\n \n \n if _a85chars is None :\n  _a85chars=[bytes((i,))for i in range(33,118)]\n  _a85chars2=[(a+b)for a in _a85chars for b in _a85chars]\n  \n result=_85encode(b,_a85chars,_a85chars2,pad,True ,foldspaces)\n \n if adobe:\n  result=_A85START+result\n if wrapcol:\n  wrapcol=max(2 if adobe else 1,wrapcol)\n  chunks=[result[i:i+wrapcol]\n  for i in range(0,len(result),wrapcol)]\n  if adobe:\n   if len(chunks[-1])+2 >wrapcol:\n    chunks.append(b'')\n  result=b'\\n'.join(chunks)\n if adobe:\n  result +=_A85END\n  \n return result\n \ndef a85decode(b,*,foldspaces=False ,adobe=False ,ignorechars=b' \\t\\n\\r\\v'):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n b=_bytes_from_decode_data(b)\n if adobe:\n  if not b.endswith(_A85END):\n   raise ValueError(\n   \"Ascii85 encoded byte sequences must end \"\n   \"with {!r}\".format(_A85END)\n   )\n  if b.startswith(_A85START):\n   b=b[2:-2]\n  else :\n   b=b[:-2]\n   \n   \n   \n   \n packI=struct.Struct('!I').pack\n decoded=[]\n decoded_append=decoded.append\n curr=[]\n curr_append=curr.append\n curr_clear=curr.clear\n for x in b+b'u'*4:\n  if b'!'[0]<=x <=b'u'[0]:\n   curr_append(x)\n   if len(curr)==5:\n    acc=0\n    for x in curr:\n     acc=85 *acc+(x -33)\n    try :\n     decoded_append(packI(acc))\n    except struct.error:\n     raise ValueError('Ascii85 overflow')from None\n    curr_clear()\n  elif x ==b'z'[0]:\n   if curr:\n    raise ValueError('z inside Ascii85 5-tuple')\n   decoded_append(b'\\0\\0\\0\\0')\n  elif foldspaces and x ==b'y'[0]:\n   if curr:\n    raise ValueError('y inside Ascii85 5-tuple')\n   decoded_append(b'\\x20\\x20\\x20\\x20')\n  elif x in ignorechars:\n  \n   continue\n  else :\n   raise ValueError('Non-Ascii85 digit found: %c'%x)\n   \n result=b''.join(decoded)\n padding=4 -len(curr)\n if padding:\n \n  result=result[:-padding]\n return result\n \n \n \n_b85alphabet=(b\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\nb\"abcdefghijklmnopqrstuvwxyz!#$%&()*+-;<=>?@^_`{|}~\")\n_b85chars=None\n_b85chars2=None\n_b85dec=None\n\ndef b85encode(b,pad=False ):\n ''\n\n\n\n \n global _b85chars,_b85chars2\n \n \n if _b85chars is None :\n  _b85chars=[bytes((i,))for i in _b85alphabet]\n  _b85chars2=[(a+b)for a in _b85chars for b in _b85chars]\n return _85encode(b,_b85chars,_b85chars2,pad)\n \ndef b85decode(b):\n ''\n\n\n \n global _b85dec\n \n \n if _b85dec is None :\n  _b85dec=[None ]*256\n  for i,c in enumerate(_b85alphabet):\n   _b85dec[c]=i\n   \n b=_bytes_from_decode_data(b)\n padding=(-len(b))%5\n b=b+b'~'*padding\n out=[]\n packI=struct.Struct('!I').pack\n for i in range(0,len(b),5):\n  chunk=b[i:i+5]\n  acc=0\n  try :\n   for c in chunk:\n    acc=acc *85+_b85dec[c]\n  except TypeError:\n   for j,c in enumerate(chunk):\n    if _b85dec[c]is None :\n     raise ValueError('bad base85 character at position %d'\n     %(i+j))from None\n   raise\n  try :\n   out.append(packI(acc))\n  except struct.error:\n   raise ValueError('base85 overflow in hunk starting at byte %d'\n   %i)from None\n   \n result=b''.join(out)\n if padding:\n  result=result[:-padding]\n return result\n \n \n \n \n \nMAXLINESIZE=76\nMAXBINSIZE=(MAXLINESIZE //4)*3\n\ndef encode(input,output):\n ''\n while True :\n  s=input.read(MAXBINSIZE)\n  if not s:\n   break\n  while len(s)<MAXBINSIZE:\n   ns=input.read(MAXBINSIZE -len(s))\n   if not ns:\n    break\n   s +=ns\n  line=binascii.b2a_base64(s)\n  output.write(line)\n  \n  \ndef decode(input,output):\n ''\n while True :\n  line=input.readline()\n  if not line:\n   break\n  s=binascii.a2b_base64(line)\n  output.write(s)\n  \ndef _input_type_check(s):\n try :\n  m=memoryview(s)\n except TypeError as err:\n  msg=\"expected bytes-like object, not %s\"%s.__class__.__name__\n  raise TypeError(msg)from err\n if m.format not in ('c','b','B'):\n  msg=(\"expected single byte elements, not %r from %s\"%\n  (m.format,s.__class__.__name__))\n  raise TypeError(msg)\n if m.ndim !=1:\n  msg=(\"expected 1-D data, not %d-D data from %s\"%\n  (m.ndim,s.__class__.__name__))\n  raise TypeError(msg)\n  \n  \ndef encodebytes(s):\n ''\n \n _input_type_check(s)\n pieces=[]\n for i in range(0,len(s),MAXBINSIZE):\n  chunk=s[i:i+MAXBINSIZE]\n  pieces.append(binascii.b2a_base64(chunk))\n return b\"\".join(pieces)\n \n \ndef decodebytes(s):\n ''\n _input_type_check(s)\n return binascii.a2b_base64(s)\n \n \n \ndef main():\n ''\n import sys,getopt\n try :\n  opts,args=getopt.getopt(sys.argv[1:],'deut')\n except getopt.error as msg:\n  sys.stdout=sys.stderr\n  print(msg)\n  print(\"\"\"usage: %s [-d|-e|-u|-t] [file|-]\n        -d, -u: decode\n        -e: encode (default)\n        -t: encode and decode string 'Aladdin:open sesame'\"\"\"%sys.argv[0])\n  sys.exit(2)\n func=encode\n for o,a in opts:\n  if o =='-e':func=encode\n  if o =='-d':func=decode\n  if o =='-u':func=decode\n  if o =='-t':test();return\n if args and args[0]!='-':\n  with open(args[0],'rb')as f:\n   func(f,sys.stdout.buffer)\n else :\n  func(sys.stdin.buffer,sys.stdout.buffer)\n  \n  \ndef test():\n s0=b\"Aladdin:open sesame\"\n print(repr(s0))\n s1=encodebytes(s0)\n print(repr(s1))\n s2=decodebytes(s1)\n print(repr(s2))\n assert s0 ==s2\n \n \nif __name__ =='__main__':\n main()\n", ["binascii", "getopt", "re", "struct", "sys"]],
     "bdb": [".py", "''\n\nimport fnmatch\nimport sys\nimport os\nfrom inspect import CO_GENERATOR,CO_COROUTINE,CO_ASYNC_GENERATOR\n\n__all__=[\"BdbQuit\",\"Bdb\",\"Breakpoint\"]\n\nGENERATOR_AND_COROUTINE_FLAGS=CO_GENERATOR |CO_COROUTINE |CO_ASYNC_GENERATOR\n\n\nclass BdbQuit(Exception):\n ''\n \n \nclass Bdb:\n ''\n\n\n\n\n\n\n\n\n\n\n \n \n def __init__(self,skip=None ):\n  self.skip=set(skip)if skip else None\n  self.breaks={}\n  self.fncache={}\n  self.frame_returning=None\n  \n def canonic(self,filename):\n  ''\n\n\n\n\n\n  \n  if filename ==\"<\"+filename[1:-1]+\">\":\n   return filename\n  canonic=self.fncache.get(filename)\n  if not canonic:\n   canonic=os.path.abspath(filename)\n   canonic=os.path.normcase(canonic)\n   self.fncache[filename]=canonic\n  return canonic\n  \n def reset(self):\n  ''\n  import linecache\n  linecache.checkcache()\n  self.botframe=None\n  self._set_stopinfo(None ,None )\n  \n def trace_dispatch(self,frame,event,arg):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  if self.quitting:\n   return\n  if event =='line':\n   return self.dispatch_line(frame)\n  if event =='call':\n   return self.dispatch_call(frame,arg)\n  if event =='return':\n   return self.dispatch_return(frame,arg)\n  if event =='exception':\n   return self.dispatch_exception(frame,arg)\n  if event =='c_call':\n   return self.trace_dispatch\n  if event =='c_exception':\n   return self.trace_dispatch\n  if event =='c_return':\n   return self.trace_dispatch\n  print('bdb.Bdb.dispatch: unknown debugging event:',repr(event))\n  return self.trace_dispatch\n  \n def dispatch_line(self,frame):\n  ''\n\n\n\n\n  \n  if self.stop_here(frame)or self.break_here(frame):\n   self.user_line(frame)\n   if self.quitting:raise BdbQuit\n  return self.trace_dispatch\n  \n def dispatch_call(self,frame,arg):\n  ''\n\n\n\n\n  \n  \n  if self.botframe is None :\n  \n   self.botframe=frame.f_back\n   return self.trace_dispatch\n  if not (self.stop_here(frame)or self.break_anywhere(frame)):\n  \n   return\n   \n  if self.stopframe and frame.f_code.co_flags&GENERATOR_AND_COROUTINE_FLAGS:\n   return self.trace_dispatch\n  self.user_call(frame,arg)\n  if self.quitting:raise BdbQuit\n  return self.trace_dispatch\n  \n def dispatch_return(self,frame,arg):\n  ''\n\n\n\n\n  \n  if self.stop_here(frame)or frame ==self.returnframe:\n  \n   if self.stopframe and frame.f_code.co_flags&GENERATOR_AND_COROUTINE_FLAGS:\n    return self.trace_dispatch\n   try :\n    self.frame_returning=frame\n    self.user_return(frame,arg)\n   finally :\n    self.frame_returning=None\n   if self.quitting:raise BdbQuit\n   \n   if self.stopframe is frame and self.stoplineno !=-1:\n    self._set_stopinfo(None ,None )\n  return self.trace_dispatch\n  \n def dispatch_exception(self,frame,arg):\n  ''\n\n\n\n\n  \n  if self.stop_here(frame):\n  \n  \n  \n   if not (frame.f_code.co_flags&GENERATOR_AND_COROUTINE_FLAGS\n   and arg[0]is StopIteration and arg[2]is None ):\n    self.user_exception(frame,arg)\n    if self.quitting:raise BdbQuit\n    \n    \n    \n    \n  elif (self.stopframe and frame is not self.stopframe\n  and self.stopframe.f_code.co_flags&GENERATOR_AND_COROUTINE_FLAGS\n  and arg[0]in (StopIteration,GeneratorExit)):\n   self.user_exception(frame,arg)\n   if self.quitting:raise BdbQuit\n   \n  return self.trace_dispatch\n  \n  \n  \n  \n  \n def is_skipped_module(self,module_name):\n  ''\n  if module_name is None :\n   return False\n  for pattern in self.skip:\n   if fnmatch.fnmatch(module_name,pattern):\n    return True\n  return False\n  \n def stop_here(self,frame):\n  ''\n  \n  \n  if self.skip and\\\n  self.is_skipped_module(frame.f_globals.get('__name__')):\n   return False\n  if frame is self.stopframe:\n   if self.stoplineno ==-1:\n    return False\n   return frame.f_lineno >=self.stoplineno\n  if not self.stopframe:\n   return True\n  return False\n  \n def break_here(self,frame):\n  ''\n\n\n\n  \n  filename=self.canonic(frame.f_code.co_filename)\n  if filename not in self.breaks:\n   return False\n  lineno=frame.f_lineno\n  if lineno not in self.breaks[filename]:\n  \n  \n   lineno=frame.f_code.co_firstlineno\n   if lineno not in self.breaks[filename]:\n    return False\n    \n    \n  (bp,flag)=effective(filename,lineno,frame)\n  if bp:\n   self.currentbp=bp.number\n   if (flag and bp.temporary):\n    self.do_clear(str(bp.number))\n   return True\n  else :\n   return False\n   \n def do_clear(self,arg):\n  ''\n\n\n  \n  raise NotImplementedError(\"subclass of bdb must implement do_clear()\")\n  \n def break_anywhere(self,frame):\n  ''\n  \n  return self.canonic(frame.f_code.co_filename)in self.breaks\n  \n  \n  \n  \n def user_call(self,frame,argument_list):\n  ''\n  pass\n  \n def user_line(self,frame):\n  ''\n  pass\n  \n def user_return(self,frame,return_value):\n  ''\n  pass\n  \n def user_exception(self,frame,exc_info):\n  ''\n  pass\n  \n def _set_stopinfo(self,stopframe,returnframe,stoplineno=0):\n  ''\n\n\n\n\n  \n  self.stopframe=stopframe\n  self.returnframe=returnframe\n  self.quitting=False\n  \n  \n  self.stoplineno=stoplineno\n  \n  \n  \n  \n def set_until(self,frame,lineno=None ):\n  ''\n  \n  \n  if lineno is None :\n   lineno=frame.f_lineno+1\n  self._set_stopinfo(frame,frame,lineno)\n  \n def set_step(self):\n  ''\n  \n  \n  \n  \n  if self.frame_returning:\n   caller_frame=self.frame_returning.f_back\n   if caller_frame and not caller_frame.f_trace:\n    caller_frame.f_trace=self.trace_dispatch\n  self._set_stopinfo(None ,None )\n  \n def set_next(self,frame):\n  ''\n  self._set_stopinfo(frame,None )\n  \n def set_return(self,frame):\n  ''\n  if frame.f_code.co_flags&GENERATOR_AND_COROUTINE_FLAGS:\n   self._set_stopinfo(frame,None ,-1)\n  else :\n   self._set_stopinfo(frame.f_back,frame)\n   \n def set_trace(self,frame=None ):\n  ''\n\n\n  \n  if frame is None :\n   frame=sys._getframe().f_back\n  self.reset()\n  while frame:\n   frame.f_trace=self.trace_dispatch\n   self.botframe=frame\n   frame=frame.f_back\n  self.set_step()\n  sys.settrace(self.trace_dispatch)\n  \n def set_continue(self):\n  ''\n\n\n  \n  \n  self._set_stopinfo(self.botframe,None ,-1)\n  if not self.breaks:\n  \n   sys.settrace(None )\n   frame=sys._getframe().f_back\n   while frame and frame is not self.botframe:\n    del frame.f_trace\n    frame=frame.f_back\n    \n def set_quit(self):\n  ''\n\n\n  \n  self.stopframe=self.botframe\n  self.returnframe=None\n  self.quitting=True\n  sys.settrace(None )\n  \n  \n  \n  \n  \n  \n  \n  \n def set_break(self,filename,lineno,temporary=False ,cond=None ,\n funcname=None ):\n  ''\n\n\n\n  \n  filename=self.canonic(filename)\n  import linecache\n  line=linecache.getline(filename,lineno)\n  if not line:\n   return 'Line %s:%d does not exist'%(filename,lineno)\n  list=self.breaks.setdefault(filename,[])\n  if lineno not in list:\n   list.append(lineno)\n  bp=Breakpoint(filename,lineno,temporary,cond,funcname)\n  return None\n  \n def _prune_breaks(self,filename,lineno):\n  ''\n\n\n\n\n\n  \n  if (filename,lineno)not in Breakpoint.bplist:\n   self.breaks[filename].remove(lineno)\n  if not self.breaks[filename]:\n   del self.breaks[filename]\n   \n def clear_break(self,filename,lineno):\n  ''\n\n\n  \n  filename=self.canonic(filename)\n  if filename not in self.breaks:\n   return 'There are no breakpoints in %s'%filename\n  if lineno not in self.breaks[filename]:\n   return 'There is no breakpoint at %s:%d'%(filename,lineno)\n   \n   \n  for bp in Breakpoint.bplist[filename,lineno][:]:\n   bp.deleteMe()\n  self._prune_breaks(filename,lineno)\n  return None\n  \n def clear_bpbynumber(self,arg):\n  ''\n\n\n  \n  try :\n   bp=self.get_bpbynumber(arg)\n  except ValueError as err:\n   return str(err)\n  bp.deleteMe()\n  self._prune_breaks(bp.file,bp.line)\n  return None\n  \n def clear_all_file_breaks(self,filename):\n  ''\n\n\n  \n  filename=self.canonic(filename)\n  if filename not in self.breaks:\n   return 'There are no breakpoints in %s'%filename\n  for line in self.breaks[filename]:\n   blist=Breakpoint.bplist[filename,line]\n   for bp in blist:\n    bp.deleteMe()\n  del self.breaks[filename]\n  return None\n  \n def clear_all_breaks(self):\n  ''\n\n\n  \n  if not self.breaks:\n   return 'There are no breakpoints'\n  for bp in Breakpoint.bpbynumber:\n   if bp:\n    bp.deleteMe()\n  self.breaks={}\n  return None\n  \n def get_bpbynumber(self,arg):\n  ''\n\n\n\n  \n  if not arg:\n   raise ValueError('Breakpoint number expected')\n  try :\n   number=int(arg)\n  except ValueError:\n   raise ValueError('Non-numeric breakpoint number %s'%arg)from None\n  try :\n   bp=Breakpoint.bpbynumber[number]\n  except IndexError:\n   raise ValueError('Breakpoint number %d out of range'%number)from None\n  if bp is None :\n   raise ValueError('Breakpoint %d already deleted'%number)\n  return bp\n  \n def get_break(self,filename,lineno):\n  ''\n  filename=self.canonic(filename)\n  return filename in self.breaks and\\\n  lineno in self.breaks[filename]\n  \n def get_breaks(self,filename,lineno):\n  ''\n\n\n  \n  filename=self.canonic(filename)\n  return filename in self.breaks and\\\n  lineno in self.breaks[filename]and\\\n  Breakpoint.bplist[filename,lineno]or []\n  \n def get_file_breaks(self,filename):\n  ''\n\n\n  \n  filename=self.canonic(filename)\n  if filename in self.breaks:\n   return self.breaks[filename]\n  else :\n   return []\n   \n def get_all_breaks(self):\n  ''\n  return self.breaks\n  \n  \n  \n  \n def get_stack(self,f,t):\n  ''\n\n\n\n  \n  stack=[]\n  if t and t.tb_frame is f:\n   t=t.tb_next\n  while f is not None :\n   stack.append((f,f.f_lineno))\n   if f is self.botframe:\n    break\n   f=f.f_back\n  stack.reverse()\n  i=max(0,len(stack)-1)\n  while t is not None :\n   stack.append((t.tb_frame,t.tb_lineno))\n   t=t.tb_next\n  if f is None :\n   i=max(0,len(stack)-1)\n  return stack,i\n  \n def format_stack_entry(self,frame_lineno,lprefix=': '):\n  ''\n\n\n\n\n\n\n  \n  import linecache,reprlib\n  frame,lineno=frame_lineno\n  filename=self.canonic(frame.f_code.co_filename)\n  s='%s(%r)'%(filename,lineno)\n  if frame.f_code.co_name:\n   s +=frame.f_code.co_name\n  else :\n   s +=\"<lambda>\"\n  s +='()'\n  if '__return__'in frame.f_locals:\n   rv=frame.f_locals['__return__']\n   s +='->'\n   s +=reprlib.repr(rv)\n  line=linecache.getline(filename,lineno,frame.f_globals)\n  if line:\n   s +=lprefix+line.strip()\n  return s\n  \n  \n  \n  \n  \n def run(self,cmd,globals=None ,locals=None ):\n  ''\n\n\n  \n  if globals is None :\n   import __main__\n   globals=__main__.__dict__\n  if locals is None :\n   locals=globals\n  self.reset()\n  if isinstance(cmd,str):\n   cmd=compile(cmd,\"<string>\",\"exec\")\n  sys.settrace(self.trace_dispatch)\n  try :\n   exec(cmd,globals,locals)\n  except BdbQuit:\n   pass\n  finally :\n   self.quitting=True\n   sys.settrace(None )\n   \n def runeval(self,expr,globals=None ,locals=None ):\n  ''\n\n\n  \n  if globals is None :\n   import __main__\n   globals=__main__.__dict__\n  if locals is None :\n   locals=globals\n  self.reset()\n  sys.settrace(self.trace_dispatch)\n  try :\n   return eval(expr,globals,locals)\n  except BdbQuit:\n   pass\n  finally :\n   self.quitting=True\n   sys.settrace(None )\n   \n def runctx(self,cmd,globals,locals):\n  ''\n  \n  self.run(cmd,globals,locals)\n  \n  \n  \n def runcall(self,func,/,*args,**kwds):\n  ''\n\n\n  \n  self.reset()\n  sys.settrace(self.trace_dispatch)\n  res=None\n  try :\n   res=func(*args,**kwds)\n  except BdbQuit:\n   pass\n  finally :\n   self.quitting=True\n   sys.settrace(None )\n  return res\n  \n  \ndef set_trace():\n ''\n Bdb().set_trace()\n \n \nclass Breakpoint:\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n next=1\n bplist={}\n bpbynumber=[None ]\n \n \n \n def __init__(self,file,line,temporary=False ,cond=None ,funcname=None ):\n  self.funcname=funcname\n  \n  self.func_first_executable_line=None\n  self.file=file\n  self.line=line\n  self.temporary=temporary\n  self.cond=cond\n  self.enabled=True\n  self.ignore=0\n  self.hits=0\n  self.number=Breakpoint.next\n  Breakpoint.next +=1\n  \n  self.bpbynumber.append(self)\n  if (file,line)in self.bplist:\n   self.bplist[file,line].append(self)\n  else :\n   self.bplist[file,line]=[self]\n   \n def deleteMe(self):\n  ''\n\n\n\n  \n  \n  index=(self.file,self.line)\n  self.bpbynumber[self.number]=None\n  self.bplist[index].remove(self)\n  if not self.bplist[index]:\n  \n   del self.bplist[index]\n   \n def enable(self):\n  ''\n  self.enabled=True\n  \n def disable(self):\n  ''\n  self.enabled=False\n  \n def bpprint(self,out=None ):\n  ''\n\n\n\n  \n  if out is None :\n   out=sys.stdout\n  print(self.bpformat(),file=out)\n  \n def bpformat(self):\n  ''\n\n\n\n\n\n  \n  if self.temporary:\n   disp='del  '\n  else :\n   disp='keep '\n  if self.enabled:\n   disp=disp+'yes  '\n  else :\n   disp=disp+'no   '\n  ret='%-4dbreakpoint   %s at %s:%d'%(self.number,disp,\n  self.file,self.line)\n  if self.cond:\n   ret +='\\n\\tstop only if %s'%(self.cond,)\n  if self.ignore:\n   ret +='\\n\\tignore next %d hits'%(self.ignore,)\n  if self.hits:\n   if self.hits >1:\n    ss='s'\n   else :\n    ss=''\n   ret +='\\n\\tbreakpoint already hit %d time%s'%(self.hits,ss)\n  return ret\n  \n def __str__(self):\n  ''\n  return 'breakpoint %s at %s:%s'%(self.number,self.file,self.line)\n  \n  \n  \n  \ndef checkfuncname(b,frame):\n ''\n\n\n\n\n\n \n if not b.funcname:\n \n  if b.line !=frame.f_lineno:\n  \n  \n   return False\n  return True\n  \n  \n if frame.f_code.co_name !=b.funcname:\n \n  return False\n  \n  \n if not b.func_first_executable_line:\n \n  b.func_first_executable_line=frame.f_lineno\n  \n if b.func_first_executable_line !=frame.f_lineno:\n \n  return False\n return True\n \n \n \n \ndef effective(file,line,frame):\n ''\n\n\n\n\n\n \n possibles=Breakpoint.bplist[file,line]\n for b in possibles:\n  if not b.enabled:\n   continue\n  if not checkfuncname(b,frame):\n   continue\n   \n  b.hits +=1\n  if not b.cond:\n  \n   if b.ignore >0:\n    b.ignore -=1\n    continue\n   else :\n   \n    return (b,True )\n  else :\n  \n  \n  \n   try :\n    val=eval(b.cond,frame.f_globals,frame.f_locals)\n    if val:\n     if b.ignore >0:\n      b.ignore -=1\n      \n     else :\n      return (b,True )\n      \n      \n   except :\n   \n   \n   \n    return (b,False )\n return (None ,None )\n \n \n \n \nclass Tdb(Bdb):\n def user_call(self,frame,args):\n  name=frame.f_code.co_name\n  if not name:name='???'\n  print('+++ call',name,args)\n def user_line(self,frame):\n  import linecache\n  name=frame.f_code.co_name\n  if not name:name='???'\n  fn=self.canonic(frame.f_code.co_filename)\n  line=linecache.getline(fn,frame.f_lineno,frame.f_globals)\n  print('+++',fn,frame.f_lineno,name,':',line.strip())\n def user_return(self,frame,retval):\n  print('+++ return',retval)\n def user_exception(self,frame,exc_stuff):\n  print('+++ exception',exc_stuff)\n  self.set_continue()\n  \ndef foo(n):\n print('foo(',n,')')\n x=bar(n *10)\n print('bar returned',x)\n \ndef bar(a):\n print('bar(',a,')')\n return a /2\n \ndef test():\n t=Tdb()\n t.run('import bdb; bdb.foo(10)')\n", ["__main__", "fnmatch", "inspect", "linecache", "os", "reprlib", "sys"]],
     "binascii": [".py", "''\n\n\n\n\n\n\n\nimport _base64\n\nfrom _binascii import *\n\nclass Error(ValueError):\n def __init__(self,msg=''):\n  self._msg=msg\n  \n def __str__(self):\n  return \" binascii.Error: \"+self._msg\n  \n  \nclass Done(Exception):\n pass\n \nclass Incomplete(Error):\n pass\n \ndef a2b_uu(s):\n if not s:\n  return ''\n  \n length=(ord(s[0])-0x20)%64\n \n def quadruplets_gen(s):\n  while s:\n   try :\n    yield ord(s[0]),ord(s[1]),ord(s[2]),ord(s[3])\n   except IndexError:\n    s +='   '\n    yield ord(s[0]),ord(s[1]),ord(s[2]),ord(s[3])\n    return\n   s=s[4:]\n   \n try :\n  result=[''.join(\n  [chr((A -0x20)<<2 |(((B -0x20)>>4)&0x3)),\n  chr(((B -0x20)&0xf)<<4 |(((C -0x20)>>2)&0xf)),\n  chr(((C -0x20)&0x3)<<6 |((D -0x20)&0x3f))\n  ])for A,B,C,D in quadruplets_gen(s[1:].rstrip())]\n except ValueError:\n  raise Error('Illegal char')\n result=''.join(result)\n trailingdata=result[length:]\n if trailingdata.strip('\\x00'):\n  raise Error('Trailing garbage')\n result=result[:length]\n if len(result)<length:\n  result +=((length -len(result))*'\\x00')\n return bytes(result,__BRYTHON__.charset)\n \n \ntable_a2b_base64={\n'A':0,\n'B':1,\n'C':2,\n'D':3,\n'E':4,\n'F':5,\n'G':6,\n'H':7,\n'I':8,\n'J':9,\n'K':10,\n'L':11,\n'M':12,\n'N':13,\n'O':14,\n'P':15,\n'Q':16,\n'R':17,\n'S':18,\n'T':19,\n'U':20,\n'V':21,\n'W':22,\n'X':23,\n'Y':24,\n'Z':25,\n'a':26,\n'b':27,\n'c':28,\n'd':29,\n'e':30,\n'f':31,\n'g':32,\n'h':33,\n'i':34,\n'j':35,\n'k':36,\n'l':37,\n'm':38,\n'n':39,\n'o':40,\n'p':41,\n'q':42,\n'r':43,\n's':44,\n't':45,\n'u':46,\n'v':47,\n'w':48,\n'x':49,\n'y':50,\n'z':51,\n'0':52,\n'1':53,\n'2':54,\n'3':55,\n'4':56,\n'5':57,\n'6':58,\n'7':59,\n'8':60,\n'9':61,\n'+':62,\n'/':63,\n'=':0,\n}\n\n\ndef XXXa2b_base64(s):\n return _base64.Base64.decode(s)\n \ntable_b2a_base64=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\"\\\n\"0123456789+/\"\n\ndef XXXb2a_base64(s,newline=True ):\n length=len(s)\n final_length=length %3\n \n def triples_gen(s):\n  while s:\n   try :\n    yield s[0],s[1],s[2]\n   except IndexError:\n    s +=b'\\0\\0'\n    yield s[0],s[1],s[2]\n    return\n   s=s[3:]\n   \n a=triples_gen(s[:length -final_length])\n \n result=[''.join(\n [table_b2a_base64[(A >>2)&0x3F],\n table_b2a_base64[((A <<4)|((B >>4)&0xF))&0x3F],\n table_b2a_base64[((B <<2)|((C >>6)&0x3))&0x3F],\n table_b2a_base64[(C)&0x3F]])\n for A,B,C in a]\n \n final=s[length -final_length:]\n if final_length ==0:\n  snippet=''\n elif final_length ==1:\n  a=final[0]\n  snippet=table_b2a_base64[(a >>2)&0x3F]+\\\n  table_b2a_base64[(a <<4)&0x3F]+'=='\n else :\n  a=final[0]\n  b=final[1]\n  snippet=table_b2a_base64[(a >>2)&0x3F]+\\\n  table_b2a_base64[((a <<4)|(b >>4)&0xF)&0x3F]+\\\n  table_b2a_base64[(b <<2)&0x3F]+'='\n  \n result=''.join(result)+snippet\n if newline:\n  result +='\\n'\n return bytes(result,__BRYTHON__.charset)\n \ndef a2b_qp(s,header=False ):\n inp=0\n odata=[]\n while inp <len(s):\n  if s[inp]=='=':\n   inp +=1\n   if inp >=len(s):\n    break\n    \n   if (s[inp]=='\\n')or (s[inp]=='\\r'):\n    if s[inp]!='\\n':\n     while inp <len(s)and s[inp]!='\\n':\n      inp +=1\n    if inp <len(s):\n     inp +=1\n   elif s[inp]=='=':\n   \n    odata.append('=')\n    inp +=1\n   elif s[inp]in hex_numbers and s[inp+1]in hex_numbers:\n    ch=chr(int(s[inp:inp+2],16))\n    inp +=2\n    odata.append(ch)\n   else :\n    odata.append('=')\n  elif header and s[inp]=='_':\n   odata.append(' ')\n   inp +=1\n  else :\n   odata.append(s[inp])\n   inp +=1\n return bytes(''.join(odata),__BRYTHON__.charset)\n \ndef b2a_qp(data,quotetabs=False ,istext=True ,header=False ):\n ''\n\n\n\n\n \n MAXLINESIZE=76\n \n \n lf=data.find('\\n')\n crlf=lf >0 and data[lf -1]=='\\r'\n \n inp=0\n linelen=0\n odata=[]\n while inp <len(data):\n  c=data[inp]\n  if (c >'~'or\n  c =='='or\n  (header and c =='_')or\n  (c =='.'and linelen ==0 and (inp+1 ==len(data)or\n  data[inp+1]=='\\n'or\n  data[inp+1]=='\\r'))or\n  (not istext and (c =='\\r'or c =='\\n'))or\n  ((c =='\\t'or c ==' ')and (inp+1 ==len(data)))or\n  (c <=' 'and c !='\\r'and c !='\\n'and\n  (quotetabs or (not quotetabs and (c !='\\t'and c !=' '))))):\n   linelen +=3\n   if linelen >=MAXLINESIZE:\n    odata.append('=')\n    if crlf:odata.append('\\r')\n    odata.append('\\n')\n    linelen=3\n   odata.append('='+two_hex_digits(ord(c)))\n   inp +=1\n  else :\n   if (istext and\n   (c =='\\n'or (inp+1 <len(data)and c =='\\r'and\n   data[inp+1]=='\\n'))):\n    linelen=0\n    \n    if (len(odata)>0 and\n    (odata[-1]==' 'or odata[-1]=='\\t')):\n     ch=ord(odata[-1])\n     odata[-1]='='\n     odata.append(two_hex_digits(ch))\n     \n    if crlf:odata.append('\\r')\n    odata.append('\\n')\n    if c =='\\r':\n     inp +=2\n    else :\n     inp +=1\n   else :\n    if (inp+1 <len(data)and\n    data[inp+1]!='\\n'and\n    (linelen+1)>=MAXLINESIZE):\n     odata.append('=')\n     if crlf:odata.append('\\r')\n     odata.append('\\n')\n     linelen=0\n     \n    linelen +=1\n    if header and c ==' ':\n     c='_'\n    odata.append(c)\n    inp +=1\n return ''.join(odata)\n \nhex_numbers='0123456789ABCDEF'\ndef hex(n):\n if n ==0:\n  return '0'\n  \n if n <0:\n  n=-n\n  sign='-'\n else :\n  sign=''\n arr=[]\n \n def hex_gen(n):\n  ''\n  while n:\n   yield n %0x10\n   n=n /0x10\n   \n for nibble in hex_gen(n):\n  arr=[hex_numbers[nibble]]+arr\n return sign+''.join(arr)\n \ndef two_hex_digits(n):\n return hex_numbers[n /0x10]+hex_numbers[n %0x10]\n \n \ndef strhex_to_int(s):\n i=0\n for c in s:\n  i=i *0x10+hex_numbers.index(c)\n return i\n \nhqx_encoding='!\"#$%&\\'()*+,-012345689@ABCDEFGHIJKLMNPQRSTUVXYZ[`abcdefhijklmpqr'\n\nDONE=0x7f\nSKIP=0x7e\nFAIL=0x7d\n\ntable_a2b_hqx=[\n\nFAIL,FAIL,FAIL,FAIL,FAIL,FAIL,FAIL,FAIL,\n\nFAIL,FAIL,SKIP,FAIL,FAIL,SKIP,FAIL,FAIL,\n\nFAIL,FAIL,FAIL,FAIL,FAIL,FAIL,FAIL,FAIL,\n\nFAIL,FAIL,FAIL,FAIL,FAIL,FAIL,FAIL,FAIL,\n\nFAIL,0x00,0x01,0x02,0x03,0x04,0x05,0x06,\n\n0x07,0x08,0x09,0x0A,0x0B,0x0C,FAIL,FAIL,\n\n0x0D,0x0E,0x0F,0x10,0x11,0x12,0x13,FAIL,\n\n0x14,0x15,DONE,FAIL,FAIL,FAIL,FAIL,FAIL,\n\n0x16,0x17,0x18,0x19,0x1A,0x1B,0x1C,0x1D,\n\n0x1E,0x1F,0x20,0x21,0x22,0x23,0x24,FAIL,\n\n0x25,0x26,0x27,0x28,0x29,0x2A,0x2B,FAIL,\n\n0x2C,0x2D,0x2E,0x2F,FAIL,FAIL,FAIL,FAIL,\n\n0x30,0x31,0x32,0x33,0x34,0x35,0x36,FAIL,\n\n0x37,0x38,0x39,0x3A,0x3B,0x3C,FAIL,FAIL,\n\n0x3D,0x3E,0x3F,FAIL,FAIL,FAIL,FAIL,FAIL,\n\nFAIL,FAIL,FAIL,FAIL,FAIL,FAIL,FAIL,FAIL,\nFAIL,FAIL,FAIL,FAIL,FAIL,FAIL,FAIL,FAIL,\nFAIL,FAIL,FAIL,FAIL,FAIL,FAIL,FAIL,FAIL,\nFAIL,FAIL,FAIL,FAIL,FAIL,FAIL,FAIL,FAIL,\nFAIL,FAIL,FAIL,FAIL,FAIL,FAIL,FAIL,FAIL,\nFAIL,FAIL,FAIL,FAIL,FAIL,FAIL,FAIL,FAIL,\nFAIL,FAIL,FAIL,FAIL,FAIL,FAIL,FAIL,FAIL,\nFAIL,FAIL,FAIL,FAIL,FAIL,FAIL,FAIL,FAIL,\nFAIL,FAIL,FAIL,FAIL,FAIL,FAIL,FAIL,FAIL,\nFAIL,FAIL,FAIL,FAIL,FAIL,FAIL,FAIL,FAIL,\nFAIL,FAIL,FAIL,FAIL,FAIL,FAIL,FAIL,FAIL,\nFAIL,FAIL,FAIL,FAIL,FAIL,FAIL,FAIL,FAIL,\nFAIL,FAIL,FAIL,FAIL,FAIL,FAIL,FAIL,FAIL,\nFAIL,FAIL,FAIL,FAIL,FAIL,FAIL,FAIL,FAIL,\nFAIL,FAIL,FAIL,FAIL,FAIL,FAIL,FAIL,FAIL,\nFAIL,FAIL,FAIL,FAIL,FAIL,FAIL,FAIL,FAIL,\nFAIL,FAIL,FAIL,FAIL,FAIL,FAIL,FAIL,FAIL,\n]\n\ndef a2b_hqx(s):\n result=[]\n \n def quadruples_gen(s):\n  t=[]\n  for c in s:\n   res=table_a2b_hqx[ord(c)]\n   if res ==SKIP:\n    continue\n   elif res ==FAIL:\n    raise Error('Illegal character')\n   elif res ==DONE:\n    yield t\n    raise Done\n   else :\n    t.append(res)\n   if len(t)==4:\n    yield t\n    t=[]\n  yield t\n  \n done=0\n try :\n  for snippet in quadruples_gen(s):\n   length=len(snippet)\n   if length ==4:\n    result.append(chr(((snippet[0]&0x3f)<<2)|(snippet[1]>>4)))\n    result.append(chr(((snippet[1]&0x0f)<<4)|(snippet[2]>>2)))\n    result.append(chr(((snippet[2]&0x03)<<6)|(snippet[3])))\n   elif length ==3:\n    result.append(chr(((snippet[0]&0x3f)<<2)|(snippet[1]>>4)))\n    result.append(chr(((snippet[1]&0x0f)<<4)|(snippet[2]>>2)))\n   elif length ==2:\n    result.append(chr(((snippet[0]&0x3f)<<2)|(snippet[1]>>4)))\n except Done:\n  done=1\n except Error:\n  raise\n return (''.join(result),done)\n \n \n \ndef b2a_hqx(s):\n result=[]\n \n def triples_gen(s):\n  while s:\n   try :\n    yield ord(s[0]),ord(s[1]),ord(s[2])\n   except IndexError:\n    yield tuple([ord(c)for c in s])\n   s=s[3:]\n   \n for snippet in triples_gen(s):\n  length=len(snippet)\n  if length ==3:\n   result.append(\n   hqx_encoding[(snippet[0]&0xfc)>>2])\n   result.append(hqx_encoding[\n   ((snippet[0]&0x03)<<4)|((snippet[1]&0xf0)>>4)])\n   result.append(hqx_encoding[\n   (snippet[1]&0x0f)<<2 |((snippet[2]&0xc0)>>6)])\n   result.append(hqx_encoding[snippet[2]&0x3f])\n  elif length ==2:\n   result.append(\n   hqx_encoding[(snippet[0]&0xfc)>>2])\n   result.append(hqx_encoding[\n   ((snippet[0]&0x03)<<4)|((snippet[1]&0xf0)>>4)])\n   result.append(hqx_encoding[\n   (snippet[1]&0x0f)<<2])\n  elif length ==1:\n   result.append(\n   hqx_encoding[(snippet[0]&0xfc)>>2])\n   result.append(hqx_encoding[\n   ((snippet[0]&0x03)<<4)])\n return ''.join(result)\n \ncrctab_hqx=[\n0x0000,0x1021,0x2042,0x3063,0x4084,0x50a5,0x60c6,0x70e7,\n0x8108,0x9129,0xa14a,0xb16b,0xc18c,0xd1ad,0xe1ce,0xf1ef,\n0x1231,0x0210,0x3273,0x2252,0x52b5,0x4294,0x72f7,0x62d6,\n0x9339,0x8318,0xb37b,0xa35a,0xd3bd,0xc39c,0xf3ff,0xe3de,\n0x2462,0x3443,0x0420,0x1401,0x64e6,0x74c7,0x44a4,0x5485,\n0xa56a,0xb54b,0x8528,0x9509,0xe5ee,0xf5cf,0xc5ac,0xd58d,\n0x3653,0x2672,0x1611,0x0630,0x76d7,0x66f6,0x5695,0x46b4,\n0xb75b,0xa77a,0x9719,0x8738,0xf7df,0xe7fe,0xd79d,0xc7bc,\n0x48c4,0x58e5,0x6886,0x78a7,0x0840,0x1861,0x2802,0x3823,\n0xc9cc,0xd9ed,0xe98e,0xf9af,0x8948,0x9969,0xa90a,0xb92b,\n0x5af5,0x4ad4,0x7ab7,0x6a96,0x1a71,0x0a50,0x3a33,0x2a12,\n0xdbfd,0xcbdc,0xfbbf,0xeb9e,0x9b79,0x8b58,0xbb3b,0xab1a,\n0x6ca6,0x7c87,0x4ce4,0x5cc5,0x2c22,0x3c03,0x0c60,0x1c41,\n0xedae,0xfd8f,0xcdec,0xddcd,0xad2a,0xbd0b,0x8d68,0x9d49,\n0x7e97,0x6eb6,0x5ed5,0x4ef4,0x3e13,0x2e32,0x1e51,0x0e70,\n0xff9f,0xefbe,0xdfdd,0xcffc,0xbf1b,0xaf3a,0x9f59,0x8f78,\n0x9188,0x81a9,0xb1ca,0xa1eb,0xd10c,0xc12d,0xf14e,0xe16f,\n0x1080,0x00a1,0x30c2,0x20e3,0x5004,0x4025,0x7046,0x6067,\n0x83b9,0x9398,0xa3fb,0xb3da,0xc33d,0xd31c,0xe37f,0xf35e,\n0x02b1,0x1290,0x22f3,0x32d2,0x4235,0x5214,0x6277,0x7256,\n0xb5ea,0xa5cb,0x95a8,0x8589,0xf56e,0xe54f,0xd52c,0xc50d,\n0x34e2,0x24c3,0x14a0,0x0481,0x7466,0x6447,0x5424,0x4405,\n0xa7db,0xb7fa,0x8799,0x97b8,0xe75f,0xf77e,0xc71d,0xd73c,\n0x26d3,0x36f2,0x0691,0x16b0,0x6657,0x7676,0x4615,0x5634,\n0xd94c,0xc96d,0xf90e,0xe92f,0x99c8,0x89e9,0xb98a,0xa9ab,\n0x5844,0x4865,0x7806,0x6827,0x18c0,0x08e1,0x3882,0x28a3,\n0xcb7d,0xdb5c,0xeb3f,0xfb1e,0x8bf9,0x9bd8,0xabbb,0xbb9a,\n0x4a75,0x5a54,0x6a37,0x7a16,0x0af1,0x1ad0,0x2ab3,0x3a92,\n0xfd2e,0xed0f,0xdd6c,0xcd4d,0xbdaa,0xad8b,0x9de8,0x8dc9,\n0x7c26,0x6c07,0x5c64,0x4c45,0x3ca2,0x2c83,0x1ce0,0x0cc1,\n0xef1f,0xff3e,0xcf5d,0xdf7c,0xaf9b,0xbfba,0x8fd9,0x9ff8,\n0x6e17,0x7e36,0x4e55,0x5e74,0x2e93,0x3eb2,0x0ed1,0x1ef0,\n]\n\ndef crc_hqx(s,crc):\n for c in s:\n  crc=((crc <<8)&0xff00)^crctab_hqx[((crc >>8)&0xff)^ord(c)]\n  \n return crc\n \ndef rlecode_hqx(s):\n ''\n\n\n\n \n if not s:\n  return ''\n result=[]\n prev=s[0]\n count=1\n \n \n \n \n if s[-1]=='!':\n  s=s[1:]+'?'\n else :\n  s=s[1:]+'!'\n  \n for c in s:\n  if c ==prev and count <255:\n   count +=1\n  else :\n   if count ==1:\n    if prev !='\\x90':\n     result.append(prev)\n    else :\n     result.extend(['\\x90','\\x00'])\n   elif count <4:\n    if prev !='\\x90':\n     result.extend([prev]*count)\n    else :\n     result.extend(['\\x90','\\x00']*count)\n   else :\n    if prev !='\\x90':\n     result.extend([prev,'\\x90',chr(count)])\n    else :\n     result.extend(['\\x90','\\x00','\\x90',chr(count)])\n   count=1\n   prev=c\n   \n return ''.join(result)\n \ndef rledecode_hqx(s):\n s=s.split('\\x90')\n result=[s[0]]\n prev=s[0]\n for snippet in s[1:]:\n  count=ord(snippet[0])\n  if count >0:\n   result.append(prev[-1]*(count -1))\n   prev=snippet\n  else :\n   result.append('\\x90')\n   prev='\\x90'\n  result.append(snippet[1:])\n  \n return ''.join(result)\n \ncrc_32_tab=[\n0x00000000,0x77073096,0xee0e612c,0x990951ba,0x076dc419,\n0x706af48f,0xe963a535,0x9e6495a3,0x0edb8832,0x79dcb8a4,\n0xe0d5e91e,0x97d2d988,0x09b64c2b,0x7eb17cbd,0xe7b82d07,\n0x90bf1d91,0x1db71064,0x6ab020f2,0xf3b97148,0x84be41de,\n0x1adad47d,0x6ddde4eb,0xf4d4b551,0x83d385c7,0x136c9856,\n0x646ba8c0,0xfd62f97a,0x8a65c9ec,0x14015c4f,0x63066cd9,\n0xfa0f3d63,0x8d080df5,0x3b6e20c8,0x4c69105e,0xd56041e4,\n0xa2677172,0x3c03e4d1,0x4b04d447,0xd20d85fd,0xa50ab56b,\n0x35b5a8fa,0x42b2986c,0xdbbbc9d6,0xacbcf940,0x32d86ce3,\n0x45df5c75,0xdcd60dcf,0xabd13d59,0x26d930ac,0x51de003a,\n0xc8d75180,0xbfd06116,0x21b4f4b5,0x56b3c423,0xcfba9599,\n0xb8bda50f,0x2802b89e,0x5f058808,0xc60cd9b2,0xb10be924,\n0x2f6f7c87,0x58684c11,0xc1611dab,0xb6662d3d,0x76dc4190,\n0x01db7106,0x98d220bc,0xefd5102a,0x71b18589,0x06b6b51f,\n0x9fbfe4a5,0xe8b8d433,0x7807c9a2,0x0f00f934,0x9609a88e,\n0xe10e9818,0x7f6a0dbb,0x086d3d2d,0x91646c97,0xe6635c01,\n0x6b6b51f4,0x1c6c6162,0x856530d8,0xf262004e,0x6c0695ed,\n0x1b01a57b,0x8208f4c1,0xf50fc457,0x65b0d9c6,0x12b7e950,\n0x8bbeb8ea,0xfcb9887c,0x62dd1ddf,0x15da2d49,0x8cd37cf3,\n0xfbd44c65,0x4db26158,0x3ab551ce,0xa3bc0074,0xd4bb30e2,\n0x4adfa541,0x3dd895d7,0xa4d1c46d,0xd3d6f4fb,0x4369e96a,\n0x346ed9fc,0xad678846,0xda60b8d0,0x44042d73,0x33031de5,\n0xaa0a4c5f,0xdd0d7cc9,0x5005713c,0x270241aa,0xbe0b1010,\n0xc90c2086,0x5768b525,0x206f85b3,0xb966d409,0xce61e49f,\n0x5edef90e,0x29d9c998,0xb0d09822,0xc7d7a8b4,0x59b33d17,\n0x2eb40d81,0xb7bd5c3b,0xc0ba6cad,0xedb88320,0x9abfb3b6,\n0x03b6e20c,0x74b1d29a,0xead54739,0x9dd277af,0x04db2615,\n0x73dc1683,0xe3630b12,0x94643b84,0x0d6d6a3e,0x7a6a5aa8,\n0xe40ecf0b,0x9309ff9d,0x0a00ae27,0x7d079eb1,0xf00f9344,\n0x8708a3d2,0x1e01f268,0x6906c2fe,0xf762575d,0x806567cb,\n0x196c3671,0x6e6b06e7,0xfed41b76,0x89d32be0,0x10da7a5a,\n0x67dd4acc,0xf9b9df6f,0x8ebeeff9,0x17b7be43,0x60b08ed5,\n0xd6d6a3e8,0xa1d1937e,0x38d8c2c4,0x4fdff252,0xd1bb67f1,\n0xa6bc5767,0x3fb506dd,0x48b2364b,0xd80d2bda,0xaf0a1b4c,\n0x36034af6,0x41047a60,0xdf60efc3,0xa867df55,0x316e8eef,\n0x4669be79,0xcb61b38c,0xbc66831a,0x256fd2a0,0x5268e236,\n0xcc0c7795,0xbb0b4703,0x220216b9,0x5505262f,0xc5ba3bbe,\n0xb2bd0b28,0x2bb45a92,0x5cb36a04,0xc2d7ffa7,0xb5d0cf31,\n0x2cd99e8b,0x5bdeae1d,0x9b64c2b0,0xec63f226,0x756aa39c,\n0x026d930a,0x9c0906a9,0xeb0e363f,0x72076785,0x05005713,\n0x95bf4a82,0xe2b87a14,0x7bb12bae,0x0cb61b38,0x92d28e9b,\n0xe5d5be0d,0x7cdcefb7,0x0bdbdf21,0x86d3d2d4,0xf1d4e242,\n0x68ddb3f8,0x1fda836e,0x81be16cd,0xf6b9265b,0x6fb077e1,\n0x18b74777,0x88085ae6,0xff0f6a70,0x66063bca,0x11010b5c,\n0x8f659eff,0xf862ae69,0x616bffd3,0x166ccf45,0xa00ae278,\n0xd70dd2ee,0x4e048354,0x3903b3c2,0xa7672661,0xd06016f7,\n0x4969474d,0x3e6e77db,0xaed16a4a,0xd9d65adc,0x40df0b66,\n0x37d83bf0,0xa9bcae53,0xdebb9ec5,0x47b2cf7f,0x30b5ffe9,\n0xbdbdf21c,0xcabac28a,0x53b39330,0x24b4a3a6,0xbad03605,\n0xcdd70693,0x54de5729,0x23d967bf,0xb3667a2e,0xc4614ab8,\n0x5d681b02,0x2a6f2b94,0xb40bbe37,0xc30c8ea1,0x5a05df1b,\n0x2d02ef8d\n]\n\ndef crc32(s,crc=0):\n result=0\n crc=~int(crc)&0xffffffff\n \n for c in s:\n  crc=crc_32_tab[(crc ^int(ord(c)))&0xff]^(crc >>8)\n  \n  \n  \n result=crc ^0xffffffff\n \n if result >2 **31:\n  result=((result+2 **31)%2 **32)-2 **31\n  \n return result\n", ["_base64", "_binascii"]],
     "bisect": [".py", "''\n\ndef insort_right(a,x,lo=0,hi=None ):\n ''\n\n\n\n\n\n \n \n lo=bisect_right(a,x,lo,hi)\n a.insert(lo,x)\n \ndef bisect_right(a,x,lo=0,hi=None ):\n ''\n\n\n\n\n\n\n\n \n \n if lo <0:\n  raise ValueError('lo must be non-negative')\n if hi is None :\n  hi=len(a)\n while lo <hi:\n  mid=(lo+hi)//2\n  \n  if x <a[mid]:hi=mid\n  else :lo=mid+1\n return lo\n \ndef insort_left(a,x,lo=0,hi=None ):\n ''\n\n\n\n\n\n \n \n lo=bisect_left(a,x,lo,hi)\n a.insert(lo,x)\n \n \ndef bisect_left(a,x,lo=0,hi=None ):\n ''\n\n\n\n\n\n\n\n \n \n if lo <0:\n  raise ValueError('lo must be non-negative')\n if hi is None :\n  hi=len(a)\n while lo <hi:\n  mid=(lo+hi)//2\n  \n  if a[mid]<x:lo=mid+1\n  else :hi=mid\n return lo\n \n \ntry :\n from _bisect import *\nexcept ImportError:\n pass\n \n \nbisect=bisect_right\ninsort=insort_right\n", ["_bisect"]],
@@ -60,15 +60,15 @@
     "colorsys": [".py", "''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n__all__=[\"rgb_to_yiq\",\"yiq_to_rgb\",\"rgb_to_hls\",\"hls_to_rgb\",\n\"rgb_to_hsv\",\"hsv_to_rgb\"]\n\n\n\nONE_THIRD=1.0 /3.0\nONE_SIXTH=1.0 /6.0\nTWO_THIRD=2.0 /3.0\n\n\n\n\n\n\n\n\ndef rgb_to_yiq(r,g,b):\n y=0.30 *r+0.59 *g+0.11 *b\n i=0.74 *(r -y)-0.27 *(b -y)\n q=0.48 *(r -y)+0.41 *(b -y)\n return (y,i,q)\n \ndef yiq_to_rgb(y,i,q):\n\n\n\n\n r=y+0.9468822170900693 *i+0.6235565819861433 *q\n g=y -0.27478764629897834 *i -0.6356910791873801 *q\n b=y -1.1085450346420322 *i+1.7090069284064666 *q\n \n if r <0.0:\n  r=0.0\n if g <0.0:\n  g=0.0\n if b <0.0:\n  b=0.0\n if r >1.0:\n  r=1.0\n if g >1.0:\n  g=1.0\n if b >1.0:\n  b=1.0\n return (r,g,b)\n \n \n \n \n \n \n \ndef rgb_to_hls(r,g,b):\n maxc=max(r,g,b)\n minc=min(r,g,b)\n \n l=(minc+maxc)/2.0\n if minc ==maxc:\n  return 0.0,l,0.0\n if l <=0.5:\n  s=(maxc -minc)/(maxc+minc)\n else :\n  s=(maxc -minc)/(2.0 -maxc -minc)\n rc=(maxc -r)/(maxc -minc)\n gc=(maxc -g)/(maxc -minc)\n bc=(maxc -b)/(maxc -minc)\n if r ==maxc:\n  h=bc -gc\n elif g ==maxc:\n  h=2.0+rc -bc\n else :\n  h=4.0+gc -rc\n h=(h /6.0)%1.0\n return h,l,s\n \ndef hls_to_rgb(h,l,s):\n if s ==0.0:\n  return l,l,l\n if l <=0.5:\n  m2=l *(1.0+s)\n else :\n  m2=l+s -(l *s)\n m1=2.0 *l -m2\n return (_v(m1,m2,h+ONE_THIRD),_v(m1,m2,h),_v(m1,m2,h -ONE_THIRD))\n \ndef _v(m1,m2,hue):\n hue=hue %1.0\n if hue <ONE_SIXTH:\n  return m1+(m2 -m1)*hue *6.0\n if hue <0.5:\n  return m2\n if hue <TWO_THIRD:\n  return m1+(m2 -m1)*(TWO_THIRD -hue)*6.0\n return m1\n \n \n \n \n \n \n \ndef rgb_to_hsv(r,g,b):\n maxc=max(r,g,b)\n minc=min(r,g,b)\n v=maxc\n if minc ==maxc:\n  return 0.0,0.0,v\n s=(maxc -minc)/maxc\n rc=(maxc -r)/(maxc -minc)\n gc=(maxc -g)/(maxc -minc)\n bc=(maxc -b)/(maxc -minc)\n if r ==maxc:\n  h=bc -gc\n elif g ==maxc:\n  h=2.0+rc -bc\n else :\n  h=4.0+gc -rc\n h=(h /6.0)%1.0\n return h,s,v\n \ndef hsv_to_rgb(h,s,v):\n if s ==0.0:\n  return v,v,v\n i=int(h *6.0)\n f=(h *6.0)-i\n p=v *(1.0 -s)\n q=v *(1.0 -s *f)\n t=v *(1.0 -s *(1.0 -f))\n i=i %6\n if i ==0:\n  return v,t,p\n if i ==1:\n  return q,v,p\n if i ==2:\n  return p,v,t\n if i ==3:\n  return p,q,v\n if i ==4:\n  return t,p,v\n if i ==5:\n  return v,p,q\n  \n", []],
     "configparser": [".py", "''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfrom collections.abc import MutableMapping\nfrom collections import ChainMap as _ChainMap\nimport functools\nimport io\nimport itertools\nimport os\nimport re\nimport sys\nimport warnings\n\n__all__=[\"NoSectionError\",\"DuplicateOptionError\",\"DuplicateSectionError\",\n\"NoOptionError\",\"InterpolationError\",\"InterpolationDepthError\",\n\"InterpolationMissingOptionError\",\"InterpolationSyntaxError\",\n\"ParsingError\",\"MissingSectionHeaderError\",\n\"ConfigParser\",\"SafeConfigParser\",\"RawConfigParser\",\n\"Interpolation\",\"BasicInterpolation\",\"ExtendedInterpolation\",\n\"LegacyInterpolation\",\"SectionProxy\",\"ConverterMapping\",\n\"DEFAULTSECT\",\"MAX_INTERPOLATION_DEPTH\"]\n\n_default_dict=dict\nDEFAULTSECT=\"DEFAULT\"\n\nMAX_INTERPOLATION_DEPTH=10\n\n\n\n\nclass Error(Exception):\n ''\n \n def __init__(self,msg=''):\n  self.message=msg\n  Exception.__init__(self,msg)\n  \n def __repr__(self):\n  return self.message\n  \n __str__=__repr__\n \n \nclass NoSectionError(Error):\n ''\n \n def __init__(self,section):\n  Error.__init__(self,'No section: %r'%(section,))\n  self.section=section\n  self.args=(section,)\n  \n  \nclass DuplicateSectionError(Error):\n ''\n\n\n\n\n \n \n def __init__(self,section,source=None ,lineno=None ):\n  msg=[repr(section),\" already exists\"]\n  if source is not None :\n   message=[\"While reading from \",repr(source)]\n   if lineno is not None :\n    message.append(\" [line {0:2d}]\".format(lineno))\n   message.append(\": section \")\n   message.extend(msg)\n   msg=message\n  else :\n   msg.insert(0,\"Section \")\n  Error.__init__(self,\"\".join(msg))\n  self.section=section\n  self.source=source\n  self.lineno=lineno\n  self.args=(section,source,lineno)\n  \n  \nclass DuplicateOptionError(Error):\n ''\n\n\n\n \n \n def __init__(self,section,option,source=None ,lineno=None ):\n  msg=[repr(option),\" in section \",repr(section),\n  \" already exists\"]\n  if source is not None :\n   message=[\"While reading from \",repr(source)]\n   if lineno is not None :\n    message.append(\" [line {0:2d}]\".format(lineno))\n   message.append(\": option \")\n   message.extend(msg)\n   msg=message\n  else :\n   msg.insert(0,\"Option \")\n  Error.__init__(self,\"\".join(msg))\n  self.section=section\n  self.option=option\n  self.source=source\n  self.lineno=lineno\n  self.args=(section,option,source,lineno)\n  \n  \nclass NoOptionError(Error):\n ''\n \n def __init__(self,option,section):\n  Error.__init__(self,\"No option %r in section: %r\"%\n  (option,section))\n  self.option=option\n  self.section=section\n  self.args=(option,section)\n  \n  \nclass InterpolationError(Error):\n ''\n \n def __init__(self,option,section,msg):\n  Error.__init__(self,msg)\n  self.option=option\n  self.section=section\n  self.args=(option,section,msg)\n  \n  \nclass InterpolationMissingOptionError(InterpolationError):\n ''\n \n def __init__(self,option,section,rawval,reference):\n  msg=(\"Bad value substitution: option {!r} in section {!r} contains \"\n  \"an interpolation key {!r} which is not a valid option name. \"\n  \"Raw value: {!r}\".format(option,section,reference,rawval))\n  InterpolationError.__init__(self,option,section,msg)\n  self.reference=reference\n  self.args=(option,section,rawval,reference)\n  \n  \nclass InterpolationSyntaxError(InterpolationError):\n ''\n\n\n\n \n \n \nclass InterpolationDepthError(InterpolationError):\n ''\n \n def __init__(self,option,section,rawval):\n  msg=(\"Recursion limit exceeded in value substitution: option {!r} \"\n  \"in section {!r} contains an interpolation key which \"\n  \"cannot be substituted in {} steps. Raw value: {!r}\"\n  \"\".format(option,section,MAX_INTERPOLATION_DEPTH,\n  rawval))\n  InterpolationError.__init__(self,option,section,msg)\n  self.args=(option,section,rawval)\n  \n  \nclass ParsingError(Error):\n ''\n \n def __init__(self,source=None ,filename=None ):\n \n \n  if filename and source:\n   raise ValueError(\"Cannot specify both `filename' and `source'. \"\n   \"Use `source'.\")\n  elif not filename and not source:\n   raise ValueError(\"Required argument `source' not given.\")\n  elif filename:\n   source=filename\n  Error.__init__(self,'Source contains parsing errors: %r'%source)\n  self.source=source\n  self.errors=[]\n  self.args=(source,)\n  \n @property\n def filename(self):\n  ''\n  warnings.warn(\n  \"The 'filename' attribute will be removed in future versions.  \"\n  \"Use 'source' instead.\",\n  DeprecationWarning,stacklevel=2\n  )\n  return self.source\n  \n @filename.setter\n def filename(self,value):\n  ''\n  warnings.warn(\n  \"The 'filename' attribute will be removed in future versions.  \"\n  \"Use 'source' instead.\",\n  DeprecationWarning,stacklevel=2\n  )\n  self.source=value\n  \n def append(self,lineno,line):\n  self.errors.append((lineno,line))\n  self.message +='\\n\\t[line %2d]: %s'%(lineno,line)\n  \n  \nclass MissingSectionHeaderError(ParsingError):\n ''\n \n def __init__(self,filename,lineno,line):\n  Error.__init__(\n  self,\n  'File contains no section headers.\\nfile: %r, line: %d\\n%r'%\n  (filename,lineno,line))\n  self.source=filename\n  self.lineno=lineno\n  self.line=line\n  self.args=(filename,lineno,line)\n  \n  \n  \n  \n  \n_UNSET=object()\n\n\nclass Interpolation:\n ''\n \n def before_get(self,parser,section,option,value,defaults):\n  return value\n  \n def before_set(self,parser,section,option,value):\n  return value\n  \n def before_read(self,parser,section,option,value):\n  return value\n  \n def before_write(self,parser,section,option,value):\n  return value\n  \n  \nclass BasicInterpolation(Interpolation):\n ''\n\n\n\n\n\n\n\n\n\n\n\n \n \n _KEYCRE=re.compile(r\"%\\(([^)]+)\\)s\")\n \n def before_get(self,parser,section,option,value,defaults):\n  L=[]\n  self._interpolate_some(parser,option,L,value,section,defaults,1)\n  return ''.join(L)\n  \n def before_set(self,parser,section,option,value):\n  tmp_value=value.replace('%%','')\n  tmp_value=self._KEYCRE.sub('',tmp_value)\n  if '%'in tmp_value:\n   raise ValueError(\"invalid interpolation syntax in %r at \"\n   \"position %d\"%(value,tmp_value.find('%')))\n  return value\n  \n def _interpolate_some(self,parser,option,accum,rest,section,map,\n depth):\n  rawval=parser.get(section,option,raw=True ,fallback=rest)\n  if depth >MAX_INTERPOLATION_DEPTH:\n   raise InterpolationDepthError(option,section,rawval)\n  while rest:\n   p=rest.find(\"%\")\n   if p <0:\n    accum.append(rest)\n    return\n   if p >0:\n    accum.append(rest[:p])\n    rest=rest[p:]\n    \n   c=rest[1:2]\n   if c ==\"%\":\n    accum.append(\"%\")\n    rest=rest[2:]\n   elif c ==\"(\":\n    m=self._KEYCRE.match(rest)\n    if m is None :\n     raise InterpolationSyntaxError(option,section,\n     \"bad interpolation variable reference %r\"%rest)\n    var=parser.optionxform(m.group(1))\n    rest=rest[m.end():]\n    try :\n     v=map[var]\n    except KeyError:\n     raise InterpolationMissingOptionError(\n     option,section,rawval,var)from None\n    if \"%\"in v:\n     self._interpolate_some(parser,option,accum,v,\n     section,map,depth+1)\n    else :\n     accum.append(v)\n   else :\n    raise InterpolationSyntaxError(\n    option,section,\n    \"'%%' must be followed by '%%' or '(', \"\n    \"found: %r\"%(rest,))\n    \n    \nclass ExtendedInterpolation(Interpolation):\n ''\n \n \n _KEYCRE=re.compile(r\"\\$\\{([^}]+)\\}\")\n \n def before_get(self,parser,section,option,value,defaults):\n  L=[]\n  self._interpolate_some(parser,option,L,value,section,defaults,1)\n  return ''.join(L)\n  \n def before_set(self,parser,section,option,value):\n  tmp_value=value.replace('$$','')\n  tmp_value=self._KEYCRE.sub('',tmp_value)\n  if '$'in tmp_value:\n   raise ValueError(\"invalid interpolation syntax in %r at \"\n   \"position %d\"%(value,tmp_value.find('$')))\n  return value\n  \n def _interpolate_some(self,parser,option,accum,rest,section,map,\n depth):\n  rawval=parser.get(section,option,raw=True ,fallback=rest)\n  if depth >MAX_INTERPOLATION_DEPTH:\n   raise InterpolationDepthError(option,section,rawval)\n  while rest:\n   p=rest.find(\"$\")\n   if p <0:\n    accum.append(rest)\n    return\n   if p >0:\n    accum.append(rest[:p])\n    rest=rest[p:]\n    \n   c=rest[1:2]\n   if c ==\"$\":\n    accum.append(\"$\")\n    rest=rest[2:]\n   elif c ==\"{\":\n    m=self._KEYCRE.match(rest)\n    if m is None :\n     raise InterpolationSyntaxError(option,section,\n     \"bad interpolation variable reference %r\"%rest)\n    path=m.group(1).split(':')\n    rest=rest[m.end():]\n    sect=section\n    opt=option\n    try :\n     if len(path)==1:\n      opt=parser.optionxform(path[0])\n      v=map[opt]\n     elif len(path)==2:\n      sect=path[0]\n      opt=parser.optionxform(path[1])\n      v=parser.get(sect,opt,raw=True )\n     else :\n      raise InterpolationSyntaxError(\n      option,section,\n      \"More than one ':' found: %r\"%(rest,))\n    except (KeyError,NoSectionError,NoOptionError):\n     raise InterpolationMissingOptionError(\n     option,section,rawval,\":\".join(path))from None\n    if \"$\"in v:\n     self._interpolate_some(parser,opt,accum,v,sect,\n     dict(parser.items(sect,raw=True )),\n     depth+1)\n    else :\n     accum.append(v)\n   else :\n    raise InterpolationSyntaxError(\n    option,section,\n    \"'$' must be followed by '$' or '{', \"\n    \"found: %r\"%(rest,))\n    \n    \nclass LegacyInterpolation(Interpolation):\n ''\n \n \n _KEYCRE=re.compile(r\"%\\(([^)]*)\\)s|.\")\n \n def before_get(self,parser,section,option,value,vars):\n  rawval=value\n  depth=MAX_INTERPOLATION_DEPTH\n  while depth:\n   depth -=1\n   if value and \"%(\"in value:\n    replace=functools.partial(self._interpolation_replace,\n    parser=parser)\n    value=self._KEYCRE.sub(replace,value)\n    try :\n     value=value %vars\n    except KeyError as e:\n     raise InterpolationMissingOptionError(\n     option,section,rawval,e.args[0])from None\n   else :\n    break\n  if value and \"%(\"in value:\n   raise InterpolationDepthError(option,section,rawval)\n  return value\n  \n def before_set(self,parser,section,option,value):\n  return value\n  \n @staticmethod\n def _interpolation_replace(match,parser):\n  s=match.group(1)\n  if s is None :\n   return match.group()\n  else :\n   return \"%%(%s)s\"%parser.optionxform(s)\n   \n   \nclass RawConfigParser(MutableMapping):\n ''\n \n \n _SECT_TMPL=r\"\"\"\n        \\[                                 # [\n        (?P<header>[^]]+)                  # very permissive!\n        \\]                                 # ]\n        \"\"\"\n _OPT_TMPL=r\"\"\"\n        (?P<option>.*?)                    # very permissive!\n        \\s*(?P<vi>{delim})\\s*              # any number of space/tab,\n                                           # followed by any of the\n                                           # allowed delimiters,\n                                           # followed by any space/tab\n        (?P<value>.*)$                     # everything up to eol\n        \"\"\"\n _OPT_NV_TMPL=r\"\"\"\n        (?P<option>.*?)                    # very permissive!\n        \\s*(?:                             # any number of space/tab,\n        (?P<vi>{delim})\\s*                 # optionally followed by\n                                           # any of the allowed\n                                           # delimiters, followed by any\n                                           # space/tab\n        (?P<value>.*))?$                   # everything up to eol\n        \"\"\"\n \n _DEFAULT_INTERPOLATION=Interpolation()\n \n SECTCRE=re.compile(_SECT_TMPL,re.VERBOSE)\n \n OPTCRE=re.compile(_OPT_TMPL.format(delim=\"=|:\"),re.VERBOSE)\n \n \n OPTCRE_NV=re.compile(_OPT_NV_TMPL.format(delim=\"=|:\"),re.VERBOSE)\n \n NONSPACECRE=re.compile(r\"\\S\")\n \n BOOLEAN_STATES={'1':True ,'yes':True ,'true':True ,'on':True ,\n '0':False ,'no':False ,'false':False ,'off':False }\n \n def __init__(self,defaults=None ,dict_type=_default_dict,\n allow_no_value=False ,*,delimiters=('=',':'),\n comment_prefixes=('#',';'),inline_comment_prefixes=None ,\n strict=True ,empty_lines_in_values=True ,\n default_section=DEFAULTSECT,\n interpolation=_UNSET,converters=_UNSET):\n \n  self._dict=dict_type\n  self._sections=self._dict()\n  self._defaults=self._dict()\n  self._converters=ConverterMapping(self)\n  self._proxies=self._dict()\n  self._proxies[default_section]=SectionProxy(self,default_section)\n  self._delimiters=tuple(delimiters)\n  if delimiters ==('=',':'):\n   self._optcre=self.OPTCRE_NV if allow_no_value else self.OPTCRE\n  else :\n   d=\"|\".join(re.escape(d)for d in delimiters)\n   if allow_no_value:\n    self._optcre=re.compile(self._OPT_NV_TMPL.format(delim=d),\n    re.VERBOSE)\n   else :\n    self._optcre=re.compile(self._OPT_TMPL.format(delim=d),\n    re.VERBOSE)\n  self._comment_prefixes=tuple(comment_prefixes or ())\n  self._inline_comment_prefixes=tuple(inline_comment_prefixes or ())\n  self._strict=strict\n  self._allow_no_value=allow_no_value\n  self._empty_lines_in_values=empty_lines_in_values\n  self.default_section=default_section\n  self._interpolation=interpolation\n  if self._interpolation is _UNSET:\n   self._interpolation=self._DEFAULT_INTERPOLATION\n  if self._interpolation is None :\n   self._interpolation=Interpolation()\n  if converters is not _UNSET:\n   self._converters.update(converters)\n  if defaults:\n   self._read_defaults(defaults)\n   \n def defaults(self):\n  return self._defaults\n  \n def sections(self):\n  ''\n  \n  return list(self._sections.keys())\n  \n def add_section(self,section):\n  ''\n\n\n\n  \n  if section ==self.default_section:\n   raise ValueError('Invalid section name: %r'%section)\n   \n  if section in self._sections:\n   raise DuplicateSectionError(section)\n  self._sections[section]=self._dict()\n  self._proxies[section]=SectionProxy(self,section)\n  \n def has_section(self,section):\n  ''\n\n\n  \n  return section in self._sections\n  \n def options(self,section):\n  ''\n  try :\n   opts=self._sections[section].copy()\n  except KeyError:\n   raise NoSectionError(section)from None\n  opts.update(self._defaults)\n  return list(opts.keys())\n  \n def read(self,filenames,encoding=None ):\n  ''\n\n\n\n\n\n\n\n\n\n  \n  if isinstance(filenames,(str,bytes,os.PathLike)):\n   filenames=[filenames]\n  read_ok=[]\n  for filename in filenames:\n   try :\n    with open(filename,encoding=encoding)as fp:\n     self._read(fp,filename)\n   except OSError:\n    continue\n   if isinstance(filename,os.PathLike):\n    filename=os.fspath(filename)\n   read_ok.append(filename)\n  return read_ok\n  \n def read_file(self,f,source=None ):\n  ''\n\n\n\n\n\n  \n  if source is None :\n   try :\n    source=f.name\n   except AttributeError:\n    source='<???>'\n  self._read(f,source)\n  \n def read_string(self,string,source='<string>'):\n  ''\n  sfile=io.StringIO(string)\n  self.read_file(sfile,source)\n  \n def read_dict(self,dictionary,source='<dict>'):\n  ''\n\n\n\n\n\n\n\n\n\n\n  \n  elements_added=set()\n  for section,keys in dictionary.items():\n   section=str(section)\n   try :\n    self.add_section(section)\n   except (DuplicateSectionError,ValueError):\n    if self._strict and section in elements_added:\n     raise\n   elements_added.add(section)\n   for key,value in keys.items():\n    key=self.optionxform(str(key))\n    if value is not None :\n     value=str(value)\n    if self._strict and (section,key)in elements_added:\n     raise DuplicateOptionError(section,key,source)\n    elements_added.add((section,key))\n    self.set(section,key,value)\n    \n def readfp(self,fp,filename=None ):\n  ''\n  warnings.warn(\n  \"This method will be removed in future versions.  \"\n  \"Use 'parser.read_file()' instead.\",\n  DeprecationWarning,stacklevel=2\n  )\n  self.read_file(fp,source=filename)\n  \n def get(self,section,option,*,raw=False ,vars=None ,fallback=_UNSET):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  try :\n   d=self._unify_values(section,vars)\n  except NoSectionError:\n   if fallback is _UNSET:\n    raise\n   else :\n    return fallback\n  option=self.optionxform(option)\n  try :\n   value=d[option]\n  except KeyError:\n   if fallback is _UNSET:\n    raise NoOptionError(option,section)\n   else :\n    return fallback\n    \n  if raw or value is None :\n   return value\n  else :\n   return self._interpolation.before_get(self,section,option,value,\n   d)\n   \n def _get(self,section,conv,option,**kwargs):\n  return conv(self.get(section,option,**kwargs))\n  \n def _get_conv(self,section,option,conv,*,raw=False ,vars=None ,\n fallback=_UNSET,**kwargs):\n  try :\n   return self._get(section,conv,option,raw=raw,vars=vars,\n   **kwargs)\n  except (NoSectionError,NoOptionError):\n   if fallback is _UNSET:\n    raise\n   return fallback\n   \n   \n def getint(self,section,option,*,raw=False ,vars=None ,\n fallback=_UNSET,**kwargs):\n  return self._get_conv(section,option,int,raw=raw,vars=vars,\n  fallback=fallback,**kwargs)\n  \n def getfloat(self,section,option,*,raw=False ,vars=None ,\n fallback=_UNSET,**kwargs):\n  return self._get_conv(section,option,float,raw=raw,vars=vars,\n  fallback=fallback,**kwargs)\n  \n def getboolean(self,section,option,*,raw=False ,vars=None ,\n fallback=_UNSET,**kwargs):\n  return self._get_conv(section,option,self._convert_to_boolean,\n  raw=raw,vars=vars,fallback=fallback,**kwargs)\n  \n def items(self,section=_UNSET,raw=False ,vars=None ):\n  ''\n\n\n\n\n\n\n\n\n  \n  if section is _UNSET:\n   return super().items()\n  d=self._defaults.copy()\n  try :\n   d.update(self._sections[section])\n  except KeyError:\n   if section !=self.default_section:\n    raise NoSectionError(section)\n  orig_keys=list(d.keys())\n  \n  if vars:\n   for key,value in vars.items():\n    d[self.optionxform(key)]=value\n  value_getter=lambda option:self._interpolation.before_get(self,\n  section,option,d[option],d)\n  if raw:\n   value_getter=lambda option:d[option]\n  return [(option,value_getter(option))for option in orig_keys]\n  \n def popitem(self):\n  ''\n\n\n\n\n  \n  for key in self.sections():\n   value=self[key]\n   del self[key]\n   return key,value\n  raise KeyError\n  \n def optionxform(self,optionstr):\n  return optionstr.lower()\n  \n def has_option(self,section,option):\n  ''\n\n  \n  if not section or section ==self.default_section:\n   option=self.optionxform(option)\n   return option in self._defaults\n  elif section not in self._sections:\n   return False\n  else :\n   option=self.optionxform(option)\n   return (option in self._sections[section]\n   or option in self._defaults)\n   \n def set(self,section,option,value=None ):\n  ''\n  if value:\n   value=self._interpolation.before_set(self,section,option,\n   value)\n  if not section or section ==self.default_section:\n   sectdict=self._defaults\n  else :\n   try :\n    sectdict=self._sections[section]\n   except KeyError:\n    raise NoSectionError(section)from None\n  sectdict[self.optionxform(option)]=value\n  \n def write(self,fp,space_around_delimiters=True ):\n  ''\n\n\n\n  \n  if space_around_delimiters:\n   d=\" {} \".format(self._delimiters[0])\n  else :\n   d=self._delimiters[0]\n  if self._defaults:\n   self._write_section(fp,self.default_section,\n   self._defaults.items(),d)\n  for section in self._sections:\n   self._write_section(fp,section,\n   self._sections[section].items(),d)\n   \n def _write_section(self,fp,section_name,section_items,delimiter):\n  ''\n  fp.write(\"[{}]\\n\".format(section_name))\n  for key,value in section_items:\n   value=self._interpolation.before_write(self,section_name,key,\n   value)\n   if value is not None or not self._allow_no_value:\n    value=delimiter+str(value).replace('\\n','\\n\\t')\n   else :\n    value=\"\"\n   fp.write(\"{}{}\\n\".format(key,value))\n  fp.write(\"\\n\")\n  \n def remove_option(self,section,option):\n  ''\n  if not section or section ==self.default_section:\n   sectdict=self._defaults\n  else :\n   try :\n    sectdict=self._sections[section]\n   except KeyError:\n    raise NoSectionError(section)from None\n  option=self.optionxform(option)\n  existed=option in sectdict\n  if existed:\n   del sectdict[option]\n  return existed\n  \n def remove_section(self,section):\n  ''\n  existed=section in self._sections\n  if existed:\n   del self._sections[section]\n   del self._proxies[section]\n  return existed\n  \n def __getitem__(self,key):\n  if key !=self.default_section and not self.has_section(key):\n   raise KeyError(key)\n  return self._proxies[key]\n  \n def __setitem__(self,key,value):\n \n \n  if key in self and self[key]is value:\n   return\n   \n   \n  if key ==self.default_section:\n   self._defaults.clear()\n  elif key in self._sections:\n   self._sections[key].clear()\n  self.read_dict({key:value})\n  \n def __delitem__(self,key):\n  if key ==self.default_section:\n   raise ValueError(\"Cannot remove the default section.\")\n  if not self.has_section(key):\n   raise KeyError(key)\n  self.remove_section(key)\n  \n def __contains__(self,key):\n  return key ==self.default_section or self.has_section(key)\n  \n def __len__(self):\n  return len(self._sections)+1\n  \n def __iter__(self):\n \n  return itertools.chain((self.default_section,),self._sections.keys())\n  \n def _read(self,fp,fpname):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  elements_added=set()\n  cursect=None\n  sectname=None\n  optname=None\n  lineno=0\n  indent_level=0\n  e=None\n  for lineno,line in enumerate(fp,start=1):\n   comment_start=sys.maxsize\n   \n   inline_prefixes={p:-1 for p in self._inline_comment_prefixes}\n   while comment_start ==sys.maxsize and inline_prefixes:\n    next_prefixes={}\n    for prefix,index in inline_prefixes.items():\n     index=line.find(prefix,index+1)\n     if index ==-1:\n      continue\n     next_prefixes[prefix]=index\n     if index ==0 or (index >0 and line[index -1].isspace()):\n      comment_start=min(comment_start,index)\n    inline_prefixes=next_prefixes\n    \n   for prefix in self._comment_prefixes:\n    if line.strip().startswith(prefix):\n     comment_start=0\n     break\n   if comment_start ==sys.maxsize:\n    comment_start=None\n   value=line[:comment_start].strip()\n   if not value:\n    if self._empty_lines_in_values:\n    \n    \n     if (comment_start is None and\n     cursect is not None and\n     optname and\n     cursect[optname]is not None ):\n      cursect[optname].append('')\n    else :\n    \n     indent_level=sys.maxsize\n    continue\n    \n   first_nonspace=self.NONSPACECRE.search(line)\n   cur_indent_level=first_nonspace.start()if first_nonspace else 0\n   if (cursect is not None and optname and\n   cur_indent_level >indent_level):\n    cursect[optname].append(value)\n    \n   else :\n    indent_level=cur_indent_level\n    \n    mo=self.SECTCRE.match(value)\n    if mo:\n     sectname=mo.group('header')\n     if sectname in self._sections:\n      if self._strict and sectname in elements_added:\n       raise DuplicateSectionError(sectname,fpname,\n       lineno)\n      cursect=self._sections[sectname]\n      elements_added.add(sectname)\n     elif sectname ==self.default_section:\n      cursect=self._defaults\n     else :\n      cursect=self._dict()\n      self._sections[sectname]=cursect\n      self._proxies[sectname]=SectionProxy(self,sectname)\n      elements_added.add(sectname)\n      \n     optname=None\n     \n    elif cursect is None :\n     raise MissingSectionHeaderError(fpname,lineno,line)\n     \n    else :\n     mo=self._optcre.match(value)\n     if mo:\n      optname,vi,optval=mo.group('option','vi','value')\n      if not optname:\n       e=self._handle_error(e,fpname,lineno,line)\n      optname=self.optionxform(optname.rstrip())\n      if (self._strict and\n      (sectname,optname)in elements_added):\n       raise DuplicateOptionError(sectname,optname,\n       fpname,lineno)\n      elements_added.add((sectname,optname))\n      \n      \n      if optval is not None :\n       optval=optval.strip()\n       cursect[optname]=[optval]\n      else :\n      \n       cursect[optname]=None\n     else :\n     \n     \n     \n     \n      e=self._handle_error(e,fpname,lineno,line)\n  self._join_multiline_values()\n  \n  if e:\n   raise e\n   \n def _join_multiline_values(self):\n  defaults=self.default_section,self._defaults\n  all_sections=itertools.chain((defaults,),\n  self._sections.items())\n  for section,options in all_sections:\n   for name,val in options.items():\n    if isinstance(val,list):\n     val='\\n'.join(val).rstrip()\n    options[name]=self._interpolation.before_read(self,\n    section,\n    name,val)\n    \n def _read_defaults(self,defaults):\n  ''\n  \n  for key,value in defaults.items():\n   self._defaults[self.optionxform(key)]=value\n   \n def _handle_error(self,exc,fpname,lineno,line):\n  if not exc:\n   exc=ParsingError(fpname)\n  exc.append(lineno,repr(line))\n  return exc\n  \n def _unify_values(self,section,vars):\n  ''\n\n\n  \n  sectiondict={}\n  try :\n   sectiondict=self._sections[section]\n  except KeyError:\n   if section !=self.default_section:\n    raise NoSectionError(section)from None\n    \n  vardict={}\n  if vars:\n   for key,value in vars.items():\n    if value is not None :\n     value=str(value)\n    vardict[self.optionxform(key)]=value\n  return _ChainMap(vardict,sectiondict,self._defaults)\n  \n def _convert_to_boolean(self,value):\n  ''\n  \n  if value.lower()not in self.BOOLEAN_STATES:\n   raise ValueError('Not a boolean: %s'%value)\n  return self.BOOLEAN_STATES[value.lower()]\n  \n def _validate_value_types(self,*,section=\"\",option=\"\",value=\"\"):\n  ''\n\n\n\n\n\n\n\n\n\n\n  \n  if not isinstance(section,str):\n   raise TypeError(\"section names must be strings\")\n  if not isinstance(option,str):\n   raise TypeError(\"option keys must be strings\")\n  if not self._allow_no_value or value:\n   if not isinstance(value,str):\n    raise TypeError(\"option values must be strings\")\n    \n @property\n def converters(self):\n  return self._converters\n  \n  \nclass ConfigParser(RawConfigParser):\n ''\n \n _DEFAULT_INTERPOLATION=BasicInterpolation()\n \n def set(self,section,option,value=None ):\n  ''\n  \n  self._validate_value_types(option=option,value=value)\n  super().set(section,option,value)\n  \n def add_section(self,section):\n  ''\n\n  \n  self._validate_value_types(section=section)\n  super().add_section(section)\n  \n def _read_defaults(self,defaults):\n  ''\n\n\n\n  \n  try :\n   hold_interpolation=self._interpolation\n   self._interpolation=Interpolation()\n   self.read_dict({self.default_section:defaults})\n  finally :\n   self._interpolation=hold_interpolation\n   \n   \nclass SafeConfigParser(ConfigParser):\n ''\n \n def __init__(self,*args,**kwargs):\n  super().__init__(*args,**kwargs)\n  warnings.warn(\n  \"The SafeConfigParser class has been renamed to ConfigParser \"\n  \"in Python 3.2. This alias will be removed in future versions.\"\n  \" Use ConfigParser directly instead.\",\n  DeprecationWarning,stacklevel=2\n  )\n  \n  \nclass SectionProxy(MutableMapping):\n ''\n \n def __init__(self,parser,name):\n  ''\n  self._parser=parser\n  self._name=name\n  for conv in parser.converters:\n   key='get'+conv\n   getter=functools.partial(self.get,_impl=getattr(parser,key))\n   setattr(self,key,getter)\n   \n def __repr__(self):\n  return '<Section: {}>'.format(self._name)\n  \n def __getitem__(self,key):\n  if not self._parser.has_option(self._name,key):\n   raise KeyError(key)\n  return self._parser.get(self._name,key)\n  \n def __setitem__(self,key,value):\n  self._parser._validate_value_types(option=key,value=value)\n  return self._parser.set(self._name,key,value)\n  \n def __delitem__(self,key):\n  if not (self._parser.has_option(self._name,key)and\n  self._parser.remove_option(self._name,key)):\n   raise KeyError(key)\n   \n def __contains__(self,key):\n  return self._parser.has_option(self._name,key)\n  \n def __len__(self):\n  return len(self._options())\n  \n def __iter__(self):\n  return self._options().__iter__()\n  \n def _options(self):\n  if self._name !=self._parser.default_section:\n   return self._parser.options(self._name)\n  else :\n   return self._parser.defaults()\n   \n @property\n def parser(self):\n \n  return self._parser\n  \n @property\n def name(self):\n \n  return self._name\n  \n def get(self,option,fallback=None ,*,raw=False ,vars=None ,\n _impl=None ,**kwargs):\n  ''\n\n\n\n\n  \n  \n  \n  if not _impl:\n   _impl=self._parser.get\n  return _impl(self._name,option,raw=raw,vars=vars,\n  fallback=fallback,**kwargs)\n  \n  \nclass ConverterMapping(MutableMapping):\n ''\n\n\n\n\n \n \n GETTERCRE=re.compile(r\"^get(?P<name>.+)$\")\n \n def __init__(self,parser):\n  self._parser=parser\n  self._data={}\n  for getter in dir(self._parser):\n   m=self.GETTERCRE.match(getter)\n   if not m or not callable(getattr(self._parser,getter)):\n    continue\n   self._data[m.group('name')]=None\n   \n def __getitem__(self,key):\n  return self._data[key]\n  \n def __setitem__(self,key,value):\n  try :\n   k='get'+key\n  except TypeError:\n   raise ValueError('Incompatible key: {} (type: {})'\n   ''.format(key,type(key)))\n  if k =='get':\n   raise ValueError('Incompatible key: cannot use \"\" as a name')\n  self._data[key]=value\n  func=functools.partial(self._parser._get_conv,conv=value)\n  func.converter=value\n  setattr(self._parser,k,func)\n  for proxy in self._parser.values():\n   getter=functools.partial(proxy.get,_impl=func)\n   setattr(proxy,k,getter)\n   \n def __delitem__(self,key):\n  try :\n   k='get'+(key or None )\n  except TypeError:\n   raise KeyError(key)\n  del self._data[key]\n  for inst in itertools.chain((self._parser,),self._parser.values()):\n   try :\n    delattr(inst,k)\n   except AttributeError:\n   \n   \n    continue\n    \n def __iter__(self):\n  return iter(self._data)\n  \n def __len__(self):\n  return len(self._data)\n", ["collections", "collections.abc", "functools", "io", "itertools", "os", "re", "sys", "warnings"]],
     "contextlib": [".py", "''\nimport abc\nimport sys\nimport _collections_abc\nfrom collections import deque\nfrom functools import wraps\nfrom types import MethodType,GenericAlias\n\n__all__=[\"asynccontextmanager\",\"contextmanager\",\"closing\",\"nullcontext\",\n\"AbstractContextManager\",\"AbstractAsyncContextManager\",\n\"AsyncExitStack\",\"ContextDecorator\",\"ExitStack\",\n\"redirect_stdout\",\"redirect_stderr\",\"suppress\"]\n\n\nclass AbstractContextManager(abc.ABC):\n\n ''\n \n __class_getitem__=classmethod(GenericAlias)\n \n def __enter__(self):\n  ''\n  return self\n  \n @abc.abstractmethod\n def __exit__(self,exc_type,exc_value,traceback):\n  ''\n  return None\n  \n @classmethod\n def __subclasshook__(cls,C):\n  if cls is AbstractContextManager:\n   return _collections_abc._check_methods(C,\"__enter__\",\"__exit__\")\n  return NotImplemented\n  \n  \nclass AbstractAsyncContextManager(abc.ABC):\n\n ''\n \n __class_getitem__=classmethod(GenericAlias)\n \n async def __aenter__(self):\n  ''\n  return self\n  \n @abc.abstractmethod\n async def __aexit__(self,exc_type,exc_value,traceback):\n  ''\n  return None\n  \n @classmethod\n def __subclasshook__(cls,C):\n  if cls is AbstractAsyncContextManager:\n   return _collections_abc._check_methods(C,\"__aenter__\",\n   \"__aexit__\")\n  return NotImplemented\n  \n  \nclass ContextDecorator(object):\n ''\n \n def _recreate_cm(self):\n  ''\n\n\n\n\n\n\n\n  \n  return self\n  \n def __call__(self,func):\n  @wraps(func)\n  def inner(*args,**kwds):\n   with self._recreate_cm():\n    return func(*args,**kwds)\n  return inner\n  \n  \nclass _GeneratorContextManagerBase:\n ''\n \n def __init__(self,func,args,kwds):\n  self.gen=func(*args,**kwds)\n  self.func,self.args,self.kwds=func,args,kwds\n  \n  doc=getattr(func,\"__doc__\",None )\n  if doc is None :\n   doc=type(self).__doc__\n  self.__doc__=doc\n  \n  \n  \n  \n  \n  \n  \nclass _GeneratorContextManager(_GeneratorContextManagerBase,\nAbstractContextManager,\nContextDecorator):\n ''\n \n def _recreate_cm(self):\n \n \n \n  return self.__class__(self.func,self.args,self.kwds)\n  \n def __enter__(self):\n \n \n  del self.args,self.kwds,self.func\n  try :\n   return next(self.gen)\n  except StopIteration:\n   raise RuntimeError(\"generator didn't yield\")from None\n   \n def __exit__(self,type,value,traceback):\n  if type is None :\n   try :\n    next(self.gen)\n   except StopIteration:\n    return False\n   else :\n    raise RuntimeError(\"generator didn't stop\")\n  else :\n   if value is None :\n   \n   \n    value=type()\n   try :\n    self.gen.throw(type,value,traceback)\n   except StopIteration as exc:\n   \n   \n   \n    return exc is not value\n   except RuntimeError as exc:\n   \n    if exc is value:\n     return False\n     \n     \n     \n    if type is StopIteration and exc.__cause__ is value:\n     return False\n    raise\n   except :\n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n    if sys.exc_info()[1]is value:\n     return False\n    raise\n   raise RuntimeError(\"generator didn't stop after throw()\")\n   \n   \nclass _AsyncGeneratorContextManager(_GeneratorContextManagerBase,\nAbstractAsyncContextManager):\n ''\n \n async def __aenter__(self):\n  try :\n   return await self.gen.__anext__()\n  except StopAsyncIteration:\n   raise RuntimeError(\"generator didn't yield\")from None\n   \n async def __aexit__(self,typ,value,traceback):\n  if typ is None :\n   try :\n    await self.gen.__anext__()\n   except StopAsyncIteration:\n    return\n   else :\n    raise RuntimeError(\"generator didn't stop\")\n  else :\n   if value is None :\n    value=typ()\n    \n    \n   try :\n    await self.gen.athrow(typ,value,traceback)\n    raise RuntimeError(\"generator didn't stop after athrow()\")\n   except StopAsyncIteration as exc:\n    return exc is not value\n   except RuntimeError as exc:\n    if exc is value:\n     return False\n     \n     \n     \n     \n     \n     \n    if isinstance(value,(StopIteration,StopAsyncIteration)):\n     if exc.__cause__ is value:\n      return False\n    raise\n   except BaseException as exc:\n    if exc is not value:\n     raise\n     \n     \ndef contextmanager(func):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n @wraps(func)\n def helper(*args,**kwds):\n  return _GeneratorContextManager(func,args,kwds)\n return helper\n \n \ndef asynccontextmanager(func):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n @wraps(func)\n def helper(*args,**kwds):\n  return _AsyncGeneratorContextManager(func,args,kwds)\n return helper\n \n \nclass closing(AbstractContextManager):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n def __init__(self,thing):\n  self.thing=thing\n def __enter__(self):\n  return self.thing\n def __exit__(self,*exc_info):\n  self.thing.close()\n  \n  \nclass _RedirectStream(AbstractContextManager):\n\n _stream=None\n \n def __init__(self,new_target):\n  self._new_target=new_target\n  \n  self._old_targets=[]\n  \n def __enter__(self):\n  self._old_targets.append(getattr(sys,self._stream))\n  setattr(sys,self._stream,self._new_target)\n  return self._new_target\n  \n def __exit__(self,exctype,excinst,exctb):\n  setattr(sys,self._stream,self._old_targets.pop())\n  \n  \nclass redirect_stdout(_RedirectStream):\n ''\n\n\n\n\n\n\n\n\n\n \n \n _stream=\"stdout\"\n \n \nclass redirect_stderr(_RedirectStream):\n ''\n \n _stream=\"stderr\"\n \n \nclass suppress(AbstractContextManager):\n ''\n\n\n\n\n\n\n\n \n \n def __init__(self,*exceptions):\n  self._exceptions=exceptions\n  \n def __enter__(self):\n  pass\n  \n def __exit__(self,exctype,excinst,exctb):\n \n \n \n \n \n \n \n \n \n  return exctype is not None and issubclass(exctype,self._exceptions)\n  \n  \nclass _BaseExitStack:\n ''\n \n @staticmethod\n def _create_exit_wrapper(cm,cm_exit):\n  return MethodType(cm_exit,cm)\n  \n @staticmethod\n def _create_cb_wrapper(callback,/,*args,**kwds):\n  def _exit_wrapper(exc_type,exc,tb):\n   callback(*args,**kwds)\n  return _exit_wrapper\n  \n def __init__(self):\n  self._exit_callbacks=deque()\n  \n def pop_all(self):\n  ''\n  new_stack=type(self)()\n  new_stack._exit_callbacks=self._exit_callbacks\n  self._exit_callbacks=deque()\n  return new_stack\n  \n def push(self,exit):\n  ''\n\n\n\n\n  \n  \n  \n  _cb_type=type(exit)\n  \n  try :\n   exit_method=_cb_type.__exit__\n  except AttributeError:\n  \n   self._push_exit_callback(exit)\n  else :\n   self._push_cm_exit(exit,exit_method)\n  return exit\n  \n def enter_context(self,cm):\n  ''\n\n\n\n  \n  \n  \n  _cm_type=type(cm)\n  _exit=_cm_type.__exit__\n  result=_cm_type.__enter__(cm)\n  self._push_cm_exit(cm,_exit)\n  return result\n  \n def callback(self,callback,/,*args,**kwds):\n  ''\n\n\n  \n  _exit_wrapper=self._create_cb_wrapper(callback,*args,**kwds)\n  \n  \n  \n  _exit_wrapper.__wrapped__=callback\n  self._push_exit_callback(_exit_wrapper)\n  return callback\n  \n def _push_cm_exit(self,cm,cm_exit):\n  ''\n  _exit_wrapper=self._create_exit_wrapper(cm,cm_exit)\n  self._push_exit_callback(_exit_wrapper,True )\n  \n def _push_exit_callback(self,callback,is_sync=True ):\n  self._exit_callbacks.append((is_sync,callback))\n  \n  \n  \nclass ExitStack(_BaseExitStack,AbstractContextManager):\n ''\n\n\n\n\n\n\n\n \n \n def __enter__(self):\n  return self\n  \n def __exit__(self,*exc_details):\n  received_exc=exc_details[0]is not None\n  \n  \n  \n  frame_exc=sys.exc_info()[1]\n  def _fix_exception_context(new_exc,old_exc):\n  \n   while 1:\n    exc_context=new_exc.__context__\n    if exc_context is old_exc:\n    \n     return\n    if exc_context is None or exc_context is frame_exc:\n     break\n    new_exc=exc_context\n    \n    \n   new_exc.__context__=old_exc\n   \n   \n   \n  suppressed_exc=False\n  pending_raise=False\n  while self._exit_callbacks:\n   is_sync,cb=self._exit_callbacks.pop()\n   assert is_sync\n   try :\n    if cb(*exc_details):\n     suppressed_exc=True\n     pending_raise=False\n     exc_details=(None ,None ,None )\n   except :\n    new_exc_details=sys.exc_info()\n    \n    _fix_exception_context(new_exc_details[1],exc_details[1])\n    pending_raise=True\n    exc_details=new_exc_details\n  if pending_raise:\n   try :\n   \n   \n    fixed_ctx=exc_details[1].__context__\n    raise exc_details[1]\n   except BaseException:\n    exc_details[1].__context__=fixed_ctx\n    raise\n  return received_exc and suppressed_exc\n  \n def close(self):\n  ''\n  self.__exit__(None ,None ,None )\n  \n  \n  \nclass AsyncExitStack(_BaseExitStack,AbstractAsyncContextManager):\n ''\n\n\n\n\n\n\n\n\n\n \n \n @staticmethod\n def _create_async_exit_wrapper(cm,cm_exit):\n  return MethodType(cm_exit,cm)\n  \n @staticmethod\n def _create_async_cb_wrapper(callback,/,*args,**kwds):\n  async def _exit_wrapper(exc_type,exc,tb):\n   await callback(*args,**kwds)\n  return _exit_wrapper\n  \n async def enter_async_context(self,cm):\n  ''\n\n\n\n  \n  _cm_type=type(cm)\n  _exit=_cm_type.__aexit__\n  result=await _cm_type.__aenter__(cm)\n  self._push_async_cm_exit(cm,_exit)\n  return result\n  \n def push_async_exit(self,exit):\n  ''\n\n\n\n\n\n  \n  _cb_type=type(exit)\n  try :\n   exit_method=_cb_type.__aexit__\n  except AttributeError:\n  \n   self._push_exit_callback(exit,False )\n  else :\n   self._push_async_cm_exit(exit,exit_method)\n  return exit\n  \n def push_async_callback(self,callback,/,*args,**kwds):\n  ''\n\n\n  \n  _exit_wrapper=self._create_async_cb_wrapper(callback,*args,**kwds)\n  \n  \n  \n  _exit_wrapper.__wrapped__=callback\n  self._push_exit_callback(_exit_wrapper,False )\n  return callback\n  \n async def aclose(self):\n  ''\n  await self.__aexit__(None ,None ,None )\n  \n def _push_async_cm_exit(self,cm,cm_exit):\n  ''\n  \n  _exit_wrapper=self._create_async_exit_wrapper(cm,cm_exit)\n  self._push_exit_callback(_exit_wrapper,False )\n  \n async def __aenter__(self):\n  return self\n  \n async def __aexit__(self,*exc_details):\n  received_exc=exc_details[0]is not None\n  \n  \n  \n  frame_exc=sys.exc_info()[1]\n  def _fix_exception_context(new_exc,old_exc):\n  \n   while 1:\n    exc_context=new_exc.__context__\n    if exc_context is old_exc:\n    \n     return\n    if exc_context is None or exc_context is frame_exc:\n     break\n    new_exc=exc_context\n    \n    \n   new_exc.__context__=old_exc\n   \n   \n   \n  suppressed_exc=False\n  pending_raise=False\n  while self._exit_callbacks:\n   is_sync,cb=self._exit_callbacks.pop()\n   try :\n    if is_sync:\n     cb_suppress=cb(*exc_details)\n    else :\n     cb_suppress=await cb(*exc_details)\n     \n    if cb_suppress:\n     suppressed_exc=True\n     pending_raise=False\n     exc_details=(None ,None ,None )\n   except :\n    new_exc_details=sys.exc_info()\n    \n    _fix_exception_context(new_exc_details[1],exc_details[1])\n    pending_raise=True\n    exc_details=new_exc_details\n  if pending_raise:\n   try :\n   \n   \n    fixed_ctx=exc_details[1].__context__\n    raise exc_details[1]\n   except BaseException:\n    exc_details[1].__context__=fixed_ctx\n    raise\n  return received_exc and suppressed_exc\n  \n  \nclass nullcontext(AbstractContextManager):\n ''\n\n\n\n\n\n\n\n \n \n def __init__(self,enter_result=None ):\n  self.enter_result=enter_result\n  \n def __enter__(self):\n  return self.enter_result\n  \n def __exit__(self,*excinfo):\n  pass\n", ["_collections_abc", "abc", "collections", "functools", "sys", "types"]],
     "contextvars": [".py", "from _contextvars import Context,ContextVar,Token,copy_context\n\n\n__all__=('Context','ContextVar','Token','copy_context')\n", ["_contextvars"]],
     "copy": [".py", "''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nimport types\nimport weakref\nfrom copyreg import dispatch_table\n\nclass Error(Exception):\n pass\nerror=Error\n\ntry :\n from org.python.core import PyStringMap\nexcept ImportError:\n PyStringMap=None\n \n__all__=[\"Error\",\"copy\",\"deepcopy\"]\n\ndef copy(x):\n ''\n\n\n \n \n cls=type(x)\n \n copier=_copy_dispatch.get(cls)\n if copier:\n  return copier(x)\n  \n if issubclass(cls,type):\n \n  return _copy_immutable(x)\n  \n copier=getattr(cls,\"__copy__\",None )\n if copier is not None :\n  return copier(x)\n  \n reductor=dispatch_table.get(cls)\n if reductor is not None :\n  rv=reductor(x)\n else :\n  reductor=getattr(x,\"__reduce_ex__\",None )\n  if reductor is not None :\n   rv=reductor(4)\n  else :\n   reductor=getattr(x,\"__reduce__\",None )\n   if reductor:\n    rv=reductor()\n   else :\n    raise Error(\"un(shallow)copyable object of type %s\"%cls)\n    \n if isinstance(rv,str):\n  return x\n return _reconstruct(x,None ,*rv)\n \n \n_copy_dispatch=d={}\n\ndef _copy_immutable(x):\n return x\nfor t in (type(None ),int,float,bool,complex,str,tuple,\nbytes,frozenset,type,range,slice,property,\ntypes.BuiltinFunctionType,type(Ellipsis),type(NotImplemented),\ntypes.FunctionType,weakref.ref):\n d[t]=_copy_immutable\nt=getattr(types,\"CodeType\",None )\nif t is not None :\n d[t]=_copy_immutable\n \nd[list]=list.copy\nd[dict]=dict.copy\nd[set]=set.copy\nd[bytearray]=bytearray.copy\n\nif PyStringMap is not None :\n d[PyStringMap]=PyStringMap.copy\n \ndel d,t\n\ndef deepcopy(x,memo=None ,_nil=[]):\n ''\n\n\n \n \n if memo is None :\n  memo={}\n  \n d=id(x)\n y=memo.get(d,_nil)\n if y is not _nil:\n  return y\n  \n cls=type(x)\n \n copier=_deepcopy_dispatch.get(cls)\n if copier is not None :\n  y=copier(x,memo)\n else :\n  if issubclass(cls,type):\n   y=_deepcopy_atomic(x,memo)\n  else :\n   copier=getattr(x,\"__deepcopy__\",None )\n   if copier is not None :\n    y=copier(memo)\n   else :\n    reductor=dispatch_table.get(cls)\n    if reductor:\n     rv=reductor(x)\n    else :\n     reductor=getattr(x,\"__reduce_ex__\",None )\n     if reductor is not None :\n      rv=reductor(4)\n     else :\n      reductor=getattr(x,\"__reduce__\",None )\n      if reductor:\n       rv=reductor()\n      else :\n       raise Error(\n       \"un(deep)copyable object of type %s\"%cls)\n    if isinstance(rv,str):\n     y=x\n    else :\n     y=_reconstruct(x,memo,*rv)\n     \n     \n if y is not x:\n  memo[d]=y\n  _keep_alive(x,memo)\n return y\n \n_deepcopy_dispatch=d={}\n\ndef _deepcopy_atomic(x,memo):\n return x\nd[type(None )]=_deepcopy_atomic\nd[type(Ellipsis)]=_deepcopy_atomic\nd[type(NotImplemented)]=_deepcopy_atomic\nd[int]=_deepcopy_atomic\nd[float]=_deepcopy_atomic\nd[bool]=_deepcopy_atomic\nd[complex]=_deepcopy_atomic\nd[bytes]=_deepcopy_atomic\nd[str]=_deepcopy_atomic\nd[types.CodeType]=_deepcopy_atomic\nd[type]=_deepcopy_atomic\nd[types.BuiltinFunctionType]=_deepcopy_atomic\nd[types.FunctionType]=_deepcopy_atomic\nd[weakref.ref]=_deepcopy_atomic\nd[property]=_deepcopy_atomic\n\ndef _deepcopy_list(x,memo,deepcopy=deepcopy):\n y=[]\n memo[id(x)]=y\n append=y.append\n for a in x:\n  append(deepcopy(a,memo))\n return y\nd[list]=_deepcopy_list\n\ndef _deepcopy_tuple(x,memo,deepcopy=deepcopy):\n y=[deepcopy(a,memo)for a in x]\n \n \n try :\n  return memo[id(x)]\n except KeyError:\n  pass\n for k,j in zip(x,y):\n  if k is not j:\n   y=tuple(y)\n   break\n else :\n  y=x\n return y\nd[tuple]=_deepcopy_tuple\n\ndef _deepcopy_dict(x,memo,deepcopy=deepcopy):\n y={}\n memo[id(x)]=y\n for key,value in x.items():\n  y[deepcopy(key,memo)]=deepcopy(value,memo)\n return y\nd[dict]=_deepcopy_dict\nif PyStringMap is not None :\n d[PyStringMap]=_deepcopy_dict\n \ndef _deepcopy_method(x,memo):\n return type(x)(x.__func__,deepcopy(x.__self__,memo))\nd[types.MethodType]=_deepcopy_method\n\ndel d\n\ndef _keep_alive(x,memo):\n ''\n\n\n\n\n\n\n\n \n try :\n  memo[id(memo)].append(x)\n except KeyError:\n \n  memo[id(memo)]=[x]\n  \ndef _reconstruct(x,memo,func,args,\nstate=None ,listiter=None ,dictiter=None ,\ndeepcopy=deepcopy):\n deep=memo is not None\n if deep and args:\n  args=(deepcopy(arg,memo)for arg in args)\n y=func(*args)\n if deep:\n  memo[id(x)]=y\n  \n if state is not None :\n  if deep:\n   state=deepcopy(state,memo)\n  if hasattr(y,'__setstate__'):\n   y.__setstate__(state)\n  else :\n   if isinstance(state,tuple)and len(state)==2:\n    state,slotstate=state\n   else :\n    slotstate=None\n   if state is not None :\n    y.__dict__.update(state)\n   if slotstate is not None :\n    for key,value in slotstate.items():\n     setattr(y,key,value)\n     \n if listiter is not None :\n  if deep:\n   for item in listiter:\n    item=deepcopy(item,memo)\n    y.append(item)\n  else :\n   for item in listiter:\n    y.append(item)\n if dictiter is not None :\n  if deep:\n   for key,value in dictiter:\n    key=deepcopy(key,memo)\n    value=deepcopy(value,memo)\n    y[key]=value\n  else :\n   for key,value in dictiter:\n    y[key]=value\n return y\n \ndel types,weakref,PyStringMap\n", ["copyreg", "org.python.core", "types", "weakref"]],
     "copyreg": [".py", "''\n\n\n\n\n\n__all__=[\"pickle\",\"constructor\",\n\"add_extension\",\"remove_extension\",\"clear_extension_cache\"]\n\ndispatch_table={}\n\ndef pickle(ob_type,pickle_function,constructor_ob=None ):\n if not callable(pickle_function):\n  raise TypeError(\"reduction functions must be callable\")\n dispatch_table[ob_type]=pickle_function\n \n \n \n if constructor_ob is not None :\n  constructor(constructor_ob)\n  \ndef constructor(object):\n if not callable(object):\n  raise TypeError(\"constructors must be callable\")\n  \n  \n  \ntry :\n complex\nexcept NameError:\n pass\nelse :\n\n def pickle_complex(c):\n  return complex,(c.real,c.imag)\n  \n pickle(complex,pickle_complex,complex)\n \n \n \ndef _reconstructor(cls,base,state):\n if base is object:\n  obj=object.__new__(cls)\n else :\n  obj=base.__new__(cls,state)\n  if base.__init__ !=object.__init__:\n   base.__init__(obj,state)\n return obj\n \n_HEAPTYPE=1 <<9\n\n\n\ndef _reduce_ex(self,proto):\n assert proto <2\n cls=self.__class__\n for base in cls.__mro__:\n  if hasattr(base,'__flags__')and not base.__flags__&_HEAPTYPE:\n   break\n else :\n  base=object\n if base is object:\n  state=None\n else :\n  if base is cls:\n   raise TypeError(f\"cannot pickle {cls.__name__!r} object\")\n  state=base(self)\n args=(cls,base,state)\n try :\n  getstate=self.__getstate__\n except AttributeError:\n  if getattr(self,\"__slots__\",None ):\n   raise TypeError(f\"cannot pickle {cls.__name__!r} object: \"\n   f\"a class that defines __slots__ without \"\n   f\"defining __getstate__ cannot be pickled \"\n   f\"with protocol {proto}\")from None\n  try :\n   dict=self.__dict__\n  except AttributeError:\n   dict=None\n else :\n  dict=getstate()\n if dict:\n  return _reconstructor,args,dict\n else :\n  return _reconstructor,args\n  \n  \n  \ndef __newobj__(cls,*args):\n return cls.__new__(cls,*args)\n \ndef __newobj_ex__(cls,args,kwargs):\n ''\n\n \n return cls.__new__(cls,*args,**kwargs)\n \ndef _slotnames(cls):\n ''\n\n\n\n\n\n\n\n \n \n \n names=cls.__dict__.get(\"__slotnames__\")\n if names is not None :\n  return names\n  \n  \n names=[]\n if not hasattr(cls,\"__slots__\"):\n \n  pass\n else :\n \n  for c in cls.__mro__:\n   if \"__slots__\"in c.__dict__:\n    slots=c.__dict__['__slots__']\n    \n    if isinstance(slots,str):\n     slots=(slots,)\n    for name in slots:\n    \n     if name in (\"__dict__\",\"__weakref__\"):\n      continue\n      \n     elif name.startswith('__')and not name.endswith('__'):\n      stripped=c.__name__.lstrip('_')\n      if stripped:\n       names.append('_%s%s'%(stripped,name))\n      else :\n       names.append(name)\n     else :\n      names.append(name)\n      \n      \n try :\n  cls.__slotnames__=names\n except :\n  pass\n  \n return names\n \n \n \n \n \n \n \n \n \n \n_extension_registry={}\n_inverted_registry={}\n_extension_cache={}\n\n\n\ndef add_extension(module,name,code):\n ''\n code=int(code)\n if not 1 <=code <=0x7fffffff:\n  raise ValueError(\"code out of range\")\n key=(module,name)\n if (_extension_registry.get(key)==code and\n _inverted_registry.get(code)==key):\n  return\n if key in _extension_registry:\n  raise ValueError(\"key %s is already registered with code %s\"%\n  (key,_extension_registry[key]))\n if code in _inverted_registry:\n  raise ValueError(\"code %s is already in use for key %s\"%\n  (code,_inverted_registry[code]))\n _extension_registry[key]=code\n _inverted_registry[code]=key\n \ndef remove_extension(module,name,code):\n ''\n key=(module,name)\n if (_extension_registry.get(key)!=code or\n _inverted_registry.get(code)!=key):\n  raise ValueError(\"key %s is not registered with code %s\"%\n  (key,code))\n del _extension_registry[key]\n del _inverted_registry[code]\n if code in _extension_cache:\n  del _extension_cache[code]\n  \ndef clear_extension_cache():\n _extension_cache.clear()\n \n \n \n \n \n \n \n \n \n \n \n \n \n", []],
     "csv": [".py", "\n\"\"\"\ncsv.py - read/write/investigate CSV files\n\"\"\"\n\nimport re\nfrom _csv import Error,__version__,writer,reader,register_dialect,\\\nunregister_dialect,get_dialect,list_dialects,\\\nfield_size_limit,\\\nQUOTE_MINIMAL,QUOTE_ALL,QUOTE_NONNUMERIC,QUOTE_NONE,\\\n__doc__\nfrom _csv import Dialect as _Dialect\n\nfrom io import StringIO\n\n__all__=[\"QUOTE_MINIMAL\",\"QUOTE_ALL\",\"QUOTE_NONNUMERIC\",\"QUOTE_NONE\",\n\"Error\",\"Dialect\",\"__doc__\",\"excel\",\"excel_tab\",\n\"field_size_limit\",\"reader\",\"writer\",\n\"register_dialect\",\"get_dialect\",\"list_dialects\",\"Sniffer\",\n\"unregister_dialect\",\"__version__\",\"DictReader\",\"DictWriter\",\n\"unix_dialect\"]\n\nclass Dialect:\n ''\n\n\n\n\n\n \n _name=\"\"\n _valid=False\n \n delimiter=None\n quotechar=None\n escapechar=None\n doublequote=None\n skipinitialspace=None\n lineterminator=None\n quoting=None\n \n def __init__(self):\n  if self.__class__ !=Dialect:\n   self._valid=True\n  self._validate()\n  \n def _validate(self):\n  try :\n   _Dialect(self)\n  except TypeError as e:\n  \n   raise Error(str(e))\n   \nclass excel(Dialect):\n ''\n delimiter=','\n quotechar='\"'\n doublequote=True\n skipinitialspace=False\n lineterminator='\\r\\n'\n quoting=QUOTE_MINIMAL\nregister_dialect(\"excel\",excel)\n\nclass excel_tab(excel):\n ''\n delimiter='\\t'\nregister_dialect(\"excel-tab\",excel_tab)\n\nclass unix_dialect(Dialect):\n ''\n delimiter=','\n quotechar='\"'\n doublequote=True\n skipinitialspace=False\n lineterminator='\\n'\n quoting=QUOTE_ALL\nregister_dialect(\"unix\",unix_dialect)\n\n\nclass DictReader:\n def __init__(self,f,fieldnames=None ,restkey=None ,restval=None ,\n dialect=\"excel\",*args,**kwds):\n  self._fieldnames=fieldnames\n  self.restkey=restkey\n  self.restval=restval\n  self.reader=reader(f,dialect,*args,**kwds)\n  self.dialect=dialect\n  self.line_num=0\n  \n def __iter__(self):\n  return self\n  \n @property\n def fieldnames(self):\n  if self._fieldnames is None :\n   try :\n    self._fieldnames=next(self.reader)\n   except StopIteration:\n    pass\n  self.line_num=self.reader.line_num\n  return self._fieldnames\n  \n @fieldnames.setter\n def fieldnames(self,value):\n  self._fieldnames=value\n  \n def __next__(self):\n  if self.line_num ==0:\n  \n   self.fieldnames\n  row=next(self.reader)\n  self.line_num=self.reader.line_num\n  \n  \n  \n  \n  while row ==[]:\n   row=next(self.reader)\n  d=dict(zip(self.fieldnames,row))\n  lf=len(self.fieldnames)\n  lr=len(row)\n  if lf <lr:\n   d[self.restkey]=row[lf:]\n  elif lf >lr:\n   for key in self.fieldnames[lr:]:\n    d[key]=self.restval\n  return d\n  \n  \nclass DictWriter:\n def __init__(self,f,fieldnames,restval=\"\",extrasaction=\"raise\",\n dialect=\"excel\",*args,**kwds):\n  self.fieldnames=fieldnames\n  self.restval=restval\n  if extrasaction.lower()not in (\"raise\",\"ignore\"):\n   raise ValueError(\"extrasaction (%s) must be 'raise' or 'ignore'\"\n   %extrasaction)\n  self.extrasaction=extrasaction\n  self.writer=writer(f,dialect,*args,**kwds)\n  \n def writeheader(self):\n  header=dict(zip(self.fieldnames,self.fieldnames))\n  return self.writerow(header)\n  \n def _dict_to_list(self,rowdict):\n  if self.extrasaction ==\"raise\":\n   wrong_fields=rowdict.keys()-self.fieldnames\n   if wrong_fields:\n    raise ValueError(\"dict contains fields not in fieldnames: \"\n    +\", \".join([repr(x)for x in wrong_fields]))\n  return (rowdict.get(key,self.restval)for key in self.fieldnames)\n  \n def writerow(self,rowdict):\n  return self.writer.writerow(self._dict_to_list(rowdict))\n  \n def writerows(self,rowdicts):\n  return self.writer.writerows(map(self._dict_to_list,rowdicts))\n  \n  \ntry :\n complex\nexcept NameError:\n complex=float\n \nclass Sniffer:\n ''\n\n\n \n def __init__(self):\n \n  self.preferred=[',','\\t',';',' ',':']\n  \n  \n def sniff(self,sample,delimiters=None ):\n  ''\n\n  \n  \n  quotechar,doublequote,delimiter,skipinitialspace=\\\n  self._guess_quote_and_delimiter(sample,delimiters)\n  if not delimiter:\n   delimiter,skipinitialspace=self._guess_delimiter(sample,\n   delimiters)\n   \n  if not delimiter:\n   raise Error(\"Could not determine delimiter\")\n   \n  class dialect(Dialect):\n   _name=\"sniffed\"\n   lineterminator='\\r\\n'\n   quoting=QUOTE_MINIMAL\n   \n   \n  dialect.doublequote=doublequote\n  dialect.delimiter=delimiter\n  \n  dialect.quotechar=quotechar or '\"'\n  dialect.skipinitialspace=skipinitialspace\n  \n  return dialect\n  \n  \n def _guess_quote_and_delimiter(self,data,delimiters):\n  ''\n\n\n\n\n\n\n\n\n  \n  \n  matches=[]\n  for restr in (r'(?P<delim>[^\\w\\n\"\\'])(?P<space> ?)(?P<quote>[\"\\']).*?(?P=quote)(?P=delim)',\n  r'(?:^|\\n)(?P<quote>[\"\\']).*?(?P=quote)(?P<delim>[^\\w\\n\"\\'])(?P<space> ?)',\n  r'(?P<delim>[^\\w\\n\"\\'])(?P<space> ?)(?P<quote>[\"\\']).*?(?P=quote)(?:$|\\n)',\n  r'(?:^|\\n)(?P<quote>[\"\\']).*?(?P=quote)(?:$|\\n)'):\n   regexp=re.compile(restr,re.DOTALL |re.MULTILINE)\n   matches=regexp.findall(data)\n   if matches:\n    break\n    \n  if not matches:\n  \n   return ('',False ,None ,0)\n  quotes={}\n  delims={}\n  spaces=0\n  groupindex=regexp.groupindex\n  for m in matches:\n   n=groupindex['quote']-1\n   key=m[n]\n   if key:\n    quotes[key]=quotes.get(key,0)+1\n   try :\n    n=groupindex['delim']-1\n    key=m[n]\n   except KeyError:\n    continue\n   if key and (delimiters is None or key in delimiters):\n    delims[key]=delims.get(key,0)+1\n   try :\n    n=groupindex['space']-1\n   except KeyError:\n    continue\n   if m[n]:\n    spaces +=1\n    \n  quotechar=max(quotes,key=quotes.get)\n  \n  if delims:\n   delim=max(delims,key=delims.get)\n   skipinitialspace=delims[delim]==spaces\n   if delim =='\\n':\n    delim=''\n  else :\n  \n   delim=''\n   skipinitialspace=0\n   \n   \n   \n  dq_regexp=re.compile(\n  r\"((%(delim)s)|^)\\W*%(quote)s[^%(delim)s\\n]*%(quote)s[^%(delim)s\\n]*%(quote)s\\W*((%(delim)s)|$)\"%\\\n  {'delim':re.escape(delim),'quote':quotechar},re.MULTILINE)\n  \n  \n  \n  if dq_regexp.search(data):\n   doublequote=True\n  else :\n   doublequote=False\n   \n  return (quotechar,doublequote,delim,skipinitialspace)\n  \n  \n def _guess_delimiter(self,data,delimiters):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  \n  data=list(filter(None ,data.split('\\n')))\n  \n  ascii=[chr(c)for c in range(127)]\n  \n  \n  chunkLength=min(10,len(data))\n  iteration=0\n  charFrequency={}\n  modes={}\n  delims={}\n  start,end=0,chunkLength\n  while start <len(data):\n   iteration +=1\n   for line in data[start:end]:\n    for char in ascii:\n     metaFrequency=charFrequency.get(char,{})\n     \n     freq=line.count(char)\n     \n     metaFrequency[freq]=metaFrequency.get(freq,0)+1\n     charFrequency[char]=metaFrequency\n     \n   for char in charFrequency.keys():\n    items=list(charFrequency[char].items())\n    if len(items)==1 and items[0][0]==0:\n     continue\n     \n    if len(items)>1:\n     modes[char]=max(items,key=lambda x:x[1])\n     \n     \n     items.remove(modes[char])\n     modes[char]=(modes[char][0],modes[char][1]\n     -sum(item[1]for item in items))\n    else :\n     modes[char]=items[0]\n     \n     \n   modeList=modes.items()\n   total=float(min(chunkLength *iteration,len(data)))\n   \n   consistency=1.0\n   \n   threshold=0.9\n   while len(delims)==0 and consistency >=threshold:\n    for k,v in modeList:\n     if v[0]>0 and v[1]>0:\n      if ((v[1]/total)>=consistency and\n      (delimiters is None or k in delimiters)):\n       delims[k]=v\n    consistency -=0.01\n    \n   if len(delims)==1:\n    delim=list(delims.keys())[0]\n    skipinitialspace=(data[0].count(delim)==\n    data[0].count(\"%c \"%delim))\n    return (delim,skipinitialspace)\n    \n    \n   start=end\n   end +=chunkLength\n   \n  if not delims:\n   return ('',0)\n   \n   \n  if len(delims)>1:\n   for d in self.preferred:\n    if d in delims.keys():\n     skipinitialspace=(data[0].count(d)==\n     data[0].count(\"%c \"%d))\n     return (d,skipinitialspace)\n     \n     \n     \n  items=[(v,k)for (k,v)in delims.items()]\n  items.sort()\n  delim=items[-1][1]\n  \n  skipinitialspace=(data[0].count(delim)==\n  data[0].count(\"%c \"%delim))\n  return (delim,skipinitialspace)\n  \n  \n def has_header(self,sample):\n \n \n \n \n \n \n \n \n \n  rdr=reader(StringIO(sample),self.sniff(sample))\n  \n  header=next(rdr)\n  \n  columns=len(header)\n  columnTypes={}\n  for i in range(columns):columnTypes[i]=None\n  \n  checked=0\n  for row in rdr:\n  \n   if checked >20:\n    break\n   checked +=1\n   \n   if len(row)!=columns:\n    continue\n    \n   for col in list(columnTypes.keys()):\n   \n    for thisType in [int,float,complex]:\n     try :\n      thisType(row[col])\n      break\n     except (ValueError,OverflowError):\n      pass\n    else :\n    \n     thisType=len(row[col])\n     \n    if thisType !=columnTypes[col]:\n     if columnTypes[col]is None :\n      columnTypes[col]=thisType\n     else :\n     \n     \n      del columnTypes[col]\n      \n      \n      \n  hasHeader=0\n  for col,colType in columnTypes.items():\n   if type(colType)==type(0):\n    if len(header[col])!=colType:\n     hasHeader +=1\n    else :\n     hasHeader -=1\n   else :\n    try :\n     colType(header[col])\n    except (ValueError,TypeError):\n     hasHeader +=1\n    else :\n     hasHeader -=1\n     \n  return hasHeader >0\n", ["_csv", "io", "re"]],
-    "dataclasses": [".py", "import re\nimport sys\nimport copy\nimport types\nimport inspect\nimport keyword\nimport builtins\nimport functools\nimport _thread\nfrom types import GenericAlias\n\n\n__all__=['dataclass',\n'field',\n'Field',\n'FrozenInstanceError',\n'InitVar',\n'MISSING',\n\n\n'fields',\n'asdict',\n'astuple',\n'make_dataclass',\n'replace',\n'is_dataclass',\n]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nclass FrozenInstanceError(AttributeError):pass\n\n\n\n\nclass _HAS_DEFAULT_FACTORY_CLASS:\n def __repr__(self):\n  return '<factory>'\n_HAS_DEFAULT_FACTORY=_HAS_DEFAULT_FACTORY_CLASS()\n\n\n\nclass _MISSING_TYPE:\n pass\nMISSING=_MISSING_TYPE()\n\n\n\n_EMPTY_METADATA=types.MappingProxyType({})\n\n\nclass _FIELD_BASE:\n def __init__(self,name):\n  self.name=name\n def __repr__(self):\n  return self.name\n_FIELD=_FIELD_BASE('_FIELD')\n_FIELD_CLASSVAR=_FIELD_BASE('_FIELD_CLASSVAR')\n_FIELD_INITVAR=_FIELD_BASE('_FIELD_INITVAR')\n\n\n\n_FIELDS='__dataclass_fields__'\n\n\n\n_PARAMS='__dataclass_params__'\n\n\n\n_POST_INIT_NAME='__post_init__'\n\n\n\n\n_MODULE_IDENTIFIER_RE=re.compile(r'^(?:\\s*(\\w+)\\s*\\.)?\\s*(\\w+)')\n\nclass InitVar:\n __slots__=('type',)\n \n def __init__(self,type):\n  self.type=type\n  \n def __repr__(self):\n  if isinstance(self.type,type):\n   type_name=self.type.__name__\n  else :\n  \n   type_name=repr(self.type)\n  return f'dataclasses.InitVar[{type_name}]'\n  \n def __class_getitem__(cls,type):\n  return InitVar(type)\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \nclass Field:\n __slots__=('name',\n 'type',\n 'default',\n 'default_factory',\n 'repr',\n 'hash',\n 'init',\n 'compare',\n 'metadata',\n '_field_type',\n )\n \n def __init__(self,default,default_factory,init,repr,hash,compare,\n metadata):\n  self.name=None\n  self.type=None\n  self.default=default\n  self.default_factory=default_factory\n  self.init=init\n  self.repr=repr\n  self.hash=hash\n  self.compare=compare\n  self.metadata=(_EMPTY_METADATA\n  if metadata is None else\n  types.MappingProxyType(metadata))\n  self._field_type=None\n  \n def __repr__(self):\n  return ('Field('\n  f'name={self.name!r},'\n  f'type={self.type!r},'\n  f'default={self.default!r},'\n  f'default_factory={self.default_factory!r},'\n  f'init={self.init!r},'\n  f'repr={self.repr!r},'\n  f'hash={self.hash!r},'\n  f'compare={self.compare!r},'\n  f'metadata={self.metadata!r},'\n  f'_field_type={self._field_type}'\n  ')')\n  \n  \n  \n  \n  \n  \n  \n  \n  \n def __set_name__(self,owner,name):\n  func=getattr(type(self.default),'__set_name__',None )\n  if func:\n  \n  \n   func(self.default,owner,name)\n   \n __class_getitem__=classmethod(GenericAlias)\n \n \nclass _DataclassParams:\n __slots__=('init',\n 'repr',\n 'eq',\n 'order',\n 'unsafe_hash',\n 'frozen',\n )\n \n def __init__(self,init,repr,eq,order,unsafe_hash,frozen):\n  self.init=init\n  self.repr=repr\n  self.eq=eq\n  self.order=order\n  self.unsafe_hash=unsafe_hash\n  self.frozen=frozen\n  \n def __repr__(self):\n  return ('_DataclassParams('\n  f'init={self.init!r},'\n  f'repr={self.repr!r},'\n  f'eq={self.eq!r},'\n  f'order={self.order!r},'\n  f'unsafe_hash={self.unsafe_hash!r},'\n  f'frozen={self.frozen!r}'\n  ')')\n  \n  \n  \n  \n  \ndef field(*,default=MISSING,default_factory=MISSING,init=True ,repr=True ,\nhash=None ,compare=True ,metadata=None ):\n ''\n\n\n\n\n\n\n\n\n\n\n\n \n \n if default is not MISSING and default_factory is not MISSING:\n  raise ValueError('cannot specify both default and default_factory')\n return Field(default,default_factory,init,repr,hash,compare,\n metadata)\n \n \ndef _tuple_str(obj_name,fields):\n\n\n\n\n\n if not fields:\n  return '()'\n  \n return f'({\",\".join([f\"{obj_name}.{f.name}\" for f in fields])},)'\n \n \n \n \ndef _recursive_repr(user_function):\n\n\n repr_running=set()\n \n @functools.wraps(user_function)\n def wrapper(self):\n  key=id(self),_thread.get_ident()\n  if key in repr_running:\n   return '...'\n  repr_running.add(key)\n  try :\n   result=user_function(self)\n  finally :\n   repr_running.discard(key)\n  return result\n return wrapper\n \n \ndef _create_fn(name,args,body,*,globals=None ,locals=None ,\nreturn_type=MISSING):\n\n\n\n if locals is None :\n  locals={}\n if 'BUILTINS'not in locals:\n  locals['BUILTINS']=builtins\n return_annotation=''\n if return_type is not MISSING:\n  locals['_return_type']=return_type\n  return_annotation='->_return_type'\n args=','.join(args)\n body='\\n'.join(f'  {b}'for b in body)\n \n \n txt=f' def {name}({args}){return_annotation}:\\n{body}'\n \n local_vars=', '.join(locals.keys())\n txt=f\"def __create_fn__({local_vars}):\\n{txt}\\n return {name}\"\n \n ns={}\n exec(txt,globals,ns)\n return ns['__create_fn__'](**locals)\n \n \ndef _field_assign(frozen,name,value,self_name):\n\n\n\n\n\n\n if frozen:\n  return f'BUILTINS.object.__setattr__({self_name},{name!r},{value})'\n return f'{self_name}.{name}={value}'\n \n \ndef _field_init(f,frozen,globals,self_name):\n\n\n\n default_name=f'_dflt_{f.name}'\n if f.default_factory is not MISSING:\n  if f.init:\n  \n  \n   globals[default_name]=f.default_factory\n   value=(f'{default_name}() '\n   f'if {f.name} is _HAS_DEFAULT_FACTORY '\n   f'else {f.name}')\n  else :\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n   globals[default_name]=f.default_factory\n   value=f'{default_name}()'\n else :\n \n  if f.init:\n   if f.default is MISSING:\n   \n    value=f.name\n   elif f.default is not MISSING:\n    globals[default_name]=f.default\n    value=f.name\n  else :\n  \n  \n   return None\n   \n   \n   \n   \n if f._field_type is _FIELD_INITVAR:\n  return None\n  \n  \n return _field_assign(frozen,f.name,value,self_name)\n \n \ndef _init_param(f):\n\n\n\n\n if f.default is MISSING and f.default_factory is MISSING:\n \n \n  default=''\n elif f.default is not MISSING:\n \n \n  default=f'=_dflt_{f.name}'\n elif f.default_factory is not MISSING:\n \n  default='=_HAS_DEFAULT_FACTORY'\n return f'{f.name}:_type_{f.name}{default}'\n \n \ndef _init_fn(fields,frozen,has_post_init,self_name,globals):\n\n\n\n\n\n\n\n seen_default=False\n for f in fields:\n \n  if f.init:\n   if not (f.default is MISSING and f.default_factory is MISSING):\n    seen_default=True\n   elif seen_default:\n    raise TypeError(f'non-default argument {f.name!r} '\n    'follows default argument')\n    \n locals={f'_type_{f.name}':f.type for f in fields}\n locals.update({\n 'MISSING':MISSING,\n '_HAS_DEFAULT_FACTORY':_HAS_DEFAULT_FACTORY,\n })\n \n body_lines=[]\n for f in fields:\n  line=_field_init(f,frozen,locals,self_name)\n  \n  \n  if line:\n   body_lines.append(line)\n   \n   \n if has_post_init:\n  params_str=','.join(f.name for f in fields\n  if f._field_type is _FIELD_INITVAR)\n  body_lines.append(f'{self_name}.{_POST_INIT_NAME}({params_str})')\n  \n  \n if not body_lines:\n  body_lines=['pass']\n  \n return _create_fn('__init__',\n [self_name]+[_init_param(f)for f in fields if f.init],\n body_lines,\n locals=locals,\n globals=globals,\n return_type=None )\n \n \ndef _repr_fn(fields,globals):\n fn=_create_fn('__repr__',\n ('self',),\n ['return self.__class__.__qualname__ + f\"('+\n ', '.join([f\"{f.name}={{self.{f.name}!r}}\"\n for f in fields])+\n ')\"'],\n globals=globals)\n return _recursive_repr(fn)\n \n \ndef _frozen_get_del_attr(cls,fields,globals):\n locals={'cls':cls,\n 'FrozenInstanceError':FrozenInstanceError}\n if fields:\n  fields_str='('+','.join(repr(f.name)for f in fields)+',)'\n else :\n \n  fields_str='()'\n return (_create_fn('__setattr__',\n ('self','name','value'),\n (f'if type(self) is cls or name in {fields_str}:',\n ' raise FrozenInstanceError(f\"cannot assign to field {name!r}\")',\n f'super(cls, self).__setattr__(name, value)'),\n locals=locals,\n globals=globals),\n _create_fn('__delattr__',\n ('self','name'),\n (f'if type(self) is cls or name in {fields_str}:',\n ' raise FrozenInstanceError(f\"cannot delete field {name!r}\")',\n f'super(cls, self).__delattr__(name)'),\n locals=locals,\n globals=globals),\n )\n \n \ndef _cmp_fn(name,op,self_tuple,other_tuple,globals):\n\n\n\n\n\n return _create_fn(name,\n ('self','other'),\n ['if other.__class__ is self.__class__:',\n f' return {self_tuple}{op}{other_tuple}',\n 'return NotImplemented'],\n globals=globals)\n \n \ndef _hash_fn(fields,globals):\n self_tuple=_tuple_str('self',fields)\n return _create_fn('__hash__',\n ('self',),\n [f'return hash({self_tuple})'],\n globals=globals)\n \n \ndef _is_classvar(a_type,typing):\n\n\n return (a_type is typing.ClassVar\n or (type(a_type)is typing._GenericAlias\n and a_type.__origin__ is typing.ClassVar))\n \n \ndef _is_initvar(a_type,dataclasses):\n\n\n return (a_type is dataclasses.InitVar\n or type(a_type)is dataclasses.InitVar)\n \n \ndef _is_type(annotation,cls,a_module,a_type,is_type_predicate):\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n match=_MODULE_IDENTIFIER_RE.match(annotation)\n if match:\n  ns=None\n  module_name=match.group(1)\n  if not module_name:\n  \n  \n   ns=sys.modules.get(cls.__module__).__dict__\n  else :\n  \n   module=sys.modules.get(cls.__module__)\n   if module and module.__dict__.get(module_name)is a_module:\n    ns=sys.modules.get(a_type.__module__).__dict__\n  if ns and is_type_predicate(ns.get(match.group(2)),a_module):\n   return True\n return False\n \n \ndef _get_field(cls,a_name,a_type):\n\n\n\n\n\n\n default=getattr(cls,a_name,MISSING)\n if isinstance(default,Field):\n  f=default\n else :\n  if isinstance(default,types.MemberDescriptorType):\n  \n   default=MISSING\n  f=field(default=default)\n  \n  \n f.name=a_name\n f.type=a_type\n \n \n \n \n f._field_type=_FIELD\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n typing=sys.modules.get('typing')\n if typing:\n  if (_is_classvar(a_type,typing)\n  or (isinstance(f.type,str)\n  and _is_type(f.type,cls,typing,typing.ClassVar,\n  _is_classvar))):\n   f._field_type=_FIELD_CLASSVAR\n   \n   \n   \n if f._field_type is _FIELD:\n \n \n  dataclasses=sys.modules[__name__]\n  if (_is_initvar(a_type,dataclasses)\n  or (isinstance(f.type,str)\n  and _is_type(f.type,cls,dataclasses,dataclasses.InitVar,\n  _is_initvar))):\n   f._field_type=_FIELD_INITVAR\n   \n   \n   \n   \n   \n   \n if f._field_type in (_FIELD_CLASSVAR,_FIELD_INITVAR):\n  if f.default_factory is not MISSING:\n   raise TypeError(f'field {f.name} cannot have a '\n   'default factory')\n   \n   \n   \n   \n   \n   \n   \n if f._field_type is _FIELD and isinstance(f.default,(list,dict,set)):\n  raise ValueError(f'mutable default {type(f.default)} for field '\n  f'{f.name} is not allowed: use default_factory')\n  \n return f\n \n \ndef _set_new_attribute(cls,name,value):\n\n\n if name in cls.__dict__:\n  return True\n setattr(cls,name,value)\n return False\n \n \n \n \n \n \n \ndef _hash_set_none(cls,fields,globals):\n return None\n \ndef _hash_add(cls,fields,globals):\n flds=[f for f in fields if (f.compare if f.hash is None else f.hash)]\n return _hash_fn(flds,globals)\n \ndef _hash_exception(cls,fields,globals):\n\n raise TypeError(f'Cannot overwrite attribute __hash__ '\n f'in class {cls.__name__}')\n \n \n \n \n \n \n \n \n \n \n_hash_action={(False ,False ,False ,False ):None ,\n(False ,False ,False ,True ):None ,\n(False ,False ,True ,False ):None ,\n(False ,False ,True ,True ):None ,\n(False ,True ,False ,False ):_hash_set_none,\n(False ,True ,False ,True ):None ,\n(False ,True ,True ,False ):_hash_add,\n(False ,True ,True ,True ):None ,\n(True ,False ,False ,False ):_hash_add,\n(True ,False ,False ,True ):_hash_exception,\n(True ,False ,True ,False ):_hash_add,\n(True ,False ,True ,True ):_hash_exception,\n(True ,True ,False ,False ):_hash_add,\n(True ,True ,False ,True ):_hash_exception,\n(True ,True ,True ,False ):_hash_add,\n(True ,True ,True ,True ):_hash_exception,\n}\n\n\n\n\ndef _process_class(cls,init,repr,eq,order,unsafe_hash,frozen):\n\n\n\n\n fields={}\n \n if cls.__module__ in sys.modules:\n  globals=sys.modules[cls.__module__].__dict__\n else :\n \n \n \n \n \n  globals={}\n  \n setattr(cls,_PARAMS,_DataclassParams(init,repr,eq,order,\n unsafe_hash,frozen))\n \n \n \n \n \n any_frozen_base=False\n has_dataclass_bases=False\n for b in cls.__mro__[-1:0:-1]:\n \n \n  base_fields=getattr(b,_FIELDS,None )\n  if base_fields:\n   has_dataclass_bases=True\n   for f in base_fields.values():\n    fields[f.name]=f\n   if getattr(b,_PARAMS).frozen:\n    any_frozen_base=True\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n cls_annotations=cls.__dict__.get('__annotations__',{})\n \n \n \n \n cls_fields=[_get_field(cls,name,type)\n for name,type in cls_annotations.items()]\n for f in cls_fields:\n  fields[f.name]=f\n  \n  \n  \n  \n  \n  if isinstance(getattr(cls,f.name,None ),Field):\n   if f.default is MISSING:\n   \n   \n   \n   \n   \n   \n    delattr(cls,f.name)\n   else :\n    setattr(cls,f.name,f.default)\n    \n    \n for name,value in cls.__dict__.items():\n  if isinstance(value,Field)and not name in cls_annotations:\n   raise TypeError(f'{name!r} is a field but has no type annotation')\n   \n   \n if has_dataclass_bases:\n \n  if any_frozen_base and not frozen:\n   raise TypeError('cannot inherit non-frozen dataclass from a '\n   'frozen one')\n   \n   \n  if not any_frozen_base and frozen:\n   raise TypeError('cannot inherit frozen dataclass from a '\n   'non-frozen one')\n   \n   \n   \n setattr(cls,_FIELDS,fields)\n \n \n \n \n \n \n class_hash=cls.__dict__.get('__hash__',MISSING)\n has_explicit_hash=not (class_hash is MISSING or\n (class_hash is None and '__eq__'in cls.__dict__))\n \n \n \n if order and not eq:\n  raise ValueError('eq must be true if order is true')\n  \n if init:\n \n  has_post_init=hasattr(cls,_POST_INIT_NAME)\n  \n  \n  flds=[f for f in fields.values()\n  if f._field_type in (_FIELD,_FIELD_INITVAR)]\n  _set_new_attribute(cls,'__init__',\n  _init_fn(flds,\n  frozen,\n  has_post_init,\n  \n  \n  \n  '__dataclass_self__'if 'self'in fields\n  else 'self',\n  globals,\n  ))\n  \n  \n  \n field_list=[f for f in fields.values()if f._field_type is _FIELD]\n \n if repr:\n  flds=[f for f in field_list if f.repr]\n  _set_new_attribute(cls,'__repr__',_repr_fn(flds,globals))\n  \n if eq:\n \n \n  flds=[f for f in field_list if f.compare]\n  self_tuple=_tuple_str('self',flds)\n  other_tuple=_tuple_str('other',flds)\n  _set_new_attribute(cls,'__eq__',\n  _cmp_fn('__eq__','==',\n  self_tuple,other_tuple,\n  globals=globals))\n  \n if order:\n \n  flds=[f for f in field_list if f.compare]\n  self_tuple=_tuple_str('self',flds)\n  other_tuple=_tuple_str('other',flds)\n  for name,op in [('__lt__','<'),\n  ('__le__','<='),\n  ('__gt__','>'),\n  ('__ge__','>='),\n  ]:\n   if _set_new_attribute(cls,name,\n   _cmp_fn(name,op,self_tuple,other_tuple,\n   globals=globals)):\n    raise TypeError(f'Cannot overwrite attribute {name} '\n    f'in class {cls.__name__}. Consider using '\n    'functools.total_ordering')\n    \n if frozen:\n  for fn in _frozen_get_del_attr(cls,field_list,globals):\n   if _set_new_attribute(cls,fn.__name__,fn):\n    raise TypeError(f'Cannot overwrite attribute {fn.__name__} '\n    f'in class {cls.__name__}')\n    \n    \n hash_action=_hash_action[bool(unsafe_hash),\n bool(eq),\n bool(frozen),\n has_explicit_hash]\n if hash_action:\n \n \n  cls.__hash__=hash_action(cls,field_list,globals)\n  \n if not getattr(cls,'__doc__'):\n \n  cls.__doc__=(cls.__name__+\n  str(inspect.signature(cls)).replace(' -> None',''))\n  \n return cls\n \n \ndef dataclass(cls=None ,/,*,init=True ,repr=True ,eq=True ,order=False ,\nunsafe_hash=False ,frozen=False ):\n ''\n\n\n\n\n\n\n\n\n\n \n \n def wrap(cls):\n  return _process_class(cls,init,repr,eq,order,unsafe_hash,frozen)\n  \n  \n if cls is None :\n \n  return wrap\n  \n  \n return wrap(cls)\n \n \ndef fields(class_or_instance):\n ''\n\n\n\n \n \n \n try :\n  fields=getattr(class_or_instance,_FIELDS)\n except AttributeError:\n  raise TypeError('must be called with a dataclass type or instance')\n  \n  \n  \n return tuple(f for f in fields.values()if f._field_type is _FIELD)\n \n \ndef _is_dataclass_instance(obj):\n ''\n return hasattr(type(obj),_FIELDS)\n \n \ndef is_dataclass(obj):\n ''\n \n cls=obj if isinstance(obj,type)else type(obj)\n return hasattr(cls,_FIELDS)\n \n \ndef asdict(obj,*,dict_factory=dict):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n if not _is_dataclass_instance(obj):\n  raise TypeError(\"asdict() should be called on dataclass instances\")\n return _asdict_inner(obj,dict_factory)\n \n \ndef _asdict_inner(obj,dict_factory):\n if _is_dataclass_instance(obj):\n  result=[]\n  for f in fields(obj):\n   value=_asdict_inner(getattr(obj,f.name),dict_factory)\n   result.append((f.name,value))\n  return dict_factory(result)\n elif isinstance(obj,tuple)and hasattr(obj,'_fields'):\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n  return type(obj)(*[_asdict_inner(v,dict_factory)for v in obj])\n elif isinstance(obj,(list,tuple)):\n \n \n \n  return type(obj)(_asdict_inner(v,dict_factory)for v in obj)\n elif isinstance(obj,dict):\n  return type(obj)((_asdict_inner(k,dict_factory),\n  _asdict_inner(v,dict_factory))\n  for k,v in obj.items())\n else :\n  return copy.deepcopy(obj)\n  \n  \ndef astuple(obj,*,tuple_factory=tuple):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n if not _is_dataclass_instance(obj):\n  raise TypeError(\"astuple() should be called on dataclass instances\")\n return _astuple_inner(obj,tuple_factory)\n \n \ndef _astuple_inner(obj,tuple_factory):\n if _is_dataclass_instance(obj):\n  result=[]\n  for f in fields(obj):\n   value=_astuple_inner(getattr(obj,f.name),tuple_factory)\n   result.append(value)\n  return tuple_factory(result)\n elif isinstance(obj,tuple)and hasattr(obj,'_fields'):\n \n \n \n \n \n \n  return type(obj)(*[_astuple_inner(v,tuple_factory)for v in obj])\n elif isinstance(obj,(list,tuple)):\n \n \n \n  return type(obj)(_astuple_inner(v,tuple_factory)for v in obj)\n elif isinstance(obj,dict):\n  return type(obj)((_astuple_inner(k,tuple_factory),_astuple_inner(v,tuple_factory))\n  for k,v in obj.items())\n else :\n  return copy.deepcopy(obj)\n  \n  \ndef make_dataclass(cls_name,fields,*,bases=(),namespace=None ,init=True ,\nrepr=True ,eq=True ,order=False ,unsafe_hash=False ,\nfrozen=False ):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n if namespace is None :\n  namespace={}\n else :\n \n  namespace=namespace.copy()\n  \n  \n  \n seen=set()\n anns={}\n for item in fields:\n  if isinstance(item,str):\n   name=item\n   tp='typing.Any'\n  elif len(item)==2:\n   name,tp,=item\n  elif len(item)==3:\n   name,tp,spec=item\n   namespace[name]=spec\n  else :\n   raise TypeError(f'Invalid field: {item!r}')\n   \n  if not isinstance(name,str)or not name.isidentifier():\n   raise TypeError(f'Field names must be valid identifiers: {name!r}')\n  if keyword.iskeyword(name):\n   raise TypeError(f'Field names must not be keywords: {name!r}')\n  if name in seen:\n   raise TypeError(f'Field name duplicated: {name!r}')\n   \n  seen.add(name)\n  anns[name]=tp\n  \n namespace['__annotations__']=anns\n \n \n cls=types.new_class(cls_name,bases,{},lambda ns:ns.update(namespace))\n return dataclass(cls,init=init,repr=repr,eq=eq,order=order,\n unsafe_hash=unsafe_hash,frozen=frozen)\n \n \ndef replace(obj,/,**changes):\n ''\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n if not _is_dataclass_instance(obj):\n  raise TypeError(\"replace() should be called on dataclass instances\")\n  \n  \n  \n  \n for f in getattr(obj,_FIELDS).values():\n \n  if f._field_type is _FIELD_CLASSVAR:\n   continue\n   \n  if not f.init:\n  \n   if f.name in changes:\n    raise ValueError(f'field {f.name} is declared with '\n    'init=False, it cannot be specified with '\n    'replace()')\n   continue\n   \n  if f.name not in changes:\n   if f._field_type is _FIELD_INITVAR:\n    raise ValueError(f\"InitVar {f.name!r} \"\n    'must be specified with replace()')\n   changes[f.name]=getattr(obj,f.name)\n   \n   \n   \n   \n   \n   \n return obj.__class__(**changes)\n", ["_thread", "builtins", "copy", "functools", "inspect", "keyword", "re", "sys", "types"]],
+    "dataclasses": [".py", "import re\nimport sys\nimport copy\nimport types\nimport inspect\nimport keyword\nimport builtins\nimport functools\nimport abc\nimport _thread\nfrom types import FunctionType,GenericAlias\n\n\n__all__=['dataclass',\n'field',\n'Field',\n'FrozenInstanceError',\n'InitVar',\n'MISSING',\n\n\n'fields',\n'asdict',\n'astuple',\n'make_dataclass',\n'replace',\n'is_dataclass',\n]\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nclass FrozenInstanceError(AttributeError):pass\n\n\n\n\nclass _HAS_DEFAULT_FACTORY_CLASS:\n def __repr__(self):\n  return '<factory>'\n_HAS_DEFAULT_FACTORY=_HAS_DEFAULT_FACTORY_CLASS()\n\n\n\nclass _MISSING_TYPE:\n pass\nMISSING=_MISSING_TYPE()\n\n\n\n_EMPTY_METADATA=types.MappingProxyType({})\n\n\nclass _FIELD_BASE:\n def __init__(self,name):\n  self.name=name\n def __repr__(self):\n  return self.name\n_FIELD=_FIELD_BASE('_FIELD')\n_FIELD_CLASSVAR=_FIELD_BASE('_FIELD_CLASSVAR')\n_FIELD_INITVAR=_FIELD_BASE('_FIELD_INITVAR')\n\n\n\n_FIELDS='__dataclass_fields__'\n\n\n\n_PARAMS='__dataclass_params__'\n\n\n\n_POST_INIT_NAME='__post_init__'\n\n\n\n\n_MODULE_IDENTIFIER_RE=re.compile(r'^(?:\\s*(\\w+)\\s*\\.)?\\s*(\\w+)')\n\nclass InitVar:\n __slots__=('type',)\n \n def __init__(self,type):\n  self.type=type\n  \n def __repr__(self):\n  if isinstance(self.type,type):\n   type_name=self.type.__name__\n  else :\n  \n   type_name=repr(self.type)\n  return f'dataclasses.InitVar[{type_name}]'\n  \n def __class_getitem__(cls,type):\n  return InitVar(type)\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \nclass Field:\n __slots__=('name',\n 'type',\n 'default',\n 'default_factory',\n 'repr',\n 'hash',\n 'init',\n 'compare',\n 'metadata',\n '_field_type',\n )\n \n def __init__(self,default,default_factory,init,repr,hash,compare,\n metadata):\n  self.name=None\n  self.type=None\n  self.default=default\n  self.default_factory=default_factory\n  self.init=init\n  self.repr=repr\n  self.hash=hash\n  self.compare=compare\n  self.metadata=(_EMPTY_METADATA\n  if metadata is None else\n  types.MappingProxyType(metadata))\n  self._field_type=None\n  \n def __repr__(self):\n  return ('Field('\n  f'name={self.name!r},'\n  f'type={self.type!r},'\n  f'default={self.default!r},'\n  f'default_factory={self.default_factory!r},'\n  f'init={self.init!r},'\n  f'repr={self.repr!r},'\n  f'hash={self.hash!r},'\n  f'compare={self.compare!r},'\n  f'metadata={self.metadata!r},'\n  f'_field_type={self._field_type}'\n  ')')\n  \n  \n  \n  \n  \n  \n  \n  \n  \n def __set_name__(self,owner,name):\n  func=getattr(type(self.default),'__set_name__',None )\n  if func:\n  \n  \n   func(self.default,owner,name)\n   \n __class_getitem__=classmethod(GenericAlias)\n \n \nclass _DataclassParams:\n __slots__=('init',\n 'repr',\n 'eq',\n 'order',\n 'unsafe_hash',\n 'frozen',\n )\n \n def __init__(self,init,repr,eq,order,unsafe_hash,frozen):\n  self.init=init\n  self.repr=repr\n  self.eq=eq\n  self.order=order\n  self.unsafe_hash=unsafe_hash\n  self.frozen=frozen\n  \n def __repr__(self):\n  return ('_DataclassParams('\n  f'init={self.init!r},'\n  f'repr={self.repr!r},'\n  f'eq={self.eq!r},'\n  f'order={self.order!r},'\n  f'unsafe_hash={self.unsafe_hash!r},'\n  f'frozen={self.frozen!r}'\n  ')')\n  \n  \n  \n  \n  \ndef field(*,default=MISSING,default_factory=MISSING,init=True ,repr=True ,\nhash=None ,compare=True ,metadata=None ):\n ''\n\n\n\n\n\n\n\n\n\n\n\n \n \n if default is not MISSING and default_factory is not MISSING:\n  raise ValueError('cannot specify both default and default_factory')\n return Field(default,default_factory,init,repr,hash,compare,\n metadata)\n \n \ndef _tuple_str(obj_name,fields):\n\n\n\n\n\n if not fields:\n  return '()'\n  \n return f'({\",\".join([f\"{obj_name}.{f.name}\" for f in fields])},)'\n \n \n \n \ndef _recursive_repr(user_function):\n\n\n repr_running=set()\n \n @functools.wraps(user_function)\n def wrapper(self):\n  key=id(self),_thread.get_ident()\n  if key in repr_running:\n   return '...'\n  repr_running.add(key)\n  try :\n   result=user_function(self)\n  finally :\n   repr_running.discard(key)\n  return result\n return wrapper\n \n \ndef _create_fn(name,args,body,*,globals=None ,locals=None ,\nreturn_type=MISSING):\n\n\n\n if locals is None :\n  locals={}\n if 'BUILTINS'not in locals:\n  locals['BUILTINS']=builtins\n return_annotation=''\n if return_type is not MISSING:\n  locals['_return_type']=return_type\n  return_annotation='->_return_type'\n args=','.join(args)\n body='\\n'.join(f'  {b}'for b in body)\n \n \n txt=f' def {name}({args}){return_annotation}:\\n{body}'\n \n local_vars=', '.join(locals.keys())\n txt=f\"def __create_fn__({local_vars}):\\n{txt}\\n return {name}\"\n \n ns={}\n exec(txt,globals,ns)\n func=ns['__create_fn__'](**locals)\n for arg,annotation in func.__annotations__.copy().items():\n  func.__annotations__[arg]=locals[annotation]\n return func\n \ndef _field_assign(frozen,name,value,self_name):\n\n\n\n\n\n\n if frozen:\n  return f'BUILTINS.object.__setattr__({self_name},{name!r},{value})'\n return f'{self_name}.{name}={value}'\n \n \ndef _field_init(f,frozen,globals,self_name):\n\n\n\n default_name=f'_dflt_{f.name}'\n if f.default_factory is not MISSING:\n  if f.init:\n  \n  \n   globals[default_name]=f.default_factory\n   value=(f'{default_name}() '\n   f'if {f.name} is _HAS_DEFAULT_FACTORY '\n   f'else {f.name}')\n  else :\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n   globals[default_name]=f.default_factory\n   value=f'{default_name}()'\n else :\n \n  if f.init:\n   if f.default is MISSING:\n   \n    value=f.name\n   elif f.default is not MISSING:\n    globals[default_name]=f.default\n    value=f.name\n  else :\n  \n  \n   return None\n   \n   \n   \n   \n if f._field_type is _FIELD_INITVAR:\n  return None\n  \n  \n return _field_assign(frozen,f.name,value,self_name)\n \n \ndef _init_param(f):\n\n\n\n\n if f.default is MISSING and f.default_factory is MISSING:\n \n \n  default=''\n elif f.default is not MISSING:\n \n \n  default=f'=_dflt_{f.name}'\n elif f.default_factory is not MISSING:\n \n  default='=_HAS_DEFAULT_FACTORY'\n return f'{f.name}:_type_{f.name}{default}'\n \n \ndef _init_fn(fields,frozen,has_post_init,self_name,globals):\n\n\n\n\n\n\n\n seen_default=False\n for f in fields:\n \n  if f.init:\n   if not (f.default is MISSING and f.default_factory is MISSING):\n    seen_default=True\n   elif seen_default:\n    raise TypeError(f'non-default argument {f.name!r} '\n    'follows default argument')\n    \n locals={f'_type_{f.name}':f.type for f in fields}\n locals.update({\n 'MISSING':MISSING,\n '_HAS_DEFAULT_FACTORY':_HAS_DEFAULT_FACTORY,\n })\n \n body_lines=[]\n for f in fields:\n  line=_field_init(f,frozen,locals,self_name)\n  \n  \n  if line:\n   body_lines.append(line)\n   \n   \n if has_post_init:\n  params_str=','.join(f.name for f in fields\n  if f._field_type is _FIELD_INITVAR)\n  body_lines.append(f'{self_name}.{_POST_INIT_NAME}({params_str})')\n  \n  \n if not body_lines:\n  body_lines=['pass']\n  \n return _create_fn('__init__',\n [self_name]+[_init_param(f)for f in fields if f.init],\n body_lines,\n locals=locals,\n globals=globals,\n return_type=None )\n \n \ndef _repr_fn(fields,globals):\n fn=_create_fn('__repr__',\n ('self',),\n ['return self.__class__.__qualname__ + f\"('+\n ', '.join([f\"{f.name}={{self.{f.name}!r}}\"\n for f in fields])+\n ')\"'],\n globals=globals)\n return _recursive_repr(fn)\n \n \ndef _frozen_get_del_attr(cls,fields,globals):\n locals={'cls':cls,\n 'FrozenInstanceError':FrozenInstanceError}\n if fields:\n  fields_str='('+','.join(repr(f.name)for f in fields)+',)'\n else :\n \n  fields_str='()'\n return (_create_fn('__setattr__',\n ('self','name','value'),\n (f'if type(self) is cls or name in {fields_str}:',\n ' raise FrozenInstanceError(f\"cannot assign to field {name!r}\")',\n f'super(cls, self).__setattr__(name, value)'),\n locals=locals,\n globals=globals),\n _create_fn('__delattr__',\n ('self','name'),\n (f'if type(self) is cls or name in {fields_str}:',\n ' raise FrozenInstanceError(f\"cannot delete field {name!r}\")',\n f'super(cls, self).__delattr__(name)'),\n locals=locals,\n globals=globals),\n )\n \n \ndef _cmp_fn(name,op,self_tuple,other_tuple,globals):\n\n\n\n\n\n return _create_fn(name,\n ('self','other'),\n ['if other.__class__ is self.__class__:',\n f' return {self_tuple}{op}{other_tuple}',\n 'return NotImplemented'],\n globals=globals)\n \n \ndef _hash_fn(fields,globals):\n self_tuple=_tuple_str('self',fields)\n return _create_fn('__hash__',\n ('self',),\n [f'return hash({self_tuple})'],\n globals=globals)\n \n \ndef _is_classvar(a_type,typing):\n\n\n return (a_type is typing.ClassVar\n or (type(a_type)is typing._GenericAlias\n and a_type.__origin__ is typing.ClassVar))\n \n \ndef _is_initvar(a_type,dataclasses):\n\n\n return (a_type is dataclasses.InitVar\n or type(a_type)is dataclasses.InitVar)\n \n \ndef _is_type(annotation,cls,a_module,a_type,is_type_predicate):\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n if annotation.startswith((\"'\",'\"'))and annotation.endswith((\"'\",'\"')):\n  annotation=annotation[1:-1]\n  \n match=_MODULE_IDENTIFIER_RE.match(annotation)\n if match:\n  ns=None\n  module_name=match.group(1)\n  if not module_name:\n  \n  \n   ns=sys.modules.get(cls.__module__).__dict__\n  else :\n  \n   module=sys.modules.get(cls.__module__)\n   if module and module.__dict__.get(module_name)is a_module:\n    ns=sys.modules.get(a_type.__module__).__dict__\n  if ns and is_type_predicate(ns.get(match.group(2)),a_module):\n   return True\n return False\n \n \ndef _get_field(cls,a_name,a_type):\n\n\n\n\n\n\n default=getattr(cls,a_name,MISSING)\n if isinstance(default,Field):\n  f=default\n else :\n  if isinstance(default,types.MemberDescriptorType):\n  \n   default=MISSING\n  f=field(default=default)\n  \n  \n f.name=a_name\n f.type=a_type\n \n \n \n \n f._field_type=_FIELD\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n typing=sys.modules.get('typing')\n if typing:\n  if (_is_classvar(a_type,typing)\n  or (isinstance(f.type,str)\n  and _is_type(f.type,cls,typing,typing.ClassVar,\n  _is_classvar))):\n   f._field_type=_FIELD_CLASSVAR\n   \n   \n   \n if f._field_type is _FIELD:\n \n \n  dataclasses=sys.modules[__name__]\n  if (_is_initvar(a_type,dataclasses)\n  or (isinstance(f.type,str)\n  and _is_type(f.type,cls,dataclasses,dataclasses.InitVar,\n  _is_initvar))):\n   f._field_type=_FIELD_INITVAR\n   \n   \n   \n   \n   \n   \n if f._field_type in (_FIELD_CLASSVAR,_FIELD_INITVAR):\n  if f.default_factory is not MISSING:\n   raise TypeError(f'field {f.name} cannot have a '\n   'default factory')\n   \n   \n   \n   \n   \n   \n   \n if f._field_type is _FIELD and isinstance(f.default,(list,dict,set)):\n  raise ValueError(f'mutable default {type(f.default)} for field '\n  f'{f.name} is not allowed: use default_factory')\n  \n return f\n \ndef _set_qualname(cls,value):\n\n\n if isinstance(value,FunctionType):\n  value.__qualname__=f\"{cls.__qualname__}.{value.__name__}\"\n return value\n \ndef _set_new_attribute(cls,name,value):\n\n\n if name in cls.__dict__:\n  return True\n _set_qualname(cls,value)\n setattr(cls,name,value)\n return False\n \n \n \n \n \n \n \ndef _hash_set_none(cls,fields,globals):\n return None\n \ndef _hash_add(cls,fields,globals):\n flds=[f for f in fields if (f.compare if f.hash is None else f.hash)]\n return _set_qualname(cls,_hash_fn(flds,globals))\n \ndef _hash_exception(cls,fields,globals):\n\n raise TypeError(f'Cannot overwrite attribute __hash__ '\n f'in class {cls.__name__}')\n \n \n \n \n \n \n \n \n \n \n_hash_action={(False ,False ,False ,False ):None ,\n(False ,False ,False ,True ):None ,\n(False ,False ,True ,False ):None ,\n(False ,False ,True ,True ):None ,\n(False ,True ,False ,False ):_hash_set_none,\n(False ,True ,False ,True ):None ,\n(False ,True ,True ,False ):_hash_add,\n(False ,True ,True ,True ):None ,\n(True ,False ,False ,False ):_hash_add,\n(True ,False ,False ,True ):_hash_exception,\n(True ,False ,True ,False ):_hash_add,\n(True ,False ,True ,True ):_hash_exception,\n(True ,True ,False ,False ):_hash_add,\n(True ,True ,False ,True ):_hash_exception,\n(True ,True ,True ,False ):_hash_add,\n(True ,True ,True ,True ):_hash_exception,\n}\n\n\n\n\ndef _process_class(cls,init,repr,eq,order,unsafe_hash,frozen):\n\n\n\n\n fields={}\n \n if cls.__module__ in sys.modules:\n  globals=sys.modules[cls.__module__].__dict__\n else :\n \n \n \n \n \n  globals={}\n  \n setattr(cls,_PARAMS,_DataclassParams(init,repr,eq,order,\n unsafe_hash,frozen))\n \n \n \n \n \n any_frozen_base=False\n has_dataclass_bases=False\n for b in cls.__mro__[-1:0:-1]:\n \n \n  base_fields=getattr(b,_FIELDS,None )\n  if base_fields:\n   has_dataclass_bases=True\n   for f in base_fields.values():\n    fields[f.name]=f\n   if getattr(b,_PARAMS).frozen:\n    any_frozen_base=True\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n cls_annotations=cls.__dict__.get('__annotations__',{})\n \n \n \n \n cls_fields=[_get_field(cls,name,type)\n for name,type in cls_annotations.items()]\n for f in cls_fields:\n  fields[f.name]=f\n  \n  \n  \n  \n  \n  if isinstance(getattr(cls,f.name,None ),Field):\n   if f.default is MISSING:\n   \n   \n   \n   \n   \n   \n    delattr(cls,f.name)\n   else :\n    setattr(cls,f.name,f.default)\n    \n    \n for name,value in cls.__dict__.items():\n  if isinstance(value,Field)and not name in cls_annotations:\n   raise TypeError(f'{name!r} is a field but has no type annotation')\n   \n   \n if has_dataclass_bases:\n \n  if any_frozen_base and not frozen:\n   raise TypeError('cannot inherit non-frozen dataclass from a '\n   'frozen one')\n   \n   \n  if not any_frozen_base and frozen:\n   raise TypeError('cannot inherit frozen dataclass from a '\n   'non-frozen one')\n   \n   \n   \n setattr(cls,_FIELDS,fields)\n \n \n \n \n \n \n class_hash=cls.__dict__.get('__hash__',MISSING)\n has_explicit_hash=not (class_hash is MISSING or\n (class_hash is None and '__eq__'in cls.__dict__))\n \n \n \n if order and not eq:\n  raise ValueError('eq must be true if order is true')\n  \n if init:\n \n  has_post_init=hasattr(cls,_POST_INIT_NAME)\n  \n  \n  flds=[f for f in fields.values()\n  if f._field_type in (_FIELD,_FIELD_INITVAR)]\n  _set_new_attribute(cls,'__init__',\n  _init_fn(flds,\n  frozen,\n  has_post_init,\n  \n  \n  \n  '__dataclass_self__'if 'self'in fields\n  else 'self',\n  globals,\n  ))\n  \n  \n  \n field_list=[f for f in fields.values()if f._field_type is _FIELD]\n \n if repr:\n  flds=[f for f in field_list if f.repr]\n  _set_new_attribute(cls,'__repr__',_repr_fn(flds,globals))\n  \n if eq:\n \n \n  flds=[f for f in field_list if f.compare]\n  self_tuple=_tuple_str('self',flds)\n  other_tuple=_tuple_str('other',flds)\n  _set_new_attribute(cls,'__eq__',\n  _cmp_fn('__eq__','==',\n  self_tuple,other_tuple,\n  globals=globals))\n  \n if order:\n \n  flds=[f for f in field_list if f.compare]\n  self_tuple=_tuple_str('self',flds)\n  other_tuple=_tuple_str('other',flds)\n  for name,op in [('__lt__','<'),\n  ('__le__','<='),\n  ('__gt__','>'),\n  ('__ge__','>='),\n  ]:\n   if _set_new_attribute(cls,name,\n   _cmp_fn(name,op,self_tuple,other_tuple,\n   globals=globals)):\n    raise TypeError(f'Cannot overwrite attribute {name} '\n    f'in class {cls.__name__}. Consider using '\n    'functools.total_ordering')\n    \n if frozen:\n  for fn in _frozen_get_del_attr(cls,field_list,globals):\n   if _set_new_attribute(cls,fn.__name__,fn):\n    raise TypeError(f'Cannot overwrite attribute {fn.__name__} '\n    f'in class {cls.__name__}')\n    \n    \n hash_action=_hash_action[bool(unsafe_hash),\n bool(eq),\n bool(frozen),\n has_explicit_hash]\n if hash_action:\n \n \n  cls.__hash__=hash_action(cls,field_list,globals)\n  \n if not getattr(cls,'__doc__'):\n \n  cls.__doc__=(cls.__name__+\n  str(inspect.signature(cls)).replace(' -> NoneType',''))\n  \n if '__match_args__'not in cls.__dict__:\n  cls.__match_args__=tuple(f.name for f in flds if f.init)\n  \n abc.update_abstractmethods(cls)\n \n return cls\n \n \ndef dataclass(cls=None ,/,*,init=True ,repr=True ,eq=True ,order=False ,\nunsafe_hash=False ,frozen=False ):\n ''\n\n\n\n\n\n\n\n\n\n \n \n def wrap(cls):\n  return _process_class(cls,init,repr,eq,order,unsafe_hash,frozen)\n  \n  \n if cls is None :\n \n  return wrap\n  \n  \n return wrap(cls)\n \n \ndef fields(class_or_instance):\n ''\n\n\n\n \n \n \n try :\n  fields=getattr(class_or_instance,_FIELDS)\n except AttributeError:\n  raise TypeError('must be called with a dataclass type or instance')\n  \n  \n  \n return tuple(f for f in fields.values()if f._field_type is _FIELD)\n \n \ndef _is_dataclass_instance(obj):\n ''\n return hasattr(type(obj),_FIELDS)\n \n \ndef is_dataclass(obj):\n ''\n \n cls=obj if isinstance(obj,type)else type(obj)\n return hasattr(cls,_FIELDS)\n \n \ndef asdict(obj,*,dict_factory=dict):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n if not _is_dataclass_instance(obj):\n  raise TypeError(\"asdict() should be called on dataclass instances\")\n return _asdict_inner(obj,dict_factory)\n \n \ndef _asdict_inner(obj,dict_factory):\n if _is_dataclass_instance(obj):\n  result=[]\n  for f in fields(obj):\n   value=_asdict_inner(getattr(obj,f.name),dict_factory)\n   result.append((f.name,value))\n  return dict_factory(result)\n elif isinstance(obj,tuple)and hasattr(obj,'_fields'):\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n  return type(obj)(*[_asdict_inner(v,dict_factory)for v in obj])\n elif isinstance(obj,(list,tuple)):\n \n \n \n  return type(obj)(_asdict_inner(v,dict_factory)for v in obj)\n elif isinstance(obj,dict):\n  return type(obj)((_asdict_inner(k,dict_factory),\n  _asdict_inner(v,dict_factory))\n  for k,v in obj.items())\n else :\n  return copy.deepcopy(obj)\n  \n  \ndef astuple(obj,*,tuple_factory=tuple):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n if not _is_dataclass_instance(obj):\n  raise TypeError(\"astuple() should be called on dataclass instances\")\n return _astuple_inner(obj,tuple_factory)\n \n \ndef _astuple_inner(obj,tuple_factory):\n if _is_dataclass_instance(obj):\n  result=[]\n  for f in fields(obj):\n   value=_astuple_inner(getattr(obj,f.name),tuple_factory)\n   result.append(value)\n  return tuple_factory(result)\n elif isinstance(obj,tuple)and hasattr(obj,'_fields'):\n \n \n \n \n \n \n  return type(obj)(*[_astuple_inner(v,tuple_factory)for v in obj])\n elif isinstance(obj,(list,tuple)):\n \n \n \n  return type(obj)(_astuple_inner(v,tuple_factory)for v in obj)\n elif isinstance(obj,dict):\n  return type(obj)((_astuple_inner(k,tuple_factory),_astuple_inner(v,tuple_factory))\n  for k,v in obj.items())\n else :\n  return copy.deepcopy(obj)\n  \n  \ndef make_dataclass(cls_name,fields,*,bases=(),namespace=None ,init=True ,\nrepr=True ,eq=True ,order=False ,unsafe_hash=False ,\nfrozen=False ):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n if namespace is None :\n  namespace={}\n else :\n \n  namespace=namespace.copy()\n  \n  \n  \n seen=set()\n anns={}\n for item in fields:\n  if isinstance(item,str):\n   name=item\n   tp='typing.Any'\n  elif len(item)==2:\n   name,tp,=item\n  elif len(item)==3:\n   name,tp,spec=item\n   namespace[name]=spec\n  else :\n   raise TypeError(f'Invalid field: {item!r}')\n   \n  if not isinstance(name,str)or not name.isidentifier():\n   raise TypeError(f'Field names must be valid identifiers: {name!r}')\n  if keyword.iskeyword(name):\n   raise TypeError(f'Field names must not be keywords: {name!r}')\n  if name in seen:\n   raise TypeError(f'Field name duplicated: {name!r}')\n   \n  seen.add(name)\n  anns[name]=tp\n  \n namespace['__annotations__']=anns\n \n \n cls=types.new_class(cls_name,bases,{},lambda ns:ns.update(namespace))\n return dataclass(cls,init=init,repr=repr,eq=eq,order=order,\n unsafe_hash=unsafe_hash,frozen=frozen)\n \n \ndef replace(obj,/,**changes):\n ''\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n if not _is_dataclass_instance(obj):\n  raise TypeError(\"replace() should be called on dataclass instances\")\n  \n  \n  \n  \n for f in getattr(obj,_FIELDS).values():\n \n  if f._field_type is _FIELD_CLASSVAR:\n   continue\n   \n  if not f.init:\n  \n   if f.name in changes:\n    raise ValueError(f'field {f.name} is declared with '\n    'init=False, it cannot be specified with '\n    'replace()')\n   continue\n   \n  if f.name not in changes:\n   if f._field_type is _FIELD_INITVAR:\n    raise ValueError(f\"InitVar {f.name!r} \"\n    'must be specified with replace()')\n   changes[f.name]=getattr(obj,f.name)\n   \n   \n   \n   \n   \n   \n return obj.__class__(**changes)\n \n", ["_thread", "abc", "builtins", "copy", "functools", "inspect", "keyword", "re", "sys", "types"]],
     "datetime": [".py", "''\n\n\n\n\n\n__all__=(\"date\",\"datetime\",\"time\",\"timedelta\",\"timezone\",\"tzinfo\",\n\"MINYEAR\",\"MAXYEAR\")\n\n\nimport time as _time\nimport math as _math\nimport sys\n\ndef _cmp(x,y):\n return 0 if x ==y else 1 if x >y else -1\n \nMINYEAR=1\nMAXYEAR=9999\n_MAXORDINAL=3652059\n\n\n\n\n\n\n\n\n\n\n\n_DAYS_IN_MONTH=[-1,31,28,31,30,31,30,31,31,30,31,30,31]\n\n_DAYS_BEFORE_MONTH=[-1]\ndbm=0\nfor dim in _DAYS_IN_MONTH[1:]:\n _DAYS_BEFORE_MONTH.append(dbm)\n dbm +=dim\ndel dbm,dim\n\ndef _is_leap(year):\n ''\n return year %4 ==0 and (year %100 !=0 or year %400 ==0)\n \ndef _days_before_year(year):\n ''\n y=year -1\n return y *365+y //4 -y //100+y //400\n \ndef _days_in_month(year,month):\n ''\n assert 1 <=month <=12,month\n if month ==2 and _is_leap(year):\n  return 29\n return _DAYS_IN_MONTH[month]\n \ndef _days_before_month(year,month):\n ''\n assert 1 <=month <=12,'month must be in 1..12'\n return _DAYS_BEFORE_MONTH[month]+(month >2 and _is_leap(year))\n \ndef _ymd2ord(year,month,day):\n ''\n assert 1 <=month <=12,'month must be in 1..12'\n dim=_days_in_month(year,month)\n assert 1 <=day <=dim,('day must be in 1..%d'%dim)\n return (_days_before_year(year)+\n _days_before_month(year,month)+\n day)\n \n_DI400Y=_days_before_year(401)\n_DI100Y=_days_before_year(101)\n_DI4Y=_days_before_year(5)\n\n\n\nassert _DI4Y ==4 *365+1\n\n\n\nassert _DI400Y ==4 *_DI100Y+1\n\n\n\nassert _DI100Y ==25 *_DI4Y -1\n\ndef _ord2ymd(n):\n ''\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n n -=1\n n400,n=divmod(n,_DI400Y)\n year=n400 *400+1\n \n \n \n \n \n \n n100,n=divmod(n,_DI100Y)\n \n \n n4,n=divmod(n,_DI4Y)\n \n \n \n n1,n=divmod(n,365)\n \n year +=n100 *100+n4 *4+n1\n if n1 ==4 or n100 ==4:\n  assert n ==0\n  return year -1,12,31\n  \n  \n  \n leapyear=n1 ==3 and (n4 !=24 or n100 ==3)\n assert leapyear ==_is_leap(year)\n month=(n+50)>>5\n preceding=_DAYS_BEFORE_MONTH[month]+(month >2 and leapyear)\n if preceding >n:\n  month -=1\n  preceding -=_DAYS_IN_MONTH[month]+(month ==2 and leapyear)\n n -=preceding\n assert 0 <=n <_days_in_month(year,month)\n \n \n \n return year,month,n+1\n \n \n_MONTHNAMES=[None ,\"Jan\",\"Feb\",\"Mar\",\"Apr\",\"May\",\"Jun\",\n\"Jul\",\"Aug\",\"Sep\",\"Oct\",\"Nov\",\"Dec\"]\n_DAYNAMES=[None ,\"Mon\",\"Tue\",\"Wed\",\"Thu\",\"Fri\",\"Sat\",\"Sun\"]\n\n\ndef _build_struct_time(y,m,d,hh,mm,ss,dstflag):\n wday=(_ymd2ord(y,m,d)+6)%7\n dnum=_days_before_month(y,m)+d\n return _time.struct_time((y,m,d,hh,mm,ss,wday,dnum,dstflag))\n \ndef _format_time(hh,mm,ss,us,timespec='auto'):\n specs={\n 'hours':'{:02d}',\n 'minutes':'{:02d}:{:02d}',\n 'seconds':'{:02d}:{:02d}:{:02d}',\n 'milliseconds':'{:02d}:{:02d}:{:02d}.{:03d}',\n 'microseconds':'{:02d}:{:02d}:{:02d}.{:06d}'\n }\n \n if timespec =='auto':\n \n  timespec='microseconds'if us else 'seconds'\n elif timespec =='milliseconds':\n  us //=1000\n try :\n  fmt=specs[timespec]\n except KeyError:\n  raise ValueError('Unknown timespec value')\n else :\n  return fmt.format(hh,mm,ss,us)\n  \ndef _format_offset(off):\n s=''\n if off is not None :\n  if off.days <0:\n   sign=\"-\"\n   off=-off\n  else :\n   sign=\"+\"\n  hh,mm=divmod(off,timedelta(hours=1))\n  mm,ss=divmod(mm,timedelta(minutes=1))\n  s +=\"%s%02d:%02d\"%(sign,hh,mm)\n  if ss or ss.microseconds:\n   s +=\":%02d\"%ss.seconds\n   \n   if ss.microseconds:\n    s +='.%06d'%ss.microseconds\n return s\n \n \ndef _wrap_strftime(object,format,timetuple):\n\n freplace=None\n zreplace=None\n Zreplace=None\n \n \n newformat=[]\n push=newformat.append\n i,n=0,len(format)\n while i <n:\n  ch=format[i]\n  i +=1\n  if ch =='%':\n   if i <n:\n    ch=format[i]\n    i +=1\n    if ch =='f':\n     if freplace is None :\n      freplace='%06d'%getattr(object,\n      'microsecond',0)\n     newformat.append(freplace)\n    elif ch =='z':\n     if zreplace is None :\n      zreplace=\"\"\n      if hasattr(object,\"utcoffset\"):\n       offset=object.utcoffset()\n       if offset is not None :\n        sign='+'\n        if offset.days <0:\n         offset=-offset\n         sign='-'\n        h,rest=divmod(offset,timedelta(hours=1))\n        m,rest=divmod(rest,timedelta(minutes=1))\n        s=rest.seconds\n        u=offset.microseconds\n        if u:\n         zreplace='%c%02d%02d%02d.%06d'%(sign,h,m,s,u)\n        elif s:\n         zreplace='%c%02d%02d%02d'%(sign,h,m,s)\n        else :\n         zreplace='%c%02d%02d'%(sign,h,m)\n     assert '%'not in zreplace\n     newformat.append(zreplace)\n    elif ch =='Z':\n     if Zreplace is None :\n      Zreplace=\"\"\n      if hasattr(object,\"tzname\"):\n       s=object.tzname()\n       if s is not None :\n       \n        Zreplace=s.replace('%','%%')\n     newformat.append(Zreplace)\n    else :\n     push('%')\n     push(ch)\n   else :\n    push('%')\n  else :\n   push(ch)\n newformat=\"\".join(newformat)\n return _time.strftime(newformat,timetuple)\n \n \ndef _parse_isoformat_date(dtstr):\n\n\n year=int(dtstr[0:4])\n if dtstr[4]!='-':\n  raise ValueError('Invalid date separator: %s'%dtstr[4])\n  \n month=int(dtstr[5:7])\n \n if dtstr[7]!='-':\n  raise ValueError('Invalid date separator')\n  \n day=int(dtstr[8:10])\n \n return [year,month,day]\n \ndef _parse_hh_mm_ss_ff(tstr):\n\n len_str=len(tstr)\n \n time_comps=[0,0,0,0]\n pos=0\n for comp in range(0,3):\n  if (len_str -pos)<2:\n   raise ValueError('Incomplete time component')\n   \n  time_comps[comp]=int(tstr[pos:pos+2])\n  \n  pos +=2\n  next_char=tstr[pos:pos+1]\n  \n  if not next_char or comp >=2:\n   break\n   \n  if next_char !=':':\n   raise ValueError('Invalid time separator: %c'%next_char)\n   \n  pos +=1\n  \n if pos <len_str:\n  if tstr[pos]!='.':\n   raise ValueError('Invalid microsecond component')\n  else :\n   pos +=1\n   \n   len_remainder=len_str -pos\n   if len_remainder not in (3,6):\n    raise ValueError('Invalid microsecond component')\n    \n   time_comps[3]=int(tstr[pos:])\n   if len_remainder ==3:\n    time_comps[3]*=1000\n    \n return time_comps\n \ndef _parse_isoformat_time(tstr):\n\n len_str=len(tstr)\n if len_str <2:\n  raise ValueError('Isoformat time too short')\n  \n  \n tz_pos=(tstr.find('-')+1 or tstr.find('+')+1)\n timestr=tstr[:tz_pos -1]if tz_pos >0 else tstr\n \n time_comps=_parse_hh_mm_ss_ff(timestr)\n \n tzi=None\n if tz_pos >0:\n  tzstr=tstr[tz_pos:]\n  \n  \n  \n  \n  \n  \n  if len(tzstr)not in (5,8,15):\n   raise ValueError('Malformed time zone string')\n   \n  tz_comps=_parse_hh_mm_ss_ff(tzstr)\n  if all(x ==0 for x in tz_comps):\n   tzi=timezone.utc\n  else :\n   tzsign=-1 if tstr[tz_pos -1]=='-'else 1\n   \n   td=timedelta(hours=tz_comps[0],minutes=tz_comps[1],\n   seconds=tz_comps[2],microseconds=tz_comps[3])\n   \n   tzi=timezone(tzsign *td)\n   \n time_comps.append(tzi)\n \n return time_comps\n \n \n \ndef _check_tzname(name):\n if name is not None and not isinstance(name,str):\n  raise TypeError(\"tzinfo.tzname() must return None or string, \"\n  \"not '%s'\"%type(name))\n  \n  \n  \n  \n  \n  \n  \ndef _check_utc_offset(name,offset):\n assert name in (\"utcoffset\",\"dst\")\n if offset is None :\n  return\n if not isinstance(offset,timedelta):\n  raise TypeError(\"tzinfo.%s() must return None \"\n  \"or timedelta, not '%s'\"%(name,type(offset)))\n if not -timedelta(1)<offset <timedelta(1):\n  raise ValueError(\"%s()=%s, must be strictly between \"\n  \"-timedelta(hours=24) and timedelta(hours=24)\"%\n  (name,offset))\n  \ndef _check_int_field(value):\n if isinstance(value,int):\n  return value\n if isinstance(value,float):\n  raise TypeError('integer argument expected, got float')\n try :\n  value=value.__index__()\n except AttributeError:\n  pass\n else :\n  if not isinstance(value,int):\n   raise TypeError('__index__ returned non-int (type %s)'%\n   type(value).__name__)\n  return value\n orig=value\n try :\n  value=value.__int__()\n except AttributeError:\n  pass\n else :\n  if not isinstance(value,int):\n   raise TypeError('__int__ returned non-int (type %s)'%\n   type(value).__name__)\n  import warnings\n  warnings.warn(\"an integer is required (got type %s)\"%\n  type(orig).__name__,\n  DeprecationWarning,\n  stacklevel=2)\n  return value\n raise TypeError('an integer is required (got type %s)'%\n type(value).__name__)\n \ndef _check_date_fields(year,month,day):\n year=_check_int_field(year)\n month=_check_int_field(month)\n day=_check_int_field(day)\n if not MINYEAR <=year <=MAXYEAR:\n  raise ValueError('year must be in %d..%d'%(MINYEAR,MAXYEAR),year)\n if not 1 <=month <=12:\n  raise ValueError('month must be in 1..12',month)\n dim=_days_in_month(year,month)\n if not 1 <=day <=dim:\n  raise ValueError('day must be in 1..%d'%dim,day)\n return year,month,day\n \ndef _check_time_fields(hour,minute,second,microsecond,fold):\n hour=_check_int_field(hour)\n minute=_check_int_field(minute)\n second=_check_int_field(second)\n microsecond=_check_int_field(microsecond)\n if not 0 <=hour <=23:\n  raise ValueError('hour must be in 0..23',hour)\n if not 0 <=minute <=59:\n  raise ValueError('minute must be in 0..59',minute)\n if not 0 <=second <=59:\n  raise ValueError('second must be in 0..59',second)\n if not 0 <=microsecond <=999999:\n  raise ValueError('microsecond must be in 0..999999',microsecond)\n if fold not in (0,1):\n  raise ValueError('fold must be either 0 or 1',fold)\n return hour,minute,second,microsecond,fold\n \ndef _check_tzinfo_arg(tz):\n if tz is not None and not isinstance(tz,tzinfo):\n  raise TypeError(\"tzinfo argument must be None or of a tzinfo subclass\")\n  \ndef _cmperror(x,y):\n raise TypeError(\"can't compare '%s' to '%s'\"%(\n type(x).__name__,type(y).__name__))\n \ndef _divide_and_round(a,b):\n ''\n\n\n\n \n \n \n q,r=divmod(a,b)\n \n \n \n r *=2\n greater_than_half=r >b if b >0 else r <b\n if greater_than_half or r ==b and q %2 ==1:\n  q +=1\n  \n return q\n \n \nclass timedelta:\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n __slots__='_days','_seconds','_microseconds','_hashcode'\n \n def __new__(cls,days=0,seconds=0,microseconds=0,\n milliseconds=0,minutes=0,hours=0,weeks=0):\n \n \n \n \n \n \n \n \n \n \n \n \n  d=s=us=0\n  \n  \n  days +=weeks *7\n  seconds +=minutes *60+hours *3600\n  microseconds +=milliseconds *1000\n  \n  \n  \n  if isinstance(days,float):\n   dayfrac,days=_math.modf(days)\n   daysecondsfrac,daysecondswhole=_math.modf(dayfrac *(24. *3600.))\n   assert daysecondswhole ==int(daysecondswhole)\n   s=int(daysecondswhole)\n   assert days ==int(days)\n   d=int(days)\n  else :\n   daysecondsfrac=0.0\n   d=days\n  assert isinstance(daysecondsfrac,float)\n  assert abs(daysecondsfrac)<=1.0\n  assert isinstance(d,int)\n  assert abs(s)<=24 *3600\n  \n  \n  if isinstance(seconds,float):\n   secondsfrac,seconds=_math.modf(seconds)\n   assert seconds ==int(seconds)\n   seconds=int(seconds)\n   secondsfrac +=daysecondsfrac\n   assert abs(secondsfrac)<=2.0\n  else :\n   secondsfrac=daysecondsfrac\n   \n  assert isinstance(secondsfrac,float)\n  assert abs(secondsfrac)<=2.0\n  \n  assert isinstance(seconds,int)\n  days,seconds=divmod(seconds,24 *3600)\n  d +=days\n  s +=int(seconds)\n  assert isinstance(s,int)\n  assert abs(s)<=2 *24 *3600\n  \n  \n  usdouble=secondsfrac *1e6\n  assert abs(usdouble)<2.1e6\n  \n  \n  if isinstance(microseconds,float):\n   microseconds=round(microseconds+usdouble)\n   seconds,microseconds=divmod(microseconds,1000000)\n   days,seconds=divmod(seconds,24 *3600)\n   d +=days\n   s +=seconds\n  else :\n   microseconds=int(microseconds)\n   seconds,microseconds=divmod(microseconds,1000000)\n   days,seconds=divmod(seconds,24 *3600)\n   d +=days\n   s +=seconds\n   microseconds=round(microseconds+usdouble)\n  assert isinstance(s,int)\n  assert isinstance(microseconds,int)\n  assert abs(s)<=3 *24 *3600\n  assert abs(microseconds)<3.1e6\n  \n  \n  seconds,us=divmod(microseconds,1000000)\n  s +=seconds\n  days,s=divmod(s,24 *3600)\n  d +=days\n  \n  assert isinstance(d,int)\n  assert isinstance(s,int)and 0 <=s <24 *3600\n  assert isinstance(us,int)and 0 <=us <1000000\n  \n  if abs(d)>999999999:\n   raise OverflowError(\"timedelta # of days is too large: %d\"%d)\n   \n  self=object.__new__(cls)\n  self._days=d\n  self._seconds=s\n  self._microseconds=us\n  self._hashcode=-1\n  return self\n  \n def __repr__(self):\n  args=[]\n  if self._days:\n   args.append(\"days=%d\"%self._days)\n  if self._seconds:\n   args.append(\"seconds=%d\"%self._seconds)\n  if self._microseconds:\n   args.append(\"microseconds=%d\"%self._microseconds)\n  if not args:\n   args.append('0')\n  return \"%s.%s(%s)\"%(self.__class__.__module__,\n  self.__class__.__qualname__,\n  ', '.join(args))\n  \n def __str__(self):\n  mm,ss=divmod(self._seconds,60)\n  hh,mm=divmod(mm,60)\n  s=\"%d:%02d:%02d\"%(hh,mm,ss)\n  if self._days:\n   def plural(n):\n    return n,abs(n)!=1 and \"s\"or \"\"\n   s=(\"%d day%s, \"%plural(self._days))+s\n  if self._microseconds:\n   s=s+\".%06d\"%self._microseconds\n  return s\n  \n def total_seconds(self):\n  ''\n  return ((self.days *86400+self.seconds)*10 **6+\n  self.microseconds)/10 **6\n  \n  \n @property\n def days(self):\n  ''\n  return self._days\n  \n @property\n def seconds(self):\n  ''\n  return self._seconds\n  \n @property\n def microseconds(self):\n  ''\n  return self._microseconds\n  \n def __add__(self,other):\n  if isinstance(other,timedelta):\n  \n  \n   return timedelta(self._days+other._days,\n   self._seconds+other._seconds,\n   self._microseconds+other._microseconds)\n  return NotImplemented\n  \n __radd__=__add__\n \n def __sub__(self,other):\n  if isinstance(other,timedelta):\n  \n  \n   return timedelta(self._days -other._days,\n   self._seconds -other._seconds,\n   self._microseconds -other._microseconds)\n  return NotImplemented\n  \n def __rsub__(self,other):\n  if isinstance(other,timedelta):\n   return -self+other\n  return NotImplemented\n  \n def __neg__(self):\n \n \n  return timedelta(-self._days,\n  -self._seconds,\n  -self._microseconds)\n  \n def __pos__(self):\n  return self\n  \n def __abs__(self):\n  if self._days <0:\n   return -self\n  else :\n   return self\n   \n def __mul__(self,other):\n  if isinstance(other,int):\n  \n  \n   return timedelta(self._days *other,\n   self._seconds *other,\n   self._microseconds *other)\n  if isinstance(other,float):\n   usec=self._to_microseconds()\n   a,b=other.as_integer_ratio()\n   return timedelta(0,0,_divide_and_round(usec *a,b))\n  return NotImplemented\n  \n __rmul__=__mul__\n \n def _to_microseconds(self):\n  return ((self._days *(24 *3600)+self._seconds)*1000000+\n  self._microseconds)\n  \n def __floordiv__(self,other):\n  if not isinstance(other,(int,timedelta)):\n   return NotImplemented\n  usec=self._to_microseconds()\n  if isinstance(other,timedelta):\n   return usec //other._to_microseconds()\n  if isinstance(other,int):\n   return timedelta(0,0,usec //other)\n   \n def __truediv__(self,other):\n  if not isinstance(other,(int,float,timedelta)):\n   return NotImplemented\n  usec=self._to_microseconds()\n  if isinstance(other,timedelta):\n   return usec /other._to_microseconds()\n  if isinstance(other,int):\n   return timedelta(0,0,_divide_and_round(usec,other))\n  if isinstance(other,float):\n   a,b=other.as_integer_ratio()\n   return timedelta(0,0,_divide_and_round(b *usec,a))\n   \n def __mod__(self,other):\n  if isinstance(other,timedelta):\n   r=self._to_microseconds()%other._to_microseconds()\n   return timedelta(0,0,r)\n  return NotImplemented\n  \n def __divmod__(self,other):\n  if isinstance(other,timedelta):\n   q,r=divmod(self._to_microseconds(),\n   other._to_microseconds())\n   return q,timedelta(0,0,r)\n  return NotImplemented\n  \n  \n  \n def __eq__(self,other):\n  if isinstance(other,timedelta):\n   return self._cmp(other)==0\n  else :\n   return NotImplemented\n   \n def __le__(self,other):\n  if isinstance(other,timedelta):\n   return self._cmp(other)<=0\n  else :\n   return NotImplemented\n   \n def __lt__(self,other):\n  if isinstance(other,timedelta):\n   return self._cmp(other)<0\n  else :\n   return NotImplemented\n   \n def __ge__(self,other):\n  if isinstance(other,timedelta):\n   return self._cmp(other)>=0\n  else :\n   return NotImplemented\n   \n def __gt__(self,other):\n  if isinstance(other,timedelta):\n   return self._cmp(other)>0\n  else :\n   return NotImplemented\n   \n def _cmp(self,other):\n  assert isinstance(other,timedelta)\n  return _cmp(self._getstate(),other._getstate())\n  \n def __hash__(self):\n  if self._hashcode ==-1:\n   self._hashcode=hash(self._getstate())\n  return self._hashcode\n  \n def __bool__(self):\n  return (self._days !=0 or\n  self._seconds !=0 or\n  self._microseconds !=0)\n  \n  \n  \n def _getstate(self):\n  return (self._days,self._seconds,self._microseconds)\n  \n def __reduce__(self):\n  return (self.__class__,self._getstate())\n  \ntimedelta.min=timedelta(-999999999)\ntimedelta.max=timedelta(days=999999999,hours=23,minutes=59,seconds=59,\nmicroseconds=999999)\ntimedelta.resolution=timedelta(microseconds=1)\n\nclass date:\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n __slots__='_year','_month','_day','_hashcode'\n \n def __new__(cls,year,month=None ,day=None ):\n  ''\n\n\n\n\n  \n  if (month is None and\n  isinstance(year,(bytes,str))and len(year)==4 and\n  1 <=ord(year[2:3])<=12):\n  \n   if isinstance(year,str):\n    try :\n     year=year.encode('latin1')\n    except UnicodeEncodeError:\n    \n     raise ValueError(\n     \"Failed to encode latin1 string when unpickling \"\n     \"a date object. \"\n     \"pickle.load(data, encoding='latin1') is assumed.\")\n   self=object.__new__(cls)\n   self.__setstate(year)\n   self._hashcode=-1\n   return self\n  year,month,day=_check_date_fields(year,month,day)\n  self=object.__new__(cls)\n  self._year=year\n  self._month=month\n  self._day=day\n  self._hashcode=-1\n  return self\n  \n  \n  \n @classmethod\n def fromtimestamp(cls,t):\n  ''\n  y,m,d,hh,mm,ss,weekday,jday,dst=_time.localtime(t)\n  return cls(y,m,d)\n  \n @classmethod\n def today(cls):\n  ''\n  t=_time.time()\n  return cls.fromtimestamp(t)\n  \n @classmethod\n def fromordinal(cls,n):\n  ''\n\n\n\n  \n  y,m,d=_ord2ymd(n)\n  return cls(y,m,d)\n  \n @classmethod\n def fromisoformat(cls,date_string):\n  ''\n  if not isinstance(date_string,str):\n   raise TypeError('fromisoformat: argument must be str')\n   \n  try :\n   assert len(date_string)==10\n   return cls(*_parse_isoformat_date(date_string))\n  except Exception:\n   raise ValueError(f'Invalid isoformat string: {date_string!r}')\n   \n @classmethod\n def fromisocalendar(cls,year,week,day):\n  ''\n\n  \n  \n  if not MINYEAR <=year <=MAXYEAR:\n   raise ValueError(f\"Year is out of range: {year}\")\n   \n  if not 0 <week <53:\n   out_of_range=True\n   \n   if week ==53:\n   \n   \n    first_weekday=_ymd2ord(year,1,1)%7\n    if (first_weekday ==4 or (first_weekday ==3 and\n    _is_leap(year))):\n     out_of_range=False\n     \n   if out_of_range:\n    raise ValueError(f\"Invalid week: {week}\")\n    \n  if not 0 <day <8:\n   raise ValueError(f\"Invalid weekday: {day} (range is [1, 7])\")\n   \n   \n  day_offset=(week -1)*7+(day -1)\n  \n  \n  day_1=_isoweek1monday(year)\n  ord_day=day_1+day_offset\n  \n  return cls(*_ord2ymd(ord_day))\n  \n  \n  \n def __repr__(self):\n  ''\n\n\n\n\n\n\n\n\n  \n  return \"%s.%s(%d, %d, %d)\"%(self.__class__.__module__,\n  self.__class__.__qualname__,\n  self._year,\n  self._month,\n  self._day)\n  \n  \n  \n  \n  \n  \n def ctime(self):\n  ''\n  weekday=self.toordinal()%7 or 7\n  return \"%s %s %2d 00:00:00 %04d\"%(\n  _DAYNAMES[weekday],\n  _MONTHNAMES[self._month],\n  self._day,self._year)\n  \n def strftime(self,fmt):\n  ''\n  return _wrap_strftime(self,fmt,self.timetuple())\n  \n def __format__(self,fmt):\n  if not isinstance(fmt,str):\n   raise TypeError(\"must be str, not %s\"%type(fmt).__name__)\n  if len(fmt)!=0:\n   return self.strftime(fmt)\n  return str(self)\n  \n def isoformat(self):\n  ''\n\n\n\n\n\n\n  \n  return \"%04d-%02d-%02d\"%(self._year,self._month,self._day)\n  \n __str__=isoformat\n \n \n @property\n def year(self):\n  ''\n  return self._year\n  \n @property\n def month(self):\n  ''\n  return self._month\n  \n @property\n def day(self):\n  ''\n  return self._day\n  \n  \n  \n  \n def timetuple(self):\n  ''\n  return _build_struct_time(self._year,self._month,self._day,\n  0,0,0,-1)\n  \n def toordinal(self):\n  ''\n\n\n\n  \n  return _ymd2ord(self._year,self._month,self._day)\n  \n def replace(self,year=None ,month=None ,day=None ):\n  ''\n  if year is None :\n   year=self._year\n  if month is None :\n   month=self._month\n  if day is None :\n   day=self._day\n  return type(self)(year,month,day)\n  \n  \n  \n def __eq__(self,other):\n  if isinstance(other,date):\n   return self._cmp(other)==0\n  return NotImplemented\n  \n def __le__(self,other):\n  if isinstance(other,date):\n   return self._cmp(other)<=0\n  return NotImplemented\n  \n def __lt__(self,other):\n  if isinstance(other,date):\n   return self._cmp(other)<0\n  return NotImplemented\n  \n def __ge__(self,other):\n  if isinstance(other,date):\n   return self._cmp(other)>=0\n  return NotImplemented\n  \n def __gt__(self,other):\n  if isinstance(other,date):\n   return self._cmp(other)>0\n  return NotImplemented\n  \n def _cmp(self,other):\n  assert isinstance(other,date)\n  y,m,d=self._year,self._month,self._day\n  y2,m2,d2=other._year,other._month,other._day\n  return _cmp((y,m,d),(y2,m2,d2))\n  \n def __hash__(self):\n  ''\n  if self._hashcode ==-1:\n   self._hashcode=hash(self._getstate())\n  return self._hashcode\n  \n  \n  \n def __add__(self,other):\n  ''\n  if isinstance(other,timedelta):\n   o=self.toordinal()+other.days\n   if 0 <o <=_MAXORDINAL:\n    return type(self).fromordinal(o)\n   raise OverflowError(\"result out of range\")\n  return NotImplemented\n  \n __radd__=__add__\n \n def __sub__(self,other):\n  ''\n  if isinstance(other,timedelta):\n   return self+timedelta(-other.days)\n  if isinstance(other,date):\n   days1=self.toordinal()\n   days2=other.toordinal()\n   return timedelta(days1 -days2)\n  return NotImplemented\n  \n def weekday(self):\n  ''\n  return (self.toordinal()+6)%7\n  \n  \n  \n def isoweekday(self):\n  ''\n  \n  return self.toordinal()%7 or 7\n  \n def isocalendar(self):\n  ''\n\n\n\n\n\n\n\n\n\n\n  \n  year=self._year\n  week1monday=_isoweek1monday(year)\n  today=_ymd2ord(self._year,self._month,self._day)\n  \n  week,day=divmod(today -week1monday,7)\n  if week <0:\n   year -=1\n   week1monday=_isoweek1monday(year)\n   week,day=divmod(today -week1monday,7)\n  elif week >=52:\n   if today >=_isoweek1monday(year+1):\n    year +=1\n    week=0\n  return _IsoCalendarDate(year,week+1,day+1)\n  \n  \n  \n def _getstate(self):\n  yhi,ylo=divmod(self._year,256)\n  return bytes([yhi,ylo,self._month,self._day]),\n  \n def __setstate(self,string):\n  yhi,ylo,self._month,self._day=string\n  self._year=yhi *256+ylo\n  \n def __reduce__(self):\n  return (self.__class__,self._getstate())\n  \n_date_class=date\n\ndate.min=date(1,1,1)\ndate.max=date(9999,12,31)\ndate.resolution=timedelta(days=1)\n\n\nclass tzinfo:\n ''\n\n\n \n __slots__=()\n \n def tzname(self,dt):\n  ''\n  raise NotImplementedError(\"tzinfo subclass must override tzname()\")\n  \n def utcoffset(self,dt):\n  ''\n  raise NotImplementedError(\"tzinfo subclass must override utcoffset()\")\n  \n def dst(self,dt):\n  ''\n\n\n\n  \n  raise NotImplementedError(\"tzinfo subclass must override dst()\")\n  \n def fromutc(self,dt):\n  ''\n  \n  if not isinstance(dt,datetime):\n   raise TypeError(\"fromutc() requires a datetime argument\")\n  if dt.tzinfo is not self:\n   raise ValueError(\"dt.tzinfo is not self\")\n   \n  dtoff=dt.utcoffset()\n  if dtoff is None :\n   raise ValueError(\"fromutc() requires a non-None utcoffset() \"\n   \"result\")\n   \n   \n   \n  dtdst=dt.dst()\n  if dtdst is None :\n   raise ValueError(\"fromutc() requires a non-None dst() result\")\n  delta=dtoff -dtdst\n  if delta:\n   dt +=delta\n   dtdst=dt.dst()\n   if dtdst is None :\n    raise ValueError(\"fromutc(): dt.dst gave inconsistent \"\n    \"results; cannot convert\")\n  return dt+dtdst\n  \n  \n  \n def __reduce__(self):\n  getinitargs=getattr(self,\"__getinitargs__\",None )\n  if getinitargs:\n   args=getinitargs()\n  else :\n   args=()\n  getstate=getattr(self,\"__getstate__\",None )\n  if getstate:\n   state=getstate()\n  else :\n   state=getattr(self,\"__dict__\",None )or None\n  if state is None :\n   return (self.__class__,args)\n  else :\n   return (self.__class__,args,state)\n   \n   \nclass IsoCalendarDate(tuple):\n\n def __new__(cls,year,week,weekday,/):\n  return super().__new__(cls,(year,week,weekday))\n  \n @property\n def year(self):\n  return self[0]\n  \n @property\n def week(self):\n  return self[1]\n  \n @property\n def weekday(self):\n  return self[2]\n  \n def __reduce__(self):\n \n \n  return (tuple,(tuple(self),))\n  \n def __repr__(self):\n  return (f'{self.__class__.__name__}'\n  f'(year={self[0]}, week={self[1]}, weekday={self[2]})')\n  \n  \n_IsoCalendarDate=IsoCalendarDate\ndel IsoCalendarDate\n_tzinfo_class=tzinfo\n\nclass time:\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n __slots__='_hour','_minute','_second','_microsecond','_tzinfo','_hashcode','_fold'\n \n def __new__(cls,hour=0,minute=0,second=0,microsecond=0,tzinfo=None ,*,fold=0):\n  ''\n\n\n\n\n\n\n\n  \n  if (isinstance(hour,(bytes,str))and len(hour)==6 and\n  ord(hour[0:1])&0x7F <24):\n  \n   if isinstance(hour,str):\n    try :\n     hour=hour.encode('latin1')\n    except UnicodeEncodeError:\n    \n     raise ValueError(\n     \"Failed to encode latin1 string when unpickling \"\n     \"a time object. \"\n     \"pickle.load(data, encoding='latin1') is assumed.\")\n   self=object.__new__(cls)\n   self.__setstate(hour,minute or None )\n   self._hashcode=-1\n   return self\n  hour,minute,second,microsecond,fold=_check_time_fields(\n  hour,minute,second,microsecond,fold)\n  _check_tzinfo_arg(tzinfo)\n  self=object.__new__(cls)\n  self._hour=hour\n  self._minute=minute\n  self._second=second\n  self._microsecond=microsecond\n  self._tzinfo=tzinfo\n  self._hashcode=-1\n  self._fold=fold\n  return self\n  \n  \n @property\n def hour(self):\n  ''\n  return self._hour\n  \n @property\n def minute(self):\n  ''\n  return self._minute\n  \n @property\n def second(self):\n  ''\n  return self._second\n  \n @property\n def microsecond(self):\n  ''\n  return self._microsecond\n  \n @property\n def tzinfo(self):\n  ''\n  return self._tzinfo\n  \n @property\n def fold(self):\n  return self._fold\n  \n  \n  \n  \n  \n def __eq__(self,other):\n  if isinstance(other,time):\n   return self._cmp(other,allow_mixed=True )==0\n  else :\n   return NotImplemented\n   \n def __le__(self,other):\n  if isinstance(other,time):\n   return self._cmp(other)<=0\n  else :\n   return NotImplemented\n   \n def __lt__(self,other):\n  if isinstance(other,time):\n   return self._cmp(other)<0\n  else :\n   return NotImplemented\n   \n def __ge__(self,other):\n  if isinstance(other,time):\n   return self._cmp(other)>=0\n  else :\n   return NotImplemented\n   \n def __gt__(self,other):\n  if isinstance(other,time):\n   return self._cmp(other)>0\n  else :\n   return NotImplemented\n   \n def _cmp(self,other,allow_mixed=False ):\n  assert isinstance(other,time)\n  mytz=self._tzinfo\n  ottz=other._tzinfo\n  myoff=otoff=None\n  \n  if mytz is ottz:\n   base_compare=True\n  else :\n   myoff=self.utcoffset()\n   otoff=other.utcoffset()\n   base_compare=myoff ==otoff\n   \n  if base_compare:\n   return _cmp((self._hour,self._minute,self._second,\n   self._microsecond),\n   (other._hour,other._minute,other._second,\n   other._microsecond))\n  if myoff is None or otoff is None :\n   if allow_mixed:\n    return 2\n   else :\n    raise TypeError(\"cannot compare naive and aware times\")\n  myhhmm=self._hour *60+self._minute -myoff //timedelta(minutes=1)\n  othhmm=other._hour *60+other._minute -otoff //timedelta(minutes=1)\n  return _cmp((myhhmm,self._second,self._microsecond),\n  (othhmm,other._second,other._microsecond))\n  \n def __hash__(self):\n  ''\n  if self._hashcode ==-1:\n   if self.fold:\n    t=self.replace(fold=0)\n   else :\n    t=self\n   tzoff=t.utcoffset()\n   if not tzoff:\n    self._hashcode=hash(t._getstate()[0])\n   else :\n    h,m=divmod(timedelta(hours=self.hour,minutes=self.minute)-tzoff,\n    timedelta(hours=1))\n    assert not m %timedelta(minutes=1),\"whole minute\"\n    m //=timedelta(minutes=1)\n    if 0 <=h <24:\n     self._hashcode=hash(time(h,m,self.second,self.microsecond))\n    else :\n     self._hashcode=hash((h,m,self.second,self.microsecond))\n  return self._hashcode\n  \n  \n  \n def _tzstr(self):\n  ''\n  off=self.utcoffset()\n  return _format_offset(off)\n  \n def __repr__(self):\n  ''\n  if self._microsecond !=0:\n   s=\", %d, %d\"%(self._second,self._microsecond)\n  elif self._second !=0:\n   s=\", %d\"%self._second\n  else :\n   s=\"\"\n  s=\"%s.%s(%d, %d%s)\"%(self.__class__.__module__,\n  self.__class__.__qualname__,\n  self._hour,self._minute,s)\n  if self._tzinfo is not None :\n   assert s[-1:]==\")\"\n   s=s[:-1]+\", tzinfo=%r\"%self._tzinfo+\")\"\n  if self._fold:\n   assert s[-1:]==\")\"\n   s=s[:-1]+\", fold=1)\"\n  return s\n  \n def isoformat(self,timespec='auto'):\n  ''\n\n\n\n\n\n\n\n  \n  s=_format_time(self._hour,self._minute,self._second,\n  self._microsecond,timespec)\n  tz=self._tzstr()\n  if tz:\n   s +=tz\n  return s\n  \n __str__=isoformat\n \n @classmethod\n def fromisoformat(cls,time_string):\n  ''\n  if not isinstance(time_string,str):\n   raise TypeError('fromisoformat: argument must be str')\n   \n  try :\n   return cls(*_parse_isoformat_time(time_string))\n  except Exception:\n   raise ValueError(f'Invalid isoformat string: {time_string!r}')\n   \n   \n def strftime(self,fmt):\n  ''\n\n  \n  \n  \n  timetuple=(1900,1,1,\n  self._hour,self._minute,self._second,\n  0,1,-1)\n  return _wrap_strftime(self,fmt,timetuple)\n  \n def __format__(self,fmt):\n  if not isinstance(fmt,str):\n   raise TypeError(\"must be str, not %s\"%type(fmt).__name__)\n  if len(fmt)!=0:\n   return self.strftime(fmt)\n  return str(self)\n  \n  \n  \n def utcoffset(self):\n  ''\n  \n  if self._tzinfo is None :\n   return None\n  offset=self._tzinfo.utcoffset(None )\n  _check_utc_offset(\"utcoffset\",offset)\n  return offset\n  \n def tzname(self):\n  ''\n\n\n\n\n  \n  if self._tzinfo is None :\n   return None\n  name=self._tzinfo.tzname(None )\n  _check_tzname(name)\n  return name\n  \n def dst(self):\n  ''\n\n\n\n\n\n\n  \n  if self._tzinfo is None :\n   return None\n  offset=self._tzinfo.dst(None )\n  _check_utc_offset(\"dst\",offset)\n  return offset\n  \n def replace(self,hour=None ,minute=None ,second=None ,microsecond=None ,\n tzinfo=True ,*,fold=None ):\n  ''\n  if hour is None :\n   hour=self.hour\n  if minute is None :\n   minute=self.minute\n  if second is None :\n   second=self.second\n  if microsecond is None :\n   microsecond=self.microsecond\n  if tzinfo is True :\n   tzinfo=self.tzinfo\n  if fold is None :\n   fold=self._fold\n  return type(self)(hour,minute,second,microsecond,tzinfo,fold=fold)\n  \n  \n  \n def _getstate(self,protocol=3):\n  us2,us3=divmod(self._microsecond,256)\n  us1,us2=divmod(us2,256)\n  h=self._hour\n  if self._fold and protocol >3:\n   h +=128\n  basestate=bytes([h,self._minute,self._second,\n  us1,us2,us3])\n  if self._tzinfo is None :\n   return (basestate,)\n  else :\n   return (basestate,self._tzinfo)\n   \n def __setstate(self,string,tzinfo):\n  if tzinfo is not None and not isinstance(tzinfo,_tzinfo_class):\n   raise TypeError(\"bad tzinfo state arg\")\n  h,self._minute,self._second,us1,us2,us3=string\n  if h >127:\n   self._fold=1\n   self._hour=h -128\n  else :\n   self._fold=0\n   self._hour=h\n  self._microsecond=(((us1 <<8)|us2)<<8)|us3\n  self._tzinfo=tzinfo\n  \n def __reduce_ex__(self,protocol):\n  return (time,self._getstate(protocol))\n  \n def __reduce__(self):\n  return self.__reduce_ex__(2)\n  \n_time_class=time\n\ntime.min=time(0,0,0)\ntime.max=time(23,59,59,999999)\ntime.resolution=timedelta(microseconds=1)\n\n\nclass datetime(date):\n ''\n\n\n\n \n __slots__=date.__slots__+time.__slots__\n \n def __new__(cls,year,month=None ,day=None ,hour=0,minute=0,second=0,\n microsecond=0,tzinfo=None ,*,fold=0):\n  if (isinstance(year,(bytes,str))and len(year)==10 and\n  1 <=ord(year[2:3])&0x7F <=12):\n  \n   if isinstance(year,str):\n    try :\n     year=bytes(year,'latin1')\n    except UnicodeEncodeError:\n    \n     raise ValueError(\n     \"Failed to encode latin1 string when unpickling \"\n     \"a datetime object. \"\n     \"pickle.load(data, encoding='latin1') is assumed.\")\n   self=object.__new__(cls)\n   self.__setstate(year,month)\n   self._hashcode=-1\n   return self\n  year,month,day=_check_date_fields(year,month,day)\n  hour,minute,second,microsecond,fold=_check_time_fields(\n  hour,minute,second,microsecond,fold)\n  _check_tzinfo_arg(tzinfo)\n  self=object.__new__(cls)\n  self._year=year\n  self._month=month\n  self._day=day\n  self._hour=hour\n  self._minute=minute\n  self._second=second\n  self._microsecond=microsecond\n  self._tzinfo=tzinfo\n  self._hashcode=-1\n  self._fold=fold\n  return self\n  \n  \n @property\n def hour(self):\n  ''\n  return self._hour\n  \n @property\n def minute(self):\n  ''\n  return self._minute\n  \n @property\n def second(self):\n  ''\n  return self._second\n  \n @property\n def microsecond(self):\n  ''\n  return self._microsecond\n  \n @property\n def tzinfo(self):\n  ''\n  return self._tzinfo\n  \n @property\n def fold(self):\n  return self._fold\n  \n @classmethod\n def _fromtimestamp(cls,t,utc,tz):\n  ''\n\n\n  \n  frac,t=_math.modf(t)\n  us=round(frac *1e6)\n  if us >=1000000:\n   t +=1\n   us -=1000000\n  elif us <0:\n   t -=1\n   us +=1000000\n   \n  converter=_time.gmtime if utc else _time.localtime\n  y,m,d,hh,mm,ss,weekday,jday,dst=converter(t)\n  ss=min(ss,59)\n  result=cls(y,m,d,hh,mm,ss,us,tz)\n  if tz is None :\n  \n  \n  \n   max_fold_seconds=24 *3600\n   \n   \n   \n   \n   \n   if t <max_fold_seconds and sys.platform.startswith(\"win\"):\n    return result\n    \n   y,m,d,hh,mm,ss=converter(t -max_fold_seconds)[:6]\n   probe1=cls(y,m,d,hh,mm,ss,us,tz)\n   trans=result -probe1 -timedelta(0,max_fold_seconds)\n   if trans.days <0:\n    y,m,d,hh,mm,ss=converter(t+trans //timedelta(0,1))[:6]\n    probe2=cls(y,m,d,hh,mm,ss,us,tz)\n    if probe2 ==result:\n     result._fold=1\n  else :\n   result=tz.fromutc(result)\n  return result\n  \n @classmethod\n def fromtimestamp(cls,t,tz=None ):\n  ''\n\n\n  \n  _check_tzinfo_arg(tz)\n  \n  return cls._fromtimestamp(t,tz is not None ,tz)\n  \n @classmethod\n def utcfromtimestamp(cls,t):\n  ''\n  return cls._fromtimestamp(t,True ,None )\n  \n @classmethod\n def now(cls,tz=None ):\n  ''\n  t=_time.time()\n  return cls.fromtimestamp(t,tz)\n  \n @classmethod\n def utcnow(cls):\n  ''\n  t=_time.time()\n  return cls.utcfromtimestamp(t)\n  \n @classmethod\n def combine(cls,date,time,tzinfo=True ):\n  ''\n  if not isinstance(date,_date_class):\n   raise TypeError(\"date argument must be a date instance\")\n  if not isinstance(time,_time_class):\n   raise TypeError(\"time argument must be a time instance\")\n  if tzinfo is True :\n   tzinfo=time.tzinfo\n  return cls(date.year,date.month,date.day,\n  time.hour,time.minute,time.second,time.microsecond,\n  tzinfo,fold=time.fold)\n  \n @classmethod\n def fromisoformat(cls,date_string):\n  ''\n  if not isinstance(date_string,str):\n   raise TypeError('fromisoformat: argument must be str')\n   \n   \n  dstr=date_string[0:10]\n  tstr=date_string[11:]\n  \n  try :\n   date_components=_parse_isoformat_date(dstr)\n  except ValueError:\n   raise ValueError(f'Invalid isoformat string: {date_string!r}')\n   \n  if tstr:\n   try :\n    time_components=_parse_isoformat_time(tstr)\n   except ValueError:\n    raise ValueError(f'Invalid isoformat string: {date_string!r}')\n  else :\n   time_components=[0,0,0,0,None ]\n   \n  return cls(*(date_components+time_components))\n  \n def timetuple(self):\n  ''\n  dst=self.dst()\n  if dst is None :\n   dst=-1\n  elif dst:\n   dst=1\n  else :\n   dst=0\n  return _build_struct_time(self.year,self.month,self.day,\n  self.hour,self.minute,self.second,\n  dst)\n  \n def _mktime(self):\n  ''\n  epoch=datetime(1970,1,1)\n  max_fold_seconds=24 *3600\n  t=(self -epoch)//timedelta(0,1)\n  def local(u):\n   y,m,d,hh,mm,ss=_time.localtime(u)[:6]\n   return (datetime(y,m,d,hh,mm,ss)-epoch)//timedelta(0,1)\n   \n   \n  a=local(t)-t\n  u1=t -a\n  t1=local(u1)\n  if t1 ==t:\n  \n  \n  \n   u2=u1+(-max_fold_seconds,max_fold_seconds)[self.fold]\n   b=local(u2)-u2\n   if a ==b:\n    return u1\n  else :\n   b=t1 -u1\n   assert a !=b\n  u2=t -b\n  t2=local(u2)\n  if t2 ==t:\n   return u2\n  if t1 ==t:\n   return u1\n   \n   \n  return (max,min)[self.fold](u1,u2)\n  \n  \n def timestamp(self):\n  ''\n  if self._tzinfo is None :\n   s=self._mktime()\n   return s+self.microsecond /1e6\n  else :\n   return (self -_EPOCH).total_seconds()\n   \n def utctimetuple(self):\n  ''\n  offset=self.utcoffset()\n  if offset:\n   self -=offset\n  y,m,d=self.year,self.month,self.day\n  hh,mm,ss=self.hour,self.minute,self.second\n  return _build_struct_time(y,m,d,hh,mm,ss,0)\n  \n def date(self):\n  ''\n  return date(self._year,self._month,self._day)\n  \n def time(self):\n  ''\n  return time(self.hour,self.minute,self.second,self.microsecond,fold=self.fold)\n  \n def timetz(self):\n  ''\n  return time(self.hour,self.minute,self.second,self.microsecond,\n  self._tzinfo,fold=self.fold)\n  \n def replace(self,year=None ,month=None ,day=None ,hour=None ,\n minute=None ,second=None ,microsecond=None ,tzinfo=True ,\n *,fold=None ):\n  ''\n  if year is None :\n   year=self.year\n  if month is None :\n   month=self.month\n  if day is None :\n   day=self.day\n  if hour is None :\n   hour=self.hour\n  if minute is None :\n   minute=self.minute\n  if second is None :\n   second=self.second\n  if microsecond is None :\n   microsecond=self.microsecond\n  if tzinfo is True :\n   tzinfo=self.tzinfo\n  if fold is None :\n   fold=self.fold\n  return type(self)(year,month,day,hour,minute,second,\n  microsecond,tzinfo,fold=fold)\n  \n def _local_timezone(self):\n  if self.tzinfo is None :\n   ts=self._mktime()\n  else :\n   ts=(self -_EPOCH)//timedelta(seconds=1)\n  localtm=_time.localtime(ts)\n  local=datetime(*localtm[:6])\n  \n  gmtoff=localtm.tm_gmtoff\n  zone=localtm.tm_zone\n  return timezone(timedelta(seconds=gmtoff),zone)\n  \n def astimezone(self,tz=None ):\n  if tz is None :\n   tz=self._local_timezone()\n  elif not isinstance(tz,tzinfo):\n   raise TypeError(\"tz argument must be an instance of tzinfo\")\n   \n  mytz=self.tzinfo\n  if mytz is None :\n   mytz=self._local_timezone()\n   myoffset=mytz.utcoffset(self)\n  else :\n   myoffset=mytz.utcoffset(self)\n   if myoffset is None :\n    mytz=self.replace(tzinfo=None )._local_timezone()\n    myoffset=mytz.utcoffset(self)\n    \n  if tz is mytz:\n   return self\n   \n   \n  utc=(self -myoffset).replace(tzinfo=tz)\n  \n  \n  return tz.fromutc(utc)\n  \n  \n  \n def ctime(self):\n  ''\n  weekday=self.toordinal()%7 or 7\n  return \"%s %s %2d %02d:%02d:%02d %04d\"%(\n  _DAYNAMES[weekday],\n  _MONTHNAMES[self._month],\n  self._day,\n  self._hour,self._minute,self._second,\n  self._year)\n  \n def isoformat(self,sep='T',timespec='auto'):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  s=(\"%04d-%02d-%02d%c\"%(self._year,self._month,self._day,sep)+\n  _format_time(self._hour,self._minute,self._second,\n  self._microsecond,timespec))\n  \n  off=self.utcoffset()\n  tz=_format_offset(off)\n  if tz:\n   s +=tz\n   \n  return s\n  \n def __repr__(self):\n  ''\n  L=[self._year,self._month,self._day,\n  self._hour,self._minute,self._second,self._microsecond]\n  if L[-1]==0:\n   del L[-1]\n  if L[-1]==0:\n   del L[-1]\n  s=\"%s.%s(%s)\"%(self.__class__.__module__,\n  self.__class__.__qualname__,\n  \", \".join(map(str,L)))\n  if self._tzinfo is not None :\n   assert s[-1:]==\")\"\n   s=s[:-1]+\", tzinfo=%r\"%self._tzinfo+\")\"\n  if self._fold:\n   assert s[-1:]==\")\"\n   s=s[:-1]+\", fold=1)\"\n  return s\n  \n def __str__(self):\n  ''\n  return self.isoformat(sep=' ')\n  \n @classmethod\n def strptime(cls,date_string,format):\n  ''\n  import _strptime\n  return _strptime._strptime_datetime(cls,date_string,format)\n  \n def utcoffset(self):\n  ''\n  \n  if self._tzinfo is None :\n   return None\n  offset=self._tzinfo.utcoffset(self)\n  _check_utc_offset(\"utcoffset\",offset)\n  return offset\n  \n def tzname(self):\n  ''\n\n\n\n\n  \n  if self._tzinfo is None :\n   return None\n  name=self._tzinfo.tzname(self)\n  _check_tzname(name)\n  return name\n  \n def dst(self):\n  ''\n\n\n\n\n\n\n  \n  if self._tzinfo is None :\n   return None\n  offset=self._tzinfo.dst(self)\n  _check_utc_offset(\"dst\",offset)\n  return offset\n  \n  \n  \n def __eq__(self,other):\n  if isinstance(other,datetime):\n   return self._cmp(other,allow_mixed=True )==0\n  elif not isinstance(other,date):\n   return NotImplemented\n  else :\n   return False\n   \n def __le__(self,other):\n  if isinstance(other,datetime):\n   return self._cmp(other)<=0\n  elif not isinstance(other,date):\n   return NotImplemented\n  else :\n   _cmperror(self,other)\n   \n def __lt__(self,other):\n  if isinstance(other,datetime):\n   return self._cmp(other)<0\n  elif not isinstance(other,date):\n   return NotImplemented\n  else :\n   _cmperror(self,other)\n   \n def __ge__(self,other):\n  if isinstance(other,datetime):\n   return self._cmp(other)>=0\n  elif not isinstance(other,date):\n   return NotImplemented\n  else :\n   _cmperror(self,other)\n   \n def __gt__(self,other):\n  if isinstance(other,datetime):\n   return self._cmp(other)>0\n  elif not isinstance(other,date):\n   return NotImplemented\n  else :\n   _cmperror(self,other)\n   \n def _cmp(self,other,allow_mixed=False ):\n  assert isinstance(other,datetime)\n  mytz=self._tzinfo\n  ottz=other._tzinfo\n  myoff=otoff=None\n  \n  if mytz is ottz:\n   base_compare=True\n  else :\n   myoff=self.utcoffset()\n   otoff=other.utcoffset()\n   \n   if allow_mixed:\n    if myoff !=self.replace(fold=not self.fold).utcoffset():\n     return 2\n    if otoff !=other.replace(fold=not other.fold).utcoffset():\n     return 2\n   base_compare=myoff ==otoff\n   \n  if base_compare:\n   return _cmp((self._year,self._month,self._day,\n   self._hour,self._minute,self._second,\n   self._microsecond),\n   (other._year,other._month,other._day,\n   other._hour,other._minute,other._second,\n   other._microsecond))\n  if myoff is None or otoff is None :\n   if allow_mixed:\n    return 2\n   else :\n    raise TypeError(\"cannot compare naive and aware datetimes\")\n    \n  diff=self -other\n  if diff.days <0:\n   return -1\n  return diff and 1 or 0\n  \n def __add__(self,other):\n  ''\n  if not isinstance(other,timedelta):\n   return NotImplemented\n  delta=timedelta(self.toordinal(),\n  hours=self._hour,\n  minutes=self._minute,\n  seconds=self._second,\n  microseconds=self._microsecond)\n  delta +=other\n  hour,rem=divmod(delta.seconds,3600)\n  minute,second=divmod(rem,60)\n  if 0 <delta.days <=_MAXORDINAL:\n   return type(self).combine(date.fromordinal(delta.days),\n   time(hour,minute,second,\n   delta.microseconds,\n   tzinfo=self._tzinfo))\n  raise OverflowError(\"result out of range\")\n  \n __radd__=__add__\n \n def __sub__(self,other):\n  ''\n  if not isinstance(other,datetime):\n   if isinstance(other,timedelta):\n    return self+-other\n   return NotImplemented\n   \n  days1=self.toordinal()\n  days2=other.toordinal()\n  secs1=self._second+self._minute *60+self._hour *3600\n  secs2=other._second+other._minute *60+other._hour *3600\n  base=timedelta(days1 -days2,\n  secs1 -secs2,\n  self._microsecond -other._microsecond)\n  if self._tzinfo is other._tzinfo:\n   return base\n  myoff=self.utcoffset()\n  otoff=other.utcoffset()\n  if myoff ==otoff:\n   return base\n  if myoff is None or otoff is None :\n   raise TypeError(\"cannot mix naive and timezone-aware time\")\n  return base+otoff -myoff\n  \n def __hash__(self):\n  if self._hashcode ==-1:\n   if self.fold:\n    t=self.replace(fold=0)\n   else :\n    t=self\n   tzoff=t.utcoffset()\n   if tzoff is None :\n    self._hashcode=hash(t._getstate()[0])\n   else :\n    days=_ymd2ord(self.year,self.month,self.day)\n    seconds=self.hour *3600+self.minute *60+self.second\n    self._hashcode=hash(timedelta(days,seconds,self.microsecond)-tzoff)\n  return self._hashcode\n  \n  \n  \n def _getstate(self,protocol=3):\n  yhi,ylo=divmod(self._year,256)\n  us2,us3=divmod(self._microsecond,256)\n  us1,us2=divmod(us2,256)\n  m=self._month\n  if self._fold and protocol >3:\n   m +=128\n  basestate=bytes([yhi,ylo,m,self._day,\n  self._hour,self._minute,self._second,\n  us1,us2,us3])\n  if self._tzinfo is None :\n   return (basestate,)\n  else :\n   return (basestate,self._tzinfo)\n   \n def __setstate(self,string,tzinfo):\n  if tzinfo is not None and not isinstance(tzinfo,_tzinfo_class):\n   raise TypeError(\"bad tzinfo state arg\")\n  (yhi,ylo,m,self._day,self._hour,\n  self._minute,self._second,us1,us2,us3)=string\n  if m >127:\n   self._fold=1\n   self._month=m -128\n  else :\n   self._fold=0\n   self._month=m\n  self._year=yhi *256+ylo\n  self._microsecond=(((us1 <<8)|us2)<<8)|us3\n  self._tzinfo=tzinfo\n  \n def __reduce_ex__(self,protocol):\n  return (self.__class__,self._getstate(protocol))\n  \n def __reduce__(self):\n  return self.__reduce_ex__(2)\n  \n  \ndatetime.min=datetime(1,1,1)\ndatetime.max=datetime(9999,12,31,23,59,59,999999)\ndatetime.resolution=timedelta(microseconds=1)\n\n\ndef _isoweek1monday(year):\n\n\n THURSDAY=3\n firstday=_ymd2ord(year,1,1)\n firstweekday=(firstday+6)%7\n week1monday=firstday -firstweekday\n if firstweekday >THURSDAY:\n  week1monday +=7\n return week1monday\n \n \nclass timezone(tzinfo):\n __slots__='_offset','_name'\n \n \n _Omitted=object()\n def __new__(cls,offset,name=_Omitted):\n  if not isinstance(offset,timedelta):\n   raise TypeError(\"offset must be a timedelta\")\n  if name is cls._Omitted:\n   if not offset:\n    return cls.utc\n   name=None\n  elif not isinstance(name,str):\n   raise TypeError(\"name must be a string\")\n  if not cls._minoffset <=offset <=cls._maxoffset:\n   raise ValueError(\"offset must be a timedelta \"\n   \"strictly between -timedelta(hours=24) and \"\n   \"timedelta(hours=24).\")\n  return cls._create(offset,name)\n  \n @classmethod\n def _create(cls,offset,name=None ):\n  self=tzinfo.__new__(cls)\n  self._offset=offset\n  self._name=name\n  return self\n  \n def __getinitargs__(self):\n  ''\n  if self._name is None :\n   return (self._offset,)\n  return (self._offset,self._name)\n  \n def __eq__(self,other):\n  if isinstance(other,timezone):\n   return self._offset ==other._offset\n  return NotImplemented\n  \n def __hash__(self):\n  return hash(self._offset)\n  \n def __repr__(self):\n  ''\n\n\n\n\n\n\n\n  \n  if self is self.utc:\n   return 'datetime.timezone.utc'\n  if self._name is None :\n   return \"%s.%s(%r)\"%(self.__class__.__module__,\n   self.__class__.__qualname__,\n   self._offset)\n  return \"%s.%s(%r, %r)\"%(self.__class__.__module__,\n  self.__class__.__qualname__,\n  self._offset,self._name)\n  \n def __str__(self):\n  return self.tzname(None )\n  \n def utcoffset(self,dt):\n  if isinstance(dt,datetime)or dt is None :\n   return self._offset\n  raise TypeError(\"utcoffset() argument must be a datetime instance\"\n  \" or None\")\n  \n def tzname(self,dt):\n  if isinstance(dt,datetime)or dt is None :\n   if self._name is None :\n    return self._name_from_offset(self._offset)\n   return self._name\n  raise TypeError(\"tzname() argument must be a datetime instance\"\n  \" or None\")\n  \n def dst(self,dt):\n  if isinstance(dt,datetime)or dt is None :\n   return None\n  raise TypeError(\"dst() argument must be a datetime instance\"\n  \" or None\")\n  \n def fromutc(self,dt):\n  if isinstance(dt,datetime):\n   if dt.tzinfo is not self:\n    raise ValueError(\"fromutc: dt.tzinfo \"\n    \"is not self\")\n   return dt+self._offset\n  raise TypeError(\"fromutc() argument must be a datetime instance\"\n  \" or None\")\n  \n _maxoffset=timedelta(hours=24,microseconds=-1)\n _minoffset=-_maxoffset\n \n @staticmethod\n def _name_from_offset(delta):\n  if not delta:\n   return 'UTC'\n  if delta <timedelta(0):\n   sign='-'\n   delta=-delta\n  else :\n   sign='+'\n  hours,rest=divmod(delta,timedelta(hours=1))\n  minutes,rest=divmod(rest,timedelta(minutes=1))\n  seconds=rest.seconds\n  microseconds=rest.microseconds\n  if microseconds:\n   return (f'UTC{sign}{hours:02d}:{minutes:02d}:{seconds:02d}'\n   f'.{microseconds:06d}')\n  if seconds:\n   return f'UTC{sign}{hours:02d}:{minutes:02d}:{seconds:02d}'\n  return f'UTC{sign}{hours:02d}:{minutes:02d}'\n  \ntimezone.utc=timezone._create(timedelta(0))\n\n\n\ntimezone.min=timezone._create(-timedelta(hours=23,minutes=59))\ntimezone.max=timezone._create(timedelta(hours=23,minutes=59))\n_EPOCH=datetime(1970,1,1,tzinfo=timezone.utc)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ntry :\n from _datetime import *\nexcept ImportError:\n pass\nelse :\n\n del (_DAYNAMES,_DAYS_BEFORE_MONTH,_DAYS_IN_MONTH,_DI100Y,_DI400Y,\n _DI4Y,_EPOCH,_MAXORDINAL,_MONTHNAMES,_build_struct_time,\n _check_date_fields,_check_int_field,_check_time_fields,\n _check_tzinfo_arg,_check_tzname,_check_utc_offset,_cmp,_cmperror,\n _date_class,_days_before_month,_days_before_year,_days_in_month,\n _format_time,_format_offset,_is_leap,_isoweek1monday,_math,\n _ord2ymd,_time,_time_class,_tzinfo_class,_wrap_strftime,_ymd2ord,\n _divide_and_round,_parse_isoformat_date,_parse_isoformat_time,\n _parse_hh_mm_ss_ff,_IsoCalendarDate)\n \n \n \n \n from _datetime import __doc__\n", ["_datetime", "_strptime", "math", "sys", "time", "warnings"]],
     "decimal": [".py", "\ntry :\n from _decimal import *\n from _decimal import __doc__\n from _decimal import __version__\n from _decimal import __libmpdec_version__\nexcept ImportError:\n from _pydecimal import *\n from _pydecimal import __doc__\n from _pydecimal import __version__\n from _pydecimal import __libmpdec_version__\n", ["_decimal", "_pydecimal"]],
     "difflib": [".py", "''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n__all__=['get_close_matches','ndiff','restore','SequenceMatcher',\n'Differ','IS_CHARACTER_JUNK','IS_LINE_JUNK','context_diff',\n'unified_diff','diff_bytes','HtmlDiff','Match']\n\nfrom heapq import nlargest as _nlargest\nfrom collections import namedtuple as _namedtuple\nfrom types import GenericAlias\n\nMatch=_namedtuple('Match','a b size')\n\ndef _calculate_ratio(matches,length):\n if length:\n  return 2.0 *matches /length\n return 1.0\n \nclass SequenceMatcher:\n\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n def __init__(self,isjunk=None ,a='',b='',autojunk=True ):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  self.isjunk=isjunk\n  self.a=self.b=None\n  self.autojunk=autojunk\n  self.set_seqs(a,b)\n  \n def set_seqs(self,a,b):\n  ''\n\n\n\n\n\n  \n  \n  self.set_seq1(a)\n  self.set_seq2(b)\n  \n def set_seq1(self,a):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  \n  if a is self.a:\n   return\n  self.a=a\n  self.matching_blocks=self.opcodes=None\n  \n def set_seq2(self,b):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  \n  if b is self.b:\n   return\n  self.b=b\n  self.matching_blocks=self.opcodes=None\n  self.fullbcount=None\n  self.__chain_b()\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n def __chain_b(self):\n \n \n \n \n \n \n \n \n \n \n  b=self.b\n  self.b2j=b2j={}\n  \n  for i,elt in enumerate(b):\n   indices=b2j.setdefault(elt,[])\n   indices.append(i)\n   \n   \n  self.bjunk=junk=set()\n  isjunk=self.isjunk\n  if isjunk:\n   for elt in b2j.keys():\n    if isjunk(elt):\n     junk.add(elt)\n   for elt in junk:\n    del b2j[elt]\n    \n    \n  self.bpopular=popular=set()\n  n=len(b)\n  if self.autojunk and n >=200:\n   ntest=n //100+1\n   for elt,idxs in b2j.items():\n    if len(idxs)>ntest:\n     popular.add(elt)\n   for elt in popular:\n    del b2j[elt]\n    \n def find_longest_match(self,alo=0,ahi=None ,blo=0,bhi=None ):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  a,b,b2j,isbjunk=self.a,self.b,self.b2j,self.bjunk.__contains__\n  if ahi is None :\n   ahi=len(a)\n  if bhi is None :\n   bhi=len(b)\n  besti,bestj,bestsize=alo,blo,0\n  \n  \n  \n  j2len={}\n  nothing=[]\n  for i in range(alo,ahi):\n  \n  \n   j2lenget=j2len.get\n   newj2len={}\n   for j in b2j.get(a[i],nothing):\n   \n    if j <blo:\n     continue\n    if j >=bhi:\n     break\n    k=newj2len[j]=j2lenget(j -1,0)+1\n    if k >bestsize:\n     besti,bestj,bestsize=i -k+1,j -k+1,k\n   j2len=newj2len\n   \n   \n   \n   \n   \n  while besti >alo and bestj >blo and\\\n  not isbjunk(b[bestj -1])and\\\n  a[besti -1]==b[bestj -1]:\n   besti,bestj,bestsize=besti -1,bestj -1,bestsize+1\n  while besti+bestsize <ahi and bestj+bestsize <bhi and\\\n  not isbjunk(b[bestj+bestsize])and\\\n  a[besti+bestsize]==b[bestj+bestsize]:\n   bestsize +=1\n   \n   \n   \n   \n   \n   \n   \n   \n  while besti >alo and bestj >blo and\\\n  isbjunk(b[bestj -1])and\\\n  a[besti -1]==b[bestj -1]:\n   besti,bestj,bestsize=besti -1,bestj -1,bestsize+1\n  while besti+bestsize <ahi and bestj+bestsize <bhi and\\\n  isbjunk(b[bestj+bestsize])and\\\n  a[besti+bestsize]==b[bestj+bestsize]:\n   bestsize=bestsize+1\n   \n  return Match(besti,bestj,bestsize)\n  \n def get_matching_blocks(self):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  \n  if self.matching_blocks is not None :\n   return self.matching_blocks\n  la,lb=len(self.a),len(self.b)\n  \n  \n  \n  \n  \n  \n  \n  queue=[(0,la,0,lb)]\n  matching_blocks=[]\n  while queue:\n   alo,ahi,blo,bhi=queue.pop()\n   i,j,k=x=self.find_longest_match(alo,ahi,blo,bhi)\n   \n   \n   \n   if k:\n    matching_blocks.append(x)\n    if alo <i and blo <j:\n     queue.append((alo,i,blo,j))\n    if i+k <ahi and j+k <bhi:\n     queue.append((i+k,ahi,j+k,bhi))\n  matching_blocks.sort()\n  \n  \n  \n  \n  i1=j1=k1=0\n  non_adjacent=[]\n  for i2,j2,k2 in matching_blocks:\n  \n   if i1+k1 ==i2 and j1+k1 ==j2:\n   \n   \n   \n    k1 +=k2\n   else :\n   \n   \n   \n    if k1:\n     non_adjacent.append((i1,j1,k1))\n    i1,j1,k1=i2,j2,k2\n  if k1:\n   non_adjacent.append((i1,j1,k1))\n   \n  non_adjacent.append((la,lb,0))\n  self.matching_blocks=list(map(Match._make,non_adjacent))\n  return self.matching_blocks\n  \n def get_opcodes(self):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  \n  if self.opcodes is not None :\n   return self.opcodes\n  i=j=0\n  self.opcodes=answer=[]\n  for ai,bj,size in self.get_matching_blocks():\n  \n  \n  \n  \n  \n   tag=''\n   if i <ai and j <bj:\n    tag='replace'\n   elif i <ai:\n    tag='delete'\n   elif j <bj:\n    tag='insert'\n   if tag:\n    answer.append((tag,i,ai,j,bj))\n   i,j=ai+size,bj+size\n   \n   \n   if size:\n    answer.append(('equal',ai,i,bj,j))\n  return answer\n  \n def get_grouped_opcodes(self,n=3):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  \n  codes=self.get_opcodes()\n  if not codes:\n   codes=[(\"equal\",0,1,0,1)]\n   \n  if codes[0][0]=='equal':\n   tag,i1,i2,j1,j2=codes[0]\n   codes[0]=tag,max(i1,i2 -n),i2,max(j1,j2 -n),j2\n  if codes[-1][0]=='equal':\n   tag,i1,i2,j1,j2=codes[-1]\n   codes[-1]=tag,i1,min(i2,i1+n),j1,min(j2,j1+n)\n   \n  nn=n+n\n  group=[]\n  for tag,i1,i2,j1,j2 in codes:\n  \n  \n   if tag =='equal'and i2 -i1 >nn:\n    group.append((tag,i1,min(i2,i1+n),j1,min(j2,j1+n)))\n    yield group\n    group=[]\n    i1,j1=max(i1,i2 -n),max(j1,j2 -n)\n   group.append((tag,i1,i2,j1,j2))\n  if group and not (len(group)==1 and group[0][0]=='equal'):\n   yield group\n   \n def ratio(self):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  \n  matches=sum(triple[-1]for triple in self.get_matching_blocks())\n  return _calculate_ratio(matches,len(self.a)+len(self.b))\n  \n def quick_ratio(self):\n  ''\n\n\n\n  \n  \n  \n  \n  \n  if self.fullbcount is None :\n   self.fullbcount=fullbcount={}\n   for elt in self.b:\n    fullbcount[elt]=fullbcount.get(elt,0)+1\n  fullbcount=self.fullbcount\n  \n  \n  avail={}\n  availhas,matches=avail.__contains__,0\n  for elt in self.a:\n   if availhas(elt):\n    numb=avail[elt]\n   else :\n    numb=fullbcount.get(elt,0)\n   avail[elt]=numb -1\n   if numb >0:\n    matches=matches+1\n  return _calculate_ratio(matches,len(self.a)+len(self.b))\n  \n def real_quick_ratio(self):\n  ''\n\n\n\n  \n  \n  la,lb=len(self.a),len(self.b)\n  \n  \n  return _calculate_ratio(min(la,lb),la+lb)\n  \n __class_getitem__=classmethod(GenericAlias)\n \n \ndef get_close_matches(word,possibilities,n=3,cutoff=0.6):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n if not n >0:\n  raise ValueError(\"n must be > 0: %r\"%(n,))\n if not 0.0 <=cutoff <=1.0:\n  raise ValueError(\"cutoff must be in [0.0, 1.0]: %r\"%(cutoff,))\n result=[]\n s=SequenceMatcher()\n s.set_seq2(word)\n for x in possibilities:\n  s.set_seq1(x)\n  if s.real_quick_ratio()>=cutoff and\\\n  s.quick_ratio()>=cutoff and\\\n  s.ratio()>=cutoff:\n   result.append((s.ratio(),x))\n   \n   \n result=_nlargest(n,result)\n \n return [x for score,x in result]\n \n \ndef _keep_original_ws(s,tag_s):\n ''\n return ''.join(\n c if tag_c ==\" \"and c.isspace()else tag_c\n for c,tag_c in zip(s,tag_s)\n )\n \n \n \nclass Differ:\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n def __init__(self,linejunk=None ,charjunk=None ):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  \n  self.linejunk=linejunk\n  self.charjunk=charjunk\n  \n def compare(self,a,b):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  \n  cruncher=SequenceMatcher(self.linejunk,a,b)\n  for tag,alo,ahi,blo,bhi in cruncher.get_opcodes():\n   if tag =='replace':\n    g=self._fancy_replace(a,alo,ahi,b,blo,bhi)\n   elif tag =='delete':\n    g=self._dump('-',a,alo,ahi)\n   elif tag =='insert':\n    g=self._dump('+',b,blo,bhi)\n   elif tag =='equal':\n    g=self._dump(' ',a,alo,ahi)\n   else :\n    raise ValueError('unknown tag %r'%(tag,))\n    \n   yield from g\n   \n def _dump(self,tag,x,lo,hi):\n  ''\n  for i in range(lo,hi):\n   yield '%s %s'%(tag,x[i])\n   \n def _plain_replace(self,a,alo,ahi,b,blo,bhi):\n  assert alo <ahi and blo <bhi\n  \n  \n  if bhi -blo <ahi -alo:\n   first=self._dump('+',b,blo,bhi)\n   second=self._dump('-',a,alo,ahi)\n  else :\n   first=self._dump('-',a,alo,ahi)\n   second=self._dump('+',b,blo,bhi)\n   \n  for g in first,second:\n   yield from g\n   \n def _fancy_replace(self,a,alo,ahi,b,blo,bhi):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  \n  \n  \n  best_ratio,cutoff=0.74,0.75\n  cruncher=SequenceMatcher(self.charjunk)\n  eqi,eqj=None ,None\n  \n  \n  \n  \n  for j in range(blo,bhi):\n   bj=b[j]\n   cruncher.set_seq2(bj)\n   for i in range(alo,ahi):\n    ai=a[i]\n    if ai ==bj:\n     if eqi is None :\n      eqi,eqj=i,j\n     continue\n    cruncher.set_seq1(ai)\n    \n    \n    \n    \n    \n    \n    if cruncher.real_quick_ratio()>best_ratio and\\\n    cruncher.quick_ratio()>best_ratio and\\\n    cruncher.ratio()>best_ratio:\n     best_ratio,best_i,best_j=cruncher.ratio(),i,j\n  if best_ratio <cutoff:\n  \n   if eqi is None :\n   \n    yield from self._plain_replace(a,alo,ahi,b,blo,bhi)\n    return\n    \n   best_i,best_j,best_ratio=eqi,eqj,1.0\n  else :\n  \n   eqi=None\n   \n   \n   \n   \n   \n  yield from self._fancy_helper(a,alo,best_i,b,blo,best_j)\n  \n  \n  aelt,belt=a[best_i],b[best_j]\n  if eqi is None :\n  \n   atags=btags=\"\"\n   cruncher.set_seqs(aelt,belt)\n   for tag,ai1,ai2,bj1,bj2 in cruncher.get_opcodes():\n    la,lb=ai2 -ai1,bj2 -bj1\n    if tag =='replace':\n     atags +='^'*la\n     btags +='^'*lb\n    elif tag =='delete':\n     atags +='-'*la\n    elif tag =='insert':\n     btags +='+'*lb\n    elif tag =='equal':\n     atags +=' '*la\n     btags +=' '*lb\n    else :\n     raise ValueError('unknown tag %r'%(tag,))\n   yield from self._qformat(aelt,belt,atags,btags)\n  else :\n  \n   yield '  '+aelt\n   \n   \n  yield from self._fancy_helper(a,best_i+1,ahi,b,best_j+1,bhi)\n  \n def _fancy_helper(self,a,alo,ahi,b,blo,bhi):\n  g=[]\n  if alo <ahi:\n   if blo <bhi:\n    g=self._fancy_replace(a,alo,ahi,b,blo,bhi)\n   else :\n    g=self._dump('-',a,alo,ahi)\n  elif blo <bhi:\n   g=self._dump('+',b,blo,bhi)\n   \n  yield from g\n  \n def _qformat(self,aline,bline,atags,btags):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  atags=_keep_original_ws(aline,atags).rstrip()\n  btags=_keep_original_ws(bline,btags).rstrip()\n  \n  yield \"- \"+aline\n  if atags:\n   yield f\"? {atags}\\n\"\n   \n  yield \"+ \"+bline\n  if btags:\n   yield f\"? {btags}\\n\"\n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \nimport re\n\ndef IS_LINE_JUNK(line,pat=re.compile(r\"\\s*(?:#\\s*)?$\").match):\n ''\n\n\n\n\n\n\n\n\n\n\n \n \n return pat(line)is not None\n \ndef IS_CHARACTER_JUNK(ch,ws=\" \\t\"):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n return ch in ws\n \n \n \n \n \n \ndef _format_range_unified(start,stop):\n ''\n \n beginning=start+1\n length=stop -start\n if length ==1:\n  return '{}'.format(beginning)\n if not length:\n  beginning -=1\n return '{},{}'.format(beginning,length)\n \ndef unified_diff(a,b,fromfile='',tofile='',fromfiledate='',\ntofiledate='',n=3,lineterm='\\n'):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n _check_types(a,b,fromfile,tofile,fromfiledate,tofiledate,lineterm)\n started=False\n for group in SequenceMatcher(None ,a,b).get_grouped_opcodes(n):\n  if not started:\n   started=True\n   fromdate='\\t{}'.format(fromfiledate)if fromfiledate else ''\n   todate='\\t{}'.format(tofiledate)if tofiledate else ''\n   yield '--- {}{}{}'.format(fromfile,fromdate,lineterm)\n   yield '+++ {}{}{}'.format(tofile,todate,lineterm)\n   \n  first,last=group[0],group[-1]\n  file1_range=_format_range_unified(first[1],last[2])\n  file2_range=_format_range_unified(first[3],last[4])\n  yield '@@ -{} +{} @@{}'.format(file1_range,file2_range,lineterm)\n  \n  for tag,i1,i2,j1,j2 in group:\n   if tag =='equal':\n    for line in a[i1:i2]:\n     yield ' '+line\n    continue\n   if tag in {'replace','delete'}:\n    for line in a[i1:i2]:\n     yield '-'+line\n   if tag in {'replace','insert'}:\n    for line in b[j1:j2]:\n     yield '+'+line\n     \n     \n     \n     \n     \n     \ndef _format_range_context(start,stop):\n ''\n \n beginning=start+1\n length=stop -start\n if not length:\n  beginning -=1\n if length <=1:\n  return '{}'.format(beginning)\n return '{},{}'.format(beginning,beginning+length -1)\n \n \ndef context_diff(a,b,fromfile='',tofile='',\nfromfiledate='',tofiledate='',n=3,lineterm='\\n'):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n _check_types(a,b,fromfile,tofile,fromfiledate,tofiledate,lineterm)\n prefix=dict(insert='+ ',delete='- ',replace='! ',equal='  ')\n started=False\n for group in SequenceMatcher(None ,a,b).get_grouped_opcodes(n):\n  if not started:\n   started=True\n   fromdate='\\t{}'.format(fromfiledate)if fromfiledate else ''\n   todate='\\t{}'.format(tofiledate)if tofiledate else ''\n   yield '*** {}{}{}'.format(fromfile,fromdate,lineterm)\n   yield '--- {}{}{}'.format(tofile,todate,lineterm)\n   \n  first,last=group[0],group[-1]\n  yield '***************'+lineterm\n  \n  file1_range=_format_range_context(first[1],last[2])\n  yield '*** {} ****{}'.format(file1_range,lineterm)\n  \n  if any(tag in {'replace','delete'}for tag,_,_,_,_ in group):\n   for tag,i1,i2,_,_ in group:\n    if tag !='insert':\n     for line in a[i1:i2]:\n      yield prefix[tag]+line\n      \n  file2_range=_format_range_context(first[3],last[4])\n  yield '--- {} ----{}'.format(file2_range,lineterm)\n  \n  if any(tag in {'replace','insert'}for tag,_,_,_,_ in group):\n   for tag,_,_,j1,j2 in group:\n    if tag !='delete':\n     for line in b[j1:j2]:\n      yield prefix[tag]+line\n      \ndef _check_types(a,b,*args):\n\n\n\n\n\n\n if a and not isinstance(a[0],str):\n  raise TypeError('lines to compare must be str, not %s (%r)'%\n  (type(a[0]).__name__,a[0]))\n if b and not isinstance(b[0],str):\n  raise TypeError('lines to compare must be str, not %s (%r)'%\n  (type(b[0]).__name__,b[0]))\n for arg in args:\n  if not isinstance(arg,str):\n   raise TypeError('all arguments must be str, not: %r'%(arg,))\n   \ndef diff_bytes(dfunc,a,b,fromfile=b'',tofile=b'',\nfromfiledate=b'',tofiledate=b'',n=3,lineterm=b'\\n'):\n ''\n\n\n\n\n\n\n\n \n def decode(s):\n  try :\n   return s.decode('ascii','surrogateescape')\n  except AttributeError as err:\n   msg=('all arguments must be bytes, not %s (%r)'%\n   (type(s).__name__,s))\n   raise TypeError(msg)from err\n a=list(map(decode,a))\n b=list(map(decode,b))\n fromfile=decode(fromfile)\n tofile=decode(tofile)\n fromfiledate=decode(fromfiledate)\n tofiledate=decode(tofiledate)\n lineterm=decode(lineterm)\n \n lines=dfunc(a,b,fromfile,tofile,fromfiledate,tofiledate,n,lineterm)\n for line in lines:\n  yield line.encode('ascii','surrogateescape')\n  \ndef ndiff(a,b,linejunk=None ,charjunk=IS_CHARACTER_JUNK):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n return Differ(linejunk,charjunk).compare(a,b)\n \ndef _mdiff(fromlines,tolines,context=None ,linejunk=None ,\ncharjunk=IS_CHARACTER_JUNK):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n import re\n \n \n change_re=re.compile(r'(\\++|\\-+|\\^+)')\n \n \n diff_lines_iterator=ndiff(fromlines,tolines,linejunk,charjunk)\n \n def _make_line(lines,format_key,side,num_lines=[0,0]):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  num_lines[side]+=1\n  \n  \n  if format_key is None :\n   return (num_lines[side],lines.pop(0)[2:])\n   \n  if format_key =='?':\n   text,markers=lines.pop(0),lines.pop(0)\n   \n   sub_info=[]\n   def record_sub_info(match_object,sub_info=sub_info):\n    sub_info.append([match_object.group(1)[0],match_object.span()])\n    return match_object.group(1)\n   change_re.sub(record_sub_info,markers)\n   \n   \n   for key,(begin,end)in reversed(sub_info):\n    text=text[0:begin]+'\\0'+key+text[begin:end]+'\\1'+text[end:]\n   text=text[2:]\n   \n  else :\n   text=lines.pop(0)[2:]\n   \n   \n   if not text:\n    text=' '\n    \n   text='\\0'+format_key+text+'\\1'\n   \n   \n   \n  return (num_lines[side],text)\n  \n def _line_iterator():\n  ''\n\n\n\n\n\n\n\n\n\n\n\n  \n  lines=[]\n  num_blanks_pending,num_blanks_to_yield=0,0\n  while True :\n  \n  \n  \n   while len(lines)<4:\n    lines.append(next(diff_lines_iterator,'X'))\n   s=''.join([line[0]for line in lines])\n   if s.startswith('X'):\n   \n   \n   \n    num_blanks_to_yield=num_blanks_pending\n   elif s.startswith('-?+?'):\n   \n    yield _make_line(lines,'?',0),_make_line(lines,'?',1),True\n    continue\n   elif s.startswith('--++'):\n   \n   \n    num_blanks_pending -=1\n    yield _make_line(lines,'-',0),None ,True\n    continue\n   elif s.startswith(('--?+','--+','- ')):\n   \n   \n    from_line,to_line=_make_line(lines,'-',0),None\n    num_blanks_to_yield,num_blanks_pending=num_blanks_pending -1,0\n   elif s.startswith('-+?'):\n   \n    yield _make_line(lines,None ,0),_make_line(lines,'?',1),True\n    continue\n   elif s.startswith('-?+'):\n   \n    yield _make_line(lines,'?',0),_make_line(lines,None ,1),True\n    continue\n   elif s.startswith('-'):\n   \n    num_blanks_pending -=1\n    yield _make_line(lines,'-',0),None ,True\n    continue\n   elif s.startswith('+--'):\n   \n   \n    num_blanks_pending +=1\n    yield None ,_make_line(lines,'+',1),True\n    continue\n   elif s.startswith(('+ ','+-')):\n   \n    from_line,to_line=None ,_make_line(lines,'+',1)\n    num_blanks_to_yield,num_blanks_pending=num_blanks_pending+1,0\n   elif s.startswith('+'):\n   \n    num_blanks_pending +=1\n    yield None ,_make_line(lines,'+',1),True\n    continue\n   elif s.startswith(' '):\n   \n    yield _make_line(lines[:],None ,0),_make_line(lines,None ,1),False\n    continue\n    \n    \n   while (num_blanks_to_yield <0):\n    num_blanks_to_yield +=1\n    yield None ,('','\\n'),True\n   while (num_blanks_to_yield >0):\n    num_blanks_to_yield -=1\n    yield ('','\\n'),None ,True\n   if s.startswith('X'):\n    return\n   else :\n    yield from_line,to_line,True\n    \n def _line_pair_iterator():\n  ''\n\n\n\n\n\n\n\n\n\n\n  \n  line_iterator=_line_iterator()\n  fromlines,tolines=[],[]\n  while True :\n  \n   while (len(fromlines)==0 or len(tolines)==0):\n    try :\n     from_line,to_line,found_diff=next(line_iterator)\n    except StopIteration:\n     return\n    if from_line is not None :\n     fromlines.append((from_line,found_diff))\n    if to_line is not None :\n     tolines.append((to_line,found_diff))\n     \n   from_line,fromDiff=fromlines.pop(0)\n   to_line,to_diff=tolines.pop(0)\n   yield (from_line,to_line,fromDiff or to_diff)\n   \n   \n   \n line_pair_iterator=_line_pair_iterator()\n if context is None :\n  yield from line_pair_iterator\n  \n  \n else :\n  context +=1\n  lines_to_write=0\n  while True :\n  \n  \n  \n   index,contextLines=0,[None ]*(context)\n   found_diff=False\n   while (found_diff is False ):\n    try :\n     from_line,to_line,found_diff=next(line_pair_iterator)\n    except StopIteration:\n     return\n    i=index %context\n    contextLines[i]=(from_line,to_line,found_diff)\n    index +=1\n    \n    \n   if index >context:\n    yield None ,None ,None\n    lines_to_write=context\n   else :\n    lines_to_write=index\n    index=0\n   while (lines_to_write):\n    i=index %context\n    index +=1\n    yield contextLines[i]\n    lines_to_write -=1\n    \n   lines_to_write=context -1\n   try :\n    while (lines_to_write):\n     from_line,to_line,found_diff=next(line_pair_iterator)\n     \n     if found_diff:\n      lines_to_write=context -1\n     else :\n      lines_to_write -=1\n     yield from_line,to_line,found_diff\n   except StopIteration:\n   \n    return\n    \n    \n_file_template=\"\"\"\n<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\"\n          \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\n\n<html>\n\n<head>\n    <meta http-equiv=\"Content-Type\"\n          content=\"text/html; charset=%(charset)s\" />\n    <title></title>\n    <style type=\"text/css\">%(styles)s\n    </style>\n</head>\n\n<body>\n    %(table)s%(legend)s\n</body>\n\n</html>\"\"\"\n\n_styles=\"\"\"\n        table.diff {font-family:Courier; border:medium;}\n        .diff_header {background-color:#e0e0e0}\n        td.diff_header {text-align:right}\n        .diff_next {background-color:#c0c0c0}\n        .diff_add {background-color:#aaffaa}\n        .diff_chg {background-color:#ffff77}\n        .diff_sub {background-color:#ffaaaa}\"\"\"\n\n_table_template=\"\"\"\n    <table class=\"diff\" id=\"difflib_chg_%(prefix)s_top\"\n           cellspacing=\"0\" cellpadding=\"0\" rules=\"groups\" >\n        <colgroup></colgroup> <colgroup></colgroup> <colgroup></colgroup>\n        <colgroup></colgroup> <colgroup></colgroup> <colgroup></colgroup>\n        %(header_row)s\n        <tbody>\n%(data_rows)s        </tbody>\n    </table>\"\"\"\n\n_legend=\"\"\"\n    <table class=\"diff\" summary=\"Legends\">\n        <tr> <th colspan=\"2\"> Legends </th> </tr>\n        <tr> <td> <table border=\"\" summary=\"Colors\">\n                      <tr><th> Colors </th> </tr>\n                      <tr><td class=\"diff_add\">&nbsp;Added&nbsp;</td></tr>\n                      <tr><td class=\"diff_chg\">Changed</td> </tr>\n                      <tr><td class=\"diff_sub\">Deleted</td> </tr>\n                  </table></td>\n             <td> <table border=\"\" summary=\"Links\">\n                      <tr><th colspan=\"2\"> Links </th> </tr>\n                      <tr><td>(f)irst change</td> </tr>\n                      <tr><td>(n)ext change</td> </tr>\n                      <tr><td>(t)op</td> </tr>\n                  </table></td> </tr>\n    </table>\"\"\"\n\nclass HtmlDiff(object):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n _file_template=_file_template\n _styles=_styles\n _table_template=_table_template\n _legend=_legend\n _default_prefix=0\n \n def __init__(self,tabsize=8,wrapcolumn=None ,linejunk=None ,\n charjunk=IS_CHARACTER_JUNK):\n  ''\n\n\n\n\n\n\n\n\n  \n  self._tabsize=tabsize\n  self._wrapcolumn=wrapcolumn\n  self._linejunk=linejunk\n  self._charjunk=charjunk\n  \n def make_file(self,fromlines,tolines,fromdesc='',todesc='',\n context=False ,numlines=5,*,charset='utf-8'):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  \n  return (self._file_template %dict(\n  styles=self._styles,\n  legend=self._legend,\n  table=self.make_table(fromlines,tolines,fromdesc,todesc,\n  context=context,numlines=numlines),\n  charset=charset\n  )).encode(charset,'xmlcharrefreplace').decode(charset)\n  \n def _tab_newline_replace(self,fromlines,tolines):\n  ''\n\n\n\n\n\n\n\n  \n  def expand_tabs(line):\n  \n   line=line.replace(' ','\\0')\n   \n   line=line.expandtabs(self._tabsize)\n   \n   \n   line=line.replace(' ','\\t')\n   return line.replace('\\0',' ').rstrip('\\n')\n  fromlines=[expand_tabs(line)for line in fromlines]\n  tolines=[expand_tabs(line)for line in tolines]\n  return fromlines,tolines\n  \n def _split_line(self,data_list,line_num,text):\n  ''\n\n\n\n\n\n\n  \n  \n  if not line_num:\n   data_list.append((line_num,text))\n   return\n   \n   \n  size=len(text)\n  max=self._wrapcolumn\n  if (size <=max)or ((size -(text.count('\\0')*3))<=max):\n   data_list.append((line_num,text))\n   return\n   \n   \n   \n  i=0\n  n=0\n  mark=''\n  while n <max and i <size:\n   if text[i]=='\\0':\n    i +=1\n    mark=text[i]\n    i +=1\n   elif text[i]=='\\1':\n    i +=1\n    mark=''\n   else :\n    i +=1\n    n +=1\n    \n    \n  line1=text[:i]\n  line2=text[i:]\n  \n  \n  \n  \n  if mark:\n   line1=line1+'\\1'\n   line2='\\0'+mark+line2\n   \n   \n  data_list.append((line_num,line1))\n  \n  \n  self._split_line(data_list,'>',line2)\n  \n def _line_wrapper(self,diffs):\n  ''\n  \n  \n  for fromdata,todata,flag in diffs:\n  \n   if flag is None :\n    yield fromdata,todata,flag\n    continue\n   (fromline,fromtext),(toline,totext)=fromdata,todata\n   \n   \n   fromlist,tolist=[],[]\n   self._split_line(fromlist,fromline,fromtext)\n   self._split_line(tolist,toline,totext)\n   \n   \n   while fromlist or tolist:\n    if fromlist:\n     fromdata=fromlist.pop(0)\n    else :\n     fromdata=('',' ')\n    if tolist:\n     todata=tolist.pop(0)\n    else :\n     todata=('',' ')\n    yield fromdata,todata,flag\n    \n def _collect_lines(self,diffs):\n  ''\n\n\n\n  \n  \n  fromlist,tolist,flaglist=[],[],[]\n  \n  for fromdata,todata,flag in diffs:\n   try :\n   \n    fromlist.append(self._format_line(0,flag,*fromdata))\n    tolist.append(self._format_line(1,flag,*todata))\n   except TypeError:\n   \n    fromlist.append(None )\n    tolist.append(None )\n   flaglist.append(flag)\n  return fromlist,tolist,flaglist\n  \n def _format_line(self,side,flag,linenum,text):\n  ''\n\n\n\n\n\n  \n  try :\n   linenum='%d'%linenum\n   id=' id=\"%s%s\"'%(self._prefix[side],linenum)\n  except TypeError:\n  \n   id=''\n   \n  text=text.replace(\"&\",\"&amp;\").replace(\">\",\"&gt;\").replace(\"<\",\"&lt;\")\n  \n  \n  text=text.replace(' ','&nbsp;').rstrip()\n  \n  return '<td class=\"diff_header\"%s>%s</td><td nowrap=\"nowrap\">%s</td>'\\\n  %(id,linenum,text)\n  \n def _make_prefix(self):\n  ''\n  \n  \n  \n  fromprefix=\"from%d_\"%HtmlDiff._default_prefix\n  toprefix=\"to%d_\"%HtmlDiff._default_prefix\n  HtmlDiff._default_prefix +=1\n  \n  self._prefix=[fromprefix,toprefix]\n  \n def _convert_flags(self,fromlist,tolist,flaglist,context,numlines):\n  ''\n  \n  \n  toprefix=self._prefix[1]\n  \n  \n  next_id=['']*len(flaglist)\n  next_href=['']*len(flaglist)\n  num_chg,in_change=0,False\n  last=0\n  for i,flag in enumerate(flaglist):\n   if flag:\n    if not in_change:\n     in_change=True\n     last=i\n     \n     \n     \n     i=max([0,i -numlines])\n     next_id[i]=' id=\"difflib_chg_%s_%d\"'%(toprefix,num_chg)\n     \n     \n     num_chg +=1\n     next_href[last]='<a href=\"#difflib_chg_%s_%d\">n</a>'%(\n     toprefix,num_chg)\n   else :\n    in_change=False\n    \n  if not flaglist:\n   flaglist=[False ]\n   next_id=['']\n   next_href=['']\n   last=0\n   if context:\n    fromlist=['<td></td><td>&nbsp;No Differences Found&nbsp;</td>']\n    tolist=fromlist\n   else :\n    fromlist=tolist=['<td></td><td>&nbsp;Empty File&nbsp;</td>']\n    \n  if not flaglist[0]:\n   next_href[0]='<a href=\"#difflib_chg_%s_0\">f</a>'%toprefix\n   \n  next_href[last]='<a href=\"#difflib_chg_%s_top\">t</a>'%(toprefix)\n  \n  return fromlist,tolist,flaglist,next_href,next_id\n  \n def make_table(self,fromlines,tolines,fromdesc='',todesc='',context=False ,\n numlines=5):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  \n  \n  \n  self._make_prefix()\n  \n  \n  \n  fromlines,tolines=self._tab_newline_replace(fromlines,tolines)\n  \n  \n  if context:\n   context_lines=numlines\n  else :\n   context_lines=None\n  diffs=_mdiff(fromlines,tolines,context_lines,linejunk=self._linejunk,\n  charjunk=self._charjunk)\n  \n  \n  if self._wrapcolumn:\n   diffs=self._line_wrapper(diffs)\n   \n   \n  fromlist,tolist,flaglist=self._collect_lines(diffs)\n  \n  \n  fromlist,tolist,flaglist,next_href,next_id=self._convert_flags(\n  fromlist,tolist,flaglist,context,numlines)\n  \n  s=[]\n  fmt='            <tr><td class=\"diff_next\"%s>%s</td>%s'+\\\n  '<td class=\"diff_next\">%s</td>%s</tr>\\n'\n  for i in range(len(flaglist)):\n   if flaglist[i]is None :\n   \n   \n    if i >0:\n     s.append('        </tbody>        \\n        <tbody>\\n')\n   else :\n    s.append(fmt %(next_id[i],next_href[i],fromlist[i],\n    next_href[i],tolist[i]))\n  if fromdesc or todesc:\n   header_row='<thead><tr>%s%s%s%s</tr></thead>'%(\n   '<th class=\"diff_next\"><br /></th>',\n   '<th colspan=\"2\" class=\"diff_header\">%s</th>'%fromdesc,\n   '<th class=\"diff_next\"><br /></th>',\n   '<th colspan=\"2\" class=\"diff_header\">%s</th>'%todesc)\n  else :\n   header_row=''\n   \n  table=self._table_template %dict(\n  data_rows=''.join(s),\n  header_row=header_row,\n  prefix=self._prefix[1])\n  \n  return table.replace('\\0+','<span class=\"diff_add\">').\\\n  replace('\\0-','<span class=\"diff_sub\">').\\\n  replace('\\0^','<span class=\"diff_chg\">').\\\n  replace('\\1','</span>').\\\n  replace('\\t','&nbsp;')\n  \ndel re\n\ndef restore(delta,which):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n try :\n  tag={1:\"- \",2:\"+ \"}[int(which)]\n except KeyError:\n  raise ValueError('unknown delta choice (must be 1 or 2): %r'\n  %which)from None\n prefixes=(\"  \",tag)\n for line in delta:\n  if line[:2]in prefixes:\n   yield line[2:]\n   \ndef _test():\n import doctest,difflib\n return doctest.testmod(difflib)\n \nif __name__ ==\"__main__\":\n _test()\n", ["collections", "difflib", "doctest", "heapq", "re", "types"]],
     "doctest": [".py", "\n\n\n\n\n\n\n\nr\"\"\"Module doctest -- a framework for running examples in docstrings.\n\nIn simplest use, end each module M to be tested with:\n\ndef _test():\n    import doctest\n    doctest.testmod()\n\nif __name__ == \"__main__\":\n    _test()\n\nThen running the module as a script will cause the examples in the\ndocstrings to get executed and verified:\n\npython M.py\n\nThis won't display anything unless an example fails, in which case the\nfailing example(s) and the cause(s) of the failure(s) are printed to stdout\n(why not stderr? because stderr is a lame hack <0.2 wink>), and the final\nline of output is \"Test failed.\".\n\nRun it with the -v switch instead:\n\npython M.py -v\n\nand a detailed report of all examples tried is printed to stdout, along\nwith assorted summaries at the end.\n\nYou can force verbose mode by passing \"verbose=True\" to testmod, or prohibit\nit by passing \"verbose=False\".  In either of those cases, sys.argv is not\nexamined by testmod.\n\nThere are a variety of other ways to run doctests, including integration\nwith the unittest framework, and support for running non-Python text\nfiles containing doctests.  There are also many ways to override parts\nof doctest's default behaviors.  See the Library Reference Manual for\ndetails.\n\"\"\"\n\n__docformat__='reStructuredText en'\n\n__all__=[\n\n'register_optionflag',\n'DONT_ACCEPT_TRUE_FOR_1',\n'DONT_ACCEPT_BLANKLINE',\n'NORMALIZE_WHITESPACE',\n'ELLIPSIS',\n'SKIP',\n'IGNORE_EXCEPTION_DETAIL',\n'COMPARISON_FLAGS',\n'REPORT_UDIFF',\n'REPORT_CDIFF',\n'REPORT_NDIFF',\n'REPORT_ONLY_FIRST_FAILURE',\n'REPORTING_FLAGS',\n'FAIL_FAST',\n\n\n'Example',\n'DocTest',\n\n'DocTestParser',\n\n'DocTestFinder',\n\n'DocTestRunner',\n'OutputChecker',\n'DocTestFailure',\n'UnexpectedException',\n'DebugRunner',\n\n'testmod',\n'testfile',\n'run_docstring_examples',\n\n'DocTestSuite',\n'DocFileSuite',\n'set_unittest_reportflags',\n\n'script_from_examples',\n'testsource',\n'debug_src',\n'debug',\n]\n\nimport __future__\nimport difflib\nimport inspect\nimport linecache\nimport os\nimport pdb\nimport re\nimport sys\nimport traceback\nimport unittest\nfrom io import StringIO\nfrom collections import namedtuple\n\nTestResults=namedtuple('TestResults','failed attempted')\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOPTIONFLAGS_BY_NAME={}\ndef register_optionflag(name):\n\n return OPTIONFLAGS_BY_NAME.setdefault(name,1 <<len(OPTIONFLAGS_BY_NAME))\n \nDONT_ACCEPT_TRUE_FOR_1=register_optionflag('DONT_ACCEPT_TRUE_FOR_1')\nDONT_ACCEPT_BLANKLINE=register_optionflag('DONT_ACCEPT_BLANKLINE')\nNORMALIZE_WHITESPACE=register_optionflag('NORMALIZE_WHITESPACE')\nELLIPSIS=register_optionflag('ELLIPSIS')\nSKIP=register_optionflag('SKIP')\nIGNORE_EXCEPTION_DETAIL=register_optionflag('IGNORE_EXCEPTION_DETAIL')\n\nCOMPARISON_FLAGS=(DONT_ACCEPT_TRUE_FOR_1 |\nDONT_ACCEPT_BLANKLINE |\nNORMALIZE_WHITESPACE |\nELLIPSIS |\nSKIP |\nIGNORE_EXCEPTION_DETAIL)\n\nREPORT_UDIFF=register_optionflag('REPORT_UDIFF')\nREPORT_CDIFF=register_optionflag('REPORT_CDIFF')\nREPORT_NDIFF=register_optionflag('REPORT_NDIFF')\nREPORT_ONLY_FIRST_FAILURE=register_optionflag('REPORT_ONLY_FIRST_FAILURE')\nFAIL_FAST=register_optionflag('FAIL_FAST')\n\nREPORTING_FLAGS=(REPORT_UDIFF |\nREPORT_CDIFF |\nREPORT_NDIFF |\nREPORT_ONLY_FIRST_FAILURE |\nFAIL_FAST)\n\n\nBLANKLINE_MARKER='<BLANKLINE>'\nELLIPSIS_MARKER='...'\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ndef _extract_future_flags(globs):\n ''\n\n\n \n flags=0\n for fname in __future__.all_feature_names:\n  feature=globs.get(fname,None )\n  if feature is getattr(__future__,fname):\n   flags |=feature.compiler_flag\n return flags\n \ndef _normalize_module(module,depth=2):\n ''\n\n\n\n\n\n\n\n \n if inspect.ismodule(module):\n  return module\n elif isinstance(module,str):\n  return __import__(module,globals(),locals(),[\"*\"])\n elif module is None :\n  return sys.modules[sys._getframe(depth).f_globals['__name__']]\n else :\n  raise TypeError(\"Expected a module, string, or None\")\n  \ndef _newline_convert(data):\n\n\n for newline in ('\\r\\n','\\r'):\n  data=data.replace(newline,'\\n')\n return data\n \ndef _load_testfile(filename,package,module_relative,encoding):\n if module_relative:\n  package=_normalize_module(package,3)\n  filename=_module_relative_path(package,filename)\n  if getattr(package,'__loader__',None )is not None :\n   if hasattr(package.__loader__,'get_data'):\n    file_contents=package.__loader__.get_data(filename)\n    file_contents=file_contents.decode(encoding)\n    \n    \n    return _newline_convert(file_contents),filename\n with open(filename,encoding=encoding)as f:\n  return f.read(),filename\n  \ndef _indent(s,indent=4):\n ''\n\n\n \n \n return re.sub('(?m)^(?!$)',indent *' ',s)\n \ndef _exception_traceback(exc_info):\n ''\n\n\n \n \n excout=StringIO()\n exc_type,exc_val,exc_tb=exc_info\n traceback.print_exception(exc_type,exc_val,exc_tb,file=excout)\n return excout.getvalue()\n \n \nclass _SpoofOut(StringIO):\n def getvalue(self):\n  result=StringIO.getvalue(self)\n  \n  \n  \n  if result and not result.endswith(\"\\n\"):\n   result +=\"\\n\"\n  return result\n  \n def truncate(self,size=None ):\n  self.seek(size)\n  StringIO.truncate(self)\n  \n  \ndef _ellipsis_match(want,got):\n ''\n\n\n\n \n if ELLIPSIS_MARKER not in want:\n  return want ==got\n  \n  \n ws=want.split(ELLIPSIS_MARKER)\n assert len(ws)>=2\n \n \n startpos,endpos=0,len(got)\n w=ws[0]\n if w:\n  if got.startswith(w):\n   startpos=len(w)\n   del ws[0]\n  else :\n   return False\n w=ws[-1]\n if w:\n  if got.endswith(w):\n   endpos -=len(w)\n   del ws[-1]\n  else :\n   return False\n   \n if startpos >endpos:\n \n \n  return False\n  \n  \n  \n  \n for w in ws:\n \n \n \n  startpos=got.find(w,startpos,endpos)\n  if startpos <0:\n   return False\n  startpos +=len(w)\n  \n return True\n \ndef _comment_line(line):\n ''\n line=line.rstrip()\n if line:\n  return '# '+line\n else :\n  return '#'\n  \ndef _strip_exception_details(msg):\n\n\n\n\n\n\n\n\n\n\n start,end=0,len(msg)\n \n i=msg.find(\"\\n\")\n if i >=0:\n  end=i\n  \n i=msg.find(':',0,end)\n if i >=0:\n  end=i\n  \n i=msg.rfind('.',0,end)\n if i >=0:\n  start=i+1\n return msg[start:end]\n \nclass _OutputRedirectingPdb(pdb.Pdb):\n ''\n\n\n\n \n def __init__(self,out):\n  self.__out=out\n  self.__debugger_used=False\n  \n  pdb.Pdb.__init__(self,stdout=out,nosigint=True )\n  \n  self.use_rawinput=1\n  \n def set_trace(self,frame=None ):\n  self.__debugger_used=True\n  if frame is None :\n   frame=sys._getframe().f_back\n  pdb.Pdb.set_trace(self,frame)\n  \n def set_continue(self):\n \n \n  if self.__debugger_used:\n   pdb.Pdb.set_continue(self)\n   \n def trace_dispatch(self,*args):\n \n  save_stdout=sys.stdout\n  sys.stdout=self.__out\n  \n  try :\n   return pdb.Pdb.trace_dispatch(self,*args)\n  finally :\n   sys.stdout=save_stdout\n   \n   \ndef _module_relative_path(module,test_path):\n if not inspect.ismodule(module):\n  raise TypeError('Expected a module: %r'%module)\n if test_path.startswith('/'):\n  raise ValueError('Module-relative files may not have absolute paths')\n  \n  \n test_path=os.path.join(*(test_path.split('/')))\n \n \n if hasattr(module,'__file__'):\n \n  basedir=os.path.split(module.__file__)[0]\n elif module.__name__ =='__main__':\n \n  if len(sys.argv)>0 and sys.argv[0]!='':\n   basedir=os.path.split(sys.argv[0])[0]\n  else :\n   basedir=os.curdir\n else :\n  if hasattr(module,'__path__'):\n   for directory in module.__path__:\n    fullpath=os.path.join(directory,test_path)\n    if os.path.exists(fullpath):\n     return fullpath\n     \n     \n  raise ValueError(\"Can't resolve paths relative to the module \"\n  \"%r (it has no __file__)\"\n  %module.__name__)\n  \n  \n return os.path.join(basedir,test_path)\n \n \n \n \n \n \n \n \n \n \n \n \n \nclass Example:\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n def __init__(self,source,want,exc_msg=None ,lineno=0,indent=0,\n options=None ):\n \n  if not source.endswith('\\n'):\n   source +='\\n'\n  if want and not want.endswith('\\n'):\n   want +='\\n'\n  if exc_msg is not None and not exc_msg.endswith('\\n'):\n   exc_msg +='\\n'\n   \n  self.source=source\n  self.want=want\n  self.lineno=lineno\n  self.indent=indent\n  if options is None :options={}\n  self.options=options\n  self.exc_msg=exc_msg\n  \n def __eq__(self,other):\n  if type(self)is not type(other):\n   return NotImplemented\n   \n  return self.source ==other.source and\\\n  self.want ==other.want and\\\n  self.lineno ==other.lineno and\\\n  self.indent ==other.indent and\\\n  self.options ==other.options and\\\n  self.exc_msg ==other.exc_msg\n  \n def __hash__(self):\n  return hash((self.source,self.want,self.lineno,self.indent,\n  self.exc_msg))\n  \nclass DocTest:\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n def __init__(self,examples,globs,name,filename,lineno,docstring):\n  ''\n\n\n  \n  assert not isinstance(examples,str),\\\n  \"DocTest no longer accepts str; use DocTestParser instead\"\n  self.examples=examples\n  self.docstring=docstring\n  self.globs=globs.copy()\n  self.name=name\n  self.filename=filename\n  self.lineno=lineno\n  \n def __repr__(self):\n  if len(self.examples)==0:\n   examples='no examples'\n  elif len(self.examples)==1:\n   examples='1 example'\n  else :\n   examples='%d examples'%len(self.examples)\n  return ('<%s %s from %s:%s (%s)>'%\n  (self.__class__.__name__,\n  self.name,self.filename,self.lineno,examples))\n  \n def __eq__(self,other):\n  if type(self)is not type(other):\n   return NotImplemented\n   \n  return self.examples ==other.examples and\\\n  self.docstring ==other.docstring and\\\n  self.globs ==other.globs and\\\n  self.name ==other.name and\\\n  self.filename ==other.filename and\\\n  self.lineno ==other.lineno\n  \n def __hash__(self):\n  return hash((self.docstring,self.name,self.filename,self.lineno))\n  \n  \n def __lt__(self,other):\n  if not isinstance(other,DocTest):\n   return NotImplemented\n  return ((self.name,self.filename,self.lineno,id(self))\n  <\n  (other.name,other.filename,other.lineno,id(other)))\n  \n  \n  \n  \n  \nclass DocTestParser:\n ''\n\n \n \n \n \n \n \n _EXAMPLE_RE=re.compile(r'''\n        # Source consists of a PS1 line followed by zero or more PS2 lines.\n        (?P<source>\n            (?:^(?P<indent> [ ]*) >>>    .*)    # PS1 line\n            (?:\\n           [ ]*  \\.\\.\\. .*)*)  # PS2 lines\n        \\n?\n        # Want consists of any non-blank lines that do not start with PS1.\n        (?P<want> (?:(?![ ]*$)    # Not a blank line\n                     (?![ ]*>>>)  # Not a line starting with PS1\n                     .+$\\n?       # But any other line\n                  )*)\n        ''',re.MULTILINE |re.VERBOSE)\n \n \n \n \n \n \n \n \n \n \n _EXCEPTION_RE=re.compile(r\"\"\"\n        # Grab the traceback header.  Different versions of Python have\n        # said different things on the first traceback line.\n        ^(?P<hdr> Traceback\\ \\(\n            (?: most\\ recent\\ call\\ last\n            |   innermost\\ last\n            ) \\) :\n        )\n        \\s* $                # toss trailing whitespace on the header.\n        (?P<stack> .*?)      # don't blink: absorb stuff until...\n        ^ (?P<msg> \\w+ .*)   #     a line *starts* with alphanum.\n        \"\"\",re.VERBOSE |re.MULTILINE |re.DOTALL)\n \n \n \n _IS_BLANK_OR_COMMENT=re.compile(r'^[ ]*(#.*)?$').match\n \n def parse(self,string,name='<string>'):\n  ''\n\n\n\n\n\n  \n  string=string.expandtabs()\n  \n  min_indent=self._min_indent(string)\n  if min_indent >0:\n   string='\\n'.join([l[min_indent:]for l in string.split('\\n')])\n   \n  output=[]\n  charno,lineno=0,0\n  \n  for m in self._EXAMPLE_RE.finditer(string):\n  \n   output.append(string[charno:m.start()])\n   \n   lineno +=string.count('\\n',charno,m.start())\n   \n   (source,options,want,exc_msg)=\\\n   self._parse_example(m,name,lineno)\n   \n   if not self._IS_BLANK_OR_COMMENT(source):\n    output.append(Example(source,want,exc_msg,\n    lineno=lineno,\n    indent=min_indent+len(m.group('indent')),\n    options=options))\n    \n   lineno +=string.count('\\n',m.start(),m.end())\n   \n   charno=m.end()\n   \n  output.append(string[charno:])\n  return output\n  \n def get_doctest(self,string,globs,name,filename,lineno):\n  ''\n\n\n\n\n\n\n  \n  return DocTest(self.get_examples(string,name),globs,\n  name,filename,lineno,string)\n  \n def get_examples(self,string,name='<string>'):\n  ''\n\n\n\n\n\n\n\n\n  \n  return [x for x in self.parse(string,name)\n  if isinstance(x,Example)]\n  \n def _parse_example(self,m,name,lineno):\n  ''\n\n\n\n\n\n\n\n\n  \n  \n  indent=len(m.group('indent'))\n  \n  \n  \n  source_lines=m.group('source').split('\\n')\n  self._check_prompt_blank(source_lines,indent,name,lineno)\n  self._check_prefix(source_lines[1:],' '*indent+'.',name,lineno)\n  source='\\n'.join([sl[indent+4:]for sl in source_lines])\n  \n  \n  \n  \n  want=m.group('want')\n  want_lines=want.split('\\n')\n  if len(want_lines)>1 and re.match(r' *$',want_lines[-1]):\n   del want_lines[-1]\n  self._check_prefix(want_lines,' '*indent,name,\n  lineno+len(source_lines))\n  want='\\n'.join([wl[indent:]for wl in want_lines])\n  \n  \n  m=self._EXCEPTION_RE.match(want)\n  if m:\n   exc_msg=m.group('msg')\n  else :\n   exc_msg=None\n   \n   \n  options=self._find_options(source,name,lineno)\n  \n  return source,options,want,exc_msg\n  \n  \n  \n  \n  \n  \n  \n  \n _OPTION_DIRECTIVE_RE=re.compile(r'#\\s*doctest:\\s*([^\\n\\'\"]*)$',\n re.MULTILINE)\n \n def _find_options(self,source,name,lineno):\n  ''\n\n\n\n\n\n  \n  options={}\n  \n  for m in self._OPTION_DIRECTIVE_RE.finditer(source):\n   option_strings=m.group(1).replace(',',' ').split()\n   for option in option_strings:\n    if (option[0]not in '+-'or\n    option[1:]not in OPTIONFLAGS_BY_NAME):\n     raise ValueError('line %r of the doctest for %s '\n     'has an invalid option: %r'%\n     (lineno+1,name,option))\n    flag=OPTIONFLAGS_BY_NAME[option[1:]]\n    options[flag]=(option[0]=='+')\n  if options and self._IS_BLANK_OR_COMMENT(source):\n   raise ValueError('line %r of the doctest for %s has an option '\n   'directive on a line with no example: %r'%\n   (lineno,name,source))\n  return options\n  \n  \n  \n _INDENT_RE=re.compile(r'^([ ]*)(?=\\S)',re.MULTILINE)\n \n def _min_indent(self,s):\n  ''\n  indents=[len(indent)for indent in self._INDENT_RE.findall(s)]\n  if len(indents)>0:\n   return min(indents)\n  else :\n   return 0\n   \n def _check_prompt_blank(self,lines,indent,name,lineno):\n  ''\n\n\n\n\n  \n  for i,line in enumerate(lines):\n   if len(line)>=indent+4 and line[indent+3]!=' ':\n    raise ValueError('line %r of the docstring for %s '\n    'lacks blank after %s: %r'%\n    (lineno+i+1,name,\n    line[indent:indent+3],line))\n    \n def _check_prefix(self,lines,prefix,name,lineno):\n  ''\n\n\n  \n  for i,line in enumerate(lines):\n   if line and not line.startswith(prefix):\n    raise ValueError('line %r of the docstring for %s has '\n    'inconsistent leading whitespace: %r'%\n    (lineno+i+1,name,line))\n    \n    \n    \n    \n    \n    \nclass DocTestFinder:\n ''\n\n\n\n\n\n \n \n def __init__(self,verbose=False ,parser=DocTestParser(),\n recurse=True ,exclude_empty=True ):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  self._parser=parser\n  self._verbose=verbose\n  self._recurse=recurse\n  self._exclude_empty=exclude_empty\n  \n def find(self,obj,name=None ,module=None ,globs=None ,extraglobs=None ):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  \n  if name is None :\n   name=getattr(obj,'__name__',None )\n   if name is None :\n    raise ValueError(\"DocTestFinder.find: name must be given \"\n    \"when obj.__name__ doesn't exist: %r\"%\n    (type(obj),))\n    \n    \n    \n    \n  if module is False :\n   module=None\n  elif module is None :\n   module=inspect.getmodule(obj)\n   \n   \n   \n   \n  try :\n   file=inspect.getsourcefile(obj)\n  except TypeError:\n   source_lines=None\n  else :\n   if not file:\n   \n   \n    file=inspect.getfile(obj)\n    if not file[0]+file[-2:]=='<]>':file=None\n   if file is None :\n    source_lines=None\n   else :\n    if module is not None :\n    \n    \n    \n     source_lines=linecache.getlines(file,module.__dict__)\n    else :\n    \n    \n     source_lines=linecache.getlines(file)\n    if not source_lines:\n     source_lines=None\n     \n     \n  if globs is None :\n   if module is None :\n    globs={}\n   else :\n    globs=module.__dict__.copy()\n  else :\n   globs=globs.copy()\n  if extraglobs is not None :\n   globs.update(extraglobs)\n  if '__name__'not in globs:\n   globs['__name__']='__main__'\n   \n   \n  tests=[]\n  self._find(tests,obj,name,module,source_lines,globs,{})\n  \n  \n  \n  \n  tests.sort()\n  return tests\n  \n def _from_module(self,module,object):\n  ''\n\n\n  \n  if module is None :\n   return True\n  elif inspect.getmodule(object)is not None :\n   return module is inspect.getmodule(object)\n  elif inspect.isfunction(object):\n   return module.__dict__ is object.__globals__\n  elif inspect.ismethoddescriptor(object):\n   if hasattr(object,'__objclass__'):\n    obj_mod=object.__objclass__.__module__\n   elif hasattr(object,'__module__'):\n    obj_mod=object.__module__\n   else :\n    return True\n   return module.__name__ ==obj_mod\n  elif inspect.isclass(object):\n   return module.__name__ ==object.__module__\n  elif hasattr(object,'__module__'):\n   return module.__name__ ==object.__module__\n  elif isinstance(object,property):\n   return True\n  else :\n   raise ValueError(\"object must be a class or function\")\n   \n def _find(self,tests,obj,name,module,source_lines,globs,seen):\n  ''\n\n\n  \n  if self._verbose:\n   print('Finding tests in %s'%name)\n   \n   \n  if id(obj)in seen:\n   return\n  seen[id(obj)]=1\n  \n  \n  test=self._get_test(obj,name,module,globs,source_lines)\n  if test is not None :\n   tests.append(test)\n   \n   \n  if inspect.ismodule(obj)and self._recurse:\n   for valname,val in obj.__dict__.items():\n    valname='%s.%s'%(name,valname)\n    \n    if ((inspect.isroutine(inspect.unwrap(val))\n    or inspect.isclass(val))and\n    self._from_module(module,val)):\n     self._find(tests,val,valname,module,source_lines,\n     globs,seen)\n     \n     \n  if inspect.ismodule(obj)and self._recurse:\n   for valname,val in getattr(obj,'__test__',{}).items():\n    if not isinstance(valname,str):\n     raise ValueError(\"DocTestFinder.find: __test__ keys \"\n     \"must be strings: %r\"%\n     (type(valname),))\n    if not (inspect.isroutine(val)or inspect.isclass(val)or\n    inspect.ismodule(val)or isinstance(val,str)):\n     raise ValueError(\"DocTestFinder.find: __test__ values \"\n     \"must be strings, functions, methods, \"\n     \"classes, or modules: %r\"%\n     (type(val),))\n    valname='%s.__test__.%s'%(name,valname)\n    self._find(tests,val,valname,module,source_lines,\n    globs,seen)\n    \n    \n  if inspect.isclass(obj)and self._recurse:\n   for valname,val in obj.__dict__.items():\n   \n    if isinstance(val,staticmethod):\n     val=getattr(obj,valname)\n    if isinstance(val,classmethod):\n     val=getattr(obj,valname).__func__\n     \n     \n    if ((inspect.isroutine(val)or inspect.isclass(val)or\n    isinstance(val,property))and\n    self._from_module(module,val)):\n     valname='%s.%s'%(name,valname)\n     self._find(tests,val,valname,module,source_lines,\n     globs,seen)\n     \n def _get_test(self,obj,name,module,globs,source_lines):\n  ''\n\n\n  \n  \n  \n  if isinstance(obj,str):\n   docstring=obj\n  else :\n   try :\n    if obj.__doc__ is None :\n     docstring=''\n    else :\n     docstring=obj.__doc__\n     if not isinstance(docstring,str):\n      docstring=str(docstring)\n   except (TypeError,AttributeError):\n    docstring=''\n    \n    \n  lineno=self._find_lineno(obj,source_lines)\n  \n  \n  if self._exclude_empty and not docstring:\n   return None\n   \n   \n  if module is None :\n   filename=None\n  else :\n  \n   filename=getattr(module,'__file__',None )or module.__name__\n   if filename[-4:]==\".pyc\":\n    filename=filename[:-1]\n  return self._parser.get_doctest(docstring,globs,name,\n  filename,lineno)\n  \n def _find_lineno(self,obj,source_lines):\n  ''\n\n\n  \n  lineno=None\n  \n  \n  if inspect.ismodule(obj):\n   lineno=0\n   \n   \n   \n   \n  if inspect.isclass(obj):\n   if source_lines is None :\n    return None\n   pat=re.compile(r'^\\s*class\\s*%s\\b'%\n   getattr(obj,'__name__','-'))\n   for i,line in enumerate(source_lines):\n    if pat.match(line):\n     lineno=i\n     break\n     \n     \n  if inspect.ismethod(obj):obj=obj.__func__\n  if inspect.isfunction(obj):obj=obj.__code__\n  if inspect.istraceback(obj):obj=obj.tb_frame\n  if inspect.isframe(obj):obj=obj.f_code\n  if inspect.iscode(obj):\n   lineno=getattr(obj,'co_firstlineno',None )-1\n   \n   \n   \n   \n   \n   \n  if lineno is not None :\n   if source_lines is None :\n    return lineno+1\n   pat=re.compile(r'(^|.*:)\\s*\\w*(\"|\\')')\n   for lineno in range(lineno,len(source_lines)):\n    if pat.match(source_lines[lineno]):\n     return lineno\n     \n     \n  return None\n  \n  \n  \n  \n  \nclass DocTestRunner:\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n DIVIDER=\"*\"*70\n \n def __init__(self,checker=None ,verbose=None ,optionflags=0):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  self._checker=checker or OutputChecker()\n  if verbose is None :\n   verbose='-v'in sys.argv\n  self._verbose=verbose\n  self.optionflags=optionflags\n  self.original_optionflags=optionflags\n  \n  \n  self.tries=0\n  self.failures=0\n  self._name2ft={}\n  \n  \n  self._fakeout=_SpoofOut()\n  \n  \n  \n  \n  \n def report_start(self,out,test,example):\n  ''\n\n\n  \n  if self._verbose:\n   if example.want:\n    out('Trying:\\n'+_indent(example.source)+\n    'Expecting:\\n'+_indent(example.want))\n   else :\n    out('Trying:\\n'+_indent(example.source)+\n    'Expecting nothing\\n')\n    \n def report_success(self,out,test,example,got):\n  ''\n\n\n  \n  if self._verbose:\n   out(\"ok\\n\")\n   \n def report_failure(self,out,test,example,got):\n  ''\n\n  \n  out(self._failure_header(test,example)+\n  self._checker.output_difference(example,got,self.optionflags))\n  \n def report_unexpected_exception(self,out,test,example,exc_info):\n  ''\n\n  \n  out(self._failure_header(test,example)+\n  'Exception raised:\\n'+_indent(_exception_traceback(exc_info)))\n  \n def _failure_header(self,test,example):\n  out=[self.DIVIDER]\n  if test.filename:\n   if test.lineno is not None and example.lineno is not None :\n    lineno=test.lineno+example.lineno+1\n   else :\n    lineno='?'\n   out.append('File \"%s\", line %s, in %s'%\n   (test.filename,lineno,test.name))\n  else :\n   out.append('Line %s, in %s'%(example.lineno+1,test.name))\n  out.append('Failed example:')\n  source=example.source\n  out.append(_indent(source))\n  return '\\n'.join(out)\n  \n  \n  \n  \n  \n def __run(self,test,compileflags,out):\n  ''\n\n\n\n\n\n\n\n  \n  \n  failures=tries=0\n  \n  \n  \n  original_optionflags=self.optionflags\n  \n  SUCCESS,FAILURE,BOOM=range(3)\n  \n  check=self._checker.check_output\n  \n  \n  for examplenum,example in enumerate(test.examples):\n  \n  \n  \n   quiet=(self.optionflags&REPORT_ONLY_FIRST_FAILURE and\n   failures >0)\n   \n   \n   self.optionflags=original_optionflags\n   if example.options:\n    for (optionflag,val)in example.options.items():\n     if val:\n      self.optionflags |=optionflag\n     else :\n      self.optionflags &=~optionflag\n      \n      \n   if self.optionflags&SKIP:\n    continue\n    \n    \n   tries +=1\n   if not quiet:\n    self.report_start(out,test,example)\n    \n    \n    \n    \n   filename='<doctest %s[%d]>'%(test.name,examplenum)\n   \n   \n   \n   \n   try :\n   \n    exec(compile(example.source,filename,\"single\",\n    compileflags,True ),test.globs)\n    self.debugger.set_continue()\n    exception=None\n   except KeyboardInterrupt:\n    raise\n   except :\n    exception=sys.exc_info()\n    self.debugger.set_continue()\n    \n   got=self._fakeout.getvalue()\n   self._fakeout.truncate(0)\n   outcome=FAILURE\n   \n   \n   \n   if exception is None :\n    if check(example.want,got,self.optionflags):\n     outcome=SUCCESS\n     \n     \n   else :\n    exc_msg=traceback.format_exception_only(*exception[:2])[-1]\n    if not quiet:\n     got +=_exception_traceback(exception)\n     \n     \n     \n    if example.exc_msg is None :\n     outcome=BOOM\n     \n     \n    elif check(example.exc_msg,exc_msg,self.optionflags):\n     outcome=SUCCESS\n     \n     \n    elif self.optionflags&IGNORE_EXCEPTION_DETAIL:\n     if check(_strip_exception_details(example.exc_msg),\n     _strip_exception_details(exc_msg),\n     self.optionflags):\n      outcome=SUCCESS\n      \n      \n   if outcome is SUCCESS:\n    if not quiet:\n     self.report_success(out,test,example,got)\n   elif outcome is FAILURE:\n    if not quiet:\n     self.report_failure(out,test,example,got)\n    failures +=1\n   elif outcome is BOOM:\n    if not quiet:\n     self.report_unexpected_exception(out,test,example,\n     exception)\n    failures +=1\n   else :\n    assert False ,(\"unknown outcome\",outcome)\n    \n   if failures and self.optionflags&FAIL_FAST:\n    break\n    \n    \n  self.optionflags=original_optionflags\n  \n  \n  self.__record_outcome(test,failures,tries)\n  return TestResults(failures,tries)\n  \n def __record_outcome(self,test,f,t):\n  ''\n\n\n  \n  f2,t2=self._name2ft.get(test.name,(0,0))\n  self._name2ft[test.name]=(f+f2,t+t2)\n  self.failures +=f\n  self.tries +=t\n  \n __LINECACHE_FILENAME_RE=re.compile(r'<doctest '\n r'(?P<name>.+)'\n r'\\[(?P<examplenum>\\d+)\\]>$')\n def __patched_linecache_getlines(self,filename,module_globals=None ):\n  m=self.__LINECACHE_FILENAME_RE.match(filename)\n  if m and m.group('name')==self.test.name:\n   example=self.test.examples[int(m.group('examplenum'))]\n   return example.source.splitlines(keepends=True )\n  else :\n   return self.save_linecache_getlines(filename,module_globals)\n   \n def run(self,test,compileflags=None ,out=None ,clear_globs=True ):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  self.test=test\n  \n  if compileflags is None :\n   compileflags=_extract_future_flags(test.globs)\n   \n  save_stdout=sys.stdout\n  if out is None :\n   encoding=save_stdout.encoding\n   if encoding is None or encoding.lower()=='utf-8':\n    out=save_stdout.write\n   else :\n   \n    def out(s):\n     s=str(s.encode(encoding,'backslashreplace'),encoding)\n     save_stdout.write(s)\n  sys.stdout=self._fakeout\n  \n  \n  \n  \n  \n  \n  save_trace=sys.gettrace()\n  save_set_trace=pdb.set_trace\n  self.debugger=_OutputRedirectingPdb(save_stdout)\n  self.debugger.reset()\n  pdb.set_trace=self.debugger.set_trace\n  \n  \n  \n  self.save_linecache_getlines=linecache.getlines\n  linecache.getlines=self.__patched_linecache_getlines\n  \n  \n  save_displayhook=sys.displayhook\n  sys.displayhook=sys.__displayhook__\n  \n  try :\n   return self.__run(test,compileflags,out)\n  finally :\n   sys.stdout=save_stdout\n   pdb.set_trace=save_set_trace\n   sys.settrace(save_trace)\n   linecache.getlines=self.save_linecache_getlines\n   sys.displayhook=save_displayhook\n   if clear_globs:\n    test.globs.clear()\n    import builtins\n    builtins._=None\n    \n    \n    \n    \n def summarize(self,verbose=None ):\n  ''\n\n\n\n\n\n\n\n\n  \n  if verbose is None :\n   verbose=self._verbose\n  notests=[]\n  passed=[]\n  failed=[]\n  totalt=totalf=0\n  for x in self._name2ft.items():\n   name,(f,t)=x\n   assert f <=t\n   totalt +=t\n   totalf +=f\n   if t ==0:\n    notests.append(name)\n   elif f ==0:\n    passed.append((name,t))\n   else :\n    failed.append(x)\n  if verbose:\n   if notests:\n    print(len(notests),\"items had no tests:\")\n    notests.sort()\n    for thing in notests:\n     print(\"   \",thing)\n   if passed:\n    print(len(passed),\"items passed all tests:\")\n    passed.sort()\n    for thing,count in passed:\n     print(\" %3d tests in %s\"%(count,thing))\n  if failed:\n   print(self.DIVIDER)\n   print(len(failed),\"items had failures:\")\n   failed.sort()\n   for thing,(f,t)in failed:\n    print(\" %3d of %3d in %s\"%(f,t,thing))\n  if verbose:\n   print(totalt,\"tests in\",len(self._name2ft),\"items.\")\n   print(totalt -totalf,\"passed and\",totalf,\"failed.\")\n  if totalf:\n   print(\"***Test Failed***\",totalf,\"failures.\")\n  elif verbose:\n   print(\"Test passed.\")\n  return TestResults(totalf,totalt)\n  \n  \n  \n  \n def merge(self,other):\n  d=self._name2ft\n  for name,(f,t)in other._name2ft.items():\n   if name in d:\n   \n   \n   \n   \n    f2,t2=d[name]\n    f=f+f2\n    t=t+t2\n   d[name]=f,t\n   \nclass OutputChecker:\n ''\n\n\n\n\n\n \n def _toAscii(self,s):\n  ''\n\n  \n  return str(s.encode('ASCII','backslashreplace'),\"ASCII\")\n  \n def check_output(self,want,got,optionflags):\n  ''\n\n\n\n\n\n\n\n  \n  \n  \n  \n  \n  \n  \n  got=self._toAscii(got)\n  want=self._toAscii(want)\n  \n  \n  \n  if got ==want:\n   return True\n   \n   \n   \n  if not (optionflags&DONT_ACCEPT_TRUE_FOR_1):\n   if (got,want)==(\"True\\n\",\"1\\n\"):\n    return True\n   if (got,want)==(\"False\\n\",\"0\\n\"):\n    return True\n    \n    \n    \n  if not (optionflags&DONT_ACCEPT_BLANKLINE):\n  \n   want=re.sub(r'(?m)^%s\\s*?$'%re.escape(BLANKLINE_MARKER),\n   '',want)\n   \n   \n   got=re.sub(r'(?m)^[^\\S\\n]+$','',got)\n   if got ==want:\n    return True\n    \n    \n    \n    \n  if optionflags&NORMALIZE_WHITESPACE:\n   got=' '.join(got.split())\n   want=' '.join(want.split())\n   if got ==want:\n    return True\n    \n    \n    \n  if optionflags&ELLIPSIS:\n   if _ellipsis_match(want,got):\n    return True\n    \n    \n  return False\n  \n  \n def _do_a_fancy_diff(self,want,got,optionflags):\n \n  if not optionflags&(REPORT_UDIFF |\n  REPORT_CDIFF |\n  REPORT_NDIFF):\n   return False\n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n  if optionflags&REPORT_NDIFF:\n   return True\n   \n   \n  return want.count('\\n')>2 and got.count('\\n')>2\n  \n def output_difference(self,example,got,optionflags):\n  ''\n\n\n\n\n  \n  want=example.want\n  \n  \n  if not (optionflags&DONT_ACCEPT_BLANKLINE):\n   got=re.sub('(?m)^[ ]*(?=\\n)',BLANKLINE_MARKER,got)\n   \n   \n  if self._do_a_fancy_diff(want,got,optionflags):\n  \n   want_lines=want.splitlines(keepends=True )\n   got_lines=got.splitlines(keepends=True )\n   \n   if optionflags&REPORT_UDIFF:\n    diff=difflib.unified_diff(want_lines,got_lines,n=2)\n    diff=list(diff)[2:]\n    kind='unified diff with -expected +actual'\n   elif optionflags&REPORT_CDIFF:\n    diff=difflib.context_diff(want_lines,got_lines,n=2)\n    diff=list(diff)[2:]\n    kind='context diff with expected followed by actual'\n   elif optionflags&REPORT_NDIFF:\n    engine=difflib.Differ(charjunk=difflib.IS_CHARACTER_JUNK)\n    diff=list(engine.compare(want_lines,got_lines))\n    kind='ndiff with -expected +actual'\n   else :\n    assert 0,'Bad diff option'\n   return 'Differences (%s):\\n'%kind+_indent(''.join(diff))\n   \n   \n   \n  if want and got:\n   return 'Expected:\\n%sGot:\\n%s'%(_indent(want),_indent(got))\n  elif want:\n   return 'Expected:\\n%sGot nothing\\n'%_indent(want)\n  elif got:\n   return 'Expected nothing\\nGot:\\n%s'%_indent(got)\n  else :\n   return 'Expected nothing\\nGot nothing\\n'\n   \nclass DocTestFailure(Exception):\n ''\n\n\n\n\n\n\n\n\n \n def __init__(self,test,example,got):\n  self.test=test\n  self.example=example\n  self.got=got\n  \n def __str__(self):\n  return str(self.test)\n  \nclass UnexpectedException(Exception):\n ''\n\n\n\n\n\n\n\n\n \n def __init__(self,test,example,exc_info):\n  self.test=test\n  self.example=example\n  self.exc_info=exc_info\n  \n def __str__(self):\n  return str(self.test)\n  \nclass DebugRunner(DocTestRunner):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n def run(self,test,compileflags=None ,out=None ,clear_globs=True ):\n  r=DocTestRunner.run(self,test,compileflags,out,False )\n  if clear_globs:\n   test.globs.clear()\n  return r\n  \n def report_unexpected_exception(self,out,test,example,exc_info):\n  raise UnexpectedException(test,example,exc_info)\n  \n def report_failure(self,out,test,example,got):\n  raise DocTestFailure(test,example,got)\n  \n  \n  \n  \n  \n  \n  \n  \nmaster=None\n\ndef testmod(m=None ,name=None ,globs=None ,verbose=None ,\nreport=True ,optionflags=0,extraglobs=None ,\nraise_on_error=False ,exclude_empty=False ):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n global master\n \n \n if m is None :\n \n \n \n  m=sys.modules.get('__main__')\n  \n  \n if not inspect.ismodule(m):\n  raise TypeError(\"testmod: module required; %r\"%(m,))\n  \n  \n if name is None :\n  name=m.__name__\n  \n  \n finder=DocTestFinder(exclude_empty=exclude_empty)\n \n if raise_on_error:\n  runner=DebugRunner(verbose=verbose,optionflags=optionflags)\n else :\n  runner=DocTestRunner(verbose=verbose,optionflags=optionflags)\n  \n for test in finder.find(m,name,globs=globs,extraglobs=extraglobs):\n  runner.run(test)\n  \n if report:\n  runner.summarize()\n  \n if master is None :\n  master=runner\n else :\n  master.merge(runner)\n  \n return TestResults(runner.failures,runner.tries)\n \ndef testfile(filename,module_relative=True ,name=None ,package=None ,\nglobs=None ,verbose=None ,report=True ,optionflags=0,\nextraglobs=None ,raise_on_error=False ,parser=DocTestParser(),\nencoding=None ):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n global master\n \n if package and not module_relative:\n  raise ValueError(\"Package may only be specified for module-\"\n  \"relative paths.\")\n  \n  \n text,filename=_load_testfile(filename,package,module_relative,\n encoding or \"utf-8\")\n \n \n if name is None :\n  name=os.path.basename(filename)\n  \n  \n if globs is None :\n  globs={}\n else :\n  globs=globs.copy()\n if extraglobs is not None :\n  globs.update(extraglobs)\n if '__name__'not in globs:\n  globs['__name__']='__main__'\n  \n if raise_on_error:\n  runner=DebugRunner(verbose=verbose,optionflags=optionflags)\n else :\n  runner=DocTestRunner(verbose=verbose,optionflags=optionflags)\n  \n  \n test=parser.get_doctest(text,globs,name,filename,0)\n runner.run(test)\n \n if report:\n  runner.summarize()\n  \n if master is None :\n  master=runner\n else :\n  master.merge(runner)\n  \n return TestResults(runner.failures,runner.tries)\n \ndef run_docstring_examples(f,globs,verbose=False ,name=\"NoName\",\ncompileflags=None ,optionflags=0):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n finder=DocTestFinder(verbose=verbose,recurse=False )\n runner=DocTestRunner(verbose=verbose,optionflags=optionflags)\n for test in finder.find(f,name,globs=globs):\n  runner.run(test,compileflags=compileflags)\n  \n  \n  \n  \n  \n_unittest_reportflags=0\n\ndef set_unittest_reportflags(flags):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n global _unittest_reportflags\n \n if (flags&REPORTING_FLAGS)!=flags:\n  raise ValueError(\"Only reporting flags allowed\",flags)\n old=_unittest_reportflags\n _unittest_reportflags=flags\n return old\n \n \nclass DocTestCase(unittest.TestCase):\n\n def __init__(self,test,optionflags=0,setUp=None ,tearDown=None ,\n checker=None ):\n \n  unittest.TestCase.__init__(self)\n  self._dt_optionflags=optionflags\n  self._dt_checker=checker\n  self._dt_test=test\n  self._dt_setUp=setUp\n  self._dt_tearDown=tearDown\n  \n def setUp(self):\n  test=self._dt_test\n  \n  if self._dt_setUp is not None :\n   self._dt_setUp(test)\n   \n def tearDown(self):\n  test=self._dt_test\n  \n  if self._dt_tearDown is not None :\n   self._dt_tearDown(test)\n   \n  test.globs.clear()\n  \n def runTest(self):\n  test=self._dt_test\n  old=sys.stdout\n  new=StringIO()\n  optionflags=self._dt_optionflags\n  \n  if not (optionflags&REPORTING_FLAGS):\n  \n  \n   optionflags |=_unittest_reportflags\n   \n  runner=DocTestRunner(optionflags=optionflags,\n  checker=self._dt_checker,verbose=False )\n  \n  try :\n   runner.DIVIDER=\"-\"*70\n   failures,tries=runner.run(\n   test,out=new.write,clear_globs=False )\n  finally :\n   sys.stdout=old\n   \n  if failures:\n   raise self.failureException(self.format_failure(new.getvalue()))\n   \n def format_failure(self,err):\n  test=self._dt_test\n  if test.lineno is None :\n   lineno='unknown line number'\n  else :\n   lineno='%s'%test.lineno\n  lname='.'.join(test.name.split('.')[-1:])\n  return ('Failed doctest test for %s\\n'\n  '  File \"%s\", line %s, in %s\\n\\n%s'\n  %(test.name,test.filename,lineno,lname,err)\n  )\n  \n def debug(self):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  \n  self.setUp()\n  runner=DebugRunner(optionflags=self._dt_optionflags,\n  checker=self._dt_checker,verbose=False )\n  runner.run(self._dt_test,clear_globs=False )\n  self.tearDown()\n  \n def id(self):\n  return self._dt_test.name\n  \n def __eq__(self,other):\n  if type(self)is not type(other):\n   return NotImplemented\n   \n  return self._dt_test ==other._dt_test and\\\n  self._dt_optionflags ==other._dt_optionflags and\\\n  self._dt_setUp ==other._dt_setUp and\\\n  self._dt_tearDown ==other._dt_tearDown and\\\n  self._dt_checker ==other._dt_checker\n  \n def __hash__(self):\n  return hash((self._dt_optionflags,self._dt_setUp,self._dt_tearDown,\n  self._dt_checker))\n  \n def __repr__(self):\n  name=self._dt_test.name.split('.')\n  return \"%s (%s)\"%(name[-1],'.'.join(name[:-1]))\n  \n __str__=object.__str__\n \n def shortDescription(self):\n  return \"Doctest: \"+self._dt_test.name\n  \nclass SkipDocTestCase(DocTestCase):\n def __init__(self,module):\n  self.module=module\n  DocTestCase.__init__(self,None )\n  \n def setUp(self):\n  self.skipTest(\"DocTestSuite will not work with -O2 and above\")\n  \n def test_skip(self):\n  pass\n  \n def shortDescription(self):\n  return \"Skipping tests from %s\"%self.module.__name__\n  \n __str__=shortDescription\n \n \nclass _DocTestSuite(unittest.TestSuite):\n\n def _removeTestAtIndex(self,index):\n  pass\n  \n  \ndef DocTestSuite(module=None ,globs=None ,extraglobs=None ,test_finder=None ,\n**options):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n if test_finder is None :\n  test_finder=DocTestFinder()\n  \n module=_normalize_module(module)\n tests=test_finder.find(module,globs=globs,extraglobs=extraglobs)\n \n if not tests and sys.flags.optimize >=2:\n \n  suite=_DocTestSuite()\n  suite.addTest(SkipDocTestCase(module))\n  return suite\n  \n tests.sort()\n suite=_DocTestSuite()\n \n for test in tests:\n  if len(test.examples)==0:\n   continue\n  if not test.filename:\n   filename=module.__file__\n   if filename[-4:]==\".pyc\":\n    filename=filename[:-1]\n   test.filename=filename\n  suite.addTest(DocTestCase(test,**options))\n  \n return suite\n \nclass DocFileCase(DocTestCase):\n\n def id(self):\n  return '_'.join(self._dt_test.name.split('.'))\n  \n def __repr__(self):\n  return self._dt_test.filename\n  \n def format_failure(self,err):\n  return ('Failed doctest test for %s\\n  File \"%s\", line 0\\n\\n%s'\n  %(self._dt_test.name,self._dt_test.filename,err)\n  )\n  \ndef DocFileTest(path,module_relative=True ,package=None ,\nglobs=None ,parser=DocTestParser(),\nencoding=None ,**options):\n if globs is None :\n  globs={}\n else :\n  globs=globs.copy()\n  \n if package and not module_relative:\n  raise ValueError(\"Package may only be specified for module-\"\n  \"relative paths.\")\n  \n  \n doc,path=_load_testfile(path,package,module_relative,\n encoding or \"utf-8\")\n \n if \"__file__\"not in globs:\n  globs[\"__file__\"]=path\n  \n  \n name=os.path.basename(path)\n \n \n test=parser.get_doctest(doc,globs,name,path,0)\n return DocFileCase(test,**options)\n \ndef DocFileSuite(*paths,**kw):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n suite=_DocTestSuite()\n \n \n \n \n if kw.get('module_relative',True ):\n  kw['package']=_normalize_module(kw.get('package'))\n  \n for path in paths:\n  suite.addTest(DocFileTest(path,**kw))\n  \n return suite\n \n \n \n \n \ndef script_from_examples(s):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n output=[]\n for piece in DocTestParser().parse(s):\n  if isinstance(piece,Example):\n  \n   output.append(piece.source[:-1])\n   \n   want=piece.want\n   if want:\n    output.append('# Expected:')\n    output +=['## '+l for l in want.split('\\n')[:-1]]\n  else :\n  \n   output +=[_comment_line(l)\n   for l in piece.split('\\n')[:-1]]\n   \n   \n while output and output[-1]=='#':\n  output.pop()\n while output and output[0]=='#':\n  output.pop(0)\n  \n  \n return '\\n'.join(output)+'\\n'\n \ndef testsource(module,name):\n ''\n\n\n\n\n \n module=_normalize_module(module)\n tests=DocTestFinder().find(module)\n test=[t for t in tests if t.name ==name]\n if not test:\n  raise ValueError(name,\"not found in tests\")\n test=test[0]\n testsrc=script_from_examples(test.docstring)\n return testsrc\n \ndef debug_src(src,pm=False ,globs=None ):\n ''\n testsrc=script_from_examples(src)\n debug_script(testsrc,pm,globs)\n \ndef debug_script(src,pm=False ,globs=None ):\n ''\n import pdb\n \n if globs:\n  globs=globs.copy()\n else :\n  globs={}\n  \n if pm:\n  try :\n   exec(src,globs,globs)\n  except :\n   print(sys.exc_info()[1])\n   p=pdb.Pdb(nosigint=True )\n   p.reset()\n   p.interaction(None ,sys.exc_info()[2])\n else :\n  pdb.Pdb(nosigint=True ).run(\"exec(%r)\"%src,globs,globs)\n  \ndef debug(module,name,pm=False ):\n ''\n\n\n\n\n \n module=_normalize_module(module)\n testsrc=testsource(module,name)\n debug_script(testsrc,pm,module.__dict__)\n \n \n \n \nclass _TestClass:\n ''\n\n\n\n\n\n\n\n\n\n\n \n \n def __init__(self,val):\n  ''\n\n\n\n\n  \n  \n  self.val=val\n  \n def square(self):\n  ''\n\n\n\n  \n  \n  self.val=self.val **2\n  return self\n  \n def get(self):\n  ''\n\n\n\n\n  \n  \n  return self.val\n  \n__test__={\"_TestClass\":_TestClass,\n\"string\":r\"\"\"\n                      Example of a string object, searched as-is.\n                      >>> x = 1; y = 2\n                      >>> x + y, x * y\n                      (3, 2)\n                      \"\"\",\n\n\"bool-int equivalence\":r\"\"\"\n                                    In 2.2, boolean expressions displayed\n                                    0 or 1.  By default, we still accept\n                                    them.  This can be disabled by passing\n                                    DONT_ACCEPT_TRUE_FOR_1 to the new\n                                    optionflags argument.\n                                    >>> 4 == 4\n                                    1\n                                    >>> 4 == 4\n                                    True\n                                    >>> 4 > 4\n                                    0\n                                    >>> 4 > 4\n                                    False\n                                    \"\"\",\n\n\"blank lines\":r\"\"\"\n                Blank lines can be marked with <BLANKLINE>:\n                    >>> print('foo\\n\\nbar\\n')\n                    foo\n                    <BLANKLINE>\n                    bar\n                    <BLANKLINE>\n            \"\"\",\n\n\"ellipsis\":r\"\"\"\n                If the ellipsis flag is used, then '...' can be used to\n                elide substrings in the desired output:\n                    >>> print(list(range(1000))) #doctest: +ELLIPSIS\n                    [0, 1, 2, ..., 999]\n            \"\"\",\n\n\"whitespace normalization\":r\"\"\"\n                If the whitespace normalization flag is used, then\n                differences in whitespace are ignored.\n                    >>> print(list(range(30))) #doctest: +NORMALIZE_WHITESPACE\n                    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14,\n                     15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26,\n                     27, 28, 29]\n            \"\"\",\n}\n\n\ndef _test():\n import argparse\n \n parser=argparse.ArgumentParser(description=\"doctest runner\")\n parser.add_argument('-v','--verbose',action='store_true',default=False ,\n help='print very verbose output for all tests')\n parser.add_argument('-o','--option',action='append',\n choices=OPTIONFLAGS_BY_NAME.keys(),default=[],\n help=('specify a doctest option flag to apply'\n ' to the test run; may be specified more'\n ' than once to apply multiple options'))\n parser.add_argument('-f','--fail-fast',action='store_true',\n help=('stop running tests after first failure (this'\n ' is a shorthand for -o FAIL_FAST, and is'\n ' in addition to any other -o options)'))\n parser.add_argument('file',nargs='+',\n help='file containing the tests to run')\n args=parser.parse_args()\n testfiles=args.file\n \n \n verbose=args.verbose\n options=0\n for option in args.option:\n  options |=OPTIONFLAGS_BY_NAME[option]\n if args.fail_fast:\n  options |=FAIL_FAST\n for filename in testfiles:\n  if filename.endswith(\".py\"):\n  \n  \n  \n   dirname,filename=os.path.split(filename)\n   sys.path.insert(0,dirname)\n   m=__import__(filename[:-3])\n   del sys.path[0]\n   failures,_=testmod(m,verbose=verbose,optionflags=options)\n  else :\n   failures,_=testfile(filename,module_relative=False ,\n   verbose=verbose,optionflags=options)\n  if failures:\n   return 1\n return 0\n \n \nif __name__ ==\"__main__\":\n sys.exit(_test())\n", ["__future__", "argparse", "builtins", "collections", "difflib", "inspect", "io", "linecache", "os", "pdb", "re", "sys", "traceback", "unittest"]],
     "enum": [".py", "import sys\nfrom types import MappingProxyType,DynamicClassAttribute\n\n\n__all__=[\n'EnumMeta',\n'Enum','IntEnum','Flag','IntFlag',\n'auto','unique',\n]\n\n\ndef _is_descriptor(obj):\n ''\n return (\n hasattr(obj,'__get__')or\n hasattr(obj,'__set__')or\n hasattr(obj,'__delete__'))\n \n \ndef _is_dunder(name):\n ''\n return (len(name)>4 and\n name[:2]==name[-2:]=='__'and\n name[2]!='_'and\n name[-3]!='_')\n \n \ndef _is_sunder(name):\n ''\n return (len(name)>2 and\n name[0]==name[-1]=='_'and\n name[1:2]!='_'and\n name[-2:-1]!='_')\n \n \ndef _make_class_unpicklable(cls):\n ''\n def _break_on_call_reduce(self,proto):\n  raise TypeError('%r cannot be pickled'%self)\n cls.__reduce_ex__=_break_on_call_reduce\n cls.__module__='<unknown>'\n \n_auto_null=object()\nclass auto:\n ''\n\n \n value=_auto_null\n \n \nclass _EnumDict(dict):\n ''\n\n\n\n\n \n def __init__(self):\n  super().__init__()\n  self._member_names=[]\n  self._last_values=[]\n  self._ignore=[]\n  self._auto_called=False\n  \n def __setitem__(self,key,value):\n  ''\n\n\n\n\n\n\n  \n  if _is_sunder(key):\n   if key not in (\n   '_order_','_create_pseudo_member_',\n   '_generate_next_value_','_missing_','_ignore_',\n   ):\n    raise ValueError('_names_ are reserved for future Enum use')\n   if key =='_generate_next_value_':\n   \n    if self._auto_called:\n     raise TypeError(\"_generate_next_value_ must be defined before members\")\n    setattr(self,'_generate_next_value',value)\n   elif key =='_ignore_':\n    if isinstance(value,str):\n     value=value.replace(',',' ').split()\n    else :\n     value=list(value)\n    self._ignore=value\n    already=set(value)&set(self._member_names)\n    if already:\n     raise ValueError('_ignore_ cannot specify already set names: %r'%(already,))\n  elif _is_dunder(key):\n   if key =='__order__':\n    key='_order_'\n  elif key in self._member_names:\n  \n   raise TypeError('Attempted to reuse key: %r'%key)\n  elif key in self._ignore:\n   pass\n  elif not _is_descriptor(value):\n   if key in self:\n   \n    raise TypeError('%r already defined as: %r'%(key,self[key]))\n   if isinstance(value,auto):\n    if value.value ==_auto_null:\n     value.value=self._generate_next_value(key,1,len(self._member_names),self._last_values[:])\n     self._auto_called=True\n    value=value.value\n   self._member_names.append(key)\n   self._last_values.append(value)\n  super().__setitem__(key,value)\n  \n  \n  \n  \n  \nEnum=None\n\n\nclass EnumMeta(type):\n ''\n @classmethod\n def __prepare__(metacls,cls,bases):\n \n  metacls._check_for_existing_members(cls,bases)\n  \n  enum_dict=_EnumDict()\n  \n  member_type,first_enum=metacls._get_mixins_(cls,bases)\n  if first_enum is not None :\n   enum_dict['_generate_next_value_']=getattr(first_enum,'_generate_next_value_',None )\n  return enum_dict\n  \n def __new__(metacls,cls,bases,classdict):\n \n \n \n \n \n \n  classdict.setdefault('_ignore_',[]).append('_ignore_')\n  ignore=classdict['_ignore_']\n  for key in ignore:\n   classdict.pop(key,None )\n  member_type,first_enum=metacls._get_mixins_(cls,bases)\n  __new__,save_new,use_args=metacls._find_new_(classdict,member_type,\n  first_enum)\n  \n  \n  \n  enum_members={k:classdict[k]for k in classdict._member_names}\n  for name in classdict._member_names:\n   del classdict[name]\n   \n   \n  _order_=classdict.pop('_order_',None )\n  \n  \n  invalid_names=set(enum_members)&{'mro',''}\n  if invalid_names:\n   raise ValueError('Invalid enum member name: {0}'.format(\n   ','.join(invalid_names)))\n   \n   \n  if '__doc__'not in classdict:\n   classdict['__doc__']='An enumeration.'\n   \n   \n  enum_class=super().__new__(metacls,cls,bases,classdict)\n  enum_class._member_names_=[]\n  enum_class._member_map_={}\n  enum_class._member_type_=member_type\n  \n  \n  \n  dynamic_attributes={k for c in enum_class.mro()\n  for k,v in c.__dict__.items()\n  if isinstance(v,DynamicClassAttribute)}\n  \n  \n  enum_class._value2member_map_={}\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  if '__reduce_ex__'not in classdict:\n   if member_type is not object:\n    methods=('__getnewargs_ex__','__getnewargs__',\n    '__reduce_ex__','__reduce__')\n    if not any(m in member_type.__dict__ for m in methods):\n     _make_class_unpicklable(enum_class)\n     \n     \n     \n     \n     \n  for member_name in classdict._member_names:\n   value=enum_members[member_name]\n   if not isinstance(value,tuple):\n    args=(value,)\n   else :\n    args=value\n   if member_type is tuple:\n    args=(args,)\n   if not use_args:\n    enum_member=__new__(enum_class)\n    if not hasattr(enum_member,'_value_'):\n     enum_member._value_=value\n   else :\n    enum_member=__new__(enum_class,*args)\n    if not hasattr(enum_member,'_value_'):\n     if member_type is object:\n      enum_member._value_=value\n     else :\n      enum_member._value_=member_type(*args)\n   value=enum_member._value_\n   enum_member._name_=member_name\n   enum_member.__objclass__=enum_class\n   enum_member.__init__(*args)\n   \n   \n   for name,canonical_member in enum_class._member_map_.items():\n    if canonical_member._value_ ==enum_member._value_:\n     enum_member=canonical_member\n     break\n   else :\n   \n    enum_class._member_names_.append(member_name)\n    \n    \n   if member_name not in dynamic_attributes:\n    setattr(enum_class,member_name,enum_member)\n    \n   enum_class._member_map_[member_name]=enum_member\n   try :\n   \n   \n   \n    enum_class._value2member_map_[value]=enum_member\n   except TypeError:\n    pass\n    \n    \n    \n    \n    \n  for name in ('__repr__','__str__','__format__','__reduce_ex__'):\n   if name in classdict:\n    continue\n   class_method=getattr(enum_class,name)\n   obj_method=getattr(member_type,name,None )\n   enum_method=getattr(first_enum,name,None )\n   if obj_method is not None and obj_method is class_method:\n    setattr(enum_class,name,enum_method)\n    \n    \n    \n  if Enum is not None :\n  \n  \n   if save_new:\n    enum_class.__new_member__=__new__\n   enum_class.__new__=Enum.__new__\n   \n   \n  if _order_ is not None :\n   if isinstance(_order_,str):\n    _order_=_order_.replace(',',' ').split()\n   if _order_ !=enum_class._member_names_:\n    raise TypeError('member order does not match _order_')\n    \n  return enum_class\n  \n def __bool__(self):\n  ''\n\n  \n  return True\n  \n def __call__(cls,value,names=None ,*,module=None ,qualname=None ,type=None ,start=1):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  if names is None :\n   return cls.__new__(cls,value)\n   \n  return cls._create_(value,names,module=module,qualname=qualname,type=type,start=start)\n  \n def __contains__(cls,member):\n  if not isinstance(member,Enum):\n   raise TypeError(\n   \"unsupported operand type(s) for 'in': '%s' and '%s'\"%(\n   type(member).__qualname__,cls.__class__.__qualname__))\n  return isinstance(member,cls)and member._name_ in cls._member_map_\n  \n def __delattr__(cls,attr):\n \n \n  if attr in cls._member_map_:\n   raise AttributeError(\n   \"%s: cannot delete Enum member.\"%cls.__name__)\n  super().__delattr__(attr)\n  \n def __dir__(self):\n  return (['__class__','__doc__','__members__','__module__']+\n  self._member_names_)\n  \n def __getattr__(cls,name):\n  ''\n\n\n\n\n\n\n  \n  if _is_dunder(name):\n   raise AttributeError(name)\n  try :\n   return cls._member_map_[name]\n  except KeyError:\n   raise AttributeError(name)from None\n   \n def __getitem__(cls,name):\n  return cls._member_map_[name]\n  \n def __iter__(cls):\n  return (cls._member_map_[name]for name in cls._member_names_)\n  \n def __len__(cls):\n  return len(cls._member_names_)\n  \n @property\n def __members__(cls):\n  ''\n\n\n\n\n  \n  return MappingProxyType(cls._member_map_)\n  \n def __repr__(cls):\n  return \"<enum %r>\"%cls.__name__\n  \n def __reversed__(cls):\n  return (cls._member_map_[name]for name in reversed(cls._member_names_))\n  \n def __setattr__(cls,name,value):\n  ''\n\n\n\n\n\n  \n  member_map=cls.__dict__.get('_member_map_',{})\n  if name in member_map:\n   raise AttributeError('Cannot reassign members.')\n  super().__setattr__(name,value)\n  \n def _create_(cls,class_name,names,*,module=None ,qualname=None ,type=None ,start=1):\n  ''\n\n\n\n\n\n\n\n\n\n  \n  metacls=cls.__class__\n  bases=(cls,)if type is None else (type,cls)\n  _,first_enum=cls._get_mixins_(cls,bases)\n  classdict=metacls.__prepare__(class_name,bases)\n  \n  \n  if isinstance(names,str):\n   names=names.replace(',',' ').split()\n  if isinstance(names,(tuple,list))and names and isinstance(names[0],str):\n   original_names,names=names,[]\n   last_values=[]\n   for count,name in enumerate(original_names):\n    value=first_enum._generate_next_value_(name,start,count,last_values[:])\n    last_values.append(value)\n    names.append((name,value))\n    \n    \n  for item in names:\n   if isinstance(item,str):\n    member_name,member_value=item,names[item]\n   else :\n    member_name,member_value=item\n   classdict[member_name]=member_value\n  enum_class=metacls.__new__(metacls,class_name,bases,classdict)\n  \n  \n  \n  if module is None :\n   try :\n    module=sys._getframe(2).f_globals['__name__']\n   except (AttributeError,ValueError,KeyError):\n    pass\n  if module is None :\n   _make_class_unpicklable(enum_class)\n  else :\n   enum_class.__module__=module\n  if qualname is not None :\n   enum_class.__qualname__=qualname\n   \n  return enum_class\n  \n def _convert_(cls,name,module,filter,source=None ):\n  ''\n\n  \n  \n  \n  \n  \n  \n  module_globals=vars(sys.modules[module])\n  if source:\n   source=vars(source)\n  else :\n   source=module_globals\n   \n   \n   \n  members=[\n  (name,value)\n  for name,value in source.items()\n  if filter(name)]\n  try :\n  \n   members.sort(key=lambda t:(t[1],t[0]))\n  except TypeError:\n  \n   members.sort(key=lambda t:t[0])\n  cls=cls(name,members,module=module)\n  cls.__reduce_ex__=_reduce_ex_by_name\n  module_globals.update(cls.__members__)\n  module_globals[name]=cls\n  return cls\n  \n @staticmethod\n def _check_for_existing_members(class_name,bases):\n  for chain in bases:\n   for base in chain.__mro__:\n    if issubclass(base,Enum)and base._member_names_:\n     raise TypeError(\"%s: cannot extend enumeration %r\"%(class_name,base.__name__))\n     \n @staticmethod\n def _get_mixins_(class_name,bases):\n  ''\n\n\n\n\n  \n  if not bases:\n   return object,Enum\n   \n  def _find_data_type(bases):\n   data_types=[]\n   for chain in bases:\n    candidate=None\n    for base in chain.__mro__:\n     if base is object:\n      continue\n     elif '__new__'in base.__dict__:\n      if issubclass(base,Enum):\n       continue\n      data_types.append(candidate or base)\n      break\n     elif not issubclass(base,Enum):\n      candidate=base\n   if len(data_types)>1:\n    raise TypeError('%r: too many data types: %r'%(class_name,data_types))\n   elif data_types:\n    return data_types[0]\n   else :\n    return None\n    \n    \n    \n  first_enum=bases[-1]\n  if not issubclass(first_enum,Enum):\n   raise TypeError(\"new enumerations should be created as \"\n   \"`EnumName([mixin_type, ...] [data_type,] enum_type)`\")\n  member_type=_find_data_type(bases)or object\n  if first_enum._member_names_:\n   raise TypeError(\"Cannot extend enumerations\")\n  return member_type,first_enum\n  \n @staticmethod\n def _find_new_(classdict,member_type,first_enum):\n  ''\n\n\n\n\n\n  \n  \n  \n  \n  __new__=classdict.get('__new__',None )\n  \n  \n  save_new=__new__ is not None\n  \n  if __new__ is None :\n  \n  \n   for method in ('__new_member__','__new__'):\n    for possible in (member_type,first_enum):\n     target=getattr(possible,method,None )\n     if target not in {\n     None ,\n     None .__new__,\n     object.__new__,\n     Enum.__new__,\n     }:\n      __new__=target\n      break\n    if __new__ is not None :\n     break\n   else :\n    __new__=object.__new__\n    \n    \n    \n    \n  if __new__ is object.__new__:\n   use_args=False\n  else :\n   use_args=True\n  return __new__,save_new,use_args\n  \n  \nclass Enum(metaclass=EnumMeta):\n ''\n\n\n\n \n def __new__(cls,value):\n \n \n \n  if type(value)is cls:\n  \n   return value\n   \n   \n  try :\n   return cls._value2member_map_[value]\n  except KeyError:\n  \n   pass\n  except TypeError:\n  \n   for member in cls._member_map_.values():\n    if member._value_ ==value:\n     return member\n     \n  try :\n   exc=None\n   result=cls._missing_(value)\n  except Exception as e:\n   exc=e\n   result=None\n  if isinstance(result,cls):\n   return result\n  else :\n   ve_exc=ValueError(\"%r is not a valid %s\"%(value,cls.__qualname__))\n   if result is None and exc is None :\n    raise ve_exc\n   elif exc is None :\n    exc=TypeError(\n    'error in %s._missing_: returned %r instead of None or a valid member'\n    %(cls.__name__,result)\n    )\n   exc.__context__=ve_exc\n   raise exc\n   \n def _generate_next_value_(name,start,count,last_values):\n  for last_value in reversed(last_values):\n   try :\n    return last_value+1\n   except TypeError:\n    pass\n  else :\n   return start\n   \n @classmethod\n def _missing_(cls,value):\n  return None\n  \n def __repr__(self):\n  return \"<%s.%s: %r>\"%(\n  self.__class__.__name__,self._name_,self._value_)\n  \n def __str__(self):\n  return \"%s.%s\"%(self.__class__.__name__,self._name_)\n  \n def __dir__(self):\n  added_behavior=[\n  m\n  for cls in self.__class__.mro()\n  for m in cls.__dict__\n  if m[0]!='_'and m not in self._member_map_\n  ]\n  return (['__class__','__doc__','__module__']+added_behavior)\n  \n def __format__(self,format_spec):\n \n \n \n \n \n  str_overridden=type(self).__str__ !=Enum.__str__\n  if self._member_type_ is object or str_overridden:\n   cls=str\n   val=str(self)\n   \n  else :\n   cls=self._member_type_\n   val=self._value_\n  return cls.__format__(val,format_spec)\n  \n def __hash__(self):\n  return hash(self._name_)\n  \n def __reduce_ex__(self,proto):\n  return self.__class__,(self._value_,)\n  \n  \n  \n  \n  \n  \n  \n  \n @DynamicClassAttribute\n def name(self):\n  ''\n  return self._name_\n  \n @DynamicClassAttribute\n def value(self):\n  ''\n  return self._value_\n  \n  \nclass IntEnum(int,Enum):\n ''\n \n \ndef _reduce_ex_by_name(self,proto):\n return self.name\n \nclass Flag(Enum):\n ''\n \n def _generate_next_value_(name,start,count,last_values):\n  ''\n\n\n\n\n\n\n  \n  if not count:\n   return start if start is not None else 1\n  for last_value in reversed(last_values):\n   try :\n    high_bit=_high_bit(last_value)\n    break\n   except Exception:\n    raise TypeError('Invalid Flag value: %r'%last_value)from None\n  return 2 **(high_bit+1)\n  \n @classmethod\n def _missing_(cls,value):\n  original_value=value\n  if value <0:\n   value=~value\n  possible_member=cls._create_pseudo_member_(value)\n  if original_value <0:\n   possible_member=~possible_member\n  return possible_member\n  \n @classmethod\n def _create_pseudo_member_(cls,value):\n  ''\n\n  \n  pseudo_member=cls._value2member_map_.get(value,None )\n  if pseudo_member is None :\n  \n   _,extra_flags=_decompose(cls,value)\n   if extra_flags:\n    raise ValueError(\"%r is not a valid %s\"%(value,cls.__qualname__))\n    \n   pseudo_member=object.__new__(cls)\n   pseudo_member._name_=None\n   pseudo_member._value_=value\n   \n   \n   pseudo_member=cls._value2member_map_.setdefault(value,pseudo_member)\n  return pseudo_member\n  \n def __contains__(self,other):\n  if not isinstance(other,self.__class__):\n   raise TypeError(\n   \"unsupported operand type(s) for 'in': '%s' and '%s'\"%(\n   type(other).__qualname__,self.__class__.__qualname__))\n  return other._value_&self._value_ ==other._value_\n  \n def __repr__(self):\n  cls=self.__class__\n  if self._name_ is not None :\n   return '<%s.%s: %r>'%(cls.__name__,self._name_,self._value_)\n  members,uncovered=_decompose(cls,self._value_)\n  return '<%s.%s: %r>'%(\n  cls.__name__,\n  '|'.join([str(m._name_ or m._value_)for m in members]),\n  self._value_,\n  )\n  \n def __str__(self):\n  cls=self.__class__\n  if self._name_ is not None :\n   return '%s.%s'%(cls.__name__,self._name_)\n  members,uncovered=_decompose(cls,self._value_)\n  if len(members)==1 and members[0]._name_ is None :\n   return '%s.%r'%(cls.__name__,members[0]._value_)\n  else :\n   return '%s.%s'%(\n   cls.__name__,\n   '|'.join([str(m._name_ or m._value_)for m in members]),\n   )\n   \n def __bool__(self):\n  return bool(self._value_)\n  \n def __or__(self,other):\n  if not isinstance(other,self.__class__):\n   return NotImplemented\n  return self.__class__(self._value_ |other._value_)\n  \n def __and__(self,other):\n  if not isinstance(other,self.__class__):\n   return NotImplemented\n  return self.__class__(self._value_&other._value_)\n  \n def __xor__(self,other):\n  if not isinstance(other,self.__class__):\n   return NotImplemented\n  return self.__class__(self._value_ ^other._value_)\n  \n def __invert__(self):\n  members,uncovered=_decompose(self.__class__,self._value_)\n  inverted=self.__class__(0)\n  for m in self.__class__:\n   if m not in members and not (m._value_&self._value_):\n    inverted=inverted |m\n  return self.__class__(inverted)\n  \n  \nclass IntFlag(int,Flag):\n ''\n \n @classmethod\n def _missing_(cls,value):\n  if not isinstance(value,int):\n   raise ValueError(\"%r is not a valid %s\"%(value,cls.__qualname__))\n  new_member=cls._create_pseudo_member_(value)\n  return new_member\n  \n @classmethod\n def _create_pseudo_member_(cls,value):\n  pseudo_member=cls._value2member_map_.get(value,None )\n  if pseudo_member is None :\n   need_to_create=[value]\n   \n   _,extra_flags=_decompose(cls,value)\n   \n   while extra_flags:\n   \n    bit=_high_bit(extra_flags)\n    flag_value=2 **bit\n    if (flag_value not in cls._value2member_map_ and\n    flag_value not in need_to_create\n    ):\n     need_to_create.append(flag_value)\n    if extra_flags ==-flag_value:\n     extra_flags=0\n    else :\n     extra_flags ^=flag_value\n   for value in reversed(need_to_create):\n   \n    pseudo_member=int.__new__(cls,value)\n    pseudo_member._name_=None\n    pseudo_member._value_=value\n    \n    \n    pseudo_member=cls._value2member_map_.setdefault(value,pseudo_member)\n  return pseudo_member\n  \n def __or__(self,other):\n  if not isinstance(other,(self.__class__,int)):\n   return NotImplemented\n  result=self.__class__(self._value_ |self.__class__(other)._value_)\n  return result\n  \n def __and__(self,other):\n  if not isinstance(other,(self.__class__,int)):\n   return NotImplemented\n  return self.__class__(self._value_&self.__class__(other)._value_)\n  \n def __xor__(self,other):\n  if not isinstance(other,(self.__class__,int)):\n   return NotImplemented\n  return self.__class__(self._value_ ^self.__class__(other)._value_)\n  \n __ror__=__or__\n __rand__=__and__\n __rxor__=__xor__\n \n def __invert__(self):\n  result=self.__class__(~self._value_)\n  return result\n  \n  \ndef _high_bit(value):\n ''\n return value.bit_length()-1\n \ndef unique(enumeration):\n ''\n duplicates=[]\n for name,member in enumeration.__members__.items():\n  if name !=member.name:\n   duplicates.append((name,member.name))\n if duplicates:\n  alias_details=', '.join(\n  [\"%s -> %s\"%(alias,name)for (alias,name)in duplicates])\n  raise ValueError('duplicate values found in %r: %s'%\n  (enumeration,alias_details))\n return enumeration\n \ndef _decompose(flag,value):\n ''\n \n not_covered=value\n negative=value <0\n members=[]\n for member in flag:\n  member_value=member.value\n  if member_value and member_value&value ==member_value:\n   members.append(member)\n   not_covered &=~member_value\n if not negative:\n  tmp=not_covered\n  while tmp:\n   flag_value=2 **_high_bit(tmp)\n   if flag_value in flag._value2member_map_:\n    members.append(flag._value2member_map_[flag_value])\n    not_covered &=~flag_value\n   tmp &=~flag_value\n if not members and value in flag._value2member_map_:\n  members.append(flag._value2member_map_[value])\n members.sort(key=lambda m:m._value_,reverse=True )\n if len(members)>1 and members[0].value ==value:\n \n  members.pop(0)\n return members,not_covered\n", ["sys", "types"]],
     "errno": [".py", "''\n\n\n\n\n\n\n\n\n\n\n\n\n\nE2BIG=7\n\nEACCES=13\n\nEADDRINUSE=10048\n\nEADDRNOTAVAIL=10049\n\nEAFNOSUPPORT=10047\n\nEAGAIN=11\n\nEALREADY=10037\n\nEBADF=9\n\nEBADMSG=104\n\nEBUSY=16\n\nECANCELED=105\n\nECHILD=10\n\nECONNABORTED=10053\n\nECONNREFUSED=10061\n\nECONNRESET=10054\n\nEDEADLK=36\n\nEDEADLOCK=36\n\nEDESTADDRREQ=10039\n\nEDOM=33\n\nEDQUOT=10069\n\nEEXIST=17\n\nEFAULT=14\n\nEFBIG=27\n\nEHOSTDOWN=10064\n\nEHOSTUNREACH=10065\n\nEIDRM=111\n\nEILSEQ=42\n\nEINPROGRESS=10036\n\nEINTR=4\n\nEINVAL=22\n\nEIO=5\n\nEISCONN=10056\n\nEISDIR=21\n\nELOOP=10062\n\nEMFILE=24\n\nEMLINK=31\n\nEMSGSIZE=10040\n\nENAMETOOLONG=38\n\nENETDOWN=10050\n\nENETRESET=10052\n\nENETUNREACH=10051\n\nENFILE=23\n\nENOBUFS=10055\n\nENODATA=120\n\nENODEV=19\n\nENOENT=2\n\nENOEXEC=8\n\nENOLCK=39\n\nENOLINK=121\n\nENOMEM=12\n\nENOMSG=122\n\nENOPROTOOPT=10042\n\nENOSPC=28\n\nENOSR=124\n\nENOSTR=125\n\nENOSYS=40\n\nENOTCONN=10057\n\nENOTDIR=20\n\nENOTEMPTY=41\n\nENOTRECOVERABLE=127\n\nENOTSOCK=10038\n\nENOTSUP=129\n\nENOTTY=25\n\nENXIO=6\n\nEOPNOTSUPP=10045\n\nEOVERFLOW=132\n\nEOWNERDEAD=133\n\nEPERM=1\n\nEPFNOSUPPORT=10046\n\nEPIPE=32\n\nEPROTO=134\n\nEPROTONOSUPPORT=10043\n\nEPROTOTYPE=10041\n\nERANGE=34\n\nEREMOTE=10071\n\nEROFS=30\n\nESHUTDOWN=10058\n\nESOCKTNOSUPPORT=10044\n\nESPIPE=29\n\nESRCH=3\n\nESTALE=10070\n\nETIME=137\n\nETIMEDOUT=10060\n\nETOOMANYREFS=10059\n\nETXTBSY=139\n\nEUSERS=10068\n\nEWOULDBLOCK=10035\n\nEXDEV=18\n\nWSABASEERR=10000\n\nWSAEACCES=10013\n\nWSAEADDRINUSE=10048\n\nWSAEADDRNOTAVAIL=10049\n\nWSAEAFNOSUPPORT=10047\n\nWSAEALREADY=10037\n\nWSAEBADF=10009\n\nWSAECONNABORTED=10053\n\nWSAECONNREFUSED=10061\n\nWSAECONNRESET=10054\n\nWSAEDESTADDRREQ=10039\n\nWSAEDISCON=10101\n\nWSAEDQUOT=10069\n\nWSAEFAULT=10014\n\nWSAEHOSTDOWN=10064\n\nWSAEHOSTUNREACH=10065\n\nWSAEINPROGRESS=10036\n\nWSAEINTR=10004\n\nWSAEINVAL=10022\n\nWSAEISCONN=10056\n\nWSAELOOP=10062\n\nWSAEMFILE=10024\n\nWSAEMSGSIZE=10040\n\nWSAENAMETOOLONG=10063\n\nWSAENETDOWN=10050\n\nWSAENETRESET=10052\n\nWSAENETUNREACH=10051\n\nWSAENOBUFS=10055\n\nWSAENOPROTOOPT=10042\n\nWSAENOTCONN=10057\n\nWSAENOTEMPTY=10066\n\nWSAENOTSOCK=10038\n\nWSAEOPNOTSUPP=10045\n\nWSAEPFNOSUPPORT=10046\n\nWSAEPROCLIM=10067\n\nWSAEPROTONOSUPPORT=10043\n\nWSAEPROTOTYPE=10041\n\nWSAEREMOTE=10071\n\nWSAESHUTDOWN=10058\n\nWSAESOCKTNOSUPPORT=10044\n\nWSAESTALE=10070\n\nWSAETIMEDOUT=10060\n\nWSAETOOMANYREFS=10059\n\nWSAEUSERS=10068\n\nWSAEWOULDBLOCK=10035\n\nWSANOTINITIALISED=10093\n\nWSASYSNOTREADY=10091\n\nWSAVERNOTSUPPORTED=10092\n\nerrorcode={v:k for (k,v)in globals().items()if k ==k.upper()}\n", []],
     "external_import": [".py", "import os\nfrom browser import doc\nimport urllib.request\n\n\n\n\n\nclass ModuleFinder:\n def __init__(self,path_entry):\n  print(\"external_import here..\")\n  \n  self._module=None\n  if path_entry.startswith('http://'):\n   self.path_entry=path_entry\n  else :\n   raise ImportError()\n   \n def __str__(self):\n  return '<%s for \"%s\">'%(self.__class__.__name__,self.path_entry)\n  \n def find_module(self,fullname,path=None ):\n  path=path or self.path_entry\n  \n  for _ext in ['js','pyj','py']:\n   _fp,_url,_headers=urllib.request.urlopen(path+'/'+'%s.%s'%(fullname,_ext))\n   self._module=_fp.read()\n   _fp.close()\n   if self._module is not None :\n    print(\"module found at %s:%s\"%(path,fullname))\n    return ModuleLoader(path,fullname,self._module)\n    \n  print('module %s not found'%fullname)\n  raise ImportError()\n  return None\n  \nclass ModuleLoader:\n ''\n \n def __init__(self,filepath,name,module_source):\n  self._filepath=filepath\n  self._name=name\n  self._module_source=module_source\n  \n def get_source(self):\n  return self._module_source\n  \n def is_package(self):\n  return '.'in self._name\n  \n def load_module(self):\n  if self._name in sys.modules:\n  \n   mod=sys.modules[self._name]\n   return mod\n   \n  _src=self.get_source()\n  if self._filepath.endswith('.js'):\n   mod=JSObject(import_js_module(_src,self._filepath,self._name))\n  elif self._filepath.endswith('.py'):\n   mod=JSObject(import_py_module(_src,self._filepath,self._name))\n  elif self._filepath.endswith('.pyj'):\n   mod=JSObject(import_pyj_module(_src,self._filepath,self._name))\n  else :\n   raise ImportError('Invalid Module: %s'%self._filepath)\n   \n   \n  mod.__file__=self._filepath\n  mod.__name__=self._name\n  mod.__path__=os.path.abspath(self._filepath)\n  mod.__loader__=self\n  mod.__package__='.'.join(self._name.split('.')[:-1])\n  \n  if self.is_package():\n   print('adding path for package')\n   \n   \n   mod.__path__=[self._filepath]\n  else :\n   print('imported as regular module')\n   \n  print('creating a new module object for \"%s\"'%self._name)\n  sys.modules.setdefault(self._name,mod)\n  JSObject(__BRYTHON__.imported)[self._name]=mod\n  \n  return mod\n", ["browser", "os", "urllib.request"]],
@@ -82,15 +82,15 @@
     "getopt": [".py", "''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n__all__=[\"GetoptError\",\"error\",\"getopt\",\"gnu_getopt\"]\n\nimport os\ntry :\n from gettext import gettext as _\nexcept ImportError:\n\n def _(s):return s\n \nclass GetoptError(Exception):\n opt=''\n msg=''\n def __init__(self,msg,opt=''):\n  self.msg=msg\n  self.opt=opt\n  Exception.__init__(self,msg,opt)\n  \n def __str__(self):\n  return self.msg\n  \nerror=GetoptError\n\ndef getopt(args,shortopts,longopts=[]):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n opts=[]\n if type(longopts)==type(\"\"):\n  longopts=[longopts]\n else :\n  longopts=list(longopts)\n while args and args[0].startswith('-')and args[0]!='-':\n  if args[0]=='--':\n   args=args[1:]\n   break\n  if args[0].startswith('--'):\n   opts,args=do_longs(opts,args[0][2:],longopts,args[1:])\n  else :\n   opts,args=do_shorts(opts,args[0][1:],shortopts,args[1:])\n   \n return opts,args\n \ndef gnu_getopt(args,shortopts,longopts=[]):\n ''\n\n\n\n\n\n\n\n\n\n\n\n \n \n opts=[]\n prog_args=[]\n if isinstance(longopts,str):\n  longopts=[longopts]\n else :\n  longopts=list(longopts)\n  \n  \n if shortopts.startswith('+'):\n  shortopts=shortopts[1:]\n  all_options_first=True\n elif os.environ.get(\"POSIXLY_CORRECT\"):\n  all_options_first=True\n else :\n  all_options_first=False\n  \n while args:\n  if args[0]=='--':\n   prog_args +=args[1:]\n   break\n   \n  if args[0][:2]=='--':\n   opts,args=do_longs(opts,args[0][2:],longopts,args[1:])\n  elif args[0][:1]=='-'and args[0]!='-':\n   opts,args=do_shorts(opts,args[0][1:],shortopts,args[1:])\n  else :\n   if all_options_first:\n    prog_args +=args\n    break\n   else :\n    prog_args.append(args[0])\n    args=args[1:]\n    \n return opts,prog_args\n \ndef do_longs(opts,opt,longopts,args):\n try :\n  i=opt.index('=')\n except ValueError:\n  optarg=None\n else :\n  opt,optarg=opt[:i],opt[i+1:]\n  \n has_arg,opt=long_has_args(opt,longopts)\n if has_arg:\n  if optarg is None :\n   if not args:\n    raise GetoptError(_('option --%s requires argument')%opt,opt)\n   optarg,args=args[0],args[1:]\n elif optarg is not None :\n  raise GetoptError(_('option --%s must not have an argument')%opt,opt)\n opts.append(('--'+opt,optarg or ''))\n return opts,args\n \n \n \n \ndef long_has_args(opt,longopts):\n possibilities=[o for o in longopts if o.startswith(opt)]\n if not possibilities:\n  raise GetoptError(_('option --%s not recognized')%opt,opt)\n  \n if opt in possibilities:\n  return False ,opt\n elif opt+'='in possibilities:\n  return True ,opt\n  \n if len(possibilities)>1:\n \n \n  raise GetoptError(_('option --%s not a unique prefix')%opt,opt)\n assert len(possibilities)==1\n unique_match=possibilities[0]\n has_arg=unique_match.endswith('=')\n if has_arg:\n  unique_match=unique_match[:-1]\n return has_arg,unique_match\n \ndef do_shorts(opts,optstring,shortopts,args):\n while optstring !='':\n  opt,optstring=optstring[0],optstring[1:]\n  if short_has_arg(opt,shortopts):\n   if optstring =='':\n    if not args:\n     raise GetoptError(_('option -%s requires argument')%opt,\n     opt)\n    optstring,args=args[0],args[1:]\n   optarg,optstring=optstring,''\n  else :\n   optarg=''\n  opts.append(('-'+opt,optarg))\n return opts,args\n \ndef short_has_arg(opt,shortopts):\n for i in range(len(shortopts)):\n  if opt ==shortopts[i]!=':':\n   return shortopts.startswith(':',i+1)\n raise GetoptError(_('option -%s not recognized')%opt,opt)\n \nif __name__ =='__main__':\n import sys\n print(getopt(sys.argv[1:],\"a:b\",[\"alpha=\",\"beta\"]))\n", ["gettext", "os", "sys"]],
     "gettext": [".py", "''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nimport os\nimport re\nimport sys\n\n\n__all__=['NullTranslations','GNUTranslations','Catalog',\n'find','translation','install','textdomain','bindtextdomain',\n'bind_textdomain_codeset',\n'dgettext','dngettext','gettext','lgettext','ldgettext',\n'ldngettext','lngettext','ngettext',\n'pgettext','dpgettext','npgettext','dnpgettext',\n]\n\n_default_localedir=os.path.join(sys.base_prefix,'share','locale')\n\n\n\n\n\n\n\n\n\n\n_token_pattern=re.compile(r\"\"\"\n        (?P<WHITESPACES>[ \\t]+)                    | # spaces and horizontal tabs\n        (?P<NUMBER>[0-9]+\\b)                       | # decimal integer\n        (?P<NAME>n\\b)                              | # only n is allowed\n        (?P<PARENTHESIS>[()])                      |\n        (?P<OPERATOR>[-*/%+?:]|[><!]=?|==|&&|\\|\\|) | # !, *, /, %, +, -, <, >,\n                                                     # <=, >=, ==, !=, &&, ||,\n                                                     # ? :\n                                                     # unary and bitwise ops\n                                                     # not allowed\n        (?P<INVALID>\\w+|.)                           # invalid token\n    \"\"\",re.VERBOSE |re.DOTALL)\n\ndef _tokenize(plural):\n for mo in re.finditer(_token_pattern,plural):\n  kind=mo.lastgroup\n  if kind =='WHITESPACES':\n   continue\n  value=mo.group(kind)\n  if kind =='INVALID':\n   raise ValueError('invalid token in plural form: %s'%value)\n  yield value\n yield ''\n \ndef _error(value):\n if value:\n  return ValueError('unexpected token in plural form: %s'%value)\n else :\n  return ValueError('unexpected end of plural form')\n  \n_binary_ops=(\n('||',),\n('&&',),\n('==','!='),\n('<','>','<=','>='),\n('+','-'),\n('*','/','%'),\n)\n_binary_ops={op:i for i,ops in enumerate(_binary_ops,1)for op in ops}\n_c2py_ops={'||':'or','&&':'and','/':'//'}\n\ndef _parse(tokens,priority=-1):\n result=''\n nexttok=next(tokens)\n while nexttok =='!':\n  result +='not '\n  nexttok=next(tokens)\n  \n if nexttok =='(':\n  sub,nexttok=_parse(tokens)\n  result='%s(%s)'%(result,sub)\n  if nexttok !=')':\n   raise ValueError('unbalanced parenthesis in plural form')\n elif nexttok =='n':\n  result='%s%s'%(result,nexttok)\n else :\n  try :\n   value=int(nexttok,10)\n  except ValueError:\n   raise _error(nexttok)from None\n  result='%s%d'%(result,value)\n nexttok=next(tokens)\n \n j=100\n while nexttok in _binary_ops:\n  i=_binary_ops[nexttok]\n  if i <priority:\n   break\n   \n  if i in (3,4)and j in (3,4):\n   result='(%s)'%result\n   \n  op=_c2py_ops.get(nexttok,nexttok)\n  right,nexttok=_parse(tokens,i+1)\n  result='%s %s %s'%(result,op,right)\n  j=i\n if j ==priority ==4:\n  result='(%s)'%result\n  \n if nexttok =='?'and priority <=0:\n  if_true,nexttok=_parse(tokens,0)\n  if nexttok !=':':\n   raise _error(nexttok)\n  if_false,nexttok=_parse(tokens)\n  result='%s if %s else %s'%(if_true,result,if_false)\n  if priority ==0:\n   result='(%s)'%result\n   \n return result,nexttok\n \ndef _as_int(n):\n try :\n  i=round(n)\n except TypeError:\n  raise TypeError('Plural value must be an integer, got %s'%\n  (n.__class__.__name__,))from None\n import warnings\n warnings.warn('Plural value must be an integer, got %s'%\n (n.__class__.__name__,),\n DeprecationWarning,4)\n return n\n \ndef c2py(plural):\n ''\n\n \n \n if len(plural)>1000:\n  raise ValueError('plural form expression is too long')\n try :\n  result,nexttok=_parse(_tokenize(plural))\n  if nexttok:\n   raise _error(nexttok)\n   \n  depth=0\n  for c in result:\n   if c =='(':\n    depth +=1\n    if depth >20:\n    \n    \n     raise ValueError('plural form expression is too complex')\n   elif c ==')':\n    depth -=1\n    \n  ns={'_as_int':_as_int}\n  exec('''if True:\n            def func(n):\n                if not isinstance(n, int):\n                    n = _as_int(n)\n                return int(%s)\n            '''%result,ns)\n  return ns['func']\n except RecursionError:\n \n  raise ValueError('plural form expression is too complex')\n  \n  \ndef _expand_lang(loc):\n import locale\n loc=locale.normalize(loc)\n COMPONENT_CODESET=1 <<0\n COMPONENT_TERRITORY=1 <<1\n COMPONENT_MODIFIER=1 <<2\n \n mask=0\n pos=loc.find('@')\n if pos >=0:\n  modifier=loc[pos:]\n  loc=loc[:pos]\n  mask |=COMPONENT_MODIFIER\n else :\n  modifier=''\n pos=loc.find('.')\n if pos >=0:\n  codeset=loc[pos:]\n  loc=loc[:pos]\n  mask |=COMPONENT_CODESET\n else :\n  codeset=''\n pos=loc.find('_')\n if pos >=0:\n  territory=loc[pos:]\n  loc=loc[:pos]\n  mask |=COMPONENT_TERRITORY\n else :\n  territory=''\n language=loc\n ret=[]\n for i in range(mask+1):\n  if not (i&~mask):\n   val=language\n   if i&COMPONENT_TERRITORY:val +=territory\n   if i&COMPONENT_CODESET:val +=codeset\n   if i&COMPONENT_MODIFIER:val +=modifier\n   ret.append(val)\n ret.reverse()\n return ret\n \n \n \nclass NullTranslations:\n def __init__(self,fp=None ):\n  self._info={}\n  self._charset=None\n  self._output_charset=None\n  self._fallback=None\n  if fp is not None :\n   self._parse(fp)\n   \n def _parse(self,fp):\n  pass\n  \n def add_fallback(self,fallback):\n  if self._fallback:\n   self._fallback.add_fallback(fallback)\n  else :\n   self._fallback=fallback\n   \n def gettext(self,message):\n  if self._fallback:\n   return self._fallback.gettext(message)\n  return message\n  \n def lgettext(self,message):\n  import warnings\n  warnings.warn('lgettext() is deprecated, use gettext() instead',\n  DeprecationWarning,2)\n  import locale\n  if self._fallback:\n   with warnings.catch_warnings():\n    warnings.filterwarnings('ignore',r'.*\\blgettext\\b.*',\n    DeprecationWarning)\n    return self._fallback.lgettext(message)\n  if self._output_charset:\n   return message.encode(self._output_charset)\n  return message.encode(locale.getpreferredencoding())\n  \n def ngettext(self,msgid1,msgid2,n):\n  if self._fallback:\n   return self._fallback.ngettext(msgid1,msgid2,n)\n  if n ==1:\n   return msgid1\n  else :\n   return msgid2\n   \n def lngettext(self,msgid1,msgid2,n):\n  import warnings\n  warnings.warn('lngettext() is deprecated, use ngettext() instead',\n  DeprecationWarning,2)\n  import locale\n  if self._fallback:\n   with warnings.catch_warnings():\n    warnings.filterwarnings('ignore',r'.*\\blngettext\\b.*',\n    DeprecationWarning)\n    return self._fallback.lngettext(msgid1,msgid2,n)\n  if n ==1:\n   tmsg=msgid1\n  else :\n   tmsg=msgid2\n  if self._output_charset:\n   return tmsg.encode(self._output_charset)\n  return tmsg.encode(locale.getpreferredencoding())\n  \n def pgettext(self,context,message):\n  if self._fallback:\n   return self._fallback.pgettext(context,message)\n  return message\n  \n def npgettext(self,context,msgid1,msgid2,n):\n  if self._fallback:\n   return self._fallback.npgettext(context,msgid1,msgid2,n)\n  if n ==1:\n   return msgid1\n  else :\n   return msgid2\n   \n def info(self):\n  return self._info\n  \n def charset(self):\n  return self._charset\n  \n def output_charset(self):\n  import warnings\n  warnings.warn('output_charset() is deprecated',\n  DeprecationWarning,2)\n  return self._output_charset\n  \n def set_output_charset(self,charset):\n  import warnings\n  warnings.warn('set_output_charset() is deprecated',\n  DeprecationWarning,2)\n  self._output_charset=charset\n  \n def install(self,names=None ):\n  import builtins\n  builtins.__dict__['_']=self.gettext\n  if names is not None :\n   allowed={'gettext','lgettext','lngettext',\n   'ngettext','npgettext','pgettext'}\n   for name in allowed&set(names):\n    builtins.__dict__[name]=getattr(self,name)\n    \n    \nclass GNUTranslations(NullTranslations):\n\n LE_MAGIC=0x950412de\n BE_MAGIC=0xde120495\n \n \n \n CONTEXT=\"%s\\x04%s\"\n \n \n VERSIONS=(0,1)\n \n def _get_versions(self,version):\n  ''\n  return (version >>16,version&0xffff)\n  \n def _parse(self,fp):\n  ''\n  \n  \n  from struct import unpack\n  filename=getattr(fp,'name','')\n  \n  \n  self._catalog=catalog={}\n  self.plural=lambda n:int(n !=1)\n  buf=fp.read()\n  buflen=len(buf)\n  \n  magic=unpack('<I',buf[:4])[0]\n  if magic ==self.LE_MAGIC:\n   version,msgcount,masteridx,transidx=unpack('<4I',buf[4:20])\n   ii='<II'\n  elif magic ==self.BE_MAGIC:\n   version,msgcount,masteridx,transidx=unpack('>4I',buf[4:20])\n   ii='>II'\n  else :\n   raise OSError(0,'Bad magic number',filename)\n   \n  major_version,minor_version=self._get_versions(version)\n  \n  if major_version not in self.VERSIONS:\n   raise OSError(0,'Bad version number '+str(major_version),filename)\n   \n   \n   \n  for i in range(0,msgcount):\n   mlen,moff=unpack(ii,buf[masteridx:masteridx+8])\n   mend=moff+mlen\n   tlen,toff=unpack(ii,buf[transidx:transidx+8])\n   tend=toff+tlen\n   if mend <buflen and tend <buflen:\n    msg=buf[moff:mend]\n    tmsg=buf[toff:tend]\n   else :\n    raise OSError(0,'File is corrupt',filename)\n    \n   if mlen ==0:\n   \n    lastk=None\n    for b_item in tmsg.split(b'\\n'):\n     item=b_item.decode().strip()\n     if not item:\n      continue\n      \n     if item.startswith('#-#-#-#-#')and item.endswith('#-#-#-#-#'):\n      continue\n     k=v=None\n     if ':'in item:\n      k,v=item.split(':',1)\n      k=k.strip().lower()\n      v=v.strip()\n      self._info[k]=v\n      lastk=k\n     elif lastk:\n      self._info[lastk]+='\\n'+item\n     if k =='content-type':\n      self._charset=v.split('charset=')[1]\n     elif k =='plural-forms':\n      v=v.split(';')\n      plural=v[1].split('plural=')[1]\n      self.plural=c2py(plural)\n      \n      \n      \n      \n      \n      \n      \n      \n      \n   charset=self._charset or 'ascii'\n   if b'\\x00'in msg:\n   \n    msgid1,msgid2=msg.split(b'\\x00')\n    tmsg=tmsg.split(b'\\x00')\n    msgid1=str(msgid1,charset)\n    for i,x in enumerate(tmsg):\n     catalog[(msgid1,i)]=str(x,charset)\n   else :\n    catalog[str(msg,charset)]=str(tmsg,charset)\n    \n   masteridx +=8\n   transidx +=8\n   \n def lgettext(self,message):\n  import warnings\n  warnings.warn('lgettext() is deprecated, use gettext() instead',\n  DeprecationWarning,2)\n  import locale\n  missing=object()\n  tmsg=self._catalog.get(message,missing)\n  if tmsg is missing:\n   if self._fallback:\n    return self._fallback.lgettext(message)\n   tmsg=message\n  if self._output_charset:\n   return tmsg.encode(self._output_charset)\n  return tmsg.encode(locale.getpreferredencoding())\n  \n def lngettext(self,msgid1,msgid2,n):\n  import warnings\n  warnings.warn('lngettext() is deprecated, use ngettext() instead',\n  DeprecationWarning,2)\n  import locale\n  try :\n   tmsg=self._catalog[(msgid1,self.plural(n))]\n  except KeyError:\n   if self._fallback:\n    return self._fallback.lngettext(msgid1,msgid2,n)\n   if n ==1:\n    tmsg=msgid1\n   else :\n    tmsg=msgid2\n  if self._output_charset:\n   return tmsg.encode(self._output_charset)\n  return tmsg.encode(locale.getpreferredencoding())\n  \n def gettext(self,message):\n  missing=object()\n  tmsg=self._catalog.get(message,missing)\n  if tmsg is missing:\n   if self._fallback:\n    return self._fallback.gettext(message)\n   return message\n  return tmsg\n  \n def ngettext(self,msgid1,msgid2,n):\n  try :\n   tmsg=self._catalog[(msgid1,self.plural(n))]\n  except KeyError:\n   if self._fallback:\n    return self._fallback.ngettext(msgid1,msgid2,n)\n   if n ==1:\n    tmsg=msgid1\n   else :\n    tmsg=msgid2\n  return tmsg\n  \n def pgettext(self,context,message):\n  ctxt_msg_id=self.CONTEXT %(context,message)\n  missing=object()\n  tmsg=self._catalog.get(ctxt_msg_id,missing)\n  if tmsg is missing:\n   if self._fallback:\n    return self._fallback.pgettext(context,message)\n   return message\n  return tmsg\n  \n def npgettext(self,context,msgid1,msgid2,n):\n  ctxt_msg_id=self.CONTEXT %(context,msgid1)\n  try :\n   tmsg=self._catalog[ctxt_msg_id,self.plural(n)]\n  except KeyError:\n   if self._fallback:\n    return self._fallback.npgettext(context,msgid1,msgid2,n)\n   if n ==1:\n    tmsg=msgid1\n   else :\n    tmsg=msgid2\n  return tmsg\n  \n  \n  \ndef find(domain,localedir=None ,languages=None ,all=False ):\n\n if localedir is None :\n  localedir=_default_localedir\n if languages is None :\n  languages=[]\n  for envar in ('LANGUAGE','LC_ALL','LC_MESSAGES','LANG'):\n   val=os.environ.get(envar)\n   if val:\n    languages=val.split(':')\n    break\n  if 'C'not in languages:\n   languages.append('C')\n   \n nelangs=[]\n for lang in languages:\n  for nelang in _expand_lang(lang):\n   if nelang not in nelangs:\n    nelangs.append(nelang)\n    \n if all:\n  result=[]\n else :\n  result=None\n for lang in nelangs:\n  if lang =='C':\n   break\n  mofile=os.path.join(localedir,lang,'LC_MESSAGES','%s.mo'%domain)\n  if os.path.exists(mofile):\n   if all:\n    result.append(mofile)\n   else :\n    return mofile\n return result\n \n \n \n \n_translations={}\n_unspecified=['unspecified']\n\ndef translation(domain,localedir=None ,languages=None ,\nclass_=None ,fallback=False ,codeset=_unspecified):\n if class_ is None :\n  class_=GNUTranslations\n mofiles=find(domain,localedir,languages,all=True )\n if not mofiles:\n  if fallback:\n   return NullTranslations()\n  from errno import ENOENT\n  raise FileNotFoundError(ENOENT,\n  'No translation file found for domain',domain)\n  \n  \n result=None\n for mofile in mofiles:\n  key=(class_,os.path.abspath(mofile))\n  t=_translations.get(key)\n  if t is None :\n   with open(mofile,'rb')as fp:\n    t=_translations.setdefault(key,class_(fp))\n    \n    \n    \n    \n    \n  import copy\n  t=copy.copy(t)\n  if codeset is not _unspecified:\n   import warnings\n   warnings.warn('parameter codeset is deprecated',\n   DeprecationWarning,2)\n   if codeset:\n    with warnings.catch_warnings():\n     warnings.filterwarnings('ignore',r'.*\\bset_output_charset\\b.*',\n     DeprecationWarning)\n     t.set_output_charset(codeset)\n  if result is None :\n   result=t\n  else :\n   result.add_fallback(t)\n return result\n \n \ndef install(domain,localedir=None ,codeset=_unspecified,names=None ):\n t=translation(domain,localedir,fallback=True ,codeset=codeset)\n t.install(names)\n \n \n \n \n_localedirs={}\n\n_localecodesets={}\n\n_current_domain='messages'\n\n\ndef textdomain(domain=None ):\n global _current_domain\n if domain is not None :\n  _current_domain=domain\n return _current_domain\n \n \ndef bindtextdomain(domain,localedir=None ):\n global _localedirs\n if localedir is not None :\n  _localedirs[domain]=localedir\n return _localedirs.get(domain,_default_localedir)\n \n \ndef bind_textdomain_codeset(domain,codeset=None ):\n import warnings\n warnings.warn('bind_textdomain_codeset() is deprecated',\n DeprecationWarning,2)\n global _localecodesets\n if codeset is not None :\n  _localecodesets[domain]=codeset\n return _localecodesets.get(domain)\n \n \ndef dgettext(domain,message):\n try :\n  t=translation(domain,_localedirs.get(domain,None ))\n except OSError:\n  return message\n return t.gettext(message)\n \ndef ldgettext(domain,message):\n import warnings\n warnings.warn('ldgettext() is deprecated, use dgettext() instead',\n DeprecationWarning,2)\n import locale\n codeset=_localecodesets.get(domain)\n try :\n  with warnings.catch_warnings():\n   warnings.filterwarnings('ignore',r'.*\\bparameter codeset\\b.*',\n   DeprecationWarning)\n   t=translation(domain,_localedirs.get(domain,None ),codeset=codeset)\n except OSError:\n  return message.encode(codeset or locale.getpreferredencoding())\n with warnings.catch_warnings():\n  warnings.filterwarnings('ignore',r'.*\\blgettext\\b.*',\n  DeprecationWarning)\n  return t.lgettext(message)\n  \ndef dngettext(domain,msgid1,msgid2,n):\n try :\n  t=translation(domain,_localedirs.get(domain,None ))\n except OSError:\n  if n ==1:\n   return msgid1\n  else :\n   return msgid2\n return t.ngettext(msgid1,msgid2,n)\n \ndef ldngettext(domain,msgid1,msgid2,n):\n import warnings\n warnings.warn('ldngettext() is deprecated, use dngettext() instead',\n DeprecationWarning,2)\n import locale\n codeset=_localecodesets.get(domain)\n try :\n  with warnings.catch_warnings():\n   warnings.filterwarnings('ignore',r'.*\\bparameter codeset\\b.*',\n   DeprecationWarning)\n   t=translation(domain,_localedirs.get(domain,None ),codeset=codeset)\n except OSError:\n  if n ==1:\n   tmsg=msgid1\n  else :\n   tmsg=msgid2\n  return tmsg.encode(codeset or locale.getpreferredencoding())\n with warnings.catch_warnings():\n  warnings.filterwarnings('ignore',r'.*\\blngettext\\b.*',\n  DeprecationWarning)\n  return t.lngettext(msgid1,msgid2,n)\n  \n  \ndef dpgettext(domain,context,message):\n try :\n  t=translation(domain,_localedirs.get(domain,None ))\n except OSError:\n  return message\n return t.pgettext(context,message)\n \n \ndef dnpgettext(domain,context,msgid1,msgid2,n):\n try :\n  t=translation(domain,_localedirs.get(domain,None ))\n except OSError:\n  if n ==1:\n   return msgid1\n  else :\n   return msgid2\n return t.npgettext(context,msgid1,msgid2,n)\n \n \ndef gettext(message):\n return dgettext(_current_domain,message)\n \ndef lgettext(message):\n import warnings\n warnings.warn('lgettext() is deprecated, use gettext() instead',\n DeprecationWarning,2)\n with warnings.catch_warnings():\n  warnings.filterwarnings('ignore',r'.*\\bldgettext\\b.*',\n  DeprecationWarning)\n  return ldgettext(_current_domain,message)\n  \ndef ngettext(msgid1,msgid2,n):\n return dngettext(_current_domain,msgid1,msgid2,n)\n \ndef lngettext(msgid1,msgid2,n):\n import warnings\n warnings.warn('lngettext() is deprecated, use ngettext() instead',\n DeprecationWarning,2)\n with warnings.catch_warnings():\n  warnings.filterwarnings('ignore',r'.*\\bldngettext\\b.*',\n  DeprecationWarning)\n  return ldngettext(_current_domain,msgid1,msgid2,n)\n  \n  \ndef pgettext(context,message):\n return dpgettext(_current_domain,context,message)\n \n \ndef npgettext(context,msgid1,msgid2,n):\n return dnpgettext(_current_domain,context,msgid1,msgid2,n)\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \nCatalog=translation\n", ["builtins", "copy", "errno", "locale", "os", "re", "struct", "sys", "warnings"]],
     "glob": [".py", "''\n\nimport os\nimport re\nimport fnmatch\nimport sys\n\n__all__=[\"glob\",\"iglob\",\"escape\"]\n\ndef glob(pathname,*,recursive=False ):\n ''\n\n\n\n\n\n\n\n\n \n return list(iglob(pathname,recursive=recursive))\n \ndef iglob(pathname,*,recursive=False ):\n ''\n\n\n\n\n\n\n\n\n \n sys.audit(\"glob.glob\",pathname,recursive)\n it=_iglob(pathname,recursive,False )\n if recursive and _isrecursive(pathname):\n  s=next(it)\n  assert not s\n return it\n \ndef _iglob(pathname,recursive,dironly):\n dirname,basename=os.path.split(pathname)\n if not has_magic(pathname):\n  assert not dironly\n  if basename:\n   if os.path.lexists(pathname):\n    yield pathname\n  else :\n  \n   if os.path.isdir(dirname):\n    yield pathname\n  return\n if not dirname:\n  if recursive and _isrecursive(basename):\n   yield from _glob2(dirname,basename,dironly)\n  else :\n   yield from _glob1(dirname,basename,dironly)\n  return\n  \n  \n  \n if dirname !=pathname and has_magic(dirname):\n  dirs=_iglob(dirname,recursive,True )\n else :\n  dirs=[dirname]\n if has_magic(basename):\n  if recursive and _isrecursive(basename):\n   glob_in_dir=_glob2\n  else :\n   glob_in_dir=_glob1\n else :\n  glob_in_dir=_glob0\n for dirname in dirs:\n  for name in glob_in_dir(dirname,basename,dironly):\n   yield os.path.join(dirname,name)\n   \n   \n   \n   \n   \ndef _glob1(dirname,pattern,dironly):\n names=list(_iterdir(dirname,dironly))\n if not _ishidden(pattern):\n  names=(x for x in names if not _ishidden(x))\n return fnmatch.filter(names,pattern)\n \ndef _glob0(dirname,basename,dironly):\n if not basename:\n \n \n  if os.path.isdir(dirname):\n   return [basename]\n else :\n  if os.path.lexists(os.path.join(dirname,basename)):\n   return [basename]\n return []\n \n \n \ndef glob0(dirname,pattern):\n return _glob0(dirname,pattern,False )\n \ndef glob1(dirname,pattern):\n return _glob1(dirname,pattern,False )\n \n \n \n \ndef _glob2(dirname,pattern,dironly):\n assert _isrecursive(pattern)\n yield pattern[:0]\n yield from _rlistdir(dirname,dironly)\n \n \n \ndef _iterdir(dirname,dironly):\n if not dirname:\n  if isinstance(dirname,bytes):\n   dirname=bytes(os.curdir,'ASCII')\n  else :\n   dirname=os.curdir\n try :\n  with os.scandir(dirname)as it:\n   for entry in it:\n    try :\n     if not dironly or entry.is_dir():\n      yield entry.name\n    except OSError:\n     pass\n except OSError:\n  return\n  \n  \ndef _rlistdir(dirname,dironly):\n names=list(_iterdir(dirname,dironly))\n for x in names:\n  if not _ishidden(x):\n   yield x\n   path=os.path.join(dirname,x)if dirname else x\n   for y in _rlistdir(path,dironly):\n    yield os.path.join(x,y)\n    \n    \nmagic_check=re.compile('([*?[])')\nmagic_check_bytes=re.compile(b'([*?[])')\n\ndef has_magic(s):\n if isinstance(s,bytes):\n  match=magic_check_bytes.search(s)\n else :\n  match=magic_check.search(s)\n return match is not None\n \ndef _ishidden(path):\n return path[0]in ('.',b'.'[0])\n \ndef _isrecursive(pattern):\n if isinstance(pattern,bytes):\n  return pattern ==b'**'\n else :\n  return pattern =='**'\n  \ndef escape(pathname):\n ''\n \n \n \n drive,pathname=os.path.splitdrive(pathname)\n if isinstance(pathname,bytes):\n  pathname=magic_check_bytes.sub(br'[\\1]',pathname)\n else :\n  pathname=magic_check.sub(r'[\\1]',pathname)\n return drive+pathname\n", ["fnmatch", "os", "re", "sys"]],
     "heapq": [".py", "''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n__about__=\"\"\"Heap queues\n\n[explanation by Fran\u00e7ois Pinard]\n\nHeaps are arrays for which a[k] <= a[2*k+1] and a[k] <= a[2*k+2] for\nall k, counting elements from 0.  For the sake of comparison,\nnon-existing elements are considered to be infinite.  The interesting\nproperty of a heap is that a[0] is always its smallest element.\n\nThe strange invariant above is meant to be an efficient memory\nrepresentation for a tournament.  The numbers below are `k', not a[k]:\n\n                                   0\n\n                  1                                 2\n\n          3               4                5               6\n\n      7       8       9       10      11      12      13      14\n\n    15 16   17 18   19 20   21 22   23 24   25 26   27 28   29 30\n\n\nIn the tree above, each cell `k' is topping `2*k+1' and `2*k+2'.  In\na usual binary tournament we see in sports, each cell is the winner\nover the two cells it tops, and we can trace the winner down the tree\nto see all opponents s/he had.  However, in many computer applications\nof such tournaments, we do not need to trace the history of a winner.\nTo be more memory efficient, when a winner is promoted, we try to\nreplace it by something else at a lower level, and the rule becomes\nthat a cell and the two cells it tops contain three different items,\nbut the top cell \"wins\" over the two topped cells.\n\nIf this heap invariant is protected at all time, index 0 is clearly\nthe overall winner.  The simplest algorithmic way to remove it and\nfind the \"next\" winner is to move some loser (let's say cell 30 in the\ndiagram above) into the 0 position, and then percolate this new 0 down\nthe tree, exchanging values, until the invariant is re-established.\nThis is clearly logarithmic on the total number of items in the tree.\nBy iterating over all items, you get an O(n ln n) sort.\n\nA nice feature of this sort is that you can efficiently insert new\nitems while the sort is going on, provided that the inserted items are\nnot \"better\" than the last 0'th element you extracted.  This is\nespecially useful in simulation contexts, where the tree holds all\nincoming events, and the \"win\" condition means the smallest scheduled\ntime.  When an event schedule other events for execution, they are\nscheduled into the future, so they can easily go into the heap.  So, a\nheap is a good structure for implementing schedulers (this is what I\nused for my MIDI sequencer :-).\n\nVarious structures for implementing schedulers have been extensively\nstudied, and heaps are good for this, as they are reasonably speedy,\nthe speed is almost constant, and the worst case is not much different\nthan the average case.  However, there are other representations which\nare more efficient overall, yet the worst cases might be terrible.\n\nHeaps are also very useful in big disk sorts.  You most probably all\nknow that a big sort implies producing \"runs\" (which are pre-sorted\nsequences, which size is usually related to the amount of CPU memory),\nfollowed by a merging passes for these runs, which merging is often\nvery cleverly organised[1].  It is very important that the initial\nsort produces the longest runs possible.  Tournaments are a good way\nto that.  If, using all the memory available to hold a tournament, you\nreplace and percolate items that happen to fit the current run, you'll\nproduce runs which are twice the size of the memory for random input,\nand much better for input fuzzily ordered.\n\nMoreover, if you output the 0'th item on disk and get an input which\nmay not fit in the current tournament (because the value \"wins\" over\nthe last output value), it cannot fit in the heap, so the size of the\nheap decreases.  The freed memory could be cleverly reused immediately\nfor progressively building a second heap, which grows at exactly the\nsame rate the first heap is melting.  When the first heap completely\nvanishes, you switch heaps and start a new run.  Clever and quite\neffective!\n\nIn a word, heaps are useful memory structures to know.  I use them in\na few applications, and I think it is good to keep a `heap' module\naround. :-)\n\n--------------------\n[1] The disk balancing algorithms which are current, nowadays, are\nmore annoying than clever, and this is a consequence of the seeking\ncapabilities of the disks.  On devices which cannot seek, like big\ntape drives, the story was quite different, and one had to be very\nclever to ensure (far in advance) that each tape movement will be the\nmost effective possible (that is, will best participate at\n\"progressing\" the merge).  Some tapes were even able to read\nbackwards, and this was also used to avoid the rewinding time.\nBelieve me, real good tape sorts were quite spectacular to watch!\nFrom all times, sorting has always been a Great Art! :-)\n\"\"\"\n\n__all__=['heappush','heappop','heapify','heapreplace','merge',\n'nlargest','nsmallest','heappushpop']\n\ndef heappush(heap,item):\n ''\n heap.append(item)\n _siftdown(heap,0,len(heap)-1)\n \ndef heappop(heap):\n ''\n lastelt=heap.pop()\n if heap:\n  returnitem=heap[0]\n  heap[0]=lastelt\n  _siftup(heap,0)\n  return returnitem\n return lastelt\n \ndef heapreplace(heap,item):\n ''\n\n\n\n\n\n\n\n\n \n returnitem=heap[0]\n heap[0]=item\n _siftup(heap,0)\n return returnitem\n \ndef heappushpop(heap,item):\n ''\n if heap and heap[0]<item:\n  item,heap[0]=heap[0],item\n  _siftup(heap,0)\n return item\n \ndef heapify(x):\n ''\n n=len(x)\n \n \n \n \n \n for i in reversed(range(n //2)):\n  _siftup(x,i)\n  \ndef _heappop_max(heap):\n ''\n lastelt=heap.pop()\n if heap:\n  returnitem=heap[0]\n  heap[0]=lastelt\n  _siftup_max(heap,0)\n  return returnitem\n return lastelt\n \ndef _heapreplace_max(heap,item):\n ''\n returnitem=heap[0]\n heap[0]=item\n _siftup_max(heap,0)\n return returnitem\n \ndef _heapify_max(x):\n ''\n n=len(x)\n for i in reversed(range(n //2)):\n  _siftup_max(x,i)\n  \n  \n  \n  \ndef _siftdown(heap,startpos,pos):\n newitem=heap[pos]\n \n \n while pos >startpos:\n  parentpos=(pos -1)>>1\n  parent=heap[parentpos]\n  if newitem <parent:\n   heap[pos]=parent\n   pos=parentpos\n   continue\n  break\n heap[pos]=newitem\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \ndef _siftup(heap,pos):\n endpos=len(heap)\n startpos=pos\n newitem=heap[pos]\n \n childpos=2 *pos+1\n while childpos <endpos:\n \n  rightpos=childpos+1\n  if rightpos <endpos and not heap[childpos]<heap[rightpos]:\n   childpos=rightpos\n   \n  heap[pos]=heap[childpos]\n  pos=childpos\n  childpos=2 *pos+1\n  \n  \n heap[pos]=newitem\n _siftdown(heap,startpos,pos)\n \ndef _siftdown_max(heap,startpos,pos):\n ''\n newitem=heap[pos]\n \n \n while pos >startpos:\n  parentpos=(pos -1)>>1\n  parent=heap[parentpos]\n  if parent <newitem:\n   heap[pos]=parent\n   pos=parentpos\n   continue\n  break\n heap[pos]=newitem\n \ndef _siftup_max(heap,pos):\n ''\n endpos=len(heap)\n startpos=pos\n newitem=heap[pos]\n \n childpos=2 *pos+1\n while childpos <endpos:\n \n  rightpos=childpos+1\n  if rightpos <endpos and not heap[rightpos]<heap[childpos]:\n   childpos=rightpos\n   \n  heap[pos]=heap[childpos]\n  pos=childpos\n  childpos=2 *pos+1\n  \n  \n heap[pos]=newitem\n _siftdown_max(heap,startpos,pos)\n \ndef merge(*iterables,key=None ,reverse=False ):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n h=[]\n h_append=h.append\n \n if reverse:\n  _heapify=_heapify_max\n  _heappop=_heappop_max\n  _heapreplace=_heapreplace_max\n  direction=-1\n else :\n  _heapify=heapify\n  _heappop=heappop\n  _heapreplace=heapreplace\n  direction=1\n  \n if key is None :\n  for order,it in enumerate(map(iter,iterables)):\n   try :\n    next=it.__next__\n    h_append([next(),order *direction,next])\n   except StopIteration:\n    pass\n  _heapify(h)\n  while len(h)>1:\n   try :\n    while True :\n     value,order,next=s=h[0]\n     yield value\n     s[0]=next()\n     _heapreplace(h,s)\n   except StopIteration:\n    _heappop(h)\n  if h:\n  \n   value,order,next=h[0]\n   yield value\n   yield from next.__self__\n  return\n  \n for order,it in enumerate(map(iter,iterables)):\n  try :\n   next=it.__next__\n   value=next()\n   h_append([key(value),order *direction,value,next])\n  except StopIteration:\n   pass\n _heapify(h)\n while len(h)>1:\n  try :\n   while True :\n    key_value,order,value,next=s=h[0]\n    yield value\n    value=next()\n    s[0]=key(value)\n    s[2]=value\n    _heapreplace(h,s)\n  except StopIteration:\n   _heappop(h)\n if h:\n  key_value,order,value,next=h[0]\n  yield value\n  yield from next.__self__\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \ndef nsmallest(n,iterable,key=None ):\n ''\n\n\n \n \n \n if n ==1:\n  it=iter(iterable)\n  sentinel=object()\n  result=min(it,default=sentinel,key=key)\n  return []if result is sentinel else [result]\n  \n  \n try :\n  size=len(iterable)\n except (TypeError,AttributeError):\n  pass\n else :\n  if n >=size:\n   return sorted(iterable,key=key)[:n]\n   \n   \n if key is None :\n  it=iter(iterable)\n  \n  \n  result=[(elem,i)for i,elem in zip(range(n),it)]\n  if not result:\n   return result\n  _heapify_max(result)\n  top=result[0][0]\n  order=n\n  _heapreplace=_heapreplace_max\n  for elem in it:\n   if elem <top:\n    _heapreplace(result,(elem,order))\n    top,_order=result[0]\n    order +=1\n  result.sort()\n  return [elem for (elem,order)in result]\n  \n  \n it=iter(iterable)\n result=[(key(elem),i,elem)for i,elem in zip(range(n),it)]\n if not result:\n  return result\n _heapify_max(result)\n top=result[0][0]\n order=n\n _heapreplace=_heapreplace_max\n for elem in it:\n  k=key(elem)\n  if k <top:\n   _heapreplace(result,(k,order,elem))\n   top,_order,_elem=result[0]\n   order +=1\n result.sort()\n return [elem for (k,order,elem)in result]\n \ndef nlargest(n,iterable,key=None ):\n ''\n\n\n \n \n \n if n ==1:\n  it=iter(iterable)\n  sentinel=object()\n  result=max(it,default=sentinel,key=key)\n  return []if result is sentinel else [result]\n  \n  \n try :\n  size=len(iterable)\n except (TypeError,AttributeError):\n  pass\n else :\n  if n >=size:\n   return sorted(iterable,key=key,reverse=True )[:n]\n   \n   \n if key is None :\n  it=iter(iterable)\n  result=[(elem,i)for i,elem in zip(range(0,-n,-1),it)]\n  if not result:\n   return result\n  heapify(result)\n  top=result[0][0]\n  order=-n\n  _heapreplace=heapreplace\n  for elem in it:\n   if top <elem:\n    _heapreplace(result,(elem,order))\n    top,_order=result[0]\n    order -=1\n  result.sort(reverse=True )\n  return [elem for (elem,order)in result]\n  \n  \n it=iter(iterable)\n result=[(key(elem),i,elem)for i,elem in zip(range(0,-n,-1),it)]\n if not result:\n  return result\n heapify(result)\n top=result[0][0]\n order=-n\n _heapreplace=heapreplace\n for elem in it:\n  k=key(elem)\n  if top <k:\n   _heapreplace(result,(k,order,elem))\n   top,_order,_elem=result[0]\n   order -=1\n result.sort(reverse=True )\n return [elem for (k,order,elem)in result]\n \n \ntry :\n from _heapq import *\nexcept ImportError:\n pass\ntry :\n from _heapq import _heapreplace_max\nexcept ImportError:\n pass\ntry :\n from _heapq import _heapify_max\nexcept ImportError:\n pass\ntry :\n from _heapq import _heappop_max\nexcept ImportError:\n pass\n \n \nif __name__ ==\"__main__\":\n\n import doctest\n print(doctest.testmod())\n", ["_heapq", "doctest"]],
     "hmac": [".py", "''\n\n\n\n\nimport warnings as _warnings\ntry :\n import _hashlib as _hashopenssl\nexcept ImportError:\n _hashopenssl=None\n _openssl_md_meths=None\n from _operator import _compare_digest as compare_digest\nelse :\n _openssl_md_meths=frozenset(_hashopenssl.openssl_md_meth_names)\n compare_digest=_hashopenssl.compare_digest\nimport hashlib as _hashlib\n\ntrans_5C=bytes((x ^0x5C)for x in range(256))\ntrans_36=bytes((x ^0x36)for x in range(256))\n\n\n\ndigest_size=None\n\n\n\nclass HMAC:\n ''\n\n\n \n blocksize=64\n \n __slots__=(\n \"_digest_cons\",\"_inner\",\"_outer\",\"block_size\",\"digest_size\"\n )\n \n def __init__(self,key,msg=None ,digestmod=''):\n  ''\n\n\n\n\n\n\n\n\n\n\n  \n  \n  if not isinstance(key,(bytes,bytearray)):\n   raise TypeError(\"key: expected bytes or bytearray, but got %r\"%type(key).__name__)\n   \n  if not digestmod:\n   raise TypeError(\"Missing required parameter 'digestmod'.\")\n   \n  if callable(digestmod):\n   self._digest_cons=digestmod\n  elif isinstance(digestmod,str):\n   self._digest_cons=lambda d=b'':_hashlib.new(digestmod,d)\n  else :\n   self._digest_cons=lambda d=b'':digestmod.new(d)\n   \n  self._outer=self._digest_cons()\n  self._inner=self._digest_cons()\n  self.digest_size=self._inner.digest_size\n  \n  if hasattr(self._inner,'block_size'):\n   blocksize=self._inner.block_size\n   if blocksize <16:\n    _warnings.warn('block_size of %d seems too small; using our '\n    'default of %d.'%(blocksize,self.blocksize),\n    RuntimeWarning,2)\n    blocksize=self.blocksize\n  else :\n   _warnings.warn('No block_size attribute on given digest object; '\n   'Assuming %d.'%(self.blocksize),\n   RuntimeWarning,2)\n   blocksize=self.blocksize\n   \n   \n   \n  self.block_size=blocksize\n  \n  if len(key)>blocksize:\n   key=self._digest_cons(key).digest()\n   \n  key=key.ljust(blocksize,b'\\0')\n  self._outer.update(key.translate(trans_5C))\n  self._inner.update(key.translate(trans_36))\n  if msg is not None :\n   self.update(msg)\n   \n @property\n def name(self):\n  return \"hmac-\"+self._inner.name\n  \n @property\n def digest_cons(self):\n  return self._digest_cons\n  \n @property\n def inner(self):\n  return self._inner\n  \n @property\n def outer(self):\n  return self._outer\n  \n def update(self,msg):\n  ''\n  self._inner.update(msg)\n  \n def copy(self):\n  ''\n\n\n  \n  \n  other=self.__class__.__new__(self.__class__)\n  other._digest_cons=self._digest_cons\n  other.digest_size=self.digest_size\n  other._inner=self._inner.copy()\n  other._outer=self._outer.copy()\n  return other\n  \n def _current(self):\n  ''\n\n\n  \n  h=self._outer.copy()\n  h.update(self._inner.digest())\n  return h\n  \n def digest(self):\n  ''\n\n\n\n\n  \n  h=self._current()\n  return h.digest()\n  \n def hexdigest(self):\n  ''\n  \n  h=self._current()\n  return h.hexdigest()\n  \ndef new(key,msg=None ,digestmod=''):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n return HMAC(key,msg,digestmod)\n \n \ndef digest(key,msg,digest):\n ''\n\n\n\n\n\n\n \n if (_hashopenssl is not None and\n isinstance(digest,str)and digest in _openssl_md_meths):\n  return _hashopenssl.hmac_digest(key,msg,digest)\n  \n if callable(digest):\n  digest_cons=digest\n elif isinstance(digest,str):\n  digest_cons=lambda d=b'':_hashlib.new(digest,d)\n else :\n  digest_cons=lambda d=b'':digest.new(d)\n  \n inner=digest_cons()\n outer=digest_cons()\n blocksize=getattr(inner,'block_size',64)\n if len(key)>blocksize:\n  key=digest_cons(key).digest()\n key=key+b'\\x00'*(blocksize -len(key))\n inner.update(key.translate(trans_36))\n outer.update(key.translate(trans_5C))\n inner.update(msg)\n outer.update(inner.digest())\n return outer.digest()\n", ["_hashlib", "_operator", "hashlib", "warnings"]],
     "imp": [".py", "''\n\n\n\n\n\n\n\nfrom _imp import (lock_held,acquire_lock,release_lock,\nget_frozen_object,is_frozen_package,\ninit_frozen,is_builtin,is_frozen,\n_fix_co_filename)\ntry :\n from _imp import create_dynamic\nexcept ImportError:\n\n create_dynamic=None\n \nfrom importlib._bootstrap import _ERR_MSG,_exec,_load,_builtin_from_name\nfrom importlib._bootstrap_external import SourcelessFileLoader\n\nfrom importlib import machinery\nfrom importlib import util\nimport importlib\nimport os\nimport sys\nimport tokenize\nimport types\nimport warnings\n\nwarnings.warn(\"the imp module is deprecated in favour of importlib; \"\n\"see the module's documentation for alternative uses\",\nDeprecationWarning,stacklevel=2)\n\n\nSEARCH_ERROR=0\nPY_SOURCE=1\nPY_COMPILED=2\nC_EXTENSION=3\nPY_RESOURCE=4\nPKG_DIRECTORY=5\nC_BUILTIN=6\nPY_FROZEN=7\nPY_CODERESOURCE=8\nIMP_HOOK=9\n\n\ndef new_module(name):\n ''\n\n\n\n\n\n \n return types.ModuleType(name)\n \n \ndef get_magic():\n ''\n\n\n \n return util.MAGIC_NUMBER\n \n \ndef get_tag():\n ''\n return sys.implementation.cache_tag\n \n \ndef cache_from_source(path,debug_override=None ):\n ''\n\n\n\n\n\n\n\n\n\n\n\n \n with warnings.catch_warnings():\n  warnings.simplefilter('ignore')\n  return util.cache_from_source(path,debug_override)\n  \n  \ndef source_from_cache(path):\n ''\n\n\n\n\n\n\n\n\n \n return util.source_from_cache(path)\n \n \ndef get_suffixes():\n ''\n extensions=[(s,'rb',C_EXTENSION)for s in machinery.EXTENSION_SUFFIXES]\n source=[(s,'r',PY_SOURCE)for s in machinery.SOURCE_SUFFIXES]\n bytecode=[(s,'rb',PY_COMPILED)for s in machinery.BYTECODE_SUFFIXES]\n \n return extensions+source+bytecode\n \n \nclass NullImporter:\n\n ''\n\n\n\n \n \n def __init__(self,path):\n  if path =='':\n   raise ImportError('empty pathname',path='')\n  elif os.path.isdir(path):\n   raise ImportError('existing directory',path=path)\n   \n def find_module(self,fullname):\n  ''\n  return None\n  \n  \nclass _HackedGetData:\n\n ''\n \n \n def __init__(self,fullname,path,file=None ):\n  super().__init__(fullname,path)\n  self.file=file\n  \n def get_data(self,path):\n  ''\n  if self.file and path ==self.path:\n  \n  \n   if not self.file.closed:\n    file=self.file\n    if 'b'not in file.mode:\n     file.close()\n   if self.file.closed:\n    self.file=file=open(self.path,'rb')\n    \n   with file:\n    return file.read()\n  else :\n   return super().get_data(path)\n   \n   \nclass _LoadSourceCompatibility(_HackedGetData,machinery.SourceFileLoader):\n\n ''\n \n \ndef load_source(name,pathname,file=None ):\n loader=_LoadSourceCompatibility(name,pathname,file)\n spec=util.spec_from_file_location(name,pathname,loader=loader)\n if name in sys.modules:\n  module=_exec(spec,sys.modules[name])\n else :\n  module=_load(spec)\n  \n  \n module.__loader__=machinery.SourceFileLoader(name,pathname)\n module.__spec__.loader=module.__loader__\n return module\n \n \nclass _LoadCompiledCompatibility(_HackedGetData,SourcelessFileLoader):\n\n ''\n \n \ndef load_compiled(name,pathname,file=None ):\n ''\n loader=_LoadCompiledCompatibility(name,pathname,file)\n spec=util.spec_from_file_location(name,pathname,loader=loader)\n if name in sys.modules:\n  module=_exec(spec,sys.modules[name])\n else :\n  module=_load(spec)\n  \n  \n module.__loader__=SourcelessFileLoader(name,pathname)\n module.__spec__.loader=module.__loader__\n return module\n \n \ndef load_package(name,path):\n ''\n if os.path.isdir(path):\n  extensions=(machinery.SOURCE_SUFFIXES[:]+\n  machinery.BYTECODE_SUFFIXES[:])\n  for extension in extensions:\n   init_path=os.path.join(path,'__init__'+extension)\n   if os.path.exists(init_path):\n    path=init_path\n    break\n  else :\n   raise ValueError('{!r} is not a package'.format(path))\n spec=util.spec_from_file_location(name,path,\n submodule_search_locations=[])\n if name in sys.modules:\n  return _exec(spec,sys.modules[name])\n else :\n  return _load(spec)\n  \n  \ndef load_module(name,file,filename,details):\n ''\n\n\n\n\n\n \n suffix,mode,type_=details\n if mode and (not mode.startswith(('r','U'))or '+'in mode):\n  raise ValueError('invalid file open mode {!r}'.format(mode))\n elif file is None and type_ in {PY_SOURCE,PY_COMPILED}:\n  msg='file object required for import (type code {})'.format(type_)\n  raise ValueError(msg)\n elif type_ ==PY_SOURCE:\n  return load_source(name,filename,file)\n elif type_ ==PY_COMPILED:\n  return load_compiled(name,filename,file)\n elif type_ ==C_EXTENSION and load_dynamic is not None :\n  if file is None :\n   with open(filename,'rb')as opened_file:\n    return load_dynamic(name,filename,opened_file)\n  else :\n   return load_dynamic(name,filename,file)\n elif type_ ==PKG_DIRECTORY:\n  return load_package(name,filename)\n elif type_ ==C_BUILTIN:\n  return init_builtin(name)\n elif type_ ==PY_FROZEN:\n  return init_frozen(name)\n else :\n  msg=\"Don't know how to import {} (type code {})\".format(name,type_)\n  raise ImportError(msg,name=name)\n  \n  \ndef find_module(name,path=None ):\n ''\n\n\n\n\n\n\n\n\n \n if not isinstance(name,str):\n  raise TypeError(\"'name' must be a str, not {}\".format(type(name)))\n elif not isinstance(path,(type(None ),list)):\n \n  raise RuntimeError(\"'path' must be None or a list, \"\n  \"not {}\".format(type(path)))\n  \n if path is None :\n  if is_builtin(name):\n   return None ,None ,('','',C_BUILTIN)\n  elif is_frozen(name):\n   return None ,None ,('','',PY_FROZEN)\n  else :\n   path=sys.path\n   \n for entry in path:\n  package_directory=os.path.join(entry,name)\n  for suffix in ['.py',machinery.BYTECODE_SUFFIXES[0]]:\n   package_file_name='__init__'+suffix\n   file_path=os.path.join(package_directory,package_file_name)\n   if os.path.isfile(file_path):\n    return None ,package_directory,('','',PKG_DIRECTORY)\n  for suffix,mode,type_ in get_suffixes():\n   file_name=name+suffix\n   file_path=os.path.join(entry,file_name)\n   if os.path.isfile(file_path):\n    break\n  else :\n   continue\n  break\n else :\n  raise ImportError(_ERR_MSG.format(name),name=name)\n  \n encoding=None\n if 'b'not in mode:\n  with open(file_path,'rb')as file:\n   encoding=tokenize.detect_encoding(file.readline)[0]\n file=open(file_path,mode,encoding=encoding)\n return file,file_path,(suffix,mode,type_)\n \n \ndef reload(module):\n ''\n\n\n\n\n\n \n return importlib.reload(module)\n \n \ndef init_builtin(name):\n ''\n\n\n\n \n try :\n  return _builtin_from_name(name)\n except ImportError:\n  return None\n  \n  \nif create_dynamic:\n def load_dynamic(name,path,file=None ):\n  ''\n\n\n  \n  import importlib.machinery\n  loader=importlib.machinery.ExtensionFileLoader(name,path)\n  \n  \n  \n  spec=importlib.machinery.ModuleSpec(\n  name=name,loader=loader,origin=path)\n  return _load(spec)\n  \nelse :\n load_dynamic=None\n", ["_imp", "importlib", "importlib._bootstrap", "importlib._bootstrap_external", "importlib.machinery", "importlib.util", "os", "sys", "tokenize", "types", "warnings"]],
     "inspect": [".py", "''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n__author__=('Ka-Ping Yee <ping@lfw.org>',\n'Yury Selivanov <yselivanov@sprymix.com>')\n\nimport abc\nimport dis\nimport collections.abc\nimport enum\nimport importlib.machinery\nimport itertools\nimport linecache\nimport os\nimport re\nimport sys\nimport tokenize\nimport token\nimport types\nimport warnings\nimport functools\nimport builtins\nfrom operator import attrgetter\nfrom collections import namedtuple,OrderedDict\n\n\n\nmod_dict=globals()\nfor k,v in dis.COMPILER_FLAG_NAMES.items():\n mod_dict[\"CO_\"+v]=k\n \n \nTPFLAGS_IS_ABSTRACT=1 <<20\n\n\ndef ismodule(object):\n ''\n\n\n\n\n \n return isinstance(object,types.ModuleType)\n \ndef isclass(object):\n ''\n\n\n\n \n return isinstance(object,type)\n \ndef ismethod(object):\n ''\n\n\n\n\n\n \n return isinstance(object,types.MethodType)\n \ndef ismethoddescriptor(object):\n ''\n\n\n\n\n\n\n\n\n\n\n\n \n if isclass(object)or ismethod(object)or isfunction(object):\n \n  return False\n tp=type(object)\n return hasattr(tp,\"__get__\")and not hasattr(tp,\"__set__\")\n \ndef isdatadescriptor(object):\n ''\n\n\n\n\n\n \n if isclass(object)or ismethod(object)or isfunction(object):\n \n  return False\n tp=type(object)\n return hasattr(tp,\"__set__\")or hasattr(tp,\"__delete__\")\n \nif hasattr(types,'MemberDescriptorType'):\n\n def ismemberdescriptor(object):\n  ''\n\n\n  \n  return isinstance(object,types.MemberDescriptorType)\nelse :\n\n def ismemberdescriptor(object):\n  ''\n\n\n  \n  return False\n  \nif hasattr(types,'GetSetDescriptorType'):\n\n def isgetsetdescriptor(object):\n  ''\n\n\n  \n  return isinstance(object,types.GetSetDescriptorType)\nelse :\n\n def isgetsetdescriptor(object):\n  ''\n\n\n  \n  return False\n  \ndef isfunction(object):\n ''\n\n\n\n\n\n\n\n\n \n return isinstance(object,types.FunctionType)\n \ndef _has_code_flag(f,flag):\n ''\n\n \n while ismethod(f):\n  f=f.__func__\n f=functools._unwrap_partial(f)\n if not isfunction(f):\n  return False\n return bool(f.__code__.co_flags&flag)\n \ndef isgeneratorfunction(obj):\n ''\n\n\n \n return _has_code_flag(obj,CO_GENERATOR)\n \ndef iscoroutinefunction(obj):\n ''\n\n\n \n return _has_code_flag(obj,CO_COROUTINE)\n \ndef isasyncgenfunction(obj):\n ''\n\n\n\n \n return _has_code_flag(obj,CO_ASYNC_GENERATOR)\n \ndef isasyncgen(object):\n ''\n return isinstance(object,types.AsyncGeneratorType)\n \ndef isgenerator(object):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n \n return isinstance(object,types.GeneratorType)\n \ndef iscoroutine(object):\n ''\n return isinstance(object,types.CoroutineType)\n \ndef isawaitable(object):\n ''\n return (isinstance(object,types.CoroutineType)or\n isinstance(object,types.GeneratorType)and\n bool(object.gi_code.co_flags&CO_ITERABLE_COROUTINE)or\n isinstance(object,collections.abc.Awaitable))\n \ndef istraceback(object):\n ''\n\n\n\n\n\n \n return isinstance(object,types.TracebackType)\n \ndef isframe(object):\n ''\n\n\n\n\n\n\n\n\n\n \n return isinstance(object,types.FrameType)\n \ndef iscode(object):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n return isinstance(object,types.CodeType)\n \ndef isbuiltin(object):\n ''\n\n\n\n\n \n return isinstance(object,types.BuiltinFunctionType)\n \ndef isroutine(object):\n ''\n return (isbuiltin(object)\n or isfunction(object)\n or ismethod(object)\n or ismethoddescriptor(object))\n \ndef isabstract(object):\n ''\n if not isinstance(object,type):\n  return False\n if object.__flags__&TPFLAGS_IS_ABSTRACT:\n  return True\n if not issubclass(type(object),abc.ABCMeta):\n  return False\n if hasattr(object,'__abstractmethods__'):\n \n \n  return False\n  \n  \n for name,value in object.__dict__.items():\n  if getattr(value,\"__isabstractmethod__\",False ):\n   return True\n for base in object.__bases__:\n  for name in getattr(base,\"__abstractmethods__\",()):\n   value=getattr(object,name,None )\n   if getattr(value,\"__isabstractmethod__\",False ):\n    return True\n return False\n \ndef getmembers(object,predicate=None ):\n ''\n \n if isclass(object):\n  mro=(object,)+getmro(object)\n else :\n  mro=()\n results=[]\n processed=set()\n names=dir(object)\n \n \n \n try :\n  for base in object.__bases__:\n   for k,v in base.__dict__.items():\n    if isinstance(v,types.DynamicClassAttribute):\n     names.append(k)\n except AttributeError:\n  pass\n for key in names:\n \n \n \n  try :\n   value=getattr(object,key)\n   \n   if key in processed:\n    raise AttributeError\n  except AttributeError:\n   for base in mro:\n    if key in base.__dict__:\n     value=base.__dict__[key]\n     break\n   else :\n   \n   \n    continue\n  if not predicate or predicate(value):\n   results.append((key,value))\n  processed.add(key)\n results.sort(key=lambda pair:pair[0])\n return results\n \nAttribute=namedtuple('Attribute','name kind defining_class object')\n\ndef classify_class_attrs(cls):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n mro=getmro(cls)\n metamro=getmro(type(cls))\n metamro=tuple(cls for cls in metamro if cls not in (type,object))\n class_bases=(cls,)+mro\n all_bases=class_bases+metamro\n names=dir(cls)\n \n \n \n for base in mro:\n  for k,v in base.__dict__.items():\n   if isinstance(v,types.DynamicClassAttribute):\n    names.append(k)\n result=[]\n processed=set()\n \n for name in names:\n \n \n \n \n \n \n \n \n \n  homecls=None\n  get_obj=None\n  dict_obj=None\n  if name not in processed:\n   try :\n    if name =='__dict__':\n     raise Exception(\"__dict__ is special, don't want the proxy\")\n    get_obj=getattr(cls,name)\n   except Exception as exc:\n    pass\n   else :\n    homecls=getattr(get_obj,\"__objclass__\",homecls)\n    if homecls not in class_bases:\n    \n    \n     homecls=None\n     last_cls=None\n     \n     for srch_cls in class_bases:\n      srch_obj=getattr(srch_cls,name,None )\n      if srch_obj is get_obj:\n       last_cls=srch_cls\n       \n     for srch_cls in metamro:\n      try :\n       srch_obj=srch_cls.__getattr__(cls,name)\n      except AttributeError:\n       continue\n      if srch_obj is get_obj:\n       last_cls=srch_cls\n     if last_cls is not None :\n      homecls=last_cls\n  for base in all_bases:\n   if name in base.__dict__:\n    dict_obj=base.__dict__[name]\n    if homecls not in metamro:\n     homecls=base\n    break\n  if homecls is None :\n  \n  \n   continue\n  obj=get_obj if get_obj is not None else dict_obj\n  \n  if isinstance(dict_obj,(staticmethod,types.BuiltinMethodType)):\n   kind=\"static method\"\n   obj=dict_obj\n  elif isinstance(dict_obj,(classmethod,types.ClassMethodDescriptorType)):\n   kind=\"class method\"\n   obj=dict_obj\n  elif isinstance(dict_obj,property):\n   kind=\"property\"\n   obj=dict_obj\n  elif isroutine(obj):\n   kind=\"method\"\n  else :\n   kind=\"data\"\n  result.append(Attribute(name,kind,homecls,obj))\n  processed.add(name)\n return result\n \n \n \ndef getmro(cls):\n ''\n return cls.__mro__\n \n \n \ndef unwrap(func,*,stop=None ):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n if stop is None :\n  def _is_wrapper(f):\n   return hasattr(f,'__wrapped__')\n else :\n  def _is_wrapper(f):\n   return hasattr(f,'__wrapped__')and not stop(f)\n f=func\n \n \n memo={id(f):f}\n recursion_limit=sys.getrecursionlimit()\n while _is_wrapper(func):\n  func=func.__wrapped__\n  id_func=id(func)\n  if (id_func in memo)or (len(memo)>=recursion_limit):\n   raise ValueError('wrapper loop when unwrapping {!r}'.format(f))\n  memo[id_func]=func\n return func\n \n \ndef indentsize(line):\n ''\n expline=line.expandtabs()\n return len(expline)-len(expline.lstrip())\n \ndef _findclass(func):\n cls=sys.modules.get(func.__module__)\n if cls is None :\n  return None\n for name in func.__qualname__.split('.')[:-1]:\n  cls=getattr(cls,name)\n if not isclass(cls):\n  return None\n return cls\n \ndef _finddoc(obj):\n if isclass(obj):\n  for base in obj.__mro__:\n   if base is not object:\n    try :\n     doc=base.__doc__\n    except AttributeError:\n     continue\n    if doc is not None :\n     return doc\n  return None\n  \n if ismethod(obj):\n  name=obj.__func__.__name__\n  self=obj.__self__\n  if (isclass(self)and\n  getattr(getattr(self,name,None ),'__func__')is obj.__func__):\n  \n   cls=self\n  else :\n   cls=self.__class__\n elif isfunction(obj):\n  name=obj.__name__\n  cls=_findclass(obj)\n  if cls is None or getattr(cls,name)is not obj:\n   return None\n elif isbuiltin(obj):\n  name=obj.__name__\n  self=obj.__self__\n  if (isclass(self)and\n  self.__qualname__+'.'+name ==obj.__qualname__):\n  \n   cls=self\n  else :\n   cls=self.__class__\n   \n elif isinstance(obj,property):\n  func=obj.fget\n  name=func.__name__\n  cls=_findclass(func)\n  if cls is None or getattr(cls,name)is not obj:\n   return None\n elif ismethoddescriptor(obj)or isdatadescriptor(obj):\n  name=obj.__name__\n  cls=obj.__objclass__\n  if getattr(cls,name)is not obj:\n   return None\n  if ismemberdescriptor(obj):\n   slots=getattr(cls,'__slots__',None )\n   if isinstance(slots,dict)and name in slots:\n    return slots[name]\n else :\n  return None\n for base in cls.__mro__:\n  try :\n   doc=getattr(base,name).__doc__\n  except AttributeError:\n   continue\n  if doc is not None :\n   return doc\n return None\n \ndef getdoc(object):\n ''\n\n\n\n \n try :\n  doc=object.__doc__\n except AttributeError:\n  return None\n if doc is None :\n  try :\n   doc=_finddoc(object)\n  except (AttributeError,TypeError):\n   return None\n if not isinstance(doc,str):\n  return None\n return cleandoc(doc)\n \ndef cleandoc(doc):\n ''\n\n\n \n try :\n  lines=doc.expandtabs().split('\\n')\n except UnicodeError:\n  return None\n else :\n \n  margin=sys.maxsize\n  for line in lines[1:]:\n   content=len(line.lstrip())\n   if content:\n    indent=len(line)-content\n    margin=min(margin,indent)\n    \n  if lines:\n   lines[0]=lines[0].lstrip()\n  if margin <sys.maxsize:\n   for i in range(1,len(lines)):lines[i]=lines[i][margin:]\n   \n  while lines and not lines[-1]:\n   lines.pop()\n  while lines and not lines[0]:\n   lines.pop(0)\n  return '\\n'.join(lines)\n  \ndef getfile(object):\n ''\n if ismodule(object):\n  if getattr(object,'__file__',None ):\n   return object.__file__\n  raise TypeError('{!r} is a built-in module'.format(object))\n if isclass(object):\n  if hasattr(object,'__module__'):\n   module=sys.modules.get(object.__module__)\n   if getattr(module,'__file__',None ):\n    return module.__file__\n  raise TypeError('{!r} is a built-in class'.format(object))\n if ismethod(object):\n  object=object.__func__\n if isfunction(object):\n  object=object.__code__\n if istraceback(object):\n  object=object.tb_frame\n if isframe(object):\n  object=object.f_code\n if iscode(object):\n  return object.co_filename\n raise TypeError('module, class, method, function, traceback, frame, or '\n 'code object was expected, got {}'.format(\n type(object).__name__))\n \ndef getmodulename(path):\n ''\n fname=os.path.basename(path)\n \n suffixes=[(-len(suffix),suffix)\n for suffix in importlib.machinery.all_suffixes()]\n suffixes.sort()\n for neglen,suffix in suffixes:\n  if fname.endswith(suffix):\n   return fname[:neglen]\n return None\n \ndef getsourcefile(object):\n ''\n\n \n filename=getfile(object)\n all_bytecode_suffixes=importlib.machinery.DEBUG_BYTECODE_SUFFIXES[:]\n all_bytecode_suffixes +=importlib.machinery.OPTIMIZED_BYTECODE_SUFFIXES[:]\n if any(filename.endswith(s)for s in all_bytecode_suffixes):\n  filename=(os.path.splitext(filename)[0]+\n  importlib.machinery.SOURCE_SUFFIXES[0])\n elif any(filename.endswith(s)for s in\n importlib.machinery.EXTENSION_SUFFIXES):\n  return None\n if os.path.exists(filename):\n  return filename\n  \n if getattr(getmodule(object,filename),'__loader__',None )is not None :\n  return filename\n  \n if filename in linecache.cache:\n  return filename\n  \ndef getabsfile(object,_filename=None ):\n ''\n\n\n \n if _filename is None :\n  _filename=getsourcefile(object)or getfile(object)\n return os.path.normcase(os.path.abspath(_filename))\n \nmodulesbyfile={}\n_filesbymodname={}\n\ndef getmodule(object,_filename=None ):\n ''\n if ismodule(object):\n  return object\n if hasattr(object,'__module__'):\n  return sys.modules.get(object.__module__)\n  \n if _filename is not None and _filename in modulesbyfile:\n  return sys.modules.get(modulesbyfile[_filename])\n  \n try :\n  file=getabsfile(object,_filename)\n except TypeError:\n  return None\n if file in modulesbyfile:\n  return sys.modules.get(modulesbyfile[file])\n  \n  \n for modname,module in list(sys.modules.items()):\n  if ismodule(module)and hasattr(module,'__file__'):\n   f=module.__file__\n   if f ==_filesbymodname.get(modname,None ):\n   \n    continue\n   _filesbymodname[modname]=f\n   f=getabsfile(module)\n   \n   modulesbyfile[f]=modulesbyfile[\n   os.path.realpath(f)]=module.__name__\n if file in modulesbyfile:\n  return sys.modules.get(modulesbyfile[file])\n  \n main=sys.modules['__main__']\n if not hasattr(object,'__name__'):\n  return None\n if hasattr(main,object.__name__):\n  mainobject=getattr(main,object.__name__)\n  if mainobject is object:\n   return main\n   \n builtin=sys.modules['builtins']\n if hasattr(builtin,object.__name__):\n  builtinobject=getattr(builtin,object.__name__)\n  if builtinobject is object:\n   return builtin\n   \ndef findsource(object):\n ''\n\n\n\n\n \n \n file=getsourcefile(object)\n if file:\n \n  linecache.checkcache(file)\n else :\n  file=getfile(object)\n  \n  \n  \n  if not (file.startswith('<')and file.endswith('>')):\n   raise OSError('source code not available')\n   \n module=getmodule(object,file)\n if module:\n  lines=linecache.getlines(file,module.__dict__)\n else :\n  lines=linecache.getlines(file)\n if not lines:\n  raise OSError('could not get source code')\n  \n if ismodule(object):\n  return lines,0\n  \n if isclass(object):\n  name=object.__name__\n  pat=re.compile(r'^(\\s*)class\\s*'+name+r'\\b')\n  \n  \n  \n  candidates=[]\n  for i in range(len(lines)):\n   match=pat.match(lines[i])\n   if match:\n   \n    if lines[i][0]=='c':\n     return lines,i\n     \n    candidates.append((match.group(1),i))\n  if candidates:\n  \n  \n   candidates.sort()\n   return lines,candidates[0][1]\n  else :\n   raise OSError('could not find class definition')\n   \n if ismethod(object):\n  object=object.__func__\n if isfunction(object):\n  object=object.__code__\n if istraceback(object):\n  object=object.tb_frame\n if isframe(object):\n  object=object.f_code\n if iscode(object):\n  if not hasattr(object,'co_firstlineno'):\n   raise OSError('could not find function definition')\n  lnum=object.co_firstlineno -1\n  pat=re.compile(r'^(\\s*def\\s)|(\\s*async\\s+def\\s)|(.*(?<!\\w)lambda(:|\\s))|^(\\s*@)')\n  while lnum >0:\n   if pat.match(lines[lnum]):break\n   lnum=lnum -1\n  return lines,lnum\n raise OSError('could not find code object')\n \ndef getcomments(object):\n ''\n\n\n \n try :\n  lines,lnum=findsource(object)\n except (OSError,TypeError):\n  return None\n  \n if ismodule(object):\n \n  start=0\n  if lines and lines[0][:2]=='#!':start=1\n  while start <len(lines)and lines[start].strip()in ('','#'):\n   start=start+1\n  if start <len(lines)and lines[start][:1]=='#':\n   comments=[]\n   end=start\n   while end <len(lines)and lines[end][:1]=='#':\n    comments.append(lines[end].expandtabs())\n    end=end+1\n   return ''.join(comments)\n   \n   \n elif lnum >0:\n  indent=indentsize(lines[lnum])\n  end=lnum -1\n  if end >=0 and lines[end].lstrip()[:1]=='#'and\\\n  indentsize(lines[end])==indent:\n   comments=[lines[end].expandtabs().lstrip()]\n   if end >0:\n    end=end -1\n    comment=lines[end].expandtabs().lstrip()\n    while comment[:1]=='#'and indentsize(lines[end])==indent:\n     comments[:0]=[comment]\n     end=end -1\n     if end <0:break\n     comment=lines[end].expandtabs().lstrip()\n   while comments and comments[0].strip()=='#':\n    comments[:1]=[]\n   while comments and comments[-1].strip()=='#':\n    comments[-1:]=[]\n   return ''.join(comments)\n   \nclass EndOfBlock(Exception):pass\n\nclass BlockFinder:\n ''\n def __init__(self):\n  self.indent=0\n  self.islambda=False\n  self.started=False\n  self.passline=False\n  self.indecorator=False\n  self.decoratorhasargs=False\n  self.last=1\n  \n def tokeneater(self,type,token,srowcol,erowcol,line):\n  if not self.started and not self.indecorator:\n  \n   if token ==\"@\":\n    self.indecorator=True\n    \n   elif token in (\"def\",\"class\",\"lambda\"):\n    if token ==\"lambda\":\n     self.islambda=True\n    self.started=True\n   self.passline=True\n  elif token ==\"(\":\n   if self.indecorator:\n    self.decoratorhasargs=True\n  elif token ==\")\":\n   if self.indecorator:\n    self.indecorator=False\n    self.decoratorhasargs=False\n  elif type ==tokenize.NEWLINE:\n   self.passline=False\n   self.last=srowcol[0]\n   if self.islambda:\n    raise EndOfBlock\n    \n    \n   if self.indecorator and not self.decoratorhasargs:\n    self.indecorator=False\n  elif self.passline:\n   pass\n  elif type ==tokenize.INDENT:\n   self.indent=self.indent+1\n   self.passline=True\n  elif type ==tokenize.DEDENT:\n   self.indent=self.indent -1\n   \n   \n   \n   if self.indent <=0:\n    raise EndOfBlock\n  elif self.indent ==0 and type not in (tokenize.COMMENT,tokenize.NL):\n  \n  \n   raise EndOfBlock\n   \ndef getblock(lines):\n ''\n blockfinder=BlockFinder()\n try :\n  tokens=tokenize.generate_tokens(iter(lines).__next__)\n  for _token in tokens:\n   blockfinder.tokeneater(*_token)\n except (EndOfBlock,IndentationError):\n  pass\n return lines[:blockfinder.last]\n \ndef getsourcelines(object):\n ''\n\n\n\n\n\n \n object=unwrap(object)\n lines,lnum=findsource(object)\n \n if istraceback(object):\n  object=object.tb_frame\n  \n  \n if (ismodule(object)or\n (isframe(object)and object.f_code.co_name ==\"<module>\")):\n  return lines,0\n else :\n  return getblock(lines[lnum:]),lnum+1\n  \ndef getsource(object):\n ''\n\n\n\n \n lines,lnum=getsourcelines(object)\n return ''.join(lines)\n \n \ndef walktree(classes,children,parent):\n ''\n results=[]\n classes.sort(key=attrgetter('__module__','__name__'))\n for c in classes:\n  results.append((c,c.__bases__))\n  if c in children:\n   results.append(walktree(children[c],children,c))\n return results\n \ndef getclasstree(classes,unique=False ):\n ''\n\n\n\n\n\n\n \n children={}\n roots=[]\n for c in classes:\n  if c.__bases__:\n   for parent in c.__bases__:\n    if parent not in children:\n     children[parent]=[]\n    if c not in children[parent]:\n     children[parent].append(c)\n    if unique and parent in classes:break\n  elif c not in roots:\n   roots.append(c)\n for parent in children:\n  if parent not in classes:\n   roots.append(parent)\n return walktree(roots,children,None )\n \n \nArguments=namedtuple('Arguments','args, varargs, varkw')\n\ndef getargs(co):\n ''\n\n\n\n\n \n if not iscode(co):\n  raise TypeError('{!r} is not a code object'.format(co))\n  \n names=co.co_varnames\n nargs=co.co_argcount\n nkwargs=co.co_kwonlyargcount\n args=list(names[:nargs])\n kwonlyargs=list(names[nargs:nargs+nkwargs])\n step=0\n \n nargs +=nkwargs\n varargs=None\n if co.co_flags&CO_VARARGS:\n  varargs=co.co_varnames[nargs]\n  nargs=nargs+1\n varkw=None\n if co.co_flags&CO_VARKEYWORDS:\n  varkw=co.co_varnames[nargs]\n return Arguments(args+kwonlyargs,varargs,varkw)\n \nArgSpec=namedtuple('ArgSpec','args varargs keywords defaults')\n\ndef getargspec(func):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n warnings.warn(\"inspect.getargspec() is deprecated since Python 3.0, \"\n \"use inspect.signature() or inspect.getfullargspec()\",\n DeprecationWarning,stacklevel=2)\n args,varargs,varkw,defaults,kwonlyargs,kwonlydefaults,ann=\\\n getfullargspec(func)\n if kwonlyargs or ann:\n  raise ValueError(\"Function has keyword-only parameters or annotations\"\n  \", use inspect.signature() API which can support them\")\n return ArgSpec(args,varargs,varkw,defaults)\n \nFullArgSpec=namedtuple('FullArgSpec',\n'args, varargs, varkw, defaults, kwonlyargs, kwonlydefaults, annotations')\n\ndef getfullargspec(func):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n try :\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n  sig=_signature_from_callable(func,\n  follow_wrapper_chains=False ,\n  skip_bound_arg=False ,\n  sigcls=Signature)\n except Exception as ex:\n \n \n \n \n  raise TypeError('unsupported callable')from ex\n  \n args=[]\n varargs=None\n varkw=None\n posonlyargs=[]\n kwonlyargs=[]\n defaults=()\n annotations={}\n defaults=()\n kwdefaults={}\n \n if sig.return_annotation is not sig.empty:\n  annotations['return']=sig.return_annotation\n  \n for param in sig.parameters.values():\n  kind=param.kind\n  name=param.name\n  \n  if kind is _POSITIONAL_ONLY:\n   posonlyargs.append(name)\n   if param.default is not param.empty:\n    defaults +=(param.default,)\n  elif kind is _POSITIONAL_OR_KEYWORD:\n   args.append(name)\n   if param.default is not param.empty:\n    defaults +=(param.default,)\n  elif kind is _VAR_POSITIONAL:\n   varargs=name\n  elif kind is _KEYWORD_ONLY:\n   kwonlyargs.append(name)\n   if param.default is not param.empty:\n    kwdefaults[name]=param.default\n  elif kind is _VAR_KEYWORD:\n   varkw=name\n   \n  if param.annotation is not param.empty:\n   annotations[name]=param.annotation\n   \n if not kwdefaults:\n \n  kwdefaults=None\n  \n if not defaults:\n \n  defaults=None\n  \n return FullArgSpec(posonlyargs+args,varargs,varkw,defaults,\n kwonlyargs,kwdefaults,annotations)\n \n \nArgInfo=namedtuple('ArgInfo','args varargs keywords locals')\n\ndef getargvalues(frame):\n ''\n\n\n\n\n \n args,varargs,varkw=getargs(frame.f_code)\n return ArgInfo(args,varargs,varkw,frame.f_locals)\n \ndef formatannotation(annotation,base_module=None ):\n if getattr(annotation,'__module__',None )=='typing':\n  return repr(annotation).replace('typing.','')\n if isinstance(annotation,type):\n  if annotation.__module__ in ('builtins',base_module):\n   return annotation.__qualname__\n  return annotation.__module__+'.'+annotation.__qualname__\n return repr(annotation)\n \ndef formatannotationrelativeto(object):\n module=getattr(object,'__module__',None )\n def _formatannotation(annotation):\n  return formatannotation(annotation,module)\n return _formatannotation\n \ndef formatargspec(args,varargs=None ,varkw=None ,defaults=None ,\nkwonlyargs=(),kwonlydefaults={},annotations={},\nformatarg=str,\nformatvarargs=lambda name:'*'+name,\nformatvarkw=lambda name:'**'+name,\nformatvalue=lambda value:'='+repr(value),\nformatreturns=lambda text:' -> '+text,\nformatannotation=formatannotation):\n ''\n\n\n\n\n\n\n\n\n\n \n \n from warnings import warn\n \n warn(\"`formatargspec` is deprecated since Python 3.5. Use `signature` and \"\n \"the `Signature` object directly\",\n DeprecationWarning,\n stacklevel=2)\n \n def formatargandannotation(arg):\n  result=formatarg(arg)\n  if arg in annotations:\n   result +=': '+formatannotation(annotations[arg])\n  return result\n specs=[]\n if defaults:\n  firstdefault=len(args)-len(defaults)\n for i,arg in enumerate(args):\n  spec=formatargandannotation(arg)\n  if defaults and i >=firstdefault:\n   spec=spec+formatvalue(defaults[i -firstdefault])\n  specs.append(spec)\n if varargs is not None :\n  specs.append(formatvarargs(formatargandannotation(varargs)))\n else :\n  if kwonlyargs:\n   specs.append('*')\n if kwonlyargs:\n  for kwonlyarg in kwonlyargs:\n   spec=formatargandannotation(kwonlyarg)\n   if kwonlydefaults and kwonlyarg in kwonlydefaults:\n    spec +=formatvalue(kwonlydefaults[kwonlyarg])\n   specs.append(spec)\n if varkw is not None :\n  specs.append(formatvarkw(formatargandannotation(varkw)))\n result='('+', '.join(specs)+')'\n if 'return'in annotations:\n  result +=formatreturns(formatannotation(annotations['return']))\n return result\n \ndef formatargvalues(args,varargs,varkw,locals,\nformatarg=str,\nformatvarargs=lambda name:'*'+name,\nformatvarkw=lambda name:'**'+name,\nformatvalue=lambda value:'='+repr(value)):\n ''\n\n\n\n\n \n def convert(name,locals=locals,\n formatarg=formatarg,formatvalue=formatvalue):\n  return formatarg(name)+formatvalue(locals[name])\n specs=[]\n for i in range(len(args)):\n  specs.append(convert(args[i]))\n if varargs:\n  specs.append(formatvarargs(varargs)+formatvalue(locals[varargs]))\n if varkw:\n  specs.append(formatvarkw(varkw)+formatvalue(locals[varkw]))\n return '('+', '.join(specs)+')'\n \ndef _missing_arguments(f_name,argnames,pos,values):\n names=[repr(name)for name in argnames if name not in values]\n missing=len(names)\n if missing ==1:\n  s=names[0]\n elif missing ==2:\n  s=\"{} and {}\".format(*names)\n else :\n  tail=\", {} and {}\".format(*names[-2:])\n  del names[-2:]\n  s=\", \".join(names)+tail\n raise TypeError(\"%s() missing %i required %s argument%s: %s\"%\n (f_name,missing,\n \"positional\"if pos else \"keyword-only\",\n \"\"if missing ==1 else \"s\",s))\n \ndef _too_many(f_name,args,kwonly,varargs,defcount,given,values):\n atleast=len(args)-defcount\n kwonly_given=len([arg for arg in kwonly if arg in values])\n if varargs:\n  plural=atleast !=1\n  sig=\"at least %d\"%(atleast,)\n elif defcount:\n  plural=True\n  sig=\"from %d to %d\"%(atleast,len(args))\n else :\n  plural=len(args)!=1\n  sig=str(len(args))\n kwonly_sig=\"\"\n if kwonly_given:\n  msg=\" positional argument%s (and %d keyword-only argument%s)\"\n  kwonly_sig=(msg %(\"s\"if given !=1 else \"\",kwonly_given,\n  \"s\"if kwonly_given !=1 else \"\"))\n raise TypeError(\"%s() takes %s positional argument%s but %d%s %s given\"%\n (f_name,sig,\"s\"if plural else \"\",given,kwonly_sig,\n \"was\"if given ==1 and not kwonly_given else \"were\"))\n \ndef getcallargs(func,/,*positional,**named):\n ''\n\n\n\n \n spec=getfullargspec(func)\n args,varargs,varkw,defaults,kwonlyargs,kwonlydefaults,ann=spec\n f_name=func.__name__\n arg2value={}\n \n \n if ismethod(func)and func.__self__ is not None :\n \n  positional=(func.__self__,)+positional\n num_pos=len(positional)\n num_args=len(args)\n num_defaults=len(defaults)if defaults else 0\n \n n=min(num_pos,num_args)\n for i in range(n):\n  arg2value[args[i]]=positional[i]\n if varargs:\n  arg2value[varargs]=tuple(positional[n:])\n possible_kwargs=set(args+kwonlyargs)\n if varkw:\n  arg2value[varkw]={}\n for kw,value in named.items():\n  if kw not in possible_kwargs:\n   if not varkw:\n    raise TypeError(\"%s() got an unexpected keyword argument %r\"%\n    (f_name,kw))\n   arg2value[varkw][kw]=value\n   continue\n  if kw in arg2value:\n   raise TypeError(\"%s() got multiple values for argument %r\"%\n   (f_name,kw))\n  arg2value[kw]=value\n if num_pos >num_args and not varargs:\n  _too_many(f_name,args,kwonlyargs,varargs,num_defaults,\n  num_pos,arg2value)\n if num_pos <num_args:\n  req=args[:num_args -num_defaults]\n  for arg in req:\n   if arg not in arg2value:\n    _missing_arguments(f_name,req,True ,arg2value)\n  for i,arg in enumerate(args[num_args -num_defaults:]):\n   if arg not in arg2value:\n    arg2value[arg]=defaults[i]\n missing=0\n for kwarg in kwonlyargs:\n  if kwarg not in arg2value:\n   if kwonlydefaults and kwarg in kwonlydefaults:\n    arg2value[kwarg]=kwonlydefaults[kwarg]\n   else :\n    missing +=1\n if missing:\n  _missing_arguments(f_name,kwonlyargs,False ,arg2value)\n return arg2value\n \nClosureVars=namedtuple('ClosureVars','nonlocals globals builtins unbound')\n\ndef getclosurevars(func):\n ''\n\n\n\n\n\n \n \n if ismethod(func):\n  func=func.__func__\n  \n if not isfunction(func):\n  raise TypeError(\"{!r} is not a Python function\".format(func))\n  \n code=func.__code__\n \n \n if func.__closure__ is None :\n  nonlocal_vars={}\n else :\n  nonlocal_vars={\n  var:cell.cell_contents\n  for var,cell in zip(code.co_freevars,func.__closure__)\n  }\n  \n  \n  \n global_ns=func.__globals__\n builtin_ns=global_ns.get(\"__builtins__\",builtins.__dict__)\n if ismodule(builtin_ns):\n  builtin_ns=builtin_ns.__dict__\n global_vars={}\n builtin_vars={}\n unbound_names=set()\n for name in code.co_names:\n  if name in (\"None\",\"True\",\"False\"):\n  \n  \n   continue\n  try :\n   global_vars[name]=global_ns[name]\n  except KeyError:\n   try :\n    builtin_vars[name]=builtin_ns[name]\n   except KeyError:\n    unbound_names.add(name)\n    \n return ClosureVars(nonlocal_vars,global_vars,\n builtin_vars,unbound_names)\n \n \n \nTraceback=namedtuple('Traceback','filename lineno function code_context index')\n\ndef getframeinfo(frame,context=1):\n ''\n\n\n\n\n\n \n if istraceback(frame):\n  lineno=frame.tb_lineno\n  frame=frame.tb_frame\n else :\n  lineno=frame.f_lineno\n if not isframe(frame):\n  raise TypeError('{!r} is not a frame or traceback object'.format(frame))\n  \n filename=getsourcefile(frame)or getfile(frame)\n if context >0:\n  start=lineno -1 -context //2\n  try :\n   lines,lnum=findsource(frame)\n  except OSError:\n   lines=index=None\n  else :\n   start=max(0,min(start,len(lines)-context))\n   lines=lines[start:start+context]\n   index=lineno -1 -start\n else :\n  lines=index=None\n  \n return Traceback(filename,lineno,frame.f_code.co_name,lines,index)\n \ndef getlineno(frame):\n ''\n \n return frame.f_lineno\n \nFrameInfo=namedtuple('FrameInfo',('frame',)+Traceback._fields)\n\ndef getouterframes(frame,context=1):\n ''\n\n\n \n framelist=[]\n while frame:\n  frameinfo=(frame,)+getframeinfo(frame,context)\n  framelist.append(FrameInfo(*frameinfo))\n  frame=frame.f_back\n return framelist\n \ndef getinnerframes(tb,context=1):\n ''\n\n\n \n framelist=[]\n while tb:\n  frameinfo=(tb.tb_frame,)+getframeinfo(tb,context)\n  framelist.append(FrameInfo(*frameinfo))\n  tb=tb.tb_next\n return framelist\n \ndef currentframe():\n ''\n return sys._getframe(1)if hasattr(sys,\"_getframe\")else None\n \ndef stack(context=1):\n ''\n return getouterframes(sys._getframe(1),context)\n \ndef trace(context=1):\n ''\n return getinnerframes(sys.exc_info()[2],context)\n \n \n \n \n_sentinel=object()\n\ndef _static_getmro(klass):\n return type.__dict__['__mro__'].__get__(klass)\n \ndef _check_instance(obj,attr):\n instance_dict={}\n try :\n  instance_dict=object.__getattribute__(obj,\"__dict__\")\n except AttributeError:\n  pass\n return dict.get(instance_dict,attr,_sentinel)\n \n \ndef _check_class(klass,attr):\n for entry in _static_getmro(klass):\n  if _shadowed_dict(type(entry))is _sentinel:\n   try :\n    return entry.__dict__[attr]\n   except KeyError:\n    pass\n return _sentinel\n \ndef _is_type(obj):\n try :\n  _static_getmro(obj)\n except TypeError:\n  return False\n return True\n \ndef _shadowed_dict(klass):\n dict_attr=type.__dict__[\"__dict__\"]\n for entry in _static_getmro(klass):\n  try :\n   class_dict=dict_attr.__get__(entry)[\"__dict__\"]\n  except KeyError:\n   pass\n  else :\n   if not (type(class_dict)is types.GetSetDescriptorType and\n   class_dict.__name__ ==\"__dict__\"and\n   class_dict.__objclass__ is entry):\n    return class_dict\n return _sentinel\n \ndef getattr_static(obj,attr,default=_sentinel):\n ''\n\n\n\n\n\n\n\n\n \n instance_result=_sentinel\n if not _is_type(obj):\n  klass=type(obj)\n  dict_attr=_shadowed_dict(klass)\n  if (dict_attr is _sentinel or\n  type(dict_attr)is types.MemberDescriptorType):\n   instance_result=_check_instance(obj,attr)\n else :\n  klass=obj\n  \n klass_result=_check_class(klass,attr)\n \n if instance_result is not _sentinel and klass_result is not _sentinel:\n  if (_check_class(type(klass_result),'__get__')is not _sentinel and\n  _check_class(type(klass_result),'__set__')is not _sentinel):\n   return klass_result\n   \n if instance_result is not _sentinel:\n  return instance_result\n if klass_result is not _sentinel:\n  return klass_result\n  \n if obj is klass:\n \n  for entry in _static_getmro(type(klass)):\n   if _shadowed_dict(type(entry))is _sentinel:\n    try :\n     return entry.__dict__[attr]\n    except KeyError:\n     pass\n if default is not _sentinel:\n  return default\n raise AttributeError(attr)\n \n \n \n \nGEN_CREATED='GEN_CREATED'\nGEN_RUNNING='GEN_RUNNING'\nGEN_SUSPENDED='GEN_SUSPENDED'\nGEN_CLOSED='GEN_CLOSED'\n\ndef getgeneratorstate(generator):\n ''\n\n\n\n\n\n\n \n if generator.gi_running:\n  return GEN_RUNNING\n if generator.gi_frame is None :\n  return GEN_CLOSED\n if generator.gi_frame.f_lasti ==-1:\n  return GEN_CREATED\n return GEN_SUSPENDED\n \n \ndef getgeneratorlocals(generator):\n ''\n\n\n\n \n \n if not isgenerator(generator):\n  raise TypeError(\"{!r} is not a Python generator\".format(generator))\n  \n frame=getattr(generator,\"gi_frame\",None )\n if frame is not None :\n  return generator.gi_frame.f_locals\n else :\n  return {}\n  \n  \n  \n  \nCORO_CREATED='CORO_CREATED'\nCORO_RUNNING='CORO_RUNNING'\nCORO_SUSPENDED='CORO_SUSPENDED'\nCORO_CLOSED='CORO_CLOSED'\n\ndef getcoroutinestate(coroutine):\n ''\n\n\n\n\n\n\n \n if coroutine.cr_running:\n  return CORO_RUNNING\n if coroutine.cr_frame is None :\n  return CORO_CLOSED\n if coroutine.cr_frame.f_lasti ==-1:\n  return CORO_CREATED\n return CORO_SUSPENDED\n \n \ndef getcoroutinelocals(coroutine):\n ''\n\n\n\n \n frame=getattr(coroutine,\"cr_frame\",None )\n if frame is not None :\n  return frame.f_locals\n else :\n  return {}\n  \n  \n  \n  \n  \n  \n  \n_WrapperDescriptor=type(type.__call__)\n_MethodWrapper=type(all.__call__)\n_ClassMethodWrapper=type(int.__dict__['from_bytes'])\n\n_NonUserDefinedCallables=(_WrapperDescriptor,\n_MethodWrapper,\n_ClassMethodWrapper,\ntypes.BuiltinFunctionType)\n\n\ndef _signature_get_user_defined_method(cls,method_name):\n ''\n\n\n \n try :\n  meth=getattr(cls,method_name)\n except AttributeError:\n  return\n else :\n  if not isinstance(meth,_NonUserDefinedCallables):\n  \n  \n   return meth\n   \n   \ndef _signature_get_partial(wrapped_sig,partial,extra_args=()):\n ''\n\n\n \n \n old_params=wrapped_sig.parameters\n new_params=OrderedDict(old_params.items())\n \n partial_args=partial.args or ()\n partial_keywords=partial.keywords or {}\n \n if extra_args:\n  partial_args=extra_args+partial_args\n  \n try :\n  ba=wrapped_sig.bind_partial(*partial_args,**partial_keywords)\n except TypeError as ex:\n  msg='partial object {!r} has incorrect arguments'.format(partial)\n  raise ValueError(msg)from ex\n  \n  \n transform_to_kwonly=False\n for param_name,param in old_params.items():\n  try :\n   arg_value=ba.arguments[param_name]\n  except KeyError:\n   pass\n  else :\n   if param.kind is _POSITIONAL_ONLY:\n   \n   \n    new_params.pop(param_name)\n    continue\n    \n   if param.kind is _POSITIONAL_OR_KEYWORD:\n    if param_name in partial_keywords:\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n     transform_to_kwonly=True\n     \n     new_params[param_name]=param.replace(default=arg_value)\n    else :\n    \n     new_params.pop(param.name)\n     continue\n     \n   if param.kind is _KEYWORD_ONLY:\n   \n    new_params[param_name]=param.replace(default=arg_value)\n    \n  if transform_to_kwonly:\n   assert param.kind is not _POSITIONAL_ONLY\n   \n   if param.kind is _POSITIONAL_OR_KEYWORD:\n    new_param=new_params[param_name].replace(kind=_KEYWORD_ONLY)\n    new_params[param_name]=new_param\n    new_params.move_to_end(param_name)\n   elif param.kind in (_KEYWORD_ONLY,_VAR_KEYWORD):\n    new_params.move_to_end(param_name)\n   elif param.kind is _VAR_POSITIONAL:\n    new_params.pop(param.name)\n    \n return wrapped_sig.replace(parameters=new_params.values())\n \n \ndef _signature_bound_method(sig):\n ''\n\n \n \n params=tuple(sig.parameters.values())\n \n if not params or params[0].kind in (_VAR_KEYWORD,_KEYWORD_ONLY):\n  raise ValueError('invalid method signature')\n  \n kind=params[0].kind\n if kind in (_POSITIONAL_OR_KEYWORD,_POSITIONAL_ONLY):\n \n \n  params=params[1:]\n else :\n  if kind is not _VAR_POSITIONAL:\n  \n  \n   raise ValueError('invalid argument type')\n   \n   \n   \n return sig.replace(parameters=params)\n \n \ndef _signature_is_builtin(obj):\n ''\n\n \n return (isbuiltin(obj)or\n ismethoddescriptor(obj)or\n isinstance(obj,_NonUserDefinedCallables)or\n \n \n obj in (type,object))\n \n \ndef _signature_is_functionlike(obj):\n ''\n\n\n\n \n \n if not callable(obj)or isclass(obj):\n \n \n  return False\n  \n name=getattr(obj,'__name__',None )\n code=getattr(obj,'__code__',None )\n defaults=getattr(obj,'__defaults__',_void)\n kwdefaults=getattr(obj,'__kwdefaults__',_void)\n annotations=getattr(obj,'__annotations__',None )\n \n return (isinstance(code,types.CodeType)and\n isinstance(name,str)and\n (defaults is None or isinstance(defaults,tuple))and\n (kwdefaults is None or isinstance(kwdefaults,dict))and\n isinstance(annotations,dict))\n \n \ndef _signature_get_bound_param(spec):\n ''\n\n\n\n\n \n \n assert spec.startswith('($')\n \n pos=spec.find(',')\n if pos ==-1:\n  pos=spec.find(')')\n  \n cpos=spec.find(':')\n assert cpos ==-1 or cpos >pos\n \n cpos=spec.find('=')\n assert cpos ==-1 or cpos >pos\n \n return spec[2:pos]\n \n \ndef _signature_strip_non_python_syntax(signature):\n ''\n\n\n\n\n\n\n\n\n\n \n \n if not signature:\n  return signature,None ,None\n  \n self_parameter=None\n last_positional_only=None\n \n lines=[l.encode('ascii')for l in signature.split('\\n')]\n generator=iter(lines).__next__\n token_stream=tokenize.tokenize(generator)\n \n delayed_comma=False\n skip_next_comma=False\n text=[]\n add=text.append\n \n current_parameter=0\n OP=token.OP\n ERRORTOKEN=token.ERRORTOKEN\n \n \n t=next(token_stream)\n assert t.type ==tokenize.ENCODING\n \n for t in token_stream:\n  type,string=t.type,t.string\n  \n  if type ==OP:\n   if string ==',':\n    if skip_next_comma:\n     skip_next_comma=False\n    else :\n     assert not delayed_comma\n     delayed_comma=True\n     current_parameter +=1\n    continue\n    \n   if string =='/':\n    assert not skip_next_comma\n    assert last_positional_only is None\n    skip_next_comma=True\n    last_positional_only=current_parameter -1\n    continue\n    \n  if (type ==ERRORTOKEN)and (string =='$'):\n   assert self_parameter is None\n   self_parameter=current_parameter\n   continue\n   \n  if delayed_comma:\n   delayed_comma=False\n   if not ((type ==OP)and (string ==')')):\n    add(', ')\n  add(string)\n  if (string ==','):\n   add(' ')\n clean_signature=''.join(text)\n return clean_signature,self_parameter,last_positional_only\n \n \ndef _signature_fromstr(cls,obj,s,skip_bound_arg=True ):\n ''\n\n \n \n \n import ast\n \n Parameter=cls._parameter_cls\n \n clean_signature,self_parameter,last_positional_only=\\\n _signature_strip_non_python_syntax(s)\n \n program=\"def foo\"+clean_signature+\": pass\"\n \n try :\n  module=ast.parse(program)\n except SyntaxError:\n  module=None\n  \n if not isinstance(module,ast.Module):\n  raise ValueError(\"{!r} builtin has invalid signature\".format(obj))\n  \n f=module.body[0]\n \n parameters=[]\n empty=Parameter.empty\n invalid=object()\n \n module=None\n module_dict={}\n module_name=getattr(obj,'__module__',None )\n if module_name:\n  module=sys.modules.get(module_name,None )\n  if module:\n   module_dict=module.__dict__\n sys_module_dict=sys.modules.copy()\n \n def parse_name(node):\n  assert isinstance(node,ast.arg)\n  if node.annotation is not None :\n   raise ValueError(\"Annotations are not currently supported\")\n  return node.arg\n  \n def wrap_value(s):\n  try :\n   value=eval(s,module_dict)\n  except NameError:\n   try :\n    value=eval(s,sys_module_dict)\n   except NameError:\n    raise RuntimeError()\n    \n  if isinstance(value,(str,int,float,bytes,bool,type(None ))):\n   return ast.Constant(value)\n  raise RuntimeError()\n  \n class RewriteSymbolics(ast.NodeTransformer):\n  def visit_Attribute(self,node):\n   a=[]\n   n=node\n   while isinstance(n,ast.Attribute):\n    a.append(n.attr)\n    n=n.value\n   if not isinstance(n,ast.Name):\n    raise RuntimeError()\n   a.append(n.id)\n   value=\".\".join(reversed(a))\n   return wrap_value(value)\n   \n  def visit_Name(self,node):\n   if not isinstance(node.ctx,ast.Load):\n    raise ValueError()\n   return wrap_value(node.id)\n   \n def p(name_node,default_node,default=empty):\n  name=parse_name(name_node)\n  if name is invalid:\n   return None\n  if default_node and default_node is not _empty:\n   try :\n    default_node=RewriteSymbolics().visit(default_node)\n    o=ast.literal_eval(default_node)\n   except ValueError:\n    o=invalid\n   if o is invalid:\n    return None\n   default=o if o is not invalid else default\n  parameters.append(Parameter(name,kind,default=default,annotation=empty))\n  \n  \n args=reversed(f.args.args)\n defaults=reversed(f.args.defaults)\n iter=itertools.zip_longest(args,defaults,fillvalue=None )\n if last_positional_only is not None :\n  kind=Parameter.POSITIONAL_ONLY\n else :\n  kind=Parameter.POSITIONAL_OR_KEYWORD\n for i,(name,default)in enumerate(reversed(list(iter))):\n  p(name,default)\n  if i ==last_positional_only:\n   kind=Parameter.POSITIONAL_OR_KEYWORD\n   \n   \n if f.args.vararg:\n  kind=Parameter.VAR_POSITIONAL\n  p(f.args.vararg,empty)\n  \n  \n kind=Parameter.KEYWORD_ONLY\n for name,default in zip(f.args.kwonlyargs,f.args.kw_defaults):\n  p(name,default)\n  \n  \n if f.args.kwarg:\n  kind=Parameter.VAR_KEYWORD\n  p(f.args.kwarg,empty)\n  \n if self_parameter is not None :\n \n \n \n \n \n  assert parameters\n  _self=getattr(obj,'__self__',None )\n  self_isbound=_self is not None\n  self_ismodule=ismodule(_self)\n  if self_isbound and (self_ismodule or skip_bound_arg):\n   parameters.pop(0)\n  else :\n  \n   p=parameters[0].replace(kind=Parameter.POSITIONAL_ONLY)\n   parameters[0]=p\n   \n return cls(parameters,return_annotation=cls.empty)\n \n \ndef _signature_from_builtin(cls,func,skip_bound_arg=True ):\n ''\n\n \n \n if not _signature_is_builtin(func):\n  raise TypeError(\"{!r} is not a Python builtin \"\n  \"function\".format(func))\n  \n s=getattr(func,\"__text_signature__\",None )\n if not s:\n  raise ValueError(\"no signature found for builtin {!r}\".format(func))\n  \n return _signature_fromstr(cls,func,s,skip_bound_arg)\n \n \ndef _signature_from_function(cls,func,skip_bound_arg=True ):\n ''\n \n is_duck_function=False\n if not isfunction(func):\n  if _signature_is_functionlike(func):\n   is_duck_function=True\n  else :\n  \n  \n   raise TypeError('{!r} is not a Python function'.format(func))\n   \n s=getattr(func,\"__text_signature__\",None )\n if s:\n  return _signature_fromstr(cls,func,s,skip_bound_arg)\n  \n Parameter=cls._parameter_cls\n \n \n func_code=func.__code__\n pos_count=func_code.co_argcount\n arg_names=func_code.co_varnames\n posonly_count=func_code.co_posonlyargcount\n positional=arg_names[:pos_count]\n keyword_only_count=func_code.co_kwonlyargcount\n keyword_only=arg_names[pos_count:pos_count+keyword_only_count]\n annotations=func.__annotations__\n defaults=func.__defaults__\n kwdefaults=func.__kwdefaults__\n \n if defaults:\n  pos_default_count=len(defaults)\n else :\n  pos_default_count=0\n  \n parameters=[]\n \n non_default_count=pos_count -pos_default_count\n posonly_left=posonly_count\n \n \n for name in positional[:non_default_count]:\n  kind=_POSITIONAL_ONLY if posonly_left else _POSITIONAL_OR_KEYWORD\n  annotation=annotations.get(name,_empty)\n  parameters.append(Parameter(name,annotation=annotation,\n  kind=kind))\n  if posonly_left:\n   posonly_left -=1\n   \n   \n for offset,name in enumerate(positional[non_default_count:]):\n  kind=_POSITIONAL_ONLY if posonly_left else _POSITIONAL_OR_KEYWORD\n  annotation=annotations.get(name,_empty)\n  parameters.append(Parameter(name,annotation=annotation,\n  kind=kind,\n  default=defaults[offset]))\n  if posonly_left:\n   posonly_left -=1\n   \n   \n if func_code.co_flags&CO_VARARGS:\n  name=arg_names[pos_count+keyword_only_count]\n  annotation=annotations.get(name,_empty)\n  parameters.append(Parameter(name,annotation=annotation,\n  kind=_VAR_POSITIONAL))\n  \n  \n for name in keyword_only:\n  default=_empty\n  if kwdefaults is not None :\n   default=kwdefaults.get(name,_empty)\n   \n  annotation=annotations.get(name,_empty)\n  parameters.append(Parameter(name,annotation=annotation,\n  kind=_KEYWORD_ONLY,\n  default=default))\n  \n if func_code.co_flags&CO_VARKEYWORDS:\n  index=pos_count+keyword_only_count\n  if func_code.co_flags&CO_VARARGS:\n   index +=1\n   \n  name=arg_names[index]\n  annotation=annotations.get(name,_empty)\n  parameters.append(Parameter(name,annotation=annotation,\n  kind=_VAR_KEYWORD))\n  \n  \n  \n return cls(parameters,\n return_annotation=annotations.get('return',_empty),\n __validate_parameters__=is_duck_function)\n \n \ndef _signature_from_callable(obj,*,\nfollow_wrapper_chains=True ,\nskip_bound_arg=True ,\nsigcls):\n\n ''\n\n \n \n if not callable(obj):\n  raise TypeError('{!r} is not a callable object'.format(obj))\n  \n if isinstance(obj,types.MethodType):\n \n \n  sig=_signature_from_callable(\n  obj.__func__,\n  follow_wrapper_chains=follow_wrapper_chains,\n  skip_bound_arg=skip_bound_arg,\n  sigcls=sigcls)\n  \n  if skip_bound_arg:\n   return _signature_bound_method(sig)\n  else :\n   return sig\n   \n   \n if follow_wrapper_chains:\n  obj=unwrap(obj,stop=(lambda f:hasattr(f,\"__signature__\")))\n  if isinstance(obj,types.MethodType):\n  \n  \n  \n   return _signature_from_callable(\n   obj,\n   follow_wrapper_chains=follow_wrapper_chains,\n   skip_bound_arg=skip_bound_arg,\n   sigcls=sigcls)\n   \n try :\n  sig=obj.__signature__\n except AttributeError:\n  pass\n else :\n  if sig is not None :\n   if not isinstance(sig,Signature):\n    raise TypeError(\n    'unexpected object {!r} in __signature__ '\n    'attribute'.format(sig))\n   return sig\n   \n try :\n  partialmethod=obj._partialmethod\n except AttributeError:\n  pass\n else :\n  if isinstance(partialmethod,functools.partialmethod):\n  \n  \n  \n  \n  \n  \n  \n   wrapped_sig=_signature_from_callable(\n   partialmethod.func,\n   follow_wrapper_chains=follow_wrapper_chains,\n   skip_bound_arg=skip_bound_arg,\n   sigcls=sigcls)\n   \n   sig=_signature_get_partial(wrapped_sig,partialmethod,(None ,))\n   first_wrapped_param=tuple(wrapped_sig.parameters.values())[0]\n   if first_wrapped_param.kind is Parameter.VAR_POSITIONAL:\n   \n   \n    return sig\n   else :\n    sig_params=tuple(sig.parameters.values())\n    assert (not sig_params or\n    first_wrapped_param is not sig_params[0])\n    new_params=(first_wrapped_param,)+sig_params\n    return sig.replace(parameters=new_params)\n    \n if isfunction(obj)or _signature_is_functionlike(obj):\n \n \n  return _signature_from_function(sigcls,obj,\n  skip_bound_arg=skip_bound_arg)\n  \n if _signature_is_builtin(obj):\n  return _signature_from_builtin(sigcls,obj,\n  skip_bound_arg=skip_bound_arg)\n  \n if isinstance(obj,functools.partial):\n  wrapped_sig=_signature_from_callable(\n  obj.func,\n  follow_wrapper_chains=follow_wrapper_chains,\n  skip_bound_arg=skip_bound_arg,\n  sigcls=sigcls)\n  return _signature_get_partial(wrapped_sig,obj)\n  \n sig=None\n if isinstance(obj,type):\n \n \n \n \n  call=_signature_get_user_defined_method(type(obj),'__call__')\n  if call is not None :\n   sig=_signature_from_callable(\n   call,\n   follow_wrapper_chains=follow_wrapper_chains,\n   skip_bound_arg=skip_bound_arg,\n   sigcls=sigcls)\n  else :\n  \n   new=_signature_get_user_defined_method(obj,'__new__')\n   if new is not None :\n    sig=_signature_from_callable(\n    new,\n    follow_wrapper_chains=follow_wrapper_chains,\n    skip_bound_arg=skip_bound_arg,\n    sigcls=sigcls)\n   else :\n   \n    init=_signature_get_user_defined_method(obj,'__init__')\n    if init is not None :\n     sig=_signature_from_callable(\n     init,\n     follow_wrapper_chains=follow_wrapper_chains,\n     skip_bound_arg=skip_bound_arg,\n     sigcls=sigcls)\n     \n  if sig is None :\n  \n  \n  \n   for base in obj.__mro__[:-1]:\n   \n   \n   \n   \n   \n   \n   \n    try :\n     text_sig=base.__text_signature__\n    except AttributeError:\n     pass\n    else :\n     if text_sig:\n     \n     \n      return _signature_fromstr(sigcls,obj,text_sig)\n      \n      \n      \n      \n   if type not in obj.__mro__:\n   \n   \n    if (obj.__init__ is object.__init__ and\n    obj.__new__ is object.__new__):\n    \n     return sigcls.from_callable(object)\n    else :\n     raise ValueError(\n     'no signature found for builtin type {!r}'.format(obj))\n     \n elif not isinstance(obj,_NonUserDefinedCallables):\n \n \n \n \n  call=_signature_get_user_defined_method(type(obj),'__call__')\n  if call is not None :\n   try :\n    sig=_signature_from_callable(\n    call,\n    follow_wrapper_chains=follow_wrapper_chains,\n    skip_bound_arg=skip_bound_arg,\n    sigcls=sigcls)\n   except ValueError as ex:\n    msg='no signature found for {!r}'.format(obj)\n    raise ValueError(msg)from ex\n    \n if sig is not None :\n \n \n  if skip_bound_arg:\n   return _signature_bound_method(sig)\n  else :\n   return sig\n   \n if isinstance(obj,types.BuiltinFunctionType):\n \n  msg='no signature found for builtin function {!r}'.format(obj)\n  raise ValueError(msg)\n  \n raise ValueError('callable {!r} is not supported by signature'.format(obj))\n \n \nclass _void:\n ''\n \n \nclass _empty:\n ''\n \n \nclass _ParameterKind(enum.IntEnum):\n POSITIONAL_ONLY=0\n POSITIONAL_OR_KEYWORD=1\n VAR_POSITIONAL=2\n KEYWORD_ONLY=3\n VAR_KEYWORD=4\n \n def __str__(self):\n  return self._name_\n  \n @property\n def description(self):\n  return _PARAM_NAME_MAPPING[self]\n  \n_POSITIONAL_ONLY=_ParameterKind.POSITIONAL_ONLY\n_POSITIONAL_OR_KEYWORD=_ParameterKind.POSITIONAL_OR_KEYWORD\n_VAR_POSITIONAL=_ParameterKind.VAR_POSITIONAL\n_KEYWORD_ONLY=_ParameterKind.KEYWORD_ONLY\n_VAR_KEYWORD=_ParameterKind.VAR_KEYWORD\n\n_PARAM_NAME_MAPPING={\n_POSITIONAL_ONLY:'positional-only',\n_POSITIONAL_OR_KEYWORD:'positional or keyword',\n_VAR_POSITIONAL:'variadic positional',\n_KEYWORD_ONLY:'keyword-only',\n_VAR_KEYWORD:'variadic keyword'\n}\n\n\nclass Parameter:\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n __slots__=('_name','_kind','_default','_annotation')\n \n POSITIONAL_ONLY=_POSITIONAL_ONLY\n POSITIONAL_OR_KEYWORD=_POSITIONAL_OR_KEYWORD\n VAR_POSITIONAL=_VAR_POSITIONAL\n KEYWORD_ONLY=_KEYWORD_ONLY\n VAR_KEYWORD=_VAR_KEYWORD\n \n empty=_empty\n \n def __init__(self,name,kind,*,default=_empty,annotation=_empty):\n  try :\n   self._kind=_ParameterKind(kind)\n  except ValueError:\n   raise ValueError(f'value {kind!r} is not a valid Parameter.kind')\n  if default is not _empty:\n   if self._kind in (_VAR_POSITIONAL,_VAR_KEYWORD):\n    msg='{} parameters cannot have default values'\n    msg=msg.format(self._kind.description)\n    raise ValueError(msg)\n  self._default=default\n  self._annotation=annotation\n  \n  if name is _empty:\n   raise ValueError('name is a required attribute for Parameter')\n   \n  if not isinstance(name,str):\n   msg='name must be a str, not a {}'.format(type(name).__name__)\n   raise TypeError(msg)\n   \n  if name[0]=='.'and name[1:].isdigit():\n  \n  \n  \n  \n   if self._kind !=_POSITIONAL_OR_KEYWORD:\n    msg=(\n    'implicit arguments must be passed as '\n    'positional or keyword arguments, not {}'\n    )\n    msg=msg.format(self._kind.description)\n    raise ValueError(msg)\n   self._kind=_POSITIONAL_ONLY\n   name='implicit{}'.format(name[1:])\n   \n  if not name.isidentifier():\n   raise ValueError('{!r} is not a valid parameter name'.format(name))\n   \n  self._name=name\n  \n def __reduce__(self):\n  return (type(self),\n  (self._name,self._kind),\n  {'_default':self._default,\n  '_annotation':self._annotation})\n  \n def __setstate__(self,state):\n  self._default=state['_default']\n  self._annotation=state['_annotation']\n  \n @property\n def name(self):\n  return self._name\n  \n @property\n def default(self):\n  return self._default\n  \n @property\n def annotation(self):\n  return self._annotation\n  \n @property\n def kind(self):\n  return self._kind\n  \n def replace(self,*,name=_void,kind=_void,\n annotation=_void,default=_void):\n  ''\n  \n  if name is _void:\n   name=self._name\n   \n  if kind is _void:\n   kind=self._kind\n   \n  if annotation is _void:\n   annotation=self._annotation\n   \n  if default is _void:\n   default=self._default\n   \n  return type(self)(name,kind,default=default,annotation=annotation)\n  \n def __str__(self):\n  kind=self.kind\n  formatted=self._name\n  \n  \n  if self._annotation is not _empty:\n   formatted='{}: {}'.format(formatted,\n   formatannotation(self._annotation))\n   \n  if self._default is not _empty:\n   if self._annotation is not _empty:\n    formatted='{} = {}'.format(formatted,repr(self._default))\n   else :\n    formatted='{}={}'.format(formatted,repr(self._default))\n    \n  if kind ==_VAR_POSITIONAL:\n   formatted='*'+formatted\n  elif kind ==_VAR_KEYWORD:\n   formatted='**'+formatted\n   \n  return formatted\n  \n def __repr__(self):\n  return '<{} \"{}\">'.format(self.__class__.__name__,self)\n  \n def __hash__(self):\n  return hash((self.name,self.kind,self.annotation,self.default))\n  \n def __eq__(self,other):\n  if self is other:\n   return True\n  if not isinstance(other,Parameter):\n   return NotImplemented\n  return (self._name ==other._name and\n  self._kind ==other._kind and\n  self._default ==other._default and\n  self._annotation ==other._annotation)\n  \n  \nclass BoundArguments:\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n __slots__=('arguments','_signature','__weakref__')\n \n def __init__(self,signature,arguments):\n  self.arguments=arguments\n  self._signature=signature\n  \n @property\n def signature(self):\n  return self._signature\n  \n @property\n def args(self):\n  args=[]\n  for param_name,param in self._signature.parameters.items():\n   if param.kind in (_VAR_KEYWORD,_KEYWORD_ONLY):\n    break\n    \n   try :\n    arg=self.arguments[param_name]\n   except KeyError:\n   \n   \n    break\n   else :\n    if param.kind ==_VAR_POSITIONAL:\n    \n     args.extend(arg)\n    else :\n    \n     args.append(arg)\n     \n  return tuple(args)\n  \n @property\n def kwargs(self):\n  kwargs={}\n  kwargs_started=False\n  for param_name,param in self._signature.parameters.items():\n   if not kwargs_started:\n    if param.kind in (_VAR_KEYWORD,_KEYWORD_ONLY):\n     kwargs_started=True\n    else :\n     if param_name not in self.arguments:\n      kwargs_started=True\n      continue\n      \n   if not kwargs_started:\n    continue\n    \n   try :\n    arg=self.arguments[param_name]\n   except KeyError:\n    pass\n   else :\n    if param.kind ==_VAR_KEYWORD:\n    \n     kwargs.update(arg)\n    else :\n    \n     kwargs[param_name]=arg\n     \n  return kwargs\n  \n def apply_defaults(self):\n  ''\n\n\n\n\n\n\n  \n  arguments=self.arguments\n  new_arguments=[]\n  for name,param in self._signature.parameters.items():\n   try :\n    new_arguments.append((name,arguments[name]))\n   except KeyError:\n    if param.default is not _empty:\n     val=param.default\n    elif param.kind is _VAR_POSITIONAL:\n     val=()\n    elif param.kind is _VAR_KEYWORD:\n     val={}\n    else :\n    \n    \n     continue\n    new_arguments.append((name,val))\n  self.arguments=OrderedDict(new_arguments)\n  \n def __eq__(self,other):\n  if self is other:\n   return True\n  if not isinstance(other,BoundArguments):\n   return NotImplemented\n  return (self.signature ==other.signature and\n  self.arguments ==other.arguments)\n  \n def __setstate__(self,state):\n  self._signature=state['_signature']\n  self.arguments=state['arguments']\n  \n def __getstate__(self):\n  return {'_signature':self._signature,'arguments':self.arguments}\n  \n def __repr__(self):\n  args=[]\n  for arg,value in self.arguments.items():\n   args.append('{}={!r}'.format(arg,value))\n  return '<{} ({})>'.format(self.__class__.__name__,', '.join(args))\n  \n  \nclass Signature:\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n __slots__=('_return_annotation','_parameters')\n \n _parameter_cls=Parameter\n _bound_arguments_cls=BoundArguments\n \n empty=_empty\n \n def __init__(self,parameters=None ,*,return_annotation=_empty,\n __validate_parameters__=True ):\n  ''\n\n  \n  \n  if parameters is None :\n   params=OrderedDict()\n  else :\n   if __validate_parameters__:\n    params=OrderedDict()\n    top_kind=_POSITIONAL_ONLY\n    kind_defaults=False\n    \n    for idx,param in enumerate(parameters):\n     kind=param.kind\n     name=param.name\n     \n     if kind <top_kind:\n      msg=(\n      'wrong parameter order: {} parameter before {} '\n      'parameter'\n      )\n      msg=msg.format(top_kind.description,\n      kind.description)\n      raise ValueError(msg)\n     elif kind >top_kind:\n      kind_defaults=False\n      top_kind=kind\n      \n     if kind in (_POSITIONAL_ONLY,_POSITIONAL_OR_KEYWORD):\n      if param.default is _empty:\n       if kind_defaults:\n       \n       \n       \n        msg='non-default argument follows default '\\\n        'argument'\n        raise ValueError(msg)\n      else :\n      \n       kind_defaults=True\n       \n     if name in params:\n      msg='duplicate parameter name: {!r}'.format(name)\n      raise ValueError(msg)\n      \n     params[name]=param\n   else :\n    params=OrderedDict(((param.name,param)\n    for param in parameters))\n    \n  self._parameters=types.MappingProxyType(params)\n  self._return_annotation=return_annotation\n  \n @classmethod\n def from_function(cls,func):\n  ''\n\n\n  \n  \n  warnings.warn(\"inspect.Signature.from_function() is deprecated since \"\n  \"Python 3.5, use Signature.from_callable()\",\n  DeprecationWarning,stacklevel=2)\n  return _signature_from_function(cls,func)\n  \n @classmethod\n def from_builtin(cls,func):\n  ''\n\n\n  \n  \n  warnings.warn(\"inspect.Signature.from_builtin() is deprecated since \"\n  \"Python 3.5, use Signature.from_callable()\",\n  DeprecationWarning,stacklevel=2)\n  return _signature_from_builtin(cls,func)\n  \n @classmethod\n def from_callable(cls,obj,*,follow_wrapped=True ):\n  ''\n  return _signature_from_callable(obj,sigcls=cls,\n  follow_wrapper_chains=follow_wrapped)\n  \n @property\n def parameters(self):\n  return self._parameters\n  \n @property\n def return_annotation(self):\n  return self._return_annotation\n  \n def replace(self,*,parameters=_void,return_annotation=_void):\n  ''\n\n\n  \n  \n  if parameters is _void:\n   parameters=self.parameters.values()\n   \n  if return_annotation is _void:\n   return_annotation=self._return_annotation\n   \n  return type(self)(parameters,\n  return_annotation=return_annotation)\n  \n def _hash_basis(self):\n  params=tuple(param for param in self.parameters.values()\n  if param.kind !=_KEYWORD_ONLY)\n  \n  kwo_params={param.name:param for param in self.parameters.values()\n  if param.kind ==_KEYWORD_ONLY}\n  \n  return params,kwo_params,self.return_annotation\n  \n def __hash__(self):\n  params,kwo_params,return_annotation=self._hash_basis()\n  kwo_params=frozenset(kwo_params.values())\n  return hash((params,kwo_params,return_annotation))\n  \n def __eq__(self,other):\n  if self is other:\n   return True\n  if not isinstance(other,Signature):\n   return NotImplemented\n  return self._hash_basis()==other._hash_basis()\n  \n def _bind(self,args,kwargs,*,partial=False ):\n  ''\n  \n  arguments=OrderedDict()\n  \n  parameters=iter(self.parameters.values())\n  parameters_ex=()\n  arg_vals=iter(args)\n  \n  while True :\n  \n  \n   try :\n    arg_val=next(arg_vals)\n   except StopIteration:\n   \n    try :\n     param=next(parameters)\n    except StopIteration:\n    \n    \n     break\n    else :\n     if param.kind ==_VAR_POSITIONAL:\n     \n     \n      break\n     elif param.name in kwargs:\n      if param.kind ==_POSITIONAL_ONLY:\n       msg='{arg!r} parameter is positional only, '\\\n       'but was passed as a keyword'\n       msg=msg.format(arg=param.name)\n       raise TypeError(msg)from None\n      parameters_ex=(param,)\n      break\n     elif (param.kind ==_VAR_KEYWORD or\n     param.default is not _empty):\n     \n     \n     \n      parameters_ex=(param,)\n      break\n     else :\n     \n     \n      if partial:\n       parameters_ex=(param,)\n       break\n      else :\n       msg='missing a required argument: {arg!r}'\n       msg=msg.format(arg=param.name)\n       raise TypeError(msg)from None\n   else :\n   \n    try :\n     param=next(parameters)\n    except StopIteration:\n     raise TypeError('too many positional arguments')from None\n    else :\n     if param.kind in (_VAR_KEYWORD,_KEYWORD_ONLY):\n     \n     \n      raise TypeError(\n      'too many positional arguments')from None\n      \n     if param.kind ==_VAR_POSITIONAL:\n     \n     \n     \n      values=[arg_val]\n      values.extend(arg_vals)\n      arguments[param.name]=tuple(values)\n      break\n      \n     if param.name in kwargs:\n      raise TypeError(\n      'multiple values for argument {arg!r}'.format(\n      arg=param.name))from None\n      \n     arguments[param.name]=arg_val\n     \n     \n     \n  kwargs_param=None\n  for param in itertools.chain(parameters_ex,parameters):\n   if param.kind ==_VAR_KEYWORD:\n   \n    kwargs_param=param\n    continue\n    \n   if param.kind ==_VAR_POSITIONAL:\n   \n   \n   \n    continue\n    \n   param_name=param.name\n   try :\n    arg_val=kwargs.pop(param_name)\n   except KeyError:\n   \n   \n   \n   \n    if (not partial and param.kind !=_VAR_POSITIONAL and\n    param.default is _empty):\n     raise TypeError('missing a required argument: {arg!r}'.\\\n     format(arg=param_name))from None\n     \n   else :\n    if param.kind ==_POSITIONAL_ONLY:\n    \n    \n    \n     raise TypeError('{arg!r} parameter is positional only, '\n     'but was passed as a keyword'.\\\n     format(arg=param.name))\n     \n    arguments[param_name]=arg_val\n    \n  if kwargs:\n   if kwargs_param is not None :\n   \n    arguments[kwargs_param.name]=kwargs\n   else :\n    raise TypeError(\n    'got an unexpected keyword argument {arg!r}'.format(\n    arg=next(iter(kwargs))))\n    \n  return self._bound_arguments_cls(self,arguments)\n  \n def bind(self,/,*args,**kwargs):\n  ''\n\n\n  \n  return self._bind(args,kwargs)\n  \n def bind_partial(self,/,*args,**kwargs):\n  ''\n\n\n  \n  return self._bind(args,kwargs,partial=True )\n  \n def __reduce__(self):\n  return (type(self),\n  (tuple(self._parameters.values()),),\n  {'_return_annotation':self._return_annotation})\n  \n def __setstate__(self,state):\n  self._return_annotation=state['_return_annotation']\n  \n def __repr__(self):\n  return '<{} {}>'.format(self.__class__.__name__,self)\n  \n def __str__(self):\n  result=[]\n  render_pos_only_separator=False\n  render_kw_only_separator=True\n  for param in self.parameters.values():\n   formatted=str(param)\n   \n   kind=param.kind\n   \n   if kind ==_POSITIONAL_ONLY:\n    render_pos_only_separator=True\n   elif render_pos_only_separator:\n   \n   \n    result.append('/')\n    render_pos_only_separator=False\n    \n   if kind ==_VAR_POSITIONAL:\n   \n   \n    render_kw_only_separator=False\n   elif kind ==_KEYWORD_ONLY and render_kw_only_separator:\n   \n   \n   \n    result.append('*')\n    \n    \n    render_kw_only_separator=False\n    \n   result.append(formatted)\n   \n  if render_pos_only_separator:\n  \n  \n   result.append('/')\n   \n  rendered='({})'.format(', '.join(result))\n  \n  if self.return_annotation is not _empty:\n   anno=formatannotation(self.return_annotation)\n   rendered +=' -> {}'.format(anno)\n   \n  return rendered\n  \n  \ndef signature(obj,*,follow_wrapped=True ):\n ''\n return Signature.from_callable(obj,follow_wrapped=follow_wrapped)\n \n \ndef _main():\n ''\n import argparse\n import importlib\n \n parser=argparse.ArgumentParser()\n parser.add_argument(\n 'object',\n help=\"The object to be analysed. \"\n \"It supports the 'module:qualname' syntax\")\n parser.add_argument(\n '-d','--details',action='store_true',\n help='Display info about the module rather than its source code')\n \n args=parser.parse_args()\n \n target=args.object\n mod_name,has_attrs,attrs=target.partition(\":\")\n try :\n  obj=module=importlib.import_module(mod_name)\n except Exception as exc:\n  msg=\"Failed to import {} ({}: {})\".format(mod_name,\n  type(exc).__name__,\n  exc)\n  print(msg,file=sys.stderr)\n  sys.exit(2)\n  \n if has_attrs:\n  parts=attrs.split(\".\")\n  obj=module\n  for part in parts:\n   obj=getattr(obj,part)\n   \n if module.__name__ in sys.builtin_module_names:\n  print(\"Can't get info for builtin modules.\",file=sys.stderr)\n  sys.exit(1)\n  \n if args.details:\n  print('Target: {}'.format(target))\n  print('Origin: {}'.format(getsourcefile(module)))\n  print('Cached: {}'.format(module.__cached__))\n  if obj is module:\n   print('Loader: {}'.format(repr(module.__loader__)))\n   if hasattr(module,'__path__'):\n    print('Submodule search path: {}'.format(module.__path__))\n  else :\n   try :\n    __,lineno=findsource(obj)\n   except Exception:\n    pass\n   else :\n    print('Line: {}'.format(lineno))\n    \n  print('\\n')\n else :\n  print(getsource(obj))\n  \n  \nif __name__ ==\"__main__\":\n _main()\n", ["abc", "argparse", "ast", "builtins", "collections", "collections.abc", "dis", "enum", "functools", "importlib", "importlib.machinery", "itertools", "linecache", "operator", "os", "re", "sys", "token", "tokenize", "types", "warnings"]],
-    "interpreter": [".py", "import sys\nimport builtins\n\nimport tb as traceback\n\nfrom browser import console,document,window,html,DOMNode\nfrom browser.widgets.dialog import Dialog\n\n_credits=\"\"\"    Thanks to CWI, CNRI, BeOpen.com, Zope Corporation and a cast of thousands\n    for supporting Python development.  See www.python.org for more information.\"\"\"\n\n_copyright=\"\"\"Copyright (c) 2012, Pierre Quentel pierre.quentel@gmail.com\nAll Rights Reserved.\n\nCopyright (c) 2001-2013 Python Software Foundation.\nAll Rights Reserved.\n\nCopyright (c) 2000 BeOpen.com.\nAll Rights Reserved.\n\nCopyright (c) 1995-2001 Corporation for National Research Initiatives.\nAll Rights Reserved.\n\nCopyright (c) 1991-1995 Stichting Mathematisch Centrum, Amsterdam.\nAll Rights Reserved.\"\"\"\n\n_license=\"\"\"Copyright (c) 2012, Pierre Quentel pierre.quentel@gmail.com\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\nRedistributions of source code must retain the above copyright notice, this\nlist of conditions and the following disclaimer. Redistributions in binary\nform must reproduce the above copyright notice, this list of conditions and\nthe following disclaimer in the documentation and/or other materials provided\nwith the distribution.\nNeither the name of the <ORGANIZATION> nor the names of its contributors may\nbe used to endorse or promote products derived from this software without\nspecific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\nARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\nCONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\nSUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\nINTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\nCONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\nARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGE.\n\"\"\"\n\nclass Info:\n\n def __init__(self,msg):\n  self.msg=msg\n  \n def __repr__(self):\n  return self.msg\n  \n  \n  \neditor_ns={\n'credits':Info(_credits),\n'copyright':Info(_copyright),\n'license':Info(_license),\n'__annotations__':{},\n'__builtins__':builtins,\n'__doc__':None ,\n'__name__':'__main__'\n}\n\n\nstyle_sheet=\"\"\"\n.brython-interpreter {\n    background-color: #000;\n    color: #fff;\n    font-family: consolas, courier;\n}\n\"\"\"\n\n\nclass Trace:\n\n def __init__(self):\n  self.buf=\"\"\n  \n def write(self,data):\n  self.buf +=str(data)\n  \n def format(self):\n  ''\n  lines=self.buf.split(\"\\n\")\n  stripped=[lines[0]]\n  for i in range(1,len(lines),2):\n   if __file__ in lines[i]:\n    continue\n   stripped +=lines[i:i+2]\n  return \"\\n\".join(stripped)\n  \n  \nclass Interpreter:\n ''\n \n def __init__(self,elt_id=None ,title=\"Interactive Interpreter\",\n globals=None ,locals=None ,history=None ,\n rows=30,cols=84,default_css=True ,\n clear_zone=True ,banner=True ):\n  ''\n\n\n\n\n\n  \n  if default_css:\n  \n   for stylesheet in document.styleSheets:\n    if stylesheet.ownerNode.id ==\"brython-interpreter\":\n     break\n   else :\n    document <=html.STYLE(style_sheet,id=\"brython-interpreter\")\n    \n  if elt_id is None :\n   self.dialog=Dialog(title=title,top=10,left=10,\n   default_css=default_css)\n   self.zone=html.TEXTAREA(rows=rows,cols=cols,\n   Class=\"brython-interpreter\")\n   self.dialog.panel <=self.zone\n  else :\n   if isinstance(elt_id,str):\n    try :\n     elt=document[elt_id]\n     if elt.tagName !=\"TEXTAREA\":\n      raise ValueError(\n      f\"element {elt_id} is a {elt.tagName}, \"+\n      \"not a TEXTAREA\")\n     self.zone=elt\n    except KeyError:\n     raise KeyError(f\"no element with id '{elt_id}'\")\n   elif isinstance(elt_id,DOMNode):\n    if elt_id.tagName ==\"TEXTAREA\":\n     self.zone=elt_id\n    else :\n     raise ValueError(\"element is not a TEXTAREA\")\n   else :\n    raise ValueError(\"element should be a string or \"+\n    f\"a TEXTAREA, got '{elt_id.__class__.__name__}'\")\n  v=sys.implementation.version\n  if clear_zone:\n   self.zone.value=''\n  if banner:\n   self.zone.value +=(\n   f\"Brython {v[0]}.{v[1]}.{v[2]} on \"\n   f\"{window.navigator.appName} {window.navigator.appVersion}\"\n   \"\\n\"\n   )\n  self.zone.value +=\">>> \"\n  self.cursor_to_end()\n  self._status=\"main\"\n  self.history=history or []\n  self.current=len(self.history)\n  \n  self.globals={}if globals is None else globals\n  self.globals.update(editor_ns)\n  self.locals=self.globals if locals is None else locals\n  \n  self.buffer=''\n  sys.stdout.write=sys.stderr.write=self.write\n  sys.stdout.__len__=sys.stderr.__len__=lambda :len(self.buffer)\n  \n  self.zone.bind('keypress',self.keypress)\n  self.zone.bind('keydown',self.keydown)\n  self.zone.bind('mouseup',self.mouseup)\n  \n  self.zone.focus()\n  \n def cursor_to_end(self,*args):\n  pos=len(self.zone.value)\n  self.zone.setSelectionRange(pos,pos)\n  self.zone.scrollTop=self.zone.scrollHeight\n  \n def get_col(self):\n \n  sel=self.zone.selectionStart\n  lines=self.zone.value.split('\\n')\n  for line in lines[:-1]:\n   sel -=len(line)+1\n  return sel\n  \n def keypress(self,event):\n  if event.keyCode ==9:\n   event.preventDefault()\n   self.zone.value +=\"    \"\n  elif event.keyCode ==13:\n   sel_start=self.zone.selectionStart\n   sel_end=self.zone.selectionEnd\n   if sel_end >sel_start:\n   \n    document.execCommand(\"copy\")\n    self.cursor_to_end()\n    event.preventDefault()\n    return\n   src=self.zone.value\n   if self._status ==\"main\":\n    currentLine=src[src.rfind('\\n>>>')+5:]\n   elif self._status ==\"3string\":\n    currentLine=src[src.rfind('\\n>>>')+5:]\n    currentLine=currentLine.replace('\\n... ','\\n')\n   else :\n    currentLine=src[src.rfind('\\n...')+5:]\n   if self._status =='main'and not currentLine.strip():\n    self.zone.value +='\\n>>> '\n    event.preventDefault()\n    return\n   self.zone.value +='\\n'\n   self.history.append(currentLine)\n   self.current=len(self.history)\n   if self._status in [\"main\",\"3string\"]:\n    try :\n     _=self.globals['_']=eval(currentLine,\n     self.globals,\n     self.locals)\n     if _ is not None :\n      self.write(repr(_)+'\\n')\n     self.flush()\n     self.zone.value +='>>> '\n     self._status=\"main\"\n    except IndentationError:\n     self.zone.value +='... '\n     self._status=\"block\"\n    except SyntaxError as msg:\n     if str(msg)=='invalid syntax : triple string end not found'or\\\n     str(msg).startswith('Unbalanced bracket'):\n      self.zone.value +='... '\n      self._status=\"3string\"\n     elif str(msg)=='eval() argument must be an expression':\n      try :\n       exec(currentLine,\n       self.globals,\n       self.locals)\n      except :\n       self.print_tb()\n      self.flush()\n      self.zone.value +='>>> '\n      self._status=\"main\"\n     elif str(msg)=='decorator expects function':\n      self.zone.value +='... '\n      self._status=\"block\"\n     else :\n      self.syntax_error(msg.args)\n      self.zone.value +='>>> '\n      self._status=\"main\"\n    except :\n    \n    \n    \n     self.print_tb()\n     self.zone.value +='>>> '\n     self._status=\"main\"\n   elif currentLine ==\"\":\n    block=src[src.rfind('\\n>>>')+5:].splitlines()\n    block=[block[0]]+[b[4:]for b in block[1:]]\n    block_src='\\n'.join(block)\n    \n    self._status=\"main\"\n    try :\n     _=exec(block_src,\n     self.globals,\n     self.locals)\n     if _ is not None :\n      print(repr(_))\n    except :\n     self.print_tb()\n    self.flush()\n    self.zone.value +='>>> '\n   else :\n    self.zone.value +='... '\n    \n   self.cursor_to_end()\n   event.preventDefault()\n   \n def keydown(self,event):\n  if event.keyCode ==37:\n   sel=self.get_col()\n   if sel <5:\n    event.preventDefault()\n    event.stopPropagation()\n  elif event.keyCode ==36:\n   pos=self.zone.selectionStart\n   col=self.get_col()\n   self.zone.setSelectionRange(pos -col+4,pos -col+4)\n   event.preventDefault()\n  elif event.keyCode ==38:\n   if self.current >0:\n    pos=self.zone.selectionStart\n    col=self.get_col()\n    \n    self.zone.value=self.zone.value[:pos -col+4]\n    self.current -=1\n    self.zone.value +=self.history[self.current]\n   event.preventDefault()\n  elif event.keyCode ==40:\n   if self.current <len(self.history)-1:\n    pos=self.zone.selectionStart\n    col=self.get_col()\n    \n    self.zone.value=self.zone.value[:pos -col+4]\n    self.current +=1\n    self.zone.value +=self.history[self.current]\n   event.preventDefault()\n  elif event.keyCode ==8:\n   src=self.zone.value\n   lstart=src.rfind('\\n')\n   if (lstart ==-1 and len(src)<5)or (len(src)-lstart <6):\n    event.preventDefault()\n    event.stopPropagation()\n  elif event.keyCode in [33,34]:\n   event.preventDefault()\n   \n def mouseup(self,ev):\n  ''\n  sel_start=self.zone.selectionStart\n  sel_end=self.zone.selectionEnd\n  if sel_end ==sel_start:\n   self.cursor_to_end()\n   \n def write(self,data):\n  self.buffer +=str(data)\n  \n def flush(self):\n  self.zone.value +=self.buffer\n  self.buffer=''\n  \n def print_tb(self):\n  trace=Trace()\n  traceback.print_exc(file=trace)\n  self.write(trace.format())\n  self.flush()\n  \n def syntax_error(self,args):\n  info,[filename,lineno,offset,line]=args\n  print(f\"  File {filename}, line {lineno}\")\n  print(\"    \"+line)\n  print(\"    \"+offset *\" \"+\"^\")\n  print(\"SyntaxError:\",info)\n  self.flush()\n  \nclass Inspector(Interpreter):\n\n def __init__(self,title=\"Frames inspector\",\n rows=30,cols=84,default_css=True ):\n  frame=sys._getframe().f_back\n  super().__init__(None ,title,\n  globals=frame.f_globals.copy(),\n  locals=frame.f_locals.copy(),\n  rows=rows,cols=cols,default_css=default_css)\n  \n  frames_sel=html.SELECT()\n  self.frames=[]\n  while frame:\n   self.frames.append([frame.f_globals.copy(),\n   frame.f_locals.copy()])\n   name=frame.f_code.co_name\n   name=name.replace(\"<\",\"&lt;\").replace(\">\",\"&gt;\")\n   frames_sel <=html.OPTION(name)\n   frame=frame.f_back\n  frames_sel.bind(\"change\",self.change_frame)\n  frame_div=html.DIV(\"Frame \"+frames_sel)\n  panel_style=window.getComputedStyle(self.dialog.panel)\n  frame_div.style.paddingLeft=panel_style.paddingLeft\n  frame_div.style.paddingTop=panel_style.paddingTop\n  self.dialog.insertBefore(frame_div,self.dialog.panel)\n  \n def change_frame(self,ev):\n  self.globals,self.locals=self.frames[ev.target.selectedIndex]\n  \n", ["browser", "browser.html", "browser.widgets.dialog", "builtins", "sys", "tb"]],
+    "interpreter": [".py", "import sys\nimport builtins\n\nimport tb as traceback\n\nfrom browser import console,document,window,html,DOMNode\nfrom browser.widgets.dialog import Dialog\n\n_credits=\"\"\"    Thanks to CWI, CNRI, BeOpen.com, Zope Corporation and a cast of thousands\n    for supporting Python development.  See www.python.org for more information.\"\"\"\n\n_copyright=\"\"\"Copyright (c) 2012, Pierre Quentel pierre.quentel@gmail.com\nAll Rights Reserved.\n\nCopyright (c) 2001-2013 Python Software Foundation.\nAll Rights Reserved.\n\nCopyright (c) 2000 BeOpen.com.\nAll Rights Reserved.\n\nCopyright (c) 1995-2001 Corporation for National Research Initiatives.\nAll Rights Reserved.\n\nCopyright (c) 1991-1995 Stichting Mathematisch Centrum, Amsterdam.\nAll Rights Reserved.\"\"\"\n\n_license=\"\"\"Copyright (c) 2012, Pierre Quentel pierre.quentel@gmail.com\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\nRedistributions of source code must retain the above copyright notice, this\nlist of conditions and the following disclaimer. Redistributions in binary\nform must reproduce the above copyright notice, this list of conditions and\nthe following disclaimer in the documentation and/or other materials provided\nwith the distribution.\nNeither the name of the <ORGANIZATION> nor the names of its contributors may\nbe used to endorse or promote products derived from this software without\nspecific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\nARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\nCONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\nSUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\nINTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\nCONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\nARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGE.\n\"\"\"\n\nclass Info:\n\n def __init__(self,msg):\n  self.msg=msg\n  \n def __repr__(self):\n  return self.msg\n  \n  \n  \neditor_ns={\n'credits':Info(_credits),\n'copyright':Info(_copyright),\n'license':Info(_license),\n'__annotations__':{},\n'__builtins__':builtins,\n'__doc__':None ,\n'__name__':'__main__'\n}\n\n\nstyle_sheet=\"\"\"\n.brython-interpreter {\n    background-color: #000;\n    color: #fff;\n    font-family: consolas, courier;\n}\n\"\"\"\n\n\nclass Trace:\n\n def __init__(self):\n  self.buf=\"\"\n  \n def write(self,data):\n  self.buf +=str(data)\n  \n def format(self):\n  ''\n  lines=self.buf.split(\"\\n\")\n  stripped=[lines[0]]\n  for i in range(1,len(lines),2):\n   if __file__ in lines[i]:\n    continue\n   stripped +=lines[i:i+2]\n  return \"\\n\".join(stripped)\n  \n  \nclass Interpreter:\n ''\n \n def __init__(self,elt_id=None ,title=\"Interactive Interpreter\",\n globals=None ,locals=None ,history=None ,\n rows=30,cols=84,default_css=True ,\n clear_zone=True ,banner=True ):\n  ''\n\n\n\n\n\n  \n  if default_css:\n  \n   for stylesheet in document.styleSheets:\n    if stylesheet.ownerNode.id ==\"brython-interpreter\":\n     break\n   else :\n    document <=html.STYLE(style_sheet,id=\"brython-interpreter\")\n    \n  if elt_id is None :\n   self.dialog=Dialog(title=title,top=10,left=10,\n   default_css=default_css)\n   self.zone=html.TEXTAREA(rows=rows,cols=cols,\n   Class=\"brython-interpreter\")\n   self.dialog.panel <=self.zone\n  else :\n   if isinstance(elt_id,str):\n    try :\n     elt=document[elt_id]\n     if elt.tagName !=\"TEXTAREA\":\n      raise ValueError(\n      f\"element {elt_id} is a {elt.tagName}, \"+\n      \"not a TEXTAREA\")\n     self.zone=elt\n    except KeyError:\n     raise KeyError(f\"no element with id '{elt_id}'\")\n   elif isinstance(elt_id,DOMNode):\n    if elt_id.tagName ==\"TEXTAREA\":\n     self.zone=elt_id\n    else :\n     raise ValueError(\"element is not a TEXTAREA\")\n   else :\n    raise ValueError(\"element should be a string or \"+\n    f\"a TEXTAREA, got '{elt_id.__class__.__name__}'\")\n  v=sys.implementation.version\n  if clear_zone:\n   self.zone.value=''\n  if banner:\n   self.zone.value +=(\n   f\"Brython {v[0]}.{v[1]}.{v[2]} on \"\n   f\"{window.navigator.appName} {window.navigator.appVersion}\"\n   \"\\n\"\n   )\n  self.zone.value +=\">>> \"\n  self.cursor_to_end()\n  self._status=\"main\"\n  self.history=history or []\n  self.current=len(self.history)\n  \n  self.globals={}if globals is None else globals\n  self.globals.update(editor_ns)\n  self.locals=self.globals if locals is None else locals\n  \n  self.buffer=''\n  sys.stdout.write=sys.stderr.write=self.write\n  sys.stdout.__len__=sys.stderr.__len__=lambda :len(self.buffer)\n  \n  self.zone.bind('keypress',self.keypress)\n  self.zone.bind('keydown',self.keydown)\n  self.zone.bind('mouseup',self.mouseup)\n  \n  self.zone.focus()\n  \n def cursor_to_end(self,*args):\n  pos=len(self.zone.value)\n  self.zone.setSelectionRange(pos,pos)\n  self.zone.scrollTop=self.zone.scrollHeight\n  \n def get_col(self):\n \n  sel=self.zone.selectionStart\n  lines=self.zone.value.split('\\n')\n  for line in lines[:-1]:\n   sel -=len(line)+1\n  return sel\n  \n def keypress(self,event):\n  if event.keyCode ==9:\n   event.preventDefault()\n   self.zone.value +=\"    \"\n  elif event.keyCode ==13:\n   sel_start=self.zone.selectionStart\n   sel_end=self.zone.selectionEnd\n   if sel_end >sel_start:\n   \n    document.execCommand(\"copy\")\n    self.cursor_to_end()\n    event.preventDefault()\n    return\n   src=self.zone.value\n   if self._status ==\"main\":\n    currentLine=src[src.rfind('\\n>>>')+5:]\n   elif self._status ==\"3string\":\n    currentLine=src[src.rfind('\\n>>>')+5:]\n    currentLine=currentLine.replace('\\n... ','\\n')\n   else :\n    currentLine=src[src.rfind('\\n...')+5:]\n   if self._status =='main'and not currentLine.strip():\n    self.zone.value +='\\n>>> '\n    event.preventDefault()\n    return\n   self.zone.value +='\\n'\n   self.history.append(currentLine)\n   self.current=len(self.history)\n   if self._status in [\"main\",\"3string\"]:\n    try :\n     _=self.globals['_']=eval(currentLine,\n     self.globals,\n     self.locals)\n     if _ is not None :\n      self.write(repr(_)+'\\n')\n     self.flush()\n     self.zone.value +='>>> '\n     self._status=\"main\"\n    except IndentationError:\n     self.zone.value +='... '\n     self._status=\"block\"\n    except SyntaxError as msg:\n     if str(msg)=='invalid syntax : triple string end not found':\n      self.zone.value +='... '\n      self._status=\"3string\"\n     elif str(msg)=='eval() argument must be an expression':\n      try :\n       exec(currentLine,\n       self.globals,\n       self.locals)\n      except :\n       self.print_tb()\n      self.flush()\n      self.zone.value +='>>> '\n      self._status=\"main\"\n     elif str(msg)=='decorator expects function':\n      self.zone.value +='... '\n      self._status=\"block\"\n     elif str(msg).endswith('was never closed'):\n      self.zone.value +='... '\n      self._status=\"block\"\n     else :\n      self.syntax_error(msg.args)\n      self.zone.value +='>>> '\n      self._status=\"main\"\n    except :\n    \n    \n    \n     self.print_tb()\n     self.zone.value +='>>> '\n     self._status=\"main\"\n   elif currentLine ==\"\":\n    block=src[src.rfind('\\n>>>')+5:].splitlines()\n    block=[block[0]]+[b[4:]for b in block[1:]]\n    block_src='\\n'.join(block)\n    \n    self._status=\"main\"\n    try :\n     _=exec(block_src,\n     self.globals,\n     self.locals)\n     if _ is not None :\n      print(repr(_))\n    except :\n     self.print_tb()\n    self.flush()\n    self.zone.value +='>>> '\n   else :\n    self.zone.value +='... '\n    \n   self.cursor_to_end()\n   event.preventDefault()\n   \n def keydown(self,event):\n  if event.keyCode ==37:\n   sel=self.get_col()\n   if sel <5:\n    event.preventDefault()\n    event.stopPropagation()\n  elif event.keyCode ==36:\n   pos=self.zone.selectionStart\n   col=self.get_col()\n   self.zone.setSelectionRange(pos -col+4,pos -col+4)\n   event.preventDefault()\n  elif event.keyCode ==38:\n   if self.current >0:\n    pos=self.zone.selectionStart\n    col=self.get_col()\n    \n    self.zone.value=self.zone.value[:pos -col+4]\n    self.current -=1\n    self.zone.value +=self.history[self.current]\n   event.preventDefault()\n  elif event.keyCode ==40:\n   if self.current <len(self.history)-1:\n    pos=self.zone.selectionStart\n    col=self.get_col()\n    \n    self.zone.value=self.zone.value[:pos -col+4]\n    self.current +=1\n    self.zone.value +=self.history[self.current]\n   event.preventDefault()\n  elif event.keyCode ==8:\n   src=self.zone.value\n   lstart=src.rfind('\\n')\n   if (lstart ==-1 and len(src)<5)or (len(src)-lstart <6):\n    event.preventDefault()\n    event.stopPropagation()\n  elif event.keyCode in [33,34]:\n   event.preventDefault()\n   \n def mouseup(self,ev):\n  ''\n  sel_start=self.zone.selectionStart\n  sel_end=self.zone.selectionEnd\n  if sel_end ==sel_start:\n   self.cursor_to_end()\n   \n def write(self,data):\n  self.buffer +=str(data)\n  \n def flush(self):\n  self.zone.value +=self.buffer\n  self.buffer=''\n  \n def print_tb(self):\n  trace=Trace()\n  traceback.print_exc(file=trace)\n  self.write(trace.format())\n  self.flush()\n  \n def syntax_error(self,args):\n  info,[filename,lineno,offset,line]=args\n  print(f\"  File {filename}, line {lineno}\")\n  print(\"    \"+line)\n  print(\"    \"+offset *\" \"+\"^\")\n  print(\"SyntaxError:\",info)\n  self.flush()\n  \nclass Inspector(Interpreter):\n\n def __init__(self,title=\"Frames inspector\",\n rows=30,cols=84,default_css=True ):\n  frame=sys._getframe().f_back\n  super().__init__(None ,title,\n  globals=frame.f_globals.copy(),\n  locals=frame.f_locals.copy(),\n  rows=rows,cols=cols,default_css=default_css)\n  \n  frames_sel=html.SELECT()\n  self.frames=[]\n  while frame:\n   self.frames.append([frame.f_globals.copy(),\n   frame.f_locals.copy()])\n   name=frame.f_code.co_name\n   name=name.replace(\"<\",\"&lt;\").replace(\">\",\"&gt;\")\n   frames_sel <=html.OPTION(name)\n   frame=frame.f_back\n  frames_sel.bind(\"change\",self.change_frame)\n  frame_div=html.DIV(\"Frame \"+frames_sel)\n  panel_style=window.getComputedStyle(self.dialog.panel)\n  frame_div.style.paddingLeft=panel_style.paddingLeft\n  frame_div.style.paddingTop=panel_style.paddingTop\n  self.dialog.insertBefore(frame_div,self.dialog.panel)\n  \n def change_frame(self,ev):\n  self.globals,self.locals=self.frames[ev.target.selectedIndex]\n  \n", ["browser", "browser.html", "browser.widgets.dialog", "builtins", "sys", "tb"]],
     "io": [".py", "''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n__author__=(\"Guido van Rossum <guido@python.org>, \"\n\"Mike Verdone <mike.verdone@gmail.com>, \"\n\"Mark Russell <mark.russell@zen.co.uk>, \"\n\"Antoine Pitrou <solipsis@pitrou.net>, \"\n\"Amaury Forgeot d'Arc <amauryfa@gmail.com>, \"\n\"Benjamin Peterson <benjamin@python.org>\")\n\n__all__=[\"BlockingIOError\",\"open\",\"open_code\",\"IOBase\",\"RawIOBase\",\n\"FileIO\",\"BytesIO\",\"StringIO\",\"BufferedIOBase\",\n\"BufferedReader\",\"BufferedWriter\",\"BufferedRWPair\",\n\"BufferedRandom\",\"TextIOBase\",\"TextIOWrapper\",\n\"UnsupportedOperation\",\"SEEK_SET\",\"SEEK_CUR\",\"SEEK_END\"]\n\n\nimport _io\nimport abc\n\nfrom _io import (DEFAULT_BUFFER_SIZE,BlockingIOError,UnsupportedOperation,\nopen,open_code,FileIO,BytesIO,StringIO,BufferedReader,\nBufferedWriter,BufferedRWPair,BufferedRandom,\nIncrementalNewlineDecoder,TextIOWrapper)\n\nOpenWrapper=_io.open\n\n\nUnsupportedOperation.__module__=\"io\"\n\n\nSEEK_SET=0\nSEEK_CUR=1\nSEEK_END=2\n\n\n\n\nclass IOBase(_io._IOBase,metaclass=abc.ABCMeta):\n __doc__=_io._IOBase.__doc__\n \nclass RawIOBase(_io._RawIOBase,IOBase):\n __doc__=_io._RawIOBase.__doc__\n \nclass BufferedIOBase(_io._BufferedIOBase,IOBase):\n __doc__=_io._BufferedIOBase.__doc__\n \nclass TextIOBase(_io._TextIOBase,IOBase):\n __doc__=_io._TextIOBase.__doc__\n \nRawIOBase.register(FileIO)\n\nfor klass in (BytesIO,BufferedReader,BufferedWriter,BufferedRandom,\nBufferedRWPair):\n BufferedIOBase.register(klass)\n \nfor klass in (StringIO,TextIOWrapper):\n TextIOBase.register(klass)\ndel klass\n\ntry :\n from _io import _WindowsConsoleIO\nexcept ImportError:\n pass\nelse :\n RawIOBase.register(_WindowsConsoleIO)\n", ["_io", "abc"]],
     "ipaddress": [".py", "\n\n\n\"\"\"A fast, lightweight IPv4/IPv6 manipulation library in Python.\n\nThis library is used to create/poke/manipulate IPv4 and IPv6 addresses\nand networks.\n\n\"\"\"\n\n__version__='1.0'\n\n\nimport functools\n\nIPV4LENGTH=32\nIPV6LENGTH=128\n\nclass AddressValueError(ValueError):\n ''\n \n \nclass NetmaskValueError(ValueError):\n ''\n \n \ndef ip_address(address):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n try :\n  return IPv4Address(address)\n except (AddressValueError,NetmaskValueError):\n  pass\n  \n try :\n  return IPv6Address(address)\n except (AddressValueError,NetmaskValueError):\n  pass\n  \n raise ValueError('%r does not appear to be an IPv4 or IPv6 address'%\n address)\n \n \ndef ip_network(address,strict=True ):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n try :\n  return IPv4Network(address,strict)\n except (AddressValueError,NetmaskValueError):\n  pass\n  \n try :\n  return IPv6Network(address,strict)\n except (AddressValueError,NetmaskValueError):\n  pass\n  \n raise ValueError('%r does not appear to be an IPv4 or IPv6 network'%\n address)\n \n \ndef ip_interface(address):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n try :\n  return IPv4Interface(address)\n except (AddressValueError,NetmaskValueError):\n  pass\n  \n try :\n  return IPv6Interface(address)\n except (AddressValueError,NetmaskValueError):\n  pass\n  \n raise ValueError('%r does not appear to be an IPv4 or IPv6 interface'%\n address)\n \n \ndef v4_int_to_packed(address):\n ''\n\n\n\n\n\n\n\n\n\n\n\n \n try :\n  return address.to_bytes(4,'big')\n except OverflowError:\n  raise ValueError(\"Address negative or too large for IPv4\")\n  \n  \ndef v6_int_to_packed(address):\n ''\n\n\n\n\n\n\n\n \n try :\n  return address.to_bytes(16,'big')\n except OverflowError:\n  raise ValueError(\"Address negative or too large for IPv6\")\n  \n  \ndef _split_optional_netmask(address):\n ''\n addr=str(address).split('/')\n if len(addr)>2:\n  raise AddressValueError(\"Only one '/' permitted in %r\"%address)\n return addr\n \n \ndef _find_address_range(addresses):\n ''\n\n\n\n\n\n\n\n \n it=iter(addresses)\n first=last=next(it)\n for ip in it:\n  if ip._ip !=last._ip+1:\n   yield first,last\n   first=ip\n  last=ip\n yield first,last\n \n \ndef _count_righthand_zero_bits(number,bits):\n ''\n\n\n\n\n\n\n\n\n \n if number ==0:\n  return bits\n return min(bits,(~number&(number -1)).bit_length())\n \n \ndef summarize_address_range(first,last):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n if (not (isinstance(first,_BaseAddress)and\n isinstance(last,_BaseAddress))):\n  raise TypeError('first and last must be IP addresses, not networks')\n if first.version !=last.version:\n  raise TypeError(\"%s and %s are not of the same version\"%(\n  first,last))\n if first >last:\n  raise ValueError('last IP address must be greater than first')\n  \n if first.version ==4:\n  ip=IPv4Network\n elif first.version ==6:\n  ip=IPv6Network\n else :\n  raise ValueError('unknown IP version')\n  \n ip_bits=first._max_prefixlen\n first_int=first._ip\n last_int=last._ip\n while first_int <=last_int:\n  nbits=min(_count_righthand_zero_bits(first_int,ip_bits),\n  (last_int -first_int+1).bit_length()-1)\n  net=ip((first_int,ip_bits -nbits))\n  yield net\n  first_int +=1 <<nbits\n  if first_int -1 ==ip._ALL_ONES:\n   break\n   \n   \ndef _collapse_addresses_internal(addresses):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n to_merge=list(addresses)\n subnets={}\n while to_merge:\n  net=to_merge.pop()\n  supernet=net.supernet()\n  existing=subnets.get(supernet)\n  if existing is None :\n   subnets[supernet]=net\n  elif existing !=net:\n  \n   del subnets[supernet]\n   to_merge.append(supernet)\n   \n last=None\n for net in sorted(subnets.values()):\n  if last is not None :\n  \n  \n   if last.broadcast_address >=net.broadcast_address:\n    continue\n  yield net\n  last=net\n  \n  \ndef collapse_addresses(addresses):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n addrs=[]\n ips=[]\n nets=[]\n \n \n for ip in addresses:\n  if isinstance(ip,_BaseAddress):\n   if ips and ips[-1]._version !=ip._version:\n    raise TypeError(\"%s and %s are not of the same version\"%(\n    ip,ips[-1]))\n   ips.append(ip)\n  elif ip._prefixlen ==ip._max_prefixlen:\n   if ips and ips[-1]._version !=ip._version:\n    raise TypeError(\"%s and %s are not of the same version\"%(\n    ip,ips[-1]))\n   try :\n    ips.append(ip.ip)\n   except AttributeError:\n    ips.append(ip.network_address)\n  else :\n   if nets and nets[-1]._version !=ip._version:\n    raise TypeError(\"%s and %s are not of the same version\"%(\n    ip,nets[-1]))\n   nets.append(ip)\n   \n   \n ips=sorted(set(ips))\n \n \n if ips:\n  for first,last in _find_address_range(ips):\n   addrs.extend(summarize_address_range(first,last))\n   \n return _collapse_addresses_internal(addrs+nets)\n \n \ndef get_mixed_type_key(obj):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n if isinstance(obj,_BaseNetwork):\n  return obj._get_networks_key()\n elif isinstance(obj,_BaseAddress):\n  return obj._get_address_key()\n return NotImplemented\n \n \nclass _IPAddressBase:\n\n ''\n \n __slots__=()\n \n @property\n def exploded(self):\n  ''\n  return self._explode_shorthand_ip_string()\n  \n @property\n def compressed(self):\n  ''\n  return str(self)\n  \n @property\n def reverse_pointer(self):\n  ''\n\n\n\n\n\n  \n  return self._reverse_pointer()\n  \n @property\n def version(self):\n  msg='%200s has no version specified'%(type(self),)\n  raise NotImplementedError(msg)\n  \n def _check_int_address(self,address):\n  if address <0:\n   msg=\"%d (< 0) is not permitted as an IPv%d address\"\n   raise AddressValueError(msg %(address,self._version))\n  if address >self._ALL_ONES:\n   msg=\"%d (>= 2**%d) is not permitted as an IPv%d address\"\n   raise AddressValueError(msg %(address,self._max_prefixlen,\n   self._version))\n   \n def _check_packed_address(self,address,expected_len):\n  address_len=len(address)\n  if address_len !=expected_len:\n   msg=\"%r (len %d != %d) is not permitted as an IPv%d address\"\n   raise AddressValueError(msg %(address,address_len,\n   expected_len,self._version))\n   \n @classmethod\n def _ip_int_from_prefix(cls,prefixlen):\n  ''\n\n\n\n\n\n\n\n  \n  return cls._ALL_ONES ^(cls._ALL_ONES >>prefixlen)\n  \n @classmethod\n def _prefix_from_ip_int(cls,ip_int):\n  ''\n\n\n\n\n\n\n\n\n\n  \n  trailing_zeroes=_count_righthand_zero_bits(ip_int,\n  cls._max_prefixlen)\n  prefixlen=cls._max_prefixlen -trailing_zeroes\n  leading_ones=ip_int >>trailing_zeroes\n  all_ones=(1 <<prefixlen)-1\n  if leading_ones !=all_ones:\n   byteslen=cls._max_prefixlen //8\n   details=ip_int.to_bytes(byteslen,'big')\n   msg='Netmask pattern %r mixes zeroes & ones'\n   raise ValueError(msg %details)\n  return prefixlen\n  \n @classmethod\n def _report_invalid_netmask(cls,netmask_str):\n  msg='%r is not a valid netmask'%netmask_str\n  raise NetmaskValueError(msg)from None\n  \n @classmethod\n def _prefix_from_prefix_string(cls,prefixlen_str):\n  ''\n\n\n\n\n\n\n\n\n\n  \n  \n  \n  if not (prefixlen_str.isascii()and prefixlen_str.isdigit()):\n   cls._report_invalid_netmask(prefixlen_str)\n  try :\n   prefixlen=int(prefixlen_str)\n  except ValueError:\n   cls._report_invalid_netmask(prefixlen_str)\n  if not (0 <=prefixlen <=cls._max_prefixlen):\n   cls._report_invalid_netmask(prefixlen_str)\n  return prefixlen\n  \n @classmethod\n def _prefix_from_ip_string(cls,ip_str):\n  ''\n\n\n\n\n\n\n\n\n\n  \n  \n  try :\n   ip_int=cls._ip_int_from_string(ip_str)\n  except AddressValueError:\n   cls._report_invalid_netmask(ip_str)\n   \n   \n   \n   \n  try :\n   return cls._prefix_from_ip_int(ip_int)\n  except ValueError:\n   pass\n   \n   \n  ip_int ^=cls._ALL_ONES\n  try :\n   return cls._prefix_from_ip_int(ip_int)\n  except ValueError:\n   cls._report_invalid_netmask(ip_str)\n   \n @classmethod\n def _split_addr_prefix(cls,address):\n  ''\n\n\n\n\n\n\n  \n  \n  if isinstance(address,(bytes,int)):\n   return address,cls._max_prefixlen\n   \n  if not isinstance(address,tuple):\n  \n  \n   address=_split_optional_netmask(address)\n   \n   \n  if len(address)>1:\n   return address\n  return address[0],cls._max_prefixlen\n  \n def __reduce__(self):\n  return self.__class__,(str(self),)\n  \n  \n_address_fmt_re=None\n\n@functools.total_ordering\nclass _BaseAddress(_IPAddressBase):\n\n ''\n\n\n\n \n \n __slots__=()\n \n def __int__(self):\n  return self._ip\n  \n def __eq__(self,other):\n  try :\n   return (self._ip ==other._ip\n   and self._version ==other._version)\n  except AttributeError:\n   return NotImplemented\n   \n def __lt__(self,other):\n  if not isinstance(other,_BaseAddress):\n   return NotImplemented\n  if self._version !=other._version:\n   raise TypeError('%s and %s are not of the same version'%(\n   self,other))\n  if self._ip !=other._ip:\n   return self._ip <other._ip\n  return False\n  \n  \n  \n def __add__(self,other):\n  if not isinstance(other,int):\n   return NotImplemented\n  return self.__class__(int(self)+other)\n  \n def __sub__(self,other):\n  if not isinstance(other,int):\n   return NotImplemented\n  return self.__class__(int(self)-other)\n  \n def __repr__(self):\n  return '%s(%r)'%(self.__class__.__name__,str(self))\n  \n def __str__(self):\n  return str(self._string_from_ip_int(self._ip))\n  \n def __hash__(self):\n  return hash(hex(int(self._ip)))\n  \n def _get_address_key(self):\n  return (self._version,self)\n  \n def __reduce__(self):\n  return self.__class__,(self._ip,)\n  \n def __format__(self,fmt):\n  ''\n\n\n\n\n\n\n\n\n\n  \n  \n  \n  if not fmt or fmt[-1]=='s':\n   return format(str(self),fmt)\n   \n   \n  global _address_fmt_re\n  if _address_fmt_re is None :\n   import re\n   _address_fmt_re=re.compile('(#?)(_?)([xbnX])')\n   \n  m=_address_fmt_re.fullmatch(fmt)\n  if not m:\n   return super().__format__(fmt)\n   \n  alternate,grouping,fmt_base=m.groups()\n  \n  \n  if fmt_base =='n':\n   if self._version ==4:\n    fmt_base='b'\n   else :\n    fmt_base='x'\n    \n  if fmt_base =='b':\n   padlen=self._max_prefixlen\n  else :\n   padlen=self._max_prefixlen //4\n   \n  if grouping:\n   padlen +=padlen //4 -1\n   \n  if alternate:\n   padlen +=2\n   \n  return format(int(self),f'{alternate}0{padlen}{grouping}{fmt_base}')\n  \n  \n@functools.total_ordering\nclass _BaseNetwork(_IPAddressBase):\n ''\n\n\n\n \n \n def __repr__(self):\n  return '%s(%r)'%(self.__class__.__name__,str(self))\n  \n def __str__(self):\n  return '%s/%d'%(self.network_address,self.prefixlen)\n  \n def hosts(self):\n  ''\n\n\n\n\n  \n  network=int(self.network_address)\n  broadcast=int(self.broadcast_address)\n  for x in range(network+1,broadcast):\n   yield self._address_class(x)\n   \n def __iter__(self):\n  network=int(self.network_address)\n  broadcast=int(self.broadcast_address)\n  for x in range(network,broadcast+1):\n   yield self._address_class(x)\n   \n def __getitem__(self,n):\n  network=int(self.network_address)\n  broadcast=int(self.broadcast_address)\n  if n >=0:\n   if network+n >broadcast:\n    raise IndexError('address out of range')\n   return self._address_class(network+n)\n  else :\n   n +=1\n   if broadcast+n <network:\n    raise IndexError('address out of range')\n   return self._address_class(broadcast+n)\n   \n def __lt__(self,other):\n  if not isinstance(other,_BaseNetwork):\n   return NotImplemented\n  if self._version !=other._version:\n   raise TypeError('%s and %s are not of the same version'%(\n   self,other))\n  if self.network_address !=other.network_address:\n   return self.network_address <other.network_address\n  if self.netmask !=other.netmask:\n   return self.netmask <other.netmask\n  return False\n  \n def __eq__(self,other):\n  try :\n   return (self._version ==other._version and\n   self.network_address ==other.network_address and\n   int(self.netmask)==int(other.netmask))\n  except AttributeError:\n   return NotImplemented\n   \n def __hash__(self):\n  return hash(int(self.network_address)^int(self.netmask))\n  \n def __contains__(self,other):\n \n  if self._version !=other._version:\n   return False\n   \n  if isinstance(other,_BaseNetwork):\n   return False\n   \n  else :\n  \n   return other._ip&self.netmask._ip ==self.network_address._ip\n   \n def overlaps(self,other):\n  ''\n  return self.network_address in other or (\n  self.broadcast_address in other or (\n  other.network_address in self or (\n  other.broadcast_address in self)))\n  \n @functools.cached_property\n def broadcast_address(self):\n  return self._address_class(int(self.network_address)|\n  int(self.hostmask))\n  \n @functools.cached_property\n def hostmask(self):\n  return self._address_class(int(self.netmask)^self._ALL_ONES)\n  \n @property\n def with_prefixlen(self):\n  return '%s/%d'%(self.network_address,self._prefixlen)\n  \n @property\n def with_netmask(self):\n  return '%s/%s'%(self.network_address,self.netmask)\n  \n @property\n def with_hostmask(self):\n  return '%s/%s'%(self.network_address,self.hostmask)\n  \n @property\n def num_addresses(self):\n  ''\n  return int(self.broadcast_address)-int(self.network_address)+1\n  \n @property\n def _address_class(self):\n \n \n \n  msg='%200s has no associated address class'%(type(self),)\n  raise NotImplementedError(msg)\n  \n @property\n def prefixlen(self):\n  return self._prefixlen\n  \n def address_exclude(self,other):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  if not self._version ==other._version:\n   raise TypeError(\"%s and %s are not of the same version\"%(\n   self,other))\n   \n  if not isinstance(other,_BaseNetwork):\n   raise TypeError(\"%s is not a network object\"%other)\n   \n  if not other.subnet_of(self):\n   raise ValueError('%s not contained in %s'%(other,self))\n  if other ==self:\n   return\n   \n   \n  other=other.__class__('%s/%s'%(other.network_address,\n  other.prefixlen))\n  \n  s1,s2=self.subnets()\n  while s1 !=other and s2 !=other:\n   if other.subnet_of(s1):\n    yield s2\n    s1,s2=s1.subnets()\n   elif other.subnet_of(s2):\n    yield s1\n    s1,s2=s2.subnets()\n   else :\n   \n    raise AssertionError('Error performing exclusion: '\n    's1: %s s2: %s other: %s'%\n    (s1,s2,other))\n  if s1 ==other:\n   yield s2\n  elif s2 ==other:\n   yield s1\n  else :\n  \n   raise AssertionError('Error performing exclusion: '\n   's1: %s s2: %s other: %s'%\n   (s1,s2,other))\n   \n def compare_networks(self,other):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  \n  if self._version !=other._version:\n   raise TypeError('%s and %s are not of the same type'%(\n   self,other))\n   \n  if self.network_address <other.network_address:\n   return -1\n  if self.network_address >other.network_address:\n   return 1\n   \n  if self.netmask <other.netmask:\n   return -1\n  if self.netmask >other.netmask:\n   return 1\n  return 0\n  \n def _get_networks_key(self):\n  ''\n\n\n\n\n\n  \n  return (self._version,self.network_address,self.netmask)\n  \n def subnets(self,prefixlen_diff=1,new_prefix=None ):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  if self._prefixlen ==self._max_prefixlen:\n   yield self\n   return\n   \n  if new_prefix is not None :\n   if new_prefix <self._prefixlen:\n    raise ValueError('new prefix must be longer')\n   if prefixlen_diff !=1:\n    raise ValueError('cannot set prefixlen_diff and new_prefix')\n   prefixlen_diff=new_prefix -self._prefixlen\n   \n  if prefixlen_diff <0:\n   raise ValueError('prefix length diff must be > 0')\n  new_prefixlen=self._prefixlen+prefixlen_diff\n  \n  if new_prefixlen >self._max_prefixlen:\n   raise ValueError(\n   'prefix length diff %d is invalid for netblock %s'%(\n   new_prefixlen,self))\n   \n  start=int(self.network_address)\n  end=int(self.broadcast_address)+1\n  step=(int(self.hostmask)+1)>>prefixlen_diff\n  for new_addr in range(start,end,step):\n   current=self.__class__((new_addr,new_prefixlen))\n   yield current\n   \n def supernet(self,prefixlen_diff=1,new_prefix=None ):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  if self._prefixlen ==0:\n   return self\n   \n  if new_prefix is not None :\n   if new_prefix >self._prefixlen:\n    raise ValueError('new prefix must be shorter')\n   if prefixlen_diff !=1:\n    raise ValueError('cannot set prefixlen_diff and new_prefix')\n   prefixlen_diff=self._prefixlen -new_prefix\n   \n  new_prefixlen=self.prefixlen -prefixlen_diff\n  if new_prefixlen <0:\n   raise ValueError(\n   'current prefixlen is %d, cannot have a prefixlen_diff of %d'%\n   (self.prefixlen,prefixlen_diff))\n  return self.__class__((\n  int(self.network_address)&(int(self.netmask)<<prefixlen_diff),\n  new_prefixlen\n  ))\n  \n @property\n def is_multicast(self):\n  ''\n\n\n\n\n\n  \n  return (self.network_address.is_multicast and\n  self.broadcast_address.is_multicast)\n  \n @staticmethod\n def _is_subnet_of(a,b):\n  try :\n  \n   if a._version !=b._version:\n    raise TypeError(f\"{a} and {b} are not of the same version\")\n   return (b.network_address <=a.network_address and\n   b.broadcast_address >=a.broadcast_address)\n  except AttributeError:\n   raise TypeError(f\"Unable to test subnet containment \"\n   f\"between {a} and {b}\")\n   \n def subnet_of(self,other):\n  ''\n  return self._is_subnet_of(self,other)\n  \n def supernet_of(self,other):\n  ''\n  return self._is_subnet_of(other,self)\n  \n @property\n def is_reserved(self):\n  ''\n\n\n\n\n\n  \n  return (self.network_address.is_reserved and\n  self.broadcast_address.is_reserved)\n  \n @property\n def is_link_local(self):\n  ''\n\n\n\n\n  \n  return (self.network_address.is_link_local and\n  self.broadcast_address.is_link_local)\n  \n @property\n def is_private(self):\n  ''\n\n\n\n\n\n  \n  return (self.network_address.is_private and\n  self.broadcast_address.is_private)\n  \n @property\n def is_global(self):\n  ''\n\n\n\n\n\n  \n  return not self.is_private\n  \n @property\n def is_unspecified(self):\n  ''\n\n\n\n\n\n  \n  return (self.network_address.is_unspecified and\n  self.broadcast_address.is_unspecified)\n  \n @property\n def is_loopback(self):\n  ''\n\n\n\n\n\n  \n  return (self.network_address.is_loopback and\n  self.broadcast_address.is_loopback)\n  \nclass _BaseV4:\n\n ''\n\n\n\n\n \n \n __slots__=()\n _version=4\n \n _ALL_ONES=(2 **IPV4LENGTH)-1\n \n _max_prefixlen=IPV4LENGTH\n \n \n _netmask_cache={}\n \n def _explode_shorthand_ip_string(self):\n  return str(self)\n  \n @classmethod\n def _make_netmask(cls,arg):\n  ''\n\n\n\n\n\n  \n  if arg not in cls._netmask_cache:\n   if isinstance(arg,int):\n    prefixlen=arg\n    if not (0 <=prefixlen <=cls._max_prefixlen):\n     cls._report_invalid_netmask(prefixlen)\n   else :\n    try :\n    \n     prefixlen=cls._prefix_from_prefix_string(arg)\n    except NetmaskValueError:\n    \n    \n     prefixlen=cls._prefix_from_ip_string(arg)\n   netmask=IPv4Address(cls._ip_int_from_prefix(prefixlen))\n   cls._netmask_cache[arg]=netmask,prefixlen\n  return cls._netmask_cache[arg]\n  \n @classmethod\n def _ip_int_from_string(cls,ip_str):\n  ''\n\n\n\n\n\n\n\n\n\n\n  \n  if not ip_str:\n   raise AddressValueError('Address cannot be empty')\n   \n  octets=ip_str.split('.')\n  if len(octets)!=4:\n   raise AddressValueError(\"Expected 4 octets in %r\"%ip_str)\n   \n  try :\n   return int.from_bytes(map(cls._parse_octet,octets),'big')\n  except ValueError as exc:\n   raise AddressValueError(\"%s in %r\"%(exc,ip_str))from None\n   \n @classmethod\n def _parse_octet(cls,octet_str):\n  ''\n\n\n\n\n\n\n\n\n\n\n  \n  if not octet_str:\n   raise ValueError(\"Empty octet not permitted\")\n   \n  if not (octet_str.isascii()and octet_str.isdigit()):\n   msg=\"Only decimal digits permitted in %r\"\n   raise ValueError(msg %octet_str)\n   \n   \n  if len(octet_str)>3:\n   msg=\"At most 3 characters permitted in %r\"\n   raise ValueError(msg %octet_str)\n   \n  octet_int=int(octet_str,10)\n  if octet_int >255:\n   raise ValueError(\"Octet %d (> 255) not permitted\"%octet_int)\n  return octet_int\n  \n @classmethod\n def _string_from_ip_int(cls,ip_int):\n  ''\n\n\n\n\n\n\n\n  \n  return '.'.join(map(str,ip_int.to_bytes(4,'big')))\n  \n def _reverse_pointer(self):\n  ''\n\n\n\n  \n  reverse_octets=str(self).split('.')[::-1]\n  return '.'.join(reverse_octets)+'.in-addr.arpa'\n  \n @property\n def max_prefixlen(self):\n  return self._max_prefixlen\n  \n @property\n def version(self):\n  return self._version\n  \n  \nclass IPv4Address(_BaseV4,_BaseAddress):\n\n ''\n \n __slots__=('_ip','__weakref__')\n \n def __init__(self,address):\n \n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  \n  if isinstance(address,int):\n   self._check_int_address(address)\n   self._ip=address\n   return\n   \n   \n  if isinstance(address,bytes):\n   self._check_packed_address(address,4)\n   self._ip=int.from_bytes(address,'big')\n   return\n   \n   \n   \n  addr_str=str(address)\n  if '/'in addr_str:\n   raise AddressValueError(\"Unexpected '/' in %r\"%address)\n  self._ip=self._ip_int_from_string(addr_str)\n  \n @property\n def packed(self):\n  ''\n  return v4_int_to_packed(self._ip)\n  \n @property\n def is_reserved(self):\n  ''\n\n\n\n\n\n  \n  return self in self._constants._reserved_network\n  \n @property\n @functools.lru_cache()\n def is_private(self):\n  ''\n\n\n\n\n\n  \n  return any(self in net for net in self._constants._private_networks)\n  \n @property\n @functools.lru_cache()\n def is_global(self):\n  return self not in self._constants._public_network and not self.is_private\n  \n @property\n def is_multicast(self):\n  ''\n\n\n\n\n\n  \n  return self in self._constants._multicast_network\n  \n @property\n def is_unspecified(self):\n  ''\n\n\n\n\n\n  \n  return self ==self._constants._unspecified_address\n  \n @property\n def is_loopback(self):\n  ''\n\n\n\n\n  \n  return self in self._constants._loopback_network\n  \n @property\n def is_link_local(self):\n  ''\n\n\n\n\n  \n  return self in self._constants._linklocal_network\n  \n  \nclass IPv4Interface(IPv4Address):\n\n def __init__(self,address):\n  addr,mask=self._split_addr_prefix(address)\n  \n  IPv4Address.__init__(self,addr)\n  self.network=IPv4Network((addr,mask),strict=False )\n  self.netmask=self.network.netmask\n  self._prefixlen=self.network._prefixlen\n  \n @functools.cached_property\n def hostmask(self):\n  return self.network.hostmask\n  \n def __str__(self):\n  return '%s/%d'%(self._string_from_ip_int(self._ip),\n  self._prefixlen)\n  \n def __eq__(self,other):\n  address_equal=IPv4Address.__eq__(self,other)\n  if address_equal is NotImplemented or not address_equal:\n   return address_equal\n  try :\n   return self.network ==other.network\n  except AttributeError:\n  \n  \n  \n   return False\n   \n def __lt__(self,other):\n  address_less=IPv4Address.__lt__(self,other)\n  if address_less is NotImplemented:\n   return NotImplemented\n  try :\n   return (self.network <other.network or\n   self.network ==other.network and address_less)\n  except AttributeError:\n  \n  \n   return False\n   \n def __hash__(self):\n  return hash((self._ip,self._prefixlen,int(self.network.network_address)))\n  \n __reduce__=_IPAddressBase.__reduce__\n \n @property\n def ip(self):\n  return IPv4Address(self._ip)\n  \n @property\n def with_prefixlen(self):\n  return '%s/%s'%(self._string_from_ip_int(self._ip),\n  self._prefixlen)\n  \n @property\n def with_netmask(self):\n  return '%s/%s'%(self._string_from_ip_int(self._ip),\n  self.netmask)\n  \n @property\n def with_hostmask(self):\n  return '%s/%s'%(self._string_from_ip_int(self._ip),\n  self.hostmask)\n  \n  \nclass IPv4Network(_BaseV4,_BaseNetwork):\n\n ''\n\n\n\n\n\n\n\n\n \n \n _address_class=IPv4Address\n \n def __init__(self,address,strict=True ):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  addr,mask=self._split_addr_prefix(address)\n  \n  self.network_address=IPv4Address(addr)\n  self.netmask,self._prefixlen=self._make_netmask(mask)\n  packed=int(self.network_address)\n  if packed&int(self.netmask)!=packed:\n   if strict:\n    raise ValueError('%s has host bits set'%self)\n   else :\n    self.network_address=IPv4Address(packed&\n    int(self.netmask))\n    \n  if self._prefixlen ==(self._max_prefixlen -1):\n   self.hosts=self.__iter__\n  elif self._prefixlen ==(self._max_prefixlen):\n   self.hosts=lambda :[IPv4Address(addr)]\n   \n @property\n @functools.lru_cache()\n def is_global(self):\n  ''\n\n\n\n\n\n  \n  return (not (self.network_address in IPv4Network('100.64.0.0/10')and\n  self.broadcast_address in IPv4Network('100.64.0.0/10'))and\n  not self.is_private)\n  \n  \nclass _IPv4Constants:\n _linklocal_network=IPv4Network('169.254.0.0/16')\n \n _loopback_network=IPv4Network('127.0.0.0/8')\n \n _multicast_network=IPv4Network('224.0.0.0/4')\n \n _public_network=IPv4Network('100.64.0.0/10')\n \n _private_networks=[\n IPv4Network('0.0.0.0/8'),\n IPv4Network('10.0.0.0/8'),\n IPv4Network('127.0.0.0/8'),\n IPv4Network('169.254.0.0/16'),\n IPv4Network('172.16.0.0/12'),\n IPv4Network('192.0.0.0/29'),\n IPv4Network('192.0.0.170/31'),\n IPv4Network('192.0.2.0/24'),\n IPv4Network('192.168.0.0/16'),\n IPv4Network('198.18.0.0/15'),\n IPv4Network('198.51.100.0/24'),\n IPv4Network('203.0.113.0/24'),\n IPv4Network('240.0.0.0/4'),\n IPv4Network('255.255.255.255/32'),\n ]\n \n _reserved_network=IPv4Network('240.0.0.0/4')\n \n _unspecified_address=IPv4Address('0.0.0.0')\n \n \nIPv4Address._constants=_IPv4Constants\n\n\nclass _BaseV6:\n\n ''\n\n\n\n\n \n \n __slots__=()\n _version=6\n _ALL_ONES=(2 **IPV6LENGTH)-1\n _HEXTET_COUNT=8\n _HEX_DIGITS=frozenset('0123456789ABCDEFabcdef')\n _max_prefixlen=IPV6LENGTH\n \n \n \n _netmask_cache={}\n \n @classmethod\n def _make_netmask(cls,arg):\n  ''\n\n\n\n\n\n  \n  if arg not in cls._netmask_cache:\n   if isinstance(arg,int):\n    prefixlen=arg\n    if not (0 <=prefixlen <=cls._max_prefixlen):\n     cls._report_invalid_netmask(prefixlen)\n   else :\n    prefixlen=cls._prefix_from_prefix_string(arg)\n   netmask=IPv6Address(cls._ip_int_from_prefix(prefixlen))\n   cls._netmask_cache[arg]=netmask,prefixlen\n  return cls._netmask_cache[arg]\n  \n @classmethod\n def _ip_int_from_string(cls,ip_str):\n  ''\n\n\n\n\n\n\n\n\n\n\n  \n  if not ip_str:\n   raise AddressValueError('Address cannot be empty')\n   \n  parts=ip_str.split(':')\n  \n  \n  _min_parts=3\n  if len(parts)<_min_parts:\n   msg=\"At least %d parts expected in %r\"%(_min_parts,ip_str)\n   raise AddressValueError(msg)\n   \n   \n  if '.'in parts[-1]:\n   try :\n    ipv4_int=IPv4Address(parts.pop())._ip\n   except AddressValueError as exc:\n    raise AddressValueError(\"%s in %r\"%(exc,ip_str))from None\n   parts.append('%x'%((ipv4_int >>16)&0xFFFF))\n   parts.append('%x'%(ipv4_int&0xFFFF))\n   \n   \n   \n   \n  _max_parts=cls._HEXTET_COUNT+1\n  if len(parts)>_max_parts:\n   msg=\"At most %d colons permitted in %r\"%(_max_parts -1,ip_str)\n   raise AddressValueError(msg)\n   \n   \n   \n  skip_index=None\n  for i in range(1,len(parts)-1):\n   if not parts[i]:\n    if skip_index is not None :\n    \n     msg=\"At most one '::' permitted in %r\"%ip_str\n     raise AddressValueError(msg)\n    skip_index=i\n    \n    \n    \n  if skip_index is not None :\n  \n   parts_hi=skip_index\n   parts_lo=len(parts)-skip_index -1\n   if not parts[0]:\n    parts_hi -=1\n    if parts_hi:\n     msg=\"Leading ':' only permitted as part of '::' in %r\"\n     raise AddressValueError(msg %ip_str)\n   if not parts[-1]:\n    parts_lo -=1\n    if parts_lo:\n     msg=\"Trailing ':' only permitted as part of '::' in %r\"\n     raise AddressValueError(msg %ip_str)\n   parts_skipped=cls._HEXTET_COUNT -(parts_hi+parts_lo)\n   if parts_skipped <1:\n    msg=\"Expected at most %d other parts with '::' in %r\"\n    raise AddressValueError(msg %(cls._HEXTET_COUNT -1,ip_str))\n  else :\n  \n  \n  \n   if len(parts)!=cls._HEXTET_COUNT:\n    msg=\"Exactly %d parts expected without '::' in %r\"\n    raise AddressValueError(msg %(cls._HEXTET_COUNT,ip_str))\n   if not parts[0]:\n    msg=\"Leading ':' only permitted as part of '::' in %r\"\n    raise AddressValueError(msg %ip_str)\n   if not parts[-1]:\n    msg=\"Trailing ':' only permitted as part of '::' in %r\"\n    raise AddressValueError(msg %ip_str)\n   parts_hi=len(parts)\n   parts_lo=0\n   parts_skipped=0\n   \n  try :\n  \n   ip_int=0\n   for i in range(parts_hi):\n    ip_int <<=16\n    ip_int |=cls._parse_hextet(parts[i])\n   ip_int <<=16 *parts_skipped\n   for i in range(-parts_lo,0):\n    ip_int <<=16\n    ip_int |=cls._parse_hextet(parts[i])\n   return ip_int\n  except ValueError as exc:\n   raise AddressValueError(\"%s in %r\"%(exc,ip_str))from None\n   \n @classmethod\n def _parse_hextet(cls,hextet_str):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n  \n  \n  if not cls._HEX_DIGITS.issuperset(hextet_str):\n   raise ValueError(\"Only hex digits permitted in %r\"%hextet_str)\n   \n   \n  if len(hextet_str)>4:\n   msg=\"At most 4 characters permitted in %r\"\n   raise ValueError(msg %hextet_str)\n   \n  return int(hextet_str,16)\n  \n @classmethod\n def _compress_hextets(cls,hextets):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  best_doublecolon_start=-1\n  best_doublecolon_len=0\n  doublecolon_start=-1\n  doublecolon_len=0\n  for index,hextet in enumerate(hextets):\n   if hextet =='0':\n    doublecolon_len +=1\n    if doublecolon_start ==-1:\n    \n     doublecolon_start=index\n    if doublecolon_len >best_doublecolon_len:\n    \n     best_doublecolon_len=doublecolon_len\n     best_doublecolon_start=doublecolon_start\n   else :\n    doublecolon_len=0\n    doublecolon_start=-1\n    \n  if best_doublecolon_len >1:\n   best_doublecolon_end=(best_doublecolon_start+\n   best_doublecolon_len)\n   \n   if best_doublecolon_end ==len(hextets):\n    hextets +=['']\n   hextets[best_doublecolon_start:best_doublecolon_end]=['']\n   \n   if best_doublecolon_start ==0:\n    hextets=['']+hextets\n    \n  return hextets\n  \n @classmethod\n def _string_from_ip_int(cls,ip_int=None ):\n  ''\n\n\n\n\n\n\n\n\n\n\n  \n  if ip_int is None :\n   ip_int=int(cls._ip)\n   \n  if ip_int >cls._ALL_ONES:\n   raise ValueError('IPv6 address is too large')\n   \n  hex_str='%032x'%ip_int\n  hextets=['%x'%int(hex_str[x:x+4],16)for x in range(0,32,4)]\n  \n  hextets=cls._compress_hextets(hextets)\n  return ':'.join(hextets)\n  \n def _explode_shorthand_ip_string(self):\n  ''\n\n\n\n\n\n\n\n  \n  if isinstance(self,IPv6Network):\n   ip_str=str(self.network_address)\n  elif isinstance(self,IPv6Interface):\n   ip_str=str(self.ip)\n  else :\n   ip_str=str(self)\n   \n  ip_int=self._ip_int_from_string(ip_str)\n  hex_str='%032x'%ip_int\n  parts=[hex_str[x:x+4]for x in range(0,32,4)]\n  if isinstance(self,(_BaseNetwork,IPv6Interface)):\n   return '%s/%d'%(':'.join(parts),self._prefixlen)\n  return ':'.join(parts)\n  \n def _reverse_pointer(self):\n  ''\n\n\n\n  \n  reverse_chars=self.exploded[::-1].replace(':','')\n  return '.'.join(reverse_chars)+'.ip6.arpa'\n  \n @staticmethod\n def _split_scope_id(ip_str):\n  ''\n\n\n\n\n\n\n\n\n\n  \n  addr,sep,scope_id=ip_str.partition('%')\n  if not sep:\n   scope_id=None\n  elif not scope_id or '%'in scope_id:\n   raise AddressValueError('Invalid IPv6 address: \"%r\"'%ip_str)\n  return addr,scope_id\n  \n @property\n def max_prefixlen(self):\n  return self._max_prefixlen\n  \n @property\n def version(self):\n  return self._version\n  \n  \nclass IPv6Address(_BaseV6,_BaseAddress):\n\n ''\n \n __slots__=('_ip','_scope_id','__weakref__')\n \n def __init__(self,address):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  \n  if isinstance(address,int):\n   self._check_int_address(address)\n   self._ip=address\n   self._scope_id=None\n   return\n   \n   \n  if isinstance(address,bytes):\n   self._check_packed_address(address,16)\n   self._ip=int.from_bytes(address,'big')\n   self._scope_id=None\n   return\n   \n   \n   \n  addr_str=str(address)\n  if '/'in addr_str:\n   raise AddressValueError(\"Unexpected '/' in %r\"%address)\n  addr_str,self._scope_id=self._split_scope_id(addr_str)\n  \n  self._ip=self._ip_int_from_string(addr_str)\n  \n def __str__(self):\n  ip_str=super().__str__()\n  return ip_str+'%'+self._scope_id if self._scope_id else ip_str\n  \n def __hash__(self):\n  return hash((self._ip,self._scope_id))\n  \n def __eq__(self,other):\n  address_equal=super().__eq__(other)\n  if address_equal is NotImplemented:\n   return NotImplemented\n  if not address_equal:\n   return False\n  return self._scope_id ==getattr(other,'_scope_id',None )\n  \n @property\n def scope_id(self):\n  ''\n\n\n\n\n\n\n  \n  return self._scope_id\n  \n @property\n def packed(self):\n  ''\n  return v6_int_to_packed(self._ip)\n  \n @property\n def is_multicast(self):\n  ''\n\n\n\n\n\n  \n  return self in self._constants._multicast_network\n  \n @property\n def is_reserved(self):\n  ''\n\n\n\n\n\n  \n  return any(self in x for x in self._constants._reserved_networks)\n  \n @property\n def is_link_local(self):\n  ''\n\n\n\n\n  \n  return self in self._constants._linklocal_network\n  \n @property\n def is_site_local(self):\n  ''\n\n\n\n\n\n\n\n\n  \n  return self in self._constants._sitelocal_network\n  \n @property\n @functools.lru_cache()\n def is_private(self):\n  ''\n\n\n\n\n\n  \n  return any(self in net for net in self._constants._private_networks)\n  \n @property\n def is_global(self):\n  ''\n\n\n\n\n\n  \n  return not self.is_private\n  \n @property\n def is_unspecified(self):\n  ''\n\n\n\n\n\n  \n  return self._ip ==0\n  \n @property\n def is_loopback(self):\n  ''\n\n\n\n\n\n  \n  return self._ip ==1\n  \n @property\n def ipv4_mapped(self):\n  ''\n\n\n\n\n\n  \n  if (self._ip >>32)!=0xFFFF:\n   return None\n  return IPv4Address(self._ip&0xFFFFFFFF)\n  \n @property\n def teredo(self):\n  ''\n\n\n\n\n\n\n  \n  if (self._ip >>96)!=0x20010000:\n   return None\n  return (IPv4Address((self._ip >>64)&0xFFFFFFFF),\n  IPv4Address(~self._ip&0xFFFFFFFF))\n  \n @property\n def sixtofour(self):\n  ''\n\n\n\n\n\n  \n  if (self._ip >>112)!=0x2002:\n   return None\n  return IPv4Address((self._ip >>80)&0xFFFFFFFF)\n  \n  \nclass IPv6Interface(IPv6Address):\n\n def __init__(self,address):\n  addr,mask=self._split_addr_prefix(address)\n  \n  IPv6Address.__init__(self,addr)\n  self.network=IPv6Network((addr,mask),strict=False )\n  self.netmask=self.network.netmask\n  self._prefixlen=self.network._prefixlen\n  \n @functools.cached_property\n def hostmask(self):\n  return self.network.hostmask\n  \n def __str__(self):\n  return '%s/%d'%(super().__str__(),\n  self._prefixlen)\n  \n def __eq__(self,other):\n  address_equal=IPv6Address.__eq__(self,other)\n  if address_equal is NotImplemented or not address_equal:\n   return address_equal\n  try :\n   return self.network ==other.network\n  except AttributeError:\n  \n  \n  \n   return False\n   \n def __lt__(self,other):\n  address_less=IPv6Address.__lt__(self,other)\n  if address_less is NotImplemented:\n   return address_less\n  try :\n   return (self.network <other.network or\n   self.network ==other.network and address_less)\n  except AttributeError:\n  \n  \n   return False\n   \n def __hash__(self):\n  return hash((self._ip,self._prefixlen,int(self.network.network_address)))\n  \n __reduce__=_IPAddressBase.__reduce__\n \n @property\n def ip(self):\n  return IPv6Address(self._ip)\n  \n @property\n def with_prefixlen(self):\n  return '%s/%s'%(self._string_from_ip_int(self._ip),\n  self._prefixlen)\n  \n @property\n def with_netmask(self):\n  return '%s/%s'%(self._string_from_ip_int(self._ip),\n  self.netmask)\n  \n @property\n def with_hostmask(self):\n  return '%s/%s'%(self._string_from_ip_int(self._ip),\n  self.hostmask)\n  \n @property\n def is_unspecified(self):\n  return self._ip ==0 and self.network.is_unspecified\n  \n @property\n def is_loopback(self):\n  return self._ip ==1 and self.network.is_loopback\n  \n  \nclass IPv6Network(_BaseV6,_BaseNetwork):\n\n ''\n\n\n\n\n\n\n\n\n \n \n \n _address_class=IPv6Address\n \n def __init__(self,address,strict=True ):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  addr,mask=self._split_addr_prefix(address)\n  \n  self.network_address=IPv6Address(addr)\n  self.netmask,self._prefixlen=self._make_netmask(mask)\n  packed=int(self.network_address)\n  if packed&int(self.netmask)!=packed:\n   if strict:\n    raise ValueError('%s has host bits set'%self)\n   else :\n    self.network_address=IPv6Address(packed&\n    int(self.netmask))\n    \n  if self._prefixlen ==(self._max_prefixlen -1):\n   self.hosts=self.__iter__\n  elif self._prefixlen ==self._max_prefixlen:\n   self.hosts=lambda :[IPv6Address(addr)]\n   \n def hosts(self):\n  ''\n\n\n\n\n  \n  network=int(self.network_address)\n  broadcast=int(self.broadcast_address)\n  for x in range(network+1,broadcast+1):\n   yield self._address_class(x)\n   \n @property\n def is_site_local(self):\n  ''\n\n\n\n\n\n\n\n\n  \n  return (self.network_address.is_site_local and\n  self.broadcast_address.is_site_local)\n  \n  \nclass _IPv6Constants:\n\n _linklocal_network=IPv6Network('fe80::/10')\n \n _multicast_network=IPv6Network('ff00::/8')\n \n _private_networks=[\n IPv6Network('::1/128'),\n IPv6Network('::/128'),\n IPv6Network('::ffff:0:0/96'),\n IPv6Network('100::/64'),\n IPv6Network('2001::/23'),\n IPv6Network('2001:2::/48'),\n IPv6Network('2001:db8::/32'),\n IPv6Network('2001:10::/28'),\n IPv6Network('fc00::/7'),\n IPv6Network('fe80::/10'),\n ]\n \n _reserved_networks=[\n IPv6Network('::/8'),IPv6Network('100::/8'),\n IPv6Network('200::/7'),IPv6Network('400::/6'),\n IPv6Network('800::/5'),IPv6Network('1000::/4'),\n IPv6Network('4000::/3'),IPv6Network('6000::/3'),\n IPv6Network('8000::/3'),IPv6Network('A000::/3'),\n IPv6Network('C000::/3'),IPv6Network('E000::/4'),\n IPv6Network('F000::/5'),IPv6Network('F800::/6'),\n IPv6Network('FE00::/9'),\n ]\n \n _sitelocal_network=IPv6Network('fec0::/10')\n \n \nIPv6Address._constants=_IPv6Constants\n", ["functools", "re"]],
     "itertools": [".py", "import operator\n\nclass accumulate:\n def __init__(self,iterable,func=operator.add):\n  self.it=iter(iterable)\n  self._total=None\n  self.func=func\n  \n def __iter__(self):\n  return self\n  \n def __next__(self):\n  if not self._total:\n   self._total=next(self.it)\n   return self._total\n  else :\n   element=next(self.it)\n   try :\n    self._total=self.func(self._total,element)\n   except :\n    raise TypeError(\"unsupported operand type\")\n   return self._total\n   \n   \n   \nclass chain:\n def __init__(self,*iterables):\n  self._iterables_iter=iter(map(iter,iterables))\n  \n  self._cur_iterable_iter=iter([])\n  \n def __iter__(self):\n  return self\n  \n def __next__(self):\n  while True :\n   try :\n    return next(self._cur_iterable_iter)\n   except StopIteration:\n    self._cur_iterable_iter=next(self._iterables_iter)\n    \n @classmethod\n def from_iterable(cls,iterable):\n  for it in iterable:\n   for element in it:\n    yield element\n    \nclass combinations:\n def __init__(self,iterable,r):\n  self.pool=tuple(iterable)\n  self.n=len(self.pool)\n  self.r=r\n  self.indices=list(range(self.r))\n  self.zero=False\n  \n def __iter__(self):\n  return self\n  \n def __next__(self):\n  if self.r >self.n:\n   raise StopIteration\n  if not self.zero:\n   self.zero=True\n   return tuple(self.pool[i]for i in self.indices)\n  else :\n   try :\n    for i in reversed(range(self.r)):\n     if self.indices[i]!=i+self.n -self.r:\n      break\n    self.indices[i]+=1\n    for j in range(i+1,self.r):\n     self.indices[j]=self.indices[j -1]+1\n    return tuple(self.pool[i]for i in self.indices)\n   except :\n    raise StopIteration\n    \nclass combinations_with_replacement:\n def __init__(self,iterable,r):\n  self.pool=tuple(iterable)\n  self.n=len(self.pool)\n  self.r=r\n  self.indices=[0]*self.r\n  self.zero=False\n  \n def __iter__(self):\n  return self\n  \n def __next__(self):\n  if not self.n and self.r:\n   raise StopIteration\n  if not self.zero:\n   self.zero=True\n   return tuple(self.pool[i]for i in self.indices)\n  else :\n   try :\n    for i in reversed(range(self.r)):\n     if self.indices[i]!=self.n -1:\n      break\n    self.indices[i:]=[self.indices[i]+1]*(self.r -i)\n    return tuple(self.pool[i]for i in self.indices)\n   except :\n    raise StopIteration\n    \n    \n    \nclass compress:\n def __init__(self,data,selectors):\n  self.data=iter(data)\n  self.selectors=iter(selectors)\n  \n def __iter__(self):\n  return self\n  \n def __next__(self):\n  while True :\n   next_item=next(self.data)\n   next_selector=next(self.selectors)\n   if bool(next_selector):\n    return next_item\n    \n    \n    \n    \nclass count:\n ''\n\n\n\n \n def __init__(self,start=0,step=1):\n  if not isinstance(start,(int,float)):\n   raise TypeError('a number is required')\n  self.times=start -step\n  self.step=step\n  \n def __iter__(self):\n  return self\n  \n def __next__(self):\n  self.times +=self.step\n  return self.times\n  \n def __repr__(self):\n  return 'count(%d)'%(self.times+self.step)\n  \n  \n  \nclass cycle:\n def __init__(self,iterable):\n  self._cur_iter=iter(iterable)\n  self._saved=[]\n  self._must_save=True\n  \n def __iter__(self):\n  return self\n  \n def __next__(self):\n  try :\n   next_elt=next(self._cur_iter)\n   if self._must_save:\n    self._saved.append(next_elt)\n  except StopIteration:\n   self._cur_iter=iter(self._saved)\n   next_elt=next(self._cur_iter)\n   self._must_save=False\n  return next_elt\n  \n  \n  \nclass dropwhile:\n def __init__(self,predicate,iterable):\n  self._predicate=predicate\n  self._iter=iter(iterable)\n  self._dropped=False\n  \n def __iter__(self):\n  return self\n  \n def __next__(self):\n  value=next(self._iter)\n  if self._dropped:\n   return value\n  while self._predicate(value):\n   value=next(self._iter)\n  self._dropped=True\n  return value\n  \n  \n  \nclass filterfalse:\n def __init__(self,predicate,iterable):\n \n  self._iter=iter(iterable)\n  if predicate is None :\n   self._predicate=bool\n  else :\n   self._predicate=predicate\n   \n def __iter__(self):\n  return self\n def __next__(self):\n  next_elt=next(self._iter)\n  while True :\n   if not self._predicate(next_elt):\n    return next_elt\n   next_elt=next(self._iter)\n   \nclass groupby:\n\n\n def __init__(self,iterable,key=None ):\n  if key is None :\n   key=lambda x:x\n  self.keyfunc=key\n  self.it=iter(iterable)\n  self.tgtkey=self.currkey=self.currvalue=object()\n def __iter__(self):\n  return self\n def __next__(self):\n  while self.currkey ==self.tgtkey:\n   self.currvalue=next(self.it)\n   self.currkey=self.keyfunc(self.currvalue)\n  self.tgtkey=self.currkey\n  return (self.currkey,self._grouper(self.tgtkey))\n def _grouper(self,tgtkey):\n  while self.currkey ==tgtkey:\n   yield self.currvalue\n   self.currvalue=next(self.it)\n   self.currkey=self.keyfunc(self.currvalue)\n   \n   \n   \nclass islice:\n def __init__(self,iterable,*args):\n  s=slice(*args)\n  self.start,self.stop,self.step=s.start or 0,s.stop,s.step\n  if not isinstance(self.start,int):\n   raise ValueError(\"Start argument must be an integer\")\n  if self.stop !=None and not isinstance(self.stop,int):\n   raise ValueError(\"Stop argument must be an integer or None\")\n  if self.step is None :\n   self.step=1\n  if self.start <0 or (self.stop !=None and self.stop <0\n  )or self.step <=0:\n   raise ValueError(\"indices for islice() must be positive\")\n  self.it=iter(iterable)\n  self.donext=None\n  self.cnt=0\n  \n def __iter__(self):\n  return self\n  \n def __next__(self):\n  nextindex=self.start\n  if self.stop !=None and nextindex >=self.stop:\n   raise StopIteration\n  while self.cnt <=nextindex:\n   nextitem=next(self.it)\n   self.cnt +=1\n  self.start +=self.step\n  return nextitem\n  \nclass permutations:\n def __init__(self,iterable,r=None ):\n  self.pool=tuple(iterable)\n  self.n=len(self.pool)\n  self.r=self.n if r is None else r\n  self.indices=list(range(self.n))\n  self.cycles=list(range(self.n,self.n -self.r,-1))\n  self.zero=False\n  self.stop=False\n  \n def __iter__(self):\n  return self\n  \n def __next__(self):\n  indices=self.indices\n  if self.r >self.n:\n   raise StopIteration\n  if not self.zero:\n   self.zero=True\n   return tuple(self.pool[i]for i in indices[:self.r])\n   \n  i=self.r -1\n  while i >=0:\n   j=self.cycles[i]-1\n   if j >0:\n    self.cycles[i]=j\n    indices[i],indices[-j]=indices[-j],indices[i]\n    return tuple(self.pool[i]for i in indices[:self.r])\n   self.cycles[i]=len(indices)-i\n   n1=len(indices)-1\n   assert n1 >=0\n   num=indices[i]\n   for k in range(i,n1):\n    indices[k]=indices[k+1]\n   indices[n1]=num\n   i -=1\n  raise StopIteration\n  \n  \ndef product(*args,repeat=1):\n\n\n pools=[tuple(pool)for pool in args]*repeat\n result=[[]]\n for pool in pools:\n  result=[x+[y]for x in result for y in pool]\n for prod in result:\n  yield tuple(prod)\n  \n  \n  \n  \n  \n  \n  \n  \nclass _product:\n def __init__(self,*args,**kw):\n  if len(kw)>1:\n   raise TypeError(\"product() takes at most 1 argument (%d given)\"%\n   len(kw))\n  self.repeat=kw.get('repeat',1)\n  if not isinstance(self.repeat,int):\n   raise TypeError(\"integer argument expected, got %s\"%\n   type(self.repeat))\n  self.gears=[x for x in args]*self.repeat\n  self.num_gears=len(self.gears)\n  \n  self.indicies=[(0,len(self.gears[x]))\n  for x in range(0,self.num_gears)]\n  self.cont=True\n  self.zero=False\n  \n def roll_gears(self):\n \n \n \n  should_carry=True\n  for n in range(0,self.num_gears):\n   nth_gear=self.num_gears -n -1\n   if should_carry:\n    count,lim=self.indicies[nth_gear]\n    count +=1\n    if count ==lim and nth_gear ==0:\n     self.cont=False\n    if count ==lim:\n     should_carry=True\n     count=0\n    else :\n     should_carry=False\n    self.indicies[nth_gear]=(count,lim)\n   else :\n    break\n    \n def __iter__(self):\n  return self\n  \n def __next__(self):\n  if self.zero:\n   raise StopIteration\n  if self.repeat >0:\n   if not self.cont:\n    raise StopIteration\n   l=[]\n   for x in range(0,self.num_gears):\n    index,limit=self.indicies[x]\n    print('itertools 353',self.gears,x,index)\n    l.append(self.gears[x][index])\n   self.roll_gears()\n   return tuple(l)\n  elif self.repeat ==0:\n   self.zero=True\n   return ()\n  else :\n   raise ValueError(\"repeat argument cannot be negative\")\n   \n   \n   \nclass repeat:\n def __init__(self,obj,times=None ):\n  self._obj=obj\n  if times is not None :\n   range(times)\n   if times <0:\n    times=0\n  self._times=times\n  \n def __iter__(self):\n  return self\n  \n def __next__(self):\n \n  if self._times is not None :\n   if self._times <=0:\n    raise StopIteration()\n   self._times -=1\n  return self._obj\n  \n def __repr__(self):\n  if self._times is not None :\n   return 'repeat(%r, %r)'%(self._obj,self._times)\n  else :\n   return 'repeat(%r)'%(self._obj,)\n   \n def __len__(self):\n  if self._times ==-1 or self._times is None :\n   raise TypeError(\"len() of uniszed object\")\n  return self._times\n  \n  \n  \nclass starmap(object):\n def __init__(self,function,iterable):\n  self._func=function\n  self._iter=iter(iterable)\n  \n def __iter__(self):\n  return self\n  \n def __next__(self):\n  t=next(self._iter)\n  return self._func(*t)\n  \n  \n  \nclass takewhile(object):\n def __init__(self,predicate,iterable):\n  self._predicate=predicate\n  self._iter=iter(iterable)\n  \n def __iter__(self):\n  return self\n  \n def __next__(self):\n  value=next(self._iter)\n  if not self._predicate(value):\n   raise StopIteration()\n  return value\n  \n  \n  \nclass TeeData(object):\n def __init__(self,iterator):\n  self.data=[]\n  self._iter=iterator\n  \n def __getitem__(self,i):\n \n  while i >=len(self.data):\n   self.data.append(next(self._iter))\n  return self.data[i]\n  \n  \nclass TeeObject(object):\n def __init__(self,iterable=None ,tee_data=None ):\n  if tee_data:\n   self.tee_data=tee_data\n   self.pos=0\n   \n  elif isinstance(iterable,TeeObject):\n   self.tee_data=iterable.tee_data\n   self.pos=iterable.pos\n  else :\n   self.tee_data=TeeData(iter(iterable))\n   self.pos=0\n   \n def __next__(self):\n  data=self.tee_data[self.pos]\n  self.pos +=1\n  return data\n  \n def __iter__(self):\n  return self\n  \n  \ndef tee(iterable,n=2):\n if isinstance(iterable,TeeObject):\n  return tuple([iterable]+\n  [TeeObject(tee_data=iterable.tee_data)for i in range(n -1)])\n tee_data=TeeData(iter(iterable))\n return tuple([TeeObject(tee_data=tee_data)for i in range(n)])\n \nclass zip_longest:\n def __init__(self,*args,fillvalue=None ):\n  self.args=[iter(arg)for arg in args]\n  self.fillvalue=fillvalue\n  self.units=len(args)\n  \n def __iter__(self):\n  return self\n  \n def __next__(self):\n  temp=[]\n  nb=0\n  for i in range(self.units):\n   try :\n    temp.append(next(self.args[i]))\n    nb +=1\n   except StopIteration:\n    temp.append(self.fillvalue)\n  if nb ==0:\n   raise StopIteration\n  return tuple(temp)\n", ["operator"]],
     "json": [".py", "''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n__version__='2.0.9'\n__all__=[\n'dump','dumps','load','loads',\n'JSONDecoder','JSONDecodeError','JSONEncoder',\n]\n\n__author__='Bob Ippolito <bob@redivi.com>'\n\n\n\n\n\nclass codecs:\n\n BOM_UTF8=b'\\xef\\xbb\\xbf'\n BOM_LE=BOM_UTF16_LE=b'\\xff\\xfe'\n BOM_BE=BOM_UTF16_BE=b'\\xfe\\xff'\n BOM_UTF32_LE=b'\\xff\\xfe\\x00\\x00'\n BOM_UTF32_BE=b'\\x00\\x00\\xfe\\xff'\n \nimport _json\n\nclass JSONDecodeError(ValueError):\n ''\n\n\n\n\n\n\n\n \n \n def __init__(self,msg,doc,pos):\n  lineno=doc.count('\\n',0,pos)+1\n  colno=pos -doc.rfind('\\n',0,pos)\n  errmsg='%s: line %d column %d (char %d)'%(msg,lineno,colno,pos)\n  ValueError.__init__(self,errmsg)\n  self.msg=msg\n  self.doc=doc\n  self.pos=pos\n  self.lineno=lineno\n  self.colno=colno\n  \n def __reduce__(self):\n  return self.__class__,(self.msg,self.doc,self.pos)\n  \ndef dump(obj,fp,**kw):\n fp.write(dumps(obj,**kw))\n \ndef dumps(obj,*,cls=None ,**kw):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n if cls is None :\n  return _json.dumps(obj,1,**kw)\n return cls(\n skipkeys=skipkeys,ensure_ascii=ensure_ascii,\n check_circular=check_circular,allow_nan=allow_nan,indent=indent,\n separators=separators,default=default,sort_keys=sort_keys,\n **kw).encode(obj)\n \ndef detect_encoding(b):\n bstartswith=b.startswith\n if bstartswith((codecs.BOM_UTF32_BE,codecs.BOM_UTF32_LE)):\n  return 'utf-32'\n if bstartswith((codecs.BOM_UTF16_BE,codecs.BOM_UTF16_LE)):\n  return 'utf-16'\n if bstartswith(codecs.BOM_UTF8):\n  return 'utf-8-sig'\n  \n if len(b)>=4:\n  if not b[0]:\n  \n  \n   return 'utf-16-be'if b[1]else 'utf-32-be'\n  if not b[1]:\n  \n  \n  \n   return 'utf-16-le'if b[2]or b[3]else 'utf-32-le'\n elif len(b)==2:\n  if not b[0]:\n  \n   return 'utf-16-be'\n  if not b[1]:\n  \n   return 'utf-16-le'\n   \n return 'utf-8'\n \n \ndef load(fp,*,cls=None ,object_hook=None ,parse_float=None ,\nparse_int=None ,parse_constant=None ,object_pairs_hook=None ,**kw):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n return loads(fp.read(),\n cls=cls,object_hook=object_hook,\n parse_float=parse_float,parse_int=parse_int,\n parse_constant=parse_constant,object_pairs_hook=object_pairs_hook,**kw)\n \n \ndef loads(s,*,cls=None ,**kw):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n if isinstance(s,str):\n  if s.startswith('\\ufeff'):\n   raise JSONDecodeError(\"Unexpected UTF-8 BOM (decode using utf-8-sig)\",\n   s,0)\n else :\n  if not isinstance(s,(bytes,bytearray)):\n   raise TypeError(f'the JSON object must be str, bytes or bytearray, '\n   f'not {s.__class__.__name__}')\n  s=s.decode(detect_encoding(s),'surrogatepass')\n  \n  \n if \"encoding\"in kw:\n  import warnings\n  warnings.warn(\n  \"'encoding' is ignored and deprecated. It will be removed in Python 3.9\",\n  DeprecationWarning,\n  stacklevel=2\n  )\n  del kw['encoding']\n  \n if cls is None :\n \n \n  return _json.loads(s,**kw)\n if object_hook is not None :\n  kw['object_hook']=object_hook\n if object_pairs_hook is not None :\n  kw['object_pairs_hook']=object_pairs_hook\n if parse_float is not None :\n  kw['parse_float']=parse_float\n if parse_int is not None :\n  kw['parse_int']=parse_int\n if parse_constant is not None :\n  kw['parse_constant']=parse_constant\n return cls(**kw).decode(s)\n", ["_json", "warnings"]],
     "keyword": [".py", "''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n__all__=[\"iskeyword\",\"issoftkeyword\",\"kwlist\",\"softkwlist\"]\n\nkwlist=[\n'False',\n'None',\n'True',\n'__peg_parser__',\n'and',\n'as',\n'assert',\n'async',\n'await',\n'break',\n'class',\n'continue',\n'def',\n'del',\n'elif',\n'else',\n'except',\n'finally',\n'for',\n'from',\n'global',\n'if',\n'import',\n'in',\n'is',\n'lambda',\n'nonlocal',\n'not',\n'or',\n'pass',\n'raise',\n'return',\n'try',\n'while',\n'with',\n'yield'\n]\n\nsoftkwlist=[\n\n]\n\niskeyword=frozenset(kwlist).__contains__\nissoftkeyword=frozenset(softkwlist).__contains__\n", []],
     "linecache": [".py", "''\n\n\n\n\n\n\nimport functools\nimport sys\nimport os\nimport tokenize\n\n__all__=[\"getline\",\"clearcache\",\"checkcache\",\"lazycache\"]\n\n\n\n\ncache={}\n\n\ndef clearcache():\n ''\n cache.clear()\n \n \ndef getline(filename,lineno,module_globals=None ):\n ''\n \n \n lines=getlines(filename,module_globals)\n if 1 <=lineno <=len(lines):\n  return lines[lineno -1]\n return ''\n \n \ndef getlines(filename,module_globals=None ):\n ''\n \n \n if filename in cache:\n  entry=cache[filename]\n  if len(entry)!=1:\n   return cache[filename][2]\n   \n try :\n  return updatecache(filename,module_globals)\n except MemoryError:\n  clearcache()\n  return []\n  \n  \ndef checkcache(filename=None ):\n ''\n \n \n if filename is None :\n  filenames=list(cache.keys())\n elif filename in cache:\n  filenames=[filename]\n else :\n  return\n  \n for filename in filenames:\n  entry=cache[filename]\n  if len(entry)==1:\n  \n   continue\n  size,mtime,lines,fullname=entry\n  if mtime is None :\n   continue\n  try :\n   stat=os.stat(fullname)\n  except OSError:\n   cache.pop(filename,None )\n   continue\n  if size !=stat.st_size or mtime !=stat.st_mtime:\n   cache.pop(filename,None )\n   \n   \ndef updatecache(filename,module_globals=None ):\n ''\n\n \n \n if filename in cache:\n  if len(cache[filename])!=1:\n   cache.pop(filename,None )\n if not filename or (filename.startswith('<')and filename.endswith('>')):\n  return []\n  \n fullname=filename\n try :\n  stat=os.stat(fullname)\n except OSError:\n  basename=filename\n  \n  \n  \n  if lazycache(filename,module_globals):\n   try :\n    data=cache[filename][0]()\n   except (ImportError,OSError):\n    pass\n   else :\n    if data is None :\n    \n    \n     return []\n    cache[filename]=(\n    len(data),\n    None ,\n    [line+'\\n'for line in data.splitlines()],\n    fullname\n    )\n    return cache[filename][2]\n    \n    \n    \n  if os.path.isabs(filename):\n   return []\n   \n  for dirname in sys.path:\n   try :\n    fullname=os.path.join(dirname,basename)\n   except (TypeError,AttributeError):\n   \n    continue\n   try :\n    stat=os.stat(fullname)\n    break\n   except OSError:\n    pass\n  else :\n   return []\n try :\n  with tokenize.open(fullname)as fp:\n   lines=fp.readlines()\n except OSError:\n  return []\n if lines and not lines[-1].endswith('\\n'):\n  lines[-1]+='\\n'\n size,mtime=stat.st_size,stat.st_mtime\n cache[filename]=size,mtime,lines,fullname\n return lines\n \n \ndef lazycache(filename,module_globals):\n ''\n\n\n\n\n\n\n\n\n\n\n \n if filename in cache:\n  if len(cache[filename])==1:\n   return True\n  else :\n   return False\n if not filename or (filename.startswith('<')and filename.endswith('>')):\n  return False\n  \n if module_globals and '__loader__'in module_globals:\n  name=module_globals.get('__name__')\n  loader=module_globals['__loader__']\n  get_source=getattr(loader,'get_source',None )\n  \n  if name and get_source:\n   get_lines=functools.partial(get_source,name)\n   cache[filename]=(get_lines,)\n   return True\n return False\n", ["functools", "os", "sys", "tokenize"]],
     "locale": [".py", "''\n\n\n\n\n\n\n\n\n\n\n\nimport sys\nimport encodings\nimport encodings.aliases\nimport re\nimport _collections_abc\nfrom builtins import str as _builtin_str\nimport functools\n\n\n\n\n\n\n\n__all__=[\"getlocale\",\"getdefaultlocale\",\"getpreferredencoding\",\"Error\",\n\"setlocale\",\"resetlocale\",\"localeconv\",\"strcoll\",\"strxfrm\",\n\"str\",\"atof\",\"atoi\",\"format\",\"format_string\",\"currency\",\n\"normalize\",\"LC_CTYPE\",\"LC_COLLATE\",\"LC_TIME\",\"LC_MONETARY\",\n\"LC_NUMERIC\",\"LC_ALL\",\"CHAR_MAX\"]\n\ndef _strcoll(a,b):\n ''\n\n \n return (a >b)-(a <b)\n \ndef _strxfrm(s):\n ''\n\n \n return s\n \ntry :\n\n from _locale import *\n \nexcept ImportError:\n\n\n\n CHAR_MAX=127\n LC_ALL=6\n LC_COLLATE=3\n LC_CTYPE=0\n LC_MESSAGES=5\n LC_MONETARY=4\n LC_NUMERIC=1\n LC_TIME=2\n Error=ValueError\n \n def localeconv():\n  ''\n\n  \n  \n  return {'grouping':[127],\n  'currency_symbol':'',\n  'n_sign_posn':127,\n  'p_cs_precedes':127,\n  'n_cs_precedes':127,\n  'mon_grouping':[],\n  'n_sep_by_space':127,\n  'decimal_point':'.',\n  'negative_sign':'',\n  'positive_sign':'',\n  'p_sep_by_space':127,\n  'int_curr_symbol':'',\n  'p_sign_posn':127,\n  'thousands_sep':'',\n  'mon_thousands_sep':'',\n  'frac_digits':127,\n  'mon_decimal_point':'',\n  'int_frac_digits':127}\n  \n def setlocale(category,value=None ):\n  ''\n\n  \n  if value not in (None ,'','C'):\n   raise Error('_locale emulation only supports \"C\" locale')\n  return 'C'\n  \n  \nif 'strxfrm'not in globals():\n strxfrm=_strxfrm\nif 'strcoll'not in globals():\n strcoll=_strcoll\n \n \n_localeconv=localeconv\n\n\n\n_override_localeconv={}\n\n@functools.wraps(_localeconv)\ndef localeconv():\n d=_localeconv()\n if _override_localeconv:\n  d.update(_override_localeconv)\n return d\n \n \n \n \n \n \n \n \ndef _grouping_intervals(grouping):\n last_interval=None\n for interval in grouping:\n \n  if interval ==CHAR_MAX:\n   return\n   \n  if interval ==0:\n   if last_interval is None :\n    raise ValueError(\"invalid grouping\")\n   while True :\n    yield last_interval\n  yield interval\n  last_interval=interval\n  \n  \ndef _group(s,monetary=False ):\n conv=localeconv()\n thousands_sep=conv[monetary and 'mon_thousands_sep'or 'thousands_sep']\n grouping=conv[monetary and 'mon_grouping'or 'grouping']\n if not grouping:\n  return (s,0)\n if s[-1]==' ':\n  stripped=s.rstrip()\n  right_spaces=s[len(stripped):]\n  s=stripped\n else :\n  right_spaces=''\n left_spaces=''\n groups=[]\n for interval in _grouping_intervals(grouping):\n  if not s or s[-1]not in \"0123456789\":\n  \n   left_spaces=s\n   s=''\n   break\n  groups.append(s[-interval:])\n  s=s[:-interval]\n if s:\n  groups.append(s)\n groups.reverse()\n return (\n left_spaces+thousands_sep.join(groups)+right_spaces,\n len(thousands_sep)*(len(groups)-1)\n )\n \n \ndef _strip_padding(s,amount):\n lpos=0\n while amount and s[lpos]==' ':\n  lpos +=1\n  amount -=1\n rpos=len(s)-1\n while amount and s[rpos]==' ':\n  rpos -=1\n  amount -=1\n return s[lpos:rpos+1]\n \n_percent_re=re.compile(r'%(?:\\((?P<key>.*?)\\))?'\nr'(?P<modifiers>[-#0-9 +*.hlL]*?)[eEfFgGdiouxXcrs%]')\n\ndef _format(percent,value,grouping=False ,monetary=False ,*additional):\n if additional:\n  formatted=percent %((value,)+additional)\n else :\n  formatted=percent %value\n  \n if percent[-1]in 'eEfFgG':\n  seps=0\n  parts=formatted.split('.')\n  if grouping:\n   parts[0],seps=_group(parts[0],monetary=monetary)\n  decimal_point=localeconv()[monetary and 'mon_decimal_point'\n  or 'decimal_point']\n  formatted=decimal_point.join(parts)\n  if seps:\n   formatted=_strip_padding(formatted,seps)\n elif percent[-1]in 'diu':\n  seps=0\n  if grouping:\n   formatted,seps=_group(formatted,monetary=monetary)\n  if seps:\n   formatted=_strip_padding(formatted,seps)\n return formatted\n \ndef format_string(f,val,grouping=False ,monetary=False ):\n ''\n\n\n\n\n \n percents=list(_percent_re.finditer(f))\n new_f=_percent_re.sub('%s',f)\n \n if isinstance(val,_collections_abc.Mapping):\n  new_val=[]\n  for perc in percents:\n   if perc.group()[-1]=='%':\n    new_val.append('%')\n   else :\n    new_val.append(_format(perc.group(),val,grouping,monetary))\n else :\n  if not isinstance(val,tuple):\n   val=(val,)\n  new_val=[]\n  i=0\n  for perc in percents:\n   if perc.group()[-1]=='%':\n    new_val.append('%')\n   else :\n    starcount=perc.group('modifiers').count('*')\n    new_val.append(_format(perc.group(),\n    val[i],\n    grouping,\n    monetary,\n    *val[i+1:i+1+starcount]))\n    i +=(1+starcount)\n val=tuple(new_val)\n \n return new_f %val\n \ndef format(percent,value,grouping=False ,monetary=False ,*additional):\n ''\n import warnings\n warnings.warn(\n \"This method will be removed in a future version of Python. \"\n \"Use 'locale.format_string()' instead.\",\n DeprecationWarning,stacklevel=2\n )\n \n match=_percent_re.match(percent)\n if not match or len(match.group())!=len(percent):\n  raise ValueError((\"format() must be given exactly one %%char \"\n  \"format specifier, %s not valid\")%repr(percent))\n return _format(percent,value,grouping,monetary,*additional)\n \ndef currency(val,symbol=True ,grouping=False ,international=False ):\n ''\n \n conv=localeconv()\n \n \n digits=conv[international and 'int_frac_digits'or 'frac_digits']\n if digits ==127:\n  raise ValueError(\"Currency formatting is not possible using \"\n  \"the 'C' locale.\")\n  \n s=_format('%%.%if'%digits,abs(val),grouping,monetary=True )\n \n s='<'+s+'>'\n \n if symbol:\n  smb=conv[international and 'int_curr_symbol'or 'currency_symbol']\n  precedes=conv[val <0 and 'n_cs_precedes'or 'p_cs_precedes']\n  separated=conv[val <0 and 'n_sep_by_space'or 'p_sep_by_space']\n  \n  if precedes:\n   s=smb+(separated and ' 'or '')+s\n  else :\n   if international and smb[-1]==' ':\n    smb=smb[:-1]\n   s=s+(separated and ' 'or '')+smb\n   \n sign_pos=conv[val <0 and 'n_sign_posn'or 'p_sign_posn']\n sign=conv[val <0 and 'negative_sign'or 'positive_sign']\n \n if sign_pos ==0:\n  s='('+s+')'\n elif sign_pos ==1:\n  s=sign+s\n elif sign_pos ==2:\n  s=s+sign\n elif sign_pos ==3:\n  s=s.replace('<',sign)\n elif sign_pos ==4:\n  s=s.replace('>',sign)\n else :\n \n \n  s=sign+s\n  \n return s.replace('<','').replace('>','')\n \ndef str(val):\n ''\n return _format(\"%.12g\",val)\n \ndef delocalize(string):\n ''\n \n conv=localeconv()\n \n \n ts=conv['thousands_sep']\n if ts:\n  string=string.replace(ts,'')\n  \n  \n dd=conv['decimal_point']\n if dd:\n  string=string.replace(dd,'.')\n return string\n \ndef atof(string,func=float):\n ''\n return func(delocalize(string))\n \ndef atoi(string):\n ''\n return int(delocalize(string))\n \ndef _test():\n setlocale(LC_ALL,\"\")\n \n s1=format_string(\"%d\",123456789,1)\n print(s1,\"is\",atoi(s1))\n \n s1=str(3.14)\n print(s1,\"is\",atof(s1))\n \n \n \n \n \n \n \n \n_setlocale=setlocale\n\ndef _replace_encoding(code,encoding):\n if '.'in code:\n  langname=code[:code.index('.')]\n else :\n  langname=code\n  \n norm_encoding=encodings.normalize_encoding(encoding)\n \n norm_encoding=encodings.aliases.aliases.get(norm_encoding.lower(),\n norm_encoding)\n \n encoding=norm_encoding\n norm_encoding=norm_encoding.lower()\n if norm_encoding in locale_encoding_alias:\n  encoding=locale_encoding_alias[norm_encoding]\n else :\n  norm_encoding=norm_encoding.replace('_','')\n  norm_encoding=norm_encoding.replace('-','')\n  if norm_encoding in locale_encoding_alias:\n   encoding=locale_encoding_alias[norm_encoding]\n   \n return langname+'.'+encoding\n \ndef _append_modifier(code,modifier):\n if modifier =='euro':\n  if '.'not in code:\n   return code+'.ISO8859-15'\n  _,_,encoding=code.partition('.')\n  if encoding in ('ISO8859-15','UTF-8'):\n   return code\n  if encoding =='ISO8859-1':\n   return _replace_encoding(code,'ISO8859-15')\n return code+'@'+modifier\n \ndef normalize(localename):\n\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n code=localename.lower()\n if ':'in code:\n \n  code=code.replace(':','.')\n if '@'in code:\n  code,modifier=code.split('@',1)\n else :\n  modifier=''\n if '.'in code:\n  langname,encoding=code.split('.')[:2]\n else :\n  langname=code\n  encoding=''\n  \n  \n lang_enc=langname\n if encoding:\n  norm_encoding=encoding.replace('-','')\n  norm_encoding=norm_encoding.replace('_','')\n  lang_enc +='.'+norm_encoding\n lookup_name=lang_enc\n if modifier:\n  lookup_name +='@'+modifier\n code=locale_alias.get(lookup_name,None )\n if code is not None :\n  return code\n  \n  \n if modifier:\n \n  code=locale_alias.get(lang_enc,None )\n  if code is not None :\n  \n   if '@'not in code:\n    return _append_modifier(code,modifier)\n   if code.split('@',1)[1].lower()==modifier:\n    return code\n    \n    \n if encoding:\n \n  lookup_name=langname\n  if modifier:\n   lookup_name +='@'+modifier\n  code=locale_alias.get(lookup_name,None )\n  if code is not None :\n  \n   if '@'not in code:\n    return _replace_encoding(code,encoding)\n   code,modifier=code.split('@',1)\n   return _replace_encoding(code,encoding)+'@'+modifier\n   \n  if modifier:\n  \n   code=locale_alias.get(langname,None )\n   if code is not None :\n   \n    if '@'not in code:\n     code=_replace_encoding(code,encoding)\n     return _append_modifier(code,modifier)\n    code,defmod=code.split('@',1)\n    if defmod.lower()==modifier:\n     return _replace_encoding(code,encoding)+'@'+defmod\n     \n return localename\n \ndef _parse_localename(localename):\n\n ''\n\n\n\n\n\n\n\n\n\n\n \n code=normalize(localename)\n if '@'in code:\n \n  code,modifier=code.split('@',1)\n  if modifier =='euro'and '.'not in code:\n  \n  \n  \n   return code,'iso-8859-15'\n   \n if '.'in code:\n  return tuple(code.split('.')[:2])\n elif code =='C':\n  return None ,None\n elif code =='UTF-8':\n \n \n  return None ,'UTF-8'\n raise ValueError('unknown locale: %s'%localename)\n \ndef _build_localename(localetuple):\n\n ''\n\n\n\n\n \n try :\n  language,encoding=localetuple\n  \n  if language is None :\n   language='C'\n  if encoding is None :\n   return language\n  else :\n   return language+'.'+encoding\n except (TypeError,ValueError):\n  raise TypeError('Locale must be None, a string, or an iterable of '\n  'two strings -- language code, encoding.')from None\n  \ndef getdefaultlocale(envvars=('LC_ALL','LC_CTYPE','LANG','LANGUAGE')):\n\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n try :\n \n  import _locale\n  code,encoding=_locale._getdefaultlocale()\n except (ImportError,AttributeError):\n  pass\n else :\n \n  if sys.platform ==\"win32\"and code and code[:2]==\"0x\":\n  \n   code=windows_locale.get(int(code,0))\n   \n   \n  return code,encoding\n  \n  \n import os\n lookup=os.environ.get\n for variable in envvars:\n  localename=lookup(variable,None )\n  if localename:\n   if variable =='LANGUAGE':\n    localename=localename.split(':')[0]\n   break\n else :\n  localename='C'\n return _parse_localename(localename)\n \n \ndef getlocale(category=LC_CTYPE):\n\n ''\n\n\n\n\n\n\n\n\n\n \n localename=_setlocale(category)\n if category ==LC_ALL and ';'in localename:\n  raise TypeError('category LC_ALL is not supported')\n return _parse_localename(localename)\n \ndef setlocale(category,locale=None ):\n\n ''\n\n\n\n\n\n\n\n\n \n if locale and not isinstance(locale,_builtin_str):\n \n  locale=normalize(_build_localename(locale))\n return _setlocale(category,locale)\n \ndef resetlocale(category=LC_ALL):\n\n ''\n\n\n\n\n \n _setlocale(category,_build_localename(getdefaultlocale()))\n \nif sys.platform.startswith(\"win\"):\n\n def getpreferredencoding(do_setlocale=True ):\n  ''\n  if sys.flags.utf8_mode:\n   return 'UTF-8'\n  import _bootlocale\n  return _bootlocale.getpreferredencoding(False )\nelse :\n\n try :\n  CODESET\n except NameError:\n  if hasattr(sys,'getandroidapilevel'):\n  \n  \n   def getpreferredencoding(do_setlocale=True ):\n    return 'UTF-8'\n  else :\n  \n   def getpreferredencoding(do_setlocale=True ):\n    ''\n    \n    if sys.flags.utf8_mode:\n     return 'UTF-8'\n    res=getdefaultlocale()[1]\n    if res is None :\n    \n     res='ascii'\n    return res\n else :\n  def getpreferredencoding(do_setlocale=True ):\n   ''\n   \n   if sys.flags.utf8_mode:\n    return 'UTF-8'\n   import _bootlocale\n   if do_setlocale:\n    oldloc=setlocale(LC_CTYPE)\n    try :\n     setlocale(LC_CTYPE,\"\")\n    except Error:\n     pass\n   result=_bootlocale.getpreferredencoding(False )\n   if do_setlocale:\n    setlocale(LC_CTYPE,oldloc)\n   return result\n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \nlocale_encoding_alias={\n\n\n'437':'C',\n'c':'C',\n'en':'ISO8859-1',\n'jis':'JIS7',\n'jis7':'JIS7',\n'ajec':'eucJP',\n'koi8c':'KOI8-C',\n'microsoftcp1251':'CP1251',\n'microsoftcp1255':'CP1255',\n'microsoftcp1256':'CP1256',\n'88591':'ISO8859-1',\n'88592':'ISO8859-2',\n'88595':'ISO8859-5',\n'885915':'ISO8859-15',\n\n\n'ascii':'ISO8859-1',\n'latin_1':'ISO8859-1',\n'iso8859_1':'ISO8859-1',\n'iso8859_10':'ISO8859-10',\n'iso8859_11':'ISO8859-11',\n'iso8859_13':'ISO8859-13',\n'iso8859_14':'ISO8859-14',\n'iso8859_15':'ISO8859-15',\n'iso8859_16':'ISO8859-16',\n'iso8859_2':'ISO8859-2',\n'iso8859_3':'ISO8859-3',\n'iso8859_4':'ISO8859-4',\n'iso8859_5':'ISO8859-5',\n'iso8859_6':'ISO8859-6',\n'iso8859_7':'ISO8859-7',\n'iso8859_8':'ISO8859-8',\n'iso8859_9':'ISO8859-9',\n'iso2022_jp':'JIS7',\n'shift_jis':'SJIS',\n'tactis':'TACTIS',\n'euc_jp':'eucJP',\n'euc_kr':'eucKR',\n'utf_8':'UTF-8',\n'koi8_r':'KOI8-R',\n'koi8_t':'KOI8-T',\n'koi8_u':'KOI8-U',\n'kz1048':'RK1048',\n'cp1251':'CP1251',\n'cp1255':'CP1255',\n'cp1256':'CP1256',\n\n\n\n}\n\nfor k,v in sorted(locale_encoding_alias.items()):\n k=k.replace('_','')\n locale_encoding_alias.setdefault(k,v)\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \nlocale_alias={\n'a3':'az_AZ.KOI8-C',\n'a3_az':'az_AZ.KOI8-C',\n'a3_az.koic':'az_AZ.KOI8-C',\n'aa_dj':'aa_DJ.ISO8859-1',\n'aa_er':'aa_ER.UTF-8',\n'aa_et':'aa_ET.UTF-8',\n'af':'af_ZA.ISO8859-1',\n'af_za':'af_ZA.ISO8859-1',\n'agr_pe':'agr_PE.UTF-8',\n'ak_gh':'ak_GH.UTF-8',\n'am':'am_ET.UTF-8',\n'am_et':'am_ET.UTF-8',\n'american':'en_US.ISO8859-1',\n'an_es':'an_ES.ISO8859-15',\n'anp_in':'anp_IN.UTF-8',\n'ar':'ar_AA.ISO8859-6',\n'ar_aa':'ar_AA.ISO8859-6',\n'ar_ae':'ar_AE.ISO8859-6',\n'ar_bh':'ar_BH.ISO8859-6',\n'ar_dz':'ar_DZ.ISO8859-6',\n'ar_eg':'ar_EG.ISO8859-6',\n'ar_in':'ar_IN.UTF-8',\n'ar_iq':'ar_IQ.ISO8859-6',\n'ar_jo':'ar_JO.ISO8859-6',\n'ar_kw':'ar_KW.ISO8859-6',\n'ar_lb':'ar_LB.ISO8859-6',\n'ar_ly':'ar_LY.ISO8859-6',\n'ar_ma':'ar_MA.ISO8859-6',\n'ar_om':'ar_OM.ISO8859-6',\n'ar_qa':'ar_QA.ISO8859-6',\n'ar_sa':'ar_SA.ISO8859-6',\n'ar_sd':'ar_SD.ISO8859-6',\n'ar_ss':'ar_SS.UTF-8',\n'ar_sy':'ar_SY.ISO8859-6',\n'ar_tn':'ar_TN.ISO8859-6',\n'ar_ye':'ar_YE.ISO8859-6',\n'arabic':'ar_AA.ISO8859-6',\n'as':'as_IN.UTF-8',\n'as_in':'as_IN.UTF-8',\n'ast_es':'ast_ES.ISO8859-15',\n'ayc_pe':'ayc_PE.UTF-8',\n'az':'az_AZ.ISO8859-9E',\n'az_az':'az_AZ.ISO8859-9E',\n'az_az.iso88599e':'az_AZ.ISO8859-9E',\n'az_ir':'az_IR.UTF-8',\n'be':'be_BY.CP1251',\n'be@latin':'be_BY.UTF-8@latin',\n'be_bg.utf8':'bg_BG.UTF-8',\n'be_by':'be_BY.CP1251',\n'be_by@latin':'be_BY.UTF-8@latin',\n'bem_zm':'bem_ZM.UTF-8',\n'ber_dz':'ber_DZ.UTF-8',\n'ber_ma':'ber_MA.UTF-8',\n'bg':'bg_BG.CP1251',\n'bg_bg':'bg_BG.CP1251',\n'bhb_in.utf8':'bhb_IN.UTF-8',\n'bho_in':'bho_IN.UTF-8',\n'bho_np':'bho_NP.UTF-8',\n'bi_vu':'bi_VU.UTF-8',\n'bn_bd':'bn_BD.UTF-8',\n'bn_in':'bn_IN.UTF-8',\n'bo_cn':'bo_CN.UTF-8',\n'bo_in':'bo_IN.UTF-8',\n'bokmal':'nb_NO.ISO8859-1',\n'bokm\\xe5l':'nb_NO.ISO8859-1',\n'br':'br_FR.ISO8859-1',\n'br_fr':'br_FR.ISO8859-1',\n'brx_in':'brx_IN.UTF-8',\n'bs':'bs_BA.ISO8859-2',\n'bs_ba':'bs_BA.ISO8859-2',\n'bulgarian':'bg_BG.CP1251',\n'byn_er':'byn_ER.UTF-8',\n'c':'C',\n'c-french':'fr_CA.ISO8859-1',\n'c.ascii':'C',\n'c.en':'C',\n'c.iso88591':'en_US.ISO8859-1',\n'c.utf8':'en_US.UTF-8',\n'c_c':'C',\n'c_c.c':'C',\n'ca':'ca_ES.ISO8859-1',\n'ca_ad':'ca_AD.ISO8859-1',\n'ca_es':'ca_ES.ISO8859-1',\n'ca_es@valencia':'ca_ES.UTF-8@valencia',\n'ca_fr':'ca_FR.ISO8859-1',\n'ca_it':'ca_IT.ISO8859-1',\n'catalan':'ca_ES.ISO8859-1',\n'ce_ru':'ce_RU.UTF-8',\n'cextend':'en_US.ISO8859-1',\n'chinese-s':'zh_CN.eucCN',\n'chinese-t':'zh_TW.eucTW',\n'chr_us':'chr_US.UTF-8',\n'ckb_iq':'ckb_IQ.UTF-8',\n'cmn_tw':'cmn_TW.UTF-8',\n'crh_ua':'crh_UA.UTF-8',\n'croatian':'hr_HR.ISO8859-2',\n'cs':'cs_CZ.ISO8859-2',\n'cs_cs':'cs_CZ.ISO8859-2',\n'cs_cz':'cs_CZ.ISO8859-2',\n'csb_pl':'csb_PL.UTF-8',\n'cv_ru':'cv_RU.UTF-8',\n'cy':'cy_GB.ISO8859-1',\n'cy_gb':'cy_GB.ISO8859-1',\n'cz':'cs_CZ.ISO8859-2',\n'cz_cz':'cs_CZ.ISO8859-2',\n'czech':'cs_CZ.ISO8859-2',\n'da':'da_DK.ISO8859-1',\n'da_dk':'da_DK.ISO8859-1',\n'danish':'da_DK.ISO8859-1',\n'dansk':'da_DK.ISO8859-1',\n'de':'de_DE.ISO8859-1',\n'de_at':'de_AT.ISO8859-1',\n'de_be':'de_BE.ISO8859-1',\n'de_ch':'de_CH.ISO8859-1',\n'de_de':'de_DE.ISO8859-1',\n'de_it':'de_IT.ISO8859-1',\n'de_li.utf8':'de_LI.UTF-8',\n'de_lu':'de_LU.ISO8859-1',\n'deutsch':'de_DE.ISO8859-1',\n'doi_in':'doi_IN.UTF-8',\n'dutch':'nl_NL.ISO8859-1',\n'dutch.iso88591':'nl_BE.ISO8859-1',\n'dv_mv':'dv_MV.UTF-8',\n'dz_bt':'dz_BT.UTF-8',\n'ee':'ee_EE.ISO8859-4',\n'ee_ee':'ee_EE.ISO8859-4',\n'eesti':'et_EE.ISO8859-1',\n'el':'el_GR.ISO8859-7',\n'el_cy':'el_CY.ISO8859-7',\n'el_gr':'el_GR.ISO8859-7',\n'el_gr@euro':'el_GR.ISO8859-15',\n'en':'en_US.ISO8859-1',\n'en_ag':'en_AG.UTF-8',\n'en_au':'en_AU.ISO8859-1',\n'en_be':'en_BE.ISO8859-1',\n'en_bw':'en_BW.ISO8859-1',\n'en_ca':'en_CA.ISO8859-1',\n'en_dk':'en_DK.ISO8859-1',\n'en_dl.utf8':'en_DL.UTF-8',\n'en_gb':'en_GB.ISO8859-1',\n'en_hk':'en_HK.ISO8859-1',\n'en_ie':'en_IE.ISO8859-1',\n'en_il':'en_IL.UTF-8',\n'en_in':'en_IN.ISO8859-1',\n'en_ng':'en_NG.UTF-8',\n'en_nz':'en_NZ.ISO8859-1',\n'en_ph':'en_PH.ISO8859-1',\n'en_sc.utf8':'en_SC.UTF-8',\n'en_sg':'en_SG.ISO8859-1',\n'en_uk':'en_GB.ISO8859-1',\n'en_us':'en_US.ISO8859-1',\n'en_us@euro@euro':'en_US.ISO8859-15',\n'en_za':'en_ZA.ISO8859-1',\n'en_zm':'en_ZM.UTF-8',\n'en_zw':'en_ZW.ISO8859-1',\n'en_zw.utf8':'en_ZS.UTF-8',\n'eng_gb':'en_GB.ISO8859-1',\n'english':'en_EN.ISO8859-1',\n'english.iso88591':'en_US.ISO8859-1',\n'english_uk':'en_GB.ISO8859-1',\n'english_united-states':'en_US.ISO8859-1',\n'english_united-states.437':'C',\n'english_us':'en_US.ISO8859-1',\n'eo':'eo_XX.ISO8859-3',\n'eo.utf8':'eo.UTF-8',\n'eo_eo':'eo_EO.ISO8859-3',\n'eo_us.utf8':'eo_US.UTF-8',\n'eo_xx':'eo_XX.ISO8859-3',\n'es':'es_ES.ISO8859-1',\n'es_ar':'es_AR.ISO8859-1',\n'es_bo':'es_BO.ISO8859-1',\n'es_cl':'es_CL.ISO8859-1',\n'es_co':'es_CO.ISO8859-1',\n'es_cr':'es_CR.ISO8859-1',\n'es_cu':'es_CU.UTF-8',\n'es_do':'es_DO.ISO8859-1',\n'es_ec':'es_EC.ISO8859-1',\n'es_es':'es_ES.ISO8859-1',\n'es_gt':'es_GT.ISO8859-1',\n'es_hn':'es_HN.ISO8859-1',\n'es_mx':'es_MX.ISO8859-1',\n'es_ni':'es_NI.ISO8859-1',\n'es_pa':'es_PA.ISO8859-1',\n'es_pe':'es_PE.ISO8859-1',\n'es_pr':'es_PR.ISO8859-1',\n'es_py':'es_PY.ISO8859-1',\n'es_sv':'es_SV.ISO8859-1',\n'es_us':'es_US.ISO8859-1',\n'es_uy':'es_UY.ISO8859-1',\n'es_ve':'es_VE.ISO8859-1',\n'estonian':'et_EE.ISO8859-1',\n'et':'et_EE.ISO8859-15',\n'et_ee':'et_EE.ISO8859-15',\n'eu':'eu_ES.ISO8859-1',\n'eu_es':'eu_ES.ISO8859-1',\n'eu_fr':'eu_FR.ISO8859-1',\n'fa':'fa_IR.UTF-8',\n'fa_ir':'fa_IR.UTF-8',\n'fa_ir.isiri3342':'fa_IR.ISIRI-3342',\n'ff_sn':'ff_SN.UTF-8',\n'fi':'fi_FI.ISO8859-15',\n'fi_fi':'fi_FI.ISO8859-15',\n'fil_ph':'fil_PH.UTF-8',\n'finnish':'fi_FI.ISO8859-1',\n'fo':'fo_FO.ISO8859-1',\n'fo_fo':'fo_FO.ISO8859-1',\n'fr':'fr_FR.ISO8859-1',\n'fr_be':'fr_BE.ISO8859-1',\n'fr_ca':'fr_CA.ISO8859-1',\n'fr_ch':'fr_CH.ISO8859-1',\n'fr_fr':'fr_FR.ISO8859-1',\n'fr_lu':'fr_LU.ISO8859-1',\n'fran\\xe7ais':'fr_FR.ISO8859-1',\n'fre_fr':'fr_FR.ISO8859-1',\n'french':'fr_FR.ISO8859-1',\n'french.iso88591':'fr_CH.ISO8859-1',\n'french_france':'fr_FR.ISO8859-1',\n'fur_it':'fur_IT.UTF-8',\n'fy_de':'fy_DE.UTF-8',\n'fy_nl':'fy_NL.UTF-8',\n'ga':'ga_IE.ISO8859-1',\n'ga_ie':'ga_IE.ISO8859-1',\n'galego':'gl_ES.ISO8859-1',\n'galician':'gl_ES.ISO8859-1',\n'gd':'gd_GB.ISO8859-1',\n'gd_gb':'gd_GB.ISO8859-1',\n'ger_de':'de_DE.ISO8859-1',\n'german':'de_DE.ISO8859-1',\n'german.iso88591':'de_CH.ISO8859-1',\n'german_germany':'de_DE.ISO8859-1',\n'gez_er':'gez_ER.UTF-8',\n'gez_et':'gez_ET.UTF-8',\n'gl':'gl_ES.ISO8859-1',\n'gl_es':'gl_ES.ISO8859-1',\n'greek':'el_GR.ISO8859-7',\n'gu_in':'gu_IN.UTF-8',\n'gv':'gv_GB.ISO8859-1',\n'gv_gb':'gv_GB.ISO8859-1',\n'ha_ng':'ha_NG.UTF-8',\n'hak_tw':'hak_TW.UTF-8',\n'he':'he_IL.ISO8859-8',\n'he_il':'he_IL.ISO8859-8',\n'hebrew':'he_IL.ISO8859-8',\n'hi':'hi_IN.ISCII-DEV',\n'hi_in':'hi_IN.ISCII-DEV',\n'hi_in.isciidev':'hi_IN.ISCII-DEV',\n'hif_fj':'hif_FJ.UTF-8',\n'hne':'hne_IN.UTF-8',\n'hne_in':'hne_IN.UTF-8',\n'hr':'hr_HR.ISO8859-2',\n'hr_hr':'hr_HR.ISO8859-2',\n'hrvatski':'hr_HR.ISO8859-2',\n'hsb_de':'hsb_DE.ISO8859-2',\n'ht_ht':'ht_HT.UTF-8',\n'hu':'hu_HU.ISO8859-2',\n'hu_hu':'hu_HU.ISO8859-2',\n'hungarian':'hu_HU.ISO8859-2',\n'hy_am':'hy_AM.UTF-8',\n'hy_am.armscii8':'hy_AM.ARMSCII_8',\n'ia':'ia.UTF-8',\n'ia_fr':'ia_FR.UTF-8',\n'icelandic':'is_IS.ISO8859-1',\n'id':'id_ID.ISO8859-1',\n'id_id':'id_ID.ISO8859-1',\n'ig_ng':'ig_NG.UTF-8',\n'ik_ca':'ik_CA.UTF-8',\n'in':'id_ID.ISO8859-1',\n'in_id':'id_ID.ISO8859-1',\n'is':'is_IS.ISO8859-1',\n'is_is':'is_IS.ISO8859-1',\n'iso-8859-1':'en_US.ISO8859-1',\n'iso-8859-15':'en_US.ISO8859-15',\n'iso8859-1':'en_US.ISO8859-1',\n'iso8859-15':'en_US.ISO8859-15',\n'iso_8859_1':'en_US.ISO8859-1',\n'iso_8859_15':'en_US.ISO8859-15',\n'it':'it_IT.ISO8859-1',\n'it_ch':'it_CH.ISO8859-1',\n'it_it':'it_IT.ISO8859-1',\n'italian':'it_IT.ISO8859-1',\n'iu':'iu_CA.NUNACOM-8',\n'iu_ca':'iu_CA.NUNACOM-8',\n'iu_ca.nunacom8':'iu_CA.NUNACOM-8',\n'iw':'he_IL.ISO8859-8',\n'iw_il':'he_IL.ISO8859-8',\n'iw_il.utf8':'iw_IL.UTF-8',\n'ja':'ja_JP.eucJP',\n'ja_jp':'ja_JP.eucJP',\n'ja_jp.euc':'ja_JP.eucJP',\n'ja_jp.mscode':'ja_JP.SJIS',\n'ja_jp.pck':'ja_JP.SJIS',\n'japan':'ja_JP.eucJP',\n'japanese':'ja_JP.eucJP',\n'japanese-euc':'ja_JP.eucJP',\n'japanese.euc':'ja_JP.eucJP',\n'jp_jp':'ja_JP.eucJP',\n'ka':'ka_GE.GEORGIAN-ACADEMY',\n'ka_ge':'ka_GE.GEORGIAN-ACADEMY',\n'ka_ge.georgianacademy':'ka_GE.GEORGIAN-ACADEMY',\n'ka_ge.georgianps':'ka_GE.GEORGIAN-PS',\n'ka_ge.georgianrs':'ka_GE.GEORGIAN-ACADEMY',\n'kab_dz':'kab_DZ.UTF-8',\n'kk_kz':'kk_KZ.ptcp154',\n'kl':'kl_GL.ISO8859-1',\n'kl_gl':'kl_GL.ISO8859-1',\n'km_kh':'km_KH.UTF-8',\n'kn':'kn_IN.UTF-8',\n'kn_in':'kn_IN.UTF-8',\n'ko':'ko_KR.eucKR',\n'ko_kr':'ko_KR.eucKR',\n'ko_kr.euc':'ko_KR.eucKR',\n'kok_in':'kok_IN.UTF-8',\n'korean':'ko_KR.eucKR',\n'korean.euc':'ko_KR.eucKR',\n'ks':'ks_IN.UTF-8',\n'ks_in':'ks_IN.UTF-8',\n'ks_in@devanagari.utf8':'ks_IN.UTF-8@devanagari',\n'ku_tr':'ku_TR.ISO8859-9',\n'kw':'kw_GB.ISO8859-1',\n'kw_gb':'kw_GB.ISO8859-1',\n'ky':'ky_KG.UTF-8',\n'ky_kg':'ky_KG.UTF-8',\n'lb_lu':'lb_LU.UTF-8',\n'lg_ug':'lg_UG.ISO8859-10',\n'li_be':'li_BE.UTF-8',\n'li_nl':'li_NL.UTF-8',\n'lij_it':'lij_IT.UTF-8',\n'lithuanian':'lt_LT.ISO8859-13',\n'ln_cd':'ln_CD.UTF-8',\n'lo':'lo_LA.MULELAO-1',\n'lo_la':'lo_LA.MULELAO-1',\n'lo_la.cp1133':'lo_LA.IBM-CP1133',\n'lo_la.ibmcp1133':'lo_LA.IBM-CP1133',\n'lo_la.mulelao1':'lo_LA.MULELAO-1',\n'lt':'lt_LT.ISO8859-13',\n'lt_lt':'lt_LT.ISO8859-13',\n'lv':'lv_LV.ISO8859-13',\n'lv_lv':'lv_LV.ISO8859-13',\n'lzh_tw':'lzh_TW.UTF-8',\n'mag_in':'mag_IN.UTF-8',\n'mai':'mai_IN.UTF-8',\n'mai_in':'mai_IN.UTF-8',\n'mai_np':'mai_NP.UTF-8',\n'mfe_mu':'mfe_MU.UTF-8',\n'mg_mg':'mg_MG.ISO8859-15',\n'mhr_ru':'mhr_RU.UTF-8',\n'mi':'mi_NZ.ISO8859-1',\n'mi_nz':'mi_NZ.ISO8859-1',\n'miq_ni':'miq_NI.UTF-8',\n'mjw_in':'mjw_IN.UTF-8',\n'mk':'mk_MK.ISO8859-5',\n'mk_mk':'mk_MK.ISO8859-5',\n'ml':'ml_IN.UTF-8',\n'ml_in':'ml_IN.UTF-8',\n'mn_mn':'mn_MN.UTF-8',\n'mni_in':'mni_IN.UTF-8',\n'mr':'mr_IN.UTF-8',\n'mr_in':'mr_IN.UTF-8',\n'ms':'ms_MY.ISO8859-1',\n'ms_my':'ms_MY.ISO8859-1',\n'mt':'mt_MT.ISO8859-3',\n'mt_mt':'mt_MT.ISO8859-3',\n'my_mm':'my_MM.UTF-8',\n'nan_tw':'nan_TW.UTF-8',\n'nb':'nb_NO.ISO8859-1',\n'nb_no':'nb_NO.ISO8859-1',\n'nds_de':'nds_DE.UTF-8',\n'nds_nl':'nds_NL.UTF-8',\n'ne_np':'ne_NP.UTF-8',\n'nhn_mx':'nhn_MX.UTF-8',\n'niu_nu':'niu_NU.UTF-8',\n'niu_nz':'niu_NZ.UTF-8',\n'nl':'nl_NL.ISO8859-1',\n'nl_aw':'nl_AW.UTF-8',\n'nl_be':'nl_BE.ISO8859-1',\n'nl_nl':'nl_NL.ISO8859-1',\n'nn':'nn_NO.ISO8859-1',\n'nn_no':'nn_NO.ISO8859-1',\n'no':'no_NO.ISO8859-1',\n'no@nynorsk':'ny_NO.ISO8859-1',\n'no_no':'no_NO.ISO8859-1',\n'no_no.iso88591@bokmal':'no_NO.ISO8859-1',\n'no_no.iso88591@nynorsk':'no_NO.ISO8859-1',\n'norwegian':'no_NO.ISO8859-1',\n'nr':'nr_ZA.ISO8859-1',\n'nr_za':'nr_ZA.ISO8859-1',\n'nso':'nso_ZA.ISO8859-15',\n'nso_za':'nso_ZA.ISO8859-15',\n'ny':'ny_NO.ISO8859-1',\n'ny_no':'ny_NO.ISO8859-1',\n'nynorsk':'nn_NO.ISO8859-1',\n'oc':'oc_FR.ISO8859-1',\n'oc_fr':'oc_FR.ISO8859-1',\n'om_et':'om_ET.UTF-8',\n'om_ke':'om_KE.ISO8859-1',\n'or':'or_IN.UTF-8',\n'or_in':'or_IN.UTF-8',\n'os_ru':'os_RU.UTF-8',\n'pa':'pa_IN.UTF-8',\n'pa_in':'pa_IN.UTF-8',\n'pa_pk':'pa_PK.UTF-8',\n'pap_an':'pap_AN.UTF-8',\n'pap_aw':'pap_AW.UTF-8',\n'pap_cw':'pap_CW.UTF-8',\n'pd':'pd_US.ISO8859-1',\n'pd_de':'pd_DE.ISO8859-1',\n'pd_us':'pd_US.ISO8859-1',\n'ph':'ph_PH.ISO8859-1',\n'ph_ph':'ph_PH.ISO8859-1',\n'pl':'pl_PL.ISO8859-2',\n'pl_pl':'pl_PL.ISO8859-2',\n'polish':'pl_PL.ISO8859-2',\n'portuguese':'pt_PT.ISO8859-1',\n'portuguese_brazil':'pt_BR.ISO8859-1',\n'posix':'C',\n'posix-utf2':'C',\n'pp':'pp_AN.ISO8859-1',\n'pp_an':'pp_AN.ISO8859-1',\n'ps_af':'ps_AF.UTF-8',\n'pt':'pt_PT.ISO8859-1',\n'pt_br':'pt_BR.ISO8859-1',\n'pt_pt':'pt_PT.ISO8859-1',\n'quz_pe':'quz_PE.UTF-8',\n'raj_in':'raj_IN.UTF-8',\n'ro':'ro_RO.ISO8859-2',\n'ro_ro':'ro_RO.ISO8859-2',\n'romanian':'ro_RO.ISO8859-2',\n'ru':'ru_RU.UTF-8',\n'ru_ru':'ru_RU.UTF-8',\n'ru_ua':'ru_UA.KOI8-U',\n'rumanian':'ro_RO.ISO8859-2',\n'russian':'ru_RU.KOI8-R',\n'rw':'rw_RW.ISO8859-1',\n'rw_rw':'rw_RW.ISO8859-1',\n'sa_in':'sa_IN.UTF-8',\n'sat_in':'sat_IN.UTF-8',\n'sc_it':'sc_IT.UTF-8',\n'sd':'sd_IN.UTF-8',\n'sd_in':'sd_IN.UTF-8',\n'sd_in@devanagari.utf8':'sd_IN.UTF-8@devanagari',\n'sd_pk':'sd_PK.UTF-8',\n'se_no':'se_NO.UTF-8',\n'serbocroatian':'sr_RS.UTF-8@latin',\n'sgs_lt':'sgs_LT.UTF-8',\n'sh':'sr_RS.UTF-8@latin',\n'sh_ba.iso88592@bosnia':'sr_CS.ISO8859-2',\n'sh_hr':'sh_HR.ISO8859-2',\n'sh_hr.iso88592':'hr_HR.ISO8859-2',\n'sh_sp':'sr_CS.ISO8859-2',\n'sh_yu':'sr_RS.UTF-8@latin',\n'shn_mm':'shn_MM.UTF-8',\n'shs_ca':'shs_CA.UTF-8',\n'si':'si_LK.UTF-8',\n'si_lk':'si_LK.UTF-8',\n'sid_et':'sid_ET.UTF-8',\n'sinhala':'si_LK.UTF-8',\n'sk':'sk_SK.ISO8859-2',\n'sk_sk':'sk_SK.ISO8859-2',\n'sl':'sl_SI.ISO8859-2',\n'sl_cs':'sl_CS.ISO8859-2',\n'sl_si':'sl_SI.ISO8859-2',\n'slovak':'sk_SK.ISO8859-2',\n'slovene':'sl_SI.ISO8859-2',\n'slovenian':'sl_SI.ISO8859-2',\n'sm_ws':'sm_WS.UTF-8',\n'so_dj':'so_DJ.ISO8859-1',\n'so_et':'so_ET.UTF-8',\n'so_ke':'so_KE.ISO8859-1',\n'so_so':'so_SO.ISO8859-1',\n'sp':'sr_CS.ISO8859-5',\n'sp_yu':'sr_CS.ISO8859-5',\n'spanish':'es_ES.ISO8859-1',\n'spanish_spain':'es_ES.ISO8859-1',\n'sq':'sq_AL.ISO8859-2',\n'sq_al':'sq_AL.ISO8859-2',\n'sq_mk':'sq_MK.UTF-8',\n'sr':'sr_RS.UTF-8',\n'sr@cyrillic':'sr_RS.UTF-8',\n'sr@latn':'sr_CS.UTF-8@latin',\n'sr_cs':'sr_CS.UTF-8',\n'sr_cs.iso88592@latn':'sr_CS.ISO8859-2',\n'sr_cs@latn':'sr_CS.UTF-8@latin',\n'sr_me':'sr_ME.UTF-8',\n'sr_rs':'sr_RS.UTF-8',\n'sr_rs@latn':'sr_RS.UTF-8@latin',\n'sr_sp':'sr_CS.ISO8859-2',\n'sr_yu':'sr_RS.UTF-8@latin',\n'sr_yu.cp1251@cyrillic':'sr_CS.CP1251',\n'sr_yu.iso88592':'sr_CS.ISO8859-2',\n'sr_yu.iso88595':'sr_CS.ISO8859-5',\n'sr_yu.iso88595@cyrillic':'sr_CS.ISO8859-5',\n'sr_yu.microsoftcp1251@cyrillic':'sr_CS.CP1251',\n'sr_yu.utf8':'sr_RS.UTF-8',\n'sr_yu.utf8@cyrillic':'sr_RS.UTF-8',\n'sr_yu@cyrillic':'sr_RS.UTF-8',\n'ss':'ss_ZA.ISO8859-1',\n'ss_za':'ss_ZA.ISO8859-1',\n'st':'st_ZA.ISO8859-1',\n'st_za':'st_ZA.ISO8859-1',\n'sv':'sv_SE.ISO8859-1',\n'sv_fi':'sv_FI.ISO8859-1',\n'sv_se':'sv_SE.ISO8859-1',\n'sw_ke':'sw_KE.UTF-8',\n'sw_tz':'sw_TZ.UTF-8',\n'swedish':'sv_SE.ISO8859-1',\n'szl_pl':'szl_PL.UTF-8',\n'ta':'ta_IN.TSCII-0',\n'ta_in':'ta_IN.TSCII-0',\n'ta_in.tscii':'ta_IN.TSCII-0',\n'ta_in.tscii0':'ta_IN.TSCII-0',\n'ta_lk':'ta_LK.UTF-8',\n'tcy_in.utf8':'tcy_IN.UTF-8',\n'te':'te_IN.UTF-8',\n'te_in':'te_IN.UTF-8',\n'tg':'tg_TJ.KOI8-C',\n'tg_tj':'tg_TJ.KOI8-C',\n'th':'th_TH.ISO8859-11',\n'th_th':'th_TH.ISO8859-11',\n'th_th.tactis':'th_TH.TIS620',\n'th_th.tis620':'th_TH.TIS620',\n'thai':'th_TH.ISO8859-11',\n'the_np':'the_NP.UTF-8',\n'ti_er':'ti_ER.UTF-8',\n'ti_et':'ti_ET.UTF-8',\n'tig_er':'tig_ER.UTF-8',\n'tk_tm':'tk_TM.UTF-8',\n'tl':'tl_PH.ISO8859-1',\n'tl_ph':'tl_PH.ISO8859-1',\n'tn':'tn_ZA.ISO8859-15',\n'tn_za':'tn_ZA.ISO8859-15',\n'to_to':'to_TO.UTF-8',\n'tpi_pg':'tpi_PG.UTF-8',\n'tr':'tr_TR.ISO8859-9',\n'tr_cy':'tr_CY.ISO8859-9',\n'tr_tr':'tr_TR.ISO8859-9',\n'ts':'ts_ZA.ISO8859-1',\n'ts_za':'ts_ZA.ISO8859-1',\n'tt':'tt_RU.TATAR-CYR',\n'tt_ru':'tt_RU.TATAR-CYR',\n'tt_ru.tatarcyr':'tt_RU.TATAR-CYR',\n'tt_ru@iqtelif':'tt_RU.UTF-8@iqtelif',\n'turkish':'tr_TR.ISO8859-9',\n'ug_cn':'ug_CN.UTF-8',\n'uk':'uk_UA.KOI8-U',\n'uk_ua':'uk_UA.KOI8-U',\n'univ':'en_US.utf',\n'universal':'en_US.utf',\n'universal.utf8@ucs4':'en_US.UTF-8',\n'unm_us':'unm_US.UTF-8',\n'ur':'ur_PK.CP1256',\n'ur_in':'ur_IN.UTF-8',\n'ur_pk':'ur_PK.CP1256',\n'uz':'uz_UZ.UTF-8',\n'uz_uz':'uz_UZ.UTF-8',\n'uz_uz@cyrillic':'uz_UZ.UTF-8',\n've':'ve_ZA.UTF-8',\n've_za':'ve_ZA.UTF-8',\n'vi':'vi_VN.TCVN',\n'vi_vn':'vi_VN.TCVN',\n'vi_vn.tcvn':'vi_VN.TCVN',\n'vi_vn.tcvn5712':'vi_VN.TCVN',\n'vi_vn.viscii':'vi_VN.VISCII',\n'vi_vn.viscii111':'vi_VN.VISCII',\n'wa':'wa_BE.ISO8859-1',\n'wa_be':'wa_BE.ISO8859-1',\n'wae_ch':'wae_CH.UTF-8',\n'wal_et':'wal_ET.UTF-8',\n'wo_sn':'wo_SN.UTF-8',\n'xh':'xh_ZA.ISO8859-1',\n'xh_za':'xh_ZA.ISO8859-1',\n'yi':'yi_US.CP1255',\n'yi_us':'yi_US.CP1255',\n'yo_ng':'yo_NG.UTF-8',\n'yue_hk':'yue_HK.UTF-8',\n'yuw_pg':'yuw_PG.UTF-8',\n'zh':'zh_CN.eucCN',\n'zh_cn':'zh_CN.gb2312',\n'zh_cn.big5':'zh_TW.big5',\n'zh_cn.euc':'zh_CN.eucCN',\n'zh_hk':'zh_HK.big5hkscs',\n'zh_hk.big5hk':'zh_HK.big5hkscs',\n'zh_sg':'zh_SG.GB2312',\n'zh_sg.gbk':'zh_SG.GBK',\n'zh_tw':'zh_TW.big5',\n'zh_tw.euc':'zh_TW.eucTW',\n'zh_tw.euctw':'zh_TW.eucTW',\n'zu':'zu_ZA.ISO8859-1',\n'zu_za':'zu_ZA.ISO8859-1',\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nwindows_locale={\n0x0436:\"af_ZA\",\n0x041c:\"sq_AL\",\n0x0484:\"gsw_FR\",\n0x045e:\"am_ET\",\n0x0401:\"ar_SA\",\n0x0801:\"ar_IQ\",\n0x0c01:\"ar_EG\",\n0x1001:\"ar_LY\",\n0x1401:\"ar_DZ\",\n0x1801:\"ar_MA\",\n0x1c01:\"ar_TN\",\n0x2001:\"ar_OM\",\n0x2401:\"ar_YE\",\n0x2801:\"ar_SY\",\n0x2c01:\"ar_JO\",\n0x3001:\"ar_LB\",\n0x3401:\"ar_KW\",\n0x3801:\"ar_AE\",\n0x3c01:\"ar_BH\",\n0x4001:\"ar_QA\",\n0x042b:\"hy_AM\",\n0x044d:\"as_IN\",\n0x042c:\"az_AZ\",\n0x082c:\"az_AZ\",\n0x046d:\"ba_RU\",\n0x042d:\"eu_ES\",\n0x0423:\"be_BY\",\n0x0445:\"bn_IN\",\n0x201a:\"bs_BA\",\n0x141a:\"bs_BA\",\n0x047e:\"br_FR\",\n0x0402:\"bg_BG\",\n\n0x0403:\"ca_ES\",\n0x0004:\"zh_CHS\",\n0x0404:\"zh_TW\",\n0x0804:\"zh_CN\",\n0x0c04:\"zh_HK\",\n0x1004:\"zh_SG\",\n0x1404:\"zh_MO\",\n0x7c04:\"zh_CHT\",\n0x0483:\"co_FR\",\n0x041a:\"hr_HR\",\n0x101a:\"hr_BA\",\n0x0405:\"cs_CZ\",\n0x0406:\"da_DK\",\n0x048c:\"gbz_AF\",\n0x0465:\"div_MV\",\n0x0413:\"nl_NL\",\n0x0813:\"nl_BE\",\n0x0409:\"en_US\",\n0x0809:\"en_GB\",\n0x0c09:\"en_AU\",\n0x1009:\"en_CA\",\n0x1409:\"en_NZ\",\n0x1809:\"en_IE\",\n0x1c09:\"en_ZA\",\n0x2009:\"en_JA\",\n0x2409:\"en_CB\",\n0x2809:\"en_BZ\",\n0x2c09:\"en_TT\",\n0x3009:\"en_ZW\",\n0x3409:\"en_PH\",\n0x4009:\"en_IN\",\n0x4409:\"en_MY\",\n0x4809:\"en_IN\",\n0x0425:\"et_EE\",\n0x0438:\"fo_FO\",\n0x0464:\"fil_PH\",\n0x040b:\"fi_FI\",\n0x040c:\"fr_FR\",\n0x080c:\"fr_BE\",\n0x0c0c:\"fr_CA\",\n0x100c:\"fr_CH\",\n0x140c:\"fr_LU\",\n0x180c:\"fr_MC\",\n0x0462:\"fy_NL\",\n0x0456:\"gl_ES\",\n0x0437:\"ka_GE\",\n0x0407:\"de_DE\",\n0x0807:\"de_CH\",\n0x0c07:\"de_AT\",\n0x1007:\"de_LU\",\n0x1407:\"de_LI\",\n0x0408:\"el_GR\",\n0x046f:\"kl_GL\",\n0x0447:\"gu_IN\",\n0x0468:\"ha_NG\",\n0x040d:\"he_IL\",\n0x0439:\"hi_IN\",\n0x040e:\"hu_HU\",\n0x040f:\"is_IS\",\n0x0421:\"id_ID\",\n0x045d:\"iu_CA\",\n0x085d:\"iu_CA\",\n0x083c:\"ga_IE\",\n0x0410:\"it_IT\",\n0x0810:\"it_CH\",\n0x0411:\"ja_JP\",\n0x044b:\"kn_IN\",\n0x043f:\"kk_KZ\",\n0x0453:\"kh_KH\",\n0x0486:\"qut_GT\",\n0x0487:\"rw_RW\",\n0x0457:\"kok_IN\",\n0x0412:\"ko_KR\",\n0x0440:\"ky_KG\",\n0x0454:\"lo_LA\",\n0x0426:\"lv_LV\",\n0x0427:\"lt_LT\",\n0x082e:\"dsb_DE\",\n0x046e:\"lb_LU\",\n0x042f:\"mk_MK\",\n0x043e:\"ms_MY\",\n0x083e:\"ms_BN\",\n0x044c:\"ml_IN\",\n0x043a:\"mt_MT\",\n0x0481:\"mi_NZ\",\n0x047a:\"arn_CL\",\n0x044e:\"mr_IN\",\n0x047c:\"moh_CA\",\n0x0450:\"mn_MN\",\n0x0850:\"mn_CN\",\n0x0461:\"ne_NP\",\n0x0414:\"nb_NO\",\n0x0814:\"nn_NO\",\n0x0482:\"oc_FR\",\n0x0448:\"or_IN\",\n0x0463:\"ps_AF\",\n0x0429:\"fa_IR\",\n0x0415:\"pl_PL\",\n0x0416:\"pt_BR\",\n0x0816:\"pt_PT\",\n0x0446:\"pa_IN\",\n0x046b:\"quz_BO\",\n0x086b:\"quz_EC\",\n0x0c6b:\"quz_PE\",\n0x0418:\"ro_RO\",\n0x0417:\"rm_CH\",\n0x0419:\"ru_RU\",\n0x243b:\"smn_FI\",\n0x103b:\"smj_NO\",\n0x143b:\"smj_SE\",\n0x043b:\"se_NO\",\n0x083b:\"se_SE\",\n0x0c3b:\"se_FI\",\n0x203b:\"sms_FI\",\n0x183b:\"sma_NO\",\n0x1c3b:\"sma_SE\",\n0x044f:\"sa_IN\",\n0x0c1a:\"sr_SP\",\n0x1c1a:\"sr_BA\",\n0x081a:\"sr_SP\",\n0x181a:\"sr_BA\",\n0x045b:\"si_LK\",\n0x046c:\"ns_ZA\",\n0x0432:\"tn_ZA\",\n0x041b:\"sk_SK\",\n0x0424:\"sl_SI\",\n0x040a:\"es_ES\",\n0x080a:\"es_MX\",\n0x0c0a:\"es_ES\",\n0x100a:\"es_GT\",\n0x140a:\"es_CR\",\n0x180a:\"es_PA\",\n0x1c0a:\"es_DO\",\n0x200a:\"es_VE\",\n0x240a:\"es_CO\",\n0x280a:\"es_PE\",\n0x2c0a:\"es_AR\",\n0x300a:\"es_EC\",\n0x340a:\"es_CL\",\n0x380a:\"es_UR\",\n0x3c0a:\"es_PY\",\n0x400a:\"es_BO\",\n0x440a:\"es_SV\",\n0x480a:\"es_HN\",\n0x4c0a:\"es_NI\",\n0x500a:\"es_PR\",\n0x540a:\"es_US\",\n\n0x0441:\"sw_KE\",\n0x041d:\"sv_SE\",\n0x081d:\"sv_FI\",\n0x045a:\"syr_SY\",\n0x0428:\"tg_TJ\",\n0x085f:\"tmz_DZ\",\n0x0449:\"ta_IN\",\n0x0444:\"tt_RU\",\n0x044a:\"te_IN\",\n0x041e:\"th_TH\",\n0x0851:\"bo_BT\",\n0x0451:\"bo_CN\",\n0x041f:\"tr_TR\",\n0x0442:\"tk_TM\",\n0x0480:\"ug_CN\",\n0x0422:\"uk_UA\",\n0x042e:\"wen_DE\",\n0x0420:\"ur_PK\",\n0x0820:\"ur_IN\",\n0x0443:\"uz_UZ\",\n0x0843:\"uz_UZ\",\n0x042a:\"vi_VN\",\n0x0452:\"cy_GB\",\n0x0488:\"wo_SN\",\n0x0434:\"xh_ZA\",\n0x0485:\"sah_RU\",\n0x0478:\"ii_CN\",\n0x046a:\"yo_NG\",\n0x0435:\"zu_ZA\",\n}\n\ndef _print_locale():\n\n ''\n \n categories={}\n def _init_categories(categories=categories):\n  for k,v in globals().items():\n   if k[:3]=='LC_':\n    categories[k]=v\n _init_categories()\n del categories['LC_ALL']\n \n print('Locale defaults as determined by getdefaultlocale():')\n print('-'*72)\n lang,enc=getdefaultlocale()\n print('Language: ',lang or '(undefined)')\n print('Encoding: ',enc or '(undefined)')\n print()\n \n print('Locale settings on startup:')\n print('-'*72)\n for name,category in categories.items():\n  print(name,'...')\n  lang,enc=getlocale(category)\n  print('   Language: ',lang or '(undefined)')\n  print('   Encoding: ',enc or '(undefined)')\n  print()\n  \n print()\n print('Locale settings after calling resetlocale():')\n print('-'*72)\n resetlocale()\n for name,category in categories.items():\n  print(name,'...')\n  lang,enc=getlocale(category)\n  print('   Language: ',lang or '(undefined)')\n  print('   Encoding: ',enc or '(undefined)')\n  print()\n  \n try :\n  setlocale(LC_ALL,\"\")\n except :\n  print('NOTE:')\n  print('setlocale(LC_ALL, \"\") does not support the default locale')\n  print('given in the OS environment variables.')\n else :\n  print()\n  print('Locale settings after calling setlocale(LC_ALL, \"\"):')\n  print('-'*72)\n  for name,category in categories.items():\n   print(name,'...')\n   lang,enc=getlocale(category)\n   print('   Language: ',lang or '(undefined)')\n   print('   Encoding: ',enc or '(undefined)')\n   print()\n   \n   \n   \ntry :\n LC_MESSAGES\nexcept NameError:\n pass\nelse :\n __all__.append(\"LC_MESSAGES\")\n \nif __name__ =='__main__':\n print('Locale aliasing:')\n print()\n _print_locale()\n print()\n print('Number formatting:')\n print()\n _test()\n", ["_bootlocale", "_collections_abc", "_locale", "builtins", "encodings", "encodings.aliases", "functools", "os", "re", "sys", "warnings"]],
@@ -141,15 +141,15 @@
     "this": [".py", "s=\"\"\"Gur Mra bs Clguba, ol Gvz Crgref\n\nOrnhgvshy vf orggre guna htyl.\nRkcyvpvg vf orggre guna vzcyvpvg.\nFvzcyr vf orggre guna pbzcyrk.\nPbzcyrk vf orggre guna pbzcyvpngrq.\nSyng vf orggre guna arfgrq.\nFcnefr vf orggre guna qrafr.\nErnqnovyvgl pbhagf.\nFcrpvny pnfrf nera'g fcrpvny rabhtu gb oernx gur ehyrf.\nNygubhtu cenpgvpnyvgl orngf chevgl.\nReebef fubhyq arire cnff fvyragyl.\nHayrff rkcyvpvgyl fvyraprq.\nVa gur snpr bs nzovthvgl, ershfr gur grzcgngvba gb thrff.\nGurer fubhyq or bar-- naq cersrenoyl bayl bar --boivbhf jnl gb qb vg.\nNygubhtu gung jnl znl abg or boivbhf ng svefg hayrff lbh'er Qhgpu.\nAbj vf orggre guna arire.\nNygubhtu arire vf bsgra orggre guna *evtug* abj.\nVs gur vzcyrzragngvba vf uneq gb rkcynva, vg'f n onq vqrn.\nVs gur vzcyrzragngvba vf rnfl gb rkcynva, vg znl or n tbbq vqrn.\nAnzrfcnprf ner bar ubaxvat terng vqrn -- yrg'f qb zber bs gubfr!\"\"\"\n\nd={}\nfor c in (65,97):\n for i in range(26):\n  d[chr(i+c)]=chr((i+13)%26+c)\n  \nprint(\"\".join([d.get(c,c)for c in s]))\n", []],
     "threading": [".py", "''\n\nimport os as _os\nimport sys as _sys\nimport _thread\nimport functools\n\nfrom time import monotonic as _time\nfrom _weakrefset import WeakSet\nfrom itertools import islice as _islice,count as _count\ntry :\n from _collections import deque as _deque\nexcept ImportError:\n from collections import deque as _deque\n \n \n \n \n \n \n \n \n \n \n \n__all__=['get_ident','active_count','Condition','current_thread',\n'enumerate','main_thread','TIMEOUT_MAX',\n'Event','Lock','RLock','Semaphore','BoundedSemaphore','Thread',\n'Barrier','BrokenBarrierError','Timer','ThreadError',\n'setprofile','settrace','local','stack_size',\n'excepthook','ExceptHookArgs']\n\n\n_start_new_thread=_thread.start_new_thread\n_allocate_lock=_thread.allocate_lock\n_set_sentinel=_thread._set_sentinel\nget_ident=_thread.get_ident\ntry :\n get_native_id=_thread.get_native_id\n _HAVE_THREAD_NATIVE_ID=True\n __all__.append('get_native_id')\nexcept AttributeError:\n _HAVE_THREAD_NATIVE_ID=False\nThreadError=_thread.error\ntry :\n _CRLock=_thread.RLock\nexcept AttributeError:\n _CRLock=None\nTIMEOUT_MAX=_thread.TIMEOUT_MAX\ndel _thread\n\n\n\n\n_profile_hook=None\n_trace_hook=None\n\ndef setprofile(func):\n ''\n\n\n\n\n \n global _profile_hook\n _profile_hook=func\n \ndef settrace(func):\n ''\n\n\n\n\n \n global _trace_hook\n _trace_hook=func\n \n \n \nLock=_allocate_lock\n\ndef RLock(*args,**kwargs):\n ''\n\n\n\n\n\n\n \n if _CRLock is None :\n  return _PyRLock(*args,**kwargs)\n return _CRLock(*args,**kwargs)\n \nclass _RLock:\n ''\n\n\n\n\n\n\n \n \n def __init__(self):\n  self._block=_allocate_lock()\n  self._owner=None\n  self._count=0\n  \n def __repr__(self):\n  owner=self._owner\n  try :\n   owner=_active[owner].name\n  except KeyError:\n   pass\n  return \"<%s %s.%s object owner=%r count=%d at %s>\"%(\n  \"locked\"if self._block.locked()else \"unlocked\",\n  self.__class__.__module__,\n  self.__class__.__qualname__,\n  owner,\n  self._count,\n  hex(id(self))\n  )\n  \n def _at_fork_reinit(self):\n  self._block._at_fork_reinit()\n  self._owner=None\n  self._count=0\n  \n def acquire(self,blocking=True ,timeout=-1):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  me=get_ident()\n  if self._owner ==me:\n   self._count +=1\n   return 1\n  rc=self._block.acquire(blocking,timeout)\n  if rc:\n   self._owner=me\n   self._count=1\n  return rc\n  \n __enter__=acquire\n \n def release(self):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  if self._owner !=get_ident():\n   raise RuntimeError(\"cannot release un-acquired lock\")\n  self._count=count=self._count -1\n  if not count:\n   self._owner=None\n   self._block.release()\n   \n def __exit__(self,t,v,tb):\n  self.release()\n  \n  \n  \n def _acquire_restore(self,state):\n  self._block.acquire()\n  self._count,self._owner=state\n  \n def _release_save(self):\n  if self._count ==0:\n   raise RuntimeError(\"cannot release un-acquired lock\")\n  count=self._count\n  self._count=0\n  owner=self._owner\n  self._owner=None\n  self._block.release()\n  return (count,owner)\n  \n def _is_owned(self):\n  return self._owner ==get_ident()\n  \n_PyRLock=_RLock\n\n\nclass Condition:\n ''\n\n\n\n\n\n\n\n\n \n \n def __init__(self,lock=None ):\n  if lock is None :\n   lock=RLock()\n  self._lock=lock\n  \n  self.acquire=lock.acquire\n  self.release=lock.release\n  \n  \n  \n  try :\n   self._release_save=lock._release_save\n  except AttributeError:\n   pass\n  try :\n   self._acquire_restore=lock._acquire_restore\n  except AttributeError:\n   pass\n  try :\n   self._is_owned=lock._is_owned\n  except AttributeError:\n   pass\n  self._waiters=_deque()\n  \n def _at_fork_reinit(self):\n  self._lock._at_fork_reinit()\n  self._waiters.clear()\n  \n def __enter__(self):\n  return self._lock.__enter__()\n  \n def __exit__(self,*args):\n  return self._lock.__exit__(*args)\n  \n def __repr__(self):\n  return \"<Condition(%s, %d)>\"%(self._lock,len(self._waiters))\n  \n def _release_save(self):\n  self._lock.release()\n  \n def _acquire_restore(self,x):\n  self._lock.acquire()\n  \n def _is_owned(self):\n \n \n  if self._lock.acquire(False ):\n   self._lock.release()\n   return False\n  else :\n   return True\n   \n def wait(self,timeout=None ):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  if not self._is_owned():\n   raise RuntimeError(\"cannot wait on un-acquired lock\")\n  waiter=_allocate_lock()\n  waiter.acquire()\n  self._waiters.append(waiter)\n  saved_state=self._release_save()\n  gotit=False\n  try :\n   if timeout is None :\n    waiter.acquire()\n    gotit=True\n   else :\n    if timeout >0:\n     gotit=waiter.acquire(True ,timeout)\n    else :\n     gotit=waiter.acquire(False )\n   return gotit\n  finally :\n   self._acquire_restore(saved_state)\n   if not gotit:\n    try :\n     self._waiters.remove(waiter)\n    except ValueError:\n     pass\n     \n def wait_for(self,predicate,timeout=None ):\n  ''\n\n\n\n\n\n  \n  endtime=None\n  waittime=timeout\n  result=predicate()\n  while not result:\n   if waittime is not None :\n    if endtime is None :\n     endtime=_time()+waittime\n    else :\n     waittime=endtime -_time()\n     if waittime <=0:\n      break\n   self.wait(waittime)\n   result=predicate()\n  return result\n  \n def notify(self,n=1):\n  ''\n\n\n\n\n\n\n\n  \n  if not self._is_owned():\n   raise RuntimeError(\"cannot notify on un-acquired lock\")\n  all_waiters=self._waiters\n  waiters_to_notify=_deque(_islice(all_waiters,n))\n  if not waiters_to_notify:\n   return\n  for waiter in waiters_to_notify:\n   waiter.release()\n   try :\n    all_waiters.remove(waiter)\n   except ValueError:\n    pass\n    \n def notify_all(self):\n  ''\n\n\n\n\n  \n  self.notify(len(self._waiters))\n  \n notifyAll=notify_all\n \n \nclass Semaphore:\n ''\n\n\n\n\n\n\n \n \n \n \n def __init__(self,value=1):\n  if value <0:\n   raise ValueError(\"semaphore initial value must be >= 0\")\n  self._cond=Condition(Lock())\n  self._value=value\n  \n def acquire(self,blocking=True ,timeout=None ):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  if not blocking and timeout is not None :\n   raise ValueError(\"can't specify timeout for non-blocking acquire\")\n  rc=False\n  endtime=None\n  with self._cond:\n   while self._value ==0:\n    if not blocking:\n     break\n    if timeout is not None :\n     if endtime is None :\n      endtime=_time()+timeout\n     else :\n      timeout=endtime -_time()\n      if timeout <=0:\n       break\n    self._cond.wait(timeout)\n   else :\n    self._value -=1\n    rc=True\n  return rc\n  \n __enter__=acquire\n \n def release(self,n=1):\n  ''\n\n\n\n\n  \n  if n <1:\n   raise ValueError('n must be one or more')\n  with self._cond:\n   self._value +=n\n   for i in range(n):\n    self._cond.notify()\n    \n def __exit__(self,t,v,tb):\n  self.release()\n  \n  \nclass BoundedSemaphore(Semaphore):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n def __init__(self,value=1):\n  Semaphore.__init__(self,value)\n  self._initial_value=value\n  \n def release(self,n=1):\n  ''\n\n\n\n\n\n\n\n  \n  if n <1:\n   raise ValueError('n must be one or more')\n  with self._cond:\n   if self._value+n >self._initial_value:\n    raise ValueError(\"Semaphore released too many times\")\n   self._value +=n\n   for i in range(n):\n    self._cond.notify()\n    \n    \nclass Event:\n ''\n\n\n\n\n\n \n \n \n \n def __init__(self):\n  self._cond=Condition(Lock())\n  self._flag=False\n  \n def _at_fork_reinit(self):\n \n  self._cond._at_fork_reinit()\n  \n def is_set(self):\n  ''\n  return self._flag\n  \n isSet=is_set\n \n def set(self):\n  ''\n\n\n\n\n  \n  with self._cond:\n   self._flag=True\n   self._cond.notify_all()\n   \n def clear(self):\n  ''\n\n\n\n\n  \n  with self._cond:\n   self._flag=False\n   \n def wait(self,timeout=None ):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  with self._cond:\n   signaled=self._flag\n   if not signaled:\n    signaled=self._cond.wait(timeout)\n   return signaled\n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \nclass Barrier:\n ''\n\n\n\n\n\n \n \n def __init__(self,parties,action=None ,timeout=None ):\n  ''\n\n\n\n\n\n\n  \n  self._cond=Condition(Lock())\n  self._action=action\n  self._timeout=timeout\n  self._parties=parties\n  self._state=0\n  self._count=0\n  \n def wait(self,timeout=None ):\n  ''\n\n\n\n\n\n\n  \n  if timeout is None :\n   timeout=self._timeout\n  with self._cond:\n   self._enter()\n   index=self._count\n   self._count +=1\n   try :\n    if index+1 ==self._parties:\n    \n     self._release()\n    else :\n    \n     self._wait(timeout)\n    return index\n   finally :\n    self._count -=1\n    \n    self._exit()\n    \n    \n    \n def _enter(self):\n  while self._state in (-1,1):\n  \n   self._cond.wait()\n   \n  if self._state <0:\n   raise BrokenBarrierError\n  assert self._state ==0\n  \n  \n  \n def _release(self):\n  try :\n   if self._action:\n    self._action()\n    \n   self._state=1\n   self._cond.notify_all()\n  except :\n  \n   self._break()\n   raise\n   \n   \n   \n def _wait(self,timeout):\n  if not self._cond.wait_for(lambda :self._state !=0,timeout):\n  \n   self._break()\n   raise BrokenBarrierError\n  if self._state <0:\n   raise BrokenBarrierError\n  assert self._state ==1\n  \n  \n  \n def _exit(self):\n  if self._count ==0:\n   if self._state in (-1,1):\n   \n    self._state=0\n    self._cond.notify_all()\n    \n def reset(self):\n  ''\n\n\n\n\n  \n  with self._cond:\n   if self._count >0:\n    if self._state ==0:\n    \n     self._state=-1\n    elif self._state ==-2:\n    \n    \n     self._state=-1\n   else :\n    self._state=0\n   self._cond.notify_all()\n   \n def abort(self):\n  ''\n\n\n\n\n  \n  with self._cond:\n   self._break()\n   \n def _break(self):\n \n \n  self._state=-2\n  self._cond.notify_all()\n  \n @property\n def parties(self):\n  ''\n  return self._parties\n  \n @property\n def n_waiting(self):\n  ''\n  \n  \n  if self._state ==0:\n   return self._count\n  return 0\n  \n @property\n def broken(self):\n  ''\n  return self._state ==-2\n  \n  \nclass BrokenBarrierError(RuntimeError):\n pass\n \n \n \n_counter=_count().__next__\n_counter()\ndef _newname(template=\"Thread-%d\"):\n return template %_counter()\n \n \n_active_limbo_lock=_allocate_lock()\n_active={}\n_limbo={}\n_dangling=WeakSet()\n\n\n\n_shutdown_locks_lock=_allocate_lock()\n_shutdown_locks=set()\n\n\n\nclass Thread:\n ''\n\n\n\n\n\n \n \n _initialized=False\n \n def __init__(self,group=None ,target=None ,name=None ,\n args=(),kwargs=None ,*,daemon=None ):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  assert group is None ,\"group argument must be None for now\"\n  if kwargs is None :\n   kwargs={}\n  self._target=target\n  self._name=str(name or _newname())\n  self._args=args\n  self._kwargs=kwargs\n  if daemon is not None :\n   self._daemonic=daemon\n  else :\n   self._daemonic=current_thread().daemon\n  self._ident=None\n  if _HAVE_THREAD_NATIVE_ID:\n   self._native_id=None\n  self._tstate_lock=None\n  self._started=Event()\n  self._is_stopped=False\n  self._initialized=True\n  \n  self._stderr=_sys.stderr\n  self._invoke_excepthook=_make_invoke_excepthook()\n  \n  _dangling.add(self)\n  \n def _reset_internal_locks(self,is_alive):\n \n \n  self._started._at_fork_reinit()\n  if is_alive:\n   self._tstate_lock._at_fork_reinit()\n   self._tstate_lock.acquire()\n  else :\n  \n  \n   self._is_stopped=True\n   self._tstate_lock=None\n   \n def __repr__(self):\n  assert self._initialized,\"Thread.__init__() was not called\"\n  status=\"initial\"\n  if self._started.is_set():\n   status=\"started\"\n  self.is_alive()\n  if self._is_stopped:\n   status=\"stopped\"\n  if self._daemonic:\n   status +=\" daemon\"\n  if self._ident is not None :\n   status +=\" %s\"%self._ident\n  return \"<%s(%s, %s)>\"%(self.__class__.__name__,self._name,status)\n  \n def start(self):\n  ''\n\n\n\n\n\n\n\n  \n  if not self._initialized:\n   raise RuntimeError(\"thread.__init__() not called\")\n   \n  if self._started.is_set():\n   raise RuntimeError(\"threads can only be started once\")\n   \n  with _active_limbo_lock:\n   _limbo[self]=self\n  try :\n   _start_new_thread(self._bootstrap,())\n  except Exception:\n   with _active_limbo_lock:\n    del _limbo[self]\n   raise\n  self._started.wait()\n  \n def run(self):\n  ''\n\n\n\n\n\n\n  \n  try :\n   if self._target:\n    self._target(*self._args,**self._kwargs)\n  finally :\n  \n  \n   del self._target,self._args,self._kwargs\n   \n def _bootstrap(self):\n \n \n \n \n \n \n \n \n \n \n \n \n  try :\n   self._bootstrap_inner()\n  except :\n   if self._daemonic and _sys is None :\n    return\n   raise\n   \n def _set_ident(self):\n  self._ident=get_ident()\n  \n if _HAVE_THREAD_NATIVE_ID:\n  def _set_native_id(self):\n   self._native_id=get_native_id()\n   \n def _set_tstate_lock(self):\n  ''\n\n\n  \n  self._tstate_lock=_set_sentinel()\n  self._tstate_lock.acquire()\n  \n  if not self.daemon:\n   with _shutdown_locks_lock:\n    _shutdown_locks.add(self._tstate_lock)\n    \n def _bootstrap_inner(self):\n  try :\n   self._set_ident()\n   self._set_tstate_lock()\n   if _HAVE_THREAD_NATIVE_ID:\n    self._set_native_id()\n   self._started.set()\n   with _active_limbo_lock:\n    _active[self._ident]=self\n    del _limbo[self]\n    \n   if _trace_hook:\n    _sys.settrace(_trace_hook)\n   if _profile_hook:\n    _sys.setprofile(_profile_hook)\n    \n   try :\n    self.run()\n   except :\n    self._invoke_excepthook(self)\n  finally :\n   with _active_limbo_lock:\n    try :\n    \n    \n     del _active[get_ident()]\n    except :\n     pass\n     \n def _stop(self):\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n  lock=self._tstate_lock\n  if lock is not None :\n   assert not lock.locked()\n  self._is_stopped=True\n  self._tstate_lock=None\n  if not self.daemon:\n   with _shutdown_locks_lock:\n    _shutdown_locks.discard(lock)\n    \n def _delete(self):\n  ''\n  with _active_limbo_lock:\n   del _active[get_ident()]\n   \n   \n   \n   \n   \n def join(self,timeout=None ):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  if not self._initialized:\n   raise RuntimeError(\"Thread.__init__() not called\")\n  if not self._started.is_set():\n   raise RuntimeError(\"cannot join thread before it is started\")\n  if self is current_thread():\n   raise RuntimeError(\"cannot join current thread\")\n   \n  if timeout is None :\n   self._wait_for_tstate_lock()\n  else :\n  \n  \n   self._wait_for_tstate_lock(timeout=max(timeout,0))\n   \n def _wait_for_tstate_lock(self,block=True ,timeout=-1):\n \n \n \n \n \n \n  lock=self._tstate_lock\n  if lock is None :\n   assert self._is_stopped\n  elif lock.acquire(block,timeout):\n   lock.release()\n   self._stop()\n   \n @property\n def name(self):\n  ''\n\n\n\n\n  \n  assert self._initialized,\"Thread.__init__() not called\"\n  return self._name\n  \n @name.setter\n def name(self,name):\n  assert self._initialized,\"Thread.__init__() not called\"\n  self._name=str(name)\n  \n @property\n def ident(self):\n  ''\n\n\n\n\n\n  \n  assert self._initialized,\"Thread.__init__() not called\"\n  return self._ident\n  \n if _HAVE_THREAD_NATIVE_ID:\n  @property\n  def native_id(self):\n   ''\n\n\n\n\n   \n   assert self._initialized,\"Thread.__init__() not called\"\n   return self._native_id\n   \n def is_alive(self):\n  ''\n\n\n\n\n\n  \n  assert self._initialized,\"Thread.__init__() not called\"\n  if self._is_stopped or not self._started.is_set():\n   return False\n  self._wait_for_tstate_lock(False )\n  return not self._is_stopped\n  \n @property\n def daemon(self):\n  ''\n\n\n\n\n\n\n\n\n  \n  assert self._initialized,\"Thread.__init__() not called\"\n  return self._daemonic\n  \n @daemon.setter\n def daemon(self,daemonic):\n  if not self._initialized:\n   raise RuntimeError(\"Thread.__init__() not called\")\n  if self._started.is_set():\n   raise RuntimeError(\"cannot set daemon status of active thread\")\n  self._daemonic=daemonic\n  \n def isDaemon(self):\n  return self.daemon\n  \n def setDaemon(self,daemonic):\n  self.daemon=daemonic\n  \n def getName(self):\n  return self.name\n  \n def setName(self,name):\n  self.name=name\n  \n  \ntry :\n from _thread import (_excepthook as excepthook,\n _ExceptHookArgs as ExceptHookArgs)\nexcept ImportError:\n\n from traceback import print_exception as _print_exception\n from collections import namedtuple\n \n _ExceptHookArgs=namedtuple(\n 'ExceptHookArgs',\n 'exc_type exc_value exc_traceback thread')\n \n def ExceptHookArgs(args):\n  return _ExceptHookArgs(*args)\n  \n def excepthook(args,/):\n  ''\n\n  \n  if args.exc_type ==SystemExit:\n  \n   return\n   \n  if _sys is not None and _sys.stderr is not None :\n   stderr=_sys.stderr\n  elif args.thread is not None :\n   stderr=args.thread._stderr\n   if stderr is None :\n   \n   \n    return\n  else :\n  \n   return\n   \n  if args.thread is not None :\n   name=args.thread.name\n  else :\n   name=get_ident()\n  print(f\"Exception in thread {name}:\",\n  file=stderr,flush=True )\n  _print_exception(args.exc_type,args.exc_value,args.exc_traceback,\n  file=stderr)\n  stderr.flush()\n  \n  \ndef _make_invoke_excepthook():\n\n\n\n\n old_excepthook=excepthook\n old_sys_excepthook=_sys.excepthook\n if old_excepthook is None :\n  raise RuntimeError(\"threading.excepthook is None\")\n if old_sys_excepthook is None :\n  raise RuntimeError(\"sys.excepthook is None\")\n  \n sys_exc_info=_sys.exc_info\n local_print=print\n local_sys=_sys\n \n def invoke_excepthook(thread):\n  global excepthook\n  try :\n   hook=excepthook\n   if hook is None :\n    hook=old_excepthook\n    \n   args=ExceptHookArgs([*sys_exc_info(),thread])\n   \n   hook(args)\n  except Exception as exc:\n   exc.__suppress_context__=True\n   del exc\n   \n   if local_sys is not None and local_sys.stderr is not None :\n    stderr=local_sys.stderr\n   else :\n    stderr=thread._stderr\n    \n   local_print(\"Exception in threading.excepthook:\",\n   file=stderr,flush=True )\n   \n   if local_sys is not None and local_sys.excepthook is not None :\n    sys_excepthook=local_sys.excepthook\n   else :\n    sys_excepthook=old_sys_excepthook\n    \n   sys_excepthook(*sys_exc_info())\n  finally :\n  \n   args=None\n   \n return invoke_excepthook\n \n \n \n \nclass Timer(Thread):\n ''\n\n\n\n\n\n \n \n def __init__(self,interval,function,args=None ,kwargs=None ):\n  Thread.__init__(self)\n  self.interval=interval\n  self.function=function\n  self.args=args if args is not None else []\n  self.kwargs=kwargs if kwargs is not None else {}\n  self.finished=Event()\n  \n def cancel(self):\n  ''\n  self.finished.set()\n  \n def run(self):\n  self.finished.wait(self.interval)\n  if not self.finished.is_set():\n   self.function(*self.args,**self.kwargs)\n  self.finished.set()\n  \n  \n  \n  \nclass _MainThread(Thread):\n\n def __init__(self):\n  Thread.__init__(self,name=\"MainThread\",daemon=False )\n  self._set_tstate_lock()\n  self._started.set()\n  self._set_ident()\n  if _HAVE_THREAD_NATIVE_ID:\n   self._set_native_id()\n  with _active_limbo_lock:\n   _active[self._ident]=self\n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \nclass _DummyThread(Thread):\n\n def __init__(self):\n  Thread.__init__(self,name=_newname(\"Dummy-%d\"),daemon=True )\n  \n  self._started.set()\n  self._set_ident()\n  if _HAVE_THREAD_NATIVE_ID:\n   self._set_native_id()\n  with _active_limbo_lock:\n   _active[self._ident]=self\n   \n def _stop(self):\n  pass\n  \n def is_alive(self):\n  assert not self._is_stopped and self._started.is_set()\n  return True\n  \n def join(self,timeout=None ):\n  assert False ,\"cannot join a dummy thread\"\n  \n  \n  \n  \ndef current_thread():\n ''\n\n\n\n\n \n try :\n  return _active[get_ident()]\n except KeyError:\n  return _DummyThread()\n  \ncurrentThread=current_thread\n\ndef active_count():\n ''\n\n\n\n\n \n with _active_limbo_lock:\n  return len(_active)+len(_limbo)\n  \nactiveCount=active_count\n\ndef _enumerate():\n\n return list(_active.values())+list(_limbo.values())\n \ndef enumerate():\n ''\n\n\n\n\n\n \n with _active_limbo_lock:\n  return list(_active.values())+list(_limbo.values())\n  \n  \n_threading_atexits=[]\n_SHUTTING_DOWN=False\n\ndef _register_atexit(func,*arg,**kwargs):\n ''\n\n\n\n\n\n\n\n \n if _SHUTTING_DOWN:\n  raise RuntimeError(\"can't register atexit after shutdown\")\n  \n call=functools.partial(func,*arg,**kwargs)\n _threading_atexits.append(call)\n \n \nfrom _thread import stack_size\n\n\n\n\n\n_main_thread=_MainThread()\n\ndef _shutdown():\n ''\n\n \n \n \n \n \n \n if _main_thread._is_stopped:\n \n  return\n  \n global _SHUTTING_DOWN\n _SHUTTING_DOWN=True\n \n tlock=_main_thread._tstate_lock\n \n \n assert tlock is not None\n assert tlock.locked()\n tlock.release()\n _main_thread._stop()\n \n \n \n for atexit_call in reversed(_threading_atexits):\n  atexit_call()\n  \n  \n while True :\n  with _shutdown_locks_lock:\n   locks=list(_shutdown_locks)\n   _shutdown_locks.clear()\n   \n  if not locks:\n   break\n   \n  for lock in locks:\n  \n   lock.acquire()\n   lock.release()\n   \n   \n   \n   \n   \ndef main_thread():\n ''\n\n\n\n \n return _main_thread\n \n \n \n \ntry :\n from _thread import _local as local\nexcept ImportError:\n from _threading_local import local\n \n \ndef _after_fork():\n ''\n\n \n \n \n global _active_limbo_lock,_main_thread\n global _shutdown_locks_lock,_shutdown_locks\n _active_limbo_lock=_allocate_lock()\n \n \n new_active={}\n \n try :\n  current=_active[get_ident()]\n except KeyError:\n \n \n \n  current=_MainThread()\n  \n _main_thread=current\n \n \n _shutdown_locks_lock=_allocate_lock()\n _shutdown_locks=set()\n \n with _active_limbo_lock:\n \n \n  threads=set(_enumerate())\n  threads.update(_dangling)\n  for thread in threads:\n  \n  \n   if thread is current:\n   \n   \n    thread._reset_internal_locks(True )\n    ident=get_ident()\n    thread._ident=ident\n    new_active[ident]=thread\n   else :\n   \n    thread._reset_internal_locks(False )\n    thread._stop()\n    \n  _limbo.clear()\n  _active.clear()\n  _active.update(new_active)\n  assert len(_active)==1\n  \n  \nif hasattr(_os,\"register_at_fork\"):\n _os.register_at_fork(after_in_child=_after_fork)\n", ["_collections", "_thread", "_threading_local", "_weakrefset", "collections", "functools", "itertools", "os", "sys", "time", "traceback"]],
     "time": [".py", "import _locale\nimport javascript\n\n\ndate=javascript.Date.new\nnow=javascript.Date.now\n\n\n\n\n\n\n\n_STRUCT_TM_ITEMS=9\n\n\n\n\n\ndef _get_day_of_year(arg):\n ''\n\n\n\n\n\n\n\n\n\n \n ml=[31,28,31,30,31,30,31,31,30,31,30,31]\n if arg[0]%4 ==0:\n  ml[1]+=1\n i=1\n yday=0\n while i <arg[1]:\n  yday +=ml[i -1]\n  i +=1\n yday +=arg[2]\n return yday\n \ndef _get_week_of_year(arg):\n ''\n\n\n\n\n\n\n\n\n\n\n \n d1=date(arg[0],arg[1]-1,arg[2])\n d0=date(arg[0],0,1)\n firstday=d0.getDay()\n if firstday ==0:\n  firstday=7\n firstweek=8 -firstday\n doy=arg[7]\n if firstday !=1:\n  doy=doy -firstweek\n if doy %7 ==0:\n  week_number=doy //7\n else :\n  week_number=doy //7+1\n return week_number\n \ndef _check_struct_time(t):\n mm=t[1]\n if mm ==0:\n  mm=1\n if -1 >mm >13:\n  raise ValueError(\"month out of range\")\n  \n dd=t[2]\n if dd ==0:dd=1\n if -1 >dd >32:\n  raise ValueError(\"day of month out of range\")\n  \n hh=t[3]\n if -1 >hh >24:\n  raise ValueError(\"hour out of range\")\n  \n minu=t[4]\n if -1 >minu >60:\n  raise ValueError(\"minute out of range\")\n  \n ss=t[5]\n if -1 >ss >62:\n  raise ValueError(\"seconds out of range\")\n  \n wd=t[6]%7\n if wd <-2:\n  raise ValueError(\"day of week out of range\")\n  \n dy=t[7]\n if dy ==0:dy=1\n if -1 >dy >367:\n  raise ValueError(\"day of year out of range\")\n  \n return t[0],mm,dd,hh,minu,ss,wd,dy,t[-1]\n \n \ndef _is_dst(secs=None ):\n ''\n d=date()\n if secs is not None :\n  d=date(secs *1000)\n  \n  \n  \n jan=date(d.getFullYear(),0,1)\n jul=date(d.getFullYear(),6,1)\n dst=int(d.getTimezoneOffset()<max(abs(jan.getTimezoneOffset()),\n abs(jul.getTimezoneOffset())))\n return dst\n \ndef _get_tzname():\n ''\n d=date()\n d=d.toTimeString()\n try :\n  d=d.split('(')[1].split(')')[0]\n  return (d,'NotAvailable')\n except :\n  return ('','')\n  \ndef _set_altzone():\n d=date()\n jan=date(d.getFullYear(),0,1)\n jul=date(d.getFullYear(),6,1)\n result=timezone -(jan.getTimezoneOffset()-jul.getTimezoneOffset())*60\n return result\n \ndef _check_input(t):\n if t and isinstance(t,struct_time)and len(t.args)==9:\n  t=t.args\n elif t and isinstance(t,tuple)and len(t)==9:\n  t=t\n elif t and isinstance(t,struct_time)and len(t.args)!=9:\n  raise TypeError(\"function takes exactly 9 arguments ({} given)\".format(len(t.args)))\n elif t and isinstance(t,tuple)and len(t)!=9:\n  raise TypeError(\"function takes exactly 9 arguments ({} given)\".format(len(t)))\n elif t and not isinstance(t,(tuple,struct_time)):\n  raise TypeError(\"Tuple or struct_time argument required\")\n else :\n  t=localtime().args\n return t\n \n \n \n \n \ndaylight=_is_dst()\ntimezone=date().getTimezoneOffset()*60\ntzname=_get_tzname()\naltzone=_set_altzone()if daylight else timezone\n\n\ndef asctime(t=None ):\n weekdays={i:day for (i,day)in\n enumerate(\"Mon Tue Wed Thu Fri Sat Sun\".split())\n }\n \n months={i+1:month for (i,month)in\n enumerate(\"Jan Fev Mar Apr May Jun Jul Aug Sep Oct Nov Dec\".split())\n }\n \n t=_check_input(t)\n t=_check_struct_time(t)\n \n result=\"%s %s %2d %02d:%02d:%02d %d\"%(\n weekdays[t[6]],months[t[1]],t[2],t[3],t[4],t[5],t[0])\n return result\n \ndef ctime(timestamp=None ):\n return asctime(localtime(timestamp))\n \ndef gmtime(secs=None ):\n d=date()\n if secs is not None :\n  d=date(secs *1000)\n wday=d.getUTCDay()-1 if d.getUTCDay()-1 >=0 else 6\n tmp=struct_time([d.getUTCFullYear(),\n d.getUTCMonth()+1,d.getUTCDate(),\n d.getUTCHours(),d.getUTCMinutes(),d.getUTCSeconds(),\n wday,0,0])\n tmp.args[7]=_get_day_of_year(tmp.args)\n return tmp\n \ndef localtime(secs=None ):\n d=date()\n if secs is not None :\n  d=date(secs *1000)\n dst=_is_dst(secs)\n wday=d.getDay()-1 if d.getDay()-1 >=0 else 6\n tmp=struct_time([d.getFullYear(),\n d.getMonth()+1,d.getDate(),\n d.getHours(),d.getMinutes(),d.getSeconds(),\n wday,0,dst])\n tmp.args[7]=_get_day_of_year(tmp.args)\n return tmp\n \ndef mktime(t):\n if isinstance(t,struct_time):\n  d1=date(t.tm_year,t.tm_mon -1,t.tm_mday,\n  t.tm_hour,t.tm_min,t.tm_sec,0).getTime()\n elif isinstance(t,tuple):\n  d1=date(t[0],t[1]-1,t[2],t[3],t[4],t[5],0).getTime()\n else :\n  raise ValueError(\"Tuple or struct_time argument required\")\n d2=date(0).getTime()\n return (d1 -d2)/1000.\n \ndef monotonic():\n return now()/1000.\n \ndef perf_counter():\n return now()/1000.\n \ndef process_time():\n return now()/1000.\n \ndef time():\n return float(date().getTime()/1000)\n \ndef sleep(secs):\n ''\n\n \n raise NotImplementedError(\"Blocking functions like time.sleep() are not \"\n \"supported in the browser. Use functions in module browser.timer \"\n \"instead.\")\n \ndef strftime(_format,t=None ):\n def ns(t,nb):\n \n  res=str(t)\n  while len(res)<nb:\n   res='0'+res\n  return res\n  \n t=_check_input(t)\n t=_check_struct_time(t)\n \n YY=ns(t[0],4)\n yy=ns(t[0],4)[2:]\n mm=ns(t[1],2)\n dd=ns(t[2],2)\n HH=t[3]\n HH24=ns(HH,2)\n HH12=ns(HH %12,2)\n if HH12 ==0:\n  HH12=12\n AMPM='AM'if 0 <=HH <12 else 'PM'\n MM=ns(t[4],2)\n SS=ns(t[5],2)\n DoY=ns(t[7],3)\n w=t[6]+1 if t[6]<6 else 0\n W=ns(_get_week_of_year(t),2)\n \n abb_weekdays=['Sun','Mon','Tue','Wed','Thu','Fri','Sat']\n full_weekdays=['Sunday','Monday','Tuesday','Wednesday',\n 'Thursday','Friday','Saturday']\n abb_months=['Jan','Feb','Mar','Apr','May','Jun',\n 'Jul','Aug','Sep','Oct','Nov','Dec']\n full_months=['January','February','March','April','May','June',\n 'July','August','September','October','November','December']\n \n res=_format\n if __BRYTHON__.locale ==\"C\":\n  res=res.replace(\"%c\",abb_weekdays[w]+' '+abb_months[int(mm)-1]+\n  ' '+dd+' '+HH24+':'+MM+':'+SS+' '+YY)\n  res=res.replace(\"%x\",mm+'/'+dd+'/'+yy)\n  res=res.replace(\"%X\",HH24+':'+MM+':'+SS)\n else :\n  formatter=_locale._date_format\n  c_format=formatter(\"x\")+\" \"+formatter(\"X\")\n  res=res.replace(\"%c\",c_format)\n  x_format=formatter(\"x\")\n  res=res.replace(\"%x\",x_format)\n  X_format=formatter(\"X\")\n  res=res.replace(\"%X\",X_format)\n  \n res=res.replace(\"%H\",HH24)\n res=res.replace(\"%I\",HH12)\n res=res.replace(\"%i\",HH12.lstrip(\"0\"))\n res=res.replace(\"%p\",AMPM)\n res=res.replace(\"%M\",MM)\n res=res.replace(\"%S\",SS)\n res=res.replace(\"%Y\",YY)\n res=res.replace(\"%y\",yy)\n res=res.replace(\"%m\",mm)\n res=res.replace(\"%d\",dd)\n res=res.replace(\"%a\",abb_weekdays[w])\n res=res.replace(\"%A\",full_weekdays[w])\n res=res.replace(\"%b\",abb_months[int(mm)-1])\n res=res.replace(\"%B\",full_months[int(mm)-1])\n res=res.replace(\"%j\",DoY)\n res=res.replace(\"%w\",str(w))\n res=res.replace(\"%W\",W)\n res=res.replace(\"%%\",'%')\n \n return res\n \nclass struct_time:\n\n def __init__(self,*args,**kw):\n \n  time_tuple=args[0]\n  if len(time_tuple)!=9:\n   raise TypeError(\"time.struct_time() takes a 9-sequence (%s-sequence given)\"%len(args))\n   \n  self.args=time_tuple\n  \n @property\n def tm_year(self):\n  return self.args[0]\n  \n @property\n def tm_mon(self):\n  return self.args[1]\n  \n @property\n def tm_mday(self):\n  return self.args[2]\n  \n @property\n def tm_hour(self):\n  return self.args[3]\n  \n @property\n def tm_min(self):\n  return self.args[4]\n  \n @property\n def tm_sec(self):\n  return self.args[5]\n  \n @property\n def tm_wday(self):\n  return self.args[6]\n  \n @property\n def tm_yday(self):\n  return self.args[7]\n  \n @property\n def tm_isdst(self):\n  return self.args[8]\n  \n def __eq__(self,other):\n  return self.args ==other.args\n  \n def __getitem__(self,i):\n  return self.args[i]\n  \n def __iter__(self):\n  return iter(self.args)\n  \n def __reduce_ex__(self,protocol):\n  return (struct_time,(self.args,{}))\n  \n def __repr__(self):\n  return (\"time.structime(tm_year={}, tm_mon={}, tm_day={}, \"+\\\n  \"tm_hour={}, tm_min={}, tm_sec={}, tm_wday={}, \"+\\\n  \"tm_yday={}, tm_isdst={})\").format(*self.args)\n  \n def __str__(self):\n  return self.__repr__()\n  \ndef to_struct_time(*arg):\n arg=list(arg)\n \n \n ml=[31,28,31,30,31,30,31,31,30,31,30,31]\n if arg[0]%4 ==0:\n  ml[1]+=1\n  \n i=1\n yday=0\n while i <arg[1]:\n  yday +=ml[i -1]\n  i +=1\n yday +=arg[2]\n arg.append(yday)\n arg.append(-1)\n return struct_time(tuple(arg))\n \ndef wait(secs):\n\n pass\n \ndef strptime(string,_format):\n import _strptime\n return _strptime._strptime_datetime(to_struct_time,string,_format)\n \n \n \n_clock_msg=\"\"\"Browser cannot access CPU. See '%s'\"\"\"\ndef _clock_xx(url):\n raise NotImplementedError(_clock_msg %url)\nclock=time\nclock_getres=lambda :_clock_xx(\"https://docs.python.org/3/library/time.html#time.clock_getres\")\nclock_gettime=lambda :_clock_xx(\"https://docs.python.org/3/library/time.html#time.clock_gettime\")\nclock_settime=lambda :_clock_xx(\"https://docs.python.org/3/library/time.html#time.clock_settime\")\nCLOCK_HIGHRES=_clock_msg %\"https://docs.python.org/3/library/time.html#time.CLOCK_HIGHRES\"\nCLOCK_MONOTONIC=_clock_msg %\"https://docs.python.org/3/library/time.html#time.CLOCK_MONOTONIC\"\nCLOCK_MONOTONIC_RAW=_clock_msg %\"https://docs.python.org/3/library/time.html#time.CLOCK_MONOTONIC_RAW\"\nCLOCK_PROCESS_CPUTIME_ID=_clock_msg %\"https://docs.python.org/3/library/time.html#time.CLOCK_PROCESS_CPUTIME_ID\"\nCLOCK_REALTIME=_clock_msg %\"https://docs.python.org/3/library/time.html#time.CLOCK_REALTIME\"\nCLOCK_THREAD_CPUTIME_ID=_clock_msg %\"https://docs.python.org/3/library/time.html#time.CLOCK_THREAD_CPUTIME_ID\"\n\nclass ClockInfo:\n\n def __init__(self,*kw):\n  for key,value in kw.items():\n   setattr(self,key,value)\n   \ndef get_clock_info(cl):\n\n if cl =='monotonic':\n  return ClockInfo(adjustable=False ,\n  implementation='window.performance.now',\n  monotonic=True ,\n  resolution=0.000001)\n elif cl =='perf_counter'or cl =='process_time':\n  return ClockInfo(adjustable=False ,\n  implementation='date.getTime',\n  monotonic=False ,\n  resolution=0.001)\n else :\n  _clock_xx(\"https://docs.python.org/3/library/time.html#time.get_clock_info\")\n  \ndef tzset():\n pass\n", ["_locale", "_strptime", "javascript"]],
     "timeit": [".py", "#! /usr/bin/env python3\n\n\"\"\"Tool for measuring execution time of small code snippets.\n\nThis module avoids a number of common traps for measuring execution\ntimes.  See also Tim Peters' introduction to the Algorithms chapter in\nthe Python Cookbook, published by O'Reilly.\n\nLibrary usage: see the Timer class.\n\nCommand line usage:\n    python timeit.py [-n N] [-r N] [-s S] [-p] [-h] [--] [statement]\n\nOptions:\n  -n/--number N: how many times to execute 'statement' (default: see below)\n  -r/--repeat N: how many times to repeat the timer (default 5)\n  -s/--setup S: statement to be executed once initially (default 'pass').\n                Execution time of this setup statement is NOT timed.\n  -p/--process: use time.process_time() (default is time.perf_counter())\n  -v/--verbose: print raw timing results; repeat for more digits precision\n  -u/--unit: set the output time unit (nsec, usec, msec, or sec)\n  -h/--help: print this usage message and exit\n  --: separate options from statement, use when statement starts with -\n  statement: statement to be timed (default 'pass')\n\nA multi-line statement may be given by specifying each line as a\nseparate argument; indented lines are possible by enclosing an\nargument in quotes and using leading spaces.  Multiple -s options are\ntreated similarly.\n\nIf -n is not given, a suitable number of loops is calculated by trying\nincreasing numbers from the sequence 1, 2, 5, 10, 20, 50, ... until the\ntotal time is at least 0.2 seconds.\n\nNote: there is a certain baseline overhead associated with executing a\npass statement.  It differs between versions.  The code here doesn't try\nto hide it, but you should be aware of it.  The baseline overhead can be\nmeasured by invoking the program without arguments.\n\nClasses:\n\n    Timer\n\nFunctions:\n\n    timeit(string, string) -> float\n    repeat(string, string) -> list\n    default_timer() -> float\n\n\"\"\"\n\nimport gc\nimport sys\nimport time\nimport itertools\n\n__all__=[\"Timer\",\"timeit\",\"repeat\",\"default_timer\"]\n\ndummy_src_name=\"<timeit-src>\"\ndefault_number=1000000\ndefault_repeat=5\ndefault_timer=time.perf_counter\n\n_globals=globals\n\n\n\n\ntemplate=\"\"\"\ndef inner(_it, _timer{init}):\n    {setup}\n    _t0 = _timer()\n    for _i in _it:\n        {stmt}\n    _t1 = _timer()\n    return _t1 - _t0\n\"\"\"\n\ndef reindent(src,indent):\n ''\n return src.replace(\"\\n\",\"\\n\"+\" \"*indent)\n \nclass Timer:\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n def __init__(self,stmt=\"pass\",setup=\"pass\",timer=default_timer,\n globals=None ):\n  ''\n  self.timer=timer\n  local_ns={}\n  global_ns=_globals()if globals is None else globals\n  init=''\n  if isinstance(setup,str):\n  \n   compile(setup,dummy_src_name,\"exec\")\n   stmtprefix=setup+'\\n'\n   setup=reindent(setup,4)\n  elif callable(setup):\n   local_ns['_setup']=setup\n   init +=', _setup=_setup'\n   stmtprefix=''\n   setup='_setup()'\n  else :\n   raise ValueError(\"setup is neither a string nor callable\")\n  if isinstance(stmt,str):\n  \n   compile(stmtprefix+stmt,dummy_src_name,\"exec\")\n   stmt=reindent(stmt,8)\n  elif callable(stmt):\n   local_ns['_stmt']=stmt\n   init +=', _stmt=_stmt'\n   stmt='_stmt()'\n  else :\n   raise ValueError(\"stmt is neither a string nor callable\")\n  src=template.format(stmt=stmt,setup=setup,init=init)\n  self.src=src\n  code=compile(src,dummy_src_name,\"exec\")\n  exec(code,global_ns,local_ns)\n  self.inner=local_ns[\"inner\"]\n  \n def print_exc(self,file=None ):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  import linecache,traceback\n  if self.src is not None :\n   linecache.cache[dummy_src_name]=(len(self.src),\n   None ,\n   self.src.split(\"\\n\"),\n   dummy_src_name)\n   \n   \n  traceback.print_exc(file=file)\n  \n def timeit(self,number=default_number):\n  ''\n\n\n\n\n\n\n\n  \n  it=itertools.repeat(None ,number)\n  gcold=gc.isenabled()\n  gc.disable()\n  try :\n   timing=self.inner(it,self.timer)\n  finally :\n   if gcold:\n    gc.enable()\n  return timing\n  \n def repeat(self,repeat=default_repeat,number=default_number):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  r=[]\n  for i in range(repeat):\n   t=self.timeit(number)\n   r.append(t)\n  return r\n  \n def autorange(self,callback=None ):\n  ''\n\n\n\n\n\n\n\n  \n  i=1\n  while True :\n   for j in 1,2,5:\n    number=i *j\n    time_taken=self.timeit(number)\n    if callback:\n     callback(number,time_taken)\n    if time_taken >=0.2:\n     return (number,time_taken)\n   i *=10\n   \ndef timeit(stmt=\"pass\",setup=\"pass\",timer=default_timer,\nnumber=default_number,globals=None ):\n ''\n return Timer(stmt,setup,timer,globals).timeit(number)\n \ndef repeat(stmt=\"pass\",setup=\"pass\",timer=default_timer,\nrepeat=default_repeat,number=default_number,globals=None ):\n ''\n return Timer(stmt,setup,timer,globals).repeat(repeat,number)\n \ndef main(args=None ,*,_wrap_timer=None ):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n if args is None :\n  args=sys.argv[1:]\n import getopt\n try :\n  opts,args=getopt.getopt(args,\"n:u:s:r:tcpvh\",\n  [\"number=\",\"setup=\",\"repeat=\",\n  \"time\",\"clock\",\"process\",\n  \"verbose\",\"unit=\",\"help\"])\n except getopt.error as err:\n  print(err)\n  print(\"use -h/--help for command line help\")\n  return 2\n  \n timer=default_timer\n stmt=\"\\n\".join(args)or \"pass\"\n number=0\n setup=[]\n repeat=default_repeat\n verbose=0\n time_unit=None\n units={\"nsec\":1e-9,\"usec\":1e-6,\"msec\":1e-3,\"sec\":1.0}\n precision=3\n for o,a in opts:\n  if o in (\"-n\",\"--number\"):\n   number=int(a)\n  if o in (\"-s\",\"--setup\"):\n   setup.append(a)\n  if o in (\"-u\",\"--unit\"):\n   if a in units:\n    time_unit=a\n   else :\n    print(\"Unrecognized unit. Please select nsec, usec, msec, or sec.\",\n    file=sys.stderr)\n    return 2\n  if o in (\"-r\",\"--repeat\"):\n   repeat=int(a)\n   if repeat <=0:\n    repeat=1\n  if o in (\"-p\",\"--process\"):\n   timer=time.process_time\n  if o in (\"-v\",\"--verbose\"):\n   if verbose:\n    precision +=1\n   verbose +=1\n  if o in (\"-h\",\"--help\"):\n   print(__doc__,end=' ')\n   return 0\n setup=\"\\n\".join(setup)or \"pass\"\n \n \n \n \n import os\n sys.path.insert(0,os.curdir)\n if _wrap_timer is not None :\n  timer=_wrap_timer(timer)\n  \n t=Timer(stmt,setup,timer)\n if number ==0:\n \n  callback=None\n  if verbose:\n   def callback(number,time_taken):\n    msg=\"{num} loop{s} -> {secs:.{prec}g} secs\"\n    plural=(number !=1)\n    print(msg.format(num=number,s='s'if plural else '',\n    secs=time_taken,prec=precision))\n  try :\n   number,_=t.autorange(callback)\n  except :\n   t.print_exc()\n   return 1\n   \n  if verbose:\n   print()\n   \n try :\n  raw_timings=t.repeat(repeat,number)\n except :\n  t.print_exc()\n  return 1\n  \n def format_time(dt):\n  unit=time_unit\n  \n  if unit is not None :\n   scale=units[unit]\n  else :\n   scales=[(scale,unit)for unit,scale in units.items()]\n   scales.sort(reverse=True )\n   for scale,unit in scales:\n    if dt >=scale:\n     break\n     \n  return \"%.*g %s\"%(precision,dt /scale,unit)\n  \n if verbose:\n  print(\"raw times: %s\"%\", \".join(map(format_time,raw_timings)))\n  print()\n timings=[dt /number for dt in raw_timings]\n \n best=min(timings)\n print(\"%d loop%s, best of %d: %s per loop\"\n %(number,'s'if number !=1 else '',\n repeat,format_time(best)))\n \n best=min(timings)\n worst=max(timings)\n if worst >=best *4:\n  import warnings\n  warnings.warn_explicit(\"The test results are likely unreliable. \"\n  \"The worst time (%s) was more than four times \"\n  \"slower than the best time (%s).\"\n  %(format_time(worst),format_time(best)),\n  UserWarning,'',0)\n return None\n \nif __name__ ==\"__main__\":\n sys.exit(main())\n", ["gc", "getopt", "itertools", "linecache", "os", "sys", "time", "traceback", "warnings"]],
     "token": [".py", "''\n\n\n__all__=['tok_name','ISTERMINAL','ISNONTERMINAL','ISEOF']\n\nENDMARKER=0\nNAME=1\nNUMBER=2\nSTRING=3\nNEWLINE=4\nINDENT=5\nDEDENT=6\nLPAR=7\nRPAR=8\nLSQB=9\nRSQB=10\nCOLON=11\nCOMMA=12\nSEMI=13\nPLUS=14\nMINUS=15\nSTAR=16\nSLASH=17\nVBAR=18\nAMPER=19\nLESS=20\nGREATER=21\nEQUAL=22\nDOT=23\nPERCENT=24\nLBRACE=25\nRBRACE=26\nEQEQUAL=27\nNOTEQUAL=28\nLESSEQUAL=29\nGREATEREQUAL=30\nTILDE=31\nCIRCUMFLEX=32\nLEFTSHIFT=33\nRIGHTSHIFT=34\nDOUBLESTAR=35\nPLUSEQUAL=36\nMINEQUAL=37\nSTAREQUAL=38\nSLASHEQUAL=39\nPERCENTEQUAL=40\nAMPEREQUAL=41\nVBAREQUAL=42\nCIRCUMFLEXEQUAL=43\nLEFTSHIFTEQUAL=44\nRIGHTSHIFTEQUAL=45\nDOUBLESTAREQUAL=46\nDOUBLESLASH=47\nDOUBLESLASHEQUAL=48\nAT=49\nATEQUAL=50\nRARROW=51\nELLIPSIS=52\nCOLONEQUAL=53\nOP=54\nAWAIT=55\nASYNC=56\nTYPE_IGNORE=57\nTYPE_COMMENT=58\n\nERRORTOKEN=59\nCOMMENT=60\nNL=61\nENCODING=62\nN_TOKENS=63\n\nNT_OFFSET=256\n\ntok_name={value:name\nfor name,value in globals().items()\nif isinstance(value,int)and not name.startswith('_')}\n__all__.extend(tok_name.values())\n\nEXACT_TOKEN_TYPES={\n'!=':NOTEQUAL,\n'%':PERCENT,\n'%=':PERCENTEQUAL,\n'&':AMPER,\n'&=':AMPEREQUAL,\n'(':LPAR,\n')':RPAR,\n'*':STAR,\n'**':DOUBLESTAR,\n'**=':DOUBLESTAREQUAL,\n'*=':STAREQUAL,\n'+':PLUS,\n'+=':PLUSEQUAL,\n',':COMMA,\n'-':MINUS,\n'-=':MINEQUAL,\n'->':RARROW,\n'.':DOT,\n'...':ELLIPSIS,\n'/':SLASH,\n'//':DOUBLESLASH,\n'//=':DOUBLESLASHEQUAL,\n'/=':SLASHEQUAL,\n':':COLON,\n':=':COLONEQUAL,\n';':SEMI,\n'<':LESS,\n'<<':LEFTSHIFT,\n'<<=':LEFTSHIFTEQUAL,\n'<=':LESSEQUAL,\n'=':EQUAL,\n'==':EQEQUAL,\n'>':GREATER,\n'>=':GREATEREQUAL,\n'>>':RIGHTSHIFT,\n'>>=':RIGHTSHIFTEQUAL,\n'@':AT,\n'@=':ATEQUAL,\n'[':LSQB,\n']':RSQB,\n'^':CIRCUMFLEX,\n'^=':CIRCUMFLEXEQUAL,\n'{':LBRACE,\n'|':VBAR,\n'|=':VBAREQUAL,\n'}':RBRACE,\n'~':TILDE,\n}\n\ndef ISTERMINAL(x):\n return x <NT_OFFSET\n \ndef ISNONTERMINAL(x):\n return x >=NT_OFFSET\n \ndef ISEOF(x):\n return x ==ENDMARKER\n", []],
     "tokenize": [".py", "''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n__author__='Ka-Ping Yee <ping@lfw.org>'\n__credits__=('GvR, ESR, Tim Peters, Thomas Wouters, Fred Drake, '\n'Skip Montanaro, Raymond Hettinger, Trent Nelson, '\n'Michael Foord')\nfrom builtins import open as _builtin_open\nfrom codecs import lookup,BOM_UTF8\nimport collections\nfrom io import TextIOWrapper\nimport itertools as _itertools\nimport re\nimport sys\nfrom token import *\nfrom token import EXACT_TOKEN_TYPES\n\ncookie_re=re.compile(r'^[ \\t\\f]*#.*?coding[:=][ \\t]*([-\\w.]+)',re.ASCII)\nblank_re=re.compile(br'^[ \\t\\f]*(?:[#\\r\\n]|$)',re.ASCII)\n\nimport token\n__all__=token.__all__+[\"tokenize\",\"generate_tokens\",\"detect_encoding\",\n\"untokenize\",\"TokenInfo\"]\ndel token\n\nclass TokenInfo(collections.namedtuple('TokenInfo','type string start end line')):\n def __repr__(self):\n  annotated_type='%d (%s)'%(self.type,tok_name[self.type])\n  return ('TokenInfo(type=%s, string=%r, start=%r, end=%r, line=%r)'%\n  self._replace(type=annotated_type))\n  \n @property\n def exact_type(self):\n  if self.type ==OP and self.string in EXACT_TOKEN_TYPES:\n   return EXACT_TOKEN_TYPES[self.string]\n  else :\n   return self.type\n   \ndef group(*choices):return '('+'|'.join(choices)+')'\ndef any(*choices):return group(*choices)+'*'\ndef maybe(*choices):return group(*choices)+'?'\n\n\n\nWhitespace=r'[ \\f\\t]*'\nComment=r'#[^\\r\\n]*'\nIgnore=Whitespace+any(r'\\\\\\r?\\n'+Whitespace)+maybe(Comment)\nName=r'\\w+'\n\nHexnumber=r'0[xX](?:_?[0-9a-fA-F])+'\nBinnumber=r'0[bB](?:_?[01])+'\nOctnumber=r'0[oO](?:_?[0-7])+'\nDecnumber=r'(?:0(?:_?0)*|[1-9](?:_?[0-9])*)'\nIntnumber=group(Hexnumber,Binnumber,Octnumber,Decnumber)\nExponent=r'[eE][-+]?[0-9](?:_?[0-9])*'\nPointfloat=group(r'[0-9](?:_?[0-9])*\\.(?:[0-9](?:_?[0-9])*)?',\nr'\\.[0-9](?:_?[0-9])*')+maybe(Exponent)\nExpfloat=r'[0-9](?:_?[0-9])*'+Exponent\nFloatnumber=group(Pointfloat,Expfloat)\nImagnumber=group(r'[0-9](?:_?[0-9])*[jJ]',Floatnumber+r'[jJ]')\nNumber=group(Imagnumber,Floatnumber,Intnumber)\n\n\ndef _all_string_prefixes():\n\n\n\n _valid_string_prefixes=['b','r','u','f','br','fr']\n \n result={''}\n for prefix in _valid_string_prefixes:\n  for t in _itertools.permutations(prefix):\n  \n  \n   for u in _itertools.product(*[(c,c.upper())for c in t]):\n    result.add(''.join(u))\n return result\n \ndef _compile(expr):\n return re.compile(expr,re.UNICODE)\n \n \n \nStringPrefix=group(*_all_string_prefixes())\n\n\nSingle=r\"[^'\\\\]*(?:\\\\.[^'\\\\]*)*'\"\n\nDouble=r'[^\"\\\\]*(?:\\\\.[^\"\\\\]*)*\"'\n\nSingle3=r\"[^'\\\\]*(?:(?:\\\\.|'(?!''))[^'\\\\]*)*'''\"\n\nDouble3=r'[^\"\\\\]*(?:(?:\\\\.|\"(?!\"\"))[^\"\\\\]*)*\"\"\"'\nTriple=group(StringPrefix+\"'''\",StringPrefix+'\"\"\"')\n\nString=group(StringPrefix+r\"'[^\\n'\\\\]*(?:\\\\.[^\\n'\\\\]*)*'\",\nStringPrefix+r'\"[^\\n\"\\\\]*(?:\\\\.[^\\n\"\\\\]*)*\"')\n\n\n\n\nSpecial=group(*map(re.escape,sorted(EXACT_TOKEN_TYPES,reverse=True )))\nFunny=group(r'\\r?\\n',Special)\n\nPlainToken=group(Number,Funny,String,Name)\nToken=Ignore+PlainToken\n\n\nContStr=group(StringPrefix+r\"'[^\\n'\\\\]*(?:\\\\.[^\\n'\\\\]*)*\"+\ngroup(\"'\",r'\\\\\\r?\\n'),\nStringPrefix+r'\"[^\\n\"\\\\]*(?:\\\\.[^\\n\"\\\\]*)*'+\ngroup('\"',r'\\\\\\r?\\n'))\nPseudoExtras=group(r'\\\\\\r?\\n|\\Z',Comment,Triple)\nPseudoToken=Whitespace+group(PseudoExtras,Number,Funny,ContStr,Name)\n\n\n\n\nendpats={}\nfor _prefix in _all_string_prefixes():\n endpats[_prefix+\"'\"]=Single\n endpats[_prefix+'\"']=Double\n endpats[_prefix+\"'''\"]=Single3\n endpats[_prefix+'\"\"\"']=Double3\n \n \n \nsingle_quoted=set()\ntriple_quoted=set()\nfor t in _all_string_prefixes():\n for u in (t+'\"',t+\"'\"):\n  single_quoted.add(u)\n for u in (t+'\"\"\"',t+\"'''\"):\n  triple_quoted.add(u)\n  \ntabsize=8\n\nclass TokenError(Exception):pass\n\nclass StopTokenizing(Exception):pass\n\n\nclass Untokenizer:\n\n def __init__(self):\n  self.tokens=[]\n  self.prev_row=1\n  self.prev_col=0\n  self.encoding=None\n  \n def add_whitespace(self,start):\n  row,col=start\n  if row <self.prev_row or row ==self.prev_row and col <self.prev_col:\n   raise ValueError(\"start ({},{}) precedes previous end ({},{})\"\n   .format(row,col,self.prev_row,self.prev_col))\n  row_offset=row -self.prev_row\n  if row_offset:\n   self.tokens.append(\"\\\\\\n\"*row_offset)\n   self.prev_col=0\n  col_offset=col -self.prev_col\n  if col_offset:\n   self.tokens.append(\" \"*col_offset)\n   \n def untokenize(self,iterable):\n  it=iter(iterable)\n  indents=[]\n  startline=False\n  for t in it:\n   if len(t)==2:\n    self.compat(t,it)\n    break\n   tok_type,token,start,end,line=t\n   if tok_type ==ENCODING:\n    self.encoding=token\n    continue\n   if tok_type ==ENDMARKER:\n    break\n   if tok_type ==INDENT:\n    indents.append(token)\n    continue\n   elif tok_type ==DEDENT:\n    indents.pop()\n    self.prev_row,self.prev_col=end\n    continue\n   elif tok_type in (NEWLINE,NL):\n    startline=True\n   elif startline and indents:\n    indent=indents[-1]\n    if start[1]>=len(indent):\n     self.tokens.append(indent)\n     self.prev_col=len(indent)\n    startline=False\n   self.add_whitespace(start)\n   self.tokens.append(token)\n   self.prev_row,self.prev_col=end\n   if tok_type in (NEWLINE,NL):\n    self.prev_row +=1\n    self.prev_col=0\n  return \"\".join(self.tokens)\n  \n def compat(self,token,iterable):\n  indents=[]\n  toks_append=self.tokens.append\n  startline=token[0]in (NEWLINE,NL)\n  prevstring=False\n  \n  for tok in _itertools.chain([token],iterable):\n   toknum,tokval=tok[:2]\n   if toknum ==ENCODING:\n    self.encoding=tokval\n    continue\n    \n   if toknum in (NAME,NUMBER):\n    tokval +=' '\n    \n    \n   if toknum ==STRING:\n    if prevstring:\n     tokval=' '+tokval\n    prevstring=True\n   else :\n    prevstring=False\n    \n   if toknum ==INDENT:\n    indents.append(tokval)\n    continue\n   elif toknum ==DEDENT:\n    indents.pop()\n    continue\n   elif toknum in (NEWLINE,NL):\n    startline=True\n   elif startline and indents:\n    toks_append(indents[-1])\n    startline=False\n   toks_append(tokval)\n   \n   \ndef untokenize(iterable):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n ut=Untokenizer()\n out=ut.untokenize(iterable)\n if ut.encoding is not None :\n  out=out.encode(ut.encoding)\n return out\n \n \ndef _get_normal_name(orig_enc):\n ''\n \n enc=orig_enc[:12].lower().replace(\"_\",\"-\")\n if enc ==\"utf-8\"or enc.startswith(\"utf-8-\"):\n  return \"utf-8\"\n if enc in (\"latin-1\",\"iso-8859-1\",\"iso-latin-1\")or\\\n enc.startswith((\"latin-1-\",\"iso-8859-1-\",\"iso-latin-1-\")):\n  return \"iso-8859-1\"\n return orig_enc\n \ndef detect_encoding(readline):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n try :\n  filename=readline.__self__.name\n except AttributeError:\n  filename=None\n bom_found=False\n encoding=None\n default='utf-8'\n def read_or_stop():\n  try :\n   return readline()\n  except StopIteration:\n   return b''\n   \n def find_cookie(line):\n  try :\n  \n  \n  \n   line_string=line.decode('utf-8')\n  except UnicodeDecodeError:\n   msg=\"invalid or missing encoding declaration\"\n   if filename is not None :\n    msg='{} for {!r}'.format(msg,filename)\n   raise SyntaxError(msg)\n   \n  match=cookie_re.match(line_string)\n  if not match:\n   return None\n  encoding=_get_normal_name(match.group(1))\n  try :\n   codec=lookup(encoding)\n  except LookupError:\n  \n   if filename is None :\n    msg=\"unknown encoding: \"+encoding\n   else :\n    msg=\"unknown encoding for {!r}: {}\".format(filename,\n    encoding)\n   raise SyntaxError(msg)\n   \n  if bom_found:\n   if encoding !='utf-8':\n   \n    if filename is None :\n     msg='encoding problem: utf-8'\n    else :\n     msg='encoding problem for {!r}: utf-8'.format(filename)\n    raise SyntaxError(msg)\n   encoding +='-sig'\n  return encoding\n  \n first=read_or_stop()\n if first.startswith(BOM_UTF8):\n  bom_found=True\n  first=first[3:]\n  default='utf-8-sig'\n if not first:\n  return default,[]\n  \n encoding=find_cookie(first)\n if encoding:\n  return encoding,[first]\n if not blank_re.match(first):\n  return default,[first]\n  \n second=read_or_stop()\n if not second:\n  return default,[first]\n  \n encoding=find_cookie(second)\n if encoding:\n  return encoding,[first,second]\n  \n return default,[first,second]\n \n \ndef open(filename):\n ''\n\n \n buffer=_builtin_open(filename,'rb')\n try :\n  encoding,lines=detect_encoding(buffer.readline)\n  buffer.seek(0)\n  text=TextIOWrapper(buffer,encoding,line_buffering=True )\n  text.mode='r'\n  return text\n except :\n  buffer.close()\n  raise\n  \n  \ndef tokenize(readline):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n encoding,consumed=detect_encoding(readline)\n empty=_itertools.repeat(b\"\")\n rl_gen=_itertools.chain(consumed,iter(readline,b\"\"),empty)\n return _tokenize(rl_gen.__next__,encoding)\n \n \ndef _tokenize(readline,encoding):\n lnum=parenlev=continued=0\n numchars='0123456789'\n contstr,needcont='',0\n contline=None\n indents=[0]\n \n if encoding is not None :\n  if encoding ==\"utf-8-sig\":\n  \n   encoding=\"utf-8\"\n  yield TokenInfo(ENCODING,encoding,(0,0),(0,0),'')\n last_line=b''\n line=b''\n while True :\n  try :\n  \n  \n  \n  \n   last_line=line\n   line=readline()\n  except StopIteration:\n   line=b''\n   \n  if encoding is not None :\n   line=line.decode(encoding)\n  lnum +=1\n  pos,max=0,len(line)\n  \n  if contstr:\n   if not line:\n    raise TokenError(\"EOF in multi-line string\",strstart)\n   endmatch=endprog.match(line)\n   if endmatch:\n    pos=end=endmatch.end(0)\n    yield TokenInfo(STRING,contstr+line[:end],\n    strstart,(lnum,end),contline+line)\n    contstr,needcont='',0\n    contline=None\n   elif needcont and line[-2:]!='\\\\\\n'and line[-3:]!='\\\\\\r\\n':\n    yield TokenInfo(ERRORTOKEN,contstr+line,\n    strstart,(lnum,len(line)),contline)\n    contstr=''\n    contline=None\n    continue\n   else :\n    contstr=contstr+line\n    contline=contline+line\n    continue\n    \n  elif parenlev ==0 and not continued:\n   if not line:break\n   column=0\n   while pos <max:\n    if line[pos]==' ':\n     column +=1\n    elif line[pos]=='\\t':\n     column=(column //tabsize+1)*tabsize\n    elif line[pos]=='\\f':\n     column=0\n    else :\n     break\n    pos +=1\n   if pos ==max:\n    break\n    \n   if line[pos]in '#\\r\\n':\n    if line[pos]=='#':\n     comment_token=line[pos:].rstrip('\\r\\n')\n     yield TokenInfo(COMMENT,comment_token,\n     (lnum,pos),(lnum,pos+len(comment_token)),line)\n     pos +=len(comment_token)\n     \n    yield TokenInfo(NL,line[pos:],\n    (lnum,pos),(lnum,len(line)),line)\n    continue\n    \n   if column >indents[-1]:\n    indents.append(column)\n    yield TokenInfo(INDENT,line[:pos],(lnum,0),(lnum,pos),line)\n   while column <indents[-1]:\n    if column not in indents:\n     raise IndentationError(\n     \"unindent does not match any outer indentation level\",\n     (\"<tokenize>\",lnum,pos,line))\n    indents=indents[:-1]\n    \n    yield TokenInfo(DEDENT,'',(lnum,pos),(lnum,pos),line)\n    \n  else :\n   if not line:\n    raise TokenError(\"EOF in multi-line statement\",(lnum,0))\n   continued=0\n   \n  while pos <max:\n   pseudomatch=_compile(PseudoToken).match(line,pos)\n   if pseudomatch:\n    start,end=pseudomatch.span(1)\n    spos,epos,pos=(lnum,start),(lnum,end),end\n    if start ==end:\n     continue\n    token,initial=line[start:end],line[start]\n    \n    if (initial in numchars or\n    (initial =='.'and token !='.'and token !='...')):\n     yield TokenInfo(NUMBER,token,spos,epos,line)\n    elif initial in '\\r\\n':\n     if parenlev >0:\n      yield TokenInfo(NL,token,spos,epos,line)\n     else :\n      yield TokenInfo(NEWLINE,token,spos,epos,line)\n      \n    elif initial =='#':\n     assert not token.endswith(\"\\n\")\n     yield TokenInfo(COMMENT,token,spos,epos,line)\n     \n    elif token in triple_quoted:\n     endprog=_compile(endpats[token])\n     endmatch=endprog.match(line,pos)\n     if endmatch:\n      pos=endmatch.end(0)\n      token=line[start:pos]\n      yield TokenInfo(STRING,token,spos,(lnum,pos),line)\n     else :\n      strstart=(lnum,start)\n      contstr=line[start:]\n      contline=line\n      break\n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n    elif (initial in single_quoted or\n    token[:2]in single_quoted or\n    token[:3]in single_quoted):\n     if token[-1]=='\\n':\n      strstart=(lnum,start)\n      \n      \n      \n      \n      \n      \n      endprog=_compile(endpats.get(initial)or\n      endpats.get(token[1])or\n      endpats.get(token[2]))\n      contstr,needcont=line[start:],1\n      contline=line\n      break\n     else :\n      yield TokenInfo(STRING,token,spos,epos,line)\n      \n    elif initial.isidentifier():\n     yield TokenInfo(NAME,token,spos,epos,line)\n    elif initial =='\\\\':\n     continued=1\n    else :\n     if initial in '([{':\n      parenlev +=1\n     elif initial in ')]}':\n      parenlev -=1\n     yield TokenInfo(OP,token,spos,epos,line)\n   else :\n    yield TokenInfo(ERRORTOKEN,line[pos],\n    (lnum,pos),(lnum,pos+1),line)\n    pos +=1\n    \n    \n if last_line and last_line[-1]not in '\\r\\n':\n  yield TokenInfo(NEWLINE,'',(lnum -1,len(last_line)),(lnum -1,len(last_line)+1),'')\n for indent in indents[1:]:\n  yield TokenInfo(DEDENT,'',(lnum,0),(lnum,0),'')\n yield TokenInfo(ENDMARKER,'',(lnum,0),(lnum,0),'')\n \n \ndef generate_tokens(readline):\n ''\n\n\n\n \n return _tokenize(readline,None )\n \ndef main():\n import argparse\n \n \n def perror(message):\n  sys.stderr.write(message)\n  sys.stderr.write('\\n')\n  \n def error(message,filename=None ,location=None ):\n  if location:\n   args=(filename,)+location+(message,)\n   perror(\"%s:%d:%d: error: %s\"%args)\n  elif filename:\n   perror(\"%s: error: %s\"%(filename,message))\n  else :\n   perror(\"error: %s\"%message)\n  sys.exit(1)\n  \n  \n parser=argparse.ArgumentParser(prog='python -m tokenize')\n parser.add_argument(dest='filename',nargs='?',\n metavar='filename.py',\n help='the file to tokenize; defaults to stdin')\n parser.add_argument('-e','--exact',dest='exact',action='store_true',\n help='display token names using the exact type')\n args=parser.parse_args()\n \n try :\n \n  if args.filename:\n   filename=args.filename\n   with _builtin_open(filename,'rb')as f:\n    tokens=list(tokenize(f.readline))\n  else :\n   filename=\"<stdin>\"\n   tokens=_tokenize(sys.stdin.readline,None )\n   \n   \n  for token in tokens:\n   token_type=token.type\n   if args.exact:\n    token_type=token.exact_type\n   token_range=\"%d,%d-%d,%d:\"%(token.start+token.end)\n   print(\"%-20s%-15s%-15r\"%\n   (token_range,tok_name[token_type],token.string))\n except IndentationError as err:\n  line,column=err.args[1][1:3]\n  error(err.args[0],filename,(line,column))\n except TokenError as err:\n  line,column=err.args[1]\n  error(err.args[0],filename,(line,column))\n except SyntaxError as err:\n  error(err,filename)\n except OSError as err:\n  error(err)\n except KeyboardInterrupt:\n  print(\"interrupted\\n\")\n except Exception as err:\n  perror(\"unexpected error: %s\"%err)\n  raise\n  \nif __name__ ==\"__main__\":\n main()\n", ["argparse", "builtins", "codecs", "collections", "io", "itertools", "re", "sys", "token"]],
     "traceback": [".py", "''\n\nimport collections\nimport itertools\nimport linecache\nimport sys\n\n__all__=['extract_stack','extract_tb','format_exception',\n'format_exception_only','format_list','format_stack',\n'format_tb','print_exc','format_exc','print_exception',\n'print_last','print_stack','print_tb','clear_frames',\n'FrameSummary','StackSummary','TracebackException',\n'walk_stack','walk_tb']\n\n\n\n\n\ndef print_list(extracted_list,file=None ):\n ''\n \n if file is None :\n  file=sys.stderr\n for item in StackSummary.from_list(extracted_list).format():\n  print(item,file=file,end=\"\")\n  \ndef format_list(extracted_list):\n ''\n\n\n\n\n\n\n\n\n\n \n return StackSummary.from_list(extracted_list).format()\n \n \n \n \n \ndef print_tb(tb,limit=None ,file=None ):\n ''\n\n\n\n\n\n \n print_list(extract_tb(tb,limit=limit),file=file)\n \ndef format_tb(tb,limit=None ):\n ''\n return extract_tb(tb,limit=limit).format()\n \ndef extract_tb(tb,limit=None ):\n ''\n\n\n\n\n\n\n\n\n\n\n \n return StackSummary.extract(walk_tb(tb),limit=limit)\n \n \n \n \n \n_cause_message=(\n\"\\nThe above exception was the direct cause \"\n\"of the following exception:\\n\\n\")\n\n_context_message=(\n\"\\nDuring handling of the above exception, \"\n\"another exception occurred:\\n\\n\")\n\n\ndef print_exception(etype,value,tb,limit=None ,file=None ,chain=True ):\n ''\n\n\n\n\n\n\n\n\n \n \n \n \n if file is None :\n  file=sys.stderr\n for line in TracebackException(\n type(value),value,tb,limit=limit).format(chain=chain):\n  print(line,file=file,end=\"\")\n  \n  \ndef format_exception(etype,value,tb,limit=None ,chain=True ):\n ''\n\n\n\n\n\n\n \n \n \n \n return list(TracebackException(\n type(value),value,tb,limit=limit).format(chain=chain))\n \n \ndef format_exception_only(etype,value):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n return list(TracebackException(etype,value,None ).format_exception_only())\n \n \n \n \ndef _format_final_exc_line(etype,value):\n valuestr=_some_str(value)\n if value is None or not valuestr:\n  line=\"%s\\n\"%etype\n else :\n  line=\"%s: %s\\n\"%(etype,valuestr)\n return line\n \ndef _some_str(value):\n try :\n  return str(value)\n except :\n  return '<unprintable %s object>'%type(value).__name__\n  \n  \n  \ndef print_exc(limit=None ,file=None ,chain=True ):\n ''\n print_exception(*sys.exc_info(),limit=limit,file=file,chain=chain)\n \ndef format_exc(limit=None ,chain=True ):\n ''\n return \"\".join(format_exception(*sys.exc_info(),limit=limit,chain=chain))\n \ndef print_last(limit=None ,file=None ,chain=True ):\n ''\n \n if not hasattr(sys,\"last_type\"):\n  raise ValueError(\"no last exception\")\n print_exception(sys.last_type,sys.last_value,sys.last_traceback,\n limit,file,chain)\n \n \n \n \n \ndef print_stack(f=None ,limit=None ,file=None ):\n ''\n\n\n\n\n \n if f is None :\n  f=sys._getframe().f_back\n print_list(extract_stack(f,limit=limit),file=file)\n \n \ndef format_stack(f=None ,limit=None ):\n ''\n if f is None :\n  f=sys._getframe().f_back\n return format_list(extract_stack(f,limit=limit))\n \n \ndef extract_stack(f=None ,limit=None ):\n ''\n\n\n\n\n\n\n \n if f is None :\n  f=sys._getframe().f_back\n stack=StackSummary.extract(walk_stack(f),limit=limit)\n stack.reverse()\n return stack\n \n \ndef clear_frames(tb):\n ''\n while tb is not None :\n  try :\n   tb.tb_frame.clear()\n  except RuntimeError:\n  \n   pass\n  tb=tb.tb_next\n  \n  \nclass FrameSummary:\n ''\n\n\n\n\n\n\n\n\n\n\n \n \n __slots__=('filename','lineno','name','_line','locals')\n \n def __init__(self,filename,lineno,name,*,lookup_line=True ,\n locals=None ,line=None ):\n  ''\n\n\n\n\n\n\n\n  \n  self.filename=filename\n  self.lineno=lineno\n  self.name=name\n  self._line=line\n  if lookup_line:\n   self.line\n  self.locals={k:repr(v)for k,v in locals.items()}if locals else None\n  \n def __eq__(self,other):\n  if isinstance(other,FrameSummary):\n   return (self.filename ==other.filename and\n   self.lineno ==other.lineno and\n   self.name ==other.name and\n   self.locals ==other.locals)\n  if isinstance(other,tuple):\n   return (self.filename,self.lineno,self.name,self.line)==other\n  return NotImplemented\n  \n def __getitem__(self,pos):\n  return (self.filename,self.lineno,self.name,self.line)[pos]\n  \n def __iter__(self):\n  return iter([self.filename,self.lineno,self.name,self.line])\n  \n def __repr__(self):\n  return \"<FrameSummary file {filename}, line {lineno} in {name}>\".format(\n  filename=self.filename,lineno=self.lineno,name=self.name)\n  \n def __len__(self):\n  return 4\n  \n @property\n def line(self):\n  if self._line is None :\n   self._line=linecache.getline(self.filename,self.lineno).strip()\n  return self._line\n  \n  \ndef walk_stack(f):\n ''\n\n\n\n \n if f is None :\n  f=sys._getframe().f_back.f_back\n while f is not None :\n  yield f,f.f_lineno\n  f=f.f_back\n  \n  \ndef walk_tb(tb):\n ''\n\n\n\n \n while tb is not None :\n  yield tb.tb_frame,tb.tb_lineno\n  tb=tb.tb_next\n  \n  \n_RECURSIVE_CUTOFF=3\n\nclass StackSummary(list):\n ''\n \n @classmethod\n def extract(klass,frame_gen,*,limit=None ,lookup_lines=True ,\n capture_locals=False ):\n  ''\n\n\n\n\n\n\n\n\n\n  \n  if limit is None :\n   limit=getattr(sys,'tracebacklimit',None )\n   if limit is not None and limit <0:\n    limit=0\n  if limit is not None :\n   if limit >=0:\n    frame_gen=itertools.islice(frame_gen,limit)\n   else :\n    frame_gen=collections.deque(frame_gen,maxlen=-limit)\n    \n  result=klass()\n  fnames=set()\n  for f,lineno in frame_gen:\n   co=f.f_code\n   filename=co.co_filename\n   name=co.co_name\n   \n   fnames.add(filename)\n   linecache.lazycache(filename,f.f_globals)\n   \n   if capture_locals:\n    f_locals=f.f_locals\n   else :\n    f_locals=None\n   result.append(FrameSummary(\n   filename,lineno,name,lookup_line=False ,locals=f_locals))\n  for filename in fnames:\n   linecache.checkcache(filename)\n   \n  if lookup_lines:\n   for f in result:\n    f.line\n  return result\n  \n @classmethod\n def from_list(klass,a_list):\n  ''\n\n\n  \n  \n  \n  \n  \n  result=StackSummary()\n  for frame in a_list:\n   if isinstance(frame,FrameSummary):\n    result.append(frame)\n   else :\n    filename,lineno,name,line=frame\n    result.append(FrameSummary(filename,lineno,name,line=line))\n  return result\n  \n def format(self):\n  ''\n\n\n\n\n\n\n\n\n\n  \n  result=[]\n  last_file=None\n  last_line=None\n  last_name=None\n  count=0\n  for frame in self:\n   if (last_file is None or last_file !=frame.filename or\n   last_line is None or last_line !=frame.lineno or\n   last_name is None or last_name !=frame.name):\n    if count >_RECURSIVE_CUTOFF:\n     count -=_RECURSIVE_CUTOFF\n     result.append(\n     f'  [Previous line repeated {count} more '\n     f'time{\"s\" if count > 1 else \"\"}]\\n'\n     )\n    last_file=frame.filename\n    last_line=frame.lineno\n    last_name=frame.name\n    count=0\n   count +=1\n   if count >_RECURSIVE_CUTOFF:\n    continue\n   row=[]\n   row.append('  File \"{}\", line {}, in {}\\n'.format(\n   frame.filename,frame.lineno,frame.name))\n   if frame.line:\n    row.append('    {}\\n'.format(frame.line.strip()))\n   if frame.locals:\n    for name,value in sorted(frame.locals.items()):\n     row.append('    {name} = {value}\\n'.format(name=name,value=value))\n   result.append(''.join(row))\n  if count >_RECURSIVE_CUTOFF:\n   count -=_RECURSIVE_CUTOFF\n   result.append(\n   f'  [Previous line repeated {count} more '\n   f'time{\"s\" if count > 1 else \"\"}]\\n'\n   )\n  return result\n  \n  \nclass TracebackException:\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n def __init__(self,exc_type,exc_value,exc_traceback,*,limit=None ,\n lookup_lines=True ,capture_locals=False ,_seen=None ):\n \n \n \n \n  if _seen is None :\n   _seen=set()\n  _seen.add(id(exc_value))\n  \n  \n  if (exc_value and exc_value.__cause__ is not None\n  and id(exc_value.__cause__)not in _seen):\n   cause=TracebackException(\n   type(exc_value.__cause__),\n   exc_value.__cause__,\n   exc_value.__cause__.__traceback__,\n   limit=limit,\n   lookup_lines=False ,\n   capture_locals=capture_locals,\n   _seen=_seen)\n  else :\n   cause=None\n  if (exc_value and exc_value.__context__ is not None\n  and id(exc_value.__context__)not in _seen):\n   context=TracebackException(\n   type(exc_value.__context__),\n   exc_value.__context__,\n   exc_value.__context__.__traceback__,\n   limit=limit,\n   lookup_lines=False ,\n   capture_locals=capture_locals,\n   _seen=_seen)\n  else :\n   context=None\n  self.exc_traceback=exc_traceback\n  self.__cause__=cause\n  self.__context__=context\n  self.__suppress_context__=\\\n  exc_value.__suppress_context__ if exc_value else False\n  \n  self.stack=StackSummary.extract(\n  walk_tb(exc_traceback),limit=limit,lookup_lines=lookup_lines,\n  capture_locals=capture_locals)\n  self.exc_type=exc_type\n  \n  \n  self._str=_some_str(exc_value)\n  if exc_type and issubclass(exc_type,SyntaxError):\n  \n   self.filename=exc_value.filename\n   self.lineno=str(exc_value.lineno)\n   self.text=exc_value.text\n   self.offset=exc_value.offset\n   self.msg=exc_value.msg\n  if lookup_lines:\n   self._load_lines()\n   \n @classmethod\n def from_exception(cls,exc,*args,**kwargs):\n  ''\n  return cls(type(exc),exc,exc.__traceback__,*args,**kwargs)\n  \n def _load_lines(self):\n  ''\n  for frame in self.stack:\n   frame.line\n  if self.__context__:\n   self.__context__._load_lines()\n  if self.__cause__:\n   self.__cause__._load_lines()\n   \n def __eq__(self,other):\n  if isinstance(other,TracebackException):\n   return self.__dict__ ==other.__dict__\n  return NotImplemented\n  \n def __str__(self):\n  return self._str\n  \n def format_exception_only(self):\n  ''\n\n\n\n\n\n\n\n\n\n\n  \n  if self.exc_type is None :\n   yield _format_final_exc_line(None ,self._str)\n   return\n   \n  stype=self.exc_type.__qualname__\n  smod=self.exc_type.__module__\n  if smod not in (\"__main__\",\"builtins\"):\n   stype=smod+'.'+stype\n   \n  if not issubclass(self.exc_type,SyntaxError):\n   yield _format_final_exc_line(stype,self._str)\n  else :\n   yield from self._format_syntax_error(stype)\n   \n def _format_syntax_error(self,stype):\n  ''\n  \n  filename=self.filename or \"<string>\"\n  lineno=str(self.lineno)or '?'\n  yield '  File \"{}\", line {}\\n'.format(filename,lineno)\n  \n  text=self.text\n  if text is not None :\n  \n  \n  \n   rtext=text.rstrip('\\n')\n   ltext=rtext.lstrip(' \\n\\f')\n   spaces=len(rtext)-len(ltext)\n   yield '    {}\\n'.format(ltext)\n   \n   caret=(self.offset or 0)-1 -spaces\n   if caret >=0:\n   \n    caretspace=((c if c.isspace()else ' ')for c in ltext[:caret])\n    yield '    {}^\\n'.format(''.join(caretspace))\n  msg=self.msg or \"<no detail available>\"\n  yield \"{}: {}\\n\".format(stype,msg)\n  \n def format(self,*,chain=True ):\n  ''\n\n\n\n\n\n\n\n\n\n  \n  if chain:\n   if self.__cause__ is not None :\n    yield from self.__cause__.format(chain=chain)\n    yield _cause_message\n   elif (self.__context__ is not None and\n   not self.__suppress_context__):\n    yield from self.__context__.format(chain=chain)\n    yield _context_message\n  if self.exc_traceback is not None :\n   yield 'Traceback (most recent call last):\\n'\n  yield from self.stack.format()\n  yield from self.format_exception_only()\n", ["collections", "itertools", "linecache", "sys"]],
-    "turtle": [".py", "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nimport math\nimport sys\n\nfrom math import cos,sin\n\nfrom browser import console,document,html,timer\nimport _svg as svg\n\n\n\n\n\n\n_CFG={\n\n\n\"canvwidth\":500,\n\"canvheight\":500,\n\n\n\"mode\":\"standard\",\n\n\n\n\"shape\":\"classic\",\n\"pencolor\":\"black\",\n\"fillcolor\":\"black\",\n\n\"visible\":True ,\n\n\n\n\n\n\n\n\"turtle_canvas_wrapper\":None ,\n\"turtle_canvas_id\":\"turtle-canvas\",\n\"min_duration\":\"1ms\"\n}\n\n_cfg_copy=_CFG.copy()\n\n\ndef set_defaults(**params):\n ''\n _CFG.update(**params)\n Screen().reset()\n \n \nclass FormattedTuple(tuple):\n ''\n def __new__(cls,x,y):\n  return tuple.__new__(cls,(x,y))\n def __repr__(self):\n  return \"(%.2f, %.2f)\"%self\n  \ndef create_circle(r):\n ''\n circle=svg.circle(x=0,y=0,r=r,stroke=\"black\",fill=\"black\")\n circle.setAttribute(\"stroke-width\",1)\n return circle\n \n \ndef create_polygon(points):\n ''\n points=[\"%s,%s \"%(x,y)for x,y in points]\n polygon=svg.polygon(points=points,stroke=\"black\",fill=\"black\")\n polygon.setAttribute(\"stroke-width\",1)\n return polygon\n \n \ndef create_rectangle(width=2,height=2,rx=None ,ry=None ):\n ''\n \n rectangle=svg.rect(x=-width /2,y=-height /2,width=width,\n height=height,stroke=\"black\",fill=\"black\")\n rectangle.setAttribute(\"stroke-width\",1)\n if rx is not None :\n  rectangle.setAttribute(\"rx\",rx)\n if ry is not None :\n  rectangle.setAttribute(\"ry\",ry)\n return rectangle\n \n \ndef create_square(size=2,r=None ):\n ''\n \n return create_rectangle(width=size,height=size,rx=r,ry=r)\n \n \nclass TurtleGraphicsError(Exception):\n ''\n \n pass\n \n \nclass Singleton(type):\n _instances={}\n def __call__(cls,*args,**kwargs):\n  if cls not in cls._instances:\n   cls._instances[cls]=super(Singleton,cls).__call__(*args,**kwargs)\n  return cls._instances[cls]\n  \n  \nclass Screen(metaclass=Singleton):\n\n def __init__(self):\n  self.shapes={\n  'arrow':(create_polygon,((-10,0),(10,0),(0,10))),\n  'turtle':(create_polygon,((0,16),(-2,14),(-1,10),(-4,7),\n  (-7,9),(-9,8),(-6,5),(-7,1),(-5,-3),(-8,-6),\n  (-6,-8),(-4,-5),(0,-7),(4,-5),(6,-8),(8,-6),\n  (5,-3),(7,1),(6,5),(9,8),(7,9),(4,7),(1,10),\n  (2,14))),\n  'classic':(create_polygon,((0,0),(-5,-9),(0,-7),(5,-9))),\n  'triangle':(create_polygon,((10,-5.77),(0,11.55),(-10,-5.77))),\n  'square':(create_square,20),\n  'circle':(create_circle,10)\n  }\n  self.reset()\n  self._set_geometry()\n  \n def bgcolor(self,color=None ):\n  ''\n\n  \n  if color is None :\n   return self.background_color\n  self.background_color=color\n  width=_CFG['canvwidth']\n  height=_CFG['canvheight']\n  if self.mode()in ['logo','standard']:\n   x=-width //2\n   y=-height //2\n  else :\n   x=0\n   y=-height\n   \n  self.frame_index +=1\n  rect=svg.rect(x=x,y=y,width=width,height=height,fill=color,\n  style={'display':'none'})\n  an=svg.animate(Id=\"animation_frame%s\"%self.frame_index,\n  attributeName=\"display\",attributeType=\"CSS\",\n  From=\"block\",to=\"block\",\n  dur=_CFG[\"min_duration\"],fill='freeze')\n  an.setAttribute('begin',\"animation_frame%s.end\"%(self.frame_index -1))\n  rect <=an\n  \n  self.background_canvas <=rect\n  \n def _convert_coordinates(self,x,y):\n  ''\n\n\n\n\n\n  \n  return x *self.yscale,self.y_points_down *y *self.yscale\n  \n  \n def create_svg_turtle(self,_turtle,name):\n  if name in self.shapes:\n   fn=self.shapes[name][0]\n   arg=self.shapes[name][1]\n  else :\n   print(\"Unknown turtle '%s'; the default turtle will be used\")\n   fn=self.shapes[_CVG[\"shape\"]][0]\n   arg=self.shapes[_CVG[\"shape\"]][1]\n  shape=fn(arg)\n  if self._mode =='standard'or self._mode =='world':\n   rotation=-90\n  else :\n   rotation=0\n  return shape,rotation\n  \n def _dot(self,pos,size,color):\n  ''\n  if color is None :\n   color='black'\n  if size is None or size <1:\n   size=1\n  self.frame_index +=1\n  \n  x,y=self._convert_coordinates(pos[0],pos[1])\n  \n  circle=svg.circle(cx=x,cy=y,r=size,fill=color,\n  style={'display':'none'})\n  an=svg.animate(Id=\"animation_frame%s\"%self.frame_index,\n  attributeName=\"display\",attributeType=\"CSS\",\n  From=\"block\",to=\"block\",\n  dur=_CFG[\"min_duration\"],fill='freeze')\n  an.setAttribute('begin',\"animation_frame%s.end\"%(self.frame_index -1))\n  circle <=an\n  self.canvas <=circle\n  \n def _drawline(self,_turtle,coordlist=None ,\n color=None ,width=1,speed=None ):\n  ''\n\n\n\n\n  \n  \n  outline=color[0]\n  fill=color[1]\n  \n  x0,y0=coordlist[0]\n  x1,y1=coordlist[1]\n  \n  x0,y0=self._convert_coordinates(x0,y0)\n  x1,y1=self._convert_coordinates(x1,y1)\n  \n  \n  if speed ==0:\n   duration=_CFG[\"min_duration\"]\n  else :\n   dist=_turtle._distance\n   if speed is None or speed ==1:\n    duration=0.02 *dist\n   else :\n    duration=0.02 *dist /speed **1.2\n   if duration <0.001:\n    duration=_CFG[\"min_duration\"]\n   else :\n    duration=\"%6.3fs\"%duration\n    \n  drawing=_turtle._drawing\n  \n  _line=svg.line(x1=x0,y1=y0,x2=x0,y2=y0,\n  style={'stroke':outline,'stroke-width':width})\n  if not drawing:\n   _line.setAttribute('opacity',0)\n   \n   \n  begin=\"animation_frame%s.end\"%self.frame_index\n  self.frame_index +=1\n  _an1=svg.animate(Id=\"animation_frame%s\"%self.frame_index,\n  attributeName=\"x2\",attributeType=\"XML\",\n  From=x0,to=x1,dur=duration,fill='freeze',\n  begin=begin)\n  _line <=_an1\n  \n  \n  if drawing:\n   _an2=svg.animate(attributeName=\"y2\",attributeType=\"XML\",\n   begin=begin,\n   From=y0,to=y1,dur=duration,fill='freeze')\n   _line <=_an2\n   \n   if width >2:\n    _line_cap=svg.set(attributeName=\"stroke-linecap\",\n    begin=begin,\n    attributeType=\"xml\",to=\"round\",dur=duration,fill='freeze')\n    _line <=_line_cap\n    \n  self.canvas <=_line\n  return begin,duration,(x0,y0),(x1,y1)\n  \n def _drawpoly(self,coordlist,outline=None ,fill=None ,width=None ):\n  ''\n\n\n\n\n  \n  self.frame_index +=1\n  shape=[\"%s,%s\"%self._convert_coordinates(x,y)for x,y in coordlist]\n  \n  style={'display':'none'}\n  if fill is not None :\n   style['fill']=fill\n  if outline is not None :\n   style['stroke']=outline\n   if width is not None :\n    style['stroke-width']=width\n   else :\n    style['stroke-width']=1\n    \n  polygon=svg.polygon(points=\" \".join(shape),style=style)\n  \n  an=svg.animate(Id=\"animation_frame%s\"%self.frame_index,\n  attributeName=\"display\",attributeType=\"CSS\",\n  From=\"block\",to=\"block\",\n  dur=_CFG[\"min_duration\"],fill='freeze')\n  \n  an.setAttribute('begin',\"animation_frame%s.end\"%(self.frame_index -1))\n  polygon <=an\n  self.canvas <=polygon\n  \n  \n def _new_frame(self):\n  ''\n  \n  previous_end=\"animation_frame%s.end\"%self.frame_index\n  self.frame_index +=1\n  new_frame_id=\"animation_frame%s\"%self.frame_index\n  return previous_end,new_frame_id\n  \n def mode(self,_mode=None ):\n  if _mode is None :\n   return self._mode\n  _CFG['mode']=_mode\n  self.reset()\n  \n  \n def reset(self):\n  self._turtles=[]\n  self.frame_index=0\n  self.background_color=\"white\"\n  self._set_geometry()\n  \n def _set_geometry(self):\n  self.width=_CFG[\"canvwidth\"]\n  self.height=_CFG[\"canvheight\"]\n  self.x_offset=self.y_offset=0\n  self.xscale=self.yscale=1\n  \n  self.y_points_down=-1\n  self._mode=_CFG[\"mode\"].lower()\n  if self._mode in ['logo','standard']:\n   self.translate_canvas=(self.width //2,self.height //2)\n  elif self._mode =='world':\n   self.translate_canvas=(0,self.height)\n  self._setup_canvas()\n  \n def _setup_canvas(self):\n  self.svg_scene=svg.svg(Id=_CFG[\"turtle_canvas_id\"],width=self.width,\n  height=self.height)\n  translate=\"translate(%d %d)\"%self.translate_canvas\n  \n  \n  self.svg_scene <=svg.animate(\n  Id=\"animation_frame%s\"%self.frame_index,\n  attributeName=\"width\",attributeType=\"CSS\",\n  From=self.width,to=self.width,begin=\"0s\",\n  dur=_CFG[\"min_duration\"],fill='freeze')\n  \n  \n  \n  \n  self.background_canvas=svg.g(transform=translate)\n  self.canvas=svg.g(transform=translate)\n  self.writing_canvas=svg.g(transform=translate)\n  self.turtle_canvas=svg.g(transform=translate)\n  \n  self.svg_scene <=self.background_canvas\n  self.svg_scene <=self.canvas\n  self.svg_scene <=self.writing_canvas\n  self.svg_scene <=self.turtle_canvas\n  \n  \n def setworldcoordinates(self,llx,lly,urx,ury):\n  ''\n\n\n\n\n\n\n\n\n\n\n  \n  self._mode=\"world\"\n  \n  if urx <llx:\n   sys.stderr.write(\"Warning: urx must be greater than llx; your choice will be reversed\")\n   urx,llx=llx,urx\n  xspan=urx -llx\n  yspan=abs(ury -lly)\n  \n  self.xscale=int(self.width)/xspan\n  self.yscale=int(self.height)/yspan\n  self.x_offset=-llx *self.xscale\n  if ury <lly:\n   self.y_points_down=1\n  else :\n   self.y_points_down=-1\n  self.y_offset=self.y_points_down *lly *self.yscale\n  self.translate_canvas=(self.x_offset,self.height -self.y_offset)\n  self._setup_canvas()\n  \n def show_scene(self):\n  ''\n  \n  for t in self._turtles:\n   self.turtle_canvas <=t.svg\n  if _CFG[\"turtle_canvas_wrapper\"]is None :\n   _CFG[\"turtle_canvas_wrapper\"]=html.DIV(Id=\"turtle-canvas-wrapper\")\n   document <=_CFG[\"turtle_canvas_wrapper\"]\n  if _CFG[\"turtle_canvas_id\"]not in document:\n   _CFG[\"turtle_canvas_wrapper\"]<=self.svg_scene\n  def set_svg():\n  \n   _CFG[\"turtle_canvas_wrapper\"].html=_CFG[\"turtle_canvas_wrapper\"].html\n  timer.set_timeout(set_svg,1)\n  \n  \n def turtles(self):\n  ''\n  \n  return self._turtles\n  \n def _write(self,pos,txt,align,font,color):\n  ''\n  \n  if isinstance(color,tuple):\n   stroke=color[0]\n   fill=color[1]\n  else :\n   fill=color\n   stroke=None\n  x,y=self._convert_coordinates(pos[0],pos[1])\n  text=svg.text(txt,x=x,y=y,fill=fill,\n  style={'display':'none',\n  'font-family':font[0],\n  'font-size':font[1],\n  'font-style':font[2]})\n  \n  if stroke is not None :\n   text.setAttribute('stroke',stroke)\n  if align =='left':\n   text.setAttribute('text-anchor','start')\n  elif align =='center'or align =='centre':\n   text.setAttribute('text-anchor','middle')\n  elif align =='right':\n   text.setAttribute('text-anchor','end')\n   \n  self.frame_index +=1\n  an=svg.animate(Id=\"animation_frame%s\"%self.frame_index,\n  attributeName=\"display\",attributeType=\"CSS\",\n  From=\"block\",to=\"block\",\n  dur=_CFG[\"min_duration\"],fill='freeze')\n  an.setAttribute('begin',\"animation_frame%s.end\"%(self.frame_index -1))\n  text <=an\n  self.writing_canvas <=text\n  \n def addshape(self,*args,**kwargs):\n  sys.stderr.write(\"Warning: Screen.addshape() is not implemented.\\n\")\n  \n def bgpic(self,*args,**kwargs):\n  sys.stderr.write(\"Warning: Screen.bgpic() is not implemented.\\n\")\n  \n def bye(self,*args,**kwargs):\n  sys.stderr.write(\"Warning: Screen.bye() is not implemented.\\n\")\n  \n def clearscreen(self,*args,**kwargs):\n  sys.stderr.write(\"Warning: Screen.clearscreen() is not implemented.\\n\")\n  \n def colormode(self,*args,**kwargs):\n  sys.stderr.write(\"Warning: Screen.colormode() is not implemented.\\n\")\n  \n def delay(self,*args,**kwargs):\n  sys.stderr.write(\"Warning: Screen.delay() is not implemented.\\n\")\n  \n def exitonclick(self,*args,**kwargs):\n  sys.stderr.write(\"Warning: Screen.exitonclick() is not implemented.\\n\")\n  \n def getcanvas(self,*args,**kwargs):\n  sys.stderr.write(\"Warning: Screen.getcanvas() is not implemented.\\n\")\n  \n def getshapes(self,*args,**kwargs):\n  sys.stderr.write(\"Warning: Screen.getshapes() is not implemented.\\n\")\n  \n def addshape(self,*args,**kwargs):\n  sys.stderr.write(\"Warning: Screen.addshape() is not implemented.\\n\")\n  \n def listen(self,*args,**kwargs):\n  sys.stderr.write(\"Warning: Screen.listen() is not implemented.\\n\")\n  \n def mainloop(self,*args,**kwargs):\n  sys.stderr.write(\"Warning: Screen.mainloop() is not implemented.\\n\")\n  \n def numinput(self,*args,**kwargs):\n  sys.stderr.write(\"Warning: Screen.numinput() is not implemented.\\n\")\n  \n def onkey(self,*args,**kwargs):\n  sys.stderr.write(\"Warning: Screen.onkey() is not implemented.\\n\")\n  \n def onkeypress(self,*args,**kwargs):\n  sys.stderr.write(\"Warning: Screen.onkeypress() is not implemented.\\n\")\n  \n def onkeyrelease(self,*args,**kwargs):\n  sys.stderr.write(\"Warning: Screen.onkeyrelease() is not implemented.\\n\")\n  \n def onscreenclick(self,*args,**kwargs):\n  sys.stderr.write(\"Warning: Screen.onscreenclick() is not implemented.\\n\")\n  \n def ontimer(self,*args,**kwargs):\n  sys.stderr.write(\"Warning: Screen.ontimer() is not implemented.\\n\")\n  \n def register_shape(self,*args,**kwargs):\n  sys.stderr.write(\"Warning: Screen.register_shape() is not implemented.\\n\")\n  \n def resetscreen(self,*args,**kwargs):\n  sys.stderr.write(\"Warning: Screen.resetscreen() is not implemented.\\n\")\n  \n def screensize(self,*args,**kwargs):\n  sys.stderr.write(\"Warning: Screen.screensize() is not implemented.\\n\")\n  \n def setup(self,*args,**kwargs):\n  sys.stderr.write(\"Warning: Screen.setup() is not implemented.\\n\")\n  \n def textinput(self,*args,**kwargs):\n  sys.stderr.write(\"Warning: Screen.textinput() is not implemented.\\n\")\n  \n def title(self,*args,**kwargs):\n  sys.stderr.write(\"Warning: Screen.title() is not implemented.\\n\")\n  \n def tracer(self,*args,**kwargs):\n  sys.stderr.write(\"Warning: Screen.tracer() is not implemented.\\n\")\n  \n def update(self,*args,**kwargs):\n  sys.stderr.write(\"Warning: Screen.update() is not implemented.\\n\")\n  \n def window_height(self,*args,**kwargs):\n  sys.stderr.write(\"Warning: Screen.window_height() is not implemented.\\n\")\n  \n def window_width(self,*args,**kwargs):\n  sys.stderr.write(\"Warning: Screen.window_width() is not implemented.\\n\")\n  \n  \nclass TNavigator:\n ''\n\n \n \n \n \n \n DEFAULT_MODE=\"standard\"\n DEFAULT_ANGLEOFFSET=0\n DEFAULT_ANGLEORIENT=1\n \n def __init__(self,mode=DEFAULT_MODE):\n  self._angleOffset=self.DEFAULT_ANGLEOFFSET\n  self._angleOrient=self.DEFAULT_ANGLEORIENT\n  self._mode=mode\n  self.degree_to_radians=math.pi /180\n  self.degrees()\n  self._mode=_CFG['mode']\n  self._setmode(mode)\n  TNavigator.reset(self)\n  \n def reset(self):\n  ''\n\n\n  \n  self._position=(0.0,0.0)\n  self._x=0\n  self._y=0\n  self._angle=0\n  self._old_heading=0\n  \n def _setmode(self,mode=None ):\n  ''\n  \n  if mode is None :\n   return self._mode\n  if mode not in [\"standard\",\"logo\",\"world\"]:\n   print(mode,\"is an unknown mode; it will be ignored.\")\n   return\n  self._mode=mode\n  if mode in [\"standard\",\"world\"]:\n   self._angleOffset=0\n   self._angleOrient=1\n  else :\n   self._angleOffset=-self._fullcircle /4.\n   self._angleOrient=1\n   \n def _setDegreesPerAU(self,fullcircle):\n  ''\n  self._fullcircle=fullcircle\n  self._degreesPerAU=360 /fullcircle\n  \n def degrees(self,fullcircle=360.0):\n  ''\n  \n  self._setDegreesPerAU(fullcircle)\n  \n def radians(self):\n  ''\n  \n  self._setDegreesPerAU(2 *math.pi)\n  \n def _rotate(self,angle):\n  ''\n  pass\n  \n def _goto(self,x,y):\n  pass\n  \n def forward(self,distance):\n  ''\n  \n  x1=distance *cos(self._angle *self.degree_to_radians)\n  y1=distance *sin(self._angle *self.degree_to_radians)\n  self._distance=distance\n  self._goto(self._x+x1,self._y+y1)\n fd=forward\n \n def back(self,distance):\n  ''\n  \n  x1=-distance *cos(self._angle *self.degree_to_radians)\n  y1=-distance *sin(self._angle *self.degree_to_radians)\n  self._distance=distance\n  self._goto(self._x+x1,self._y+y1)\n backward=back\n bk=back\n \n def right(self,angle):\n  ''\n  \n  angle *=self._degreesPerAU\n  self._angle +=self.screen.y_points_down *angle\n  self._rotate_image(-angle)\n rt=right\n \n def left(self,angle):\n  ''\n  \n  angle *=self._degreesPerAU\n  self._angle +=-self.screen.y_points_down *angle\n  self._rotate_image(angle)\n lt=left\n \n def pos(self):\n  ''\n  \n  return FormattedTuple(self._x,self._y)\n position=pos\n \n def xcor(self):\n  ''\n  \n  return self._x\n  \n def ycor(self):\n  ''\n  \n  return self._y\n  \n def goto(self,x,y=None ):\n  ''\n  \n  if y is None :\n   x,y=x[0],x[1]\n   \n   \n   \n   \n   \n   \n   \n   \n  self._distance=abs(self._x -x)+abs(self._y -y)\n  self._goto(x,y)\n setpos=goto\n setposition=goto\n \n \n def home(self):\n  ''\n\n  \n  self.goto(0,0)\n  self.setheading(0)\n  \n def setx(self,x):\n  ''\n  \n  self._distance=abs(x -self._x)\n  self._goto(x,self._y)\n  \n def sety(self,y):\n  ''\n  \n  self._distance=abs(y -self._y)\n  self._goto(self._x,y)\n  \n def distance(self,x,y=None ):\n  ''\n  \n  if y is None :\n   assert isinstance(x,tuple)\n   x,y=x\n  return math.sqrt((self._x -x)**2+(self._y -y)**2)\n  \n def towards(self,x,y=None ):\n  ''\n  \n  if y is None :\n   assert isinstance(x,tuple)\n   x,y=x\n  x,y=x -self._x,y -self._y\n  result=round(math.atan2(y,x)*180.0 /math.pi,10)%360.0\n  result /=self._degreesPerAU\n  return (self._angleOffset+self._angleOrient *result)%self._fullcircle\n  \n def heading(self):\n  ''\n  \n  angle=self._angle /self._degreesPerAU\n  return (self._angleOffset+self._angleOrient *angle)%self._fullcircle\n  \n def setheading(self,to_angle):\n  ''\n  \n  self._rotate(to_angle -self._angle)\n seth=setheading\n \n def circle(self,radius,extent=None ,steps=None ):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  speed=self.speed()\n  if extent is None :\n   extent=self._fullcircle\n  if steps is None :\n   frac=abs(extent)/self._fullcircle\n   steps=1+int(min(11+abs(radius)/6.0,59.0)*frac)\n  w=1.0 *extent /steps\n  w2=0.5 *w\n  l=2.0 *radius *math.sin(w2 *math.pi /180.0 *self._degreesPerAU)\n  if radius <0:\n   l,w,w2=-l,-w,-w2\n  self._rotate(w2)\n  for i in range(steps):\n   self.speed(speed)\n   self.forward(l)\n   self.speed(0)\n   self._rotate(w)\n  self._rotate(-w2)\n  self.speed(speed)\n  \nclass TPen:\n ''\n \n \n def __init__(self):\n  TPen._reset(self)\n  \n def _reset(self,pencolor=_CFG[\"pencolor\"],\n fillcolor=_CFG[\"fillcolor\"]):\n  self._pensize=1\n  self._shown=True\n  self._drawing=True\n  self._pencolor='black'\n  self._fillcolor='black'\n  self._speed=3\n  self._stretchfactor=(1.,1.)\n  \n  \n def resizemode(self,rmode=None ):\n  sys.stderr.write(\"Warning: TPen.resizemode() is not implemented.\\n\")\n  \n def pensize(self,width=None ):\n  ''\n  \n  if width is None :\n   return self._pensize\n  self.pen(pensize=width)\n width=pensize\n \n def pendown(self):\n  ''\n  \n  if self._drawing:\n   return\n  self.pen(pendown=True )\n pd=pendown\n down=pendown\n \n def penup(self):\n  ''\n  \n  if not self._drawing:\n   return\n  self.pen(pendown=False )\n pu=penup\n up=penup\n \n def isdown(self):\n  ''\n  \n  return self._drawing\n  \n def speed(self,speed=None ):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  speeds={'fastest':0,'fast':10,'normal':6,'slow':3,'slowest':1}\n  if speed is None :\n   return self._speed\n  if speed in speeds:\n   speed=speeds[speed]\n  elif 0.5 <speed <10.5:\n   speed=int(round(speed))\n  else :\n   speed=0\n  self.pen(speed=speed)\n  \n def color(self,*args):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  if args:\n   l=len(args)\n   if l ==1:\n    if isinstance(args[0],tuple):\n     pencolor=args[0][0]\n     fillcolor=args[0][1]\n    else :\n     pencolor=fillcolor=args[0]\n   elif l ==2:\n    pencolor,fillcolor=args\n    \n   if not isinstance(pencolor,str)or not isinstance(fillcolor,str):\n    raise TurtleGraphicsError(\"bad color arguments: %s\"%str(args))\n    \n   self.pen(pencolor=pencolor,fillcolor=fillcolor)\n  else :\n   return self._pencolor,self._fillcolor\n   \n def pencolor(self,color=None ):\n  ''\n\n\n\n\n\n  \n  if color is not None :\n   if not isinstance(color,str):\n    raise TurtleGraphicsError(\"bad color arguments: %s\"%str(color))\n   if color ==self._pencolor:\n    return\n   self.pen(pencolor=color)\n  else :\n   return self._pencolor\n   \n def fillcolor(self,color=None ):\n  ''\n\n\n\n\n\n  \n  if color is not None :\n   if not isinstance(color,str):\n    raise TurtleGraphicsError(\"bad color arguments: %s\"%str(color))\n   if color ==self._fillcolor:\n    return\n   self.pen(fillcolor=color)\n  else :\n   return self._pencolor\n   \n def showturtle(self):\n  ''\n  \n  if self._shown:\n   return\n  self.pen(shown=True )\n  self.left(0)\n st=showturtle\n \n def hideturtle(self):\n  ''\n  \n  if self._shown:\n   self.pen(shown=False )\n ht=hideturtle\n \n def isvisible(self):\n  ''\n  \n  return self._shown\n  \n def pen(self,pen=None ,**pendict):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  _pd={\"shown\":self._shown,\n  \"pendown\":self._drawing,\n  \"pencolor\":self._pencolor,\n  \"fillcolor\":self._fillcolor,\n  \"pensize\":self._pensize,\n  \"speed\":self._speed\n  }\n  \n  if not (pen or pendict):\n   return _pd\n   \n  if isinstance(pen,dict):\n   p=pen\n  else :\n   p={}\n  p.update(pendict)\n  \n  _p_buf={}\n  for key in p:\n   _p_buf[key]=_pd[key]\n  if \"pendown\"in p:\n   self._drawing=p[\"pendown\"]\n  if \"pencolor\"in p:\n   old_color=self._pencolor\n   self._pencolor=p[\"pencolor\"]\n   previous_end,new_frame_id=self.screen._new_frame()\n   anim=svg.animate(Id=new_frame_id,begin=previous_end,\n   dur=_CFG[\"min_duration\"],fill=\"freeze\",\n   attributeName=\"stroke\",attributeType=\"XML\",\n   From=old_color,to=self._pencolor)\n   self.svg <=anim\n  if \"pensize\"in p:\n   self._pensize=p[\"pensize\"]\n  if \"fillcolor\"in p:\n   old_color=self._fillcolor\n   self._fillcolor=p[\"fillcolor\"]\n   previous_end,new_frame_id=self.screen._new_frame()\n   anim=svg.animate(Id=new_frame_id,begin=previous_end,\n   dur=_CFG[\"min_duration\"],fill=\"freeze\",\n   attributeName=\"fill\",attributeType=\"XML\",\n   From=old_color,to=self._fillcolor)\n   self.svg <=anim\n  if \"speed\"in p:\n   self._speed=p[\"speed\"]\n  if \"shown\"in p:\n   old_shown=self._shown\n   if old_shown:\n    opacity=0\n    old_opacity=1\n   else :\n    opacity=1\n    old_opacity=0\n   previous_end,new_frame_id=self.screen._new_frame()\n   anim=svg.animate(Id=new_frame_id,begin=previous_end,\n   dur=_CFG[\"min_duration\"],fill=\"freeze\",\n   attributeName=\"opacity\",attributeType=\"XML\",\n   From=old_opacity,to=opacity)\n   self.svg <=anim\n   self.forward(0)\n   self._shown=p[\"shown\"]\n   \n   \n   \nclass Turtle(TPen,TNavigator):\n ''\n\n\n \n _pen=None\n screen=None\n \n def __init__(self,shape=_CFG[\"shape\"],visible=_CFG[\"visible\"]):\n \n  self.screen=Screen()\n  TPen.__init__(self)\n  TNavigator.__init__(self,self.screen.mode())\n  self._poly=None\n  self._creatingPoly=False\n  self._fillitem=self._fillpath=None\n  \n  self.name=shape\n  self.svg,rotation=self.screen.create_svg_turtle(self,name=shape)\n  self.svg.setAttribute(\"opacity\",0)\n  self._shown=False\n  if visible:\n   self.showturtle()\n  self.screen._turtles.append(self)\n  self.rotation_correction=rotation\n  \n  self._old_heading=self.heading()+self.rotation_correction\n  speed=self.speed()\n  self.speed(0)\n  self.left(-self._angleOffset)\n  self.speed(speed)\n  \n def reset(self):\n  ''\n  \n  \n  TNavigator.reset(self)\n  TPen._reset(self)\n  self._old_heading=self.heading()+self.rotation_correction\n  self.home()\n  self.color(_CFG[\"pencolor\"],_CFG[\"fillcolor\"])\n  \n def clear(self):\n  sys.stderr.write(\"Warning: Turtle.clear() is not implemented.\\n\")\n  \n def shape(self,name=None ):\n  ''\n\n  \n  if name is None :\n   return self.name\n  _turtle=self._make_copy(name=name)\n  \n  visible=self.isvisible()\n  if visible:\n   self.hideturtle()\n  self.screen.turtle_canvas <=self.svg\n  self.svg=_turtle\n  self.screen._turtles.append(self)\n  if visible:\n   self.showturtle()\n   \n def clearstamp(self,*args,**kwargs):\n  sys.stderr.write(\"Warning: Turtle.clearstamp() is not implemented.\\n\")\n  \n def clearstamps(self,*args,**kwargs):\n  sys.stderr.write(\"Warning: Turtle.clearstamps() is not implemented.\\n\")\n  \n def onclick(self,*args,**kwargs):\n  sys.stderr.write(\"Warning: Turtle.onclick() is not implemented.\\n\")\n  \n def ondrag(self,*args,**kwargs):\n  sys.stderr.write(\"Warning: Turtle.ondrag() is not implemented.\\n\")\n  \n def onrelease(self,*args,**kwargs):\n  sys.stderr.write(\"Warning: Turtle.onrelease() is not implemented.\\n\")\n  \n def undo(self,*args,**kwargs):\n  sys.stderr.write(\"Warning: Turtle.undo() is not implemented.\\n\")\n  \n def setundobuffer(self,*args,**kwargs):\n  sys.stderr.write(\"Warning: Turtle.setundobuffer() is not implemented.\\n\")\n  \n def undobufferentries(self,*args,**kwargs):\n  sys.stderr.write(\"Warning: Turtle.undobufferentries() is not implemented.\\n\")\n  \n def shapesize(self,*args,**kwargs):\n  sys.stderr.write(\"Warning: Turtle.shapesize() is not implemented.\\n\")\n turtlesize=shapesize\n \n def shearfactor(self,shear=None ):\n  sys.stderr.write(\"Warning: Turtle.shearfactor() is not implemented.\\n\")\n  \n def settiltangle(self,angle):\n  sys.stderr.write(\"Warning: Turtle.settiltangle() is not implemented.\\n\")\n  \n def tiltangle(self,angle=None ):\n  sys.stderr.write(\"Warning: Turtle.tiltangle() is not implemented.\\n\")\n  \n def tilt(self,angle):\n  sys.stderr.write(\"Warning: Turtle.tilt() is not implemented.\\n\")\n  \n def shapetransform(self,t11=None ,t12=None ,t21=None ,t22=None ):\n  sys.stderr.write(\"Warning: Turtle.shapetransform() is not implemented.\\n\")\n  \n def get_shapepoly(self):\n  sys.stderr.write(\"Warning: Turtle.get_shapepoly() is not implemented.\\n\")\n  \n def _goto(self,x,y):\n  ''\n\n\n  \n  \n  begin,duration,_from,_to=self.screen._drawline(self,\n  ((self._x,self._y),(x,y)),\n  (self._pencolor,self._fillcolor),\n  self._pensize,self._speed)\n  if self._shown:\n   self.svg <=svg.animateMotion(begin=begin,dur=_CFG[\"min_duration\"],\n   fill=\"remove\")\n   \n   self.svg <=svg.animateMotion(From=\"%s,%s\"%_from,to=\"%s,%s\"%_to,\n   dur=duration,begin=begin,fill=\"freeze\")\n   \n   \n  if self._fillpath is not None :\n   self._fillpath.append((x,y))\n  self._position=(x,y)\n  self._x=x\n  self._y=y\n  \n  \n def _rotate(self,angle):\n  ''\n  \n  angle *=self._degreesPerAU\n  self._angle +=-self.screen.y_points_down *angle\n  self._rotate_image(angle)\n  \n def _rotate_image(self,angle):\n  new_heading=self._old_heading -angle\n  \n  if self.isvisible():\n   previous_end,new_frame_id=self.screen._new_frame()\n   if self._speed ==0:\n    duration=_CFG[\"min_duration\"]\n   else :\n    duration=(abs(angle)/(self._speed *360))\n    if duration <0.001:\n     duration=_CFG[\"min_duration\"]\n    else :\n     duration=\"%6.3fs\"%duration\n     \n   self.svg <=svg.animateMotion(begin=previous_end,\n   dur=_CFG[\"min_duration\"],fill=\"remove\")\n   self.svg <=svg.animateTransform(attributeName=\"transform\",\n   Id=new_frame_id,\n   type=\"rotate\",\n   From=(self._old_heading,0,0),\n   to=(new_heading,0,0),\n   begin=previous_end,\n   dur=duration,fill=\"freeze\")\n  self._old_heading=new_heading\n  \n def filling(self):\n  ''\n  \n  return self._fillpath is not None\n  \n def begin_fill(self):\n  ''\n  \n  self._fillpath=[(self._x,self._y)]\n  \n def end_fill(self):\n  ''\n  \n  if self.filling()and len(self._fillpath)>2:\n   self.screen._drawpoly(self._fillpath,outline=self._pencolor,\n   fill=self._fillcolor,)\n  else :\n   print(\"No path to fill.\")\n  self._fillpath=None\n  \n def dot(self,size=None ,color=None ):\n  ''\n  \n  item=self.screen._dot((self._x,self._y),size,color=color)\n  \n def _write(self,txt,align,font,color=None ):\n  ''\n  \n  if color is None :\n   color=self._pencolor\n  self.screen._write((self._x,self._y),txt,align,font,color)\n  \n  \n def write(self,arg,align=\"left\",font=(\"Arial\",8,\"normal\"),color=None ):\n  ''\n\n\n\n\n\n\n  \n  self._write(str(arg),align.lower(),font,color=color)\n  \n def begin_poly(self):\n  ''\n  \n  self._poly=[(self._x,self._y)]\n  self._creatingPoly=True\n  \n def end_poly(self):\n  ''\n  \n  self._creatingPoly=False\n  \n def get_poly(self):\n  ''\n  \n  \n  if self._poly is not None :\n   return tuple(self._poly)\n   \n def getscreen(self):\n  ''\n  \n  return self.screen\n  \n def getturtle(self):\n  ''\n\n\n  \n  return self\n getpen=getturtle\n \n def _make_copy(self,name=None ):\n  ''\n\n  \n  \n  if name is None :\n   name=self.name\n   \n   \n   \n   \n   \n  _turtle,rotation=self.screen.create_svg_turtle(self,name=name)\n  _turtle.setAttribute(\"opacity\",0)\n  _turtle.setAttribute(\"fill\",self._fillcolor)\n  _turtle.setAttribute(\"stroke\",self._pencolor)\n  \n  \n  \n  previous_end,new_frame_id=self.screen._new_frame()\n  x,y=self.screen._convert_coordinates(self._x,self._y)\n  _turtle <=svg.animateMotion(begin=previous_end,dur=_CFG[\"min_duration\"],\n  fill=\"remove\")\n  \n  _turtle <=svg.animateMotion(Id=new_frame_id,\n  From=\"%s,%s\"%(x,y),to=\"%s,%s\"%(x,y),\n  dur=_CFG[\"min_duration\"],begin=previous_end,\n  fill=\"freeze\")\n  _turtle <=svg.animateTransform(attributeName=\"transform\",\n  type=\"rotate\",\n  From=(self._old_heading,0,0),\n  to=(self._old_heading,0,0),\n  begin=previous_end,\n  dur=_CFG[\"min_duration\"],fill=\"freeze\")\n  _turtle <=svg.animate(begin=previous_end,\n  dur=_CFG[\"min_duration\"],fill=\"freeze\",\n  attributeName=\"opacity\",attributeType=\"XML\",\n  From=0,to=1)\n  return _turtle\n  \n def stamp(self):\n  ''\n  \n  _turtle=self._make_copy(name=self.name)\n  self.screen.canvas <=_turtle\n  \n  \n def clone(self):\n  ''\n  \n  n=Turtle(self.name)\n  \n  attrs=vars(self)\n  new_dict={}\n  for attr in attrs:\n   if isinstance(getattr(self,attr),(int,str,float)):\n    new_dict[attr]=getattr(self,attr)\n  n.__dict__.update(**new_dict)\n  \n  if not n._shown:\n   n._shown=True\n   n.hideturtle()\n  n.left(0)\n  n.fd(0)\n  n.color(n.color())\n  return n\n  \n  \nPen=Turtle\n\n\ndef done():\n Screen().show_scene()\nshow_scene=done\n\n\ndef replay_scene():\n ''\n if (_CFG[\"turtle_canvas_id\"]in document and\n document[_CFG[\"turtle_canvas_id\"]]is not None ):\n  element=document[_CFG[\"turtle_canvas_id\"]]\n  element.parentNode.removeChild(element)\n show_scene()\n \n \ndef restart():\n ''\n _CFG.update(_cfg_copy)\n Screen().reset()\n Turtle._pen=None\n \n if (_CFG[\"turtle_canvas_id\"]in document and\n document[_CFG[\"turtle_canvas_id\"]]is not None ):\n  element=document[_CFG[\"turtle_canvas_id\"]]\n  element.parentNode.removeChild(element)\n  \n  \n  \n_tg_screen_functions=['addshape','bgcolor','bgpic','bye',\n'clearscreen','colormode','delay','exitonclick','getcanvas',\n'getshapes','listen','mainloop','mode','numinput',\n'onkey','onkeypress','onkeyrelease','onscreenclick','ontimer',\n'register_shape','resetscreen','screensize','setup',\n'setworldcoordinates','textinput','title','tracer','turtles','update',\n'window_height','window_width']\n\n_tg_turtle_functions=['back','backward','begin_fill','begin_poly','bk',\n'circle','clear','clearstamp','clearstamps','clone','color',\n'degrees','distance','dot','down','end_fill','end_poly','fd',\n'fillcolor','filling','forward','get_poly','getpen','getscreen','get_shapepoly',\n'getturtle','goto','heading','hideturtle','home','ht','isdown',\n'isvisible','left','lt','onclick','ondrag','onrelease','pd',\n'pen','pencolor','pendown','pensize','penup','pos','position',\n'pu','radians','right','reset','resizemode','rt',\n'seth','setheading','setpos','setposition','settiltangle',\n'setundobuffer','setx','sety','shape','shapesize','shapetransform','shearfactor','showturtle',\n'speed','st','stamp','tilt','tiltangle','towards',\n'turtlesize','undo','undobufferentries','up','width',\n'write','xcor','ycor']\n\n\n__all__=(_tg_screen_functions+_tg_turtle_functions+\n['done','restart','replay_scene','Turtle','Screen'])\n\n\n\n\n\n__func_body=\"\"\"\\\ndef {name}(*args, **kw):\n    if {obj} is None:\n        {obj} = {init}\n    return {obj}.{name}(*args, **kw)\n\"\"\"\n\ndef _make_global_funcs(functions,cls,obj,init):\n for methodname in functions:\n  try :\n   method=getattr(cls,methodname)\n  except AttributeError:\n   print(\"methodname missing:\",methodname)\n   continue\n  defstr=__func_body.format(obj=obj,init=init,name=methodname)\n  exec(defstr,globals())\n  \n_make_global_funcs(_tg_turtle_functions,Turtle,'Turtle._pen','Turtle()')\n\n_make_global_funcs(_tg_screen_functions,Screen,'Turtle.screen','Screen()')\n", ["_svg", "browser", "browser.html", "browser.timer", "math", "sys"]],
+    "turtle": [".py", "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nimport math\nimport sys\n\nfrom math import cos,sin\n\nfrom browser import console,document,html,timer\nimport _svg as svg\n\n\n\n\n\n\n_CFG={\n\n\n\"canvwidth\":500,\n\"canvheight\":500,\n\n\n\"mode\":\"standard\",\n\n\n\n\"shape\":\"classic\",\n\"pencolor\":\"black\",\n\"fillcolor\":\"black\",\n\n\"visible\":True ,\n\n\n\n\n\n\n\n\"turtle_canvas_wrapper\":None ,\n\"turtle_canvas_id\":\"turtle-canvas\",\n\"min_duration\":\"1ms\"\n}\n\n_cfg_copy=_CFG.copy()\n\n\ndef set_defaults(**params):\n ''\n _CFG.update(**params)\n Screen().reset()\n \n \nclass FormattedTuple(tuple):\n ''\n def __new__(cls,x,y):\n  return tuple.__new__(cls,(x,y))\n def __repr__(self):\n  return \"(%.2f, %.2f)\"%self\n  \ndef create_circle(r):\n ''\n circle=svg.circle(x=0,y=0,r=r,stroke=\"black\",fill=\"black\")\n circle.setAttribute(\"stroke-width\",1)\n return circle\n \n \ndef create_polygon(points):\n ''\n points=[\"%s,%s \"%(x,y)for x,y in points]\n polygon=svg.polygon(points=points,stroke=\"black\",fill=\"black\")\n polygon.setAttribute(\"stroke-width\",1)\n return polygon\n \n \ndef create_rectangle(width=2,height=2,rx=None ,ry=None ):\n ''\n \n rectangle=svg.rect(x=-width /2,y=-height /2,width=width,\n height=height,stroke=\"black\",fill=\"black\")\n rectangle.setAttribute(\"stroke-width\",1)\n if rx is not None :\n  rectangle.setAttribute(\"rx\",rx)\n if ry is not None :\n  rectangle.setAttribute(\"ry\",ry)\n return rectangle\n \n \ndef create_square(size=2,r=None ):\n ''\n \n return create_rectangle(width=size,height=size,rx=r,ry=r)\n \n \nclass TurtleGraphicsError(Exception):\n ''\n \n pass\n \n \nclass Singleton(type):\n _instances={}\n def __call__(cls,*args,**kwargs):\n  if cls not in cls._instances:\n   cls._instances[cls]=super(Singleton,cls).__call__(*args,**kwargs)\n  return cls._instances[cls]\n  \n  \nclass Screen(metaclass=Singleton):\n\n def __init__(self):\n  self.shapes={\n  'arrow':(create_polygon,((-10,0),(10,0),(0,10))),\n  'turtle':(create_polygon,((0,16),(-2,14),(-1,10),(-4,7),\n  (-7,9),(-9,8),(-6,5),(-7,1),(-5,-3),(-8,-6),\n  (-6,-8),(-4,-5),(0,-7),(4,-5),(6,-8),(8,-6),\n  (5,-3),(7,1),(6,5),(9,8),(7,9),(4,7),(1,10),\n  (2,14))),\n  'classic':(create_polygon,((0,0),(-5,-9),(0,-7),(5,-9))),\n  'triangle':(create_polygon,((10,-5.77),(0,11.55),(-10,-5.77))),\n  'square':(create_square,20),\n  'circle':(create_circle,10)\n  }\n  self.reset()\n  self._set_geometry()\n  \n def bgcolor(self,color=None ):\n  ''\n\n  \n  if color is None :\n   return self.background_color\n  self.background_color=color\n  width=_CFG['canvwidth']\n  height=_CFG['canvheight']\n  if self.mode()in ['logo','standard']:\n   x=-width //2\n   y=-height //2\n  else :\n   x=0\n   y=-height\n   \n  self.frame_index +=1\n  rect=svg.rect(x=x,y=y,width=width,height=height,fill=color,\n  style={'display':'none'})\n  an=svg.animate(Id=\"animation_frame%s\"%self.frame_index,\n  attributeName=\"display\",attributeType=\"CSS\",\n  From=\"block\",to=\"block\",\n  dur=_CFG[\"min_duration\"],fill='freeze')\n  an.setAttribute('begin',\"animation_frame%s.end\"%(self.frame_index -1))\n  rect <=an\n  \n  self.background_canvas <=rect\n  \n def _convert_coordinates(self,x,y):\n  ''\n\n\n\n\n\n  \n  return x *self.yscale,self.y_points_down *y *self.yscale\n  \n  \n def create_svg_turtle(self,_turtle,name):\n  if name in self.shapes:\n   fn=self.shapes[name][0]\n   arg=self.shapes[name][1]\n  else :\n   print(\"Unknown turtle '%s'; the default turtle will be used\")\n   fn=self.shapes[_CVG[\"shape\"]][0]\n   arg=self.shapes[_CVG[\"shape\"]][1]\n  shape=fn(arg)\n  if self._mode =='standard'or self._mode =='world':\n   rotation=-90\n  else :\n   rotation=0\n  return shape,rotation\n  \n def _dot(self,pos,size,color):\n  ''\n  if color is None :\n   color='black'\n  if size is None or size <1:\n   size=1\n  self.frame_index +=1\n  \n  \n  radius=size /2\n  \n  x,y=self._convert_coordinates(pos[0],pos[1])\n  \n  circle=svg.circle(cx=x,cy=y,r=radius,fill=color,\n  style={'display':'none'})\n  an=svg.animate(Id=\"animation_frame%s\"%self.frame_index,\n  attributeName=\"display\",attributeType=\"CSS\",\n  From=\"block\",to=\"block\",\n  dur=_CFG[\"min_duration\"],fill='freeze')\n  an.setAttribute('begin',\"animation_frame%s.end\"%(self.frame_index -1))\n  circle <=an\n  self.canvas <=circle\n  \n def _drawline(self,_turtle,coordlist=None ,\n color=None ,width=1,speed=None ):\n  ''\n\n\n\n\n  \n  \n  outline=color[0]\n  fill=color[1]\n  \n  x0,y0=coordlist[0]\n  x1,y1=coordlist[1]\n  \n  x0,y0=self._convert_coordinates(x0,y0)\n  x1,y1=self._convert_coordinates(x1,y1)\n  \n  \n  if speed ==0:\n   duration=_CFG[\"min_duration\"]\n  else :\n   dist=_turtle._distance\n   if speed is None or speed ==1:\n    duration=0.02 *dist\n   else :\n    duration=0.02 *dist /speed **1.2\n   if duration <0.001:\n    duration=_CFG[\"min_duration\"]\n   else :\n    duration=\"%6.3fs\"%duration\n    \n  drawing=_turtle._drawing\n  \n  _line=svg.line(x1=x0,y1=y0,x2=x0,y2=y0,\n  style={'stroke':outline,'stroke-width':width})\n  if not drawing:\n   _line.setAttribute('opacity',0)\n   \n   \n  begin=\"animation_frame%s.end\"%self.frame_index\n  self.frame_index +=1\n  _an1=svg.animate(Id=\"animation_frame%s\"%self.frame_index,\n  attributeName=\"x2\",attributeType=\"XML\",\n  From=x0,to=x1,dur=duration,fill='freeze',\n  begin=begin)\n  _line <=_an1\n  \n  \n  if drawing:\n   _an2=svg.animate(attributeName=\"y2\",attributeType=\"XML\",\n   begin=begin,\n   From=y0,to=y1,dur=duration,fill='freeze')\n   _line <=_an2\n   \n   if width >2:\n    _line_cap=svg.set(attributeName=\"stroke-linecap\",\n    begin=begin,\n    attributeType=\"xml\",to=\"round\",dur=duration,fill='freeze')\n    _line <=_line_cap\n    \n  self.canvas <=_line\n  return begin,duration,(x0,y0),(x1,y1)\n  \n def _drawpoly(self,coordlist,outline=None ,fill=None ,width=None ):\n  ''\n\n\n\n\n  \n  self.frame_index +=1\n  shape=[\"%s,%s\"%self._convert_coordinates(x,y)for x,y in coordlist]\n  \n  style={'display':'none'}\n  if fill is not None :\n   style['fill']=fill\n  if outline is not None :\n   style['stroke']=outline\n   if width is not None :\n    style['stroke-width']=width\n   else :\n    style['stroke-width']=1\n    \n  polygon=svg.polygon(points=\" \".join(shape),style=style)\n  \n  an=svg.animate(Id=\"animation_frame%s\"%self.frame_index,\n  attributeName=\"display\",attributeType=\"CSS\",\n  From=\"block\",to=\"block\",\n  dur=_CFG[\"min_duration\"],fill='freeze')\n  \n  an.setAttribute('begin',\"animation_frame%s.end\"%(self.frame_index -1))\n  polygon <=an\n  self.canvas <=polygon\n  \n  \n def _new_frame(self):\n  ''\n  \n  previous_end=\"animation_frame%s.end\"%self.frame_index\n  self.frame_index +=1\n  new_frame_id=\"animation_frame%s\"%self.frame_index\n  return previous_end,new_frame_id\n  \n def mode(self,_mode=None ):\n  if _mode is None :\n   return self._mode\n  _CFG['mode']=_mode\n  self.reset()\n  \n  \n def reset(self):\n  self._turtles=[]\n  self.frame_index=0\n  self.background_color=\"white\"\n  self._set_geometry()\n  \n def _set_geometry(self):\n  self.width=_CFG[\"canvwidth\"]\n  self.height=_CFG[\"canvheight\"]\n  self.x_offset=self.y_offset=0\n  self.xscale=self.yscale=1\n  \n  self.y_points_down=-1\n  self._mode=_CFG[\"mode\"].lower()\n  if self._mode in ['logo','standard']:\n   self.translate_canvas=(self.width //2,self.height //2)\n  elif self._mode =='world':\n   self.translate_canvas=(0,self.height)\n  self._setup_canvas()\n  \n def _setup_canvas(self):\n  self.svg_scene=svg.svg(Id=_CFG[\"turtle_canvas_id\"],width=self.width,\n  height=self.height)\n  translate=\"translate(%d %d)\"%self.translate_canvas\n  \n  \n  self.svg_scene <=svg.animate(\n  Id=\"animation_frame%s\"%self.frame_index,\n  attributeName=\"width\",attributeType=\"CSS\",\n  From=self.width,to=self.width,begin=\"0s\",\n  dur=_CFG[\"min_duration\"],fill='freeze')\n  \n  \n  \n  \n  self.background_canvas=svg.g(transform=translate)\n  self.canvas=svg.g(transform=translate)\n  self.writing_canvas=svg.g(transform=translate)\n  self.turtle_canvas=svg.g(transform=translate)\n  \n  self.svg_scene <=self.background_canvas\n  self.svg_scene <=self.canvas\n  self.svg_scene <=self.writing_canvas\n  self.svg_scene <=self.turtle_canvas\n  \n  \n def setworldcoordinates(self,llx,lly,urx,ury):\n  ''\n\n\n\n\n\n\n\n\n\n\n  \n  self._mode=\"world\"\n  \n  if urx <llx:\n   sys.stderr.write(\"Warning: urx must be greater than llx; your choice will be reversed\")\n   urx,llx=llx,urx\n  xspan=urx -llx\n  yspan=abs(ury -lly)\n  \n  self.xscale=int(self.width)/xspan\n  self.yscale=int(self.height)/yspan\n  self.x_offset=-llx *self.xscale\n  if ury <lly:\n   self.y_points_down=1\n  else :\n   self.y_points_down=-1\n  self.y_offset=self.y_points_down *lly *self.yscale\n  self.translate_canvas=(self.x_offset,self.height -self.y_offset)\n  self._setup_canvas()\n  \n def show_scene(self):\n  ''\n  \n  for t in self._turtles:\n   self.turtle_canvas <=t.svg\n  if _CFG[\"turtle_canvas_wrapper\"]is None :\n   _CFG[\"turtle_canvas_wrapper\"]=html.DIV(Id=\"turtle-canvas-wrapper\")\n   document <=_CFG[\"turtle_canvas_wrapper\"]\n  if _CFG[\"turtle_canvas_id\"]not in document:\n   _CFG[\"turtle_canvas_wrapper\"]<=self.svg_scene\n  def set_svg():\n  \n   _CFG[\"turtle_canvas_wrapper\"].html=_CFG[\"turtle_canvas_wrapper\"].html\n  timer.set_timeout(set_svg,1)\n  \n  \n def turtles(self):\n  ''\n  \n  return self._turtles\n  \n def _write(self,pos,txt,align,font,color):\n  ''\n  \n  if isinstance(color,tuple):\n   stroke=color[0]\n   fill=color[1]\n  else :\n   fill=color\n   stroke=None\n  x,y=self._convert_coordinates(pos[0],pos[1])\n  text=svg.text(txt,x=x,y=y,fill=fill,\n  style={'display':'none',\n  'font-family':font[0],\n  'font-size':font[1],\n  'font-style':font[2]})\n  \n  if stroke is not None :\n   text.setAttribute('stroke',stroke)\n  if align =='left':\n   text.setAttribute('text-anchor','start')\n  elif align =='center'or align =='centre':\n   text.setAttribute('text-anchor','middle')\n  elif align =='right':\n   text.setAttribute('text-anchor','end')\n   \n  self.frame_index +=1\n  an=svg.animate(Id=\"animation_frame%s\"%self.frame_index,\n  attributeName=\"display\",attributeType=\"CSS\",\n  From=\"block\",to=\"block\",\n  dur=_CFG[\"min_duration\"],fill='freeze')\n  an.setAttribute('begin',\"animation_frame%s.end\"%(self.frame_index -1))\n  text <=an\n  self.writing_canvas <=text\n  \n def addshape(self,*args,**kwargs):\n  sys.stderr.write(\"Warning: Screen.addshape() is not implemented.\\n\")\n  \n def bgpic(self,*args,**kwargs):\n  sys.stderr.write(\"Warning: Screen.bgpic() is not implemented.\\n\")\n  \n def bye(self,*args,**kwargs):\n  sys.stderr.write(\"Warning: Screen.bye() is not implemented.\\n\")\n  \n def clearscreen(self,*args,**kwargs):\n  sys.stderr.write(\"Warning: Screen.clearscreen() is not implemented.\\n\")\n  \n def colormode(self,*args,**kwargs):\n  sys.stderr.write(\"Warning: Screen.colormode() is not implemented.\\n\")\n  \n def delay(self,*args,**kwargs):\n  sys.stderr.write(\"Warning: Screen.delay() is not implemented.\\n\")\n  \n def exitonclick(self,*args,**kwargs):\n  sys.stderr.write(\"Warning: Screen.exitonclick() is not implemented.\\n\")\n  \n def getcanvas(self,*args,**kwargs):\n  sys.stderr.write(\"Warning: Screen.getcanvas() is not implemented.\\n\")\n  \n def getshapes(self,*args,**kwargs):\n  sys.stderr.write(\"Warning: Screen.getshapes() is not implemented.\\n\")\n  \n def addshape(self,*args,**kwargs):\n  sys.stderr.write(\"Warning: Screen.addshape() is not implemented.\\n\")\n  \n def listen(self,*args,**kwargs):\n  sys.stderr.write(\"Warning: Screen.listen() is not implemented.\\n\")\n  \n def mainloop(self,*args,**kwargs):\n  sys.stderr.write(\"Warning: Screen.mainloop() is not implemented.\\n\")\n  \n def numinput(self,*args,**kwargs):\n  sys.stderr.write(\"Warning: Screen.numinput() is not implemented.\\n\")\n  \n def onkey(self,*args,**kwargs):\n  sys.stderr.write(\"Warning: Screen.onkey() is not implemented.\\n\")\n  \n def onkeypress(self,*args,**kwargs):\n  sys.stderr.write(\"Warning: Screen.onkeypress() is not implemented.\\n\")\n  \n def onkeyrelease(self,*args,**kwargs):\n  sys.stderr.write(\"Warning: Screen.onkeyrelease() is not implemented.\\n\")\n  \n def onscreenclick(self,*args,**kwargs):\n  sys.stderr.write(\"Warning: Screen.onscreenclick() is not implemented.\\n\")\n  \n def ontimer(self,*args,**kwargs):\n  sys.stderr.write(\"Warning: Screen.ontimer() is not implemented.\\n\")\n  \n def register_shape(self,*args,**kwargs):\n  sys.stderr.write(\"Warning: Screen.register_shape() is not implemented.\\n\")\n  \n def resetscreen(self,*args,**kwargs):\n  sys.stderr.write(\"Warning: Screen.resetscreen() is not implemented.\\n\")\n  \n def screensize(self,*args,**kwargs):\n  sys.stderr.write(\"Warning: Screen.screensize() is not implemented.\\n\")\n  \n def setup(self,*args,**kwargs):\n  sys.stderr.write(\"Warning: Screen.setup() is not implemented.\\n\")\n  \n def textinput(self,*args,**kwargs):\n  sys.stderr.write(\"Warning: Screen.textinput() is not implemented.\\n\")\n  \n def title(self,*args,**kwargs):\n  sys.stderr.write(\"Warning: Screen.title() is not implemented.\\n\")\n  \n def tracer(self,*args,**kwargs):\n  sys.stderr.write(\"Warning: Screen.tracer() is not implemented.\\n\")\n  \n def update(self,*args,**kwargs):\n  sys.stderr.write(\"Warning: Screen.update() is not implemented.\\n\")\n  \n def window_height(self,*args,**kwargs):\n  sys.stderr.write(\"Warning: Screen.window_height() is not implemented.\\n\")\n  \n def window_width(self,*args,**kwargs):\n  sys.stderr.write(\"Warning: Screen.window_width() is not implemented.\\n\")\n  \n  \nclass TNavigator:\n ''\n\n \n \n \n \n \n DEFAULT_MODE=\"standard\"\n DEFAULT_ANGLEOFFSET=0\n DEFAULT_ANGLEORIENT=1\n \n def __init__(self,mode=DEFAULT_MODE):\n  self._angleOffset=self.DEFAULT_ANGLEOFFSET\n  self._angleOrient=self.DEFAULT_ANGLEORIENT\n  self._mode=mode\n  self.degree_to_radians=math.pi /180\n  self.degrees()\n  self._mode=_CFG['mode']\n  self._setmode(mode)\n  TNavigator.reset(self)\n  \n def reset(self):\n  ''\n\n\n  \n  self._position=(0.0,0.0)\n  self._x=0\n  self._y=0\n  self._angle=0\n  self._old_heading=0\n  \n def _setmode(self,mode=None ):\n  ''\n  \n  if mode is None :\n   return self._mode\n  if mode not in [\"standard\",\"logo\",\"world\"]:\n   print(mode,\"is an unknown mode; it will be ignored.\")\n   return\n  self._mode=mode\n  if mode in [\"standard\",\"world\"]:\n   self._angleOffset=0\n   self._angleOrient=1\n  else :\n   self._angleOffset=-self._fullcircle /4.\n   self._angleOrient=1\n   \n def _setDegreesPerAU(self,fullcircle):\n  ''\n  self._fullcircle=fullcircle\n  self._degreesPerAU=360 /fullcircle\n  \n def degrees(self,fullcircle=360.0):\n  ''\n  \n  self._setDegreesPerAU(fullcircle)\n  \n def radians(self):\n  ''\n  \n  self._setDegreesPerAU(2 *math.pi)\n  \n def _rotate(self,angle):\n  ''\n  pass\n  \n def _goto(self,x,y):\n  pass\n  \n def forward(self,distance):\n  ''\n  \n  x1=distance *cos(self._angle *self.degree_to_radians)\n  y1=distance *sin(self._angle *self.degree_to_radians)\n  self._distance=distance\n  self._goto(self._x+x1,self._y+y1)\n fd=forward\n \n def back(self,distance):\n  ''\n  \n  x1=-distance *cos(self._angle *self.degree_to_radians)\n  y1=-distance *sin(self._angle *self.degree_to_radians)\n  self._distance=distance\n  self._goto(self._x+x1,self._y+y1)\n backward=back\n bk=back\n \n def right(self,angle):\n  ''\n  \n  angle *=self._degreesPerAU\n  self._angle +=self.screen.y_points_down *angle\n  self._rotate_image(-angle)\n rt=right\n \n def left(self,angle):\n  ''\n  \n  angle *=self._degreesPerAU\n  self._angle +=-self.screen.y_points_down *angle\n  self._rotate_image(angle)\n lt=left\n \n def pos(self):\n  ''\n  \n  return FormattedTuple(self._x,self._y)\n position=pos\n \n def xcor(self):\n  ''\n  \n  return self._x\n  \n def ycor(self):\n  ''\n  \n  return self._y\n  \n def goto(self,x,y=None ):\n  ''\n  \n  if y is None :\n   x,y=x[0],x[1]\n   \n   \n   \n   \n   \n   \n   \n   \n  self._distance=abs(self._x -x)+abs(self._y -y)\n  self._goto(x,y)\n setpos=goto\n setposition=goto\n \n \n def home(self):\n  ''\n\n  \n  self.goto(0,0)\n  self.setheading(0)\n  \n def setx(self,x):\n  ''\n  \n  self._distance=abs(x -self._x)\n  self._goto(x,self._y)\n  \n def sety(self,y):\n  ''\n  \n  self._distance=abs(y -self._y)\n  self._goto(self._x,y)\n  \n def distance(self,x,y=None ):\n  ''\n  \n  if y is None :\n   assert isinstance(x,tuple)\n   x,y=x\n  return math.sqrt((self._x -x)**2+(self._y -y)**2)\n  \n def towards(self,x,y=None ):\n  ''\n  \n  if y is None :\n   assert isinstance(x,tuple)\n   x,y=x\n  x,y=x -self._x,y -self._y\n  result=round(math.atan2(y,x)*180.0 /math.pi,10)%360.0\n  result /=self._degreesPerAU\n  return (self._angleOffset+self._angleOrient *result)%self._fullcircle\n  \n def heading(self):\n  ''\n  \n  angle=self._angle /self._degreesPerAU\n  return (self._angleOffset+self._angleOrient *angle)%self._fullcircle\n  \n def setheading(self,to_angle):\n  ''\n  \n  self._rotate(to_angle -self._angle)\n seth=setheading\n \n def circle(self,radius,extent=None ,steps=None ):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  speed=self.speed()\n  if extent is None :\n   extent=self._fullcircle\n  if steps is None :\n   frac=abs(extent)/self._fullcircle\n   steps=1+int(min(11+abs(radius)/6.0,59.0)*frac)\n  w=1.0 *extent /steps\n  w2=0.5 *w\n  l=2.0 *radius *math.sin(w2 *math.pi /180.0 *self._degreesPerAU)\n  if radius <0:\n   l,w,w2=-l,-w,-w2\n  self._rotate(w2)\n  for i in range(steps):\n   self.speed(speed)\n   self.forward(l)\n   self.speed(0)\n   self._rotate(w)\n  self._rotate(-w2)\n  self.speed(speed)\n  \nclass TPen:\n ''\n \n \n def __init__(self):\n  TPen._reset(self)\n  \n def _reset(self,pencolor=_CFG[\"pencolor\"],\n fillcolor=_CFG[\"fillcolor\"]):\n  self._pensize=1\n  self._shown=True\n  self._drawing=True\n  self._pencolor='black'\n  self._fillcolor='black'\n  self._speed=3\n  self._stretchfactor=(1.,1.)\n  \n  \n def resizemode(self,rmode=None ):\n  sys.stderr.write(\"Warning: TPen.resizemode() is not implemented.\\n\")\n  \n def pensize(self,width=None ):\n  ''\n  \n  if width is None :\n   return self._pensize\n  self.pen(pensize=width)\n width=pensize\n \n def pendown(self):\n  ''\n  \n  if self._drawing:\n   return\n  self.pen(pendown=True )\n pd=pendown\n down=pendown\n \n def penup(self):\n  ''\n  \n  if not self._drawing:\n   return\n  self.pen(pendown=False )\n pu=penup\n up=penup\n \n def isdown(self):\n  ''\n  \n  return self._drawing\n  \n def speed(self,speed=None ):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  speeds={'fastest':0,'fast':10,'normal':6,'slow':3,'slowest':1}\n  if speed is None :\n   return self._speed\n  if speed in speeds:\n   speed=speeds[speed]\n  elif 0.5 <speed <10.5:\n   speed=int(round(speed))\n  else :\n   speed=0\n  self.pen(speed=speed)\n  \n def color(self,*args):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  if args:\n   l=len(args)\n   if l ==1:\n    if isinstance(args[0],tuple):\n     pencolor=args[0][0]\n     fillcolor=args[0][1]\n    else :\n     pencolor=fillcolor=args[0]\n   elif l ==2:\n    pencolor,fillcolor=args\n    \n   if not isinstance(pencolor,str)or not isinstance(fillcolor,str):\n    raise TurtleGraphicsError(\"bad color arguments: %s\"%str(args))\n    \n   self.pen(pencolor=pencolor,fillcolor=fillcolor)\n  else :\n   return self._pencolor,self._fillcolor\n   \n def pencolor(self,color=None ):\n  ''\n\n\n\n\n\n  \n  if color is not None :\n   if not isinstance(color,str):\n    raise TurtleGraphicsError(\"bad color arguments: %s\"%str(color))\n   if color ==self._pencolor:\n    return\n   self.pen(pencolor=color)\n  else :\n   return self._pencolor\n   \n def fillcolor(self,color=None ):\n  ''\n\n\n\n\n\n  \n  if color is not None :\n   if not isinstance(color,str):\n    raise TurtleGraphicsError(\"bad color arguments: %s\"%str(color))\n   if color ==self._fillcolor:\n    return\n   self.pen(fillcolor=color)\n  else :\n   return self._pencolor\n   \n def showturtle(self):\n  ''\n  \n  if self._shown:\n   return\n  self.pen(shown=True )\n  self.left(0)\n st=showturtle\n \n def hideturtle(self):\n  ''\n  \n  if self._shown:\n   self.pen(shown=False )\n ht=hideturtle\n \n def isvisible(self):\n  ''\n  \n  return self._shown\n  \n def pen(self,pen=None ,**pendict):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  _pd={\"shown\":self._shown,\n  \"pendown\":self._drawing,\n  \"pencolor\":self._pencolor,\n  \"fillcolor\":self._fillcolor,\n  \"pensize\":self._pensize,\n  \"speed\":self._speed\n  }\n  \n  if not (pen or pendict):\n   return _pd\n   \n  if isinstance(pen,dict):\n   p=pen\n  else :\n   p={}\n  p.update(pendict)\n  \n  _p_buf={}\n  for key in p:\n   _p_buf[key]=_pd[key]\n  if \"pendown\"in p:\n   self._drawing=p[\"pendown\"]\n  if \"pencolor\"in p:\n   old_color=self._pencolor\n   self._pencolor=p[\"pencolor\"]\n   previous_end,new_frame_id=self.screen._new_frame()\n   anim=svg.animate(Id=new_frame_id,begin=previous_end,\n   dur=_CFG[\"min_duration\"],fill=\"freeze\",\n   attributeName=\"stroke\",attributeType=\"XML\",\n   From=old_color,to=self._pencolor)\n   self.svg <=anim\n  if \"pensize\"in p:\n   self._pensize=p[\"pensize\"]\n  if \"fillcolor\"in p:\n   old_color=self._fillcolor\n   self._fillcolor=p[\"fillcolor\"]\n   previous_end,new_frame_id=self.screen._new_frame()\n   anim=svg.animate(Id=new_frame_id,begin=previous_end,\n   dur=_CFG[\"min_duration\"],fill=\"freeze\",\n   attributeName=\"fill\",attributeType=\"XML\",\n   From=old_color,to=self._fillcolor)\n   self.svg <=anim\n  if \"speed\"in p:\n   self._speed=p[\"speed\"]\n  if \"shown\"in p:\n   old_shown=self._shown\n   if old_shown:\n    opacity=0\n    old_opacity=1\n   else :\n    opacity=1\n    old_opacity=0\n   previous_end,new_frame_id=self.screen._new_frame()\n   anim=svg.animate(Id=new_frame_id,begin=previous_end,\n   dur=_CFG[\"min_duration\"],fill=\"freeze\",\n   attributeName=\"opacity\",attributeType=\"XML\",\n   From=old_opacity,to=opacity)\n   self.svg <=anim\n   self.forward(0)\n   self._shown=p[\"shown\"]\n   \n   \n   \nclass Turtle(TPen,TNavigator):\n ''\n\n\n \n _pen=None\n screen=None\n \n def __init__(self,shape=_CFG[\"shape\"],visible=_CFG[\"visible\"]):\n \n  self.screen=Screen()\n  TPen.__init__(self)\n  TNavigator.__init__(self,self.screen.mode())\n  self._poly=None\n  self._creatingPoly=False\n  self._fillitem=self._fillpath=None\n  \n  self.name=shape\n  self.svg,rotation=self.screen.create_svg_turtle(self,name=shape)\n  self.svg.setAttribute(\"opacity\",0)\n  self._shown=False\n  if visible:\n   self.showturtle()\n  self.screen._turtles.append(self)\n  self.rotation_correction=rotation\n  \n  self._old_heading=self.heading()+self.rotation_correction\n  speed=self.speed()\n  self.speed(0)\n  self.left(-self._angleOffset)\n  self.speed(speed)\n  \n def reset(self):\n  ''\n  \n  \n  TNavigator.reset(self)\n  TPen._reset(self)\n  self._old_heading=self.heading()+self.rotation_correction\n  self.home()\n  self.color(_CFG[\"pencolor\"],_CFG[\"fillcolor\"])\n  \n def clear(self):\n  sys.stderr.write(\"Warning: Turtle.clear() is not implemented.\\n\")\n  \n def shape(self,name=None ):\n  ''\n\n  \n  if name is None :\n   return self.name\n  _turtle=self._make_copy(name=name)\n  \n  visible=self.isvisible()\n  if visible:\n   self.hideturtle()\n  self.screen.turtle_canvas <=self.svg\n  self.svg=_turtle\n  self.screen._turtles.append(self)\n  if visible:\n   self.showturtle()\n   \n def clearstamp(self,*args,**kwargs):\n  sys.stderr.write(\"Warning: Turtle.clearstamp() is not implemented.\\n\")\n  \n def clearstamps(self,*args,**kwargs):\n  sys.stderr.write(\"Warning: Turtle.clearstamps() is not implemented.\\n\")\n  \n def onclick(self,*args,**kwargs):\n  sys.stderr.write(\"Warning: Turtle.onclick() is not implemented.\\n\")\n  \n def ondrag(self,*args,**kwargs):\n  sys.stderr.write(\"Warning: Turtle.ondrag() is not implemented.\\n\")\n  \n def onrelease(self,*args,**kwargs):\n  sys.stderr.write(\"Warning: Turtle.onrelease() is not implemented.\\n\")\n  \n def undo(self,*args,**kwargs):\n  sys.stderr.write(\"Warning: Turtle.undo() is not implemented.\\n\")\n  \n def setundobuffer(self,*args,**kwargs):\n  sys.stderr.write(\"Warning: Turtle.setundobuffer() is not implemented.\\n\")\n  \n def undobufferentries(self,*args,**kwargs):\n  sys.stderr.write(\"Warning: Turtle.undobufferentries() is not implemented.\\n\")\n  \n def shapesize(self,*args,**kwargs):\n  sys.stderr.write(\"Warning: Turtle.shapesize() is not implemented.\\n\")\n turtlesize=shapesize\n \n def shearfactor(self,shear=None ):\n  sys.stderr.write(\"Warning: Turtle.shearfactor() is not implemented.\\n\")\n  \n def settiltangle(self,angle):\n  sys.stderr.write(\"Warning: Turtle.settiltangle() is not implemented.\\n\")\n  \n def tiltangle(self,angle=None ):\n  sys.stderr.write(\"Warning: Turtle.tiltangle() is not implemented.\\n\")\n  \n def tilt(self,angle):\n  sys.stderr.write(\"Warning: Turtle.tilt() is not implemented.\\n\")\n  \n def shapetransform(self,t11=None ,t12=None ,t21=None ,t22=None ):\n  sys.stderr.write(\"Warning: Turtle.shapetransform() is not implemented.\\n\")\n  \n def get_shapepoly(self):\n  sys.stderr.write(\"Warning: Turtle.get_shapepoly() is not implemented.\\n\")\n  \n def _goto(self,x,y):\n  ''\n\n\n  \n  \n  begin,duration,_from,_to=self.screen._drawline(self,\n  ((self._x,self._y),(x,y)),\n  (self._pencolor,self._fillcolor),\n  self._pensize,self._speed)\n  if self._shown:\n   self.svg <=svg.animateMotion(begin=begin,dur=_CFG[\"min_duration\"],\n   fill=\"remove\")\n   \n   self.svg <=svg.animateMotion(From=\"%s,%s\"%_from,to=\"%s,%s\"%_to,\n   dur=duration,begin=begin,fill=\"freeze\")\n   \n   \n  if self._fillpath is not None :\n   self._fillpath.append((x,y))\n  self._position=(x,y)\n  self._x=x\n  self._y=y\n  \n  \n def _rotate(self,angle):\n  ''\n  \n  angle *=self._degreesPerAU\n  self._angle +=-self.screen.y_points_down *angle\n  self._rotate_image(angle)\n  \n def _rotate_image(self,angle):\n  new_heading=self._old_heading -angle\n  \n  if self.isvisible():\n   previous_end,new_frame_id=self.screen._new_frame()\n   if self._speed ==0:\n    duration=_CFG[\"min_duration\"]\n   else :\n    duration=(abs(angle)/(self._speed *360))\n    if duration <0.001:\n     duration=_CFG[\"min_duration\"]\n    else :\n     duration=\"%6.3fs\"%duration\n     \n   self.svg <=svg.animateMotion(begin=previous_end,\n   dur=_CFG[\"min_duration\"],fill=\"remove\")\n   self.svg <=svg.animateTransform(attributeName=\"transform\",\n   Id=new_frame_id,\n   type=\"rotate\",\n   From=(self._old_heading,0,0),\n   to=(new_heading,0,0),\n   begin=previous_end,\n   dur=duration,fill=\"freeze\")\n  self._old_heading=new_heading\n  \n def filling(self):\n  ''\n  \n  return self._fillpath is not None\n  \n def begin_fill(self):\n  ''\n  \n  self._fillpath=[(self._x,self._y)]\n  \n def end_fill(self):\n  ''\n  \n  if self.filling()and len(self._fillpath)>2:\n   self.screen._drawpoly(self._fillpath,outline=self._pencolor,\n   fill=self._fillcolor,)\n  else :\n   print(\"No path to fill.\")\n  self._fillpath=None\n  \n def dot(self,size=None ,color=None ):\n  ''\n  \n  if size is None :\n   size=max(self._pensize+4,2 *self._pensize)\n  if color is None :\n   color=self._pencolor\n  item=self.screen._dot((self._x,self._y),size,color=color)\n  \n def _write(self,txt,align,font,color=None ):\n  ''\n  \n  if color is None :\n   color=self._pencolor\n  self.screen._write((self._x,self._y),txt,align,font,color)\n  \n  \n def write(self,arg,align=\"left\",font=(\"Arial\",8,\"normal\"),color=None ):\n  ''\n\n\n\n\n\n\n  \n  self._write(str(arg),align.lower(),font,color=color)\n  \n def begin_poly(self):\n  ''\n  \n  self._poly=[(self._x,self._y)]\n  self._creatingPoly=True\n  \n def end_poly(self):\n  ''\n  \n  self._creatingPoly=False\n  \n def get_poly(self):\n  ''\n  \n  \n  if self._poly is not None :\n   return tuple(self._poly)\n   \n def getscreen(self):\n  ''\n  \n  return self.screen\n  \n def getturtle(self):\n  ''\n\n\n  \n  return self\n getpen=getturtle\n \n def _make_copy(self,name=None ):\n  ''\n\n  \n  \n  if name is None :\n   name=self.name\n   \n   \n   \n   \n   \n  _turtle,rotation=self.screen.create_svg_turtle(self,name=name)\n  _turtle.setAttribute(\"opacity\",0)\n  _turtle.setAttribute(\"fill\",self._fillcolor)\n  _turtle.setAttribute(\"stroke\",self._pencolor)\n  \n  \n  \n  previous_end,new_frame_id=self.screen._new_frame()\n  x,y=self.screen._convert_coordinates(self._x,self._y)\n  _turtle <=svg.animateMotion(begin=previous_end,dur=_CFG[\"min_duration\"],\n  fill=\"remove\")\n  \n  _turtle <=svg.animateMotion(Id=new_frame_id,\n  From=\"%s,%s\"%(x,y),to=\"%s,%s\"%(x,y),\n  dur=_CFG[\"min_duration\"],begin=previous_end,\n  fill=\"freeze\")\n  _turtle <=svg.animateTransform(attributeName=\"transform\",\n  type=\"rotate\",\n  From=(self._old_heading,0,0),\n  to=(self._old_heading,0,0),\n  begin=previous_end,\n  dur=_CFG[\"min_duration\"],fill=\"freeze\")\n  _turtle <=svg.animate(begin=previous_end,\n  dur=_CFG[\"min_duration\"],fill=\"freeze\",\n  attributeName=\"opacity\",attributeType=\"XML\",\n  From=0,to=1)\n  return _turtle\n  \n def stamp(self):\n  ''\n  \n  _turtle=self._make_copy(name=self.name)\n  self.screen.canvas <=_turtle\n  \n  \n def clone(self):\n  ''\n  \n  n=Turtle(self.name)\n  \n  attrs=vars(self)\n  new_dict={}\n  for attr in attrs:\n   if isinstance(getattr(self,attr),(int,str,float)):\n    new_dict[attr]=getattr(self,attr)\n  n.__dict__.update(**new_dict)\n  \n  if not n._shown:\n   n._shown=True\n   n.hideturtle()\n  n.left(0)\n  n.fd(0)\n  n.color(n.color())\n  return n\n  \n  \nPen=Turtle\n\n\ndef done():\n Screen().show_scene()\nshow_scene=done\n\n\ndef replay_scene():\n ''\n if (_CFG[\"turtle_canvas_id\"]in document and\n document[_CFG[\"turtle_canvas_id\"]]is not None ):\n  element=document[_CFG[\"turtle_canvas_id\"]]\n  element.parentNode.removeChild(element)\n show_scene()\n \n \ndef restart():\n ''\n _CFG.update(_cfg_copy)\n Screen().reset()\n Turtle._pen=None\n \n if (_CFG[\"turtle_canvas_id\"]in document and\n document[_CFG[\"turtle_canvas_id\"]]is not None ):\n  element=document[_CFG[\"turtle_canvas_id\"]]\n  element.parentNode.removeChild(element)\n  \n  \n  \n_tg_screen_functions=['addshape','bgcolor','bgpic','bye',\n'clearscreen','colormode','delay','exitonclick','getcanvas',\n'getshapes','listen','mainloop','mode','numinput',\n'onkey','onkeypress','onkeyrelease','onscreenclick','ontimer',\n'register_shape','resetscreen','screensize','setup',\n'setworldcoordinates','textinput','title','tracer','turtles','update',\n'window_height','window_width']\n\n_tg_turtle_functions=['back','backward','begin_fill','begin_poly','bk',\n'circle','clear','clearstamp','clearstamps','clone','color',\n'degrees','distance','dot','down','end_fill','end_poly','fd',\n'fillcolor','filling','forward','get_poly','getpen','getscreen','get_shapepoly',\n'getturtle','goto','heading','hideturtle','home','ht','isdown',\n'isvisible','left','lt','onclick','ondrag','onrelease','pd',\n'pen','pencolor','pendown','pensize','penup','pos','position',\n'pu','radians','right','reset','resizemode','rt',\n'seth','setheading','setpos','setposition','settiltangle',\n'setundobuffer','setx','sety','shape','shapesize','shapetransform','shearfactor','showturtle',\n'speed','st','stamp','tilt','tiltangle','towards',\n'turtlesize','undo','undobufferentries','up','width',\n'write','xcor','ycor']\n\n\n__all__=(_tg_screen_functions+_tg_turtle_functions+\n['done','restart','replay_scene','Turtle','Screen'])\n\n\n\n\n\n__func_body=\"\"\"\\\ndef {name}(*args, **kw):\n    if {obj} is None:\n        {obj} = {init}\n    return {obj}.{name}(*args, **kw)\n\"\"\"\n\ndef _make_global_funcs(functions,cls,obj,init):\n for methodname in functions:\n  try :\n   method=getattr(cls,methodname)\n  except AttributeError:\n   print(\"methodname missing:\",methodname)\n   continue\n  defstr=__func_body.format(obj=obj,init=init,name=methodname)\n  exec(defstr,globals())\n  \n_make_global_funcs(_tg_turtle_functions,Turtle,'Turtle._pen','Turtle()')\n\n_make_global_funcs(_tg_screen_functions,Screen,'Turtle.screen','Screen()')\n", ["_svg", "browser", "browser.html", "browser.timer", "math", "sys"]],
     "types": [".py", "''\n\n\nimport sys\n\n\n\n\n\n\ndef _f():pass\nFunctionType=type(_f)\nLambdaType=type(lambda :None )\nCodeType=type(_f.__code__)\nMappingProxyType=type(type.__dict__)\nSimpleNamespace=type(sys.implementation)\n\ndef _cell_factory():\n a=1\n def f():\n  nonlocal a\n return f.__closure__[0]\nCellType=type(_cell_factory())\n\ndef _g():\n yield 1\nGeneratorType=type(_g())\n\nasync def _c():pass\n_c=_c()\nCoroutineType=type(_c)\n_c.close()\n\nasync def _ag():\n yield\n_ag=_ag()\nAsyncGeneratorType=type(_ag)\n\nclass _C:\n def _m(self):pass\nMethodType=type(_C()._m)\n\nBuiltinFunctionType=type(len)\nBuiltinMethodType=type([].append)\n\nWrapperDescriptorType=type(object.__init__)\nMethodWrapperType=type(object().__str__)\nMethodDescriptorType=type(str.join)\nClassMethodDescriptorType=type(dict.__dict__['fromkeys'])\n\nModuleType=type(sys)\n\ntry :\n raise TypeError\nexcept TypeError:\n tb=sys.exc_info()[2]\n TracebackType=type(tb)\n FrameType=type(tb.tb_frame)\n tb=None ;del tb\n \n \nGetSetDescriptorType=type(FunctionType.__code__)\nMemberDescriptorType=type(FunctionType.__globals__)\n\ndel sys,_f,_g,_C,_c,_ag\n\n\n\ndef new_class(name,bases=(),kwds=None ,exec_body=None ):\n ''\n resolved_bases=resolve_bases(bases)\n meta,ns,kwds=prepare_class(name,resolved_bases,kwds)\n if exec_body is not None :\n  exec_body(ns)\n if resolved_bases is not bases:\n  ns['__orig_bases__']=bases\n return meta(name,resolved_bases,ns,**kwds)\n \ndef resolve_bases(bases):\n ''\n new_bases=list(bases)\n updated=False\n shift=0\n for i,base in enumerate(bases):\n  if isinstance(base,type):\n   continue\n  if not hasattr(base,\"__mro_entries__\"):\n   continue\n  new_base=base.__mro_entries__(bases)\n  updated=True\n  if not isinstance(new_base,tuple):\n   raise TypeError(\"__mro_entries__ must return a tuple\")\n  else :\n   new_bases[i+shift:i+shift+1]=new_base\n   shift +=len(new_base)-1\n if not updated:\n  return bases\n return tuple(new_bases)\n \ndef prepare_class(name,bases=(),kwds=None ):\n ''\n\n\n\n\n\n\n\n\n \n if kwds is None :\n  kwds={}\n else :\n  kwds=dict(kwds)\n if 'metaclass'in kwds:\n  meta=kwds.pop('metaclass')\n else :\n  if bases:\n   meta=type(bases[0])\n  else :\n   meta=type\n if isinstance(meta,type):\n \n \n  meta=_calculate_meta(meta,bases)\n if hasattr(meta,'__prepare__'):\n  ns=meta.__prepare__(name,bases,**kwds)\n else :\n  ns={}\n return meta,ns,kwds\n \ndef _calculate_meta(meta,bases):\n ''\n winner=meta\n for base in bases:\n  base_meta=type(base)\n  if issubclass(winner,base_meta):\n   continue\n  if issubclass(base_meta,winner):\n   winner=base_meta\n   continue\n   \n  raise TypeError(\"metaclass conflict: \"\n  \"the metaclass of a derived class \"\n  \"must be a (non-strict) subclass \"\n  \"of the metaclasses of all its bases\")\n return winner\n \nclass DynamicClassAttribute:\n ''\n\n\n\n\n\n\n\n\n\n \n def __init__(self,fget=None ,fset=None ,fdel=None ,doc=None ):\n  self.fget=fget\n  self.fset=fset\n  self.fdel=fdel\n  \n  self.__doc__=doc or fget.__doc__\n  self.overwrite_doc=doc is None\n  \n  self.__isabstractmethod__=bool(getattr(fget,'__isabstractmethod__',False ))\n  \n def __get__(self,instance,ownerclass=None ):\n  if instance is None :\n   if self.__isabstractmethod__:\n    return self\n   raise AttributeError()\n  elif self.fget is None :\n   raise AttributeError(\"unreadable attribute\")\n  return self.fget(instance)\n  \n def __set__(self,instance,value):\n  if self.fset is None :\n   raise AttributeError(\"can't set attribute\")\n  self.fset(instance,value)\n  \n def __delete__(self,instance):\n  if self.fdel is None :\n   raise AttributeError(\"can't delete attribute\")\n  self.fdel(instance)\n  \n def getter(self,fget):\n  fdoc=fget.__doc__ if self.overwrite_doc else None\n  result=type(self)(fget,self.fset,self.fdel,fdoc or self.__doc__)\n  result.overwrite_doc=self.overwrite_doc\n  return result\n  \n def setter(self,fset):\n  result=type(self)(self.fget,fset,self.fdel,self.__doc__)\n  result.overwrite_doc=self.overwrite_doc\n  return result\n  \n def deleter(self,fdel):\n  result=type(self)(self.fget,self.fset,fdel,self.__doc__)\n  result.overwrite_doc=self.overwrite_doc\n  return result\n  \n  \nclass _GeneratorWrapper:\n\n def __init__(self,gen):\n  self.__wrapped=gen\n  self.__isgen=gen.__class__ is GeneratorType\n  self.__name__=getattr(gen,'__name__',None )\n  self.__qualname__=getattr(gen,'__qualname__',None )\n def send(self,val):\n  return self.__wrapped.send(val)\n def throw(self,tp,*rest):\n  return self.__wrapped.throw(tp,*rest)\n def close(self):\n  return self.__wrapped.close()\n @property\n def gi_code(self):\n  return self.__wrapped.gi_code\n @property\n def gi_frame(self):\n  return self.__wrapped.gi_frame\n @property\n def gi_running(self):\n  return self.__wrapped.gi_running\n @property\n def gi_yieldfrom(self):\n  return self.__wrapped.gi_yieldfrom\n cr_code=gi_code\n cr_frame=gi_frame\n cr_running=gi_running\n cr_await=gi_yieldfrom\n def __next__(self):\n  return next(self.__wrapped)\n def __iter__(self):\n  if self.__isgen:\n   return self.__wrapped\n  return self\n __await__=__iter__\n \ndef coroutine(func):\n ''\n \n if not callable(func):\n  raise TypeError('types.coroutine() expects a callable')\n  \n if (func.__class__ is FunctionType and\n getattr(func,'__code__',None ).__class__ is CodeType):\n \n  co_flags=func.__code__.co_flags\n  \n  \n  \n  if co_flags&0x180:\n   return func\n   \n   \n   \n  if co_flags&0x20:\n  \n   co=func.__code__\n   \n   func.__code__=co.replace(co_flags=co.co_flags |0x100)\n   return func\n   \n   \n   \n   \n   \n   \n import functools\n import _collections_abc\n @functools.wraps(func)\n def wrapped(*args,**kwargs):\n  coro=func(*args,**kwargs)\n  if (coro.__class__ is CoroutineType or\n  coro.__class__ is GeneratorType and coro.gi_code.co_flags&0x100):\n  \n   return coro\n  if (isinstance(coro,_collections_abc.Generator)and\n  not isinstance(coro,_collections_abc.Coroutine)):\n  \n  \n  \n   return _GeneratorWrapper(coro)\n   \n   \n  return coro\n  \n return wrapped\n \n \nGenericAlias=type(list[int])\n\n\n__all__=[n for n in globals()if n[:1]!='_']\n", ["_collections_abc", "functools", "sys"]],
     "typing": [".py", "''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfrom abc import abstractmethod,ABCMeta\nimport collections\nimport collections.abc\nimport contextlib\nimport functools\nimport operator\nimport re as stdlib_re\nimport sys\nimport types\nfrom types import WrapperDescriptorType,MethodWrapperType,MethodDescriptorType,GenericAlias\n\n\n__all__=[\n\n'Annotated',\n'Any',\n'Callable',\n'ClassVar',\n'Final',\n'ForwardRef',\n'Generic',\n'Literal',\n'Optional',\n'Protocol',\n'Tuple',\n'Type',\n'TypeVar',\n'Union',\n\n\n'AbstractSet',\n'ByteString',\n'Container',\n'ContextManager',\n'Hashable',\n'ItemsView',\n'Iterable',\n'Iterator',\n'KeysView',\n'Mapping',\n'MappingView',\n'MutableMapping',\n'MutableSequence',\n'MutableSet',\n'Sequence',\n'Sized',\n'ValuesView',\n'Awaitable',\n'AsyncIterator',\n'AsyncIterable',\n'Coroutine',\n'Collection',\n'AsyncGenerator',\n'AsyncContextManager',\n\n\n'Reversible',\n'SupportsAbs',\n'SupportsBytes',\n'SupportsComplex',\n'SupportsFloat',\n'SupportsIndex',\n'SupportsInt',\n'SupportsRound',\n\n\n'ChainMap',\n'Counter',\n'Deque',\n'Dict',\n'DefaultDict',\n'List',\n'OrderedDict',\n'Set',\n'FrozenSet',\n'NamedTuple',\n'TypedDict',\n'Generator',\n\n\n'AnyStr',\n'cast',\n'final',\n'get_args',\n'get_origin',\n'get_type_hints',\n'NewType',\n'no_type_check',\n'no_type_check_decorator',\n'NoReturn',\n'overload',\n'runtime_checkable',\n'Text',\n'TYPE_CHECKING',\n]\n\n\n\n\n\n\ndef _type_check(arg,msg,is_argument=True ):\n ''\n\n\n\n\n\n\n\n\n\n \n invalid_generic_forms=(Generic,Protocol)\n if is_argument:\n  invalid_generic_forms=invalid_generic_forms+(ClassVar,Final)\n  \n if arg is None :\n  return type(None )\n if isinstance(arg,str):\n  return ForwardRef(arg)\n if (isinstance(arg,_GenericAlias)and\n arg.__origin__ in invalid_generic_forms):\n  raise TypeError(f\"{arg} is not valid as type argument\")\n if arg in (Any,NoReturn):\n  return arg\n if isinstance(arg,_SpecialForm)or arg in (Generic,Protocol):\n  raise TypeError(f\"Plain {arg} is not valid as type argument\")\n if isinstance(arg,(type,TypeVar,ForwardRef)):\n  return arg\n if not callable(arg):\n  raise TypeError(f\"{msg} Got {arg!r:.100}.\")\n return arg\n \n \ndef _type_repr(obj):\n ''\n\n\n\n\n\n \n if isinstance(obj,type):\n  if obj.__module__ =='builtins':\n   return obj.__qualname__\n  return f'{obj.__module__}.{obj.__qualname__}'\n if obj is ...:\n  return ('...')\n if isinstance(obj,types.FunctionType):\n  return obj.__name__\n return repr(obj)\n \n \ndef _collect_type_vars(types):\n ''\n\n\n\n \n tvars=[]\n for t in types:\n  if isinstance(t,TypeVar)and t not in tvars:\n   tvars.append(t)\n  if isinstance(t,(_GenericAlias,GenericAlias)):\n   tvars.extend([t for t in t.__parameters__ if t not in tvars])\n return tuple(tvars)\n \n \ndef _check_generic(cls,parameters,elen):\n ''\n\n \n if not elen:\n  raise TypeError(f\"{cls} is not a generic class\")\n alen=len(parameters)\n if alen !=elen:\n  raise TypeError(f\"Too {'many' if alen > elen else 'few'} parameters for {cls};\"\n  f\" actual {alen}, expected {elen}\")\n  \n  \ndef _remove_dups_flatten(parameters):\n ''\n\n \n \n params=[]\n for p in parameters:\n  if isinstance(p,_UnionGenericAlias):\n   params.extend(p.__args__)\n  elif isinstance(p,tuple)and len(p)>0 and p[0]is Union:\n   params.extend(p[1:])\n  else :\n   params.append(p)\n   \n all_params=set(params)\n if len(all_params)<len(params):\n  new_params=[]\n  for t in params:\n   if t in all_params:\n    new_params.append(t)\n    all_params.remove(t)\n  params=new_params\n  assert not all_params,all_params\n return tuple(params)\n \n \n_cleanups=[]\n\n\ndef _tp_cache(func):\n ''\n\n \n cached=functools.lru_cache()(func)\n _cleanups.append(cached.cache_clear)\n \n @functools.wraps(func)\n def inner(*args,**kwds):\n  try :\n   return cached(*args,**kwds)\n  except TypeError:\n   pass\n  return func(*args,**kwds)\n return inner\n \n \ndef _eval_type(t,globalns,localns,recursive_guard=frozenset()):\n ''\n\n\n\n \n if isinstance(t,ForwardRef):\n  return t._evaluate(globalns,localns,recursive_guard)\n if isinstance(t,(_GenericAlias,GenericAlias)):\n  ev_args=tuple(_eval_type(a,globalns,localns,recursive_guard)for a in t.__args__)\n  if ev_args ==t.__args__:\n   return t\n  if isinstance(t,GenericAlias):\n   return GenericAlias(t.__origin__,ev_args)\n  else :\n   return t.copy_with(ev_args)\n return t\n \n \nclass _Final:\n ''\n \n __slots__=('__weakref__',)\n \n def __init_subclass__(self,/,*args,**kwds):\n  if '_root'not in kwds:\n   raise TypeError(\"Cannot subclass special typing classes\")\n   \nclass _Immutable:\n ''\n __slots__=()\n \n def __copy__(self):\n  return self\n  \n def __deepcopy__(self,memo):\n  return self\n  \n  \n  \n  \nclass _SpecialForm(_Final,_root=True ):\n __slots__=('_name','__doc__','_getitem')\n \n def __init__(self,getitem):\n  self._getitem=getitem\n  self._name=getitem.__name__\n  self.__doc__=getitem.__doc__\n  \n def __mro_entries__(self,bases):\n  raise TypeError(f\"Cannot subclass {self!r}\")\n  \n def __repr__(self):\n  return 'typing.'+self._name\n  \n def __reduce__(self):\n  return self._name\n  \n def __call__(self,*args,**kwds):\n  raise TypeError(f\"Cannot instantiate {self!r}\")\n  \n def __instancecheck__(self,obj):\n  raise TypeError(f\"{self} cannot be used with isinstance()\")\n  \n def __subclasscheck__(self,cls):\n  raise TypeError(f\"{self} cannot be used with issubclass()\")\n  \n @_tp_cache\n def __getitem__(self,parameters):\n  return self._getitem(self,parameters)\n  \n@_SpecialForm\ndef Any(self,parameters):\n ''\n\n\n\n\n\n\n\n\n \n raise TypeError(f\"{self} is not subscriptable\")\n \n@_SpecialForm\ndef NoReturn(self,parameters):\n ''\n\n\n\n\n\n\n\n\n\n \n raise TypeError(f\"{self} is not subscriptable\")\n \n@_SpecialForm\ndef ClassVar(self,parameters):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n item=_type_check(parameters,f'{self} accepts only single type.')\n return _GenericAlias(self,(item,))\n \n@_SpecialForm\ndef Final(self,parameters):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n item=_type_check(parameters,f'{self} accepts only single type.')\n return _GenericAlias(self,(item,))\n \n@_SpecialForm\ndef Union(self,parameters):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n if parameters ==():\n  raise TypeError(\"Cannot take a Union of no types.\")\n if not isinstance(parameters,tuple):\n  parameters=(parameters,)\n msg=\"Union[arg, ...]: each arg must be a type.\"\n parameters=tuple(_type_check(p,msg)for p in parameters)\n parameters=_remove_dups_flatten(parameters)\n if len(parameters)==1:\n  return parameters[0]\n return _UnionGenericAlias(self,parameters)\n \n@_SpecialForm\ndef Optional(self,parameters):\n ''\n\n\n \n arg=_type_check(parameters,f\"{self} requires a single type.\")\n return Union[arg,type(None )]\n \n@_SpecialForm\ndef Literal(self,parameters):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n return _GenericAlias(self,parameters)\n \n \nclass ForwardRef(_Final,_root=True ):\n ''\n \n __slots__=('__forward_arg__','__forward_code__',\n '__forward_evaluated__','__forward_value__',\n '__forward_is_argument__')\n \n def __init__(self,arg,is_argument=True ):\n  if not isinstance(arg,str):\n   raise TypeError(f\"Forward reference must be a string -- got {arg!r}\")\n  try :\n   code=compile(arg,'<string>','eval')\n  except SyntaxError:\n   raise SyntaxError(f\"Forward reference must be an expression -- got {arg!r}\")\n  self.__forward_arg__=arg\n  self.__forward_code__=code\n  self.__forward_evaluated__=False\n  self.__forward_value__=None\n  self.__forward_is_argument__=is_argument\n  \n def _evaluate(self,globalns,localns,recursive_guard):\n  if self.__forward_arg__ in recursive_guard:\n   return self\n  if not self.__forward_evaluated__ or localns is not globalns:\n   if globalns is None and localns is None :\n    globalns=localns={}\n   elif globalns is None :\n    globalns=localns\n   elif localns is None :\n    localns=globalns\n   type_=_type_check(\n   eval(self.__forward_code__,globalns,localns),\n   \"Forward references must evaluate to types.\",\n   is_argument=self.__forward_is_argument__,\n   )\n   self.__forward_value__=_eval_type(\n   type_,globalns,localns,recursive_guard |{self.__forward_arg__}\n   )\n   self.__forward_evaluated__=True\n  return self.__forward_value__\n  \n def __eq__(self,other):\n  if not isinstance(other,ForwardRef):\n   return NotImplemented\n  if self.__forward_evaluated__ and other.__forward_evaluated__:\n   return (self.__forward_arg__ ==other.__forward_arg__ and\n   self.__forward_value__ ==other.__forward_value__)\n  return self.__forward_arg__ ==other.__forward_arg__\n  \n def __hash__(self):\n  return hash(self.__forward_arg__)\n  \n def __repr__(self):\n  return f'ForwardRef({self.__forward_arg__!r})'\n  \n  \nclass TypeVar(_Final,_Immutable,_root=True ):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n __slots__=('__name__','__bound__','__constraints__',\n '__covariant__','__contravariant__','__dict__')\n \n def __init__(self,name,*constraints,bound=None ,\n covariant=False ,contravariant=False ):\n  self.__name__=name\n  if covariant and contravariant:\n   raise ValueError(\"Bivariant types are not supported.\")\n  self.__covariant__=bool(covariant)\n  self.__contravariant__=bool(contravariant)\n  if constraints and bound is not None :\n   raise TypeError(\"Constraints cannot be combined with bound=...\")\n  if constraints and len(constraints)==1:\n   raise TypeError(\"A single constraint is not allowed\")\n  msg=\"TypeVar(name, constraint, ...): constraints must be types.\"\n  self.__constraints__=tuple(_type_check(t,msg)for t in constraints)\n  if bound:\n   self.__bound__=_type_check(bound,\"Bound must be a type.\")\n  else :\n   self.__bound__=None\n  try :\n   def_mod=sys._getframe(1).f_globals.get('__name__','__main__')\n  except (AttributeError,ValueError):\n   def_mod=None\n  if def_mod !='typing':\n   self.__module__=def_mod\n   \n def __repr__(self):\n  if self.__covariant__:\n   prefix='+'\n  elif self.__contravariant__:\n   prefix='-'\n  else :\n   prefix='~'\n  return prefix+self.__name__\n  \n def __reduce__(self):\n  return self.__name__\n  \n  \ndef _is_dunder(attr):\n return attr.startswith('__')and attr.endswith('__')\n \nclass _BaseGenericAlias(_Final,_root=True ):\n ''\n\n\n\n\n\n\n \n def __init__(self,origin,*,inst=True ,name=None ):\n  self._inst=inst\n  self._name=name\n  self.__origin__=origin\n  self.__slots__=None\n  \n def __call__(self,*args,**kwargs):\n  if not self._inst:\n   raise TypeError(f\"Type {self._name} cannot be instantiated; \"\n   f\"use {self.__origin__.__name__}() instead\")\n  result=self.__origin__(*args,**kwargs)\n  try :\n   result.__orig_class__=self\n  except AttributeError:\n   pass\n  return result\n  \n def __mro_entries__(self,bases):\n  res=[]\n  if self.__origin__ not in bases:\n   res.append(self.__origin__)\n  i=bases.index(self)\n  for b in bases[i+1:]:\n   if isinstance(b,_BaseGenericAlias)or issubclass(b,Generic):\n    break\n  else :\n   res.append(Generic)\n  return tuple(res)\n  \n def __getattr__(self,attr):\n \n \n  if '__origin__'in self.__dict__ and not _is_dunder(attr):\n   return getattr(self.__origin__,attr)\n  raise AttributeError(attr)\n  \n def __setattr__(self,attr,val):\n  if _is_dunder(attr)or attr in ('_name','_inst','_nparams'):\n   super().__setattr__(attr,val)\n  else :\n   setattr(self.__origin__,attr,val)\n   \n def __instancecheck__(self,obj):\n  return self.__subclasscheck__(type(obj))\n  \n def __subclasscheck__(self,cls):\n  raise TypeError(\"Subscripted generics cannot be used with\"\n  \" class and instance checks\")\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \nclass _GenericAlias(_BaseGenericAlias,_root=True ):\n def __init__(self,origin,params,*,inst=True ,name=None ):\n  super().__init__(origin,inst=inst,name=name)\n  if not isinstance(params,tuple):\n   params=(params,)\n  self.__args__=tuple(...if a is _TypingEllipsis else\n  ()if a is _TypingEmpty else\n  a for a in params)\n  self.__parameters__=_collect_type_vars(params)\n  if not name:\n   self.__module__=origin.__module__\n   \n def __eq__(self,other):\n  if not isinstance(other,_GenericAlias):\n   return NotImplemented\n  return (self.__origin__ ==other.__origin__\n  and self.__args__ ==other.__args__)\n  \n def __hash__(self):\n  return hash((self.__origin__,self.__args__))\n  \n @_tp_cache\n def __getitem__(self,params):\n  if self.__origin__ in (Generic,Protocol):\n  \n   raise TypeError(f\"Cannot subscript already-subscripted {self}\")\n  if not isinstance(params,tuple):\n   params=(params,)\n  msg=\"Parameters to generic types must be types.\"\n  params=tuple(_type_check(p,msg)for p in params)\n  _check_generic(self,params,len(self.__parameters__))\n  \n  subst=dict(zip(self.__parameters__,params))\n  new_args=[]\n  for arg in self.__args__:\n   if isinstance(arg,TypeVar):\n    arg=subst[arg]\n   elif isinstance(arg,(_GenericAlias,GenericAlias)):\n    subparams=arg.__parameters__\n    if subparams:\n     subargs=tuple(subst[x]for x in subparams)\n     arg=arg[subargs]\n   new_args.append(arg)\n  return self.copy_with(tuple(new_args))\n  \n def copy_with(self,params):\n  return self.__class__(self.__origin__,params,name=self._name,inst=self._inst)\n  \n def __repr__(self):\n  if self._name:\n   name='typing.'+self._name\n  else :\n   name=_type_repr(self.__origin__)\n  args=\", \".join([_type_repr(a)for a in self.__args__])\n  return f'{name}[{args}]'\n  \n def __reduce__(self):\n  if self._name:\n   origin=globals()[self._name]\n  else :\n   origin=self.__origin__\n  args=tuple(self.__args__)\n  if len(args)==1 and not isinstance(args[0],tuple):\n   args,=args\n  return operator.getitem,(origin,args)\n  \n def __mro_entries__(self,bases):\n  if self._name:\n   return super().__mro_entries__(bases)\n  if self.__origin__ is Generic:\n   if Protocol in bases:\n    return ()\n   i=bases.index(self)\n   for b in bases[i+1:]:\n    if isinstance(b,_BaseGenericAlias)and b is not self:\n     return ()\n  return (self.__origin__,)\n  \n  \n  \n  \n  \n  \nclass _SpecialGenericAlias(_BaseGenericAlias,_root=True ):\n def __init__(self,origin,nparams,*,inst=True ,name=None ):\n  if name is None :\n   name=origin.__name__\n  super().__init__(origin,inst=inst,name=name)\n  self._nparams=nparams\n  if origin.__module__ =='builtins':\n   self.__doc__=f'A generic version of {origin.__qualname__}.'\n  else :\n   self.__doc__=f'A generic version of {origin.__module__}.{origin.__qualname__}.'\n   \n @_tp_cache\n def __getitem__(self,params):\n  if not isinstance(params,tuple):\n   params=(params,)\n  msg=\"Parameters to generic types must be types.\"\n  params=tuple(_type_check(p,msg)for p in params)\n  _check_generic(self,params,self._nparams)\n  return self.copy_with(params)\n  \n def copy_with(self,params):\n  return _GenericAlias(self.__origin__,params,\n  name=self._name,inst=self._inst)\n  \n def __repr__(self):\n  return 'typing.'+self._name\n  \n def __subclasscheck__(self,cls):\n  if isinstance(cls,_SpecialGenericAlias):\n   return issubclass(cls.__origin__,self.__origin__)\n  if not isinstance(cls,_GenericAlias):\n   return issubclass(cls,self.__origin__)\n  return super().__subclasscheck__(cls)\n  \n def __reduce__(self):\n  return self._name\n  \n  \nclass _CallableGenericAlias(_GenericAlias,_root=True ):\n def __repr__(self):\n  assert self._name =='Callable'\n  if len(self.__args__)==2 and self.__args__[0]is Ellipsis:\n   return super().__repr__()\n  return (f'typing.Callable'\n  f'[[{\", \".join([_type_repr(a) for a in self.__args__[:-1]])}], '\n  f'{_type_repr(self.__args__[-1])}]')\n  \n def __reduce__(self):\n  args=self.__args__\n  if not (len(args)==2 and args[0]is ...):\n   args=list(args[:-1]),args[-1]\n  return operator.getitem,(Callable,args)\n  \n  \nclass _CallableType(_SpecialGenericAlias,_root=True ):\n def copy_with(self,params):\n  return _CallableGenericAlias(self.__origin__,params,\n  name=self._name,inst=self._inst)\n  \n def __getitem__(self,params):\n  if not isinstance(params,tuple)or len(params)!=2:\n   raise TypeError(\"Callable must be used as \"\n   \"Callable[[arg, ...], result].\")\n  args,result=params\n  if args is Ellipsis:\n   params=(Ellipsis,result)\n  else :\n   if not isinstance(args,list):\n    raise TypeError(f\"Callable[args, result]: args must be a list.\"\n    f\" Got {args}\")\n   params=(tuple(args),result)\n  return self.__getitem_inner__(params)\n  \n @_tp_cache\n def __getitem_inner__(self,params):\n  args,result=params\n  msg=\"Callable[args, result]: result must be a type.\"\n  result=_type_check(result,msg)\n  if args is Ellipsis:\n   return self.copy_with((_TypingEllipsis,result))\n  msg=\"Callable[[arg, ...], result]: each arg must be a type.\"\n  args=tuple(_type_check(arg,msg)for arg in args)\n  params=args+(result,)\n  return self.copy_with(params)\n  \n  \nclass _TupleType(_SpecialGenericAlias,_root=True ):\n @_tp_cache\n def __getitem__(self,params):\n  if params ==():\n   return self.copy_with((_TypingEmpty,))\n  if not isinstance(params,tuple):\n   params=(params,)\n  if len(params)==2 and params[1]is ...:\n   msg=\"Tuple[t, ...]: t must be a type.\"\n   p=_type_check(params[0],msg)\n   return self.copy_with((p,_TypingEllipsis))\n  msg=\"Tuple[t0, t1, ...]: each t must be a type.\"\n  params=tuple(_type_check(p,msg)for p in params)\n  return self.copy_with(params)\n  \n  \nclass _UnionGenericAlias(_GenericAlias,_root=True ):\n def copy_with(self,params):\n  return Union[params]\n  \n def __eq__(self,other):\n  if not isinstance(other,_UnionGenericAlias):\n   return NotImplemented\n  return set(self.__args__)==set(other.__args__)\n  \n def __hash__(self):\n  return hash(frozenset(self.__args__))\n  \n def __repr__(self):\n  args=self.__args__\n  if len(args)==2:\n   if args[0]is type(None ):\n    return f'typing.Optional[{_type_repr(args[1])}]'\n   elif args[1]is type(None ):\n    return f'typing.Optional[{_type_repr(args[0])}]'\n  return super().__repr__()\n  \n  \nclass Generic:\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n __slots__=()\n _is_protocol=False\n \n @_tp_cache\n def __class_getitem__(cls,params):\n  if not isinstance(params,tuple):\n   params=(params,)\n  if not params and cls is not Tuple:\n   raise TypeError(\n   f\"Parameter list to {cls.__qualname__}[...] cannot be empty\")\n  msg=\"Parameters to generic types must be types.\"\n  params=tuple(_type_check(p,msg)for p in params)\n  if cls in (Generic,Protocol):\n  \n   if not all(isinstance(p,TypeVar)for p in params):\n    raise TypeError(\n    f\"Parameters to {cls.__name__}[...] must all be type variables\")\n   if len(set(params))!=len(params):\n    raise TypeError(\n    f\"Parameters to {cls.__name__}[...] must all be unique\")\n  else :\n  \n   _check_generic(cls,params,len(cls.__parameters__))\n  return _GenericAlias(cls,params)\n  \n def __init_subclass__(cls,*args,**kwargs):\n  super().__init_subclass__(*args,**kwargs)\n  tvars=[]\n  if '__orig_bases__'in cls.__dict__:\n   error=Generic in cls.__orig_bases__\n  else :\n   error=Generic in cls.__bases__ and cls.__name__ !='Protocol'\n  if error:\n   raise TypeError(\"Cannot inherit from plain Generic\")\n  if '__orig_bases__'in cls.__dict__:\n   tvars=_collect_type_vars(cls.__orig_bases__)\n   \n   \n   \n   \n   \n   gvars=None\n   for base in cls.__orig_bases__:\n    if (isinstance(base,_GenericAlias)and\n    base.__origin__ is Generic):\n     if gvars is not None :\n      raise TypeError(\n      \"Cannot inherit from Generic[...] multiple types.\")\n     gvars=base.__parameters__\n   if gvars is not None :\n    tvarset=set(tvars)\n    gvarset=set(gvars)\n    if not tvarset <=gvarset:\n     s_vars=', '.join(str(t)for t in tvars if t not in gvarset)\n     s_args=', '.join(str(g)for g in gvars)\n     raise TypeError(f\"Some type variables ({s_vars}) are\"\n     f\" not listed in Generic[{s_args}]\")\n    tvars=gvars\n  cls.__parameters__=tuple(tvars)\n  \n  \nclass _TypingEmpty:\n ''\n\n\n \n \n \nclass _TypingEllipsis:\n ''\n \n \n_TYPING_INTERNALS=['__parameters__','__orig_bases__','__orig_class__',\n'_is_protocol','_is_runtime_protocol']\n\n_SPECIAL_NAMES=['__abstractmethods__','__annotations__','__dict__','__doc__',\n'__init__','__module__','__new__','__slots__',\n'__subclasshook__','__weakref__','__class_getitem__']\n\n\nEXCLUDED_ATTRIBUTES=_TYPING_INTERNALS+_SPECIAL_NAMES+['_MutableMapping__marker']\n\n\ndef _get_protocol_attrs(cls):\n ''\n\n\n\n \n attrs=set()\n for base in cls.__mro__[:-1]:\n  if base.__name__ in ('Protocol','Generic'):\n   continue\n  annotations=getattr(base,'__annotations__',{})\n  for attr in list(base.__dict__.keys())+list(annotations.keys()):\n   if not attr.startswith('_abc_')and attr not in EXCLUDED_ATTRIBUTES:\n    attrs.add(attr)\n return attrs\n \n \ndef _is_callable_members_only(cls):\n\n return all(callable(getattr(cls,attr,None ))for attr in _get_protocol_attrs(cls))\n \n \ndef _no_init(self,*args,**kwargs):\n if type(self)._is_protocol:\n  raise TypeError('Protocols cannot be instantiated')\n  \n  \ndef _allow_reckless_class_cheks():\n ''\n\n\n\n \n try :\n  return sys._getframe(3).f_globals['__name__']in ['abc','functools']\n except (AttributeError,ValueError):\n  return True\n  \n  \n_PROTO_WHITELIST={\n'collections.abc':[\n'Callable','Awaitable','Iterable','Iterator','AsyncIterable',\n'Hashable','Sized','Container','Collection','Reversible',\n],\n'contextlib':['AbstractContextManager','AbstractAsyncContextManager'],\n}\n\n\nclass _ProtocolMeta(ABCMeta):\n\n\n def __instancecheck__(cls,instance):\n \n \n  if ((not getattr(cls,'_is_protocol',False )or\n  _is_callable_members_only(cls))and\n  issubclass(instance.__class__,cls)):\n   return True\n  if cls._is_protocol:\n   if all(hasattr(instance,attr)and\n   \n   (not callable(getattr(cls,attr,None ))or\n   getattr(instance,attr)is not None )\n   for attr in _get_protocol_attrs(cls)):\n    return True\n  return super().__instancecheck__(instance)\n  \n  \nclass Protocol(Generic,metaclass=_ProtocolMeta):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n __slots__=()\n _is_protocol=True\n _is_runtime_protocol=False\n \n def __init_subclass__(cls,*args,**kwargs):\n  super().__init_subclass__(*args,**kwargs)\n  \n  \n  if not cls.__dict__.get('_is_protocol',False ):\n   cls._is_protocol=any(b is Protocol for b in cls.__bases__)\n   \n   \n  def _proto_hook(other):\n   if not cls.__dict__.get('_is_protocol',False ):\n    return NotImplemented\n    \n    \n   if not getattr(cls,'_is_runtime_protocol',False ):\n    if _allow_reckless_class_cheks():\n     return NotImplemented\n    raise TypeError(\"Instance and class checks can only be used with\"\n    \" @runtime_checkable protocols\")\n   if not _is_callable_members_only(cls):\n    if _allow_reckless_class_cheks():\n     return NotImplemented\n    raise TypeError(\"Protocols with non-method members\"\n    \" don't support issubclass()\")\n   if not isinstance(other,type):\n   \n    raise TypeError('issubclass() arg 1 must be a class')\n    \n    \n   for attr in _get_protocol_attrs(cls):\n    for base in other.__mro__:\n    \n     if attr in base.__dict__:\n      if base.__dict__[attr]is None :\n       return NotImplemented\n      break\n      \n      \n     annotations=getattr(base,'__annotations__',{})\n     if (isinstance(annotations,collections.abc.Mapping)and\n     attr in annotations and\n     issubclass(other,Generic)and other._is_protocol):\n      break\n    else :\n     return NotImplemented\n   return True\n   \n  if '__subclasshook__'not in cls.__dict__:\n   cls.__subclasshook__=_proto_hook\n   \n   \n  if not cls._is_protocol:\n   return\n   \n   \n  for base in cls.__bases__:\n   if not (base in (object,Generic)or\n   base.__module__ in _PROTO_WHITELIST and\n   base.__name__ in _PROTO_WHITELIST[base.__module__]or\n   issubclass(base,Generic)and base._is_protocol):\n    raise TypeError('Protocols can only inherit from other'\n    ' protocols, got %r'%base)\n  cls.__init__=_no_init\n  \n  \nclass _AnnotatedAlias(_GenericAlias,_root=True ):\n ''\n\n\n\n\n\n \n def __init__(self,origin,metadata):\n  if isinstance(origin,_AnnotatedAlias):\n   metadata=origin.__metadata__+metadata\n   origin=origin.__origin__\n  super().__init__(origin,origin)\n  self.__metadata__=metadata\n  \n def copy_with(self,params):\n  assert len(params)==1\n  new_type=params[0]\n  return _AnnotatedAlias(new_type,self.__metadata__)\n  \n def __repr__(self):\n  return \"typing.Annotated[{}, {}]\".format(\n  _type_repr(self.__origin__),\n  \", \".join(repr(a)for a in self.__metadata__)\n  )\n  \n def __reduce__(self):\n  return operator.getitem,(\n  Annotated,(self.__origin__,)+self.__metadata__\n  )\n  \n def __eq__(self,other):\n  if not isinstance(other,_AnnotatedAlias):\n   return NotImplemented\n  return (self.__origin__ ==other.__origin__\n  and self.__metadata__ ==other.__metadata__)\n  \n def __hash__(self):\n  return hash((self.__origin__,self.__metadata__))\n  \n  \nclass Annotated:\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n __slots__=()\n \n def __new__(cls,*args,**kwargs):\n  raise TypeError(\"Type Annotated cannot be instantiated.\")\n  \n @_tp_cache\n def __class_getitem__(cls,params):\n  if not isinstance(params,tuple)or len(params)<2:\n   raise TypeError(\"Annotated[...] should be used \"\n   \"with at least two arguments (a type and an \"\n   \"annotation).\")\n  msg=\"Annotated[t, ...]: t must be a type.\"\n  origin=_type_check(params[0],msg)\n  metadata=tuple(params[1:])\n  return _AnnotatedAlias(origin,metadata)\n  \n def __init_subclass__(cls,*args,**kwargs):\n  raise TypeError(\n  \"Cannot subclass {}.Annotated\".format(cls.__module__)\n  )\n  \n  \ndef runtime_checkable(cls):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n if not issubclass(cls,Generic)or not cls._is_protocol:\n  raise TypeError('@runtime_checkable can be only applied to protocol classes,'\n  ' got %r'%cls)\n cls._is_runtime_protocol=True\n return cls\n \n \ndef cast(typ,val):\n ''\n\n\n\n\n\n \n return val\n \n \ndef _get_defaults(func):\n ''\n try :\n  code=func.__code__\n except AttributeError:\n \n  return {}\n pos_count=code.co_argcount\n arg_names=code.co_varnames\n arg_names=arg_names[:pos_count]\n defaults=func.__defaults__ or ()\n kwdefaults=func.__kwdefaults__\n res=dict(kwdefaults)if kwdefaults else {}\n pos_offset=pos_count -len(defaults)\n for name,value in zip(arg_names[pos_offset:],defaults):\n  assert name not in res\n  res[name]=value\n return res\n \n \n_allowed_types=(types.FunctionType,types.BuiltinFunctionType,\ntypes.MethodType,types.ModuleType,\nWrapperDescriptorType,MethodWrapperType,MethodDescriptorType)\n\n\ndef get_type_hints(obj,globalns=None ,localns=None ,include_extras=False ):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n if getattr(obj,'__no_type_check__',None ):\n  return {}\n  \n if isinstance(obj,type):\n  hints={}\n  for base in reversed(obj.__mro__):\n   if globalns is None :\n    base_globals=sys.modules[base.__module__].__dict__\n   else :\n    base_globals=globalns\n   ann=base.__dict__.get('__annotations__',{})\n   for name,value in ann.items():\n    if value is None :\n     value=type(None )\n    if isinstance(value,str):\n     value=ForwardRef(value,is_argument=False )\n    value=_eval_type(value,base_globals,localns)\n    hints[name]=value\n  return hints if include_extras else {k:_strip_annotations(t)for k,t in hints.items()}\n  \n if globalns is None :\n  if isinstance(obj,types.ModuleType):\n   globalns=obj.__dict__\n  else :\n   nsobj=obj\n   \n   while hasattr(nsobj,'__wrapped__'):\n    nsobj=nsobj.__wrapped__\n   globalns=getattr(nsobj,'__globals__',{})\n  if localns is None :\n   localns=globalns\n elif localns is None :\n  localns=globalns\n hints=getattr(obj,'__annotations__',None )\n if hints is None :\n \n  if isinstance(obj,_allowed_types):\n   return {}\n  else :\n   raise TypeError('{!r} is not a module, class, method, '\n   'or function.'.format(obj))\n defaults=_get_defaults(obj)\n hints=dict(hints)\n for name,value in hints.items():\n  if value is None :\n   value=type(None )\n  if isinstance(value,str):\n   value=ForwardRef(value)\n  value=_eval_type(value,globalns,localns)\n  if name in defaults and defaults[name]is None :\n   value=Optional[value]\n  hints[name]=value\n return hints if include_extras else {k:_strip_annotations(t)for k,t in hints.items()}\n \n \ndef _strip_annotations(t):\n ''\n \n if isinstance(t,_AnnotatedAlias):\n  return _strip_annotations(t.__origin__)\n if isinstance(t,_GenericAlias):\n  stripped_args=tuple(_strip_annotations(a)for a in t.__args__)\n  if stripped_args ==t.__args__:\n   return t\n  return t.copy_with(stripped_args)\n if isinstance(t,GenericAlias):\n  stripped_args=tuple(_strip_annotations(a)for a in t.__args__)\n  if stripped_args ==t.__args__:\n   return t\n  return GenericAlias(t.__origin__,stripped_args)\n return t\n \n \ndef get_origin(tp):\n ''\n\n\n\n\n\n\n\n\n\n\n\n \n if isinstance(tp,_AnnotatedAlias):\n  return Annotated\n if isinstance(tp,(_BaseGenericAlias,GenericAlias)):\n  return tp.__origin__\n if tp is Generic:\n  return Generic\n return None\n \n \ndef get_args(tp):\n ''\n\n\n\n\n\n\n\n\n \n if isinstance(tp,_AnnotatedAlias):\n  return (tp.__origin__,)+tp.__metadata__\n if isinstance(tp,_GenericAlias):\n  res=tp.__args__\n  if tp.__origin__ is collections.abc.Callable and res[0]is not Ellipsis:\n   res=(list(res[:-1]),res[-1])\n  return res\n if isinstance(tp,GenericAlias):\n  return tp.__args__\n return ()\n \n \ndef no_type_check(arg):\n ''\n\n\n\n\n\n\n \n if isinstance(arg,type):\n  arg_attrs=arg.__dict__.copy()\n  for attr,val in arg.__dict__.items():\n   if val in arg.__bases__+(arg,):\n    arg_attrs.pop(attr)\n  for obj in arg_attrs.values():\n   if isinstance(obj,types.FunctionType):\n    obj.__no_type_check__=True\n   if isinstance(obj,type):\n    no_type_check(obj)\n try :\n  arg.__no_type_check__=True\n except TypeError:\n  pass\n return arg\n \n \ndef no_type_check_decorator(decorator):\n ''\n\n\n\n \n \n @functools.wraps(decorator)\n def wrapped_decorator(*args,**kwds):\n  func=decorator(*args,**kwds)\n  func=no_type_check(func)\n  return func\n  \n return wrapped_decorator\n \n \ndef _overload_dummy(*args,**kwds):\n ''\n raise NotImplementedError(\n \"You should not call an overloaded function. \"\n \"A series of @overload-decorated functions \"\n \"outside a stub module should always be followed \"\n \"by an implementation that is not @overload-ed.\")\n \n \ndef overload(func):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n return _overload_dummy\n \n \ndef final(f):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n return f\n \n \n \n \nT=TypeVar('T')\nKT=TypeVar('KT')\nVT=TypeVar('VT')\nT_co=TypeVar('T_co',covariant=True )\nV_co=TypeVar('V_co',covariant=True )\nVT_co=TypeVar('VT_co',covariant=True )\nT_contra=TypeVar('T_contra',contravariant=True )\n\nCT_co=TypeVar('CT_co',covariant=True ,bound=type)\n\n\n\nAnyStr=TypeVar('AnyStr',bytes,str)\n\n\n\n_alias=_SpecialGenericAlias\n\nHashable=_alias(collections.abc.Hashable,0)\nAwaitable=_alias(collections.abc.Awaitable,1)\nCoroutine=_alias(collections.abc.Coroutine,3)\nAsyncIterable=_alias(collections.abc.AsyncIterable,1)\nAsyncIterator=_alias(collections.abc.AsyncIterator,1)\nIterable=_alias(collections.abc.Iterable,1)\nIterator=_alias(collections.abc.Iterator,1)\nReversible=_alias(collections.abc.Reversible,1)\nSized=_alias(collections.abc.Sized,0)\nContainer=_alias(collections.abc.Container,1)\nCollection=_alias(collections.abc.Collection,1)\nCallable=_CallableType(collections.abc.Callable,2)\nCallable.__doc__=\\\n\"\"\"Callable type; Callable[[int], str] is a function of (int) -> str.\n\n    The subscription syntax must always be used with exactly two\n    values: the argument list and the return type.  The argument list\n    must be a list of types or ellipsis; the return type must be a single type.\n\n    There is no syntax to indicate optional or keyword arguments,\n    such function types are rarely used as callback types.\n    \"\"\"\nAbstractSet=_alias(collections.abc.Set,1,name='AbstractSet')\nMutableSet=_alias(collections.abc.MutableSet,1)\n\nMapping=_alias(collections.abc.Mapping,2)\nMutableMapping=_alias(collections.abc.MutableMapping,2)\nSequence=_alias(collections.abc.Sequence,1)\nMutableSequence=_alias(collections.abc.MutableSequence,1)\nByteString=_alias(collections.abc.ByteString,0)\n\nTuple=_TupleType(tuple,-1,inst=False ,name='Tuple')\nTuple.__doc__=\\\n\"\"\"Tuple type; Tuple[X, Y] is the cross-product type of X and Y.\n\n    Example: Tuple[T1, T2] is a tuple of two elements corresponding\n    to type variables T1 and T2.  Tuple[int, float, str] is a tuple\n    of an int, a float and a string.\n\n    To specify a variable-length tuple of homogeneous type, use Tuple[T, ...].\n    \"\"\"\nList=_alias(list,1,inst=False ,name='List')\nDeque=_alias(collections.deque,1,name='Deque')\nSet=_alias(set,1,inst=False ,name='Set')\nFrozenSet=_alias(frozenset,1,inst=False ,name='FrozenSet')\nMappingView=_alias(collections.abc.MappingView,1)\nKeysView=_alias(collections.abc.KeysView,1)\nItemsView=_alias(collections.abc.ItemsView,2)\nValuesView=_alias(collections.abc.ValuesView,1)\nContextManager=_alias(contextlib.AbstractContextManager,1,name='ContextManager')\nAsyncContextManager=_alias(contextlib.AbstractAsyncContextManager,1,name='AsyncContextManager')\nDict=_alias(dict,2,inst=False ,name='Dict')\nDefaultDict=_alias(collections.defaultdict,2,name='DefaultDict')\nOrderedDict=_alias(collections.OrderedDict,2)\nCounter=_alias(collections.Counter,1)\nChainMap=_alias(collections.ChainMap,2)\nGenerator=_alias(collections.abc.Generator,3)\nAsyncGenerator=_alias(collections.abc.AsyncGenerator,2)\nType=_alias(type,1,inst=False ,name='Type')\nType.__doc__=\\\n\"\"\"A special construct usable to annotate class objects.\n\n    For example, suppose we have the following classes::\n\n      class User: ...  # Abstract base for User classes\n      class BasicUser(User): ...\n      class ProUser(User): ...\n      class TeamUser(User): ...\n\n    And a function that takes a class argument that's a subclass of\n    User and returns an instance of the corresponding class::\n\n      U = TypeVar('U', bound=User)\n      def new_user(user_class: Type[U]) -> U:\n          user = user_class()\n          # (Here we could write the user object to a database)\n          return user\n\n      joe = new_user(BasicUser)\n\n    At this point the type checker knows that joe has type BasicUser.\n    \"\"\"\n\n\n@runtime_checkable\nclass SupportsInt(Protocol):\n ''\n __slots__=()\n \n @abstractmethod\n def __int__(self)->int:\n  pass\n  \n  \n@runtime_checkable\nclass SupportsFloat(Protocol):\n ''\n __slots__=()\n \n @abstractmethod\n def __float__(self)->float:\n  pass\n  \n  \n@runtime_checkable\nclass SupportsComplex(Protocol):\n ''\n __slots__=()\n \n @abstractmethod\n def __complex__(self)->complex:\n  pass\n  \n  \n@runtime_checkable\nclass SupportsBytes(Protocol):\n ''\n __slots__=()\n \n @abstractmethod\n def __bytes__(self)->bytes:\n  pass\n  \n  \n@runtime_checkable\nclass SupportsIndex(Protocol):\n ''\n __slots__=()\n \n @abstractmethod\n def __index__(self)->int:\n  pass\n  \n  \n@runtime_checkable\nclass SupportsAbs(Protocol[T_co]):\n ''\n __slots__=()\n \n @abstractmethod\n def __abs__(self)->T_co:\n  pass\n  \n  \n@runtime_checkable\nclass SupportsRound(Protocol[T_co]):\n ''\n __slots__=()\n \n @abstractmethod\n def __round__(self,ndigits:int=0)->T_co:\n  pass\n  \n  \ndef _make_nmtuple(name,types,module,defaults=()):\n fields=[n for n,t in types]\n types={n:_type_check(t,f\"field {n} annotation must be a type\")\n for n,t in types}\n nm_tpl=collections.namedtuple(name,fields,\n defaults=defaults,module=module)\n nm_tpl.__annotations__=nm_tpl.__new__.__annotations__=types\n return nm_tpl\n \n \n \n_prohibited=frozenset({'__new__','__init__','__slots__','__getnewargs__',\n'_fields','_field_defaults',\n'_make','_replace','_asdict','_source'})\n\n_special=frozenset({'__module__','__name__','__annotations__'})\n\n\nclass NamedTupleMeta(type):\n\n def __new__(cls,typename,bases,ns):\n  assert bases[0]is _NamedTuple\n  types=ns.get('__annotations__',{})\n  default_names=[]\n  for field_name in types:\n   if field_name in ns:\n    default_names.append(field_name)\n   elif default_names:\n    raise TypeError(f\"Non-default namedtuple field {field_name} \"\n    f\"cannot follow default field\"\n    f\"{'s' if len(default_names) > 1 else ''} \"\n    f\"{', '.join(default_names)}\")\n  nm_tpl=_make_nmtuple(typename,types.items(),\n  defaults=[ns[n]for n in default_names],\n  module=ns['__module__'])\n  \n  for key in ns:\n   if key in _prohibited:\n    raise AttributeError(\"Cannot overwrite NamedTuple attribute \"+key)\n   elif key not in _special and key not in nm_tpl._fields:\n    setattr(nm_tpl,key,ns[key])\n  return nm_tpl\n  \n  \ndef NamedTuple(typename,fields=None ,/,**kwargs):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n if fields is None :\n  fields=kwargs.items()\n elif kwargs:\n  raise TypeError(\"Either list of fields or keywords\"\n  \" can be provided to NamedTuple, not both\")\n try :\n  module=sys._getframe(1).f_globals.get('__name__','__main__')\n except (AttributeError,ValueError):\n  module=None\n return _make_nmtuple(typename,fields,module=module)\n \n_NamedTuple=type.__new__(NamedTupleMeta,'NamedTuple',(),{})\n\ndef _namedtuple_mro_entries(bases):\n if len(bases)>1:\n  raise TypeError(\"Multiple inheritance with NamedTuple is not supported\")\n assert bases[0]is NamedTuple\n return (_NamedTuple,)\n \nNamedTuple.__mro_entries__=_namedtuple_mro_entries\n\n\nclass _TypedDictMeta(type):\n def __new__(cls,name,bases,ns,total=True ):\n  ''\n\n\n\n\n\n  \n  for base in bases:\n   if type(base)is not _TypedDictMeta:\n    raise TypeError('cannot inherit from both a TypedDict type '\n    'and a non-TypedDict base class')\n  tp_dict=type.__new__(_TypedDictMeta,name,(dict,),ns)\n  \n  annotations={}\n  own_annotations=ns.get('__annotations__',{})\n  own_annotation_keys=set(own_annotations.keys())\n  msg=\"TypedDict('Name', {f0: t0, f1: t1, ...}); each t must be a type\"\n  own_annotations={\n  n:_type_check(tp,msg)for n,tp in own_annotations.items()\n  }\n  required_keys=set()\n  optional_keys=set()\n  \n  for base in bases:\n   annotations.update(base.__dict__.get('__annotations__',{}))\n   required_keys.update(base.__dict__.get('__required_keys__',()))\n   optional_keys.update(base.__dict__.get('__optional_keys__',()))\n   \n  annotations.update(own_annotations)\n  if total:\n   required_keys.update(own_annotation_keys)\n  else :\n   optional_keys.update(own_annotation_keys)\n   \n  tp_dict.__annotations__=annotations\n  tp_dict.__required_keys__=frozenset(required_keys)\n  tp_dict.__optional_keys__=frozenset(optional_keys)\n  if not hasattr(tp_dict,'__total__'):\n   tp_dict.__total__=total\n  return tp_dict\n  \n __call__=dict\n \n def __subclasscheck__(cls,other):\n \n  raise TypeError('TypedDict does not support instance and class checks')\n  \n __instancecheck__=__subclasscheck__\n \n \ndef TypedDict(typename,fields=None ,/,*,total=True ,**kwargs):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n if fields is None :\n  fields=kwargs\n elif kwargs:\n  raise TypeError(\"TypedDict takes either a dict or keyword arguments,\"\n  \" but not both\")\n  \n ns={'__annotations__':dict(fields),'__total__':total}\n try :\n \n  ns['__module__']=sys._getframe(1).f_globals.get('__name__','__main__')\n except (AttributeError,ValueError):\n  pass\n  \n return _TypedDictMeta(typename,(),ns)\n \n_TypedDict=type.__new__(_TypedDictMeta,'TypedDict',(),{})\nTypedDict.__mro_entries__=lambda bases:(_TypedDict,)\n\n\ndef NewType(name,tp):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n def new_type(x):\n  return x\n  \n new_type.__name__=name\n new_type.__supertype__=tp\n return new_type\n \n \n \nText=str\n\n\n\nTYPE_CHECKING=False\n\n\nclass IO(Generic[AnyStr]):\n ''\n\n\n\n\n\n\n\n\n\n \n \n __slots__=()\n \n @property\n @abstractmethod\n def mode(self)->str:\n  pass\n  \n @property\n @abstractmethod\n def name(self)->str:\n  pass\n  \n @abstractmethod\n def close(self)->None :\n  pass\n  \n @property\n @abstractmethod\n def closed(self)->bool:\n  pass\n  \n @abstractmethod\n def fileno(self)->int:\n  pass\n  \n @abstractmethod\n def flush(self)->None :\n  pass\n  \n @abstractmethod\n def isatty(self)->bool:\n  pass\n  \n @abstractmethod\n def read(self,n:int=-1)->AnyStr:\n  pass\n  \n @abstractmethod\n def readable(self)->bool:\n  pass\n  \n @abstractmethod\n def readline(self,limit:int=-1)->AnyStr:\n  pass\n  \n @abstractmethod\n def readlines(self,hint:int=-1)->List[AnyStr]:\n  pass\n  \n @abstractmethod\n def seek(self,offset:int,whence:int=0)->int:\n  pass\n  \n @abstractmethod\n def seekable(self)->bool:\n  pass\n  \n @abstractmethod\n def tell(self)->int:\n  pass\n  \n @abstractmethod\n def truncate(self,size:int=None )->int:\n  pass\n  \n @abstractmethod\n def writable(self)->bool:\n  pass\n  \n @abstractmethod\n def write(self,s:AnyStr)->int:\n  pass\n  \n @abstractmethod\n def writelines(self,lines:List[AnyStr])->None :\n  pass\n  \n @abstractmethod\n def __enter__(self)->'IO[AnyStr]':\n  pass\n  \n @abstractmethod\n def __exit__(self,type,value,traceback)->None :\n  pass\n  \n  \nclass BinaryIO(IO[bytes]):\n ''\n \n __slots__=()\n \n @abstractmethod\n def write(self,s:Union[bytes,bytearray])->int:\n  pass\n  \n @abstractmethod\n def __enter__(self)->'BinaryIO':\n  pass\n  \n  \nclass TextIO(IO[str]):\n ''\n \n __slots__=()\n \n @property\n @abstractmethod\n def buffer(self)->BinaryIO:\n  pass\n  \n @property\n @abstractmethod\n def encoding(self)->str:\n  pass\n  \n @property\n @abstractmethod\n def errors(self)->Optional[str]:\n  pass\n  \n @property\n @abstractmethod\n def line_buffering(self)->bool:\n  pass\n  \n @property\n @abstractmethod\n def newlines(self)->Any:\n  pass\n  \n @abstractmethod\n def __enter__(self)->'TextIO':\n  pass\n  \n  \nclass io:\n ''\n \n __all__=['IO','TextIO','BinaryIO']\n IO=IO\n TextIO=TextIO\n BinaryIO=BinaryIO\n \n \nio.__name__=__name__+'.io'\nsys.modules[io.__name__]=io\n\nPattern=_alias(stdlib_re.Pattern,1)\nMatch=_alias(stdlib_re.Match,1)\n\nclass re:\n ''\n \n __all__=['Pattern','Match']\n Pattern=Pattern\n Match=Match\n \n \nre.__name__=__name__+'.re'\nsys.modules[re.__name__]=re\n", ["abc", "collections", "collections.abc", "contextlib", "functools", "operator", "re", "sys", "types"]],
     "uu": [".py", "#! /usr/bin/env python3\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\"\"\"Implementation of the UUencode and UUdecode functions.\n\nencode(in_file, out_file [,name, mode], *, backtick=False)\ndecode(in_file [, out_file, mode, quiet])\n\"\"\"\n\nimport binascii\nimport os\nimport sys\n\n__all__=[\"Error\",\"encode\",\"decode\"]\n\nclass Error(Exception):\n pass\n \ndef encode(in_file,out_file,name=None ,mode=None ,*,backtick=False ):\n ''\n \n \n \n opened_files=[]\n try :\n  if in_file =='-':\n   in_file=sys.stdin.buffer\n  elif isinstance(in_file,str):\n   if name is None :\n    name=os.path.basename(in_file)\n   if mode is None :\n    try :\n     mode=os.stat(in_file).st_mode\n    except AttributeError:\n     pass\n   in_file=open(in_file,'rb')\n   opened_files.append(in_file)\n   \n   \n   \n  if out_file =='-':\n   out_file=sys.stdout.buffer\n  elif isinstance(out_file,str):\n   out_file=open(out_file,'wb')\n   opened_files.append(out_file)\n   \n   \n   \n  if name is None :\n   name='-'\n  if mode is None :\n   mode=0o666\n   \n   \n   \n   \n  name=name.replace('\\n','\\\\n')\n  name=name.replace('\\r','\\\\r')\n  \n  \n  \n  \n  out_file.write(('begin %o %s\\n'%((mode&0o777),name)).encode(\"ascii\"))\n  data=in_file.read(45)\n  while len(data)>0:\n   out_file.write(binascii.b2a_uu(data,backtick=backtick))\n   data=in_file.read(45)\n  if backtick:\n   out_file.write(b'`\\nend\\n')\n  else :\n   out_file.write(b' \\nend\\n')\n finally :\n  for f in opened_files:\n   f.close()\n   \n   \ndef decode(in_file,out_file=None ,mode=None ,quiet=False ):\n ''\n \n \n \n opened_files=[]\n if in_file =='-':\n  in_file=sys.stdin.buffer\n elif isinstance(in_file,str):\n  in_file=open(in_file,'rb')\n  opened_files.append(in_file)\n  \n try :\n \n \n \n  while True :\n   hdr=in_file.readline()\n   if not hdr:\n    raise Error('No valid begin line found in input file')\n   if not hdr.startswith(b'begin'):\n    continue\n   hdrfields=hdr.split(b' ',2)\n   if len(hdrfields)==3 and hdrfields[0]==b'begin':\n    try :\n     int(hdrfields[1],8)\n     break\n    except ValueError:\n     pass\n  if out_file is None :\n  \n   out_file=hdrfields[2].rstrip(b' \\t\\r\\n\\f').decode(\"ascii\")\n   if os.path.exists(out_file):\n    raise Error('Cannot overwrite existing file: %s'%out_file)\n  if mode is None :\n   mode=int(hdrfields[1],8)\n   \n   \n   \n  if out_file =='-':\n   out_file=sys.stdout.buffer\n  elif isinstance(out_file,str):\n   fp=open(out_file,'wb')\n   os.chmod(out_file,mode)\n   out_file=fp\n   opened_files.append(out_file)\n   \n   \n   \n  s=in_file.readline()\n  while s and s.strip(b' \\t\\r\\n\\f')!=b'end':\n   try :\n    data=binascii.a2b_uu(s)\n   except binascii.Error as v:\n   \n    nbytes=(((s[0]-32)&63)*4+5)//3\n    data=binascii.a2b_uu(s[:nbytes])\n    if not quiet:\n     sys.stderr.write(\"Warning: %s\\n\"%v)\n   out_file.write(data)\n   s=in_file.readline()\n  if not s:\n   raise Error('Truncated input file')\n finally :\n  for f in opened_files:\n   f.close()\n   \ndef test():\n ''\n \n import optparse\n parser=optparse.OptionParser(usage='usage: %prog [-d] [-t] [input [output]]')\n parser.add_option('-d','--decode',dest='decode',help='Decode (instead of encode)?',default=False ,action='store_true')\n parser.add_option('-t','--text',dest='text',help='data is text, encoded format unix-compatible text?',default=False ,action='store_true')\n \n (options,args)=parser.parse_args()\n if len(args)>2:\n  parser.error('incorrect number of arguments')\n  sys.exit(1)\n  \n  \n input=sys.stdin.buffer\n output=sys.stdout.buffer\n if len(args)>0:\n  input=args[0]\n if len(args)>1:\n  output=args[1]\n  \n if options.decode:\n  if options.text:\n   if isinstance(output,str):\n    output=open(output,'wb')\n   else :\n    print(sys.argv[0],': cannot do -t to stdout')\n    sys.exit(1)\n  decode(input,output)\n else :\n  if options.text:\n   if isinstance(input,str):\n    input=open(input,'rb')\n   else :\n    print(sys.argv[0],': cannot do -t from stdin')\n    sys.exit(1)\n  encode(input,output)\n  \nif __name__ =='__main__':\n test()\n", ["binascii", "optparse", "os", "sys"]],
     "uuid": [".py", "''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nimport os\nimport sys\n\nfrom enum import Enum\n\n\n__author__='Ka-Ping Yee <ping@zesty.ca>'\n\n\nif sys.platform in ('win32','darwin'):\n _AIX=_LINUX=False\nelse :\n import platform\n _platform_system=platform.system()\n _AIX=_platform_system =='AIX'\n _LINUX=_platform_system =='Linux'\n \n_MAC_DELIM=b':'\n_MAC_OMITS_LEADING_ZEROES=False\nif _AIX:\n _MAC_DELIM=b'.'\n _MAC_OMITS_LEADING_ZEROES=True\n \nRESERVED_NCS,RFC_4122,RESERVED_MICROSOFT,RESERVED_FUTURE=[\n'reserved for NCS compatibility','specified in RFC 4122',\n'reserved for Microsoft compatibility','reserved for future definition']\n\nint_=int\nbytes_=bytes\n\n\nclass SafeUUID(Enum):\n safe=0\n unsafe=-1\n unknown=None\n \n \nclass UUID:\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n __slots__=('int','is_safe','__weakref__')\n \n def __init__(self,hex=None ,bytes=None ,bytes_le=None ,fields=None ,\n int=None ,version=None ,\n *,is_safe=SafeUUID.unknown):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  \n  if [hex,bytes,bytes_le,fields,int].count(None )!=4:\n   raise TypeError('one of the hex, bytes, bytes_le, fields, '\n   'or int arguments must be given')\n  if hex is not None :\n   hex=hex.replace('urn:','').replace('uuid:','')\n   hex=hex.strip('{}').replace('-','')\n   if len(hex)!=32:\n    raise ValueError('badly formed hexadecimal UUID string')\n   int=int_(hex,16)\n  if bytes_le is not None :\n   if len(bytes_le)!=16:\n    raise ValueError('bytes_le is not a 16-char string')\n   bytes=(bytes_le[4 -1::-1]+bytes_le[6 -1:4 -1:-1]+\n   bytes_le[8 -1:6 -1:-1]+bytes_le[8:])\n  if bytes is not None :\n   if len(bytes)!=16:\n    raise ValueError('bytes is not a 16-char string')\n   assert isinstance(bytes,bytes_),repr(bytes)\n   int=int_.from_bytes(bytes,byteorder='big')\n  if fields is not None :\n   if len(fields)!=6:\n    raise ValueError('fields is not a 6-tuple')\n   (time_low,time_mid,time_hi_version,\n   clock_seq_hi_variant,clock_seq_low,node)=fields\n   if not 0 <=time_low <1 <<32:\n    raise ValueError('field 1 out of range (need a 32-bit value)')\n   if not 0 <=time_mid <1 <<16:\n    raise ValueError('field 2 out of range (need a 16-bit value)')\n   if not 0 <=time_hi_version <1 <<16:\n    raise ValueError('field 3 out of range (need a 16-bit value)')\n   if not 0 <=clock_seq_hi_variant <1 <<8:\n    raise ValueError('field 4 out of range (need an 8-bit value)')\n   if not 0 <=clock_seq_low <1 <<8:\n    raise ValueError('field 5 out of range (need an 8-bit value)')\n   if not 0 <=node <1 <<48:\n    raise ValueError('field 6 out of range (need a 48-bit value)')\n   clock_seq=(clock_seq_hi_variant <<8)|clock_seq_low\n   int=((time_low <<96)|(time_mid <<80)|\n   (time_hi_version <<64)|(clock_seq <<48)|node)\n  if int is not None :\n   if not 0 <=int <1 <<128:\n    raise ValueError('int is out of range (need a 128-bit value)')\n  if version is not None :\n   if not 1 <=version <=5:\n    raise ValueError('illegal version number')\n    \n   int &=~(0xc000 <<48)\n   int |=0x8000 <<48\n   \n   int &=~(0xf000 <<64)\n   int |=version <<76\n  object.__setattr__(self,'int',int)\n  object.__setattr__(self,'is_safe',is_safe)\n  \n def __getstate__(self):\n  d={'int':self.int}\n  if self.is_safe !=SafeUUID.unknown:\n  \n  \n   d['is_safe']=self.is_safe.value\n  return d\n  \n def __setstate__(self,state):\n  object.__setattr__(self,'int',state['int'])\n  \n  object.__setattr__(self,'is_safe',\n  SafeUUID(state['is_safe'])\n  if 'is_safe'in state else SafeUUID.unknown)\n  \n def __eq__(self,other):\n  if isinstance(other,UUID):\n   return self.int ==other.int\n  return NotImplemented\n  \n  \n  \n  \n def __lt__(self,other):\n  if isinstance(other,UUID):\n   return self.int <other.int\n  return NotImplemented\n  \n def __gt__(self,other):\n  if isinstance(other,UUID):\n   return self.int >other.int\n  return NotImplemented\n  \n def __le__(self,other):\n  if isinstance(other,UUID):\n   return self.int <=other.int\n  return NotImplemented\n  \n def __ge__(self,other):\n  if isinstance(other,UUID):\n   return self.int >=other.int\n  return NotImplemented\n  \n def __hash__(self):\n  return hash(self.int)\n  \n def __int__(self):\n  return self.int\n  \n def __repr__(self):\n  return '%s(%r)'%(self.__class__.__name__,str(self))\n  \n def __setattr__(self,name,value):\n  raise TypeError('UUID objects are immutable')\n  \n def __str__(self):\n  hex='%032x'%self.int\n  return '%s-%s-%s-%s-%s'%(\n  hex[:8],hex[8:12],hex[12:16],hex[16:20],hex[20:])\n  \n @property\n def bytes(self):\n  return self.int.to_bytes(16,'big')\n  \n @property\n def bytes_le(self):\n  bytes=self.bytes\n  return (bytes[4 -1::-1]+bytes[6 -1:4 -1:-1]+bytes[8 -1:6 -1:-1]+\n  bytes[8:])\n  \n @property\n def fields(self):\n  return (self.time_low,self.time_mid,self.time_hi_version,\n  self.clock_seq_hi_variant,self.clock_seq_low,self.node)\n  \n @property\n def time_low(self):\n  return self.int >>96\n  \n @property\n def time_mid(self):\n  return (self.int >>80)&0xffff\n  \n @property\n def time_hi_version(self):\n  return (self.int >>64)&0xffff\n  \n @property\n def clock_seq_hi_variant(self):\n  return (self.int >>56)&0xff\n  \n @property\n def clock_seq_low(self):\n  return (self.int >>48)&0xff\n  \n @property\n def time(self):\n  return (((self.time_hi_version&0x0fff)<<48)|\n  (self.time_mid <<32)|self.time_low)\n  \n @property\n def clock_seq(self):\n  return (((self.clock_seq_hi_variant&0x3f)<<8)|\n  self.clock_seq_low)\n  \n @property\n def node(self):\n  return self.int&0xffffffffffff\n  \n @property\n def hex(self):\n  return '%032x'%self.int\n  \n @property\n def urn(self):\n  return 'urn:uuid:'+str(self)\n  \n @property\n def variant(self):\n  if not self.int&(0x8000 <<48):\n   return RESERVED_NCS\n  elif not self.int&(0x4000 <<48):\n   return RFC_4122\n  elif not self.int&(0x2000 <<48):\n   return RESERVED_MICROSOFT\n  else :\n   return RESERVED_FUTURE\n   \n @property\n def version(self):\n \n  if self.variant ==RFC_4122:\n   return int((self.int >>76)&0xf)\n   \n   \ndef _get_command_stdout(command,*args):\n import io,os,shutil,subprocess\n \n try :\n  path_dirs=os.environ.get('PATH',os.defpath).split(os.pathsep)\n  path_dirs.extend(['/sbin','/usr/sbin'])\n  executable=shutil.which(command,path=os.pathsep.join(path_dirs))\n  if executable is None :\n   return None\n   \n   \n   \n  env=dict(os.environ)\n  env['LC_ALL']='C'\n  proc=subprocess.Popen((executable,)+args,\n  stdout=subprocess.PIPE,\n  stderr=subprocess.DEVNULL,\n  env=env)\n  if not proc:\n   return None\n  stdout,stderr=proc.communicate()\n  return io.BytesIO(stdout)\n except (OSError,subprocess.SubprocessError):\n  return None\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \ndef _is_universal(mac):\n return not (mac&(1 <<41))\n \n \ndef _find_mac_near_keyword(command,args,keywords,get_word_index):\n ''\n\n\n\n\n\n\n \n stdout=_get_command_stdout(command,args)\n if stdout is None :\n  return None\n  \n first_local_mac=None\n for line in stdout:\n  words=line.lower().rstrip().split()\n  for i in range(len(words)):\n   if words[i]in keywords:\n    try :\n     word=words[get_word_index(i)]\n     mac=int(word.replace(_MAC_DELIM,b''),16)\n    except (ValueError,IndexError):\n    \n    \n    \n    \n    \n     pass\n    else :\n     if _is_universal(mac):\n      return mac\n     first_local_mac=first_local_mac or mac\n return first_local_mac or None\n \n \ndef _parse_mac(word):\n\n\n\n\n\n\n parts=word.split(_MAC_DELIM)\n if len(parts)!=6:\n  return\n if _MAC_OMITS_LEADING_ZEROES:\n \n \n \n \n  if not all(1 <=len(part)<=2 for part in parts):\n   return\n  hexstr=b''.join(part.rjust(2,b'0')for part in parts)\n else :\n  if not all(len(part)==2 for part in parts):\n   return\n  hexstr=b''.join(parts)\n try :\n  return int(hexstr,16)\n except ValueError:\n  return\n  \n  \ndef _find_mac_under_heading(command,args,heading):\n ''\n\n\n\n\n \n stdout=_get_command_stdout(command,args)\n if stdout is None :\n  return None\n  \n keywords=stdout.readline().rstrip().split()\n try :\n  column_index=keywords.index(heading)\n except ValueError:\n  return None\n  \n first_local_mac=None\n for line in stdout:\n  words=line.rstrip().split()\n  try :\n   word=words[column_index]\n  except IndexError:\n   continue\n   \n  mac=_parse_mac(word)\n  if mac is None :\n   continue\n  if _is_universal(mac):\n   return mac\n  if first_local_mac is None :\n   first_local_mac=mac\n   \n return first_local_mac\n \n \n \n \ndef _ifconfig_getnode():\n ''\n \n keywords=(b'hwaddr',b'ether',b'address:',b'lladdr')\n for args in ('','-a','-av'):\n  mac=_find_mac_near_keyword('ifconfig',args,keywords,lambda i:i+1)\n  if mac:\n   return mac\n  return None\n  \ndef _ip_getnode():\n ''\n \n mac=_find_mac_near_keyword('ip','link',[b'link/ether'],lambda i:i+1)\n if mac:\n  return mac\n return None\n \ndef _arp_getnode():\n ''\n import os,socket\n try :\n  ip_addr=socket.gethostbyname(socket.gethostname())\n except OSError:\n  return None\n  \n  \n mac=_find_mac_near_keyword('arp','-an',[os.fsencode(ip_addr)],lambda i:-1)\n if mac:\n  return mac\n  \n  \n mac=_find_mac_near_keyword('arp','-an',[os.fsencode(ip_addr)],lambda i:i+1)\n if mac:\n  return mac\n  \n  \n mac=_find_mac_near_keyword('arp','-an',[os.fsencode('(%s)'%ip_addr)],\n lambda i:i+2)\n \n if mac:\n  return mac\n return None\n \ndef _lanscan_getnode():\n ''\n \n return _find_mac_near_keyword('lanscan','-ai',[b'lan0'],lambda i:0)\n \ndef _netstat_getnode():\n ''\n \n return _find_mac_under_heading('netstat','-ian',b'Address')\n \ndef _ipconfig_getnode():\n ''\n \n return _windll_getnode()\n \ndef _netbios_getnode():\n ''\n \n return _windll_getnode()\n \n \n \ntry :\n import _uuid\n _generate_time_safe=getattr(_uuid,\"generate_time_safe\",None )\n _UuidCreate=getattr(_uuid,\"UuidCreate\",None )\n _has_uuid_generate_time_safe=_uuid.has_uuid_generate_time_safe\nexcept ImportError:\n _uuid=None\n _generate_time_safe=None\n _UuidCreate=None\n _has_uuid_generate_time_safe=None\n \n \ndef _load_system_functions():\n ''\n \n \ndef _unix_getnode():\n ''\n if _generate_time_safe:\n  uuid_time,_=_generate_time_safe()\n  return UUID(bytes=uuid_time).node\n  \ndef _windll_getnode():\n ''\n if _UuidCreate:\n  uuid_bytes=_UuidCreate()\n  return UUID(bytes_le=uuid_bytes).node\n  \ndef _random_getnode():\n ''\n \n \n \n \n \n \n \n \n \n \n import random\n return random.getrandbits(48)|(1 <<40)\n \n \n \n \n \n \n \n \nif _LINUX:\n _OS_GETTERS=[_ip_getnode,_ifconfig_getnode]\nelif sys.platform =='darwin':\n _OS_GETTERS=[_ifconfig_getnode,_arp_getnode,_netstat_getnode]\nelif sys.platform =='win32':\n\n _OS_GETTERS=[]\nelif _AIX:\n _OS_GETTERS=[_netstat_getnode]\nelse :\n _OS_GETTERS=[_ifconfig_getnode,_ip_getnode,_arp_getnode,\n _netstat_getnode,_lanscan_getnode]\nif os.name =='posix':\n _GETTERS=[_unix_getnode]+_OS_GETTERS\nelif os.name =='nt':\n _GETTERS=[_windll_getnode]+_OS_GETTERS\nelse :\n _GETTERS=_OS_GETTERS\n \n_node=None\n\ndef getnode():\n ''\n\n\n\n\n\n \n global _node\n if _node is not None :\n  return _node\n  \n for getter in _GETTERS+[_random_getnode]:\n  try :\n   _node=getter()\n  except :\n   continue\n  if (_node is not None )and (0 <=_node <(1 <<48)):\n   return _node\n assert False ,'_random_getnode() returned invalid value: {}'.format(_node)\n \n \n_last_timestamp=None\n\ndef uuid1(node=None ,clock_seq=None ):\n ''\n\n\n \n \n \n \n if _generate_time_safe is not None and node is clock_seq is None :\n  uuid_time,safely_generated=_generate_time_safe()\n  try :\n   is_safe=SafeUUID(safely_generated)\n  except ValueError:\n   is_safe=SafeUUID.unknown\n  return UUID(bytes=uuid_time,is_safe=is_safe)\n  \n global _last_timestamp\n import time\n nanoseconds=time.time_ns()\n \n \n timestamp=nanoseconds //100+0x01b21dd213814000\n if _last_timestamp is not None and timestamp <=_last_timestamp:\n  timestamp=_last_timestamp+1\n _last_timestamp=timestamp\n if clock_seq is None :\n  import random\n  clock_seq=random.getrandbits(14)\n time_low=timestamp&0xffffffff\n time_mid=(timestamp >>32)&0xffff\n time_hi_version=(timestamp >>48)&0x0fff\n clock_seq_low=clock_seq&0xff\n clock_seq_hi_variant=(clock_seq >>8)&0x3f\n if node is None :\n  node=getnode()\n return UUID(fields=(time_low,time_mid,time_hi_version,\n clock_seq_hi_variant,clock_seq_low,node),version=1)\n \ndef uuid3(namespace,name):\n ''\n from hashlib import md5\n digest=md5(\n namespace.bytes+bytes(name,\"utf-8\"),\n usedforsecurity=False\n ).digest()\n return UUID(bytes=digest[:16],version=3)\n \ndef uuid4():\n ''\n return UUID(bytes=os.urandom(16),version=4)\n \ndef uuid5(namespace,name):\n ''\n from hashlib import sha1\n hash=sha1(namespace.bytes+bytes(name,\"utf-8\")).digest()\n return UUID(bytes=hash[:16],version=5)\n \n \n \nNAMESPACE_DNS=UUID('6ba7b810-9dad-11d1-80b4-00c04fd430c8')\nNAMESPACE_URL=UUID('6ba7b811-9dad-11d1-80b4-00c04fd430c8')\nNAMESPACE_OID=UUID('6ba7b812-9dad-11d1-80b4-00c04fd430c8')\nNAMESPACE_X500=UUID('6ba7b814-9dad-11d1-80b4-00c04fd430c8')\n", ["_uuid", "enum", "hashlib", "io", "os", "platform", "random", "shutil", "socket", "subprocess", "sys", "time"]],
     "VFS_import": [".py", "import os\nimport sys\nfrom browser import doc\n\n\n\n\n\n\nVFS=dict(JSObject(__BRYTHON__.py_VFS))\nclass VFSModuleFinder:\n def __init__(self,path_entry):\n  print(\"in VFSModuleFinder\")\n  if path_entry.startswith('/libs')or path_entry.startswith('/Lib'):\n   self.path_entry=path_entry\n  else :\n   raise ImportError()\n   \n def __str__(self):\n  return '<%s for \"%s\">'%(self.__class__.__name__,self.path_entry)\n  \n def find_module(self,fullname,path=None ):\n  path=path or self.path_entry\n  \n  for _ext in ['js','pyj','py']:\n   _filepath=os.path.join(self.path_entry,'%s.%s'%(fullname,_ext))\n   if _filepath in VFS:\n    print(\"module found at %s:%s\"%(_filepath,fullname))\n    return VFSModuleLoader(_filepath,fullname)\n    \n  print('module %s not found'%fullname)\n  raise ImportError()\n  return None\n  \nclass VFSModuleLoader:\n ''\n \n def __init__(self,filepath,name):\n  self._filepath=filepath\n  self._name=name\n  \n def get_source(self):\n  if self._filepath in VFS:\n   return JSObject(readFromVFS(self._filepath))\n   \n  raise ImportError('could not find source for %s'%fullname)\n  \n def is_package(self):\n  return '.'in self._name\n  \n def load_module(self):\n  if self._name in sys.modules:\n  \n   mod=sys.modules[self._name]\n   return mod\n   \n  _src=self.get_source()\n  if self._filepath.endswith('.js'):\n   mod=JSObject(import_js_module(_src,self._filepath,self._name))\n  elif self._filepath.endswith('.py'):\n   mod=JSObject(import_py_module(_src,self._filepath,self._name))\n  elif self._filepath.endswith('.pyj'):\n   mod=JSObject(import_pyj_module(_src,self._filepath,self._name))\n  else :\n   raise ImportError('Invalid Module: %s'%self._filepath)\n   \n   \n  mod.__file__=self._filepath\n  mod.__name__=self._name\n  mod.__path__=os.path.abspath(self._filepath)\n  mod.__loader__=self\n  mod.__package__='.'.join(self._name.split('.')[:-1])\n  \n  if self.is_package():\n   print('adding path for package')\n   \n   \n   mod.__path__=[self.path_entry]\n  else :\n   print('imported as regular module')\n   \n  print('creating a new module object for \"%s\"'%self._name)\n  sys.modules.setdefault(self._name,mod)\n  JSObject(__BRYTHON__.imported)[self._name]=mod\n  \n  return mod\n  \nJSObject(__BRYTHON__.path_hooks.insert(0,VFSModuleFinder))\n", ["browser", "os", "sys"]],
     "warnings": [".py", "''\n\nimport sys\n\n\n__all__=[\"warn\",\"warn_explicit\",\"showwarning\",\n\"formatwarning\",\"filterwarnings\",\"simplefilter\",\n\"resetwarnings\",\"catch_warnings\"]\n\ndef showwarning(message,category,filename,lineno,file=None ,line=None ):\n ''\n msg=WarningMessage(message,category,filename,lineno,file,line)\n _showwarnmsg_impl(msg)\n \ndef formatwarning(message,category,filename,lineno,line=None ):\n ''\n msg=WarningMessage(message,category,filename,lineno,None ,line)\n return _formatwarnmsg_impl(msg)\n \ndef _showwarnmsg_impl(msg):\n file=msg.file\n if file is None :\n  file=sys.stderr\n  if file is None :\n  \n  \n   return\n text=_formatwarnmsg(msg)\n try :\n  file.write(text)\n except OSError:\n \n  pass\n  \ndef _formatwarnmsg_impl(msg):\n category=msg.category.__name__\n s=f\"{msg.filename}:{msg.lineno}: {category}: {msg.message}\\n\"\n \n if msg.line is None :\n  try :\n   import linecache\n   line=linecache.getline(msg.filename,msg.lineno)\n  except Exception:\n  \n  \n   line=None\n   linecache=None\n else :\n  line=msg.line\n if line:\n  line=line.strip()\n  s +=\"  %s\\n\"%line\n  \n if msg.source is not None :\n  try :\n   import tracemalloc\n   \n   \n  except Exception:\n  \n   tracing=True\n   tb=None\n  else :\n   tracing=tracemalloc.is_tracing()\n   try :\n    tb=tracemalloc.get_object_traceback(msg.source)\n   except Exception:\n   \n   \n    tb=None\n    \n  if tb is not None :\n   s +='Object allocated at (most recent call last):\\n'\n   for frame in tb:\n    s +=('  File \"%s\", lineno %s\\n'\n    %(frame.filename,frame.lineno))\n    \n    try :\n     if linecache is not None :\n      line=linecache.getline(frame.filename,frame.lineno)\n     else :\n      line=None\n    except Exception:\n     line=None\n    if line:\n     line=line.strip()\n     s +='    %s\\n'%line\n  elif not tracing:\n   s +=(f'{category}: Enable tracemalloc to get the object '\n   f'allocation traceback\\n')\n return s\n \n \n_showwarning_orig=showwarning\n\ndef _showwarnmsg(msg):\n ''\n try :\n  sw=showwarning\n except NameError:\n  pass\n else :\n  if sw is not _showwarning_orig:\n  \n   if not callable(sw):\n    raise TypeError(\"warnings.showwarning() must be set to a \"\n    \"function or method\")\n    \n   sw(msg.message,msg.category,msg.filename,msg.lineno,\n   msg.file,msg.line)\n   return\n _showwarnmsg_impl(msg)\n \n \n_formatwarning_orig=formatwarning\n\ndef _formatwarnmsg(msg):\n ''\n try :\n  fw=formatwarning\n except NameError:\n  pass\n else :\n  if fw is not _formatwarning_orig:\n  \n   return fw(msg.message,msg.category,\n   msg.filename,msg.lineno,msg.line)\n return _formatwarnmsg_impl(msg)\n \ndef filterwarnings(action,message=\"\",category=Warning,module=\"\",lineno=0,\nappend=False ):\n ''\n\n\n\n\n\n\n\n\n \n assert action in (\"error\",\"ignore\",\"always\",\"default\",\"module\",\n \"once\"),\"invalid action: %r\"%(action,)\n assert isinstance(message,str),\"message must be a string\"\n assert isinstance(category,type),\"category must be a class\"\n assert issubclass(category,Warning),\"category must be a Warning subclass\"\n assert isinstance(module,str),\"module must be a string\"\n assert isinstance(lineno,int)and lineno >=0,\\\n \"lineno must be an int >= 0\"\n \n if message or module:\n  import re\n  \n if message:\n  message=re.compile(message,re.I)\n else :\n  message=None\n if module:\n  module=re.compile(module)\n else :\n  module=None\n  \n _add_filter(action,message,category,module,lineno,append=append)\n \ndef simplefilter(action,category=Warning,lineno=0,append=False ):\n ''\n\n\n\n\n\n\n\n \n assert action in (\"error\",\"ignore\",\"always\",\"default\",\"module\",\n \"once\"),\"invalid action: %r\"%(action,)\n assert isinstance(lineno,int)and lineno >=0,\\\n \"lineno must be an int >= 0\"\n _add_filter(action,None ,category,None ,lineno,append=append)\n \ndef _add_filter(*item,append):\n\n\n if not append:\n  try :\n   filters.remove(item)\n  except ValueError:\n   pass\n  filters.insert(0,item)\n else :\n  if item not in filters:\n   filters.append(item)\n _filters_mutated()\n \ndef resetwarnings():\n ''\n filters[:]=[]\n _filters_mutated()\n \nclass _OptionError(Exception):\n ''\n pass\n \n \ndef _processoptions(args):\n for arg in args:\n  try :\n   _setoption(arg)\n  except _OptionError as msg:\n   print(\"Invalid -W option ignored:\",msg,file=sys.stderr)\n   \n   \ndef _setoption(arg):\n parts=arg.split(':')\n if len(parts)>5:\n  raise _OptionError(\"too many fields (max 5): %r\"%(arg,))\n while len(parts)<5:\n  parts.append('')\n action,message,category,module,lineno=[s.strip()\n for s in parts]\n action=_getaction(action)\n category=_getcategory(category)\n if message or module:\n  import re\n if message:\n  message=re.escape(message)\n if module:\n  module=re.escape(module)+r'\\Z'\n if lineno:\n  try :\n   lineno=int(lineno)\n   if lineno <0:\n    raise ValueError\n  except (ValueError,OverflowError):\n   raise _OptionError(\"invalid lineno %r\"%(lineno,))from None\n else :\n  lineno=0\n filterwarnings(action,message,category,module,lineno)\n \n \ndef _getaction(action):\n if not action:\n  return \"default\"\n if action ==\"all\":return \"always\"\n for a in ('default','always','ignore','module','once','error'):\n  if a.startswith(action):\n   return a\n raise _OptionError(\"invalid action: %r\"%(action,))\n \n \ndef _getcategory(category):\n if not category:\n  return Warning\n if '.'not in category:\n  import builtins as m\n  klass=category\n else :\n  module,_,klass=category.rpartition('.')\n  try :\n   m=__import__(module,None ,None ,[klass])\n  except ImportError:\n   raise _OptionError(\"invalid module name: %r\"%(module,))from None\n try :\n  cat=getattr(m,klass)\n except AttributeError:\n  raise _OptionError(\"unknown warning category: %r\"%(category,))from None\n if not issubclass(cat,Warning):\n  raise _OptionError(\"invalid warning category: %r\"%(category,))\n return cat\n \n \ndef _is_internal_frame(frame):\n ''\n filename=frame.f_code.co_filename\n return 'importlib'in filename and '_bootstrap'in filename\n \n \ndef _next_external_frame(frame):\n ''\n frame=frame.f_back\n while frame is not None and _is_internal_frame(frame):\n  frame=frame.f_back\n return frame\n \n \n \ndef warn(message,category=None ,stacklevel=1,source=None ):\n ''\n \n if isinstance(message,Warning):\n  category=message.__class__\n  \n if category is None :\n  category=UserWarning\n if not (isinstance(category,type)and issubclass(category,Warning)):\n  raise TypeError(\"category must be a Warning subclass, \"\n  \"not '{:s}'\".format(type(category).__name__))\n  \n try :\n  if stacklevel <=1 or _is_internal_frame(sys._getframe(1)):\n  \n  \n   frame=sys._getframe(stacklevel)\n  else :\n   frame=sys._getframe(1)\n   \n   for x in range(stacklevel -1):\n    frame=_next_external_frame(frame)\n    if frame is None :\n     raise ValueError\n except ValueError:\n  globals=sys.__dict__\n  filename=\"sys\"\n  lineno=1\n else :\n  globals=frame.f_globals\n  filename=frame.f_code.co_filename\n  lineno=frame.f_lineno\n if '__name__'in globals:\n  module=globals['__name__']\n else :\n  module=\"<string>\"\n registry=globals.setdefault(\"__warningregistry__\",{})\n warn_explicit(message,category,filename,lineno,module,registry,\n globals,source)\n \ndef warn_explicit(message,category,filename,lineno,\nmodule=None ,registry=None ,module_globals=None ,\nsource=None ):\n lineno=int(lineno)\n if module is None :\n  module=filename or \"<unknown>\"\n  if module[-3:].lower()==\".py\":\n   module=module[:-3]\n if registry is None :\n  registry={}\n if registry.get('version',0)!=_filters_version:\n  registry.clear()\n  registry['version']=_filters_version\n if isinstance(message,Warning):\n  text=str(message)\n  category=message.__class__\n else :\n  text=message\n  message=category(message)\n key=(text,category,lineno)\n \n if registry.get(key):\n  return\n  \n for item in filters:\n  action,msg,cat,mod,ln=item\n  if ((msg is None or msg.match(text))and\n  issubclass(category,cat)and\n  (mod is None or mod.match(module))and\n  (ln ==0 or lineno ==ln)):\n   break\n else :\n  action=defaultaction\n  \n if action ==\"ignore\":\n  return\n  \n  \n  \n import linecache\n linecache.getlines(filename,module_globals)\n \n if action ==\"error\":\n  raise message\n  \n if action ==\"once\":\n  registry[key]=1\n  oncekey=(text,category)\n  if onceregistry.get(oncekey):\n   return\n  onceregistry[oncekey]=1\n elif action ==\"always\":\n  pass\n elif action ==\"module\":\n  registry[key]=1\n  altkey=(text,category,0)\n  if registry.get(altkey):\n   return\n  registry[altkey]=1\n elif action ==\"default\":\n  registry[key]=1\n else :\n \n  raise RuntimeError(\n  \"Unrecognized action (%r) in warnings.filters:\\n %s\"%\n  (action,item))\n  \n msg=WarningMessage(message,category,filename,lineno,source)\n _showwarnmsg(msg)\n \n \nclass WarningMessage(object):\n\n _WARNING_DETAILS=(\"message\",\"category\",\"filename\",\"lineno\",\"file\",\n \"line\",\"source\")\n \n def __init__(self,message,category,filename,lineno,file=None ,\n line=None ,source=None ):\n  self.message=message\n  self.category=category\n  self.filename=filename\n  self.lineno=lineno\n  self.file=file\n  self.line=line\n  self.source=source\n  self._category_name=category.__name__ if category else None\n  \n def __str__(self):\n  return (\"{message : %r, category : %r, filename : %r, lineno : %s, \"\n  \"line : %r}\"%(self.message,self._category_name,\n  self.filename,self.lineno,self.line))\n  \n  \nclass catch_warnings(object):\n\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n def __init__(self,*,record=False ,module=None ):\n  ''\n\n\n\n\n\n  \n  self._record=record\n  self._module=sys.modules['warnings']if module is None else module\n  self._entered=False\n  \n def __repr__(self):\n  args=[]\n  if self._record:\n   args.append(\"record=True\")\n  if self._module is not sys.modules['warnings']:\n   args.append(\"module=%r\"%self._module)\n  name=type(self).__name__\n  return \"%s(%s)\"%(name,\", \".join(args))\n  \n def __enter__(self):\n  if self._entered:\n   raise RuntimeError(\"Cannot enter %r twice\"%self)\n  self._entered=True\n  self._filters=self._module.filters\n  self._module.filters=self._filters[:]\n  self._module._filters_mutated()\n  self._showwarning=self._module.showwarning\n  self._showwarnmsg_impl=self._module._showwarnmsg_impl\n  if self._record:\n   log=[]\n   self._module._showwarnmsg_impl=log.append\n   \n   \n   self._module.showwarning=self._module._showwarning_orig\n   return log\n  else :\n   return None\n   \n def __exit__(self,*exc_info):\n  if not self._entered:\n   raise RuntimeError(\"Cannot exit %r without entering first\"%self)\n  self._module.filters=self._filters\n  self._module._filters_mutated()\n  self._module.showwarning=self._showwarning\n  self._module._showwarnmsg_impl=self._showwarnmsg_impl\n  \n  \n  \ndef _warn_unawaited_coroutine(coro):\n msg_lines=[\n f\"coroutine '{coro.__qualname__}' was never awaited\\n\"\n ]\n if coro.cr_origin is not None :\n  import linecache,traceback\n  def extract():\n   for filename,lineno,funcname in reversed(coro.cr_origin):\n    line=linecache.getline(filename,lineno)\n    yield (filename,lineno,funcname,line)\n  msg_lines.append(\"Coroutine created at (most recent call last)\\n\")\n  msg_lines +=traceback.format_list(list(extract()))\n msg=\"\".join(msg_lines).rstrip(\"\\n\")\n \n \n \n \n \n \n warn(msg,category=RuntimeWarning,stacklevel=2,source=coro)\n \n \n \n \n \n \n \n \n \n \ntry :\n from _warnings import (filters,_defaultaction,_onceregistry,\n warn,warn_explicit,_filters_mutated)\n defaultaction=_defaultaction\n onceregistry=_onceregistry\n _warnings_defaults=True\nexcept ImportError:\n filters=[]\n defaultaction=\"default\"\n onceregistry={}\n \n _filters_version=1\n \n def _filters_mutated():\n  global _filters_version\n  _filters_version +=1\n  \n _warnings_defaults=False\n \n \n \n_processoptions(sys.warnoptions)\nif not _warnings_defaults:\n\n if not hasattr(sys,'gettotalrefcount'):\n  filterwarnings(\"default\",category=DeprecationWarning,\n  module=\"__main__\",append=1)\n  simplefilter(\"ignore\",category=DeprecationWarning,append=1)\n  simplefilter(\"ignore\",category=PendingDeprecationWarning,append=1)\n  simplefilter(\"ignore\",category=ImportWarning,append=1)\n  simplefilter(\"ignore\",category=ResourceWarning,append=1)\n  \ndel _warnings_defaults\n", ["_warnings", "builtins", "linecache", "re", "sys", "traceback", "tracemalloc"]],
     "weakref": [".py", "''\n\n\n\n\n\n\n\n\n\n\nfrom _weakref import (\ngetweakrefcount,\ngetweakrefs,\nref,\nproxy,\nCallableProxyType,\nProxyType,\nReferenceType,\n_remove_dead_weakref)\n\nfrom _weakrefset import WeakSet,_IterationGuard\n\nimport _collections_abc\nimport sys\nimport itertools\n\nProxyTypes=(ProxyType,CallableProxyType)\n\n__all__=[\"ref\",\"proxy\",\"getweakrefcount\",\"getweakrefs\",\n\"WeakKeyDictionary\",\"ReferenceType\",\"ProxyType\",\n\"CallableProxyType\",\"ProxyTypes\",\"WeakValueDictionary\",\n\"WeakSet\",\"WeakMethod\",\"finalize\"]\n\n\n_collections_abc.Set.register(WeakSet)\n_collections_abc.MutableSet.register(WeakSet)\n\nclass WeakMethod(ref):\n ''\n\n\n \n \n __slots__=\"_func_ref\",\"_meth_type\",\"_alive\",\"__weakref__\"\n \n def __new__(cls,meth,callback=None ):\n  try :\n   obj=meth.__self__\n   func=meth.__func__\n  except AttributeError:\n   raise TypeError(\"argument should be a bound method, not {}\"\n   .format(type(meth)))from None\n  def _cb(arg):\n  \n  \n   self=self_wr()\n   if self._alive:\n    self._alive=False\n    if callback is not None :\n     callback(self)\n  self=ref.__new__(cls,obj,_cb)\n  self._func_ref=ref(func,_cb)\n  self._meth_type=type(meth)\n  self._alive=True\n  self_wr=ref(self)\n  return self\n  \n def __call__(self):\n  obj=super().__call__()\n  func=self._func_ref()\n  if obj is None or func is None :\n   return None\n  return self._meth_type(func,obj)\n  \n def __eq__(self,other):\n  if isinstance(other,WeakMethod):\n   if not self._alive or not other._alive:\n    return self is other\n   return ref.__eq__(self,other)and self._func_ref ==other._func_ref\n  return NotImplemented\n  \n def __ne__(self,other):\n  if isinstance(other,WeakMethod):\n   if not self._alive or not other._alive:\n    return self is not other\n   return ref.__ne__(self,other)or self._func_ref !=other._func_ref\n  return NotImplemented\n  \n __hash__=ref.__hash__\n \n \nclass WeakValueDictionary(_collections_abc.MutableMapping):\n ''\n\n\n\n \n \n \n \n \n \n \n def __init__(self,other=(),/,**kw):\n  def remove(wr,selfref=ref(self),_atomic_removal=_remove_dead_weakref):\n   self=selfref()\n   if self is not None :\n    if self._iterating:\n     self._pending_removals.append(wr.key)\n    else :\n    \n    \n     _atomic_removal(self.data,wr.key)\n  self._remove=remove\n  \n  self._pending_removals=[]\n  self._iterating=set()\n  self.data={}\n  self.update(other,**kw)\n  \n def _commit_removals(self):\n  l=self._pending_removals\n  d=self.data\n  \n  \n  while l:\n   key=l.pop()\n   _remove_dead_weakref(d,key)\n   \n def __getitem__(self,key):\n  if self._pending_removals:\n   self._commit_removals()\n  o=self.data[key]()\n  if o is None :\n   raise KeyError(key)\n  else :\n   return o\n   \n def __delitem__(self,key):\n  if self._pending_removals:\n   self._commit_removals()\n  del self.data[key]\n  \n def __len__(self):\n  if self._pending_removals:\n   self._commit_removals()\n  return len(self.data)\n  \n def __contains__(self,key):\n  if self._pending_removals:\n   self._commit_removals()\n  try :\n   o=self.data[key]()\n  except KeyError:\n   return False\n  return o is not None\n  \n def __repr__(self):\n  return \"<%s at %#x>\"%(self.__class__.__name__,id(self))\n  \n def __setitem__(self,key,value):\n  if self._pending_removals:\n   self._commit_removals()\n  self.data[key]=KeyedRef(value,self._remove,key)\n  \n def copy(self):\n  if self._pending_removals:\n   self._commit_removals()\n  new=WeakValueDictionary()\n  with _IterationGuard(self):\n   for key,wr in self.data.items():\n    o=wr()\n    if o is not None :\n     new[key]=o\n  return new\n  \n __copy__=copy\n \n def __deepcopy__(self,memo):\n  from copy import deepcopy\n  if self._pending_removals:\n   self._commit_removals()\n  new=self.__class__()\n  with _IterationGuard(self):\n   for key,wr in self.data.items():\n    o=wr()\n    if o is not None :\n     new[deepcopy(key,memo)]=o\n  return new\n  \n def get(self,key,default=None ):\n  if self._pending_removals:\n   self._commit_removals()\n  try :\n   wr=self.data[key]\n  except KeyError:\n   return default\n  else :\n   o=wr()\n   if o is None :\n   \n    return default\n   else :\n    return o\n    \n def items(self):\n  if self._pending_removals:\n   self._commit_removals()\n  with _IterationGuard(self):\n   for k,wr in self.data.items():\n    v=wr()\n    if v is not None :\n     yield k,v\n     \n def keys(self):\n  if self._pending_removals:\n   self._commit_removals()\n  with _IterationGuard(self):\n   for k,wr in self.data.items():\n    if wr()is not None :\n     yield k\n     \n __iter__=keys\n \n def itervaluerefs(self):\n  ''\n\n\n\n\n\n\n\n  \n  if self._pending_removals:\n   self._commit_removals()\n  with _IterationGuard(self):\n   yield from self.data.values()\n   \n def values(self):\n  if self._pending_removals:\n   self._commit_removals()\n  with _IterationGuard(self):\n   for wr in self.data.values():\n    obj=wr()\n    if obj is not None :\n     yield obj\n     \n def popitem(self):\n  if self._pending_removals:\n   self._commit_removals()\n  while True :\n   key,wr=self.data.popitem()\n   o=wr()\n   if o is not None :\n    return key,o\n    \n def pop(self,key,*args):\n  if self._pending_removals:\n   self._commit_removals()\n  try :\n   o=self.data.pop(key)()\n  except KeyError:\n   o=None\n  if o is None :\n   if args:\n    return args[0]\n   else :\n    raise KeyError(key)\n  else :\n   return o\n   \n def setdefault(self,key,default=None ):\n  try :\n   o=self.data[key]()\n  except KeyError:\n   o=None\n  if o is None :\n   if self._pending_removals:\n    self._commit_removals()\n   self.data[key]=KeyedRef(default,self._remove,key)\n   return default\n  else :\n   return o\n   \n def update(self,other=None ,/,**kwargs):\n  if self._pending_removals:\n   self._commit_removals()\n  d=self.data\n  if other is not None :\n   if not hasattr(other,\"items\"):\n    other=dict(other)\n   for key,o in other.items():\n    d[key]=KeyedRef(o,self._remove,key)\n  for key,o in kwargs.items():\n   d[key]=KeyedRef(o,self._remove,key)\n   \n def valuerefs(self):\n  ''\n\n\n\n\n\n\n\n  \n  if self._pending_removals:\n   self._commit_removals()\n  return list(self.data.values())\n  \n def __ior__(self,other):\n  self.update(other)\n  return self\n  \n def __or__(self,other):\n  if isinstance(other,_collections_abc.Mapping):\n   c=self.copy()\n   c.update(other)\n   return c\n  return NotImplemented\n  \n def __ror__(self,other):\n  if isinstance(other,_collections_abc.Mapping):\n   c=self.__class__()\n   c.update(other)\n   c.update(self)\n   return c\n  return NotImplemented\n  \n  \nclass KeyedRef(ref):\n ''\n\n\n\n\n\n\n \n \n __slots__=\"key\",\n \n def __new__(type,ob,callback,key):\n  self=ref.__new__(type,ob,callback)\n  self.key=key\n  return self\n  \n def __init__(self,ob,callback,key):\n  super().__init__(ob,callback)\n  \n  \nclass WeakKeyDictionary(_collections_abc.MutableMapping):\n ''\n\n\n\n\n\n\n\n \n \n def __init__(self,dict=None ):\n  self.data={}\n  def remove(k,selfref=ref(self)):\n   self=selfref()\n   if self is not None :\n    if self._iterating:\n     self._pending_removals.append(k)\n    else :\n     del self.data[k]\n  self._remove=remove\n  \n  self._pending_removals=[]\n  self._iterating=set()\n  self._dirty_len=False\n  if dict is not None :\n   self.update(dict)\n   \n def _commit_removals(self):\n \n \n \n \n  l=self._pending_removals\n  d=self.data\n  while l:\n   try :\n    del d[l.pop()]\n   except KeyError:\n    pass\n    \n def _scrub_removals(self):\n  d=self.data\n  self._pending_removals=[k for k in self._pending_removals if k in d]\n  self._dirty_len=False\n  \n def __delitem__(self,key):\n  self._dirty_len=True\n  del self.data[ref(key)]\n  \n def __getitem__(self,key):\n  return self.data[ref(key)]\n  \n def __len__(self):\n  if self._dirty_len and self._pending_removals:\n  \n  \n   self._scrub_removals()\n  return len(self.data)-len(self._pending_removals)\n  \n def __repr__(self):\n  return \"<%s at %#x>\"%(self.__class__.__name__,id(self))\n  \n def __setitem__(self,key,value):\n  self.data[ref(key,self._remove)]=value\n  \n def copy(self):\n  new=WeakKeyDictionary()\n  with _IterationGuard(self):\n   for key,value in self.data.items():\n    o=key()\n    if o is not None :\n     new[o]=value\n  return new\n  \n __copy__=copy\n \n def __deepcopy__(self,memo):\n  from copy import deepcopy\n  new=self.__class__()\n  with _IterationGuard(self):\n   for key,value in self.data.items():\n    o=key()\n    if o is not None :\n     new[o]=deepcopy(value,memo)\n  return new\n  \n def get(self,key,default=None ):\n  return self.data.get(ref(key),default)\n  \n def __contains__(self,key):\n  try :\n   wr=ref(key)\n  except TypeError:\n   return False\n  return wr in self.data\n  \n def items(self):\n  with _IterationGuard(self):\n   for wr,value in self.data.items():\n    key=wr()\n    if key is not None :\n     yield key,value\n     \n def keys(self):\n  with _IterationGuard(self):\n   for wr in self.data:\n    obj=wr()\n    if obj is not None :\n     yield obj\n     \n __iter__=keys\n \n def values(self):\n  with _IterationGuard(self):\n   for wr,value in self.data.items():\n    if wr()is not None :\n     yield value\n     \n def keyrefs(self):\n  ''\n\n\n\n\n\n\n\n  \n  return list(self.data)\n  \n def popitem(self):\n  self._dirty_len=True\n  while True :\n   key,value=self.data.popitem()\n   o=key()\n   if o is not None :\n    return o,value\n    \n def pop(self,key,*args):\n  self._dirty_len=True\n  return self.data.pop(ref(key),*args)\n  \n def setdefault(self,key,default=None ):\n  return self.data.setdefault(ref(key,self._remove),default)\n  \n def update(self,dict=None ,/,**kwargs):\n  d=self.data\n  if dict is not None :\n   if not hasattr(dict,\"items\"):\n    dict=type({})(dict)\n   for key,value in dict.items():\n    d[ref(key,self._remove)]=value\n  if len(kwargs):\n   self.update(kwargs)\n   \n def __ior__(self,other):\n  self.update(other)\n  return self\n  \n def __or__(self,other):\n  if isinstance(other,_collections_abc.Mapping):\n   c=self.copy()\n   c.update(other)\n   return c\n  return NotImplemented\n  \n def __ror__(self,other):\n  if isinstance(other,_collections_abc.Mapping):\n   c=self.__class__()\n   c.update(other)\n   c.update(self)\n   return c\n  return NotImplemented\n  \n  \nclass finalize:\n ''\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n __slots__=()\n _registry={}\n _shutdown=False\n _index_iter=itertools.count()\n _dirty=False\n _registered_with_atexit=False\n \n class _Info:\n  __slots__=(\"weakref\",\"func\",\"args\",\"kwargs\",\"atexit\",\"index\")\n  \n def __init__(self,obj,func,/,*args,**kwargs):\n  if not self._registered_with_atexit:\n  \n  \n   import atexit\n   atexit.register(self._exitfunc)\n   finalize._registered_with_atexit=True\n  info=self._Info()\n  info.weakref=ref(obj,self)\n  info.func=func\n  info.args=args\n  info.kwargs=kwargs or None\n  info.atexit=True\n  info.index=next(self._index_iter)\n  self._registry[self]=info\n  finalize._dirty=True\n  \n def __call__(self,_=None ):\n  ''\n  \n  info=self._registry.pop(self,None )\n  if info and not self._shutdown:\n   return info.func(*info.args,**(info.kwargs or {}))\n   \n def detach(self):\n  ''\n  \n  info=self._registry.get(self)\n  obj=info and info.weakref()\n  if obj is not None and self._registry.pop(self,None ):\n   return (obj,info.func,info.args,info.kwargs or {})\n   \n def peek(self):\n  ''\n  \n  info=self._registry.get(self)\n  obj=info and info.weakref()\n  if obj is not None :\n   return (obj,info.func,info.args,info.kwargs or {})\n   \n @property\n def alive(self):\n  ''\n  return self in self._registry\n  \n @property\n def atexit(self):\n  ''\n  info=self._registry.get(self)\n  return bool(info)and info.atexit\n  \n @atexit.setter\n def atexit(self,value):\n  info=self._registry.get(self)\n  if info:\n   info.atexit=bool(value)\n   \n def __repr__(self):\n  info=self._registry.get(self)\n  obj=info and info.weakref()\n  if obj is None :\n   return '<%s object at %#x; dead>'%(type(self).__name__,id(self))\n  else :\n   return '<%s object at %#x; for %r at %#x>'%\\\n   (type(self).__name__,id(self),type(obj).__name__,id(obj))\n   \n @classmethod\n def _select_for_exit(cls):\n \n  L=[(f,i)for (f,i)in cls._registry.items()if i.atexit]\n  L.sort(key=lambda item:item[1].index)\n  return [f for (f,i)in L]\n  \n @classmethod\n def _exitfunc(cls):\n \n \n \n  reenable_gc=False\n  try :\n   if cls._registry:\n    import gc\n    if gc.isenabled():\n     reenable_gc=True\n     gc.disable()\n    pending=None\n    while True :\n     if pending is None or finalize._dirty:\n      pending=cls._select_for_exit()\n      finalize._dirty=False\n     if not pending:\n      break\n     f=pending.pop()\n     try :\n     \n     \n     \n     \n      f()\n     except Exception:\n      sys.excepthook(*sys.exc_info())\n     assert f not in cls._registry\n  finally :\n  \n   finalize._shutdown=True\n   if reenable_gc:\n    gc.enable()\n", ["_collections_abc", "_weakref", "_weakrefset", "atexit", "copy", "gc", "itertools", "sys"]],
@@ -186,29 +186,30 @@
     "_threading_local": [".py", "''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfrom weakref import ref\nfrom contextlib import contextmanager\n\n__all__=[\"local\"]\n\n\n\n\n\n\n\n\n\n\n\nclass _localimpl:\n ''\n __slots__='key','dicts','localargs','locallock','__weakref__'\n \n def __init__(self):\n \n \n \n  self.key='_threading_local._localimpl.'+str(id(self))\n  \n  self.dicts={}\n  \n def get_dict(self):\n  ''\n  \n  thread=current_thread()\n  return self.dicts[id(thread)][1]\n  \n def create_dict(self):\n  ''\n  localdict={}\n  key=self.key\n  thread=current_thread()\n  idt=id(thread)\n  def local_deleted(_,key=key):\n  \n   thread=wrthread()\n   if thread is not None :\n    del thread.__dict__[key]\n  def thread_deleted(_,idt=idt):\n  \n  \n  \n  \n   local=wrlocal()\n   if local is not None :\n    dct=local.dicts.pop(idt)\n  wrlocal=ref(self,local_deleted)\n  wrthread=ref(thread,thread_deleted)\n  thread.__dict__[key]=wrlocal\n  self.dicts[idt]=wrthread,localdict\n  return localdict\n  \n  \n@contextmanager\ndef _patch(self):\n impl=object.__getattribute__(self,'_local__impl')\n try :\n  dct=impl.get_dict()\n except KeyError:\n  dct=impl.create_dict()\n  args,kw=impl.localargs\n  self.__init__(*args,**kw)\n with impl.locallock:\n  object.__setattr__(self,'__dict__',dct)\n  yield\n  \n  \nclass local:\n __slots__='_local__impl','__dict__'\n \n def __new__(cls,/,*args,**kw):\n  if (args or kw)and (cls.__init__ is object.__init__):\n   raise TypeError(\"Initialization arguments are not supported\")\n  self=object.__new__(cls)\n  impl=_localimpl()\n  impl.localargs=(args,kw)\n  impl.locallock=RLock()\n  object.__setattr__(self,'_local__impl',impl)\n  \n  \n  \n  impl.create_dict()\n  return self\n  \n def __getattribute__(self,name):\n  with _patch(self):\n   return object.__getattribute__(self,name)\n   \n def __setattr__(self,name,value):\n  if name =='__dict__':\n   raise AttributeError(\n   \"%r object attribute '__dict__' is read-only\"\n   %self.__class__.__name__)\n  with _patch(self):\n   return object.__setattr__(self,name,value)\n   \n def __delattr__(self,name):\n  if name =='__dict__':\n   raise AttributeError(\n   \"%r object attribute '__dict__' is read-only\"\n   %self.__class__.__name__)\n  with _patch(self):\n   return object.__delattr__(self,name)\n   \n   \nfrom threading import current_thread,RLock\n", ["contextlib", "threading", "weakref"]],
     "_weakref": [".py", "\n\nclass ProxyType:\n\n def __init__(self,obj):\n  object.__setattr__(self,\"obj\",obj)\n  \n def __setattr__(self,attr,value):\n  setattr(object.__getattribute__(self,\"obj\"),attr,value)\n  \n def __getattr__(self,attr):\n  return getattr(object.__getattribute__(self,\"obj\"),attr)\n  \nCallableProxyType=ProxyType\nProxyTypes=[ProxyType,CallableProxyType]\n\nclass ReferenceType:\n\n def __init__(self,obj,callback):\n  self.obj=obj\n  self.callback=callback\n  \nclass ref:\n\n def __init__(self,obj,callback=None ):\n  self.obj=ReferenceType(obj,callback)\n  self.callback=callback\n  \n def __call__(self):\n  return self.obj.obj\n  \n def __hash__(self):\n  return hash(self.obj.obj)\n  \n def __eq__(self,other):\n  return self.obj.obj ==other.obj.obj\n  \ndef getweakrefcount(obj):\n return 1\n \ndef getweakrefs(obj):\n return obj\n \ndef _remove_dead_weakref(*args):\n pass\n \ndef proxy(obj,callback=None ):\n return ProxyType(obj)\n \n", []],
     "_weakrefset": [".py", "\n\n\n\nfrom _weakref import ref\nfrom types import GenericAlias\n\n__all__=['WeakSet']\n\n\nclass _IterationGuard:\n\n\n\n\n\n def __init__(self,weakcontainer):\n \n  self.weakcontainer=ref(weakcontainer)\n  \n def __enter__(self):\n  w=self.weakcontainer()\n  if w is not None :\n   w._iterating.add(self)\n  return self\n  \n def __exit__(self,e,t,b):\n  w=self.weakcontainer()\n  if w is not None :\n   s=w._iterating\n   s.remove(self)\n   if not s:\n    w._commit_removals()\n    \n    \nclass WeakSet:\n def __init__(self,data=None ):\n  self.data=set()\n  def _remove(item,selfref=ref(self)):\n   self=selfref()\n   if self is not None :\n    if self._iterating:\n     self._pending_removals.append(item)\n    else :\n     self.data.discard(item)\n  self._remove=_remove\n  \n  self._pending_removals=[]\n  self._iterating=set()\n  if data is not None :\n   self.update(data)\n   \n def _commit_removals(self):\n  l=self._pending_removals\n  discard=self.data.discard\n  while l:\n   discard(l.pop())\n   \n def __iter__(self):\n  with _IterationGuard(self):\n   for itemref in self.data:\n    item=itemref()\n    if item is not None :\n    \n    \n     yield item\n     \n def __len__(self):\n  return len(self.data)-len(self._pending_removals)\n  \n def __contains__(self,item):\n  try :\n   wr=ref(item)\n  except TypeError:\n   return False\n  return wr in self.data\n  \n def __reduce__(self):\n  return (self.__class__,(list(self),),\n  getattr(self,'__dict__',None ))\n  \n def add(self,item):\n  if self._pending_removals:\n   self._commit_removals()\n  self.data.add(ref(item,self._remove))\n  \n def clear(self):\n  if self._pending_removals:\n   self._commit_removals()\n  self.data.clear()\n  \n def copy(self):\n  return self.__class__(self)\n  \n def pop(self):\n  if self._pending_removals:\n   self._commit_removals()\n  while True :\n   try :\n    itemref=self.data.pop()\n   except KeyError:\n    raise KeyError('pop from empty WeakSet')from None\n   item=itemref()\n   if item is not None :\n    return item\n    \n def remove(self,item):\n  if self._pending_removals:\n   self._commit_removals()\n  self.data.remove(ref(item))\n  \n def discard(self,item):\n  if self._pending_removals:\n   self._commit_removals()\n  self.data.discard(ref(item))\n  \n def update(self,other):\n  if self._pending_removals:\n   self._commit_removals()\n  for element in other:\n   self.add(element)\n   \n def __ior__(self,other):\n  self.update(other)\n  return self\n  \n def difference(self,other):\n  newset=self.copy()\n  newset.difference_update(other)\n  return newset\n __sub__=difference\n \n def difference_update(self,other):\n  self.__isub__(other)\n def __isub__(self,other):\n  if self._pending_removals:\n   self._commit_removals()\n  if self is other:\n   self.data.clear()\n  else :\n   self.data.difference_update(ref(item)for item in other)\n  return self\n  \n def intersection(self,other):\n  return self.__class__(item for item in other if item in self)\n __and__=intersection\n \n def intersection_update(self,other):\n  self.__iand__(other)\n def __iand__(self,other):\n  if self._pending_removals:\n   self._commit_removals()\n  self.data.intersection_update(ref(item)for item in other)\n  return self\n  \n def issubset(self,other):\n  return self.data.issubset(ref(item)for item in other)\n __le__=issubset\n \n def __lt__(self,other):\n  return self.data <set(map(ref,other))\n  \n def issuperset(self,other):\n  return self.data.issuperset(ref(item)for item in other)\n __ge__=issuperset\n \n def __gt__(self,other):\n  return self.data >set(map(ref,other))\n  \n def __eq__(self,other):\n  if not isinstance(other,self.__class__):\n   return NotImplemented\n  return self.data ==set(map(ref,other))\n  \n def symmetric_difference(self,other):\n  newset=self.copy()\n  newset.symmetric_difference_update(other)\n  return newset\n __xor__=symmetric_difference\n \n def symmetric_difference_update(self,other):\n  self.__ixor__(other)\n def __ixor__(self,other):\n  if self._pending_removals:\n   self._commit_removals()\n  if self is other:\n   self.data.clear()\n  else :\n   self.data.symmetric_difference_update(ref(item,self._remove)for item in other)\n  return self\n  \n def union(self,other):\n  return self.__class__(e for s in (self,other)for e in s)\n __or__=union\n \n def isdisjoint(self,other):\n  return len(self.intersection(other))==0\n  \n def __repr__(self):\n  return repr(self.data)\n  \n __class_getitem__=classmethod(GenericAlias)\n", ["_weakref", "types"]],
     "__future__": [".py", "''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nall_feature_names=[\n\"nested_scopes\",\n\"generators\",\n\"division\",\n\"absolute_import\",\n\"with_statement\",\n\"print_function\",\n\"unicode_literals\",\n\"barry_as_FLUFL\",\n\"generator_stop\",\n\"annotations\",\n]\n\n__all__=[\"all_feature_names\"]+all_feature_names\n\n\n\n\n\nCO_NESTED=0x0010\nCO_GENERATOR_ALLOWED=0\nCO_FUTURE_DIVISION=0x20000\nCO_FUTURE_ABSOLUTE_IMPORT=0x40000\nCO_FUTURE_WITH_STATEMENT=0x80000\nCO_FUTURE_PRINT_FUNCTION=0x100000\nCO_FUTURE_UNICODE_LITERALS=0x200000\nCO_FUTURE_BARRY_AS_BDFL=0x400000\nCO_FUTURE_GENERATOR_STOP=0x800000\nCO_FUTURE_ANNOTATIONS=0x1000000\n\n\nclass _Feature:\n\n def __init__(self,optionalRelease,mandatoryRelease,compiler_flag):\n  self.optional=optionalRelease\n  self.mandatory=mandatoryRelease\n  self.compiler_flag=compiler_flag\n  \n def getOptionalRelease(self):\n  ''\n\n\n  \n  return self.optional\n  \n def getMandatoryRelease(self):\n  ''\n\n\n\n  \n  return self.mandatory\n  \n def __repr__(self):\n  return \"_Feature\"+repr((self.optional,\n  self.mandatory,\n  self.compiler_flag))\n  \n  \nnested_scopes=_Feature((2,1,0,\"beta\",1),\n(2,2,0,\"alpha\",0),\nCO_NESTED)\n\ngenerators=_Feature((2,2,0,\"alpha\",1),\n(2,3,0,\"final\",0),\nCO_GENERATOR_ALLOWED)\n\ndivision=_Feature((2,2,0,\"alpha\",2),\n(3,0,0,\"alpha\",0),\nCO_FUTURE_DIVISION)\n\nabsolute_import=_Feature((2,5,0,\"alpha\",1),\n(3,0,0,\"alpha\",0),\nCO_FUTURE_ABSOLUTE_IMPORT)\n\nwith_statement=_Feature((2,5,0,\"alpha\",1),\n(2,6,0,\"alpha\",0),\nCO_FUTURE_WITH_STATEMENT)\n\nprint_function=_Feature((2,6,0,\"alpha\",2),\n(3,0,0,\"alpha\",0),\nCO_FUTURE_PRINT_FUNCTION)\n\nunicode_literals=_Feature((2,6,0,\"alpha\",2),\n(3,0,0,\"alpha\",0),\nCO_FUTURE_UNICODE_LITERALS)\n\nbarry_as_FLUFL=_Feature((3,1,0,\"alpha\",2),\n(4,0,0,\"alpha\",0),\nCO_FUTURE_BARRY_AS_BDFL)\n\ngenerator_stop=_Feature((3,5,0,\"beta\",1),\n(3,7,0,\"alpha\",0),\nCO_FUTURE_GENERATOR_STOP)\n\nannotations=_Feature((3,7,0,\"beta\",1),\n(3,10,0,\"alpha\",0),\nCO_FUTURE_ANNOTATIONS)\n", []],
     "browser": [".py", "", [], 1],
     "browser.aio": [".py", "from _aio import *\nfrom browser import window\n\n\ndef _task(coro,Id,block):\n async def _task():\n  block[Id]=None\n  try :\n   block[Id]=await coro\n  except Exception as e:\n   block[Id]=e\n   \n  if not block[Id]:\n   del block[Id]\n return _task()\n \n \nasync def gather(*coros,rate=0):\n dones={}\n counts=0\n for c in coros:\n  run(_task(c,f'task{counts}',dones))\n  counts +=1\n while not all(dones.values()):\n  await sleep(rate)\n return dones\n \n \nclass Future:\n ''\n\n\n \n \n def __new__(cls,*args,**kwargs):\n  methods={}\n  def executor(resolve_cb,reject_cb):\n   methods[\"resolve\"]=resolve_cb\n   methods[\"reject\"]=reject_cb\n  promise=window.Promise.new(executor)\n  promise._methods=methods\n  promise.set_result=cls.set_result.__get__(promise)\n  promise.set_exception=cls.set_exception.__get__(promise)\n  return promise\n  \n def set_result(self,value):\n  self._methods[\"resolve\"](value)\n  \n def set_exception(self,exc):\n  self._methods[\"reject\"](exc)\n", ["_aio", "browser"]],
     "browser.ajax": [".py", "from _ajax import *\n", ["_ajax"]],
-    "browser.highlight": [".py", "import _jsre as re\n\nfrom browser import html\n\nletters='abcdefghijklmnopqrstuvwxyz'\nletters +=letters.upper()+'_'\ndigits='0123456789'\n\nbuiltin_funcs=\"\"\"abs|dict|help|min|setattr|\nall|dir|hex|next|slice|\nany|divmod|id|object|sorted|\nascii|enumerate|input|oct|staticmethod|\nbin|eval|int|open|str|\nbool|exec|isinstance|ord|sum|\nbytearray|filter|issubclass|pow|super|\nbytes|float|iter|print|tuple|\ncallable|format|len|property|type|\nchr|frozenset|list|range|vars|\nclassmethod|getattr|locals|repr|zip|\ncompile|globals|map|reversed|__import__|\ncomplex|hasattr|max|round|\ndelattr|hash|memoryview|set|\n\"\"\"\n\nkeywords=[\n'False',\n'None',\n'True',\n'and',\n'as',\n'assert',\n'async',\n'await',\n'break',\n'class',\n'continue',\n'def',\n'del',\n'elif',\n'else',\n'except',\n'finally',\n'for',\n'from',\n'global',\n'if',\n'import',\n'in',\n'is',\n'lambda',\n'nonlocal',\n'not',\n'or',\n'pass',\n'raise',\n'return',\n'try',\n'while',\n'with',\n'yield',\n]\nkw_pattern='^('+'|'.join(keywords)+')$'\nbf_pattern='^('+builtin_funcs.replace(\"\\n\",\"\")+')$'\n\ndef escape(txt):\n txt=txt.replace('<','&lt;')\n txt=txt.replace('>','&gt;')\n return txt\n \ndef highlight(txt):\n res=html.PRE()\n i=0\n name=''\n while i <len(txt):\n  car=txt[i]\n  if car in [\"'\",'\"']:\n   mul_car=txt[i:i+3]\n   if mul_car in [\"'''\",'\"\"\"']:\n    car=mul_car\n   found_match=False\n   k=i+len(car)\n   while k <len(txt):\n    k=txt.find(car,k)\n    if k !=-1:\n     nb_as,j=0,k -1\n     while txt[j]=='\\\\':\n      nb_as +=1\n      j -=1\n     if nb_as %2 ==0:\n      res <=name+html.SPAN(escape(txt[i:k+len(car)]),\n      Class=\"python-string\")\n      i=k+len(car)-1\n      name=''\n      found_match=True\n      break\n    else :\n     break\n    k +=len(car)\n   if not found_match:\n    name +=car\n  elif car =='#':\n   end=txt.find('\\n',i)\n   if end ==-1:\n    res <=html.SPAN(escape(txt[i:]),Class=\"python-comment\")\n    break\n   else :\n    res <=html.SPAN(escape(txt[i:end]),Class=\"python-comment\")\n    i=end -1\n  elif car in letters:\n   name +=car\n  elif car in digits and name:\n   name +=car\n  else :\n   if name:\n    if re.search(kw_pattern,name):\n     res <=html.SPAN(name,Class=\"python-keyword\")\n    elif re.search(bf_pattern,name):\n     res <=html.SPAN(name,Class=\"python-builtin\")\n    else :\n     res <=name\n    name=''\n   res <=car\n  i +=1\n res <=name\n return res\n", ["_jsre", "browser", "browser.html"]],
+    "browser.highlight": [".py", "import re\n\nfrom browser import html\n\nletters='abcdefghijklmnopqrstuvwxyz'\nletters +=letters.upper()+'_'\ndigits='0123456789'\n\nbuiltin_funcs=\"\"\"abs|dict|help|min|setattr|\nall|dir|hex|next|slice|\nany|divmod|id|object|sorted|\nascii|enumerate|input|oct|staticmethod|\nbin|eval|int|open|str|\nbool|exec|isinstance|ord|sum|\nbytearray|filter|issubclass|pow|super|\nbytes|float|iter|print|tuple|\ncallable|format|len|property|type|\nchr|frozenset|list|range|vars|\nclassmethod|getattr|locals|repr|zip|\ncompile|globals|map|reversed|__import__|\ncomplex|hasattr|max|round|\ndelattr|hash|memoryview|set|\n\"\"\"\n\nkeywords=[\n'False',\n'None',\n'True',\n'and',\n'as',\n'assert',\n'async',\n'await',\n'break',\n'class',\n'continue',\n'def',\n'del',\n'elif',\n'else',\n'except',\n'finally',\n'for',\n'from',\n'global',\n'if',\n'import',\n'in',\n'is',\n'lambda',\n'nonlocal',\n'not',\n'or',\n'pass',\n'raise',\n'return',\n'try',\n'while',\n'with',\n'yield',\n]\nkw_pattern='^('+'|'.join(keywords)+')$'\nbf_pattern='^('+builtin_funcs.replace(\"\\n\",\"\")+')$'\n\ndef escape(txt):\n txt=txt.replace('<','&lt;')\n txt=txt.replace('>','&gt;')\n return txt\n \ndef highlight(txt):\n res=html.PRE()\n i=0\n name=''\n while i <len(txt):\n  car=txt[i]\n  if car in [\"'\",'\"']:\n   mul_car=txt[i:i+3]\n   if mul_car in [\"'''\",'\"\"\"']:\n    car=mul_car\n   found_match=False\n   k=i+len(car)\n   while k <len(txt):\n    k=txt.find(car,k)\n    if k !=-1:\n     nb_as,j=0,k -1\n     while txt[j]=='\\\\':\n      nb_as +=1\n      j -=1\n     if nb_as %2 ==0:\n      res <=name+html.SPAN(escape(txt[i:k+len(car)]),\n      Class=\"python-string\")\n      i=k+len(car)-1\n      name=''\n      found_match=True\n      break\n    else :\n     break\n    k +=len(car)\n   if not found_match:\n    name +=car\n  elif car =='#':\n   end=txt.find('\\n',i)\n   if end ==-1:\n    res <=html.SPAN(escape(txt[i:]),Class=\"python-comment\")\n    break\n   else :\n    res <=html.SPAN(escape(txt[i:end]),Class=\"python-comment\")\n    i=end -1\n  elif car in letters:\n   name +=car\n  elif car in digits and name:\n   name +=car\n  else :\n   if name:\n    if re.search(kw_pattern,name):\n     res <=html.SPAN(name,Class=\"python-keyword\")\n    elif re.search(bf_pattern,name):\n     res <=html.SPAN(name,Class=\"python-builtin\")\n    else :\n     res <=name\n    name=''\n   res <=car\n  i +=1\n res <=name\n return res\n", ["browser", "browser.html", "re"]],
     "browser.html": [".py", "from _html import *\n", ["_html"]],
+    "browser.idbcache": [".py", "\n\nfrom datetime import datetime\n\nfrom browser.widgets import dialog\n\nfrom browser import bind,window,document\nfrom browser.html import *\n\nidb_name=\"brython-cache\"\nidb_cx=window.indexedDB.open(idb_name)\n\ninfos={\"nb_modules\":0,\"size\":0}\n\n@bind(idb_cx,\"success\")\ndef open_success(evt):\n db=evt.target.result\n if not db.objectStoreNames.contains(\"modules\"):\n  dialog.InfoDialog('indexedDB cache','db has no store \"modules\"')\n  return\n  \n table=TABLE(border=1)\n table <=TR(TH(col)for col in\n ['Name','Package','Size','Brython timestamp',\n 'Stdlib timestamp'])\n tx=db.transaction(\"modules\",\"readwrite\")\n store=tx.objectStore(\"modules\")\n outdated=[]\n \n openCursor=store.openCursor()\n \n @bind(openCursor,\"error\")\n def cursor_error(evt):\n  print(\"open cursor error\",evt)\n  \n @bind(openCursor,\"success\")\n def cursor_success(evt):\n  infos['nb_modules']+=1\n  cursor=evt.target.result\n  if cursor:\n   record=cursor.value\n   timestamp=datetime.fromtimestamp(record.timestamp /1000)\n   source_ts=datetime.fromtimestamp(record.source_ts /1000)\n   table <=TR(TD(record.name)+\n   TD(bool(record.is_package))+\n   TD(len(record.content),align=\"right\")+\n   TD(timestamp.strftime('%Y-%m-%d %H:%M'))+\n   TD(source_ts.strftime('%Y-%m-%d %H:%M'))\n   )\n   infos['size']+=len(record.content)\n   getattr(cursor,\"continue\")()\n  else :\n   panel=dialog.Dialog('indexedDB cache',top=0,left=0).panel\n   panel <=H1(\"Brython indexedDB cache\")\n   size='{:,d}'.format(infos['size'])\n   panel <=H3(f\"{infos['nb_modules']} modules, size {size} bytes\")\n   panel <=table\n", ["browser", "browser.html", "browser.widgets", "browser.widgets.dialog", "datetime"]],
     "browser.indexed_db": [".py", "class EventListener:\n def __init__(self,events=[]):\n  self._events=events\n  \n def append(self,event):\n  self._events.append(event)\n  \n def fire(self,e):\n  for _event in self._events:\n   _event(e)\n   \nclass IndexedDB:\n def __init__(self):\n  if not __BRYTHON__.has_indexedDB:\n   raise NotImplementedError(\"Your browser doesn't support indexedDB\")\n   return\n   \n  self._indexedDB=__BRYTHON__.indexedDB()\n  self._db=None\n  self._version=None\n  \n def _onsuccess(self,event):\n  self._db=event.target.result\n  \n def open(self,name,onsuccess,version=1.0,onerror=None ,\n onupgradeneeded=None ):\n  self._version=version\n  _result=self._indexedDB.open(name,version)\n  _success=EventListener([self._onsuccess,onsuccess])\n  _result.onsuccess=_success.fire\n  _result.onupgradeneeded=onupgradeneeded\n  \n  \n  def onerror(e):\n   print(\"onerror: %s:%s\"%(e.type,e.target.result))\n   \n  def onblocked(e):\n   print(\"blocked: %s:%s\"%(e.type,e.result))\n   \n  _result.onerror=onerror\n  _result.onblocked=onblocked\n  \n def transaction(self,entities,mode='read'):\n  return Transaction(self._db.transaction(entities,mode))\n  \nclass Transaction:\n\n def __init__(self,transaction):\n  self._transaction=transaction\n  \n def objectStore(self,name):\n  return ObjectStore(self._transaction.objectStore(name))\n  \nclass ObjectStore:\n\n def __init__(self,objectStore):\n  self._objectStore=objectStore\n  self._data=[]\n  \n def clear(self,onsuccess=None ,onerror=None ):\n  _result=self._objectStore.clear()\n  \n  if onsuccess is not None :\n   _result.onsuccess=onsuccess\n   \n  if onerror is not None :\n   _result.onerror=onerror\n   \n def _helper(self,func,object,onsuccess=None ,onerror=None ):\n  _result=func(object)\n  \n  if onsuccess is not None :\n   _result.onsuccess=onsuccess\n   \n  if onerror is not None :\n   _result.onerror=onerror\n   \n def put(self,obj,key=None ,onsuccess=None ,onerror=None ):\n  _r=self._objectStore.put(obj,key)\n  _r.onsuccess=onsuccess\n  _r.onerror=onerror\n  \n def add(self,obj,key,onsuccess=None ,onerror=None ):\n  _r=self._objectStore.add(obj,key)\n  _r.onsuccess=onsuccess\n  _r.onerror=onerror\n  \n  \n def delete(self,index,onsuccess=None ,onerror=None ):\n  self._helper(self._objectStore.delete,index,onsuccess,onerror)\n  \n def query(self,*args):\n  self._data=[]\n  def onsuccess(event):\n   cursor=event.target.result\n   if cursor is not None :\n    self._data.append(cursor.value)\n    getattr(cursor,\"continue\")()\n    \n  self._objectStore.openCursor(args).onsuccess=onsuccess\n  \n def fetchall(self):\n  yield self._data\n  \n def get(self,key,onsuccess=None ,onerror=None ):\n  self._helper(self._objectStore.get,key,onsuccess,onerror)\n", []],
     "browser.local_storage": [".py", "\nimport sys\nfrom browser import window,console\n\nhas_local_storage=hasattr(window,'localStorage')\n\nclass _UnProvided():\n pass\n \nclass LocalStorage():\n storage_type=\"local_storage\"\n \n def __init__(self):\n  if not has_local_storage:\n   raise EnvironmentError(\"LocalStorage not available\")\n  self.store=window.localStorage\n  \n def __delitem__(self,key):\n  if (not isinstance(key,str)):\n   raise TypeError(\"key must be string\")\n  if key not in self:\n   raise KeyError(key)\n  self.store.removeItem(key)\n  \n def __getitem__(self,key):\n  if (not isinstance(key,str)):\n   raise TypeError(\"key must be string\")\n  res=self.store.getItem(key)\n  if res is not None :\n   return res\n  raise KeyError(key)\n  \n def __setitem__(self,key,value):\n  if not isinstance(key,str):\n   raise TypeError(\"key must be string\")\n  if not isinstance(value,str):\n   raise TypeError(\"value must be string\")\n  self.store.setItem(key,value)\n  \n  \n def __contains__(self,key):\n  if (not isinstance(key,str)):\n   raise TypeError(\"key must be string\")\n  res=self.store.getItem(key)\n  if res is None :\n   return False\n  return True\n  \n def __iter__(self):\n  keys=self.keys()\n  return keys.__iter__()\n  \n def get(self,key,default=None ):\n  if (not isinstance(key,str)):\n   raise TypeError(\"key must be string\")\n  return self.store.getItem(key)or default\n  \n def pop(self,key,default=_UnProvided()):\n  if (not isinstance(key,str)):\n   raise TypeError(\"key must be string\")\n  if type(default)is _UnProvided:\n   ret=self.get(key)\n   del self[key]\n   return ret\n  else :\n   if key in self:\n    ret=self.get(key)\n    del self[key]\n    return ret\n   else :\n    return default\n    \n    \n    \n def keys(self):\n  return [self.store.key(i)for i in range(self.store.length)]\n  \n def values(self):\n  return [self.__getitem__(k)for k in self.keys()]\n  \n def items(self):\n  return list(zip(self.keys(),self.values()))\n  \n def clear(self):\n  self.store.clear()\n  \n def __len__(self):\n  return self.store.length\n  \nif has_local_storage:\n storage=LocalStorage()\n", ["browser", "sys"]],
-    "browser.markdown": [".py", "\n\ntry :\n import _jsre as re\nexcept :\n import re\n \nimport random\n\nletters='abcdefghijklmnopqrstuvwxyz'\nletters +=letters.upper()+'0123456789'\n\nclass URL:\n\n def __init__(self,src):\n  elts=src.split(maxsplit=1)\n  self.href=elts[0]\n  self.alt=''\n  if len(elts)==2:\n   alt=elts[1]\n   if alt[0]=='\"'and alt[-1]=='\"':\n    self.alt=alt[1:-1]\n   elif alt[0]==\"'\"and alt[-1]==\"'\":\n    self.alt=alt[1:-1]\n   elif alt[0]==\"(\"and alt[-1]==\")\":\n    self.alt=alt[1:-1]\n    \n    \nclass CodeBlock:\n\n def __init__(self,line):\n  self.lines=[line]\n  if line.startswith(\"```\"):\n   if len(line)>3:\n    self.info=line[3:]\n   else :\n    self.info=\"block\"\n  elif line.startswith(\"`\")and len(line)>1:\n   self.info=line[1:]\n  elif line.startswith(\">>>\"):\n   self.info=\"python-console\"\n  else :\n   self.info=None\n   \n def to_html(self):\n  if self.lines[0].startswith(\"`\"):\n   self.lines.pop(0)\n  res=escape('\\n'.join(self.lines))\n  res=unmark(res)\n  _class=self.info or \"marked\"\n  res='<pre class=\"%s\">%s</pre>\\n'%(_class,res)\n  return res,[]\n  \n  \nclass Marked:\n\n def __init__(self,line=''):\n  self.line=line\n  self.children=[]\n  \n def to_html(self):\n  return apply_markdown(self.line)\n  \n  \nclass Script:\n\n def __init__(self,src):\n  self.src=src\n  \n def to_html(self):\n  return self.src,[]\n  \n  \n  \nrefs={}\nref_pattern=r\"^\\[(.*)\\]:\\s+(.*)\"\n\ndef mark(src):\n\n global refs\n refs={}\n \n \n \n \n \n \n \n \n src=src.replace('\\r\\n','\\n')\n \n \n src=re.sub(r'(.*?)\\n=+\\n','\\n# \\\\1\\n',src)\n src=re.sub(r'(.*?)\\n-+\\n','\\n## \\\\1\\n',src)\n \n lines=src.split('\\n')+['']\n \n i=bq=0\n ul=ol=0\n \n while i <len(lines):\n \n \n  if lines[i].startswith('>'):\n   nb=1\n   while nb <len(lines[i])and lines[i][nb]=='>':\n    nb +=1\n   lines[i]=lines[i][nb:]\n   if nb >bq:\n    lines.insert(i,'<blockquote>'*(nb -bq))\n    i +=1\n    bq=nb\n   elif nb <bq:\n    lines.insert(i,'</blockquote>'*(bq -nb))\n    i +=1\n    bq=nb\n  elif bq >0:\n   lines.insert(i,'</blockquote>'*bq)\n   i +=1\n   bq=0\n   \n   \n  if (lines[i].strip()and lines[i].lstrip()[0]in '-+*'\n  and len(lines[i].lstrip())>1\n  and lines[i].lstrip()[1]==' '\n  and (i ==0 or ul or not lines[i -1].strip())):\n  \n   nb=1+len(lines[i])-len(lines[i].lstrip())\n   lines[i]='<li>'+lines[i][nb:]\n   if nb >ul:\n    lines.insert(i,'<ul>'*(nb -ul))\n    i +=1\n   elif nb <ul:\n    lines.insert(i,'</ul>'*(ul -nb))\n    i +=1\n   ul=nb\n  elif ul and not lines[i].strip():\n   if (i <len(lines)-1 and lines[i+1].strip()\n   and not lines[i+1].startswith(' ')):\n    nline=lines[i+1].lstrip()\n    if nline[0]in '-+*'and len(nline)>1 and nline[1]==' ':\n     pass\n    else :\n     lines.insert(i,'</ul>'*ul)\n     i +=1\n     ul=0\n     \n     \n  mo=re.search(r'^(\\d+\\.)',lines[i])\n  if mo:\n   if not ol:\n    lines.insert(i,'<ol>')\n    i +=1\n   lines[i]='<li>'+lines[i][len(mo.groups()[0]):]\n   ol=1\n  elif (ol and not lines[i].strip()and i <len(lines)-1\n  and not lines[i+1].startswith(' ')\n  and not re.search(r'^(\\d+\\.)',lines[i+1])):\n   lines.insert(i,'</ol>')\n   i +=1\n   ol=0\n   \n  i +=1\n  \n if ul:\n  lines.append('</ul>'*ul)\n if ol:\n  lines.append('</ol>'*ol)\n if bq:\n  lines.append('</blockquote>'*bq)\n  \n sections=[]\n scripts=[]\n section=Marked()\n \n i=0\n while i <len(lines):\n  line=lines[i]\n  if line.strip()and line.startswith('    '):\n   if isinstance(section,Marked)and section.line:\n    sections.append(section)\n   section=CodeBlock(line[4:])\n   j=i+1\n   while j <len(lines)and lines[j].startswith('    '):\n    section.lines.append(lines[j][4:])\n    j +=1\n   sections.append(section)\n   section=Marked()\n   i=j\n   continue\n   \n  elif line.strip()and line.startswith(\"```\"):\n  \n   if isinstance(section,Marked)and section.line:\n    sections.append(section)\n   section=CodeBlock(line)\n   j=i+1\n   while j <len(lines)and not lines[j].startswith(\"```\"):\n    section.lines.append(lines[j])\n    j +=1\n   sections.append(section)\n   section=Marked()\n   i=j+1\n   continue\n   \n  elif line.lower().startswith('<script'):\n   if isinstance(section,Marked)and section.line:\n    sections.append(section)\n   j=i+1\n   while j <len(lines):\n    if lines[j].lower().startswith('</script>'):\n     sections.append(Script('\\n'.join(lines[i:j+1])))\n     for k in range(i,j+1):\n      lines[k]=''\n     section=Marked()\n     break\n    j +=1\n   i=j\n   continue\n   \n   \n  elif line.startswith('#'):\n   level=1\n   line=lines[i]\n   while level <len(line)and line[level]=='#'and level <=6:\n    level +=1\n   if not line[level+1:].strip():\n    if level ==1:\n     i +=1\n     continue\n    else :\n     lines[i]='<H%s>%s</H%s>\\n'%(level -1,'#',level -1)\n   else :\n    lines[i]='<H%s>%s</H%s>\\n'%(level,line[level+1:],level)\n    \n  else :\n   mo=re.search(ref_pattern,line)\n   if mo is not None :\n    if isinstance(section,Marked)and section.line:\n     sections.append(section)\n     section=Marked()\n    key=mo.groups()[0]\n    value=URL(mo.groups()[1])\n    refs[key.lower()]=value\n   else :\n    if not line.strip():\n     line='<p></p>'\n    if section.line:\n     section.line +='\\n'\n    section.line +=line\n    \n   i +=1\n   \n if isinstance(section,Marked)and section.line:\n  sections.append(section)\n  \n res=''\n for section in sections:\n  mk,_scripts=section.to_html()\n  res +=mk\n  scripts +=_scripts\n  \n return res,scripts\n \ndef escape(czone):\n czone=czone.replace('&','&amp;')\n czone=czone.replace('<','&lt;')\n czone=czone.replace('>','&gt;')\n czone=czone.replace('_','&#95;')\n czone=czone.replace('*','&#42;')\n return czone\n \ndef s_escape(mo):\n\n czone=mo.string[mo.start():mo.end()]\n return escape(czone)\n \ndef unmark(code_zone):\n\n code_zone=code_zone.replace('_','&#95;')\n return code_zone\n \ndef s_unmark(mo):\n\n code_zone=mo.string[mo.start():mo.end()]\n code_zone=code_zone.replace('_','&#95;')\n return code_zone\n \ndef apply_markdown(src):\n\n scripts=[]\n key=None\n \n i=0\n while i <len(src):\n  if src[i]=='[':\n   start_a=i+1\n   while True :\n    end_a=src.find(']',i)\n    if end_a ==-1:\n     break\n    if src[end_a -1]=='\\\\':\n     i=end_a+1\n    else :\n     break\n   if end_a >-1 and src[start_a:end_a].find('\\n')==-1:\n    link=src[start_a:end_a]\n    rest=src[end_a+1:].lstrip()\n    if rest and rest[0]=='(':\n     j=0\n     while True :\n      end_href=rest.find(')',j)\n      if end_href ==-1:\n       break\n      if rest[end_href -1]=='\\\\':\n       j=end_href+1\n      else :\n       break\n     if end_href >-1 and rest[:end_href].find('\\n')==-1:\n      tag=('<a href=\"'+rest[1:end_href]+'\">'+link\n      +'</a>')\n      src=src[:start_a -1]+tag+rest[end_href+1:]\n      i=start_a+len(tag)\n    elif rest and rest[0]=='[':\n     j=0\n     while True :\n      end_key=rest.find(']',j)\n      if end_key ==-1:\n       break\n      if rest[end_key -1]=='\\\\':\n       j=end_key+1\n      else :\n       break\n     if end_key >-1 and rest[:end_key].find('\\n')==-1:\n      if not key:\n       key=link\n      if key.lower()not in refs:\n       raise KeyError('unknown reference %s'%key)\n      url=refs[key.lower()]\n      tag='<a href=\"'+url+'\">'+link+'</a>'\n      src=src[:start_a -1]+tag+rest[end_key+1:]\n      i=start_a+len(tag)\n      \n  i +=1\n  \n  \n  \n  \n  \n  \n  \n  \n  \n rstr=' '+''.join(random.choice(letters)for i in range(16))+' '\n \n i=0\n state=None\n start=-1\n data=''\n tags=[]\n while i <len(src):\n  if src[i]=='<':\n   j=i+1\n   while j <len(src):\n    if src[j]=='\"'or src[j]==\"'\":\n     if state ==src[j]and src[j -1]!='\\\\':\n      state=None\n      j=start+len(data)+1\n      data=''\n     elif state is None :\n      state=src[j]\n      start=j\n     else :\n      data +=src[j]\n    elif src[j]=='>'and state is None :\n     tags.append(src[i:j+1])\n     src=src[:i]+rstr+src[j+1:]\n     i +=len(rstr)\n     break\n    elif state =='\"'or state ==\"'\":\n     data +=src[j]\n    elif src[j]=='\\n':\n    \n    \n     src=src[:i]+'&lt;'+src[i+1:]\n     j=i+4\n     break\n    j +=1\n  elif src[i]=='`'and i >0:\n   if src[i -1]!='\\\\':\n   \n    j=i+1\n    while j <len(src):\n     if src[j]=='`'and src[j -1]!='\\\\':\n      break\n     j +=1\n    i=j\n   else :\n   \n    src=src[:i -1]+\"&#96;\"+src[i+1:]\n  i +=1\n  \n  \n code_pattern=r'\\`(.*?)\\`'\n src=re.sub(code_pattern,s_escape,src)\n \n \n src=src.replace(r'\\\\`','&#96;')\n src=src.replace(r'\\_','&#95;')\n src=src.replace(r'\\*','&#42;')\n \n \n strong_patterns=[('STRONG',r'\\*\\*(.+?)\\*\\*'),('B',r'__(.+?)__')]\n for tag,strong_pattern in strong_patterns:\n  src=re.sub(strong_pattern,r'<%s>\\1</%s>'%(tag,tag),src)\n  \n  \n src=re.sub(r'\\*(.+?)\\*',r'<%s>\\1</%s>'%('EM','EM'),src)\n \n \n \n src=re.sub(r'\\b_(.*?)_\\b',r'<I>\\1</I>',src,\n flags=re.M)\n \n \n code_pattern=r'\\`(.*?)\\`'\n src=re.sub(code_pattern,r'<code>\\1</code>',src)\n \n \n while True :\n  pos=src.rfind(rstr)\n  if pos ==-1:\n   break\n  repl=tags.pop()\n  src=src[:pos]+repl+src[pos+len(rstr):]\n  \n src='<p>'+src+'</p>'\n \n return src,scripts\n", ["_jsre", "random", "re"]],
+    "browser.markdown": [".py", "\n\nimport re\n\nimport random\n\nletters='abcdefghijklmnopqrstuvwxyz'\nletters +=letters.upper()+'0123456789'\n\nclass URL:\n\n def __init__(self,src):\n  elts=src.split(maxsplit=1)\n  self.href=elts[0]\n  self.alt=''\n  if len(elts)==2:\n   alt=elts[1]\n   if alt[0]=='\"'and alt[-1]=='\"':\n    self.alt=alt[1:-1]\n   elif alt[0]==\"'\"and alt[-1]==\"'\":\n    self.alt=alt[1:-1]\n   elif alt[0]==\"(\"and alt[-1]==\")\":\n    self.alt=alt[1:-1]\n    \n    \nclass CodeBlock:\n\n def __init__(self,line):\n  self.lines=[line]\n  if line.startswith(\"```\"):\n   if len(line)>3:\n    self.info=line[3:]\n   else :\n    self.info=\"block\"\n  elif line.startswith(\"`\")and len(line)>1:\n   self.info=line[1:]\n  elif line.startswith(\">>>\"):\n   self.info=\"python-console\"\n  else :\n   self.info=None\n   \n def to_html(self):\n  if self.lines[0].startswith(\"`\"):\n   self.lines.pop(0)\n  res=escape('\\n'.join(self.lines))\n  res=unmark(res)\n  _class=self.info or \"marked\"\n  res='<pre class=\"%s\">%s</pre>\\n'%(_class,res)\n  return res,[]\n  \n  \nclass Marked:\n\n def __init__(self,line=''):\n  self.line=line\n  self.children=[]\n  \n def to_html(self):\n  return apply_markdown(self.line)\n  \n  \nclass Script:\n\n def __init__(self,src):\n  self.src=src\n  \n def to_html(self):\n  return self.src,[]\n  \n  \n  \nrefs={}\nref_pattern=r\"^\\[(.*)\\]:\\s+(.*)\"\n\ndef mark(src):\n\n global refs\n refs={}\n \n \n \n \n \n \n \n \n src=src.replace('\\r\\n','\\n')\n \n \n src=re.sub(r'(.*?)\\n=+\\n','\\n# \\\\1\\n',src)\n src=re.sub(r'(.*?)\\n-+\\n','\\n## \\\\1\\n',src)\n \n lines=src.split('\\n')+['']\n \n i=bq=0\n ul=ol=0\n \n while i <len(lines):\n \n \n  if lines[i].startswith('>'):\n   nb=1\n   while nb <len(lines[i])and lines[i][nb]=='>':\n    nb +=1\n   lines[i]=lines[i][nb:]\n   if nb >bq:\n    lines.insert(i,'<blockquote>'*(nb -bq))\n    i +=1\n    bq=nb\n   elif nb <bq:\n    lines.insert(i,'</blockquote>'*(bq -nb))\n    i +=1\n    bq=nb\n  elif bq >0:\n   lines.insert(i,'</blockquote>'*bq)\n   i +=1\n   bq=0\n   \n   \n  if (lines[i].strip()and lines[i].lstrip()[0]in '-+*'\n  and len(lines[i].lstrip())>1\n  and lines[i].lstrip()[1]==' '\n  and (i ==0 or ul or not lines[i -1].strip())):\n  \n   nb=1+len(lines[i])-len(lines[i].lstrip())\n   lines[i]='<li>'+lines[i][nb:]\n   if nb >ul:\n    lines.insert(i,'<ul>'*(nb -ul))\n    i +=1\n   elif nb <ul:\n    lines.insert(i,'</ul>'*(ul -nb))\n    i +=1\n   ul=nb\n  elif ul and not lines[i].strip():\n   if (i <len(lines)-1 and lines[i+1].strip()\n   and not lines[i+1].startswith(' ')):\n    nline=lines[i+1].lstrip()\n    if nline[0]in '-+*'and len(nline)>1 and nline[1]==' ':\n     pass\n    else :\n     lines.insert(i,'</ul>'*ul)\n     i +=1\n     ul=0\n     \n     \n  mo=re.search(r'^(\\d+\\.)',lines[i])\n  if mo:\n   if not ol:\n    lines.insert(i,'<ol>')\n    i +=1\n   lines[i]='<li>'+lines[i][len(mo.groups()[0]):]\n   ol=1\n  elif (ol and not lines[i].strip()and i <len(lines)-1\n  and not lines[i+1].startswith(' ')\n  and not re.search(r'^(\\d+\\.)',lines[i+1])):\n   lines.insert(i,'</ol>')\n   i +=1\n   ol=0\n   \n  i +=1\n  \n if ul:\n  lines.append('</ul>'*ul)\n if ol:\n  lines.append('</ol>'*ol)\n if bq:\n  lines.append('</blockquote>'*bq)\n  \n sections=[]\n scripts=[]\n section=Marked()\n \n i=0\n while i <len(lines):\n  line=lines[i]\n  if line.strip()and line.startswith('    '):\n   if isinstance(section,Marked)and section.line:\n    sections.append(section)\n   section=CodeBlock(line[4:])\n   j=i+1\n   while j <len(lines)and lines[j].startswith('    '):\n    section.lines.append(lines[j][4:])\n    j +=1\n   sections.append(section)\n   section=Marked()\n   i=j\n   continue\n   \n  elif line.strip()and line.startswith(\"```\"):\n  \n   if isinstance(section,Marked)and section.line:\n    sections.append(section)\n   section=CodeBlock(line)\n   j=i+1\n   while j <len(lines)and not lines[j].startswith(\"```\"):\n    section.lines.append(lines[j])\n    j +=1\n   sections.append(section)\n   section=Marked()\n   i=j+1\n   continue\n   \n  elif line.lower().startswith('<script'):\n   if isinstance(section,Marked)and section.line:\n    sections.append(section)\n   j=i+1\n   while j <len(lines):\n    if lines[j].lower().startswith('</script>'):\n     sections.append(Script('\\n'.join(lines[i:j+1])))\n     for k in range(i,j+1):\n      lines[k]=''\n     section=Marked()\n     break\n    j +=1\n   i=j\n   continue\n   \n   \n  elif line.startswith('#'):\n   level=1\n   line=lines[i]\n   while level <len(line)and line[level]=='#'and level <=6:\n    level +=1\n   if not line[level+1:].strip():\n    if level ==1:\n     i +=1\n     continue\n    else :\n     lines[i]='<H%s>%s</H%s>\\n'%(level -1,'#',level -1)\n   else :\n    lines[i]='<H%s>%s</H%s>\\n'%(level,line[level+1:],level)\n    \n  else :\n   mo=re.search(ref_pattern,line)\n   if mo is not None :\n    if isinstance(section,Marked)and section.line:\n     sections.append(section)\n     section=Marked()\n    key=mo.groups()[0]\n    value=URL(mo.groups()[1])\n    refs[key.lower()]=value\n   else :\n    if not line.strip():\n     line='<p></p>'\n    if section.line:\n     section.line +='\\n'\n    section.line +=line\n    \n   i +=1\n   \n if isinstance(section,Marked)and section.line:\n  sections.append(section)\n  \n res=''\n for section in sections:\n  mk,_scripts=section.to_html()\n  res +=mk\n  scripts +=_scripts\n  \n return res,scripts\n \ndef escape(czone):\n czone=czone.replace('&','&amp;')\n czone=czone.replace('<','&lt;')\n czone=czone.replace('>','&gt;')\n czone=czone.replace('_','&#95;')\n czone=czone.replace('*','&#42;')\n return czone\n \ndef s_escape(mo):\n\n czone=mo.string[mo.start():mo.end()]\n return escape(czone)\n \ndef unmark(code_zone):\n\n code_zone=code_zone.replace('_','&#95;')\n return code_zone\n \ndef s_unmark(mo):\n\n code_zone=mo.string[mo.start():mo.end()]\n code_zone=code_zone.replace('_','&#95;')\n return code_zone\n \ndef apply_markdown(src):\n\n scripts=[]\n key=None\n \n i=0\n while i <len(src):\n  if src[i]=='[':\n   img_link=i >0 and src[i -1]=='!'\n   start_a=i+1\n   nb=1\n   while True :\n    end_a=src.find(']',i)\n    if end_a ==-1:\n     break\n    nb +=src[i+1:end_a].count('[')-1\n    i=end_a+1\n    if nb ==0:\n     break\n   if end_a >-1 and src[start_a:end_a].find('\\n')==-1:\n    link=src[start_a:end_a]\n    rest=src[end_a+1:].lstrip()\n    if rest and rest[0]=='(':\n     j=0\n     while True :\n      end_href=rest.find(')',j)\n      if end_href ==-1:\n       break\n      if rest[end_href -1]=='\\\\':\n       j=end_href+1\n      else :\n       break\n     if end_href >-1 and rest[:end_href].find('\\n')==-1:\n      if img_link:\n       tag=('<img src=\"'+rest[1:end_href]+\n       '\" alt=\"'+link+'\">')\n       src=src[:start_a -2]+tag+rest[end_href+1:]\n      else :\n       tag=('<a href=\"'+rest[1:end_href]+'\">'+link\n       +'</a>')\n       src=src[:start_a -1]+tag+rest[end_href+1:]\n      i=start_a+len(tag)\n    elif rest and rest[0]=='[':\n     j=0\n     while True :\n      end_key=rest.find(']',j)\n      if end_key ==-1:\n       break\n      if rest[end_key -1]=='\\\\':\n       j=end_key+1\n      else :\n       break\n     if end_key >-1 and rest[:end_key].find('\\n')==-1:\n      if not key:\n       key=link\n      if key.lower()not in refs:\n       raise KeyError('unknown reference %s'%key)\n      url=refs[key.lower()]\n      tag='<a href=\"'+url+'\">'+link+'</a>'\n      src=src[:start_a -1]+tag+rest[end_key+1:]\n      i=start_a+len(tag)\n      \n  i +=1\n  \n  \n  \n  \n  \n  \n  \n  \n  \n rstr=' '+''.join(random.choice(letters)for i in range(16))+' '\n \n i=0\n state=None\n start=-1\n data=''\n tags=[]\n while i <len(src):\n  if src[i]=='<':\n   j=i+1\n   while j <len(src):\n    if src[j]=='\"'or src[j]==\"'\":\n     if state ==src[j]and src[j -1]!='\\\\':\n      state=None\n      j=start+len(data)+1\n      data=''\n     elif state is None :\n      state=src[j]\n      start=j\n     else :\n      data +=src[j]\n    elif src[j]=='>'and state is None :\n     tags.append(src[i:j+1])\n     src=src[:i]+rstr+src[j+1:]\n     i +=len(rstr)\n     break\n    elif state =='\"'or state ==\"'\":\n     data +=src[j]\n    elif src[j]=='\\n':\n    \n    \n     src=src[:i]+'&lt;'+src[i+1:]\n     j=i+4\n     break\n    j +=1\n  elif src[i]=='`'and i >0:\n   if src[i -1]!='\\\\':\n   \n    j=i+1\n    while j <len(src):\n     if src[j]=='`'and src[j -1]!='\\\\':\n      break\n     j +=1\n    i=j\n   else :\n   \n    src=src[:i -1]+\"&#96;\"+src[i+1:]\n  i +=1\n  \n  \n code_pattern=r'\\`(.*?)\\`'\n src=re.sub(code_pattern,s_escape,src)\n \n \n src=src.replace(r'\\\\`','&#96;')\n src=src.replace(r'\\_','&#95;')\n src=src.replace(r'\\*','&#42;')\n \n \n strong_patterns=[('STRONG',r'\\*\\*(.+?)\\*\\*'),('B',r'__(.+?)__')]\n for tag,strong_pattern in strong_patterns:\n  src=re.sub(strong_pattern,r'<%s>\\1</%s>'%(tag,tag),src)\n  \n  \n src=re.sub(r'\\*(.+?)\\*',r'<%s>\\1</%s>'%('EM','EM'),src)\n \n \n \n src=re.sub(r'\\b_(.*?)_\\b',r'<I>\\1</I>',src,\n flags=re.M)\n \n \n code_pattern=r'\\`(.*?)\\`'\n src=re.sub(code_pattern,r'<code>\\1</code>',src)\n \n \n while True :\n  pos=src.rfind(rstr)\n  if pos ==-1:\n   break\n  repl=tags.pop()\n  src=src[:pos]+repl+src[pos+len(rstr):]\n  \n src='<p>'+src+'</p>'\n \n return src,scripts\n", ["random", "re"]],
     "browser.object_storage": [".py", "from javascript import JSON\n\nclass _UnProvided():\n pass\n \n \nclass ObjectStorage():\n\n def __init__(self,storage):\n  self.storage=storage\n  \n def __delitem__(self,key):\n  del self.storage[JSON.stringify(key)]\n  \n def __getitem__(self,key):\n  return JSON.parse(self.storage[JSON.stringify(key)])\n  \n def __setitem__(self,key,value):\n  self.storage[JSON.stringify(key)]=JSON.stringify(value)\n  \n def __contains__(self,key):\n  return JSON.stringify(key)in self.storage\n  \n def get(self,key,default=None ):\n  if JSON.stringify(key)in self.storage:\n   return self.storage[JSON.stringify(key)]\n  return default\n  \n def pop(self,key,default=_UnProvided()):\n  if type(default)is _UnProvided or JSON.stringify(key)in self.storage:\n   return JSON.parse(self.storage.pop(JSON.stringify(key)))\n  return default\n  \n def __iter__(self):\n  keys=self.keys()\n  return keys.__iter__()\n  \n def keys(self):\n  return [JSON.parse(key)for key in self.storage.keys()]\n  \n def values(self):\n  return [JSON.parse(val)for val in self.storage.values()]\n  \n def items(self):\n  return list(zip(self.keys(),self.values()))\n  \n def clear(self):\n  self.storage.clear()\n  \n def __len__(self):\n  return len(self.storage)\n", ["javascript"]],
     "browser.session_storage": [".py", "\nimport sys\nfrom browser import window\nfrom .local_storage import LocalStorage\n\nhas_session_storage=hasattr(window,'sessionStorage')\n\nclass SessionStorage(LocalStorage):\n\n storage_type=\"session_storage\"\n \n def __init__(self):\n  if not has_session_storage:\n   raise EnvironmentError(\"SessionStorage not available\")\n  self.store=window.sessionStorage\n  \nif has_session_storage:\n storage=SessionStorage()\n", ["browser", "browser.local_storage", "sys"]],
     "browser.svg": [".py", "from _svg import *\n", ["_svg"]],
     "browser.template": [".py", "''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nimport tb as traceback\nfrom browser import document,html\n\n\n\nvoid_elements=[\"AREA\",\"BASE\",\"BR\",\"COL\",\"EMBED\",\"HR\",\"IMG\",\"INPUT\",\n\"LINK\",\"META\",\"PARAM\",\"SOURCE\",\"TRACK\",\"WBR\"]\n\ndef copy(obj):\n if isinstance(obj,dict):\n  res={}\n  for key,value in obj.items():\n   res[key]=copy(value)\n  return res\n elif isinstance(obj,(list,tuple)):\n  return obj[:]\n elif isinstance(obj,set):\n  return {x for x in obj}\n else :\n  return obj\n  \n  \nclass ElementData:\n ''\n \n \n def __init__(self,**kw):\n  ''\n\n\n  \n  self.__keys__=set()\n  for key,value in kw.items():\n   object.__setattr__(self,key,value)\n   self.__keys__.add(key)\n   \n def __setattr__(self,attr,value):\n  ''\n\n\n  \n  object.__setattr__(self,attr,value)\n  if attr !=\"__keys__\":\n   self.__keys__.add(attr)\n   \n def to_dict(self):\n  ''\n  return {k:getattr(self,k)for k in self.__keys__}\n  \n def clone(self):\n  ''\n\n\n  \n  return copy(self.to_dict())\n  \n  \nclass TemplateError(Exception):\n pass\n \n \nclass Template:\n\n def __init__(self,element,callbacks=[]):\n  if isinstance(element,str):\n   element=document[element]\n  self.element=element\n  self.line_mapping={}\n  self.line_num=1\n  self.indent=0\n  self.python=\"\"\n  self.parse(element)\n  self.callbacks=callbacks\n  \n def add(self,content,elt):\n  self.python +=content\n  self.line_mapping[self.line_num]=elt\n  if content.endswith(\"\\n\"):\n   self.line_num +=1\n   \n def add_indent(self,content,elt):\n  self.add(\"    \"*self.indent+content,elt)\n  \n def write(self,content):\n  self.html +=str(content)+\"\\n\"\n  \n def parse(self,elt):\n  ''\n\n  \n  \n  \n  is_block=False\n  \n  if elt.nodeType ==3:\n  \n   if elt.text.strip():\n    text=elt.text.replace('\"',\"&quot;\")\n    text=text.replace(\"\\n\",\"\\\\n\")\n    text='\"'+text+'\"'\n    \n    nb_braces=elt.text.count(\"{\")\n    if nb_braces:\n     nb_double_braces=elt.text.count(\"{{\")\n     if nb_double_braces !=nb_braces:\n      lines=[line for line in elt.text.split(\"\\n\")\n      if line.strip()]\n      text='f\"\"\"'+\" \".join(lines)+'\"\"\"'\n    self.add_indent(\"__write__(\"+text+\")\\n\",elt)\n    \n  elif hasattr(elt,\"tagName\"):\n   start_tag=\"__write__('<\"+elt.tagName\n   block=None\n   \n   \n   static_attrs=[]\n   dynamic_attrs=[]\n   for item in elt.attributes:\n    if item.name ==\"b-code\":\n    \n     block=item.value.rstrip(\":\")+\":\"\n    elif item.name ==\"b-include\":\n    \n     elt.html=open(item.value).read()\n    else :\n     value=item.value.replace(\"\\n\",\"\")\n     if \"{\"in value:\n      dynamic_attrs.append(\"'\"+item.name+\"', f'\"+\n      value.replace(\"'\",\"\\\\'\")+\"'\")\n     else :\n      static_attrs.append(item.name+'=\"'+value+'\"')\n      \n   if block:\n    self.add_indent(block+\"\\n\",elt)\n    self.indent +=1\n    is_block=True\n    \n   self.add_indent(start_tag,elt)\n   \n   if static_attrs or dynamic_attrs:\n    self.add(\" \",elt)\n    \n   for attr in static_attrs:\n    self.add_indent(attr+\" \",elt)\n    \n   if dynamic_attrs:\n    self.add(\"')\\n\",elt)\n    for attr in dynamic_attrs:\n     self.add_indent(\"__render_attr__(\"+attr+\")\\n\",elt)\n    self.add_indent(\"__write__('>')\\n\",elt)\n   else :\n    self.add_indent(\">')\\n\",elt)\n    \n  for child in elt.childNodes:\n   self.parse(child)\n   \n  if hasattr(elt,\"tagName\")and elt.tagName not in void_elements:\n   self.add_indent(\"__write__('</\"+elt.tagName+\">')\\n\",elt)\n   \n  if is_block:\n   self.indent -=1\n   \n def on(self,element,event,callback):\n  def func(evt):\n   cache=self.data.clone()\n   callback(evt,self)\n   new_data=self.data.to_dict()\n   if new_data !=cache:\n    self.render(**new_data)\n  element.bind(event,func)\n  \n def render_attr(self,name,value):\n  ''\n\n\n\n\n\n  \n  if value ==\"False\":\n   return\n  elif value ==\"True\":\n   self.html +=\" \"+name\n  else :\n   self.html +=\" \"+name+'=\"'+str(value)+'\"'\n   \n def render(self,**ns):\n  ''\n\n  \n  \n  self.data=ElementData(**ns)\n  \n  \n  ns.update({\"__write__\":self.write,\n  \"__render_attr__\":self.render_attr})\n  \n  self.html=\"\"\n  \n  \n  try :\n   exec(self.python,ns)\n  except Exception as exc:\n   msg=traceback.format_exc()\n   if isinstance(exc,SyntaxError):\n    line_no=exc.args[2]\n   else :\n    tb=exc.traceback\n    while tb is not None :\n     line_no=tb.tb_lineno\n     tb=tb.tb_next\n   elt=self.line_mapping[line_no]\n   print(\"Error rendering the element:\",elt.nodeType)\n   if elt.nodeType ==3:\n    print(elt.textContent)\n   else :\n    try :\n     print(elt.outerHTML)\n    except AttributeError:\n     print('no outerHTML for',elt)\n     print(elt.html)\n   print(f\"{exc.__class__.__name__}:  {exc}\")\n   return\n   \n   \n   \n   \n   \n   \n   \n  if self.element.nodeType !=9:\n   rank=self.element.index()\n   parent=self.element.parent\n   self.element.outerHTML=self.html\n   self.element=parent.childNodes[rank]\n   \n  else :\n  \n   self.element.html=self.html\n   \n   \n  self.element.unbind()\n  callbacks={}\n  for callback in self.callbacks:\n   callbacks[callback.__name__]=callback\n   \n   \n   \n  for element in self.element.select(\"*[b-on]\"):\n   bindings=element.getAttribute(\"b-on\")\n   bindings=bindings.split(\";\")\n   for binding in bindings:\n    parts=binding.split(\":\")\n    if not len(parts)==2:\n     raise TemplateError(f\"wrong binding: {binding}\")\n    event,func_name=[x.strip()for x in parts]\n    if not func_name in callbacks:\n     print(element.outerHTML)\n     raise TemplateError(f\"unknown callback: {func_name}\")\n    self.on(element,event,callbacks[func_name])\n", ["browser", "browser.html", "tb"]],
     "browser.timer": [".py", "from browser import console,window\n\ndef wrap(func,*args):\n\n\n def f():\n  try :\n   return func(*args)\n  except Exception as exc:\n   msg=''\n   try :\n    if exc.args:\n     msg='{0.info}\\n{0.__class__.__name__}: {0.args[0]}'.format(exc)\n    else :\n     msg=str(exc)\n    import sys\n    sys.stderr.write(msg)\n   except Exception as exc2:\n    console.log(\"Error printing exception traceback\",exc2,func,\n    args,kw)\n return f\n \nclear_interval=window.clearInterval\n\nclear_timeout=window.clearTimeout\n\ndef set_interval(func,interval,*args):\n return window.setInterval(wrap(func,*args),interval)\n \ndef set_timeout(func,interval,*args):\n return int(window.setTimeout(wrap(func,*args),interval))\n \ndef request_animation_frame(func):\n return int(window.requestAnimationFrame(func))\n \ndef cancel_animation_frame(int_id):\n window.cancelAnimationFrame(int_id)\n \ndef set_loop_timeout(x):\n\n assert isinstance(x,int)\n __BRYTHON__.loop_timeout=x\n", ["browser", "sys"]],
     "browser.webcomponent": [".py", "from _webcomponent import *\n", ["_webcomponent"]],
     "browser.websocket": [".py", "from browser import window\n\nif hasattr(window,'WebSocket'):\n supported=True\n WebSocket=window.WebSocket.new\nelse :\n supported=False\n \n class WebSocket:\n  def __init__(self,*args):\n   raise NotImplementedError\n", ["browser"]],
     "browser.webworker": [".py", "''\n\n\n\n\n\nfrom browser import window\n\nimport asyncio\nimport os\nimport sys\n\nDEFAULT_BRYTHON_OPTIONS=getattr(__BRYTHON__,'$options')\n\nCHILD_WORKERS=[]\n\n\n\n\n\nS_CREATED=0\nS_LOADING=1\nS_LOADED=2\n\nS_RUNNING=3\n\nS_FINISHED=4\nS_TERMINATED=5\n\ntry :\n _Worker=window.Worker.new\n _can_launch_workers=True\nexcept :\n _can_launch_workers=False\n \nclass WorkerError(Exception):\n pass\n \n \nclass Message:\n ''\n\n\n\n \n def __init__(self,name,data,src=None ,id=-1):\n  self.name=name\n  self.data=data\n  self.id=id\n  self.is_reply=False\n  self.src=None\n  \n def __str__(self):\n  return \"MSG(\"+str(self.name)+\":\"+str(self.id)+\"):\"+str(self.data)\n  \nclass Reply(asyncio.Future):\n ''\n\n\n\n \n _LAST_MESSAGE_ID=0\n _WAITING_REPLIES={}\n \n @classmethod\n def _next_id(cls):\n  cls._LAST_MESSAGE_ID +=1\n  return cls._LAST_MESSAGE_ID\n  \n @classmethod\n def terminate(cls,worker,reason=None ):\n  wr={}\n  text=\"Worker Terminated\"\n  if reason is not None :\n   text +=\"\\n\"+str(reason)\n  for id,reply in cls._WAITING_REPLIES.items():\n   if reply._worker ==worker:\n    reply.set_exception(WorkerError(text))\n   else :\n    wr[id]=reply\n  cls._WAITING_REPLIES=wr\n  \n def __init__(self,message,timeout,worker=None ):\n  super().__init__()\n  message.id=self._next_id()\n  self._wait_id=message.id\n  self._WAITING_REPLIES[message.id]=self\n  self._worker=worker\n  self.add_done_callback(self.finish_waiting)\n  if timeout:\n   self._timeout=self._loop.call_later(timeout,self.set_exception,asyncio.TimeoutError())\n  else :\n   self._timeout=None\n   \n def finish_waiting(self,*args,**kwargs):\n  if self._timeout:\n   self._timeout.cancel()\n   \n  if self._wait_id in self._WAITING_REPLIES:\n   del self._WAITING_REPLIES[self._wait_id]\n   \n def set_result(self,result):\n  super().set_result(result)\n  \nclass WorkerCommon:\n ''\n\n\n \n \n \n @property\n def status(self):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n  \n  return self._status\n  \n def __init__(self,worker):\n  self._status=S_CREATED\n  self._event_handlers={}\n  self._message_handlers={}\n  self._worker=worker\n  self._worker.addEventListener('message',self._event_handler)\n  self._worker.addEventListener('error',self.__error_handler)\n  self._queued_messages=[]\n  self.bind_event('message',self._message_handler)\n  self.bind_event('ready',self._post_queued_messages)\n  \n def post_message(self,message,want_reply=False ,timeout=None ):\n  ''\n\n\n\n\n\n  \n  if self.status >S_RUNNING:\n   raise WorkerError(\"Invalid state\")\n  if want_reply:\n   ret=Reply(message,timeout,worker=self)\n  else :\n   ret=None\n  self._queued_messages.append({'type':'message','name':message.name,'id':message.id,'data':message.data})\n  if self.status ==S_RUNNING:\n   self._post_queued_messages()\n  return ret\n  \n def post_reply(self,message,reply):\n  ''\n\n  \n  payload={'type':'message','name':reply.name,'id':reply.id,'data':reply.data}\n  if message.id:\n   payload['reply_to']=message.id\n  self._queued_messages.append(payload)\n  if self.status ==S_RUNNING:\n   self._post_queued_messages()\n   \n def _post_queued_messages(self,*_,**kwargs):\n  for payload in self._queued_messages:\n   self._worker.postMessage(payload)\n  self._queued_messages.clear()\n  \n def bind_event(self,event,handler):\n  ''\n\n\n\n\n\n\n\n\n  \n  self._bind(self._event_handlers,event,handler)\n  \n def unbind_event(self,event=None ,handler=None ):\n  self._unbind(self._event_handlers,event,handler)\n  \n def bind_message(self,message,handler):\n  ''\n\n\n  \n  self._bind(self._message_handlers,message,handler)\n  \n def unbind_message(self,message=None ,handler=None ):\n  self._unbind(self._message_handlers,message,handler)\n  \n  \n def _bind(self,handler_list,event,handler):\n  handlers=handler_list.get(event,[])\n  handlers.append(handler)\n  handler_list[event]=handlers\n  \n def _unbind(self,handler_list,event=None ,handler=None ):\n  if event is None and handler is None :\n   handler_list={}\n  elif handler is None :\n   handler_list[event]=[]\n  elif event is None :\n   for ev,handlers in handler_list.items():\n    if handler in handlers:\n     handlers.remove(handler)\n  else :\n   handlers=handler_list.get(event,[])\n   if handler in handlers:\n    handlers.remove(handler)\n    \n def _emit_event(self,event,data=None ):\n  self._emit(self._event_handlers,event,data)\n  \n def _emit_message(self,message,msg):\n  self._emit(self._message_handlers,message,msg)\n  \n def _emit(self,handler_list,event,data=None ):\n  try :\n   handlers=handler_list.get(event,[])\n   for h in handlers:\n    h(event,data,src=self)\n  except Exception as ex:\n  \n   print(\"Exception\",str(ex),\"while handling\",event,\"data=\",str(data.data))\n   \n   \n def __error_handler(self,error,*_,**kwargs):\n  self._emit_event('error',error)\n  \n def _event_handler(self,event,*_,**kwargs):\n  try :\n   event_type=event.data['type']\n   self._emit_event(event_type,event.data)\n  except :\n   pass\n   \n def _message_handler(self,event,data,*_,**kwargs):\n  msg=Message(data['name'],data['data'],src=self,id=data['id'])\n  if 'reply_to'in data:\n   msg.is_reply=True\n   reply=Reply._WAITING_REPLIES.get(data['reply_to'],None )\n   if reply:\n    reply.set_result(msg)\n  else :\n   self._emit_message(msg.name,msg)\n   \n   \nclass WorkerParent(WorkerCommon):\n ''\n\n \n WORKER_SCRIPT=sys.base_exec_prefix+'/web_workers/worker.js'\n CHILD_CLASS='browser.webworker.WorkerChild'\n \n def __init__(self,url,argv=[],environ={},brython_options=DEFAULT_BRYTHON_OPTIONS):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n  \n  if not _can_launch_workers:\n   raise WorkerError(\"Cannot spawn workers (webkit based browsers don't support running webworkers inside webworkers)\")\n  super().__init__(_Worker(self.WORKER_SCRIPT,{\"name\":url}))\n  self.bind_event('status',self._status_handler)\n  self.bind_event('error',self._error_handler)\n  self._status_waiters=[]\n  self._status=S_LOADING\n  self._error=None\n  self._worker.postMessage({\n  'program':{'url':url},\n  'brython_options':brython_options,\n  'argv':[url]+argv,\n  'env':environ,\n  'worker_class':self.CHILD_CLASS\n  })\n  CHILD_WORKERS.append(self)\n  \n def terminate(self):\n  ''\n\n\n\n  \n  if self.status >S_RUNNING:\n   raise WorkerError(\"Invalid state\")\n  self._worker.terminate()\n  self._status=S_TERMINATED\n  Reply.terminate(self,self._error)\n  self._emit_event('exited')\n  \n def wait_for_status(self,status):\n  ''\n\n\n  \n  fut=asyncio.Future()\n  setattr(fut,'waiting_for',status)\n  if status <=self.status:\n   fut.set_result(True )\n  else :\n   self._status_waiters.append(fut)\n  return fut\n  \n  \n def _status_handler(self,event,data,*_,**kwargs):\n  self._status=data.status\n  keep=[]\n  for f in self._status_waiters:\n   if f.waiting_for <=self._status:\n    f.set_result(True )\n   else :\n    keep.append(f)\n  self._status_waiters=keep\n  if self._status >=S_FINISHED:\n   self._emit_event('exited')\n   if 'error'in data:\n    self._error=data.error\n   Reply.terminate(self,self._error)\n   CHILD_WORKERS.remove(self)\n  elif self._status ==S_LOADED:\n   self._emit_event('loaded')\n  elif self._status ==S_RUNNING:\n   self._emit_event('ready')\n   \n def _error_handler(self,error,data,*_,**kwargs):\n  self._error=data\n  self.terminate()\n  \n  \nclass WorkerChild(WorkerCommon):\n ''\n\n\n\n\n \n def __init__(self):\n  super().__init__(__BRYTHON__._WORKER)\n  self._argv=sys.argv\n  self._environ=__BRYTHON__._ENV\n  self._status=S_LOADED\n  \n def exec(self):\n  ''\n\n\n  \n  self._status=S_RUNNING\n  self._worker.postMessage({'type':'status','status':S_RUNNING})\n  self._emit_event('ready')\n  \n def terminate(self):\n  ''\n\n  \n  if self.status >S_RUNNING:\n   raise WorkerError(\"Invalid state\")\n  self._status=S_FINISHED\n  self._emit_event('exited')\n  self._worker.postMessage({'type':'status','status':S_FINISHED})\n  self._worker.close()\n  \nclass RPCWorkerParent(WorkerParent):\n CHILD_CLASS='browser.webworker.RPCWorkerChild'\n \n def __init__(self,url,argv=[],environ={},brython_options=DEFAULT_BRYTHON_OPTIONS):\n  super().__init__(url,argv,environ,brython_options)\n  self.bind_message('register',self._register)\n  \n def _register(self,msg_name,message,*_,**kwargs):\n  for method,doc in message.data:\n   self._generate_method(method,doc)\n   \n def _generate_method(self,method,doc):\n  @asyncio.coroutine\n  def meth(*args,**kwargs):\n   msg=Message('call',{'method':method,'args':args,'kwargs':kwargs})\n   reply=yield self.post_message(msg,want_reply=True )\n   if reply.data['status']=='ok':\n    return reply.data['ret']\n   else :\n    raise WorkerError(reply.data['error'])\n    \n  meth.__doc__=doc\n  meth.__name__=method\n  setattr(self,method,meth)\n  \nclass RPCWorkerChild(WorkerChild):\n def __init__(self):\n  super().__init__()\n  self._methods={}\n  self.bind_message('call',self._call)\n  \n def register_method(self,m):\n  m_name=m.__name__.split('.')[-1]\n  m_doc=m.__doc__ or ''\n  self._methods[m_name]=m\n  msg=Message('register',[(m_name,m_doc)])\n  self.post_message(msg)\n  \n def _call(self,msg_name,message,*_,**kw):\n \n  m_name=message.data['method']\n  args=message.data['args']\n  kwargs=message.data['kwargs']\n  if m_name not in self._methods:\n   self.post_reply(message,Message('result',{'status':'error','error':'Method not registered'}))\n  m=self._methods.get(m_name)\n  try :\n   ret=m(*args,**kwargs)\n   msg=Message('result',{'status':'ok','ret':ret})\n   self.post_reply(message,msg)\n  except Exception as e:\n   msg=Message('result',{'status':'error','error':\"Exception raised in call:\"+str(e)})\n   self.post_reply(message,msg)\n   \nif __BRYTHON__.isa_web_worker:\n w_cls=__BRYTHON__._WORKER_CLASS\n elements=w_cls.split('.')\n cls_name=elements[-1]\n cls_module='.'.join(elements[:-1])\n try :\n  mod=__import__(cls_module,fromlist=[cls_name])\n  current_worker=getattr(mod,cls_name)()\n except Exception as ex:\n  print(\"Error importing child worker class\",ex)\n  __BRYTHON__._WORKER.postMessage({'type':'status','status':S_TERMINATED,'error':str(ex)})\n  __BRYTHON__._WORKER.close()\n  \n os.environ.update(dict(current_worker._environ))\nelse :\n current_worker=None\n", ["asyncio", "browser", "os", "sys"]],
     "browser.worker": [".py", "from _webworker import *\n", ["_webworker"]],
-    "browser.widgets.dialog": [".py", "from browser import console,document,html,window\n\nstyle_sheet=\"\"\"\n:root {\n    --brython-dialog-font-family: Arial;\n    --brython-dialog-font-size: 100%;\n    --brython-dialog-bgcolor: #fff;\n    --brython-dialog-border-color: #000;\n    --brython-dialog-title-bgcolor: CadetBlue;\n    --brython-dialog-title-color: #fff;\n    --brython-dialog-close-bgcolor: #fff;\n    --brython-dialog-close-color: #000;\n}\n\n.brython-dialog-main {\n    font-family: var(--brython-dialog-font-family);\n    font-size: var(--brython-dialog-font-size);\n    background-color: var(--brython-dialog-bgcolor);\n    left: 10px;\n    top: 10px;\n    border-style: solid;\n    border-color: var(--brython-dialog-border-color);\n    border-width: 1px;\n    z-index: 10;\n}\n\n.brython-dialog-title {\n    background-color: var(--brython-dialog-title-bgcolor);\n    color: var(--brython-dialog-title-color);\n    border-style: solid;\n    border-color: var(--brython-dialog-border-color);\n    border-width: 0px 0px 1px 0px;\n    padding: 0.4em;\n    cursor: default;\n}\n\n.brython-dialog-close {\n    float: right;\n    background-color: var(--brython-dialog-close-bgcolor);\n    color: var(--brython-dialog-close-color);\n    cursor: default;\n    padding: 0.1em;\n}\n\n.brython-dialog-panel {\n    padding: 0.6em;\n}\n\n.brython-dialog-message {\n    padding-right: 0.6em;\n}\n\n.brython-dialog-button {\n    margin: 0.5em;\n}\n\"\"\"\n\n\nclass Dialog(html.DIV):\n ''\n\n\n\n\n\n \n \n def __init__(self,title=\"\",*,\n top=None ,left=None ,ok_cancel=False ,default_css=True ):\n  if default_css:\n   for stylesheet in document.styleSheets:\n    if stylesheet.ownerNode.id ==\"brython-dialog\":\n     break\n   else :\n    document <=html.STYLE(style_sheet,id=\"brython-dialog\")\n    \n  html.DIV.__init__(self,style=dict(position=\"absolute\"),\n  Class=\"brython-dialog-main\")\n  \n  self.title_bar=html.DIV(html.SPAN(title),Class=\"brython-dialog-title\")\n  self <=self.title_bar\n  self.close_button=html.SPAN(\"&times;\",Class=\"brython-dialog-close\")\n  self.title_bar <=self.close_button\n  self.close_button.bind(\"click\",self.close)\n  self.panel=html.DIV(Class=\"brython-dialog-panel\")\n  self <=self.panel\n  \n  if ok_cancel:\n   ok_cancel_zone=html.DIV(style={\"text-align\":\"center\"})\n   ok,cancel=\"Ok\",\"Cancel\"\n   if isinstance(ok_cancel,(list,tuple)):\n    if not len(ok_cancel)==2:\n     raise ValueError(\n     f\"ok_cancel expects 2 elements, got {len(ok_cancel)}\")\n    ok,cancel=ok_cancel\n   self.ok_button=html.BUTTON(ok,Class=\"brython-dialog-button\")\n   self.cancel_button=html.BUTTON(cancel,\n   Class=\"brython-dialog-button\")\n   self.cancel_button.bind(\"click\",self.close)\n   ok_cancel_zone <=self.ok_button+self.cancel_button\n   self <=ok_cancel_zone\n   \n  document <=self\n  cstyle=window.getComputedStyle(self)\n  \n  \n  if left is None :\n   width=round(float(cstyle.width[:-2])+0.5)\n   left=int((window.innerWidth -width)/2)\n  self.left=left\n  self.style.left=f'{left}px'\n  if top is None :\n   height=round(float(cstyle.height[:-2])+0.5)\n   top=int((window.innerHeight -height)/2)\n   \n  top +=document.scrollingElement.scrollTop\n  self.top=top\n  self.style.top=f'{top}px'\n  \n  self.title_bar.bind(\"mousedown\",self.mousedown)\n  self.title_bar.bind(\"touchstart\",self.mousedown)\n  self.title_bar.bind(\"mouseup\",self.mouseup)\n  self.title_bar.bind(\"touchend\",self.mouseup)\n  self.bind(\"leave\",self.mouseup)\n  self.is_moving=False\n  \n def close(self,*args):\n  self.remove()\n  \n def mousedown(self,event):\n  document.bind(\"mousemove\",self.mousemove)\n  document.bind(\"touchmove\",self.mousemove)\n  self.is_moving=True\n  self.initial=[self.left -event.x,self.top -event.y]\n  \n  event.preventDefault()\n  \n def mousemove(self,event):\n  if not self.is_moving:\n   return\n   \n   \n  self.left=self.initial[0]+event.x\n  self.top=self.initial[1]+event.y\n  \n def mouseup(self,event):\n  self.is_moving=False\n  document.unbind(\"mousemove\")\n  document.unbind(\"touchmove\")\n  \n  \nclass EntryDialog(Dialog):\n ''\n\n\n\n\n\n\n\n\n\n \n \n def __init__(self,title,message=None ,*,\n top=None ,left=None ,default_css=True ):\n  Dialog.__init__(self,title,\n  top=top,left=left,ok_cancel=True ,\n  default_css=default_css)\n  self.message=html.SPAN(message,Class=\"brython-dialog-message\")\\\n  or \"\"\n  self.entry=html.INPUT()\n  self.panel <=self.message+self.entry\n  self.entry.focus()\n  \n  self.entry.bind(\"keypress\",self.callback)\n  self.ok_button.bind(\"click\",self.callback)\n  \n @property\n def value(self):\n  return self.entry.value\n  \n def callback(self,evt):\n  if evt.target ==self.entry and evt.keyCode !=13:\n   return\n  self.dispatchEvent(window.Event.new(\"entry\"))\n  \nclass InfoDialog(Dialog):\n ''\n \n def __init__(self,title,message,*,\n top=None ,left=None ,default_css=True ,\n remove_after=None ,ok=False ):\n  ''\n  \n  Dialog.__init__(self,title,\n  top=top,left=left,default_css=default_css)\n  self.panel <=html.DIV(message)\n  if ok:\n   ok=ok if isinstance(ok,str)else \"Ok\"\n   self.ok_button=html.BUTTON(ok,Class=\"brython-dialog-button\")\n   self.panel <=html.P()\n   self.panel <=html.DIV(self.ok_button,\n   style={\"text-align\":\"center\"})\n   self.ok_button.bind(\"click\",lambda ev:self.remove())\n  if remove_after:\n   if not isinstance(remove_after,(int,float)):\n    raise TypeError(\"remove_after should be a number, not \"+\n    str(remove_after.__class__.__name__))\n   window.setTimeout(self.close,remove_after *1000)\n", ["browser", "browser.html"]],
+    "browser.widgets.dialog": [".py", "from browser import console,document,html,window\n\nstyle_sheet=\"\"\"\n:root {\n    --brython-dialog-font-family: Arial;\n    --brython-dialog-font-size: 100%;\n    --brython-dialog-bgcolor: #fff;\n    --brython-dialog-border-color: #000;\n    --brython-dialog-title-bgcolor: CadetBlue;\n    --brython-dialog-title-color: #fff;\n    --brython-dialog-close-bgcolor: #fff;\n    --brython-dialog-close-color: #000;\n}\n\n.brython-dialog-main {\n    font-family: var(--brython-dialog-font-family);\n    font-size: var(--brython-dialog-font-size);\n    background-color: var(--brython-dialog-bgcolor);\n    left: 10px;\n    top: 10px;\n    border-style: solid;\n    border-color: var(--brython-dialog-border-color);\n    border-width: 1px;\n    z-index: 10;\n}\n\n.brython-dialog-title {\n    background-color: var(--brython-dialog-title-bgcolor);\n    color: var(--brython-dialog-title-color);\n    border-style: solid;\n    border-color: var(--brython-dialog-border-color);\n    border-width: 0px 0px 1px 0px;\n    padding: 0.4em;\n    cursor: default;\n}\n\n.brython-dialog-close {\n    float: right;\n    background-color: var(--brython-dialog-close-bgcolor);\n    color: var(--brython-dialog-close-color);\n    cursor: default;\n    padding: 0.1em;\n}\n\n.brython-dialog-panel {\n    padding: 0.6em;\n}\n\n.brython-dialog-message {\n    padding-right: 0.6em;\n}\n\n.brython-dialog-button {\n    margin: 0.5em;\n}\n\"\"\"\n\n\nclass Dialog(html.DIV):\n ''\n\n\n\n\n\n \n \n def __init__(self,title=\"\",*,\n top=None ,left=None ,ok_cancel=False ,default_css=True ):\n  if default_css:\n   for stylesheet in document.styleSheets:\n    if stylesheet.ownerNode.id ==\"brython-dialog\":\n     break\n   else :\n    document <=html.STYLE(style_sheet,id=\"brython-dialog\")\n    \n  html.DIV.__init__(self,style=dict(position=\"absolute\"),\n  Class=\"brython-dialog-main\")\n  \n  self.title_bar=html.DIV(html.SPAN(title),Class=\"brython-dialog-title\")\n  self <=self.title_bar\n  self.close_button=html.SPAN(\"&times;\",Class=\"brython-dialog-close\")\n  self.title_bar <=self.close_button\n  self.close_button.bind(\"click\",self.close)\n  self.panel=html.DIV(Class=\"brython-dialog-panel\")\n  self <=self.panel\n  \n  if ok_cancel:\n   ok_cancel_zone=html.DIV(style={\"text-align\":\"center\"})\n   ok,cancel=\"Ok\",\"Cancel\"\n   if isinstance(ok_cancel,(list,tuple)):\n    if not len(ok_cancel)==2:\n     raise ValueError(\n     f\"ok_cancel expects 2 elements, got {len(ok_cancel)}\")\n    ok,cancel=ok_cancel\n   self.ok_button=html.BUTTON(ok,Class=\"brython-dialog-button\")\n   self.cancel_button=html.BUTTON(cancel,\n   Class=\"brython-dialog-button\")\n   self.cancel_button.bind(\"click\",self.close)\n   ok_cancel_zone <=self.ok_button+self.cancel_button\n   self <=ok_cancel_zone\n   \n  document <=self\n  cstyle=window.getComputedStyle(self)\n  \n  \n  if left is None :\n   width=round(float(cstyle.width[:-2])+0.5)\n   left=int((window.innerWidth -width)/2)\n  self.left=left\n  self.style.left=f'{left}px'\n  if top is None :\n   height=round(float(cstyle.height[:-2])+0.5)\n   top=int((window.innerHeight -height)/2)\n   \n  top +=document.scrollingElement.scrollTop\n  self.top=top\n  self.style.top=f'{top}px'\n  \n  self.title_bar.bind(\"mousedown\",self.mousedown)\n  self.title_bar.bind(\"touchstart\",self.mousedown)\n  self.title_bar.bind(\"mouseup\",self.mouseup)\n  self.title_bar.bind(\"touchend\",self.mouseup)\n  self.bind(\"leave\",self.mouseup)\n  self.is_moving=False\n  \n def close(self,*args):\n  self.remove()\n  \n def mousedown(self,event):\n  document.bind(\"mousemove\",self.mousemove)\n  document.bind(\"touchmove\",self.mousemove)\n  self.is_moving=True\n  self.initial=[self.left -event.x,self.top -event.y]\n  \n  event.preventDefault()\n  \n def mousemove(self,event):\n  if not self.is_moving:\n   return\n   \n   \n  self.left=self.initial[0]+event.x\n  self.top=self.initial[1]+event.y\n  \n def mouseup(self,event):\n  self.is_moving=False\n  document.unbind(\"mousemove\")\n  document.unbind(\"touchmove\")\n  \n  \nclass EntryDialog(Dialog):\n ''\n\n\n\n\n\n\n\n\n\n \n \n def __init__(self,title,message=None ,*,\n top=None ,left=None ,default_css=True ):\n  Dialog.__init__(self,title,\n  top=top,left=left,ok_cancel=True ,\n  default_css=default_css)\n  self.message=html.SPAN(message or '',Class=\"brython-dialog-message\")\\\n  or \"\"\n  self.entry=html.INPUT()\n  self.panel <=self.message+self.entry\n  self.entry.focus()\n  \n  self.entry.bind(\"keypress\",self.callback)\n  self.ok_button.bind(\"click\",self.callback)\n  \n @property\n def value(self):\n  return self.entry.value\n  \n def callback(self,evt):\n  if evt.target ==self.entry and evt.keyCode !=13:\n   return\n  self.dispatchEvent(window.Event.new(\"entry\"))\n  \nclass InfoDialog(Dialog):\n ''\n \n def __init__(self,title,message,*,\n top=None ,left=None ,default_css=True ,\n remove_after=None ,ok=False ):\n  ''\n  \n  Dialog.__init__(self,title,\n  top=top,left=left,default_css=default_css)\n  self.panel <=html.DIV(message)\n  if ok:\n   ok=ok if isinstance(ok,str)else \"Ok\"\n   self.ok_button=html.BUTTON(ok,Class=\"brython-dialog-button\")\n   self.panel <=html.P()\n   self.panel <=html.DIV(self.ok_button,\n   style={\"text-align\":\"center\"})\n   self.ok_button.bind(\"click\",lambda ev:self.remove())\n  if remove_after:\n   if not isinstance(remove_after,(int,float)):\n    raise TypeError(\"remove_after should be a number, not \"+\n    str(remove_after.__class__.__name__))\n   window.setTimeout(self.close,remove_after *1000)\n", ["browser", "browser.html"]],
     "browser.widgets.menu": [".py", "from browser import console,document,html,window,alert\n\nstyle_sheet=\"\"\"\n/* Classes for brython.widgets.menu */\n\n:root {\n  --brython-menu-font-family: Arial;\n  --brython-menu-font-size: 100%;\n  --brython-menu-navbar-bgcolor: CadetBlue;\n  --brython-menu-navbar-bgcolor-selected: SkyBlue;\n  --brython-menu-navbar-color: #fff;\n  --brython-menu-color: #000;\n  --brython-menu-submenu-bgcolor: #fff;\n  --brython-menu-submenu-bgcolor-selected: SkyBlue;\n}\n\n/* Item in the main horizontal navigation bar */\n.brython-menu-navbar-item {\n    font-family: var(--brython-menu-font-family);\n    font-size: var(--brython-menu-font-size);\n    background-color: var(--brython-menu-navbar-bgcolor);\n    color: var(--brython-menu-navbar-color);\n    padding: 0.5em 1em 0.5em 1em;\n    cursor: default;\n}\n\n.brython-menu-navbar-item:hover {\n    background-color: var(--brython-menu-navbar-bgcolor-selected);\n}\n\n.brython-menu-navbar-item-selected {\n    background-color: var(--brython-menu-navbar-bgcolor-selected);\n}\n\n/* Table for a submenu, opened by a click on an item */\n.brython-menu-submenu {\n    font-family: var(--brython-menu-font-family);\n    font-size: var(--brython-menu-font-size);\n    background-color: var(--brython-menu-submenu-bgcolor);\n    position: absolute;\n    border-style: solid;\n    border-width: 1px;\n    border-color: var(--brython-menu-color);\n    border-spacing: 0;\n}\n\n/* TR for a submenu item row */\n.brython-menu-submenu-row:hover {\n    color: var(--brython-menu-color);\n    background-color: var(--brython-menu-submenu-bgcolor-selected);\n}\n\n.brython-menu-submenu-row-selected {\n    color: var(--brython-menu-color);\n    background-color: var(--brython-menu-submenu-bgcolor-selected);\n}\n\n/*\n   TD for a cell in a submenu row\n   Each row has two cells, one for the item label, the other one\n   filled with a > if the item has a submenu\n*/\n.brython-menu-submenu-item {\n    font-family: var(--brython-menu-font-family);\n    padding: 0.3em 0.3em 0.3em 1em;\n    cursor: default;\n}\n\n/* end of browser.widgets.menu classes */\n\n\"\"\"\n\n\nclass Menu:\n\n def __init__(self,container=document.body,parent=None ,default_css=True ):\n  ''\n\n  \n  self.container=container\n  self.parent=parent\n  \n  if default_css:\n  \n   for stylesheet in document.styleSheets:\n    if stylesheet.ownerNode.id ==\"brython-menu\":\n     break\n   else :\n    document <=html.STYLE(style_sheet,id=\"brython-menu\")\n    \n  self.default_css=default_css\n  \n  if parent:\n   parent.submenu=html.TABLE(Class=\"brython-menu-submenu\")\n   parent.submenu.style.position=\"absolute\"\n   parent.submenu.style.display=\"none\"\n   self.container <=parent.submenu\n   \n   parent.bind(\"click\",self.unfold)\n   \n  if not hasattr(self.container,\"bind_document\"):\n  \n   document.bind(\"click\",self.hide_menus)\n   self.container.bind_document=True\n   \n def add_item(self,label,callback=None ,menu=False ):\n  if self.parent is None :\n  \n   item=html.SPAN(label,Class=\"brython-menu-navbar-item\")\n   self.container <=item\n   item.bind(\"click\",self.hide_menus)\n  else :\n  \n   item=html.TR(Class=\"brython-menu-submenu-row\")\n   self.parent.submenu <=item\n   item <=html.TD(label,Class=\"brython-menu-submenu-item\")\n   item <=html.TD(\">\"if menu else \"&nbsp;\",\n   Class=\"brython-menu-submenu-item\",\n   paddingLeft=\"2em\")\n   \n  if callback is not None :\n   item.bind(\"click\",callback)\n   \n  return item\n  \n def add_link(self,label,href):\n  ''\n  if self.parent is None :\n  \n   item=html.A(label,Class=\"brython-menu-navbar-link\",href=href)\n   self.container <=item\n  else :\n  \n   item=html.TR(Class=\"brython-menu-submenu-row\")\n   self.parent.submenu <=item\n   item <=html.TD(html.A(label,Class=\"brython-menu-submenu-link\",\n   href=href))\n   \n  return item\n  \n def add_menu(self,label):\n  ''\n  \n  item=self.add_item(label,menu=True )\n  \n  if self.parent is None :\n  \n   span=html.SPAN(Class=\"brython-menu-submenu\")\n   span.style.position=\"absolute\"\n   \n  return Menu(self.container,item,default_css=self.default_css)\n  \n def hide_menus(self,*args):\n  ''\n  for css in [\".brython-menu-navbar-item-selected\",\n  \".brython-menu-submenu-row-selected\"]:\n   for item in document.select(css):\n    item.classList.remove(css[1:])\n  for div in document.select(\".brython-menu-submenu\"):\n   if div.style.display !=\"none\":\n    div.style.display=\"none\"\n    \n def hide_submenus(self,table):\n  ''\n  for row in table.select(\"TR\"):\n   if hasattr(row,\"submenu\"):\n    row.submenu.style.display=\"none\"\n    self.hide_submenus(row.submenu)\n    \n def unfold(self,ev):\n  ''\n  target=ev.target\n  if target.nodeName ==\"SPAN\":\n  \n   selected=document.select(\".brython-menu-navbar-item-selected\")\n   \n   if selected:\n    self.hide_menus()\n    \n   for item in selected:\n    item.classList.remove(\"brython-menu-navbar-item-selected\")\n    \n   submenu=target.submenu\n   \n   target.classList.add(\"brython-menu-navbar-item-selected\")\n   submenu.style.left=f\"{target.abs_left}px\"\n   submenu.style.top=f\"{target.abs_top + target.offsetHeight}px\"\n   \n   \n   \n   if not selected:\n    for item in document.select(\".brython-menu-navbar-item\"):\n     item.bind(\"mouseenter\",self.unfold)\n     \n     \n   submenu.style.display=\"block\"\n   \n  else :\n   target=target.closest(\"TR\")\n   \n   \n   table=target.closest(\"TABLE\")\n   self.hide_submenus(table)\n   \n   \n   selected=table.select(\".brython-menu-submenu-row-selected\")\n   for row in selected:\n    row.classList.remove(\"brython-menu-submenu-row-selected\")\n    \n    \n   target.classList.add(\"brython-menu-submenu-row-selected\")\n   \n   if hasattr(target,\"submenu\"):\n   \n    target.submenu.style.top=f\"{target.abs_top}px\"\n    target.submenu.style.left=\\\n    f\"{target.abs_left + target.offsetWidth}px\"\n    target.submenu.style.display=\"block\"\n    \n   if not selected:\n   \n   \n    for row in table.select(\"TR\"):\n     row.bind(\"mouseenter\",self.unfold)\n     \n     \n     \n     \n  ev.stopPropagation()\n", ["browser", "browser.html"]],
     "browser.widgets": [".py", "", [], 1],
     "collections.abc": [".py", "from _collections_abc import *\nfrom _collections_abc import __all__\n", ["_collections_abc"]],
     "collections": [".py", "''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n__all__=[\n'ChainMap',\n'Counter',\n'OrderedDict',\n'UserDict',\n'UserList',\n'UserString',\n'defaultdict',\n'deque',\n'namedtuple',\n]\n\nimport _collections_abc\nimport heapq as _heapq\nimport sys as _sys\n\nfrom itertools import chain as _chain\nfrom itertools import repeat as _repeat\nfrom itertools import starmap as _starmap\nfrom keyword import iskeyword as _iskeyword\nfrom operator import eq as _eq\nfrom operator import itemgetter as _itemgetter\nfrom reprlib import recursive_repr as _recursive_repr\nfrom _weakref import proxy as _proxy\n\ntry :\n from _collections import deque\nexcept ImportError:\n pass\nelse :\n _collections_abc.MutableSequence.register(deque)\n \ntry :\n from _collections import defaultdict\nexcept ImportError:\n pass\n \n \ndef __getattr__(name):\n\n\n\n if name in _collections_abc.__all__:\n  obj=getattr(_collections_abc,name)\n  import warnings\n  warnings.warn(\"Using or importing the ABCs from 'collections' instead \"\n  \"of from 'collections.abc' is deprecated since Python 3.3, \"\n  \"and in 3.10 it will stop working\",\n  DeprecationWarning,stacklevel=2)\n  globals()[name]=obj\n  return obj\n raise AttributeError(f'module {__name__!r} has no attribute {name!r}')\n \n \n \n \n \n \nclass _OrderedDictKeysView(_collections_abc.KeysView):\n\n def __reversed__(self):\n  yield from reversed(self._mapping)\n  \nclass _OrderedDictItemsView(_collections_abc.ItemsView):\n\n def __reversed__(self):\n  for key in reversed(self._mapping):\n   yield (key,self._mapping[key])\n   \nclass _OrderedDictValuesView(_collections_abc.ValuesView):\n\n def __reversed__(self):\n  for key in reversed(self._mapping):\n   yield self._mapping[key]\n   \nclass _Link(object):\n __slots__='prev','next','key','__weakref__'\n \nclass OrderedDict(dict):\n ''\n \n \n \n \n \n \n \n \n \n \n \n \n \n def __init__(self,other=(),/,**kwds):\n  ''\n\n  \n  try :\n   self.__root\n  except AttributeError:\n   self.__hardroot=_Link()\n   self.__root=root=_proxy(self.__hardroot)\n   root.prev=root.next=root\n   self.__map={}\n  self.__update(other,**kwds)\n  \n def __setitem__(self,key,value,\n dict_setitem=dict.__setitem__,proxy=_proxy,Link=_Link):\n  ''\n  \n  \n  if key not in self:\n   self.__map[key]=link=Link()\n   root=self.__root\n   last=root.prev\n   link.prev,link.next,link.key=last,root,key\n   last.next=link\n   root.prev=proxy(link)\n  dict_setitem(self,key,value)\n  \n def __delitem__(self,key,dict_delitem=dict.__delitem__):\n  ''\n  \n  \n  dict_delitem(self,key)\n  link=self.__map.pop(key)\n  link_prev=link.prev\n  link_next=link.next\n  link_prev.next=link_next\n  link_next.prev=link_prev\n  link.prev=None\n  link.next=None\n  \n def __iter__(self):\n  ''\n  \n  root=self.__root\n  curr=root.next\n  while curr is not root:\n   yield curr.key\n   curr=curr.next\n   \n def __reversed__(self):\n  ''\n  \n  root=self.__root\n  curr=root.prev\n  while curr is not root:\n   yield curr.key\n   curr=curr.prev\n   \n def clear(self):\n  ''\n  root=self.__root\n  root.prev=root.next=root\n  self.__map.clear()\n  dict.clear(self)\n  \n def popitem(self,last=True ):\n  ''\n\n\n  \n  if not self:\n   raise KeyError('dictionary is empty')\n  root=self.__root\n  if last:\n   link=root.prev\n   link_prev=link.prev\n   link_prev.next=root\n   root.prev=link_prev\n  else :\n   link=root.next\n   link_next=link.next\n   root.next=link_next\n   link_next.prev=root\n  key=link.key\n  del self.__map[key]\n  value=dict.pop(self,key)\n  return key,value\n  \n def move_to_end(self,key,last=True ):\n  ''\n\n\n  \n  link=self.__map[key]\n  link_prev=link.prev\n  link_next=link.next\n  soft_link=link_next.prev\n  link_prev.next=link_next\n  link_next.prev=link_prev\n  root=self.__root\n  if last:\n   last=root.prev\n   link.prev=last\n   link.next=root\n   root.prev=soft_link\n   last.next=link\n  else :\n   first=root.next\n   link.prev=root\n   link.next=first\n   first.prev=soft_link\n   root.next=link\n   \n def __sizeof__(self):\n  sizeof=_sys.getsizeof\n  n=len(self)+1\n  size=sizeof(self.__dict__)\n  size +=sizeof(self.__map)*2\n  size +=sizeof(self.__hardroot)*n\n  size +=sizeof(self.__root)*n\n  return size\n  \n update=__update=_collections_abc.MutableMapping.update\n \n def keys(self):\n  ''\n  return _OrderedDictKeysView(self)\n  \n def items(self):\n  ''\n  return _OrderedDictItemsView(self)\n  \n def values(self):\n  ''\n  return _OrderedDictValuesView(self)\n  \n __ne__=_collections_abc.MutableMapping.__ne__\n \n __marker=object()\n \n def pop(self,key,default=__marker):\n  ''\n\n\n\n  \n  if key in self:\n   result=self[key]\n   del self[key]\n   return result\n  if default is self.__marker:\n   raise KeyError(key)\n  return default\n  \n def setdefault(self,key,default=None ):\n  ''\n\n\n  \n  if key in self:\n   return self[key]\n  self[key]=default\n  return default\n  \n @_recursive_repr()\n def __repr__(self):\n  ''\n  if not self:\n   return '%s()'%(self.__class__.__name__,)\n  return '%s(%r)'%(self.__class__.__name__,list(self.items()))\n  \n def __reduce__(self):\n  ''\n  inst_dict=vars(self).copy()\n  for k in vars(OrderedDict()):\n   inst_dict.pop(k,None )\n  return self.__class__,(),inst_dict or None ,None ,iter(self.items())\n  \n def copy(self):\n  ''\n  return self.__class__(self)\n  \n @classmethod\n def fromkeys(cls,iterable,value=None ):\n  ''\n  \n  self=cls()\n  for key in iterable:\n   self[key]=value\n  return self\n  \n def __eq__(self,other):\n  ''\n\n\n  \n  if isinstance(other,OrderedDict):\n   return dict.__eq__(self,other)and all(map(_eq,self,other))\n  return dict.__eq__(self,other)\n  \n def __ior__(self,other):\n  self.update(other)\n  return self\n  \n def __or__(self,other):\n  if not isinstance(other,dict):\n   return NotImplemented\n  new=self.__class__(self)\n  new.update(other)\n  return new\n  \n def __ror__(self,other):\n  if not isinstance(other,dict):\n   return NotImplemented\n  new=self.__class__(other)\n  new.update(self)\n  return new\n  \n  \ntry :\n from _collections import OrderedDict\nexcept ImportError:\n\n pass\n \n \n \n \n \n \ntry :\n from _collections import _tuplegetter\nexcept ImportError:\n _tuplegetter=lambda index,doc:property(_itemgetter(index),doc=doc)\n \ndef namedtuple(typename,field_names,*,rename=False ,defaults=None ,module=None ):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n if isinstance(field_names,str):\n  field_names=field_names.replace(',',' ').split()\n field_names=list(map(str,field_names))\n typename=_sys.intern(str(typename))\n \n if rename:\n  seen=set()\n  for index,name in enumerate(field_names):\n   if (not name.isidentifier()\n   or _iskeyword(name)\n   or name.startswith('_')\n   or name in seen):\n    field_names[index]=f'_{index}'\n   seen.add(name)\n   \n for name in [typename]+field_names:\n  if type(name)is not str:\n   raise TypeError('Type names and field names must be strings')\n  if not name.isidentifier():\n   raise ValueError('Type names and field names must be valid '\n   f'identifiers: {name!r}')\n  if _iskeyword(name):\n   raise ValueError('Type names and field names cannot be a '\n   f'keyword: {name!r}')\n   \n seen=set()\n for name in field_names:\n  if name.startswith('_')and not rename:\n   raise ValueError('Field names cannot start with an underscore: '\n   f'{name!r}')\n  if name in seen:\n   raise ValueError(f'Encountered duplicate field name: {name!r}')\n  seen.add(name)\n  \n field_defaults={}\n if defaults is not None :\n  defaults=tuple(defaults)\n  if len(defaults)>len(field_names):\n   raise TypeError('Got more default values than field names')\n  field_defaults=dict(reversed(list(zip(reversed(field_names),\n  reversed(defaults)))))\n  \n  \n field_names=tuple(map(_sys.intern,field_names))\n num_fields=len(field_names)\n arg_list=', '.join(field_names)\n if num_fields ==1:\n  arg_list +=','\n repr_fmt='('+', '.join(f'{name}=%r'for name in field_names)+')'\n tuple_new=tuple.__new__\n _dict,_tuple,_len,_map,_zip=dict,tuple,len,map,zip\n \n \n \n namespace={\n '_tuple_new':tuple_new,\n '__builtins__':None ,\n '__name__':f'namedtuple_{typename}',\n }\n code=f'lambda _cls, {arg_list}: _tuple_new(_cls, ({arg_list}))'\n __new__=eval(code,namespace)\n __new__.__name__='__new__'\n __new__.__doc__=f'Create new instance of {typename}({arg_list})'\n if defaults is not None :\n  __new__.__defaults__=defaults\n  \n @classmethod\n def _make(cls,iterable):\n  result=tuple_new(cls,iterable)\n  if _len(result)!=num_fields:\n   raise TypeError(f'Expected {num_fields} arguments, got {len(result)}')\n  return result\n  \n _make.__func__.__doc__=(f'Make a new {typename} object from a sequence '\n 'or iterable')\n \n def _replace(self,/,**kwds):\n  result=self._make(_map(kwds.pop,field_names,self))\n  if kwds:\n   raise ValueError(f'Got unexpected field names: {list(kwds)!r}')\n  return result\n  \n _replace.__doc__=(f'Return a new {typename} object replacing specified '\n 'fields with new values')\n \n def __repr__(self):\n  ''\n  return self.__class__.__name__+repr_fmt %self\n  \n def _asdict(self):\n  ''\n  return _dict(_zip(self._fields,self))\n  \n def __getnewargs__(self):\n  ''\n  return _tuple(self)\n  \n  \n for method in (\n __new__,\n _make.__func__,\n _replace,\n __repr__,\n _asdict,\n __getnewargs__,\n ):\n  method.__qualname__=f'{typename}.{method.__name__}'\n  \n  \n  \n class_namespace={\n '__doc__':f'{typename}({arg_list})',\n '__slots__':(),\n '_fields':field_names,\n '_field_defaults':field_defaults,\n '__new__':__new__,\n '_make':_make,\n '_replace':_replace,\n '__repr__':__repr__,\n '_asdict':_asdict,\n '__getnewargs__':__getnewargs__,\n }\n for index,name in enumerate(field_names):\n  doc=_sys.intern(f'Alias for field number {index}')\n  class_namespace[name]=_tuplegetter(index,doc)\n  \n result=type(typename,(tuple,),class_namespace)\n \n \n \n \n \n \n if module is None :\n  try :\n   module=_sys._getframe(1).f_globals.get('__name__','__main__')\n  except (AttributeError,ValueError):\n   pass\n if module is not None :\n  result.__module__=module\n  \n return result\n \n \n \n \n \n \ndef _count_elements(mapping,iterable):\n ''\n mapping_get=mapping.get\n for elem in iterable:\n  mapping[elem]=mapping_get(elem,0)+1\n  \ntry :\n from _collections import _count_elements\nexcept ImportError:\n pass\n \nclass Counter(dict):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n def __init__(self,iterable=None ,/,**kwds):\n  ''\n\n\n\n\n\n\n\n\n  \n  super().__init__()\n  self.update(iterable,**kwds)\n  \n def __missing__(self,key):\n  ''\n  \n  return 0\n  \n def most_common(self,n=None ):\n  ''\n\n\n\n\n\n  \n  \n  if n is None :\n   return sorted(self.items(),key=_itemgetter(1),reverse=True )\n  return _heapq.nlargest(n,self.items(),key=_itemgetter(1))\n  \n def elements(self):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  \n  return _chain.from_iterable(_starmap(_repeat,self.items()))\n  \n  \n  \n @classmethod\n def fromkeys(cls,iterable,v=None ):\n \n \n \n \n \n \n \n  raise NotImplementedError(\n  'Counter.fromkeys() is undefined.  Use Counter(iterable) instead.')\n  \n def update(self,iterable=None ,/,**kwds):\n  ''\n\n\n\n\n\n\n\n\n\n\n  \n  \n  \n  \n  \n  \n  \n  \n  if iterable is not None :\n   if isinstance(iterable,_collections_abc.Mapping):\n    if self:\n     self_get=self.get\n     for elem,count in iterable.items():\n      self[elem]=count+self_get(elem,0)\n    else :\n    \n     super().update(iterable)\n   else :\n    _count_elements(self,iterable)\n  if kwds:\n   self.update(kwds)\n   \n def subtract(self,iterable=None ,/,**kwds):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  if iterable is not None :\n   self_get=self.get\n   if isinstance(iterable,_collections_abc.Mapping):\n    for elem,count in iterable.items():\n     self[elem]=self_get(elem,0)-count\n   else :\n    for elem in iterable:\n     self[elem]=self_get(elem,0)-1\n  if kwds:\n   self.subtract(kwds)\n   \n def copy(self):\n  ''\n  return self.__class__(self)\n  \n def __reduce__(self):\n  return self.__class__,(dict(self),)\n  \n def __delitem__(self,elem):\n  ''\n  if elem in self:\n   super().__delitem__(elem)\n   \n def __repr__(self):\n  if not self:\n   return f'{self.__class__.__name__}()'\n  try :\n  \n   d=dict(self.most_common())\n  except TypeError:\n  \n   d=dict(self)\n  return f'{self.__class__.__name__}({d!r})'\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n def __add__(self,other):\n  ''\n\n\n\n\n  \n  if not isinstance(other,Counter):\n   return NotImplemented\n  result=Counter()\n  for elem,count in self.items():\n   newcount=count+other[elem]\n   if newcount >0:\n    result[elem]=newcount\n  for elem,count in other.items():\n   if elem not in self and count >0:\n    result[elem]=count\n  return result\n  \n def __sub__(self,other):\n  ''\n\n\n\n\n  \n  if not isinstance(other,Counter):\n   return NotImplemented\n  result=Counter()\n  for elem,count in self.items():\n   newcount=count -other[elem]\n   if newcount >0:\n    result[elem]=newcount\n  for elem,count in other.items():\n   if elem not in self and count <0:\n    result[elem]=0 -count\n  return result\n  \n def __or__(self,other):\n  ''\n\n\n\n\n  \n  if not isinstance(other,Counter):\n   return NotImplemented\n  result=Counter()\n  for elem,count in self.items():\n   other_count=other[elem]\n   newcount=other_count if count <other_count else count\n   if newcount >0:\n    result[elem]=newcount\n  for elem,count in other.items():\n   if elem not in self and count >0:\n    result[elem]=count\n  return result\n  \n def __and__(self,other):\n  ''\n\n\n\n\n  \n  if not isinstance(other,Counter):\n   return NotImplemented\n  result=Counter()\n  for elem,count in self.items():\n   other_count=other[elem]\n   newcount=count if count <other_count else other_count\n   if newcount >0:\n    result[elem]=newcount\n  return result\n  \n def __pos__(self):\n  ''\n  result=Counter()\n  for elem,count in self.items():\n   if count >0:\n    result[elem]=count\n  return result\n  \n def __neg__(self):\n  ''\n\n\n  \n  result=Counter()\n  for elem,count in self.items():\n   if count <0:\n    result[elem]=0 -count\n  return result\n  \n def _keep_positive(self):\n  ''\n  nonpositive=[elem for elem,count in self.items()if not count >0]\n  for elem in nonpositive:\n   del self[elem]\n  return self\n  \n def __iadd__(self,other):\n  ''\n\n\n\n\n\n\n  \n  for elem,count in other.items():\n   self[elem]+=count\n  return self._keep_positive()\n  \n def __isub__(self,other):\n  ''\n\n\n\n\n\n\n  \n  for elem,count in other.items():\n   self[elem]-=count\n  return self._keep_positive()\n  \n def __ior__(self,other):\n  ''\n\n\n\n\n\n\n  \n  for elem,other_count in other.items():\n   count=self[elem]\n   if other_count >count:\n    self[elem]=other_count\n  return self._keep_positive()\n  \n def __iand__(self,other):\n  ''\n\n\n\n\n\n\n  \n  for elem,count in self.items():\n   other_count=other[elem]\n   if other_count <count:\n    self[elem]=other_count\n  return self._keep_positive()\n  \n  \n  \n  \n  \n  \nclass ChainMap(_collections_abc.MutableMapping):\n ''\n\n\n\n\n\n\n\n\n\n\n \n \n def __init__(self,*maps):\n  ''\n\n\n  \n  self.maps=list(maps)or [{}]\n  \n def __missing__(self,key):\n  raise KeyError(key)\n  \n def __getitem__(self,key):\n  for mapping in self.maps:\n   try :\n    return mapping[key]\n   except KeyError:\n    pass\n  return self.__missing__(key)\n  \n def get(self,key,default=None ):\n  return self[key]if key in self else default\n  \n def __len__(self):\n  return len(set().union(*self.maps))\n  \n def __iter__(self):\n  d={}\n  for mapping in reversed(self.maps):\n   d.update(mapping)\n  return iter(d)\n  \n def __contains__(self,key):\n  return any(key in m for m in self.maps)\n  \n def __bool__(self):\n  return any(self.maps)\n  \n @_recursive_repr()\n def __repr__(self):\n  return f'{self.__class__.__name__}({\", \".join(map(repr, self.maps))})'\n  \n @classmethod\n def fromkeys(cls,iterable,*args):\n  ''\n  return cls(dict.fromkeys(iterable,*args))\n  \n def copy(self):\n  ''\n  return self.__class__(self.maps[0].copy(),*self.maps[1:])\n  \n __copy__=copy\n \n def new_child(self,m=None ):\n  ''\n\n  \n  if m is None :\n   m={}\n  return self.__class__(m,*self.maps)\n  \n @property\n def parents(self):\n  ''\n  return self.__class__(*self.maps[1:])\n  \n def __setitem__(self,key,value):\n  self.maps[0][key]=value\n  \n def __delitem__(self,key):\n  try :\n   del self.maps[0][key]\n  except KeyError:\n   raise KeyError(f'Key not found in the first mapping: {key!r}')\n   \n def popitem(self):\n  ''\n  try :\n   return self.maps[0].popitem()\n  except KeyError:\n   raise KeyError('No keys found in the first mapping.')\n   \n def pop(self,key,*args):\n  ''\n  try :\n   return self.maps[0].pop(key,*args)\n  except KeyError:\n   raise KeyError(f'Key not found in the first mapping: {key!r}')\n   \n def clear(self):\n  ''\n  self.maps[0].clear()\n  \n def __ior__(self,other):\n  self.maps[0].update(other)\n  return self\n  \n def __or__(self,other):\n  if not isinstance(other,_collections_abc.Mapping):\n   return NotImplemented\n  m=self.copy()\n  m.maps[0].update(other)\n  return m\n  \n def __ror__(self,other):\n  if not isinstance(other,_collections_abc.Mapping):\n   return NotImplemented\n  m=dict(other)\n  for child in reversed(self.maps):\n   m.update(child)\n  return self.__class__(m)\n  \n  \n  \n  \n  \n  \nclass UserDict(_collections_abc.MutableMapping):\n\n\n def __init__(self,dict=None ,/,**kwargs):\n  self.data={}\n  if dict is not None :\n   self.update(dict)\n  if kwargs:\n   self.update(kwargs)\n   \n def __len__(self):\n  return len(self.data)\n  \n def __getitem__(self,key):\n  if key in self.data:\n   return self.data[key]\n  if hasattr(self.__class__,\"__missing__\"):\n   return self.__class__.__missing__(self,key)\n  raise KeyError(key)\n  \n def __setitem__(self,key,item):\n  self.data[key]=item\n  \n def __delitem__(self,key):\n  del self.data[key]\n  \n def __iter__(self):\n  return iter(self.data)\n  \n  \n def __contains__(self,key):\n  return key in self.data\n  \n  \n def __repr__(self):\n  return repr(self.data)\n  \n def __or__(self,other):\n  if isinstance(other,UserDict):\n   return self.__class__(self.data |other.data)\n  if isinstance(other,dict):\n   return self.__class__(self.data |other)\n  return NotImplemented\n  \n def __ror__(self,other):\n  if isinstance(other,UserDict):\n   return self.__class__(other.data |self.data)\n  if isinstance(other,dict):\n   return self.__class__(other |self.data)\n  return NotImplemented\n  \n def __ior__(self,other):\n  if isinstance(other,UserDict):\n   self.data |=other.data\n  else :\n   self.data |=other\n  return self\n  \n def __copy__(self):\n  inst=self.__class__.__new__(self.__class__)\n  inst.__dict__.update(self.__dict__)\n  \n  inst.__dict__[\"data\"]=self.__dict__[\"data\"].copy()\n  return inst\n  \n def copy(self):\n  if self.__class__ is UserDict:\n   return UserDict(self.data.copy())\n  import copy\n  data=self.data\n  try :\n   self.data={}\n   c=copy.copy(self)\n  finally :\n   self.data=data\n  c.update(self)\n  return c\n  \n @classmethod\n def fromkeys(cls,iterable,value=None ):\n  d=cls()\n  for key in iterable:\n   d[key]=value\n  return d\n  \n  \n  \n  \n  \n  \nclass UserList(_collections_abc.MutableSequence):\n ''\n \n def __init__(self,initlist=None ):\n  self.data=[]\n  if initlist is not None :\n  \n   if type(initlist)==type(self.data):\n    self.data[:]=initlist\n   elif isinstance(initlist,UserList):\n    self.data[:]=initlist.data[:]\n   else :\n    self.data=list(initlist)\n    \n def __repr__(self):\n  return repr(self.data)\n  \n def __lt__(self,other):\n  return self.data <self.__cast(other)\n  \n def __le__(self,other):\n  return self.data <=self.__cast(other)\n  \n def __eq__(self,other):\n  return self.data ==self.__cast(other)\n  \n def __gt__(self,other):\n  return self.data >self.__cast(other)\n  \n def __ge__(self,other):\n  return self.data >=self.__cast(other)\n  \n def __cast(self,other):\n  return other.data if isinstance(other,UserList)else other\n  \n def __contains__(self,item):\n  return item in self.data\n  \n def __len__(self):\n  return len(self.data)\n  \n def __getitem__(self,i):\n  if isinstance(i,slice):\n   return self.__class__(self.data[i])\n  else :\n   return self.data[i]\n   \n def __setitem__(self,i,item):\n  self.data[i]=item\n  \n def __delitem__(self,i):\n  del self.data[i]\n  \n def __add__(self,other):\n  if isinstance(other,UserList):\n   return self.__class__(self.data+other.data)\n  elif isinstance(other,type(self.data)):\n   return self.__class__(self.data+other)\n  return self.__class__(self.data+list(other))\n  \n def __radd__(self,other):\n  if isinstance(other,UserList):\n   return self.__class__(other.data+self.data)\n  elif isinstance(other,type(self.data)):\n   return self.__class__(other+self.data)\n  return self.__class__(list(other)+self.data)\n  \n def __iadd__(self,other):\n  if isinstance(other,UserList):\n   self.data +=other.data\n  elif isinstance(other,type(self.data)):\n   self.data +=other\n  else :\n   self.data +=list(other)\n  return self\n  \n def __mul__(self,n):\n  return self.__class__(self.data *n)\n  \n __rmul__=__mul__\n \n def __imul__(self,n):\n  self.data *=n\n  return self\n  \n def __copy__(self):\n  inst=self.__class__.__new__(self.__class__)\n  inst.__dict__.update(self.__dict__)\n  \n  inst.__dict__[\"data\"]=self.__dict__[\"data\"][:]\n  return inst\n  \n def append(self,item):\n  self.data.append(item)\n  \n def insert(self,i,item):\n  self.data.insert(i,item)\n  \n def pop(self,i=-1):\n  return self.data.pop(i)\n  \n def remove(self,item):\n  self.data.remove(item)\n  \n def clear(self):\n  self.data.clear()\n  \n def copy(self):\n  return self.__class__(self)\n  \n def count(self,item):\n  return self.data.count(item)\n  \n def index(self,item,*args):\n  return self.data.index(item,*args)\n  \n def reverse(self):\n  self.data.reverse()\n  \n def sort(self,/,*args,**kwds):\n  self.data.sort(*args,**kwds)\n  \n def extend(self,other):\n  if isinstance(other,UserList):\n   self.data.extend(other.data)\n  else :\n   self.data.extend(other)\n   \n   \n   \n   \n   \n   \nclass UserString(_collections_abc.Sequence):\n\n def __init__(self,seq):\n  if isinstance(seq,str):\n   self.data=seq\n  elif isinstance(seq,UserString):\n   self.data=seq.data[:]\n  else :\n   self.data=str(seq)\n   \n def __str__(self):\n  return str(self.data)\n  \n def __repr__(self):\n  return repr(self.data)\n  \n def __int__(self):\n  return int(self.data)\n  \n def __float__(self):\n  return float(self.data)\n  \n def __complex__(self):\n  return complex(self.data)\n  \n def __hash__(self):\n  return hash(self.data)\n  \n def __getnewargs__(self):\n  return (self.data[:],)\n  \n def __eq__(self,string):\n  if isinstance(string,UserString):\n   return self.data ==string.data\n  return self.data ==string\n  \n def __lt__(self,string):\n  if isinstance(string,UserString):\n   return self.data <string.data\n  return self.data <string\n  \n def __le__(self,string):\n  if isinstance(string,UserString):\n   return self.data <=string.data\n  return self.data <=string\n  \n def __gt__(self,string):\n  if isinstance(string,UserString):\n   return self.data >string.data\n  return self.data >string\n  \n def __ge__(self,string):\n  if isinstance(string,UserString):\n   return self.data >=string.data\n  return self.data >=string\n  \n def __contains__(self,char):\n  if isinstance(char,UserString):\n   char=char.data\n  return char in self.data\n  \n def __len__(self):\n  return len(self.data)\n  \n def __getitem__(self,index):\n  return self.__class__(self.data[index])\n  \n def __add__(self,other):\n  if isinstance(other,UserString):\n   return self.__class__(self.data+other.data)\n  elif isinstance(other,str):\n   return self.__class__(self.data+other)\n  return self.__class__(self.data+str(other))\n  \n def __radd__(self,other):\n  if isinstance(other,str):\n   return self.__class__(other+self.data)\n  return self.__class__(str(other)+self.data)\n  \n def __mul__(self,n):\n  return self.__class__(self.data *n)\n  \n __rmul__=__mul__\n \n def __mod__(self,args):\n  return self.__class__(self.data %args)\n  \n def __rmod__(self,template):\n  return self.__class__(str(template)%self)\n  \n  \n def capitalize(self):\n  return self.__class__(self.data.capitalize())\n  \n def casefold(self):\n  return self.__class__(self.data.casefold())\n  \n def center(self,width,*args):\n  return self.__class__(self.data.center(width,*args))\n  \n def count(self,sub,start=0,end=_sys.maxsize):\n  if isinstance(sub,UserString):\n   sub=sub.data\n  return self.data.count(sub,start,end)\n  \n def removeprefix(self,prefix,/):\n  if isinstance(prefix,UserString):\n   prefix=prefix.data\n  return self.__class__(self.data.removeprefix(prefix))\n  \n def removesuffix(self,suffix,/):\n  if isinstance(suffix,UserString):\n   suffix=suffix.data\n  return self.__class__(self.data.removesuffix(suffix))\n  \n def encode(self,encoding='utf-8',errors='strict'):\n  encoding='utf-8'if encoding is None else encoding\n  errors='strict'if errors is None else errors\n  return self.data.encode(encoding,errors)\n  \n def endswith(self,suffix,start=0,end=_sys.maxsize):\n  return self.data.endswith(suffix,start,end)\n  \n def expandtabs(self,tabsize=8):\n  return self.__class__(self.data.expandtabs(tabsize))\n  \n def find(self,sub,start=0,end=_sys.maxsize):\n  if isinstance(sub,UserString):\n   sub=sub.data\n  return self.data.find(sub,start,end)\n  \n def format(self,/,*args,**kwds):\n  return self.data.format(*args,**kwds)\n  \n def format_map(self,mapping):\n  return self.data.format_map(mapping)\n  \n def index(self,sub,start=0,end=_sys.maxsize):\n  return self.data.index(sub,start,end)\n  \n def isalpha(self):\n  return self.data.isalpha()\n  \n def isalnum(self):\n  return self.data.isalnum()\n  \n def isascii(self):\n  return self.data.isascii()\n  \n def isdecimal(self):\n  return self.data.isdecimal()\n  \n def isdigit(self):\n  return self.data.isdigit()\n  \n def isidentifier(self):\n  return self.data.isidentifier()\n  \n def islower(self):\n  return self.data.islower()\n  \n def isnumeric(self):\n  return self.data.isnumeric()\n  \n def isprintable(self):\n  return self.data.isprintable()\n  \n def isspace(self):\n  return self.data.isspace()\n  \n def istitle(self):\n  return self.data.istitle()\n  \n def isupper(self):\n  return self.data.isupper()\n  \n def join(self,seq):\n  return self.data.join(seq)\n  \n def ljust(self,width,*args):\n  return self.__class__(self.data.ljust(width,*args))\n  \n def lower(self):\n  return self.__class__(self.data.lower())\n  \n def lstrip(self,chars=None ):\n  return self.__class__(self.data.lstrip(chars))\n  \n maketrans=str.maketrans\n \n def partition(self,sep):\n  return self.data.partition(sep)\n  \n def replace(self,old,new,maxsplit=-1):\n  if isinstance(old,UserString):\n   old=old.data\n  if isinstance(new,UserString):\n   new=new.data\n  return self.__class__(self.data.replace(old,new,maxsplit))\n  \n def rfind(self,sub,start=0,end=_sys.maxsize):\n  if isinstance(sub,UserString):\n   sub=sub.data\n  return self.data.rfind(sub,start,end)\n  \n def rindex(self,sub,start=0,end=_sys.maxsize):\n  return self.data.rindex(sub,start,end)\n  \n def rjust(self,width,*args):\n  return self.__class__(self.data.rjust(width,*args))\n  \n def rpartition(self,sep):\n  return self.data.rpartition(sep)\n  \n def rstrip(self,chars=None ):\n  return self.__class__(self.data.rstrip(chars))\n  \n def split(self,sep=None ,maxsplit=-1):\n  return self.data.split(sep,maxsplit)\n  \n def rsplit(self,sep=None ,maxsplit=-1):\n  return self.data.rsplit(sep,maxsplit)\n  \n def splitlines(self,keepends=False ):\n  return self.data.splitlines(keepends)\n  \n def startswith(self,prefix,start=0,end=_sys.maxsize):\n  return self.data.startswith(prefix,start,end)\n  \n def strip(self,chars=None ):\n  return self.__class__(self.data.strip(chars))\n  \n def swapcase(self):\n  return self.__class__(self.data.swapcase())\n  \n def title(self):\n  return self.__class__(self.data.title())\n  \n def translate(self,*args):\n  return self.__class__(self.data.translate(*args))\n  \n def upper(self):\n  return self.__class__(self.data.upper())\n  \n def zfill(self,width):\n  return self.__class__(self.data.zfill(width))\n", ["_collections", "_collections_abc", "_weakref", "copy", "heapq", "itertools", "keyword", "operator", "reprlib", "sys", "warnings"], 1],
     "concurrent": [".py", "", [], 1],
     "concurrent.futures.process": [".py", "\n\n\n\"\"\"Implements ProcessPoolExecutor.\n\nThe follow diagram and text describe the data-flow through the system:\n\n|======================= In-process =====================|== Out-of-process ==|\n\n+----------+     +----------+       +--------+     +-----------+    +---------+\n|          |  => | Work Ids |    => |        |  => | Call Q    | => |         |\n|          |     +----------+       |        |     +-----------+    |         |\n|          |     | ...      |       |        |     | ...       |    |         |\n|          |     | 6        |       |        |     | 5, call() |    |         |\n|          |     | 7        |       |        |     | ...       |    |         |\n| Process  |     | ...      |       | Local  |     +-----------+    | Process |\n|  Pool    |     +----------+       | Worker |                      |  #1..n  |\n| Executor |                        | Thread |                      |         |\n|          |     +----------- +     |        |     +-----------+    |         |\n|          | <=> | Work Items | <=> |        | <=  | Result Q  | <= |         |\n|          |     +------------+     |        |     +-----------+    |         |\n|          |     | 6: call()  |     |        |     | ...       |    |         |\n|          |     |    future  |     |        |     | 4, result |    |         |\n|          |     | ...        |     |        |     | 3, except |    |         |\n+----------+     +------------+     +--------+     +-----------+    +---------+\n\nExecutor.submit() called:\n- creates a uniquely numbered _WorkItem and adds it to the \"Work Items\" dict\n- adds the id of the _WorkItem to the \"Work Ids\" queue\n\nLocal worker thread:\n- reads work ids from the \"Work Ids\" queue and looks up the corresponding\n  WorkItem from the \"Work Items\" dict: if the work item has been cancelled then\n  it is simply removed from the dict, otherwise it is repackaged as a\n  _CallItem and put in the \"Call Q\". New _CallItems are put in the \"Call Q\"\n  until \"Call Q\" is full. NOTE: the size of the \"Call Q\" is kept small because\n  calls placed in the \"Call Q\" can no longer be cancelled with Future.cancel().\n- reads _ResultItems from \"Result Q\", updates the future stored in the\n  \"Work Items\" dict and deletes the dict entry\n\nProcess #1..n:\n- reads _CallItems from \"Call Q\", executes the calls, and puts the resulting\n  _ResultItems in \"Result Q\"\n\"\"\"\n\n__author__='Brian Quinlan (brian@sweetapp.com)'\n\nimport atexit\nimport os\nfrom concurrent.futures import _base\nimport queue\nfrom queue import Full\nimport multiprocessing\nfrom multiprocessing import SimpleQueue\nfrom multiprocessing.connection import wait\nimport threading\nimport weakref\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n_threads_queues=weakref.WeakKeyDictionary()\n_shutdown=False\n\ndef _python_exit():\n global _shutdown\n _shutdown=True\n items=list(_threads_queues.items())\n for t,q in items:\n  q.put(None )\n for t,q in items:\n  t.join()\n  \n  \n  \n  \n  \nEXTRA_QUEUED_CALLS=1\n\nclass _WorkItem(object):\n def __init__(self,future,fn,args,kwargs):\n  self.future=future\n  self.fn=fn\n  self.args=args\n  self.kwargs=kwargs\n  \nclass _ResultItem(object):\n def __init__(self,work_id,exception=None ,result=None ):\n  self.work_id=work_id\n  self.exception=exception\n  self.result=result\n  \nclass _CallItem(object):\n def __init__(self,work_id,fn,args,kwargs):\n  self.work_id=work_id\n  self.fn=fn\n  self.args=args\n  self.kwargs=kwargs\n  \ndef _process_worker(call_queue,result_queue):\n ''\n\n\n\n\n\n\n\n\n\n\n \n while True :\n  call_item=call_queue.get(block=True )\n  if call_item is None :\n  \n   result_queue.put(os.getpid())\n   return\n  try :\n   r=call_item.fn(*call_item.args,**call_item.kwargs)\n  except BaseException as e:\n   result_queue.put(_ResultItem(call_item.work_id,\n   exception=e))\n  else :\n   result_queue.put(_ResultItem(call_item.work_id,\n   result=r))\n   \ndef _add_call_item_to_queue(pending_work_items,\nwork_ids,\ncall_queue):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n \n while True :\n  if call_queue.full():\n   return\n  try :\n   work_id=work_ids.get(block=False )\n  except queue.Empty:\n   return\n  else :\n   work_item=pending_work_items[work_id]\n   \n   if work_item.future.set_running_or_notify_cancel():\n    call_queue.put(_CallItem(work_id,\n    work_item.fn,\n    work_item.args,\n    work_item.kwargs),\n    block=True )\n   else :\n    del pending_work_items[work_id]\n    continue\n    \ndef _queue_management_worker(executor_reference,\nprocesses,\npending_work_items,\nwork_ids_queue,\ncall_queue,\nresult_queue):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n executor=None\n \n def shutting_down():\n  return _shutdown or executor is None or executor._shutdown_thread\n  \n def shutdown_worker():\n \n  nb_children_alive=sum(p.is_alive()for p in processes.values())\n  for i in range(0,nb_children_alive):\n   call_queue.put_nowait(None )\n   \n  call_queue.close()\n  \n  \n  for p in processes.values():\n   p.join()\n   \n reader=result_queue._reader\n \n while True :\n  _add_call_item_to_queue(pending_work_items,\n  work_ids_queue,\n  call_queue)\n  \n  sentinels=[p.sentinel for p in processes.values()]\n  assert sentinels\n  ready=wait([reader]+sentinels)\n  if reader in ready:\n   result_item=reader.recv()\n  else :\n  \n   executor=executor_reference()\n   if executor is not None :\n    executor._broken=True\n    executor._shutdown_thread=True\n    executor=None\n    \n   for work_id,work_item in pending_work_items.items():\n    work_item.future.set_exception(\n    BrokenProcessPool(\n    \"A process in the process pool was \"\n    \"terminated abruptly while the future was \"\n    \"running or pending.\"\n    ))\n    \n    del work_item\n   pending_work_items.clear()\n   \n   \n   for p in processes.values():\n    p.terminate()\n   shutdown_worker()\n   return\n  if isinstance(result_item,int):\n  \n  \n   assert shutting_down()\n   p=processes.pop(result_item)\n   p.join()\n   if not processes:\n    shutdown_worker()\n    return\n  elif result_item is not None :\n   work_item=pending_work_items.pop(result_item.work_id,None )\n   \n   if work_item is not None :\n    if result_item.exception:\n     work_item.future.set_exception(result_item.exception)\n    else :\n     work_item.future.set_result(result_item.result)\n     \n    del work_item\n    \n  executor=executor_reference()\n  \n  \n  \n  \n  if shutting_down():\n   try :\n   \n   \n    if not pending_work_items:\n     shutdown_worker()\n     return\n   except Full:\n   \n   \n    pass\n  executor=None\n  \n_system_limits_checked=False\n_system_limited=None\ndef _check_system_limits():\n global _system_limits_checked,_system_limited\n if _system_limits_checked:\n  if _system_limited:\n   raise NotImplementedError(_system_limited)\n _system_limits_checked=True\n try :\n  nsems_max=os.sysconf(\"SC_SEM_NSEMS_MAX\")\n except (AttributeError,ValueError):\n \n  return\n if nsems_max ==-1:\n \n \n  return\n if nsems_max >=256:\n \n \n  return\n _system_limited=\"system provides too few semaphores (%d available, 256 necessary)\"%nsems_max\n raise NotImplementedError(_system_limited)\n \n \nclass BrokenProcessPool(RuntimeError):\n ''\n\n\n \n \n \nclass ProcessPoolExecutor(_base.Executor):\n def __init__(self,max_workers=None ):\n  ''\n\n\n\n\n\n  \n  _check_system_limits()\n  \n  if max_workers is None :\n   self._max_workers=os.cpu_count()or 1\n  else :\n   self._max_workers=max_workers\n   \n   \n   \n   \n  self._call_queue=multiprocessing.Queue(self._max_workers+\n  EXTRA_QUEUED_CALLS)\n  \n  \n  \n  self._call_queue._ignore_epipe=True\n  self._result_queue=SimpleQueue()\n  self._work_ids=queue.Queue()\n  self._queue_management_thread=None\n  \n  self._processes={}\n  \n  \n  self._shutdown_thread=False\n  self._shutdown_lock=threading.Lock()\n  self._broken=False\n  self._queue_count=0\n  self._pending_work_items={}\n  \n def _start_queue_management_thread(self):\n \n \n  def weakref_cb(_,q=self._result_queue):\n   q.put(None )\n  if self._queue_management_thread is None :\n  \n   self._adjust_process_count()\n   self._queue_management_thread=threading.Thread(\n   target=_queue_management_worker,\n   args=(weakref.ref(self,weakref_cb),\n   self._processes,\n   self._pending_work_items,\n   self._work_ids,\n   self._call_queue,\n   self._result_queue))\n   self._queue_management_thread.daemon=True\n   self._queue_management_thread.start()\n   _threads_queues[self._queue_management_thread]=self._result_queue\n   \n def _adjust_process_count(self):\n  for _ in range(len(self._processes),self._max_workers):\n   p=multiprocessing.Process(\n   target=_process_worker,\n   args=(self._call_queue,\n   self._result_queue))\n   p.start()\n   self._processes[p.pid]=p\n   \n def submit(self,fn,*args,**kwargs):\n  with self._shutdown_lock:\n   if self._broken:\n    raise BrokenProcessPool('A child process terminated '\n    'abruptly, the process pool is not usable anymore')\n   if self._shutdown_thread:\n    raise RuntimeError('cannot schedule new futures after shutdown')\n    \n   f=_base.Future()\n   w=_WorkItem(f,fn,args,kwargs)\n   \n   self._pending_work_items[self._queue_count]=w\n   self._work_ids.put(self._queue_count)\n   self._queue_count +=1\n   \n   self._result_queue.put(None )\n   \n   self._start_queue_management_thread()\n   return f\n submit.__doc__=_base.Executor.submit.__doc__\n \n def shutdown(self,wait=True ):\n  with self._shutdown_lock:\n   self._shutdown_thread=True\n  if self._queue_management_thread:\n  \n   self._result_queue.put(None )\n   if wait:\n    self._queue_management_thread.join()\n    \n    \n  self._queue_management_thread=None\n  self._call_queue=None\n  self._result_queue=None\n  self._processes=None\n shutdown.__doc__=_base.Executor.shutdown.__doc__\n \natexit.register(_python_exit)\n", ["atexit", "concurrent.futures", "concurrent.futures._base", "multiprocessing", "multiprocessing.connection", "os", "queue", "threading", "weakref"]],
     "concurrent.futures.thread": [".py", "\n\n\n\"\"\"Implements ThreadPoolExecutor.\"\"\"\n\n__author__='Brian Quinlan (brian@sweetapp.com)'\n\nimport atexit\nfrom concurrent.futures import _base\nimport queue\nimport threading\nimport weakref\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n_threads_queues=weakref.WeakKeyDictionary()\n_shutdown=False\n\ndef _python_exit():\n global _shutdown\n _shutdown=True\n items=list(_threads_queues.items())\n for t,q in items:\n  q.put(None )\n for t,q in items:\n  t.join()\n  \natexit.register(_python_exit)\n\nclass _WorkItem(object):\n def __init__(self,future,fn,args,kwargs):\n  self.future=future\n  self.fn=fn\n  self.args=args\n  self.kwargs=kwargs\n  \n def run(self):\n  if not self.future.set_running_or_notify_cancel():\n   return\n   \n  try :\n   result=self.fn(*self.args,**self.kwargs)\n  except BaseException as e:\n   self.future.set_exception(e)\n  else :\n   self.future.set_result(result)\n   \ndef _worker(executor_reference,work_queue):\n try :\n  while True :\n   work_item=work_queue.get(block=True )\n   if work_item is not None :\n    work_item.run()\n    \n    del work_item\n    continue\n   executor=executor_reference()\n   \n   \n   \n   \n   if _shutdown or executor is None or executor._shutdown:\n   \n    work_queue.put(None )\n    return\n   del executor\n except BaseException:\n  _base.LOGGER.critical('Exception in worker',exc_info=True )\n  \nclass ThreadPoolExecutor(_base.Executor):\n def __init__(self,max_workers):\n  ''\n\n\n\n\n  \n  self._max_workers=max_workers\n  self._work_queue=queue.Queue()\n  self._threads=set()\n  self._shutdown=False\n  self._shutdown_lock=threading.Lock()\n  \n def submit(self,fn,*args,**kwargs):\n  with self._shutdown_lock:\n   if self._shutdown:\n    raise RuntimeError('cannot schedule new futures after shutdown')\n    \n   f=_base.Future()\n   w=_WorkItem(f,fn,args,kwargs)\n   \n   self._work_queue.put(w)\n   self._adjust_thread_count()\n   return f\n submit.__doc__=_base.Executor.submit.__doc__\n \n def _adjust_thread_count(self):\n \n \n  def weakref_cb(_,q=self._work_queue):\n   q.put(None )\n   \n   \n  if len(self._threads)<self._max_workers:\n   t=threading.Thread(target=_worker,\n   args=(weakref.ref(self,weakref_cb),\n   self._work_queue))\n   t.daemon=True\n   t.start()\n   self._threads.add(t)\n   _threads_queues[t]=self._work_queue\n   \n def shutdown(self,wait=True ):\n  with self._shutdown_lock:\n   self._shutdown=True\n   self._work_queue.put(None )\n  if wait:\n   for t in self._threads:\n    t.join()\n shutdown.__doc__=_base.Executor.shutdown.__doc__\n", ["atexit", "concurrent.futures", "concurrent.futures._base", "queue", "threading", "weakref"]],
@@ -322,16 +323,16 @@
     "html.entities": [".py", "''\n\n__all__=['html5','name2codepoint','codepoint2name','entitydefs']\n\n\n\nname2codepoint={\n'AElig':0x00c6,\n'Aacute':0x00c1,\n'Acirc':0x00c2,\n'Agrave':0x00c0,\n'Alpha':0x0391,\n'Aring':0x00c5,\n'Atilde':0x00c3,\n'Auml':0x00c4,\n'Beta':0x0392,\n'Ccedil':0x00c7,\n'Chi':0x03a7,\n'Dagger':0x2021,\n'Delta':0x0394,\n'ETH':0x00d0,\n'Eacute':0x00c9,\n'Ecirc':0x00ca,\n'Egrave':0x00c8,\n'Epsilon':0x0395,\n'Eta':0x0397,\n'Euml':0x00cb,\n'Gamma':0x0393,\n'Iacute':0x00cd,\n'Icirc':0x00ce,\n'Igrave':0x00cc,\n'Iota':0x0399,\n'Iuml':0x00cf,\n'Kappa':0x039a,\n'Lambda':0x039b,\n'Mu':0x039c,\n'Ntilde':0x00d1,\n'Nu':0x039d,\n'OElig':0x0152,\n'Oacute':0x00d3,\n'Ocirc':0x00d4,\n'Ograve':0x00d2,\n'Omega':0x03a9,\n'Omicron':0x039f,\n'Oslash':0x00d8,\n'Otilde':0x00d5,\n'Ouml':0x00d6,\n'Phi':0x03a6,\n'Pi':0x03a0,\n'Prime':0x2033,\n'Psi':0x03a8,\n'Rho':0x03a1,\n'Scaron':0x0160,\n'Sigma':0x03a3,\n'THORN':0x00de,\n'Tau':0x03a4,\n'Theta':0x0398,\n'Uacute':0x00da,\n'Ucirc':0x00db,\n'Ugrave':0x00d9,\n'Upsilon':0x03a5,\n'Uuml':0x00dc,\n'Xi':0x039e,\n'Yacute':0x00dd,\n'Yuml':0x0178,\n'Zeta':0x0396,\n'aacute':0x00e1,\n'acirc':0x00e2,\n'acute':0x00b4,\n'aelig':0x00e6,\n'agrave':0x00e0,\n'alefsym':0x2135,\n'alpha':0x03b1,\n'amp':0x0026,\n'and':0x2227,\n'ang':0x2220,\n'aring':0x00e5,\n'asymp':0x2248,\n'atilde':0x00e3,\n'auml':0x00e4,\n'bdquo':0x201e,\n'beta':0x03b2,\n'brvbar':0x00a6,\n'bull':0x2022,\n'cap':0x2229,\n'ccedil':0x00e7,\n'cedil':0x00b8,\n'cent':0x00a2,\n'chi':0x03c7,\n'circ':0x02c6,\n'clubs':0x2663,\n'cong':0x2245,\n'copy':0x00a9,\n'crarr':0x21b5,\n'cup':0x222a,\n'curren':0x00a4,\n'dArr':0x21d3,\n'dagger':0x2020,\n'darr':0x2193,\n'deg':0x00b0,\n'delta':0x03b4,\n'diams':0x2666,\n'divide':0x00f7,\n'eacute':0x00e9,\n'ecirc':0x00ea,\n'egrave':0x00e8,\n'empty':0x2205,\n'emsp':0x2003,\n'ensp':0x2002,\n'epsilon':0x03b5,\n'equiv':0x2261,\n'eta':0x03b7,\n'eth':0x00f0,\n'euml':0x00eb,\n'euro':0x20ac,\n'exist':0x2203,\n'fnof':0x0192,\n'forall':0x2200,\n'frac12':0x00bd,\n'frac14':0x00bc,\n'frac34':0x00be,\n'frasl':0x2044,\n'gamma':0x03b3,\n'ge':0x2265,\n'gt':0x003e,\n'hArr':0x21d4,\n'harr':0x2194,\n'hearts':0x2665,\n'hellip':0x2026,\n'iacute':0x00ed,\n'icirc':0x00ee,\n'iexcl':0x00a1,\n'igrave':0x00ec,\n'image':0x2111,\n'infin':0x221e,\n'int':0x222b,\n'iota':0x03b9,\n'iquest':0x00bf,\n'isin':0x2208,\n'iuml':0x00ef,\n'kappa':0x03ba,\n'lArr':0x21d0,\n'lambda':0x03bb,\n'lang':0x2329,\n'laquo':0x00ab,\n'larr':0x2190,\n'lceil':0x2308,\n'ldquo':0x201c,\n'le':0x2264,\n'lfloor':0x230a,\n'lowast':0x2217,\n'loz':0x25ca,\n'lrm':0x200e,\n'lsaquo':0x2039,\n'lsquo':0x2018,\n'lt':0x003c,\n'macr':0x00af,\n'mdash':0x2014,\n'micro':0x00b5,\n'middot':0x00b7,\n'minus':0x2212,\n'mu':0x03bc,\n'nabla':0x2207,\n'nbsp':0x00a0,\n'ndash':0x2013,\n'ne':0x2260,\n'ni':0x220b,\n'not':0x00ac,\n'notin':0x2209,\n'nsub':0x2284,\n'ntilde':0x00f1,\n'nu':0x03bd,\n'oacute':0x00f3,\n'ocirc':0x00f4,\n'oelig':0x0153,\n'ograve':0x00f2,\n'oline':0x203e,\n'omega':0x03c9,\n'omicron':0x03bf,\n'oplus':0x2295,\n'or':0x2228,\n'ordf':0x00aa,\n'ordm':0x00ba,\n'oslash':0x00f8,\n'otilde':0x00f5,\n'otimes':0x2297,\n'ouml':0x00f6,\n'para':0x00b6,\n'part':0x2202,\n'permil':0x2030,\n'perp':0x22a5,\n'phi':0x03c6,\n'pi':0x03c0,\n'piv':0x03d6,\n'plusmn':0x00b1,\n'pound':0x00a3,\n'prime':0x2032,\n'prod':0x220f,\n'prop':0x221d,\n'psi':0x03c8,\n'quot':0x0022,\n'rArr':0x21d2,\n'radic':0x221a,\n'rang':0x232a,\n'raquo':0x00bb,\n'rarr':0x2192,\n'rceil':0x2309,\n'rdquo':0x201d,\n'real':0x211c,\n'reg':0x00ae,\n'rfloor':0x230b,\n'rho':0x03c1,\n'rlm':0x200f,\n'rsaquo':0x203a,\n'rsquo':0x2019,\n'sbquo':0x201a,\n'scaron':0x0161,\n'sdot':0x22c5,\n'sect':0x00a7,\n'shy':0x00ad,\n'sigma':0x03c3,\n'sigmaf':0x03c2,\n'sim':0x223c,\n'spades':0x2660,\n'sub':0x2282,\n'sube':0x2286,\n'sum':0x2211,\n'sup':0x2283,\n'sup1':0x00b9,\n'sup2':0x00b2,\n'sup3':0x00b3,\n'supe':0x2287,\n'szlig':0x00df,\n'tau':0x03c4,\n'there4':0x2234,\n'theta':0x03b8,\n'thetasym':0x03d1,\n'thinsp':0x2009,\n'thorn':0x00fe,\n'tilde':0x02dc,\n'times':0x00d7,\n'trade':0x2122,\n'uArr':0x21d1,\n'uacute':0x00fa,\n'uarr':0x2191,\n'ucirc':0x00fb,\n'ugrave':0x00f9,\n'uml':0x00a8,\n'upsih':0x03d2,\n'upsilon':0x03c5,\n'uuml':0x00fc,\n'weierp':0x2118,\n'xi':0x03be,\n'yacute':0x00fd,\n'yen':0x00a5,\n'yuml':0x00ff,\n'zeta':0x03b6,\n'zwj':0x200d,\n'zwnj':0x200c,\n}\n\n\n\nhtml5={\n'Aacute':'\\xc1',\n'aacute':'\\xe1',\n'Aacute;':'\\xc1',\n'aacute;':'\\xe1',\n'Abreve;':'\\u0102',\n'abreve;':'\\u0103',\n'ac;':'\\u223e',\n'acd;':'\\u223f',\n'acE;':'\\u223e\\u0333',\n'Acirc':'\\xc2',\n'acirc':'\\xe2',\n'Acirc;':'\\xc2',\n'acirc;':'\\xe2',\n'acute':'\\xb4',\n'acute;':'\\xb4',\n'Acy;':'\\u0410',\n'acy;':'\\u0430',\n'AElig':'\\xc6',\n'aelig':'\\xe6',\n'AElig;':'\\xc6',\n'aelig;':'\\xe6',\n'af;':'\\u2061',\n'Afr;':'\\U0001d504',\n'afr;':'\\U0001d51e',\n'Agrave':'\\xc0',\n'agrave':'\\xe0',\n'Agrave;':'\\xc0',\n'agrave;':'\\xe0',\n'alefsym;':'\\u2135',\n'aleph;':'\\u2135',\n'Alpha;':'\\u0391',\n'alpha;':'\\u03b1',\n'Amacr;':'\\u0100',\n'amacr;':'\\u0101',\n'amalg;':'\\u2a3f',\n'AMP':'&',\n'amp':'&',\n'AMP;':'&',\n'amp;':'&',\n'And;':'\\u2a53',\n'and;':'\\u2227',\n'andand;':'\\u2a55',\n'andd;':'\\u2a5c',\n'andslope;':'\\u2a58',\n'andv;':'\\u2a5a',\n'ang;':'\\u2220',\n'ange;':'\\u29a4',\n'angle;':'\\u2220',\n'angmsd;':'\\u2221',\n'angmsdaa;':'\\u29a8',\n'angmsdab;':'\\u29a9',\n'angmsdac;':'\\u29aa',\n'angmsdad;':'\\u29ab',\n'angmsdae;':'\\u29ac',\n'angmsdaf;':'\\u29ad',\n'angmsdag;':'\\u29ae',\n'angmsdah;':'\\u29af',\n'angrt;':'\\u221f',\n'angrtvb;':'\\u22be',\n'angrtvbd;':'\\u299d',\n'angsph;':'\\u2222',\n'angst;':'\\xc5',\n'angzarr;':'\\u237c',\n'Aogon;':'\\u0104',\n'aogon;':'\\u0105',\n'Aopf;':'\\U0001d538',\n'aopf;':'\\U0001d552',\n'ap;':'\\u2248',\n'apacir;':'\\u2a6f',\n'apE;':'\\u2a70',\n'ape;':'\\u224a',\n'apid;':'\\u224b',\n'apos;':\"'\",\n'ApplyFunction;':'\\u2061',\n'approx;':'\\u2248',\n'approxeq;':'\\u224a',\n'Aring':'\\xc5',\n'aring':'\\xe5',\n'Aring;':'\\xc5',\n'aring;':'\\xe5',\n'Ascr;':'\\U0001d49c',\n'ascr;':'\\U0001d4b6',\n'Assign;':'\\u2254',\n'ast;':'*',\n'asymp;':'\\u2248',\n'asympeq;':'\\u224d',\n'Atilde':'\\xc3',\n'atilde':'\\xe3',\n'Atilde;':'\\xc3',\n'atilde;':'\\xe3',\n'Auml':'\\xc4',\n'auml':'\\xe4',\n'Auml;':'\\xc4',\n'auml;':'\\xe4',\n'awconint;':'\\u2233',\n'awint;':'\\u2a11',\n'backcong;':'\\u224c',\n'backepsilon;':'\\u03f6',\n'backprime;':'\\u2035',\n'backsim;':'\\u223d',\n'backsimeq;':'\\u22cd',\n'Backslash;':'\\u2216',\n'Barv;':'\\u2ae7',\n'barvee;':'\\u22bd',\n'Barwed;':'\\u2306',\n'barwed;':'\\u2305',\n'barwedge;':'\\u2305',\n'bbrk;':'\\u23b5',\n'bbrktbrk;':'\\u23b6',\n'bcong;':'\\u224c',\n'Bcy;':'\\u0411',\n'bcy;':'\\u0431',\n'bdquo;':'\\u201e',\n'becaus;':'\\u2235',\n'Because;':'\\u2235',\n'because;':'\\u2235',\n'bemptyv;':'\\u29b0',\n'bepsi;':'\\u03f6',\n'bernou;':'\\u212c',\n'Bernoullis;':'\\u212c',\n'Beta;':'\\u0392',\n'beta;':'\\u03b2',\n'beth;':'\\u2136',\n'between;':'\\u226c',\n'Bfr;':'\\U0001d505',\n'bfr;':'\\U0001d51f',\n'bigcap;':'\\u22c2',\n'bigcirc;':'\\u25ef',\n'bigcup;':'\\u22c3',\n'bigodot;':'\\u2a00',\n'bigoplus;':'\\u2a01',\n'bigotimes;':'\\u2a02',\n'bigsqcup;':'\\u2a06',\n'bigstar;':'\\u2605',\n'bigtriangledown;':'\\u25bd',\n'bigtriangleup;':'\\u25b3',\n'biguplus;':'\\u2a04',\n'bigvee;':'\\u22c1',\n'bigwedge;':'\\u22c0',\n'bkarow;':'\\u290d',\n'blacklozenge;':'\\u29eb',\n'blacksquare;':'\\u25aa',\n'blacktriangle;':'\\u25b4',\n'blacktriangledown;':'\\u25be',\n'blacktriangleleft;':'\\u25c2',\n'blacktriangleright;':'\\u25b8',\n'blank;':'\\u2423',\n'blk12;':'\\u2592',\n'blk14;':'\\u2591',\n'blk34;':'\\u2593',\n'block;':'\\u2588',\n'bne;':'=\\u20e5',\n'bnequiv;':'\\u2261\\u20e5',\n'bNot;':'\\u2aed',\n'bnot;':'\\u2310',\n'Bopf;':'\\U0001d539',\n'bopf;':'\\U0001d553',\n'bot;':'\\u22a5',\n'bottom;':'\\u22a5',\n'bowtie;':'\\u22c8',\n'boxbox;':'\\u29c9',\n'boxDL;':'\\u2557',\n'boxDl;':'\\u2556',\n'boxdL;':'\\u2555',\n'boxdl;':'\\u2510',\n'boxDR;':'\\u2554',\n'boxDr;':'\\u2553',\n'boxdR;':'\\u2552',\n'boxdr;':'\\u250c',\n'boxH;':'\\u2550',\n'boxh;':'\\u2500',\n'boxHD;':'\\u2566',\n'boxHd;':'\\u2564',\n'boxhD;':'\\u2565',\n'boxhd;':'\\u252c',\n'boxHU;':'\\u2569',\n'boxHu;':'\\u2567',\n'boxhU;':'\\u2568',\n'boxhu;':'\\u2534',\n'boxminus;':'\\u229f',\n'boxplus;':'\\u229e',\n'boxtimes;':'\\u22a0',\n'boxUL;':'\\u255d',\n'boxUl;':'\\u255c',\n'boxuL;':'\\u255b',\n'boxul;':'\\u2518',\n'boxUR;':'\\u255a',\n'boxUr;':'\\u2559',\n'boxuR;':'\\u2558',\n'boxur;':'\\u2514',\n'boxV;':'\\u2551',\n'boxv;':'\\u2502',\n'boxVH;':'\\u256c',\n'boxVh;':'\\u256b',\n'boxvH;':'\\u256a',\n'boxvh;':'\\u253c',\n'boxVL;':'\\u2563',\n'boxVl;':'\\u2562',\n'boxvL;':'\\u2561',\n'boxvl;':'\\u2524',\n'boxVR;':'\\u2560',\n'boxVr;':'\\u255f',\n'boxvR;':'\\u255e',\n'boxvr;':'\\u251c',\n'bprime;':'\\u2035',\n'Breve;':'\\u02d8',\n'breve;':'\\u02d8',\n'brvbar':'\\xa6',\n'brvbar;':'\\xa6',\n'Bscr;':'\\u212c',\n'bscr;':'\\U0001d4b7',\n'bsemi;':'\\u204f',\n'bsim;':'\\u223d',\n'bsime;':'\\u22cd',\n'bsol;':'\\\\',\n'bsolb;':'\\u29c5',\n'bsolhsub;':'\\u27c8',\n'bull;':'\\u2022',\n'bullet;':'\\u2022',\n'bump;':'\\u224e',\n'bumpE;':'\\u2aae',\n'bumpe;':'\\u224f',\n'Bumpeq;':'\\u224e',\n'bumpeq;':'\\u224f',\n'Cacute;':'\\u0106',\n'cacute;':'\\u0107',\n'Cap;':'\\u22d2',\n'cap;':'\\u2229',\n'capand;':'\\u2a44',\n'capbrcup;':'\\u2a49',\n'capcap;':'\\u2a4b',\n'capcup;':'\\u2a47',\n'capdot;':'\\u2a40',\n'CapitalDifferentialD;':'\\u2145',\n'caps;':'\\u2229\\ufe00',\n'caret;':'\\u2041',\n'caron;':'\\u02c7',\n'Cayleys;':'\\u212d',\n'ccaps;':'\\u2a4d',\n'Ccaron;':'\\u010c',\n'ccaron;':'\\u010d',\n'Ccedil':'\\xc7',\n'ccedil':'\\xe7',\n'Ccedil;':'\\xc7',\n'ccedil;':'\\xe7',\n'Ccirc;':'\\u0108',\n'ccirc;':'\\u0109',\n'Cconint;':'\\u2230',\n'ccups;':'\\u2a4c',\n'ccupssm;':'\\u2a50',\n'Cdot;':'\\u010a',\n'cdot;':'\\u010b',\n'cedil':'\\xb8',\n'cedil;':'\\xb8',\n'Cedilla;':'\\xb8',\n'cemptyv;':'\\u29b2',\n'cent':'\\xa2',\n'cent;':'\\xa2',\n'CenterDot;':'\\xb7',\n'centerdot;':'\\xb7',\n'Cfr;':'\\u212d',\n'cfr;':'\\U0001d520',\n'CHcy;':'\\u0427',\n'chcy;':'\\u0447',\n'check;':'\\u2713',\n'checkmark;':'\\u2713',\n'Chi;':'\\u03a7',\n'chi;':'\\u03c7',\n'cir;':'\\u25cb',\n'circ;':'\\u02c6',\n'circeq;':'\\u2257',\n'circlearrowleft;':'\\u21ba',\n'circlearrowright;':'\\u21bb',\n'circledast;':'\\u229b',\n'circledcirc;':'\\u229a',\n'circleddash;':'\\u229d',\n'CircleDot;':'\\u2299',\n'circledR;':'\\xae',\n'circledS;':'\\u24c8',\n'CircleMinus;':'\\u2296',\n'CirclePlus;':'\\u2295',\n'CircleTimes;':'\\u2297',\n'cirE;':'\\u29c3',\n'cire;':'\\u2257',\n'cirfnint;':'\\u2a10',\n'cirmid;':'\\u2aef',\n'cirscir;':'\\u29c2',\n'ClockwiseContourIntegral;':'\\u2232',\n'CloseCurlyDoubleQuote;':'\\u201d',\n'CloseCurlyQuote;':'\\u2019',\n'clubs;':'\\u2663',\n'clubsuit;':'\\u2663',\n'Colon;':'\\u2237',\n'colon;':':',\n'Colone;':'\\u2a74',\n'colone;':'\\u2254',\n'coloneq;':'\\u2254',\n'comma;':',',\n'commat;':'@',\n'comp;':'\\u2201',\n'compfn;':'\\u2218',\n'complement;':'\\u2201',\n'complexes;':'\\u2102',\n'cong;':'\\u2245',\n'congdot;':'\\u2a6d',\n'Congruent;':'\\u2261',\n'Conint;':'\\u222f',\n'conint;':'\\u222e',\n'ContourIntegral;':'\\u222e',\n'Copf;':'\\u2102',\n'copf;':'\\U0001d554',\n'coprod;':'\\u2210',\n'Coproduct;':'\\u2210',\n'COPY':'\\xa9',\n'copy':'\\xa9',\n'COPY;':'\\xa9',\n'copy;':'\\xa9',\n'copysr;':'\\u2117',\n'CounterClockwiseContourIntegral;':'\\u2233',\n'crarr;':'\\u21b5',\n'Cross;':'\\u2a2f',\n'cross;':'\\u2717',\n'Cscr;':'\\U0001d49e',\n'cscr;':'\\U0001d4b8',\n'csub;':'\\u2acf',\n'csube;':'\\u2ad1',\n'csup;':'\\u2ad0',\n'csupe;':'\\u2ad2',\n'ctdot;':'\\u22ef',\n'cudarrl;':'\\u2938',\n'cudarrr;':'\\u2935',\n'cuepr;':'\\u22de',\n'cuesc;':'\\u22df',\n'cularr;':'\\u21b6',\n'cularrp;':'\\u293d',\n'Cup;':'\\u22d3',\n'cup;':'\\u222a',\n'cupbrcap;':'\\u2a48',\n'CupCap;':'\\u224d',\n'cupcap;':'\\u2a46',\n'cupcup;':'\\u2a4a',\n'cupdot;':'\\u228d',\n'cupor;':'\\u2a45',\n'cups;':'\\u222a\\ufe00',\n'curarr;':'\\u21b7',\n'curarrm;':'\\u293c',\n'curlyeqprec;':'\\u22de',\n'curlyeqsucc;':'\\u22df',\n'curlyvee;':'\\u22ce',\n'curlywedge;':'\\u22cf',\n'curren':'\\xa4',\n'curren;':'\\xa4',\n'curvearrowleft;':'\\u21b6',\n'curvearrowright;':'\\u21b7',\n'cuvee;':'\\u22ce',\n'cuwed;':'\\u22cf',\n'cwconint;':'\\u2232',\n'cwint;':'\\u2231',\n'cylcty;':'\\u232d',\n'Dagger;':'\\u2021',\n'dagger;':'\\u2020',\n'daleth;':'\\u2138',\n'Darr;':'\\u21a1',\n'dArr;':'\\u21d3',\n'darr;':'\\u2193',\n'dash;':'\\u2010',\n'Dashv;':'\\u2ae4',\n'dashv;':'\\u22a3',\n'dbkarow;':'\\u290f',\n'dblac;':'\\u02dd',\n'Dcaron;':'\\u010e',\n'dcaron;':'\\u010f',\n'Dcy;':'\\u0414',\n'dcy;':'\\u0434',\n'DD;':'\\u2145',\n'dd;':'\\u2146',\n'ddagger;':'\\u2021',\n'ddarr;':'\\u21ca',\n'DDotrahd;':'\\u2911',\n'ddotseq;':'\\u2a77',\n'deg':'\\xb0',\n'deg;':'\\xb0',\n'Del;':'\\u2207',\n'Delta;':'\\u0394',\n'delta;':'\\u03b4',\n'demptyv;':'\\u29b1',\n'dfisht;':'\\u297f',\n'Dfr;':'\\U0001d507',\n'dfr;':'\\U0001d521',\n'dHar;':'\\u2965',\n'dharl;':'\\u21c3',\n'dharr;':'\\u21c2',\n'DiacriticalAcute;':'\\xb4',\n'DiacriticalDot;':'\\u02d9',\n'DiacriticalDoubleAcute;':'\\u02dd',\n'DiacriticalGrave;':'`',\n'DiacriticalTilde;':'\\u02dc',\n'diam;':'\\u22c4',\n'Diamond;':'\\u22c4',\n'diamond;':'\\u22c4',\n'diamondsuit;':'\\u2666',\n'diams;':'\\u2666',\n'die;':'\\xa8',\n'DifferentialD;':'\\u2146',\n'digamma;':'\\u03dd',\n'disin;':'\\u22f2',\n'div;':'\\xf7',\n'divide':'\\xf7',\n'divide;':'\\xf7',\n'divideontimes;':'\\u22c7',\n'divonx;':'\\u22c7',\n'DJcy;':'\\u0402',\n'djcy;':'\\u0452',\n'dlcorn;':'\\u231e',\n'dlcrop;':'\\u230d',\n'dollar;':'$',\n'Dopf;':'\\U0001d53b',\n'dopf;':'\\U0001d555',\n'Dot;':'\\xa8',\n'dot;':'\\u02d9',\n'DotDot;':'\\u20dc',\n'doteq;':'\\u2250',\n'doteqdot;':'\\u2251',\n'DotEqual;':'\\u2250',\n'dotminus;':'\\u2238',\n'dotplus;':'\\u2214',\n'dotsquare;':'\\u22a1',\n'doublebarwedge;':'\\u2306',\n'DoubleContourIntegral;':'\\u222f',\n'DoubleDot;':'\\xa8',\n'DoubleDownArrow;':'\\u21d3',\n'DoubleLeftArrow;':'\\u21d0',\n'DoubleLeftRightArrow;':'\\u21d4',\n'DoubleLeftTee;':'\\u2ae4',\n'DoubleLongLeftArrow;':'\\u27f8',\n'DoubleLongLeftRightArrow;':'\\u27fa',\n'DoubleLongRightArrow;':'\\u27f9',\n'DoubleRightArrow;':'\\u21d2',\n'DoubleRightTee;':'\\u22a8',\n'DoubleUpArrow;':'\\u21d1',\n'DoubleUpDownArrow;':'\\u21d5',\n'DoubleVerticalBar;':'\\u2225',\n'DownArrow;':'\\u2193',\n'Downarrow;':'\\u21d3',\n'downarrow;':'\\u2193',\n'DownArrowBar;':'\\u2913',\n'DownArrowUpArrow;':'\\u21f5',\n'DownBreve;':'\\u0311',\n'downdownarrows;':'\\u21ca',\n'downharpoonleft;':'\\u21c3',\n'downharpoonright;':'\\u21c2',\n'DownLeftRightVector;':'\\u2950',\n'DownLeftTeeVector;':'\\u295e',\n'DownLeftVector;':'\\u21bd',\n'DownLeftVectorBar;':'\\u2956',\n'DownRightTeeVector;':'\\u295f',\n'DownRightVector;':'\\u21c1',\n'DownRightVectorBar;':'\\u2957',\n'DownTee;':'\\u22a4',\n'DownTeeArrow;':'\\u21a7',\n'drbkarow;':'\\u2910',\n'drcorn;':'\\u231f',\n'drcrop;':'\\u230c',\n'Dscr;':'\\U0001d49f',\n'dscr;':'\\U0001d4b9',\n'DScy;':'\\u0405',\n'dscy;':'\\u0455',\n'dsol;':'\\u29f6',\n'Dstrok;':'\\u0110',\n'dstrok;':'\\u0111',\n'dtdot;':'\\u22f1',\n'dtri;':'\\u25bf',\n'dtrif;':'\\u25be',\n'duarr;':'\\u21f5',\n'duhar;':'\\u296f',\n'dwangle;':'\\u29a6',\n'DZcy;':'\\u040f',\n'dzcy;':'\\u045f',\n'dzigrarr;':'\\u27ff',\n'Eacute':'\\xc9',\n'eacute':'\\xe9',\n'Eacute;':'\\xc9',\n'eacute;':'\\xe9',\n'easter;':'\\u2a6e',\n'Ecaron;':'\\u011a',\n'ecaron;':'\\u011b',\n'ecir;':'\\u2256',\n'Ecirc':'\\xca',\n'ecirc':'\\xea',\n'Ecirc;':'\\xca',\n'ecirc;':'\\xea',\n'ecolon;':'\\u2255',\n'Ecy;':'\\u042d',\n'ecy;':'\\u044d',\n'eDDot;':'\\u2a77',\n'Edot;':'\\u0116',\n'eDot;':'\\u2251',\n'edot;':'\\u0117',\n'ee;':'\\u2147',\n'efDot;':'\\u2252',\n'Efr;':'\\U0001d508',\n'efr;':'\\U0001d522',\n'eg;':'\\u2a9a',\n'Egrave':'\\xc8',\n'egrave':'\\xe8',\n'Egrave;':'\\xc8',\n'egrave;':'\\xe8',\n'egs;':'\\u2a96',\n'egsdot;':'\\u2a98',\n'el;':'\\u2a99',\n'Element;':'\\u2208',\n'elinters;':'\\u23e7',\n'ell;':'\\u2113',\n'els;':'\\u2a95',\n'elsdot;':'\\u2a97',\n'Emacr;':'\\u0112',\n'emacr;':'\\u0113',\n'empty;':'\\u2205',\n'emptyset;':'\\u2205',\n'EmptySmallSquare;':'\\u25fb',\n'emptyv;':'\\u2205',\n'EmptyVerySmallSquare;':'\\u25ab',\n'emsp13;':'\\u2004',\n'emsp14;':'\\u2005',\n'emsp;':'\\u2003',\n'ENG;':'\\u014a',\n'eng;':'\\u014b',\n'ensp;':'\\u2002',\n'Eogon;':'\\u0118',\n'eogon;':'\\u0119',\n'Eopf;':'\\U0001d53c',\n'eopf;':'\\U0001d556',\n'epar;':'\\u22d5',\n'eparsl;':'\\u29e3',\n'eplus;':'\\u2a71',\n'epsi;':'\\u03b5',\n'Epsilon;':'\\u0395',\n'epsilon;':'\\u03b5',\n'epsiv;':'\\u03f5',\n'eqcirc;':'\\u2256',\n'eqcolon;':'\\u2255',\n'eqsim;':'\\u2242',\n'eqslantgtr;':'\\u2a96',\n'eqslantless;':'\\u2a95',\n'Equal;':'\\u2a75',\n'equals;':'=',\n'EqualTilde;':'\\u2242',\n'equest;':'\\u225f',\n'Equilibrium;':'\\u21cc',\n'equiv;':'\\u2261',\n'equivDD;':'\\u2a78',\n'eqvparsl;':'\\u29e5',\n'erarr;':'\\u2971',\n'erDot;':'\\u2253',\n'Escr;':'\\u2130',\n'escr;':'\\u212f',\n'esdot;':'\\u2250',\n'Esim;':'\\u2a73',\n'esim;':'\\u2242',\n'Eta;':'\\u0397',\n'eta;':'\\u03b7',\n'ETH':'\\xd0',\n'eth':'\\xf0',\n'ETH;':'\\xd0',\n'eth;':'\\xf0',\n'Euml':'\\xcb',\n'euml':'\\xeb',\n'Euml;':'\\xcb',\n'euml;':'\\xeb',\n'euro;':'\\u20ac',\n'excl;':'!',\n'exist;':'\\u2203',\n'Exists;':'\\u2203',\n'expectation;':'\\u2130',\n'ExponentialE;':'\\u2147',\n'exponentiale;':'\\u2147',\n'fallingdotseq;':'\\u2252',\n'Fcy;':'\\u0424',\n'fcy;':'\\u0444',\n'female;':'\\u2640',\n'ffilig;':'\\ufb03',\n'fflig;':'\\ufb00',\n'ffllig;':'\\ufb04',\n'Ffr;':'\\U0001d509',\n'ffr;':'\\U0001d523',\n'filig;':'\\ufb01',\n'FilledSmallSquare;':'\\u25fc',\n'FilledVerySmallSquare;':'\\u25aa',\n'fjlig;':'fj',\n'flat;':'\\u266d',\n'fllig;':'\\ufb02',\n'fltns;':'\\u25b1',\n'fnof;':'\\u0192',\n'Fopf;':'\\U0001d53d',\n'fopf;':'\\U0001d557',\n'ForAll;':'\\u2200',\n'forall;':'\\u2200',\n'fork;':'\\u22d4',\n'forkv;':'\\u2ad9',\n'Fouriertrf;':'\\u2131',\n'fpartint;':'\\u2a0d',\n'frac12':'\\xbd',\n'frac12;':'\\xbd',\n'frac13;':'\\u2153',\n'frac14':'\\xbc',\n'frac14;':'\\xbc',\n'frac15;':'\\u2155',\n'frac16;':'\\u2159',\n'frac18;':'\\u215b',\n'frac23;':'\\u2154',\n'frac25;':'\\u2156',\n'frac34':'\\xbe',\n'frac34;':'\\xbe',\n'frac35;':'\\u2157',\n'frac38;':'\\u215c',\n'frac45;':'\\u2158',\n'frac56;':'\\u215a',\n'frac58;':'\\u215d',\n'frac78;':'\\u215e',\n'frasl;':'\\u2044',\n'frown;':'\\u2322',\n'Fscr;':'\\u2131',\n'fscr;':'\\U0001d4bb',\n'gacute;':'\\u01f5',\n'Gamma;':'\\u0393',\n'gamma;':'\\u03b3',\n'Gammad;':'\\u03dc',\n'gammad;':'\\u03dd',\n'gap;':'\\u2a86',\n'Gbreve;':'\\u011e',\n'gbreve;':'\\u011f',\n'Gcedil;':'\\u0122',\n'Gcirc;':'\\u011c',\n'gcirc;':'\\u011d',\n'Gcy;':'\\u0413',\n'gcy;':'\\u0433',\n'Gdot;':'\\u0120',\n'gdot;':'\\u0121',\n'gE;':'\\u2267',\n'ge;':'\\u2265',\n'gEl;':'\\u2a8c',\n'gel;':'\\u22db',\n'geq;':'\\u2265',\n'geqq;':'\\u2267',\n'geqslant;':'\\u2a7e',\n'ges;':'\\u2a7e',\n'gescc;':'\\u2aa9',\n'gesdot;':'\\u2a80',\n'gesdoto;':'\\u2a82',\n'gesdotol;':'\\u2a84',\n'gesl;':'\\u22db\\ufe00',\n'gesles;':'\\u2a94',\n'Gfr;':'\\U0001d50a',\n'gfr;':'\\U0001d524',\n'Gg;':'\\u22d9',\n'gg;':'\\u226b',\n'ggg;':'\\u22d9',\n'gimel;':'\\u2137',\n'GJcy;':'\\u0403',\n'gjcy;':'\\u0453',\n'gl;':'\\u2277',\n'gla;':'\\u2aa5',\n'glE;':'\\u2a92',\n'glj;':'\\u2aa4',\n'gnap;':'\\u2a8a',\n'gnapprox;':'\\u2a8a',\n'gnE;':'\\u2269',\n'gne;':'\\u2a88',\n'gneq;':'\\u2a88',\n'gneqq;':'\\u2269',\n'gnsim;':'\\u22e7',\n'Gopf;':'\\U0001d53e',\n'gopf;':'\\U0001d558',\n'grave;':'`',\n'GreaterEqual;':'\\u2265',\n'GreaterEqualLess;':'\\u22db',\n'GreaterFullEqual;':'\\u2267',\n'GreaterGreater;':'\\u2aa2',\n'GreaterLess;':'\\u2277',\n'GreaterSlantEqual;':'\\u2a7e',\n'GreaterTilde;':'\\u2273',\n'Gscr;':'\\U0001d4a2',\n'gscr;':'\\u210a',\n'gsim;':'\\u2273',\n'gsime;':'\\u2a8e',\n'gsiml;':'\\u2a90',\n'GT':'>',\n'gt':'>',\n'GT;':'>',\n'Gt;':'\\u226b',\n'gt;':'>',\n'gtcc;':'\\u2aa7',\n'gtcir;':'\\u2a7a',\n'gtdot;':'\\u22d7',\n'gtlPar;':'\\u2995',\n'gtquest;':'\\u2a7c',\n'gtrapprox;':'\\u2a86',\n'gtrarr;':'\\u2978',\n'gtrdot;':'\\u22d7',\n'gtreqless;':'\\u22db',\n'gtreqqless;':'\\u2a8c',\n'gtrless;':'\\u2277',\n'gtrsim;':'\\u2273',\n'gvertneqq;':'\\u2269\\ufe00',\n'gvnE;':'\\u2269\\ufe00',\n'Hacek;':'\\u02c7',\n'hairsp;':'\\u200a',\n'half;':'\\xbd',\n'hamilt;':'\\u210b',\n'HARDcy;':'\\u042a',\n'hardcy;':'\\u044a',\n'hArr;':'\\u21d4',\n'harr;':'\\u2194',\n'harrcir;':'\\u2948',\n'harrw;':'\\u21ad',\n'Hat;':'^',\n'hbar;':'\\u210f',\n'Hcirc;':'\\u0124',\n'hcirc;':'\\u0125',\n'hearts;':'\\u2665',\n'heartsuit;':'\\u2665',\n'hellip;':'\\u2026',\n'hercon;':'\\u22b9',\n'Hfr;':'\\u210c',\n'hfr;':'\\U0001d525',\n'HilbertSpace;':'\\u210b',\n'hksearow;':'\\u2925',\n'hkswarow;':'\\u2926',\n'hoarr;':'\\u21ff',\n'homtht;':'\\u223b',\n'hookleftarrow;':'\\u21a9',\n'hookrightarrow;':'\\u21aa',\n'Hopf;':'\\u210d',\n'hopf;':'\\U0001d559',\n'horbar;':'\\u2015',\n'HorizontalLine;':'\\u2500',\n'Hscr;':'\\u210b',\n'hscr;':'\\U0001d4bd',\n'hslash;':'\\u210f',\n'Hstrok;':'\\u0126',\n'hstrok;':'\\u0127',\n'HumpDownHump;':'\\u224e',\n'HumpEqual;':'\\u224f',\n'hybull;':'\\u2043',\n'hyphen;':'\\u2010',\n'Iacute':'\\xcd',\n'iacute':'\\xed',\n'Iacute;':'\\xcd',\n'iacute;':'\\xed',\n'ic;':'\\u2063',\n'Icirc':'\\xce',\n'icirc':'\\xee',\n'Icirc;':'\\xce',\n'icirc;':'\\xee',\n'Icy;':'\\u0418',\n'icy;':'\\u0438',\n'Idot;':'\\u0130',\n'IEcy;':'\\u0415',\n'iecy;':'\\u0435',\n'iexcl':'\\xa1',\n'iexcl;':'\\xa1',\n'iff;':'\\u21d4',\n'Ifr;':'\\u2111',\n'ifr;':'\\U0001d526',\n'Igrave':'\\xcc',\n'igrave':'\\xec',\n'Igrave;':'\\xcc',\n'igrave;':'\\xec',\n'ii;':'\\u2148',\n'iiiint;':'\\u2a0c',\n'iiint;':'\\u222d',\n'iinfin;':'\\u29dc',\n'iiota;':'\\u2129',\n'IJlig;':'\\u0132',\n'ijlig;':'\\u0133',\n'Im;':'\\u2111',\n'Imacr;':'\\u012a',\n'imacr;':'\\u012b',\n'image;':'\\u2111',\n'ImaginaryI;':'\\u2148',\n'imagline;':'\\u2110',\n'imagpart;':'\\u2111',\n'imath;':'\\u0131',\n'imof;':'\\u22b7',\n'imped;':'\\u01b5',\n'Implies;':'\\u21d2',\n'in;':'\\u2208',\n'incare;':'\\u2105',\n'infin;':'\\u221e',\n'infintie;':'\\u29dd',\n'inodot;':'\\u0131',\n'Int;':'\\u222c',\n'int;':'\\u222b',\n'intcal;':'\\u22ba',\n'integers;':'\\u2124',\n'Integral;':'\\u222b',\n'intercal;':'\\u22ba',\n'Intersection;':'\\u22c2',\n'intlarhk;':'\\u2a17',\n'intprod;':'\\u2a3c',\n'InvisibleComma;':'\\u2063',\n'InvisibleTimes;':'\\u2062',\n'IOcy;':'\\u0401',\n'iocy;':'\\u0451',\n'Iogon;':'\\u012e',\n'iogon;':'\\u012f',\n'Iopf;':'\\U0001d540',\n'iopf;':'\\U0001d55a',\n'Iota;':'\\u0399',\n'iota;':'\\u03b9',\n'iprod;':'\\u2a3c',\n'iquest':'\\xbf',\n'iquest;':'\\xbf',\n'Iscr;':'\\u2110',\n'iscr;':'\\U0001d4be',\n'isin;':'\\u2208',\n'isindot;':'\\u22f5',\n'isinE;':'\\u22f9',\n'isins;':'\\u22f4',\n'isinsv;':'\\u22f3',\n'isinv;':'\\u2208',\n'it;':'\\u2062',\n'Itilde;':'\\u0128',\n'itilde;':'\\u0129',\n'Iukcy;':'\\u0406',\n'iukcy;':'\\u0456',\n'Iuml':'\\xcf',\n'iuml':'\\xef',\n'Iuml;':'\\xcf',\n'iuml;':'\\xef',\n'Jcirc;':'\\u0134',\n'jcirc;':'\\u0135',\n'Jcy;':'\\u0419',\n'jcy;':'\\u0439',\n'Jfr;':'\\U0001d50d',\n'jfr;':'\\U0001d527',\n'jmath;':'\\u0237',\n'Jopf;':'\\U0001d541',\n'jopf;':'\\U0001d55b',\n'Jscr;':'\\U0001d4a5',\n'jscr;':'\\U0001d4bf',\n'Jsercy;':'\\u0408',\n'jsercy;':'\\u0458',\n'Jukcy;':'\\u0404',\n'jukcy;':'\\u0454',\n'Kappa;':'\\u039a',\n'kappa;':'\\u03ba',\n'kappav;':'\\u03f0',\n'Kcedil;':'\\u0136',\n'kcedil;':'\\u0137',\n'Kcy;':'\\u041a',\n'kcy;':'\\u043a',\n'Kfr;':'\\U0001d50e',\n'kfr;':'\\U0001d528',\n'kgreen;':'\\u0138',\n'KHcy;':'\\u0425',\n'khcy;':'\\u0445',\n'KJcy;':'\\u040c',\n'kjcy;':'\\u045c',\n'Kopf;':'\\U0001d542',\n'kopf;':'\\U0001d55c',\n'Kscr;':'\\U0001d4a6',\n'kscr;':'\\U0001d4c0',\n'lAarr;':'\\u21da',\n'Lacute;':'\\u0139',\n'lacute;':'\\u013a',\n'laemptyv;':'\\u29b4',\n'lagran;':'\\u2112',\n'Lambda;':'\\u039b',\n'lambda;':'\\u03bb',\n'Lang;':'\\u27ea',\n'lang;':'\\u27e8',\n'langd;':'\\u2991',\n'langle;':'\\u27e8',\n'lap;':'\\u2a85',\n'Laplacetrf;':'\\u2112',\n'laquo':'\\xab',\n'laquo;':'\\xab',\n'Larr;':'\\u219e',\n'lArr;':'\\u21d0',\n'larr;':'\\u2190',\n'larrb;':'\\u21e4',\n'larrbfs;':'\\u291f',\n'larrfs;':'\\u291d',\n'larrhk;':'\\u21a9',\n'larrlp;':'\\u21ab',\n'larrpl;':'\\u2939',\n'larrsim;':'\\u2973',\n'larrtl;':'\\u21a2',\n'lat;':'\\u2aab',\n'lAtail;':'\\u291b',\n'latail;':'\\u2919',\n'late;':'\\u2aad',\n'lates;':'\\u2aad\\ufe00',\n'lBarr;':'\\u290e',\n'lbarr;':'\\u290c',\n'lbbrk;':'\\u2772',\n'lbrace;':'{',\n'lbrack;':'[',\n'lbrke;':'\\u298b',\n'lbrksld;':'\\u298f',\n'lbrkslu;':'\\u298d',\n'Lcaron;':'\\u013d',\n'lcaron;':'\\u013e',\n'Lcedil;':'\\u013b',\n'lcedil;':'\\u013c',\n'lceil;':'\\u2308',\n'lcub;':'{',\n'Lcy;':'\\u041b',\n'lcy;':'\\u043b',\n'ldca;':'\\u2936',\n'ldquo;':'\\u201c',\n'ldquor;':'\\u201e',\n'ldrdhar;':'\\u2967',\n'ldrushar;':'\\u294b',\n'ldsh;':'\\u21b2',\n'lE;':'\\u2266',\n'le;':'\\u2264',\n'LeftAngleBracket;':'\\u27e8',\n'LeftArrow;':'\\u2190',\n'Leftarrow;':'\\u21d0',\n'leftarrow;':'\\u2190',\n'LeftArrowBar;':'\\u21e4',\n'LeftArrowRightArrow;':'\\u21c6',\n'leftarrowtail;':'\\u21a2',\n'LeftCeiling;':'\\u2308',\n'LeftDoubleBracket;':'\\u27e6',\n'LeftDownTeeVector;':'\\u2961',\n'LeftDownVector;':'\\u21c3',\n'LeftDownVectorBar;':'\\u2959',\n'LeftFloor;':'\\u230a',\n'leftharpoondown;':'\\u21bd',\n'leftharpoonup;':'\\u21bc',\n'leftleftarrows;':'\\u21c7',\n'LeftRightArrow;':'\\u2194',\n'Leftrightarrow;':'\\u21d4',\n'leftrightarrow;':'\\u2194',\n'leftrightarrows;':'\\u21c6',\n'leftrightharpoons;':'\\u21cb',\n'leftrightsquigarrow;':'\\u21ad',\n'LeftRightVector;':'\\u294e',\n'LeftTee;':'\\u22a3',\n'LeftTeeArrow;':'\\u21a4',\n'LeftTeeVector;':'\\u295a',\n'leftthreetimes;':'\\u22cb',\n'LeftTriangle;':'\\u22b2',\n'LeftTriangleBar;':'\\u29cf',\n'LeftTriangleEqual;':'\\u22b4',\n'LeftUpDownVector;':'\\u2951',\n'LeftUpTeeVector;':'\\u2960',\n'LeftUpVector;':'\\u21bf',\n'LeftUpVectorBar;':'\\u2958',\n'LeftVector;':'\\u21bc',\n'LeftVectorBar;':'\\u2952',\n'lEg;':'\\u2a8b',\n'leg;':'\\u22da',\n'leq;':'\\u2264',\n'leqq;':'\\u2266',\n'leqslant;':'\\u2a7d',\n'les;':'\\u2a7d',\n'lescc;':'\\u2aa8',\n'lesdot;':'\\u2a7f',\n'lesdoto;':'\\u2a81',\n'lesdotor;':'\\u2a83',\n'lesg;':'\\u22da\\ufe00',\n'lesges;':'\\u2a93',\n'lessapprox;':'\\u2a85',\n'lessdot;':'\\u22d6',\n'lesseqgtr;':'\\u22da',\n'lesseqqgtr;':'\\u2a8b',\n'LessEqualGreater;':'\\u22da',\n'LessFullEqual;':'\\u2266',\n'LessGreater;':'\\u2276',\n'lessgtr;':'\\u2276',\n'LessLess;':'\\u2aa1',\n'lesssim;':'\\u2272',\n'LessSlantEqual;':'\\u2a7d',\n'LessTilde;':'\\u2272',\n'lfisht;':'\\u297c',\n'lfloor;':'\\u230a',\n'Lfr;':'\\U0001d50f',\n'lfr;':'\\U0001d529',\n'lg;':'\\u2276',\n'lgE;':'\\u2a91',\n'lHar;':'\\u2962',\n'lhard;':'\\u21bd',\n'lharu;':'\\u21bc',\n'lharul;':'\\u296a',\n'lhblk;':'\\u2584',\n'LJcy;':'\\u0409',\n'ljcy;':'\\u0459',\n'Ll;':'\\u22d8',\n'll;':'\\u226a',\n'llarr;':'\\u21c7',\n'llcorner;':'\\u231e',\n'Lleftarrow;':'\\u21da',\n'llhard;':'\\u296b',\n'lltri;':'\\u25fa',\n'Lmidot;':'\\u013f',\n'lmidot;':'\\u0140',\n'lmoust;':'\\u23b0',\n'lmoustache;':'\\u23b0',\n'lnap;':'\\u2a89',\n'lnapprox;':'\\u2a89',\n'lnE;':'\\u2268',\n'lne;':'\\u2a87',\n'lneq;':'\\u2a87',\n'lneqq;':'\\u2268',\n'lnsim;':'\\u22e6',\n'loang;':'\\u27ec',\n'loarr;':'\\u21fd',\n'lobrk;':'\\u27e6',\n'LongLeftArrow;':'\\u27f5',\n'Longleftarrow;':'\\u27f8',\n'longleftarrow;':'\\u27f5',\n'LongLeftRightArrow;':'\\u27f7',\n'Longleftrightarrow;':'\\u27fa',\n'longleftrightarrow;':'\\u27f7',\n'longmapsto;':'\\u27fc',\n'LongRightArrow;':'\\u27f6',\n'Longrightarrow;':'\\u27f9',\n'longrightarrow;':'\\u27f6',\n'looparrowleft;':'\\u21ab',\n'looparrowright;':'\\u21ac',\n'lopar;':'\\u2985',\n'Lopf;':'\\U0001d543',\n'lopf;':'\\U0001d55d',\n'loplus;':'\\u2a2d',\n'lotimes;':'\\u2a34',\n'lowast;':'\\u2217',\n'lowbar;':'_',\n'LowerLeftArrow;':'\\u2199',\n'LowerRightArrow;':'\\u2198',\n'loz;':'\\u25ca',\n'lozenge;':'\\u25ca',\n'lozf;':'\\u29eb',\n'lpar;':'(',\n'lparlt;':'\\u2993',\n'lrarr;':'\\u21c6',\n'lrcorner;':'\\u231f',\n'lrhar;':'\\u21cb',\n'lrhard;':'\\u296d',\n'lrm;':'\\u200e',\n'lrtri;':'\\u22bf',\n'lsaquo;':'\\u2039',\n'Lscr;':'\\u2112',\n'lscr;':'\\U0001d4c1',\n'Lsh;':'\\u21b0',\n'lsh;':'\\u21b0',\n'lsim;':'\\u2272',\n'lsime;':'\\u2a8d',\n'lsimg;':'\\u2a8f',\n'lsqb;':'[',\n'lsquo;':'\\u2018',\n'lsquor;':'\\u201a',\n'Lstrok;':'\\u0141',\n'lstrok;':'\\u0142',\n'LT':'<',\n'lt':'<',\n'LT;':'<',\n'Lt;':'\\u226a',\n'lt;':'<',\n'ltcc;':'\\u2aa6',\n'ltcir;':'\\u2a79',\n'ltdot;':'\\u22d6',\n'lthree;':'\\u22cb',\n'ltimes;':'\\u22c9',\n'ltlarr;':'\\u2976',\n'ltquest;':'\\u2a7b',\n'ltri;':'\\u25c3',\n'ltrie;':'\\u22b4',\n'ltrif;':'\\u25c2',\n'ltrPar;':'\\u2996',\n'lurdshar;':'\\u294a',\n'luruhar;':'\\u2966',\n'lvertneqq;':'\\u2268\\ufe00',\n'lvnE;':'\\u2268\\ufe00',\n'macr':'\\xaf',\n'macr;':'\\xaf',\n'male;':'\\u2642',\n'malt;':'\\u2720',\n'maltese;':'\\u2720',\n'Map;':'\\u2905',\n'map;':'\\u21a6',\n'mapsto;':'\\u21a6',\n'mapstodown;':'\\u21a7',\n'mapstoleft;':'\\u21a4',\n'mapstoup;':'\\u21a5',\n'marker;':'\\u25ae',\n'mcomma;':'\\u2a29',\n'Mcy;':'\\u041c',\n'mcy;':'\\u043c',\n'mdash;':'\\u2014',\n'mDDot;':'\\u223a',\n'measuredangle;':'\\u2221',\n'MediumSpace;':'\\u205f',\n'Mellintrf;':'\\u2133',\n'Mfr;':'\\U0001d510',\n'mfr;':'\\U0001d52a',\n'mho;':'\\u2127',\n'micro':'\\xb5',\n'micro;':'\\xb5',\n'mid;':'\\u2223',\n'midast;':'*',\n'midcir;':'\\u2af0',\n'middot':'\\xb7',\n'middot;':'\\xb7',\n'minus;':'\\u2212',\n'minusb;':'\\u229f',\n'minusd;':'\\u2238',\n'minusdu;':'\\u2a2a',\n'MinusPlus;':'\\u2213',\n'mlcp;':'\\u2adb',\n'mldr;':'\\u2026',\n'mnplus;':'\\u2213',\n'models;':'\\u22a7',\n'Mopf;':'\\U0001d544',\n'mopf;':'\\U0001d55e',\n'mp;':'\\u2213',\n'Mscr;':'\\u2133',\n'mscr;':'\\U0001d4c2',\n'mstpos;':'\\u223e',\n'Mu;':'\\u039c',\n'mu;':'\\u03bc',\n'multimap;':'\\u22b8',\n'mumap;':'\\u22b8',\n'nabla;':'\\u2207',\n'Nacute;':'\\u0143',\n'nacute;':'\\u0144',\n'nang;':'\\u2220\\u20d2',\n'nap;':'\\u2249',\n'napE;':'\\u2a70\\u0338',\n'napid;':'\\u224b\\u0338',\n'napos;':'\\u0149',\n'napprox;':'\\u2249',\n'natur;':'\\u266e',\n'natural;':'\\u266e',\n'naturals;':'\\u2115',\n'nbsp':'\\xa0',\n'nbsp;':'\\xa0',\n'nbump;':'\\u224e\\u0338',\n'nbumpe;':'\\u224f\\u0338',\n'ncap;':'\\u2a43',\n'Ncaron;':'\\u0147',\n'ncaron;':'\\u0148',\n'Ncedil;':'\\u0145',\n'ncedil;':'\\u0146',\n'ncong;':'\\u2247',\n'ncongdot;':'\\u2a6d\\u0338',\n'ncup;':'\\u2a42',\n'Ncy;':'\\u041d',\n'ncy;':'\\u043d',\n'ndash;':'\\u2013',\n'ne;':'\\u2260',\n'nearhk;':'\\u2924',\n'neArr;':'\\u21d7',\n'nearr;':'\\u2197',\n'nearrow;':'\\u2197',\n'nedot;':'\\u2250\\u0338',\n'NegativeMediumSpace;':'\\u200b',\n'NegativeThickSpace;':'\\u200b',\n'NegativeThinSpace;':'\\u200b',\n'NegativeVeryThinSpace;':'\\u200b',\n'nequiv;':'\\u2262',\n'nesear;':'\\u2928',\n'nesim;':'\\u2242\\u0338',\n'NestedGreaterGreater;':'\\u226b',\n'NestedLessLess;':'\\u226a',\n'NewLine;':'\\n',\n'nexist;':'\\u2204',\n'nexists;':'\\u2204',\n'Nfr;':'\\U0001d511',\n'nfr;':'\\U0001d52b',\n'ngE;':'\\u2267\\u0338',\n'nge;':'\\u2271',\n'ngeq;':'\\u2271',\n'ngeqq;':'\\u2267\\u0338',\n'ngeqslant;':'\\u2a7e\\u0338',\n'nges;':'\\u2a7e\\u0338',\n'nGg;':'\\u22d9\\u0338',\n'ngsim;':'\\u2275',\n'nGt;':'\\u226b\\u20d2',\n'ngt;':'\\u226f',\n'ngtr;':'\\u226f',\n'nGtv;':'\\u226b\\u0338',\n'nhArr;':'\\u21ce',\n'nharr;':'\\u21ae',\n'nhpar;':'\\u2af2',\n'ni;':'\\u220b',\n'nis;':'\\u22fc',\n'nisd;':'\\u22fa',\n'niv;':'\\u220b',\n'NJcy;':'\\u040a',\n'njcy;':'\\u045a',\n'nlArr;':'\\u21cd',\n'nlarr;':'\\u219a',\n'nldr;':'\\u2025',\n'nlE;':'\\u2266\\u0338',\n'nle;':'\\u2270',\n'nLeftarrow;':'\\u21cd',\n'nleftarrow;':'\\u219a',\n'nLeftrightarrow;':'\\u21ce',\n'nleftrightarrow;':'\\u21ae',\n'nleq;':'\\u2270',\n'nleqq;':'\\u2266\\u0338',\n'nleqslant;':'\\u2a7d\\u0338',\n'nles;':'\\u2a7d\\u0338',\n'nless;':'\\u226e',\n'nLl;':'\\u22d8\\u0338',\n'nlsim;':'\\u2274',\n'nLt;':'\\u226a\\u20d2',\n'nlt;':'\\u226e',\n'nltri;':'\\u22ea',\n'nltrie;':'\\u22ec',\n'nLtv;':'\\u226a\\u0338',\n'nmid;':'\\u2224',\n'NoBreak;':'\\u2060',\n'NonBreakingSpace;':'\\xa0',\n'Nopf;':'\\u2115',\n'nopf;':'\\U0001d55f',\n'not':'\\xac',\n'Not;':'\\u2aec',\n'not;':'\\xac',\n'NotCongruent;':'\\u2262',\n'NotCupCap;':'\\u226d',\n'NotDoubleVerticalBar;':'\\u2226',\n'NotElement;':'\\u2209',\n'NotEqual;':'\\u2260',\n'NotEqualTilde;':'\\u2242\\u0338',\n'NotExists;':'\\u2204',\n'NotGreater;':'\\u226f',\n'NotGreaterEqual;':'\\u2271',\n'NotGreaterFullEqual;':'\\u2267\\u0338',\n'NotGreaterGreater;':'\\u226b\\u0338',\n'NotGreaterLess;':'\\u2279',\n'NotGreaterSlantEqual;':'\\u2a7e\\u0338',\n'NotGreaterTilde;':'\\u2275',\n'NotHumpDownHump;':'\\u224e\\u0338',\n'NotHumpEqual;':'\\u224f\\u0338',\n'notin;':'\\u2209',\n'notindot;':'\\u22f5\\u0338',\n'notinE;':'\\u22f9\\u0338',\n'notinva;':'\\u2209',\n'notinvb;':'\\u22f7',\n'notinvc;':'\\u22f6',\n'NotLeftTriangle;':'\\u22ea',\n'NotLeftTriangleBar;':'\\u29cf\\u0338',\n'NotLeftTriangleEqual;':'\\u22ec',\n'NotLess;':'\\u226e',\n'NotLessEqual;':'\\u2270',\n'NotLessGreater;':'\\u2278',\n'NotLessLess;':'\\u226a\\u0338',\n'NotLessSlantEqual;':'\\u2a7d\\u0338',\n'NotLessTilde;':'\\u2274',\n'NotNestedGreaterGreater;':'\\u2aa2\\u0338',\n'NotNestedLessLess;':'\\u2aa1\\u0338',\n'notni;':'\\u220c',\n'notniva;':'\\u220c',\n'notnivb;':'\\u22fe',\n'notnivc;':'\\u22fd',\n'NotPrecedes;':'\\u2280',\n'NotPrecedesEqual;':'\\u2aaf\\u0338',\n'NotPrecedesSlantEqual;':'\\u22e0',\n'NotReverseElement;':'\\u220c',\n'NotRightTriangle;':'\\u22eb',\n'NotRightTriangleBar;':'\\u29d0\\u0338',\n'NotRightTriangleEqual;':'\\u22ed',\n'NotSquareSubset;':'\\u228f\\u0338',\n'NotSquareSubsetEqual;':'\\u22e2',\n'NotSquareSuperset;':'\\u2290\\u0338',\n'NotSquareSupersetEqual;':'\\u22e3',\n'NotSubset;':'\\u2282\\u20d2',\n'NotSubsetEqual;':'\\u2288',\n'NotSucceeds;':'\\u2281',\n'NotSucceedsEqual;':'\\u2ab0\\u0338',\n'NotSucceedsSlantEqual;':'\\u22e1',\n'NotSucceedsTilde;':'\\u227f\\u0338',\n'NotSuperset;':'\\u2283\\u20d2',\n'NotSupersetEqual;':'\\u2289',\n'NotTilde;':'\\u2241',\n'NotTildeEqual;':'\\u2244',\n'NotTildeFullEqual;':'\\u2247',\n'NotTildeTilde;':'\\u2249',\n'NotVerticalBar;':'\\u2224',\n'npar;':'\\u2226',\n'nparallel;':'\\u2226',\n'nparsl;':'\\u2afd\\u20e5',\n'npart;':'\\u2202\\u0338',\n'npolint;':'\\u2a14',\n'npr;':'\\u2280',\n'nprcue;':'\\u22e0',\n'npre;':'\\u2aaf\\u0338',\n'nprec;':'\\u2280',\n'npreceq;':'\\u2aaf\\u0338',\n'nrArr;':'\\u21cf',\n'nrarr;':'\\u219b',\n'nrarrc;':'\\u2933\\u0338',\n'nrarrw;':'\\u219d\\u0338',\n'nRightarrow;':'\\u21cf',\n'nrightarrow;':'\\u219b',\n'nrtri;':'\\u22eb',\n'nrtrie;':'\\u22ed',\n'nsc;':'\\u2281',\n'nsccue;':'\\u22e1',\n'nsce;':'\\u2ab0\\u0338',\n'Nscr;':'\\U0001d4a9',\n'nscr;':'\\U0001d4c3',\n'nshortmid;':'\\u2224',\n'nshortparallel;':'\\u2226',\n'nsim;':'\\u2241',\n'nsime;':'\\u2244',\n'nsimeq;':'\\u2244',\n'nsmid;':'\\u2224',\n'nspar;':'\\u2226',\n'nsqsube;':'\\u22e2',\n'nsqsupe;':'\\u22e3',\n'nsub;':'\\u2284',\n'nsubE;':'\\u2ac5\\u0338',\n'nsube;':'\\u2288',\n'nsubset;':'\\u2282\\u20d2',\n'nsubseteq;':'\\u2288',\n'nsubseteqq;':'\\u2ac5\\u0338',\n'nsucc;':'\\u2281',\n'nsucceq;':'\\u2ab0\\u0338',\n'nsup;':'\\u2285',\n'nsupE;':'\\u2ac6\\u0338',\n'nsupe;':'\\u2289',\n'nsupset;':'\\u2283\\u20d2',\n'nsupseteq;':'\\u2289',\n'nsupseteqq;':'\\u2ac6\\u0338',\n'ntgl;':'\\u2279',\n'Ntilde':'\\xd1',\n'ntilde':'\\xf1',\n'Ntilde;':'\\xd1',\n'ntilde;':'\\xf1',\n'ntlg;':'\\u2278',\n'ntriangleleft;':'\\u22ea',\n'ntrianglelefteq;':'\\u22ec',\n'ntriangleright;':'\\u22eb',\n'ntrianglerighteq;':'\\u22ed',\n'Nu;':'\\u039d',\n'nu;':'\\u03bd',\n'num;':'#',\n'numero;':'\\u2116',\n'numsp;':'\\u2007',\n'nvap;':'\\u224d\\u20d2',\n'nVDash;':'\\u22af',\n'nVdash;':'\\u22ae',\n'nvDash;':'\\u22ad',\n'nvdash;':'\\u22ac',\n'nvge;':'\\u2265\\u20d2',\n'nvgt;':'>\\u20d2',\n'nvHarr;':'\\u2904',\n'nvinfin;':'\\u29de',\n'nvlArr;':'\\u2902',\n'nvle;':'\\u2264\\u20d2',\n'nvlt;':'<\\u20d2',\n'nvltrie;':'\\u22b4\\u20d2',\n'nvrArr;':'\\u2903',\n'nvrtrie;':'\\u22b5\\u20d2',\n'nvsim;':'\\u223c\\u20d2',\n'nwarhk;':'\\u2923',\n'nwArr;':'\\u21d6',\n'nwarr;':'\\u2196',\n'nwarrow;':'\\u2196',\n'nwnear;':'\\u2927',\n'Oacute':'\\xd3',\n'oacute':'\\xf3',\n'Oacute;':'\\xd3',\n'oacute;':'\\xf3',\n'oast;':'\\u229b',\n'ocir;':'\\u229a',\n'Ocirc':'\\xd4',\n'ocirc':'\\xf4',\n'Ocirc;':'\\xd4',\n'ocirc;':'\\xf4',\n'Ocy;':'\\u041e',\n'ocy;':'\\u043e',\n'odash;':'\\u229d',\n'Odblac;':'\\u0150',\n'odblac;':'\\u0151',\n'odiv;':'\\u2a38',\n'odot;':'\\u2299',\n'odsold;':'\\u29bc',\n'OElig;':'\\u0152',\n'oelig;':'\\u0153',\n'ofcir;':'\\u29bf',\n'Ofr;':'\\U0001d512',\n'ofr;':'\\U0001d52c',\n'ogon;':'\\u02db',\n'Ograve':'\\xd2',\n'ograve':'\\xf2',\n'Ograve;':'\\xd2',\n'ograve;':'\\xf2',\n'ogt;':'\\u29c1',\n'ohbar;':'\\u29b5',\n'ohm;':'\\u03a9',\n'oint;':'\\u222e',\n'olarr;':'\\u21ba',\n'olcir;':'\\u29be',\n'olcross;':'\\u29bb',\n'oline;':'\\u203e',\n'olt;':'\\u29c0',\n'Omacr;':'\\u014c',\n'omacr;':'\\u014d',\n'Omega;':'\\u03a9',\n'omega;':'\\u03c9',\n'Omicron;':'\\u039f',\n'omicron;':'\\u03bf',\n'omid;':'\\u29b6',\n'ominus;':'\\u2296',\n'Oopf;':'\\U0001d546',\n'oopf;':'\\U0001d560',\n'opar;':'\\u29b7',\n'OpenCurlyDoubleQuote;':'\\u201c',\n'OpenCurlyQuote;':'\\u2018',\n'operp;':'\\u29b9',\n'oplus;':'\\u2295',\n'Or;':'\\u2a54',\n'or;':'\\u2228',\n'orarr;':'\\u21bb',\n'ord;':'\\u2a5d',\n'order;':'\\u2134',\n'orderof;':'\\u2134',\n'ordf':'\\xaa',\n'ordf;':'\\xaa',\n'ordm':'\\xba',\n'ordm;':'\\xba',\n'origof;':'\\u22b6',\n'oror;':'\\u2a56',\n'orslope;':'\\u2a57',\n'orv;':'\\u2a5b',\n'oS;':'\\u24c8',\n'Oscr;':'\\U0001d4aa',\n'oscr;':'\\u2134',\n'Oslash':'\\xd8',\n'oslash':'\\xf8',\n'Oslash;':'\\xd8',\n'oslash;':'\\xf8',\n'osol;':'\\u2298',\n'Otilde':'\\xd5',\n'otilde':'\\xf5',\n'Otilde;':'\\xd5',\n'otilde;':'\\xf5',\n'Otimes;':'\\u2a37',\n'otimes;':'\\u2297',\n'otimesas;':'\\u2a36',\n'Ouml':'\\xd6',\n'ouml':'\\xf6',\n'Ouml;':'\\xd6',\n'ouml;':'\\xf6',\n'ovbar;':'\\u233d',\n'OverBar;':'\\u203e',\n'OverBrace;':'\\u23de',\n'OverBracket;':'\\u23b4',\n'OverParenthesis;':'\\u23dc',\n'par;':'\\u2225',\n'para':'\\xb6',\n'para;':'\\xb6',\n'parallel;':'\\u2225',\n'parsim;':'\\u2af3',\n'parsl;':'\\u2afd',\n'part;':'\\u2202',\n'PartialD;':'\\u2202',\n'Pcy;':'\\u041f',\n'pcy;':'\\u043f',\n'percnt;':'%',\n'period;':'.',\n'permil;':'\\u2030',\n'perp;':'\\u22a5',\n'pertenk;':'\\u2031',\n'Pfr;':'\\U0001d513',\n'pfr;':'\\U0001d52d',\n'Phi;':'\\u03a6',\n'phi;':'\\u03c6',\n'phiv;':'\\u03d5',\n'phmmat;':'\\u2133',\n'phone;':'\\u260e',\n'Pi;':'\\u03a0',\n'pi;':'\\u03c0',\n'pitchfork;':'\\u22d4',\n'piv;':'\\u03d6',\n'planck;':'\\u210f',\n'planckh;':'\\u210e',\n'plankv;':'\\u210f',\n'plus;':'+',\n'plusacir;':'\\u2a23',\n'plusb;':'\\u229e',\n'pluscir;':'\\u2a22',\n'plusdo;':'\\u2214',\n'plusdu;':'\\u2a25',\n'pluse;':'\\u2a72',\n'PlusMinus;':'\\xb1',\n'plusmn':'\\xb1',\n'plusmn;':'\\xb1',\n'plussim;':'\\u2a26',\n'plustwo;':'\\u2a27',\n'pm;':'\\xb1',\n'Poincareplane;':'\\u210c',\n'pointint;':'\\u2a15',\n'Popf;':'\\u2119',\n'popf;':'\\U0001d561',\n'pound':'\\xa3',\n'pound;':'\\xa3',\n'Pr;':'\\u2abb',\n'pr;':'\\u227a',\n'prap;':'\\u2ab7',\n'prcue;':'\\u227c',\n'prE;':'\\u2ab3',\n'pre;':'\\u2aaf',\n'prec;':'\\u227a',\n'precapprox;':'\\u2ab7',\n'preccurlyeq;':'\\u227c',\n'Precedes;':'\\u227a',\n'PrecedesEqual;':'\\u2aaf',\n'PrecedesSlantEqual;':'\\u227c',\n'PrecedesTilde;':'\\u227e',\n'preceq;':'\\u2aaf',\n'precnapprox;':'\\u2ab9',\n'precneqq;':'\\u2ab5',\n'precnsim;':'\\u22e8',\n'precsim;':'\\u227e',\n'Prime;':'\\u2033',\n'prime;':'\\u2032',\n'primes;':'\\u2119',\n'prnap;':'\\u2ab9',\n'prnE;':'\\u2ab5',\n'prnsim;':'\\u22e8',\n'prod;':'\\u220f',\n'Product;':'\\u220f',\n'profalar;':'\\u232e',\n'profline;':'\\u2312',\n'profsurf;':'\\u2313',\n'prop;':'\\u221d',\n'Proportion;':'\\u2237',\n'Proportional;':'\\u221d',\n'propto;':'\\u221d',\n'prsim;':'\\u227e',\n'prurel;':'\\u22b0',\n'Pscr;':'\\U0001d4ab',\n'pscr;':'\\U0001d4c5',\n'Psi;':'\\u03a8',\n'psi;':'\\u03c8',\n'puncsp;':'\\u2008',\n'Qfr;':'\\U0001d514',\n'qfr;':'\\U0001d52e',\n'qint;':'\\u2a0c',\n'Qopf;':'\\u211a',\n'qopf;':'\\U0001d562',\n'qprime;':'\\u2057',\n'Qscr;':'\\U0001d4ac',\n'qscr;':'\\U0001d4c6',\n'quaternions;':'\\u210d',\n'quatint;':'\\u2a16',\n'quest;':'?',\n'questeq;':'\\u225f',\n'QUOT':'\"',\n'quot':'\"',\n'QUOT;':'\"',\n'quot;':'\"',\n'rAarr;':'\\u21db',\n'race;':'\\u223d\\u0331',\n'Racute;':'\\u0154',\n'racute;':'\\u0155',\n'radic;':'\\u221a',\n'raemptyv;':'\\u29b3',\n'Rang;':'\\u27eb',\n'rang;':'\\u27e9',\n'rangd;':'\\u2992',\n'range;':'\\u29a5',\n'rangle;':'\\u27e9',\n'raquo':'\\xbb',\n'raquo;':'\\xbb',\n'Rarr;':'\\u21a0',\n'rArr;':'\\u21d2',\n'rarr;':'\\u2192',\n'rarrap;':'\\u2975',\n'rarrb;':'\\u21e5',\n'rarrbfs;':'\\u2920',\n'rarrc;':'\\u2933',\n'rarrfs;':'\\u291e',\n'rarrhk;':'\\u21aa',\n'rarrlp;':'\\u21ac',\n'rarrpl;':'\\u2945',\n'rarrsim;':'\\u2974',\n'Rarrtl;':'\\u2916',\n'rarrtl;':'\\u21a3',\n'rarrw;':'\\u219d',\n'rAtail;':'\\u291c',\n'ratail;':'\\u291a',\n'ratio;':'\\u2236',\n'rationals;':'\\u211a',\n'RBarr;':'\\u2910',\n'rBarr;':'\\u290f',\n'rbarr;':'\\u290d',\n'rbbrk;':'\\u2773',\n'rbrace;':'}',\n'rbrack;':']',\n'rbrke;':'\\u298c',\n'rbrksld;':'\\u298e',\n'rbrkslu;':'\\u2990',\n'Rcaron;':'\\u0158',\n'rcaron;':'\\u0159',\n'Rcedil;':'\\u0156',\n'rcedil;':'\\u0157',\n'rceil;':'\\u2309',\n'rcub;':'}',\n'Rcy;':'\\u0420',\n'rcy;':'\\u0440',\n'rdca;':'\\u2937',\n'rdldhar;':'\\u2969',\n'rdquo;':'\\u201d',\n'rdquor;':'\\u201d',\n'rdsh;':'\\u21b3',\n'Re;':'\\u211c',\n'real;':'\\u211c',\n'realine;':'\\u211b',\n'realpart;':'\\u211c',\n'reals;':'\\u211d',\n'rect;':'\\u25ad',\n'REG':'\\xae',\n'reg':'\\xae',\n'REG;':'\\xae',\n'reg;':'\\xae',\n'ReverseElement;':'\\u220b',\n'ReverseEquilibrium;':'\\u21cb',\n'ReverseUpEquilibrium;':'\\u296f',\n'rfisht;':'\\u297d',\n'rfloor;':'\\u230b',\n'Rfr;':'\\u211c',\n'rfr;':'\\U0001d52f',\n'rHar;':'\\u2964',\n'rhard;':'\\u21c1',\n'rharu;':'\\u21c0',\n'rharul;':'\\u296c',\n'Rho;':'\\u03a1',\n'rho;':'\\u03c1',\n'rhov;':'\\u03f1',\n'RightAngleBracket;':'\\u27e9',\n'RightArrow;':'\\u2192',\n'Rightarrow;':'\\u21d2',\n'rightarrow;':'\\u2192',\n'RightArrowBar;':'\\u21e5',\n'RightArrowLeftArrow;':'\\u21c4',\n'rightarrowtail;':'\\u21a3',\n'RightCeiling;':'\\u2309',\n'RightDoubleBracket;':'\\u27e7',\n'RightDownTeeVector;':'\\u295d',\n'RightDownVector;':'\\u21c2',\n'RightDownVectorBar;':'\\u2955',\n'RightFloor;':'\\u230b',\n'rightharpoondown;':'\\u21c1',\n'rightharpoonup;':'\\u21c0',\n'rightleftarrows;':'\\u21c4',\n'rightleftharpoons;':'\\u21cc',\n'rightrightarrows;':'\\u21c9',\n'rightsquigarrow;':'\\u219d',\n'RightTee;':'\\u22a2',\n'RightTeeArrow;':'\\u21a6',\n'RightTeeVector;':'\\u295b',\n'rightthreetimes;':'\\u22cc',\n'RightTriangle;':'\\u22b3',\n'RightTriangleBar;':'\\u29d0',\n'RightTriangleEqual;':'\\u22b5',\n'RightUpDownVector;':'\\u294f',\n'RightUpTeeVector;':'\\u295c',\n'RightUpVector;':'\\u21be',\n'RightUpVectorBar;':'\\u2954',\n'RightVector;':'\\u21c0',\n'RightVectorBar;':'\\u2953',\n'ring;':'\\u02da',\n'risingdotseq;':'\\u2253',\n'rlarr;':'\\u21c4',\n'rlhar;':'\\u21cc',\n'rlm;':'\\u200f',\n'rmoust;':'\\u23b1',\n'rmoustache;':'\\u23b1',\n'rnmid;':'\\u2aee',\n'roang;':'\\u27ed',\n'roarr;':'\\u21fe',\n'robrk;':'\\u27e7',\n'ropar;':'\\u2986',\n'Ropf;':'\\u211d',\n'ropf;':'\\U0001d563',\n'roplus;':'\\u2a2e',\n'rotimes;':'\\u2a35',\n'RoundImplies;':'\\u2970',\n'rpar;':')',\n'rpargt;':'\\u2994',\n'rppolint;':'\\u2a12',\n'rrarr;':'\\u21c9',\n'Rrightarrow;':'\\u21db',\n'rsaquo;':'\\u203a',\n'Rscr;':'\\u211b',\n'rscr;':'\\U0001d4c7',\n'Rsh;':'\\u21b1',\n'rsh;':'\\u21b1',\n'rsqb;':']',\n'rsquo;':'\\u2019',\n'rsquor;':'\\u2019',\n'rthree;':'\\u22cc',\n'rtimes;':'\\u22ca',\n'rtri;':'\\u25b9',\n'rtrie;':'\\u22b5',\n'rtrif;':'\\u25b8',\n'rtriltri;':'\\u29ce',\n'RuleDelayed;':'\\u29f4',\n'ruluhar;':'\\u2968',\n'rx;':'\\u211e',\n'Sacute;':'\\u015a',\n'sacute;':'\\u015b',\n'sbquo;':'\\u201a',\n'Sc;':'\\u2abc',\n'sc;':'\\u227b',\n'scap;':'\\u2ab8',\n'Scaron;':'\\u0160',\n'scaron;':'\\u0161',\n'sccue;':'\\u227d',\n'scE;':'\\u2ab4',\n'sce;':'\\u2ab0',\n'Scedil;':'\\u015e',\n'scedil;':'\\u015f',\n'Scirc;':'\\u015c',\n'scirc;':'\\u015d',\n'scnap;':'\\u2aba',\n'scnE;':'\\u2ab6',\n'scnsim;':'\\u22e9',\n'scpolint;':'\\u2a13',\n'scsim;':'\\u227f',\n'Scy;':'\\u0421',\n'scy;':'\\u0441',\n'sdot;':'\\u22c5',\n'sdotb;':'\\u22a1',\n'sdote;':'\\u2a66',\n'searhk;':'\\u2925',\n'seArr;':'\\u21d8',\n'searr;':'\\u2198',\n'searrow;':'\\u2198',\n'sect':'\\xa7',\n'sect;':'\\xa7',\n'semi;':';',\n'seswar;':'\\u2929',\n'setminus;':'\\u2216',\n'setmn;':'\\u2216',\n'sext;':'\\u2736',\n'Sfr;':'\\U0001d516',\n'sfr;':'\\U0001d530',\n'sfrown;':'\\u2322',\n'sharp;':'\\u266f',\n'SHCHcy;':'\\u0429',\n'shchcy;':'\\u0449',\n'SHcy;':'\\u0428',\n'shcy;':'\\u0448',\n'ShortDownArrow;':'\\u2193',\n'ShortLeftArrow;':'\\u2190',\n'shortmid;':'\\u2223',\n'shortparallel;':'\\u2225',\n'ShortRightArrow;':'\\u2192',\n'ShortUpArrow;':'\\u2191',\n'shy':'\\xad',\n'shy;':'\\xad',\n'Sigma;':'\\u03a3',\n'sigma;':'\\u03c3',\n'sigmaf;':'\\u03c2',\n'sigmav;':'\\u03c2',\n'sim;':'\\u223c',\n'simdot;':'\\u2a6a',\n'sime;':'\\u2243',\n'simeq;':'\\u2243',\n'simg;':'\\u2a9e',\n'simgE;':'\\u2aa0',\n'siml;':'\\u2a9d',\n'simlE;':'\\u2a9f',\n'simne;':'\\u2246',\n'simplus;':'\\u2a24',\n'simrarr;':'\\u2972',\n'slarr;':'\\u2190',\n'SmallCircle;':'\\u2218',\n'smallsetminus;':'\\u2216',\n'smashp;':'\\u2a33',\n'smeparsl;':'\\u29e4',\n'smid;':'\\u2223',\n'smile;':'\\u2323',\n'smt;':'\\u2aaa',\n'smte;':'\\u2aac',\n'smtes;':'\\u2aac\\ufe00',\n'SOFTcy;':'\\u042c',\n'softcy;':'\\u044c',\n'sol;':'/',\n'solb;':'\\u29c4',\n'solbar;':'\\u233f',\n'Sopf;':'\\U0001d54a',\n'sopf;':'\\U0001d564',\n'spades;':'\\u2660',\n'spadesuit;':'\\u2660',\n'spar;':'\\u2225',\n'sqcap;':'\\u2293',\n'sqcaps;':'\\u2293\\ufe00',\n'sqcup;':'\\u2294',\n'sqcups;':'\\u2294\\ufe00',\n'Sqrt;':'\\u221a',\n'sqsub;':'\\u228f',\n'sqsube;':'\\u2291',\n'sqsubset;':'\\u228f',\n'sqsubseteq;':'\\u2291',\n'sqsup;':'\\u2290',\n'sqsupe;':'\\u2292',\n'sqsupset;':'\\u2290',\n'sqsupseteq;':'\\u2292',\n'squ;':'\\u25a1',\n'Square;':'\\u25a1',\n'square;':'\\u25a1',\n'SquareIntersection;':'\\u2293',\n'SquareSubset;':'\\u228f',\n'SquareSubsetEqual;':'\\u2291',\n'SquareSuperset;':'\\u2290',\n'SquareSupersetEqual;':'\\u2292',\n'SquareUnion;':'\\u2294',\n'squarf;':'\\u25aa',\n'squf;':'\\u25aa',\n'srarr;':'\\u2192',\n'Sscr;':'\\U0001d4ae',\n'sscr;':'\\U0001d4c8',\n'ssetmn;':'\\u2216',\n'ssmile;':'\\u2323',\n'sstarf;':'\\u22c6',\n'Star;':'\\u22c6',\n'star;':'\\u2606',\n'starf;':'\\u2605',\n'straightepsilon;':'\\u03f5',\n'straightphi;':'\\u03d5',\n'strns;':'\\xaf',\n'Sub;':'\\u22d0',\n'sub;':'\\u2282',\n'subdot;':'\\u2abd',\n'subE;':'\\u2ac5',\n'sube;':'\\u2286',\n'subedot;':'\\u2ac3',\n'submult;':'\\u2ac1',\n'subnE;':'\\u2acb',\n'subne;':'\\u228a',\n'subplus;':'\\u2abf',\n'subrarr;':'\\u2979',\n'Subset;':'\\u22d0',\n'subset;':'\\u2282',\n'subseteq;':'\\u2286',\n'subseteqq;':'\\u2ac5',\n'SubsetEqual;':'\\u2286',\n'subsetneq;':'\\u228a',\n'subsetneqq;':'\\u2acb',\n'subsim;':'\\u2ac7',\n'subsub;':'\\u2ad5',\n'subsup;':'\\u2ad3',\n'succ;':'\\u227b',\n'succapprox;':'\\u2ab8',\n'succcurlyeq;':'\\u227d',\n'Succeeds;':'\\u227b',\n'SucceedsEqual;':'\\u2ab0',\n'SucceedsSlantEqual;':'\\u227d',\n'SucceedsTilde;':'\\u227f',\n'succeq;':'\\u2ab0',\n'succnapprox;':'\\u2aba',\n'succneqq;':'\\u2ab6',\n'succnsim;':'\\u22e9',\n'succsim;':'\\u227f',\n'SuchThat;':'\\u220b',\n'Sum;':'\\u2211',\n'sum;':'\\u2211',\n'sung;':'\\u266a',\n'sup1':'\\xb9',\n'sup1;':'\\xb9',\n'sup2':'\\xb2',\n'sup2;':'\\xb2',\n'sup3':'\\xb3',\n'sup3;':'\\xb3',\n'Sup;':'\\u22d1',\n'sup;':'\\u2283',\n'supdot;':'\\u2abe',\n'supdsub;':'\\u2ad8',\n'supE;':'\\u2ac6',\n'supe;':'\\u2287',\n'supedot;':'\\u2ac4',\n'Superset;':'\\u2283',\n'SupersetEqual;':'\\u2287',\n'suphsol;':'\\u27c9',\n'suphsub;':'\\u2ad7',\n'suplarr;':'\\u297b',\n'supmult;':'\\u2ac2',\n'supnE;':'\\u2acc',\n'supne;':'\\u228b',\n'supplus;':'\\u2ac0',\n'Supset;':'\\u22d1',\n'supset;':'\\u2283',\n'supseteq;':'\\u2287',\n'supseteqq;':'\\u2ac6',\n'supsetneq;':'\\u228b',\n'supsetneqq;':'\\u2acc',\n'supsim;':'\\u2ac8',\n'supsub;':'\\u2ad4',\n'supsup;':'\\u2ad6',\n'swarhk;':'\\u2926',\n'swArr;':'\\u21d9',\n'swarr;':'\\u2199',\n'swarrow;':'\\u2199',\n'swnwar;':'\\u292a',\n'szlig':'\\xdf',\n'szlig;':'\\xdf',\n'Tab;':'\\t',\n'target;':'\\u2316',\n'Tau;':'\\u03a4',\n'tau;':'\\u03c4',\n'tbrk;':'\\u23b4',\n'Tcaron;':'\\u0164',\n'tcaron;':'\\u0165',\n'Tcedil;':'\\u0162',\n'tcedil;':'\\u0163',\n'Tcy;':'\\u0422',\n'tcy;':'\\u0442',\n'tdot;':'\\u20db',\n'telrec;':'\\u2315',\n'Tfr;':'\\U0001d517',\n'tfr;':'\\U0001d531',\n'there4;':'\\u2234',\n'Therefore;':'\\u2234',\n'therefore;':'\\u2234',\n'Theta;':'\\u0398',\n'theta;':'\\u03b8',\n'thetasym;':'\\u03d1',\n'thetav;':'\\u03d1',\n'thickapprox;':'\\u2248',\n'thicksim;':'\\u223c',\n'ThickSpace;':'\\u205f\\u200a',\n'thinsp;':'\\u2009',\n'ThinSpace;':'\\u2009',\n'thkap;':'\\u2248',\n'thksim;':'\\u223c',\n'THORN':'\\xde',\n'thorn':'\\xfe',\n'THORN;':'\\xde',\n'thorn;':'\\xfe',\n'Tilde;':'\\u223c',\n'tilde;':'\\u02dc',\n'TildeEqual;':'\\u2243',\n'TildeFullEqual;':'\\u2245',\n'TildeTilde;':'\\u2248',\n'times':'\\xd7',\n'times;':'\\xd7',\n'timesb;':'\\u22a0',\n'timesbar;':'\\u2a31',\n'timesd;':'\\u2a30',\n'tint;':'\\u222d',\n'toea;':'\\u2928',\n'top;':'\\u22a4',\n'topbot;':'\\u2336',\n'topcir;':'\\u2af1',\n'Topf;':'\\U0001d54b',\n'topf;':'\\U0001d565',\n'topfork;':'\\u2ada',\n'tosa;':'\\u2929',\n'tprime;':'\\u2034',\n'TRADE;':'\\u2122',\n'trade;':'\\u2122',\n'triangle;':'\\u25b5',\n'triangledown;':'\\u25bf',\n'triangleleft;':'\\u25c3',\n'trianglelefteq;':'\\u22b4',\n'triangleq;':'\\u225c',\n'triangleright;':'\\u25b9',\n'trianglerighteq;':'\\u22b5',\n'tridot;':'\\u25ec',\n'trie;':'\\u225c',\n'triminus;':'\\u2a3a',\n'TripleDot;':'\\u20db',\n'triplus;':'\\u2a39',\n'trisb;':'\\u29cd',\n'tritime;':'\\u2a3b',\n'trpezium;':'\\u23e2',\n'Tscr;':'\\U0001d4af',\n'tscr;':'\\U0001d4c9',\n'TScy;':'\\u0426',\n'tscy;':'\\u0446',\n'TSHcy;':'\\u040b',\n'tshcy;':'\\u045b',\n'Tstrok;':'\\u0166',\n'tstrok;':'\\u0167',\n'twixt;':'\\u226c',\n'twoheadleftarrow;':'\\u219e',\n'twoheadrightarrow;':'\\u21a0',\n'Uacute':'\\xda',\n'uacute':'\\xfa',\n'Uacute;':'\\xda',\n'uacute;':'\\xfa',\n'Uarr;':'\\u219f',\n'uArr;':'\\u21d1',\n'uarr;':'\\u2191',\n'Uarrocir;':'\\u2949',\n'Ubrcy;':'\\u040e',\n'ubrcy;':'\\u045e',\n'Ubreve;':'\\u016c',\n'ubreve;':'\\u016d',\n'Ucirc':'\\xdb',\n'ucirc':'\\xfb',\n'Ucirc;':'\\xdb',\n'ucirc;':'\\xfb',\n'Ucy;':'\\u0423',\n'ucy;':'\\u0443',\n'udarr;':'\\u21c5',\n'Udblac;':'\\u0170',\n'udblac;':'\\u0171',\n'udhar;':'\\u296e',\n'ufisht;':'\\u297e',\n'Ufr;':'\\U0001d518',\n'ufr;':'\\U0001d532',\n'Ugrave':'\\xd9',\n'ugrave':'\\xf9',\n'Ugrave;':'\\xd9',\n'ugrave;':'\\xf9',\n'uHar;':'\\u2963',\n'uharl;':'\\u21bf',\n'uharr;':'\\u21be',\n'uhblk;':'\\u2580',\n'ulcorn;':'\\u231c',\n'ulcorner;':'\\u231c',\n'ulcrop;':'\\u230f',\n'ultri;':'\\u25f8',\n'Umacr;':'\\u016a',\n'umacr;':'\\u016b',\n'uml':'\\xa8',\n'uml;':'\\xa8',\n'UnderBar;':'_',\n'UnderBrace;':'\\u23df',\n'UnderBracket;':'\\u23b5',\n'UnderParenthesis;':'\\u23dd',\n'Union;':'\\u22c3',\n'UnionPlus;':'\\u228e',\n'Uogon;':'\\u0172',\n'uogon;':'\\u0173',\n'Uopf;':'\\U0001d54c',\n'uopf;':'\\U0001d566',\n'UpArrow;':'\\u2191',\n'Uparrow;':'\\u21d1',\n'uparrow;':'\\u2191',\n'UpArrowBar;':'\\u2912',\n'UpArrowDownArrow;':'\\u21c5',\n'UpDownArrow;':'\\u2195',\n'Updownarrow;':'\\u21d5',\n'updownarrow;':'\\u2195',\n'UpEquilibrium;':'\\u296e',\n'upharpoonleft;':'\\u21bf',\n'upharpoonright;':'\\u21be',\n'uplus;':'\\u228e',\n'UpperLeftArrow;':'\\u2196',\n'UpperRightArrow;':'\\u2197',\n'Upsi;':'\\u03d2',\n'upsi;':'\\u03c5',\n'upsih;':'\\u03d2',\n'Upsilon;':'\\u03a5',\n'upsilon;':'\\u03c5',\n'UpTee;':'\\u22a5',\n'UpTeeArrow;':'\\u21a5',\n'upuparrows;':'\\u21c8',\n'urcorn;':'\\u231d',\n'urcorner;':'\\u231d',\n'urcrop;':'\\u230e',\n'Uring;':'\\u016e',\n'uring;':'\\u016f',\n'urtri;':'\\u25f9',\n'Uscr;':'\\U0001d4b0',\n'uscr;':'\\U0001d4ca',\n'utdot;':'\\u22f0',\n'Utilde;':'\\u0168',\n'utilde;':'\\u0169',\n'utri;':'\\u25b5',\n'utrif;':'\\u25b4',\n'uuarr;':'\\u21c8',\n'Uuml':'\\xdc',\n'uuml':'\\xfc',\n'Uuml;':'\\xdc',\n'uuml;':'\\xfc',\n'uwangle;':'\\u29a7',\n'vangrt;':'\\u299c',\n'varepsilon;':'\\u03f5',\n'varkappa;':'\\u03f0',\n'varnothing;':'\\u2205',\n'varphi;':'\\u03d5',\n'varpi;':'\\u03d6',\n'varpropto;':'\\u221d',\n'vArr;':'\\u21d5',\n'varr;':'\\u2195',\n'varrho;':'\\u03f1',\n'varsigma;':'\\u03c2',\n'varsubsetneq;':'\\u228a\\ufe00',\n'varsubsetneqq;':'\\u2acb\\ufe00',\n'varsupsetneq;':'\\u228b\\ufe00',\n'varsupsetneqq;':'\\u2acc\\ufe00',\n'vartheta;':'\\u03d1',\n'vartriangleleft;':'\\u22b2',\n'vartriangleright;':'\\u22b3',\n'Vbar;':'\\u2aeb',\n'vBar;':'\\u2ae8',\n'vBarv;':'\\u2ae9',\n'Vcy;':'\\u0412',\n'vcy;':'\\u0432',\n'VDash;':'\\u22ab',\n'Vdash;':'\\u22a9',\n'vDash;':'\\u22a8',\n'vdash;':'\\u22a2',\n'Vdashl;':'\\u2ae6',\n'Vee;':'\\u22c1',\n'vee;':'\\u2228',\n'veebar;':'\\u22bb',\n'veeeq;':'\\u225a',\n'vellip;':'\\u22ee',\n'Verbar;':'\\u2016',\n'verbar;':'|',\n'Vert;':'\\u2016',\n'vert;':'|',\n'VerticalBar;':'\\u2223',\n'VerticalLine;':'|',\n'VerticalSeparator;':'\\u2758',\n'VerticalTilde;':'\\u2240',\n'VeryThinSpace;':'\\u200a',\n'Vfr;':'\\U0001d519',\n'vfr;':'\\U0001d533',\n'vltri;':'\\u22b2',\n'vnsub;':'\\u2282\\u20d2',\n'vnsup;':'\\u2283\\u20d2',\n'Vopf;':'\\U0001d54d',\n'vopf;':'\\U0001d567',\n'vprop;':'\\u221d',\n'vrtri;':'\\u22b3',\n'Vscr;':'\\U0001d4b1',\n'vscr;':'\\U0001d4cb',\n'vsubnE;':'\\u2acb\\ufe00',\n'vsubne;':'\\u228a\\ufe00',\n'vsupnE;':'\\u2acc\\ufe00',\n'vsupne;':'\\u228b\\ufe00',\n'Vvdash;':'\\u22aa',\n'vzigzag;':'\\u299a',\n'Wcirc;':'\\u0174',\n'wcirc;':'\\u0175',\n'wedbar;':'\\u2a5f',\n'Wedge;':'\\u22c0',\n'wedge;':'\\u2227',\n'wedgeq;':'\\u2259',\n'weierp;':'\\u2118',\n'Wfr;':'\\U0001d51a',\n'wfr;':'\\U0001d534',\n'Wopf;':'\\U0001d54e',\n'wopf;':'\\U0001d568',\n'wp;':'\\u2118',\n'wr;':'\\u2240',\n'wreath;':'\\u2240',\n'Wscr;':'\\U0001d4b2',\n'wscr;':'\\U0001d4cc',\n'xcap;':'\\u22c2',\n'xcirc;':'\\u25ef',\n'xcup;':'\\u22c3',\n'xdtri;':'\\u25bd',\n'Xfr;':'\\U0001d51b',\n'xfr;':'\\U0001d535',\n'xhArr;':'\\u27fa',\n'xharr;':'\\u27f7',\n'Xi;':'\\u039e',\n'xi;':'\\u03be',\n'xlArr;':'\\u27f8',\n'xlarr;':'\\u27f5',\n'xmap;':'\\u27fc',\n'xnis;':'\\u22fb',\n'xodot;':'\\u2a00',\n'Xopf;':'\\U0001d54f',\n'xopf;':'\\U0001d569',\n'xoplus;':'\\u2a01',\n'xotime;':'\\u2a02',\n'xrArr;':'\\u27f9',\n'xrarr;':'\\u27f6',\n'Xscr;':'\\U0001d4b3',\n'xscr;':'\\U0001d4cd',\n'xsqcup;':'\\u2a06',\n'xuplus;':'\\u2a04',\n'xutri;':'\\u25b3',\n'xvee;':'\\u22c1',\n'xwedge;':'\\u22c0',\n'Yacute':'\\xdd',\n'yacute':'\\xfd',\n'Yacute;':'\\xdd',\n'yacute;':'\\xfd',\n'YAcy;':'\\u042f',\n'yacy;':'\\u044f',\n'Ycirc;':'\\u0176',\n'ycirc;':'\\u0177',\n'Ycy;':'\\u042b',\n'ycy;':'\\u044b',\n'yen':'\\xa5',\n'yen;':'\\xa5',\n'Yfr;':'\\U0001d51c',\n'yfr;':'\\U0001d536',\n'YIcy;':'\\u0407',\n'yicy;':'\\u0457',\n'Yopf;':'\\U0001d550',\n'yopf;':'\\U0001d56a',\n'Yscr;':'\\U0001d4b4',\n'yscr;':'\\U0001d4ce',\n'YUcy;':'\\u042e',\n'yucy;':'\\u044e',\n'yuml':'\\xff',\n'Yuml;':'\\u0178',\n'yuml;':'\\xff',\n'Zacute;':'\\u0179',\n'zacute;':'\\u017a',\n'Zcaron;':'\\u017d',\n'zcaron;':'\\u017e',\n'Zcy;':'\\u0417',\n'zcy;':'\\u0437',\n'Zdot;':'\\u017b',\n'zdot;':'\\u017c',\n'zeetrf;':'\\u2128',\n'ZeroWidthSpace;':'\\u200b',\n'Zeta;':'\\u0396',\n'zeta;':'\\u03b6',\n'Zfr;':'\\u2128',\n'zfr;':'\\U0001d537',\n'ZHcy;':'\\u0416',\n'zhcy;':'\\u0436',\n'zigrarr;':'\\u21dd',\n'Zopf;':'\\u2124',\n'zopf;':'\\U0001d56b',\n'Zscr;':'\\U0001d4b5',\n'zscr;':'\\U0001d4cf',\n'zwj;':'\\u200d',\n'zwnj;':'\\u200c',\n}\n\n\ncodepoint2name={}\n\n\n\nentitydefs={}\n\nfor (name,codepoint)in name2codepoint.items():\n codepoint2name[codepoint]=name\n entitydefs[name]=chr(codepoint)\n \ndel name,codepoint\n", []],
     "html.parser": [".py", "''\n\n\n\n\n\n\n\n\n\nimport re\nimport _markupbase\n\nfrom html import unescape\n\n\n__all__=['HTMLParser']\n\n\n\ninteresting_normal=re.compile('[&<]')\nincomplete=re.compile('&[a-zA-Z#]')\n\nentityref=re.compile('&([a-zA-Z][-.a-zA-Z0-9]*)[^a-zA-Z0-9]')\ncharref=re.compile('&#(?:[0-9]+|[xX][0-9a-fA-F]+)[^0-9a-fA-F]')\n\nstarttagopen=re.compile('<[a-zA-Z]')\npiclose=re.compile('>')\ncommentclose=re.compile(r'--\\s*>')\n\n\n\n\n\n\ntagfind_tolerant=re.compile(r'([a-zA-Z][^\\t\\n\\r\\f />\\x00]*)(?:\\s|/(?!>))*')\nattrfind_tolerant=re.compile(\nr'((?<=[\\'\"\\s/])[^\\s/>][^\\s/=>]*)(\\s*=+\\s*'\nr'(\\'[^\\']*\\'|\"[^\"]*\"|(?![\\'\"])[^>\\s]*))?(?:\\s|/(?!>))*')\nlocatestarttagend_tolerant=re.compile(r\"\"\"\n  <[a-zA-Z][^\\t\\n\\r\\f />\\x00]*       # tag name\n  (?:[\\s/]*                          # optional whitespace before attribute name\n    (?:(?<=['\"\\s/])[^\\s/>][^\\s/=>]*  # attribute name\n      (?:\\s*=+\\s*                    # value indicator\n        (?:'[^']*'                   # LITA-enclosed value\n          |\"[^\"]*\"                   # LIT-enclosed value\n          |(?!['\"])[^>\\s]*           # bare value\n         )\n         (?:\\s*,)*                   # possibly followed by a comma\n       )?(?:\\s|/(?!>))*\n     )*\n   )?\n  \\s*                                # trailing whitespace\n\"\"\",re.VERBOSE)\nendendtag=re.compile('>')\n\n\nendtagfind=re.compile(r'</\\s*([a-zA-Z][-.a-zA-Z0-9:_]*)\\s*>')\n\n\n\nclass HTMLParser(_markupbase.ParserBase):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n CDATA_CONTENT_ELEMENTS=(\"script\",\"style\")\n \n def __init__(self,*,convert_charrefs=True ):\n  ''\n\n\n\n  \n  self.convert_charrefs=convert_charrefs\n  self.reset()\n  \n def reset(self):\n  ''\n  self.rawdata=''\n  self.lasttag='???'\n  self.interesting=interesting_normal\n  self.cdata_elem=None\n  _markupbase.ParserBase.reset(self)\n  \n def feed(self,data):\n  ''\n\n\n\n  \n  self.rawdata=self.rawdata+data\n  self.goahead(0)\n  \n def close(self):\n  ''\n  self.goahead(1)\n  \n __starttag_text=None\n \n def get_starttag_text(self):\n  ''\n  return self.__starttag_text\n  \n def set_cdata_mode(self,elem):\n  self.cdata_elem=elem.lower()\n  self.interesting=re.compile(r'</\\s*%s\\s*>'%self.cdata_elem,re.I)\n  \n def clear_cdata_mode(self):\n  self.interesting=interesting_normal\n  self.cdata_elem=None\n  \n  \n  \n  \n def goahead(self,end):\n  rawdata=self.rawdata\n  i=0\n  n=len(rawdata)\n  while i <n:\n   if self.convert_charrefs and not self.cdata_elem:\n    j=rawdata.find('<',i)\n    if j <0:\n    \n    \n    \n    \n    \n    \n     amppos=rawdata.rfind('&',max(i,n -34))\n     if (amppos >=0 and\n     not re.compile(r'[\\s;]').search(rawdata,amppos)):\n      break\n     j=n\n   else :\n    match=self.interesting.search(rawdata,i)\n    if match:\n     j=match.start()\n    else :\n     if self.cdata_elem:\n      break\n     j=n\n   if i <j:\n    if self.convert_charrefs and not self.cdata_elem:\n     self.handle_data(unescape(rawdata[i:j]))\n    else :\n     self.handle_data(rawdata[i:j])\n   i=self.updatepos(i,j)\n   if i ==n:break\n   startswith=rawdata.startswith\n   if startswith('<',i):\n    if starttagopen.match(rawdata,i):\n     k=self.parse_starttag(i)\n    elif startswith(\"</\",i):\n     k=self.parse_endtag(i)\n    elif startswith(\"<!--\",i):\n     k=self.parse_comment(i)\n    elif startswith(\"<?\",i):\n     k=self.parse_pi(i)\n    elif startswith(\"<!\",i):\n     k=self.parse_html_declaration(i)\n    elif (i+1)<n:\n     self.handle_data(\"<\")\n     k=i+1\n    else :\n     break\n    if k <0:\n     if not end:\n      break\n     k=rawdata.find('>',i+1)\n     if k <0:\n      k=rawdata.find('<',i+1)\n      if k <0:\n       k=i+1\n     else :\n      k +=1\n     if self.convert_charrefs and not self.cdata_elem:\n      self.handle_data(unescape(rawdata[i:k]))\n     else :\n      self.handle_data(rawdata[i:k])\n    i=self.updatepos(i,k)\n   elif startswith(\"&#\",i):\n    match=charref.match(rawdata,i)\n    if match:\n     name=match.group()[2:-1]\n     self.handle_charref(name)\n     k=match.end()\n     if not startswith(';',k -1):\n      k=k -1\n     i=self.updatepos(i,k)\n     continue\n    else :\n     if \";\"in rawdata[i:]:\n      self.handle_data(rawdata[i:i+2])\n      i=self.updatepos(i,i+2)\n     break\n   elif startswith('&',i):\n    match=entityref.match(rawdata,i)\n    if match:\n     name=match.group(1)\n     self.handle_entityref(name)\n     k=match.end()\n     if not startswith(';',k -1):\n      k=k -1\n     i=self.updatepos(i,k)\n     continue\n    match=incomplete.match(rawdata,i)\n    if match:\n    \n     if end and match.group()==rawdata[i:]:\n      k=match.end()\n      if k <=i:\n       k=n\n      i=self.updatepos(i,i+1)\n      \n     break\n    elif (i+1)<n:\n    \n    \n     self.handle_data(\"&\")\n     i=self.updatepos(i,i+1)\n    else :\n     break\n   else :\n    assert 0,\"interesting.search() lied\"\n    \n  if end and i <n and not self.cdata_elem:\n   if self.convert_charrefs and not self.cdata_elem:\n    self.handle_data(unescape(rawdata[i:n]))\n   else :\n    self.handle_data(rawdata[i:n])\n   i=self.updatepos(i,n)\n  self.rawdata=rawdata[i:]\n  \n  \n  \n  \n def parse_html_declaration(self,i):\n  rawdata=self.rawdata\n  assert rawdata[i:i+2]=='<!',('unexpected call to '\n  'parse_html_declaration()')\n  if rawdata[i:i+4]=='<!--':\n  \n   return self.parse_comment(i)\n  elif rawdata[i:i+3]=='<![':\n   return self.parse_marked_section(i)\n  elif rawdata[i:i+9].lower()=='<!doctype':\n  \n   gtpos=rawdata.find('>',i+9)\n   if gtpos ==-1:\n    return -1\n   self.handle_decl(rawdata[i+2:gtpos])\n   return gtpos+1\n  else :\n   return self.parse_bogus_comment(i)\n   \n   \n   \n def parse_bogus_comment(self,i,report=1):\n  rawdata=self.rawdata\n  assert rawdata[i:i+2]in ('<!','</'),('unexpected call to '\n  'parse_comment()')\n  pos=rawdata.find('>',i+2)\n  if pos ==-1:\n   return -1\n  if report:\n   self.handle_comment(rawdata[i+2:pos])\n  return pos+1\n  \n  \n def parse_pi(self,i):\n  rawdata=self.rawdata\n  assert rawdata[i:i+2]=='<?','unexpected call to parse_pi()'\n  match=piclose.search(rawdata,i+2)\n  if not match:\n   return -1\n  j=match.start()\n  self.handle_pi(rawdata[i+2:j])\n  j=match.end()\n  return j\n  \n  \n def parse_starttag(self,i):\n  self.__starttag_text=None\n  endpos=self.check_for_whole_start_tag(i)\n  if endpos <0:\n   return endpos\n  rawdata=self.rawdata\n  self.__starttag_text=rawdata[i:endpos]\n  \n  \n  attrs=[]\n  match=tagfind_tolerant.match(rawdata,i+1)\n  assert match,'unexpected call to parse_starttag()'\n  k=match.end()\n  self.lasttag=tag=match.group(1).lower()\n  while k <endpos:\n   m=attrfind_tolerant.match(rawdata,k)\n   if not m:\n    break\n   attrname,rest,attrvalue=m.group(1,2,3)\n   if not rest:\n    attrvalue=None\n   elif attrvalue[:1]=='\\''==attrvalue[-1:]or\\\n   attrvalue[:1]=='\"'==attrvalue[-1:]:\n    attrvalue=attrvalue[1:-1]\n   if attrvalue:\n    attrvalue=unescape(attrvalue)\n   attrs.append((attrname.lower(),attrvalue))\n   k=m.end()\n   \n  end=rawdata[k:endpos].strip()\n  if end not in (\">\",\"/>\"):\n   lineno,offset=self.getpos()\n   if \"\\n\"in self.__starttag_text:\n    lineno=lineno+self.__starttag_text.count(\"\\n\")\n    offset=len(self.__starttag_text)\\\n    -self.__starttag_text.rfind(\"\\n\")\n   else :\n    offset=offset+len(self.__starttag_text)\n   self.handle_data(rawdata[i:endpos])\n   return endpos\n  if end.endswith('/>'):\n  \n   self.handle_startendtag(tag,attrs)\n  else :\n   self.handle_starttag(tag,attrs)\n   if tag in self.CDATA_CONTENT_ELEMENTS:\n    self.set_cdata_mode(tag)\n  return endpos\n  \n  \n  \n def check_for_whole_start_tag(self,i):\n  rawdata=self.rawdata\n  m=locatestarttagend_tolerant.match(rawdata,i)\n  if m:\n   j=m.end()\n   next=rawdata[j:j+1]\n   if next ==\">\":\n    return j+1\n   if next ==\"/\":\n    if rawdata.startswith(\"/>\",j):\n     return j+2\n    if rawdata.startswith(\"/\",j):\n    \n     return -1\n     \n    if j >i:\n     return j\n    else :\n     return i+1\n   if next ==\"\":\n   \n    return -1\n   if next in (\"abcdefghijklmnopqrstuvwxyz=/\"\n   \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"):\n   \n   \n    return -1\n   if j >i:\n    return j\n   else :\n    return i+1\n  raise AssertionError(\"we should not get here!\")\n  \n  \n def parse_endtag(self,i):\n  rawdata=self.rawdata\n  assert rawdata[i:i+2]==\"</\",\"unexpected call to parse_endtag\"\n  match=endendtag.search(rawdata,i+1)\n  if not match:\n   return -1\n  gtpos=match.end()\n  match=endtagfind.match(rawdata,i)\n  if not match:\n   if self.cdata_elem is not None :\n    self.handle_data(rawdata[i:gtpos])\n    return gtpos\n    \n   namematch=tagfind_tolerant.match(rawdata,i+2)\n   if not namematch:\n   \n    if rawdata[i:i+3]=='</>':\n     return i+3\n    else :\n     return self.parse_bogus_comment(i)\n   tagname=namematch.group(1).lower()\n   \n   \n   \n   \n   gtpos=rawdata.find('>',namematch.end())\n   self.handle_endtag(tagname)\n   return gtpos+1\n   \n  elem=match.group(1).lower()\n  if self.cdata_elem is not None :\n   if elem !=self.cdata_elem:\n    self.handle_data(rawdata[i:gtpos])\n    return gtpos\n    \n  self.handle_endtag(elem)\n  self.clear_cdata_mode()\n  return gtpos\n  \n  \n def handle_startendtag(self,tag,attrs):\n  self.handle_starttag(tag,attrs)\n  self.handle_endtag(tag)\n  \n  \n def handle_starttag(self,tag,attrs):\n  pass\n  \n  \n def handle_endtag(self,tag):\n  pass\n  \n  \n def handle_charref(self,name):\n  pass\n  \n  \n def handle_entityref(self,name):\n  pass\n  \n  \n def handle_data(self,data):\n  pass\n  \n  \n def handle_comment(self,data):\n  pass\n  \n  \n def handle_decl(self,decl):\n  pass\n  \n  \n def handle_pi(self,data):\n  pass\n  \n def unknown_decl(self,data):\n  pass\n", ["_markupbase", "html", "re"]],
     "html": [".py", "''\n\n\n\nimport re as _re\nfrom html.entities import html5 as _html5\n\n\n__all__=['escape','unescape']\n\n\ndef escape(s,quote=True ):\n ''\n\n\n\n\n \n s=s.replace(\"&\",\"&amp;\")\n s=s.replace(\"<\",\"&lt;\")\n s=s.replace(\">\",\"&gt;\")\n if quote:\n  s=s.replace('\"',\"&quot;\")\n  s=s.replace('\\'',\"&#x27;\")\n return s\n \n \n \n \n_invalid_charrefs={\n0x00:'\\ufffd',\n0x0d:'\\r',\n0x80:'\\u20ac',\n0x81:'\\x81',\n0x82:'\\u201a',\n0x83:'\\u0192',\n0x84:'\\u201e',\n0x85:'\\u2026',\n0x86:'\\u2020',\n0x87:'\\u2021',\n0x88:'\\u02c6',\n0x89:'\\u2030',\n0x8a:'\\u0160',\n0x8b:'\\u2039',\n0x8c:'\\u0152',\n0x8d:'\\x8d',\n0x8e:'\\u017d',\n0x8f:'\\x8f',\n0x90:'\\x90',\n0x91:'\\u2018',\n0x92:'\\u2019',\n0x93:'\\u201c',\n0x94:'\\u201d',\n0x95:'\\u2022',\n0x96:'\\u2013',\n0x97:'\\u2014',\n0x98:'\\u02dc',\n0x99:'\\u2122',\n0x9a:'\\u0161',\n0x9b:'\\u203a',\n0x9c:'\\u0153',\n0x9d:'\\x9d',\n0x9e:'\\u017e',\n0x9f:'\\u0178',\n}\n\n_invalid_codepoints={\n\n0x1,0x2,0x3,0x4,0x5,0x6,0x7,0x8,\n\n0xe,0xf,0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,\n0x1a,0x1b,0x1c,0x1d,0x1e,0x1f,\n\n0x7f,0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8a,\n0x8b,0x8c,0x8d,0x8e,0x8f,0x90,0x91,0x92,0x93,0x94,0x95,0x96,\n0x97,0x98,0x99,0x9a,0x9b,0x9c,0x9d,0x9e,0x9f,\n\n0xfdd0,0xfdd1,0xfdd2,0xfdd3,0xfdd4,0xfdd5,0xfdd6,0xfdd7,0xfdd8,\n0xfdd9,0xfdda,0xfddb,0xfddc,0xfddd,0xfdde,0xfddf,0xfde0,0xfde1,\n0xfde2,0xfde3,0xfde4,0xfde5,0xfde6,0xfde7,0xfde8,0xfde9,0xfdea,\n0xfdeb,0xfdec,0xfded,0xfdee,0xfdef,\n\n0xb,0xfffe,0xffff,0x1fffe,0x1ffff,0x2fffe,0x2ffff,0x3fffe,0x3ffff,\n0x4fffe,0x4ffff,0x5fffe,0x5ffff,0x6fffe,0x6ffff,0x7fffe,0x7ffff,\n0x8fffe,0x8ffff,0x9fffe,0x9ffff,0xafffe,0xaffff,0xbfffe,0xbffff,\n0xcfffe,0xcffff,0xdfffe,0xdffff,0xefffe,0xeffff,0xffffe,0xfffff,\n0x10fffe,0x10ffff\n}\n\n\ndef _replace_charref(s):\n s=s.group(1)\n if s[0]=='#':\n \n  if s[1]in 'xX':\n   num=int(s[2:].rstrip(';'),16)\n  else :\n   num=int(s[1:].rstrip(';'))\n  if num in _invalid_charrefs:\n   return _invalid_charrefs[num]\n  if 0xD800 <=num <=0xDFFF or num >0x10FFFF:\n   return '\\uFFFD'\n  if num in _invalid_codepoints:\n   return ''\n  return chr(num)\n else :\n \n  if s in _html5:\n   return _html5[s]\n   \n  for x in range(len(s)-1,1,-1):\n   if s[:x]in _html5:\n    return _html5[s[:x]]+s[x:]\n  else :\n   return '&'+s\n   \n   \n_charref=_re.compile(r'&(#[0-9]+;?'\nr'|#[xX][0-9a-fA-F]+;?'\nr'|[^\\t\\n\\f <&#;]{1,32};?)')\n\ndef unescape(s):\n ''\n\n\n\n\n\n \n if '&'not in s:\n  return s\n return _charref.sub(_replace_charref,s)\n", ["html.entities", "re"], 1],
     "http.client": [".py", "''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nimport email.parser\nimport email.message\nimport http\nimport io\nimport re\nimport socket\nimport collections.abc\nfrom urllib.parse import urlsplit\n\n\n\n__all__=[\"HTTPResponse\",\"HTTPConnection\",\n\"HTTPException\",\"NotConnected\",\"UnknownProtocol\",\n\"UnknownTransferEncoding\",\"UnimplementedFileMode\",\n\"IncompleteRead\",\"InvalidURL\",\"ImproperConnectionState\",\n\"CannotSendRequest\",\"CannotSendHeader\",\"ResponseNotReady\",\n\"BadStatusLine\",\"LineTooLong\",\"RemoteDisconnected\",\"error\",\n\"responses\"]\n\nHTTP_PORT=80\nHTTPS_PORT=443\n\n_UNKNOWN='UNKNOWN'\n\n\n_CS_IDLE='Idle'\n_CS_REQ_STARTED='Request-started'\n_CS_REQ_SENT='Request-sent'\n\n\n\nglobals().update(http.HTTPStatus.__members__)\n\n\n\nresponses={v:v.phrase for v in http.HTTPStatus.__members__.values()}\n\n\n_MAXLINE=65536\n_MAXHEADERS=100\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n_is_legal_header_name=re.compile(rb'[^:\\s][^:\\r\\n]*').fullmatch\n_is_illegal_header_value=re.compile(rb'\\n(?![ \\t])|\\r(?![ \\t\\n])').search\n\n\n\n\n\n\n_contains_disallowed_url_pchar_re=re.compile('[\\x00-\\x20\\x7f]')\n\n\n\n\n\n\n_contains_disallowed_method_pchar_re=re.compile('[\\x00-\\x1f]')\n\n\n\n_METHODS_EXPECTING_BODY={'PATCH','POST','PUT'}\n\n\ndef _encode(data,name='data'):\n ''\n try :\n  return data.encode(\"latin-1\")\n except UnicodeEncodeError as err:\n  raise UnicodeEncodeError(\n  err.encoding,\n  err.object,\n  err.start,\n  err.end,\n  \"%s (%.20r) is not valid Latin-1. Use %s.encode('utf-8') \"\n  \"if you want to send it encoded in UTF-8.\"%\n  (name.title(),data[err.start:err.end],name))from None\n  \n  \nclass HTTPMessage(email.message.Message):\n\n\n\n\n\n\n def getallmatchingheaders(self,name):\n  ''\n\n\n\n\n\n\n\n  \n  name=name.lower()+':'\n  n=len(name)\n  lst=[]\n  hit=0\n  for line in self.keys():\n   if line[:n].lower()==name:\n    hit=1\n   elif not line[:1].isspace():\n    hit=0\n   if hit:\n    lst.append(line)\n  return lst\n  \ndef parse_headers(fp,_class=HTTPMessage):\n ''\n\n\n\n\n\n\n\n \n headers=[]\n while True :\n  line=fp.readline(_MAXLINE+1)\n  if len(line)>_MAXLINE:\n   raise LineTooLong(\"header line\")\n  headers.append(line)\n  if len(headers)>_MAXHEADERS:\n   raise HTTPException(\"got more than %d headers\"%_MAXHEADERS)\n  if line in (b'\\r\\n',b'\\n',b''):\n   break\n hstring=b''.join(headers).decode('iso-8859-1')\n return email.parser.Parser(_class=_class).parsestr(hstring)\n \n \nclass HTTPResponse(io.BufferedIOBase):\n\n\n\n\n\n\n\n\n def __init__(self,sock,debuglevel=0,method=None ,url=None ):\n \n \n \n \n \n \n \n  self.fp=sock.makefile(\"rb\")\n  self.debuglevel=debuglevel\n  self._method=method\n  \n  \n  \n  \n  \n  \n  \n  self.headers=self.msg=None\n  \n  \n  self.version=_UNKNOWN\n  self.status=_UNKNOWN\n  self.reason=_UNKNOWN\n  \n  self.chunked=_UNKNOWN\n  self.chunk_left=_UNKNOWN\n  self.length=_UNKNOWN\n  self.will_close=_UNKNOWN\n  \n def _read_status(self):\n  line=str(self.fp.readline(_MAXLINE+1),\"iso-8859-1\")\n  if len(line)>_MAXLINE:\n   raise LineTooLong(\"status line\")\n  if self.debuglevel >0:\n   print(\"reply:\",repr(line))\n  if not line:\n  \n  \n   raise RemoteDisconnected(\"Remote end closed connection without\"\n   \" response\")\n  try :\n   version,status,reason=line.split(None ,2)\n  except ValueError:\n   try :\n    version,status=line.split(None ,1)\n    reason=\"\"\n   except ValueError:\n   \n    version=\"\"\n  if not version.startswith(\"HTTP/\"):\n   self._close_conn()\n   raise BadStatusLine(line)\n   \n   \n  try :\n   status=int(status)\n   if status <100 or status >999:\n    raise BadStatusLine(line)\n  except ValueError:\n   raise BadStatusLine(line)\n  return version,status,reason\n  \n def begin(self):\n  if self.headers is not None :\n  \n   return\n   \n   \n  while True :\n   version,status,reason=self._read_status()\n   if status !=CONTINUE:\n    break\n    \n   while True :\n    skip=self.fp.readline(_MAXLINE+1)\n    if len(skip)>_MAXLINE:\n     raise LineTooLong(\"header line\")\n    skip=skip.strip()\n    if not skip:\n     break\n    if self.debuglevel >0:\n     print(\"header:\",skip)\n     \n  self.code=self.status=status\n  self.reason=reason.strip()\n  if version in (\"HTTP/1.0\",\"HTTP/0.9\"):\n  \n   self.version=10\n  elif version.startswith(\"HTTP/1.\"):\n   self.version=11\n  else :\n   raise UnknownProtocol(version)\n   \n  self.headers=self.msg=parse_headers(self.fp)\n  \n  if self.debuglevel >0:\n   for hdr,val in self.headers.items():\n    print(\"header:\",hdr+\":\",val)\n    \n    \n  tr_enc=self.headers.get(\"transfer-encoding\")\n  if tr_enc and tr_enc.lower()==\"chunked\":\n   self.chunked=True\n   self.chunk_left=None\n  else :\n   self.chunked=False\n   \n   \n  self.will_close=self._check_close()\n  \n  \n  \n  self.length=None\n  length=self.headers.get(\"content-length\")\n  \n  \n  tr_enc=self.headers.get(\"transfer-encoding\")\n  if length and not self.chunked:\n   try :\n    self.length=int(length)\n   except ValueError:\n    self.length=None\n   else :\n    if self.length <0:\n     self.length=None\n  else :\n   self.length=None\n   \n   \n  if (status ==NO_CONTENT or status ==NOT_MODIFIED or\n  100 <=status <200 or\n  self._method ==\"HEAD\"):\n   self.length=0\n   \n   \n   \n   \n  if (not self.will_close and\n  not self.chunked and\n  self.length is None ):\n   self.will_close=True\n   \n def _check_close(self):\n  conn=self.headers.get(\"connection\")\n  if self.version ==11:\n  \n  \n   if conn and \"close\"in conn.lower():\n    return True\n   return False\n   \n   \n   \n   \n   \n  if self.headers.get(\"keep-alive\"):\n   return False\n   \n   \n   \n  if conn and \"keep-alive\"in conn.lower():\n   return False\n   \n   \n  pconn=self.headers.get(\"proxy-connection\")\n  if pconn and \"keep-alive\"in pconn.lower():\n   return False\n   \n   \n  return True\n  \n def _close_conn(self):\n  fp=self.fp\n  self.fp=None\n  fp.close()\n  \n def close(self):\n  try :\n   super().close()\n  finally :\n   if self.fp:\n    self._close_conn()\n    \n    \n    \n    \n    \n    \n def flush(self):\n  super().flush()\n  if self.fp:\n   self.fp.flush()\n   \n def readable(self):\n  ''\n  return True\n  \n  \n  \n def isclosed(self):\n  ''\n  \n  \n  \n  \n  \n  \n  return self.fp is None\n  \n def read(self,amt=None ):\n  if self.fp is None :\n   return b\"\"\n   \n  if self._method ==\"HEAD\":\n   self._close_conn()\n   return b\"\"\n   \n  if amt is not None :\n  \n   b=bytearray(amt)\n   n=self.readinto(b)\n   return memoryview(b)[:n].tobytes()\n  else :\n  \n  \n  \n   if self.chunked:\n    return self._readall_chunked()\n    \n   if self.length is None :\n    s=self.fp.read()\n   else :\n    try :\n     s=self._safe_read(self.length)\n    except IncompleteRead:\n     self._close_conn()\n     raise\n    self.length=0\n   self._close_conn()\n   return s\n   \n def readinto(self,b):\n  ''\n\n  \n  \n  if self.fp is None :\n   return 0\n   \n  if self._method ==\"HEAD\":\n   self._close_conn()\n   return 0\n   \n  if self.chunked:\n   return self._readinto_chunked(b)\n   \n  if self.length is not None :\n   if len(b)>self.length:\n   \n    b=memoryview(b)[0:self.length]\n    \n    \n    \n    \n  n=self.fp.readinto(b)\n  if not n and b:\n  \n  \n   self._close_conn()\n  elif self.length is not None :\n   self.length -=n\n   if not self.length:\n    self._close_conn()\n  return n\n  \n def _read_next_chunk_size(self):\n \n  line=self.fp.readline(_MAXLINE+1)\n  if len(line)>_MAXLINE:\n   raise LineTooLong(\"chunk size\")\n  i=line.find(b\";\")\n  if i >=0:\n   line=line[:i]\n  try :\n   return int(line,16)\n  except ValueError:\n  \n  \n   self._close_conn()\n   raise\n   \n def _read_and_discard_trailer(self):\n \n \n  while True :\n   line=self.fp.readline(_MAXLINE+1)\n   if len(line)>_MAXLINE:\n    raise LineTooLong(\"trailer line\")\n   if not line:\n   \n   \n    break\n   if line in (b'\\r\\n',b'\\n',b''):\n    break\n    \n def _get_chunk_left(self):\n \n \n \n \n \n  chunk_left=self.chunk_left\n  if not chunk_left:\n   if chunk_left is not None :\n   \n    self._safe_read(2)\n   try :\n    chunk_left=self._read_next_chunk_size()\n   except ValueError:\n    raise IncompleteRead(b'')\n   if chunk_left ==0:\n   \n    self._read_and_discard_trailer()\n    \n    self._close_conn()\n    chunk_left=None\n   self.chunk_left=chunk_left\n  return chunk_left\n  \n def _readall_chunked(self):\n  assert self.chunked !=_UNKNOWN\n  value=[]\n  try :\n   while True :\n    chunk_left=self._get_chunk_left()\n    if chunk_left is None :\n     break\n    value.append(self._safe_read(chunk_left))\n    self.chunk_left=0\n   return b''.join(value)\n  except IncompleteRead:\n   raise IncompleteRead(b''.join(value))\n   \n def _readinto_chunked(self,b):\n  assert self.chunked !=_UNKNOWN\n  total_bytes=0\n  mvb=memoryview(b)\n  try :\n   while True :\n    chunk_left=self._get_chunk_left()\n    if chunk_left is None :\n     return total_bytes\n     \n    if len(mvb)<=chunk_left:\n     n=self._safe_readinto(mvb)\n     self.chunk_left=chunk_left -n\n     return total_bytes+n\n     \n    temp_mvb=mvb[:chunk_left]\n    n=self._safe_readinto(temp_mvb)\n    mvb=mvb[n:]\n    total_bytes +=n\n    self.chunk_left=0\n    \n  except IncompleteRead:\n   raise IncompleteRead(bytes(b[0:total_bytes]))\n   \n def _safe_read(self,amt):\n  ''\n\n\n\n\n  \n  data=self.fp.read(amt)\n  if len(data)<amt:\n   raise IncompleteRead(data,amt -len(data))\n  return data\n  \n def _safe_readinto(self,b):\n  ''\n  amt=len(b)\n  n=self.fp.readinto(b)\n  if n <amt:\n   raise IncompleteRead(bytes(b[:n]),amt -n)\n  return n\n  \n def read1(self,n=-1):\n  ''\n\n  \n  if self.fp is None or self._method ==\"HEAD\":\n   return b\"\"\n  if self.chunked:\n   return self._read1_chunked(n)\n  if self.length is not None and (n <0 or n >self.length):\n   n=self.length\n  result=self.fp.read1(n)\n  if not result and n:\n   self._close_conn()\n  elif self.length is not None :\n   self.length -=len(result)\n  return result\n  \n def peek(self,n=-1):\n \n \n  if self.fp is None or self._method ==\"HEAD\":\n   return b\"\"\n  if self.chunked:\n   return self._peek_chunked(n)\n  return self.fp.peek(n)\n  \n def readline(self,limit=-1):\n  if self.fp is None or self._method ==\"HEAD\":\n   return b\"\"\n  if self.chunked:\n  \n   return super().readline(limit)\n  if self.length is not None and (limit <0 or limit >self.length):\n   limit=self.length\n  result=self.fp.readline(limit)\n  if not result and limit:\n   self._close_conn()\n  elif self.length is not None :\n   self.length -=len(result)\n  return result\n  \n def _read1_chunked(self,n):\n \n \n  chunk_left=self._get_chunk_left()\n  if chunk_left is None or n ==0:\n   return b''\n  if not (0 <=n <=chunk_left):\n   n=chunk_left\n  read=self.fp.read1(n)\n  self.chunk_left -=len(read)\n  if not read:\n   raise IncompleteRead(b\"\")\n  return read\n  \n def _peek_chunked(self,n):\n \n \n  try :\n   chunk_left=self._get_chunk_left()\n  except IncompleteRead:\n   return b''\n  if chunk_left is None :\n   return b''\n   \n   \n  return self.fp.peek(chunk_left)[:chunk_left]\n  \n def fileno(self):\n  return self.fp.fileno()\n  \n def getheader(self,name,default=None ):\n  ''\n\n\n\n\n\n\n\n\n\n  \n  if self.headers is None :\n   raise ResponseNotReady()\n  headers=self.headers.get_all(name)or default\n  if isinstance(headers,str)or not hasattr(headers,'__iter__'):\n   return headers\n  else :\n   return ', '.join(headers)\n   \n def getheaders(self):\n  ''\n  if self.headers is None :\n   raise ResponseNotReady()\n  return list(self.headers.items())\n  \n  \n  \n def __iter__(self):\n  return self\n  \n  \n  \n def info(self):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  return self.headers\n  \n def geturl(self):\n  ''\n\n\n\n\n\n\n\n  \n  return self.url\n  \n def getcode(self):\n  ''\n\n\n  \n  return self.status\n  \nclass HTTPConnection:\n\n _http_vsn=11\n _http_vsn_str='HTTP/1.1'\n \n response_class=HTTPResponse\n default_port=HTTP_PORT\n auto_open=1\n debuglevel=0\n \n @staticmethod\n def _is_textIO(stream):\n  ''\n  \n  return isinstance(stream,io.TextIOBase)\n  \n @staticmethod\n def _get_content_length(body,method):\n  ''\n\n\n\n\n  \n  if body is None :\n  \n  \n   if method.upper()in _METHODS_EXPECTING_BODY:\n    return 0\n   else :\n    return None\n    \n  if hasattr(body,'read'):\n  \n   return None\n   \n  try :\n  \n   mv=memoryview(body)\n   return mv.nbytes\n  except TypeError:\n   pass\n   \n  if isinstance(body,str):\n   return len(body)\n   \n  return None\n  \n def __init__(self,host,port=None ,timeout=socket._GLOBAL_DEFAULT_TIMEOUT,\n source_address=None ,blocksize=8192):\n  self.timeout=timeout\n  self.source_address=source_address\n  self.blocksize=blocksize\n  self.sock=None\n  self._buffer=[]\n  self.__response=None\n  self.__state=_CS_IDLE\n  self._method=None\n  self._tunnel_host=None\n  self._tunnel_port=None\n  self._tunnel_headers={}\n  \n  (self.host,self.port)=self._get_hostport(host,port)\n  \n  self._validate_host(self.host)\n  \n  \n  \n  self._create_connection=socket.create_connection\n  \n def set_tunnel(self,host,port=None ,headers=None ):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n  \n  \n  if self.sock:\n   raise RuntimeError(\"Can't set up tunnel for established connection\")\n   \n  self._tunnel_host,self._tunnel_port=self._get_hostport(host,port)\n  if headers:\n   self._tunnel_headers=headers\n  else :\n   self._tunnel_headers.clear()\n   \n def _get_hostport(self,host,port):\n  if port is None :\n   i=host.rfind(':')\n   j=host.rfind(']')\n   if i >j:\n    try :\n     port=int(host[i+1:])\n    except ValueError:\n     if host[i+1:]==\"\":\n      port=self.default_port\n     else :\n      raise InvalidURL(\"nonnumeric port: '%s'\"%host[i+1:])\n    host=host[:i]\n   else :\n    port=self.default_port\n   if host and host[0]=='['and host[-1]==']':\n    host=host[1:-1]\n    \n  return (host,port)\n  \n def set_debuglevel(self,level):\n  self.debuglevel=level\n  \n def _tunnel(self):\n  connect_str=\"CONNECT %s:%d HTTP/1.0\\r\\n\"%(self._tunnel_host,\n  self._tunnel_port)\n  connect_bytes=connect_str.encode(\"ascii\")\n  self.send(connect_bytes)\n  for header,value in self._tunnel_headers.items():\n   header_str=\"%s: %s\\r\\n\"%(header,value)\n   header_bytes=header_str.encode(\"latin-1\")\n   self.send(header_bytes)\n  self.send(b'\\r\\n')\n  \n  response=self.response_class(self.sock,method=self._method)\n  (version,code,message)=response._read_status()\n  \n  if code !=http.HTTPStatus.OK:\n   self.close()\n   raise OSError(\"Tunnel connection failed: %d %s\"%(code,\n   message.strip()))\n  while True :\n   line=response.fp.readline(_MAXLINE+1)\n   if len(line)>_MAXLINE:\n    raise LineTooLong(\"header line\")\n   if not line:\n   \n    break\n   if line in (b'\\r\\n',b'\\n',b''):\n    break\n    \n   if self.debuglevel >0:\n    print('header:',line.decode())\n    \n def connect(self):\n  ''\n  self.sock=self._create_connection(\n  (self.host,self.port),self.timeout,self.source_address)\n  self.sock.setsockopt(socket.IPPROTO_TCP,socket.TCP_NODELAY,1)\n  \n  if self._tunnel_host:\n   self._tunnel()\n   \n def close(self):\n  ''\n  self.__state=_CS_IDLE\n  try :\n   sock=self.sock\n   if sock:\n    self.sock=None\n    sock.close()\n  finally :\n   response=self.__response\n   if response:\n    self.__response=None\n    response.close()\n    \n def send(self,data):\n  ''\n\n\n  \n  \n  if self.sock is None :\n   if self.auto_open:\n    self.connect()\n   else :\n    raise NotConnected()\n    \n  if self.debuglevel >0:\n   print(\"send:\",repr(data))\n  if hasattr(data,\"read\"):\n   if self.debuglevel >0:\n    print(\"sendIng a read()able\")\n   encode=self._is_textIO(data)\n   if encode and self.debuglevel >0:\n    print(\"encoding file using iso-8859-1\")\n   while 1:\n    datablock=data.read(self.blocksize)\n    if not datablock:\n     break\n    if encode:\n     datablock=datablock.encode(\"iso-8859-1\")\n    self.sock.sendall(datablock)\n   return\n  try :\n   self.sock.sendall(data)\n  except TypeError:\n   if isinstance(data,collections.abc.Iterable):\n    for d in data:\n     self.sock.sendall(d)\n   else :\n    raise TypeError(\"data should be a bytes-like object \"\n    \"or an iterable, got %r\"%type(data))\n    \n def _output(self,s):\n  ''\n\n\n  \n  self._buffer.append(s)\n  \n def _read_readable(self,readable):\n  if self.debuglevel >0:\n   print(\"sendIng a read()able\")\n  encode=self._is_textIO(readable)\n  if encode and self.debuglevel >0:\n   print(\"encoding file using iso-8859-1\")\n  while True :\n   datablock=readable.read(self.blocksize)\n   if not datablock:\n    break\n   if encode:\n    datablock=datablock.encode(\"iso-8859-1\")\n   yield datablock\n   \n def _send_output(self,message_body=None ,encode_chunked=False ):\n  ''\n\n\n\n  \n  self._buffer.extend((b\"\",b\"\"))\n  msg=b\"\\r\\n\".join(self._buffer)\n  del self._buffer[:]\n  self.send(msg)\n  \n  if message_body is not None :\n  \n  \n   if hasattr(message_body,'read'):\n   \n   \n   \n    chunks=self._read_readable(message_body)\n   else :\n    try :\n    \n    \n    \n    \n     memoryview(message_body)\n    except TypeError:\n     try :\n      chunks=iter(message_body)\n     except TypeError:\n      raise TypeError(\"message_body should be a bytes-like \"\n      \"object or an iterable, got %r\"\n      %type(message_body))\n    else :\n    \n    \n     chunks=(message_body,)\n     \n   for chunk in chunks:\n    if not chunk:\n     if self.debuglevel >0:\n      print('Zero length chunk ignored')\n     continue\n     \n    if encode_chunked and self._http_vsn ==11:\n    \n     chunk=f'{len(chunk):X}\\r\\n'.encode('ascii')+chunk\\\n     +b'\\r\\n'\n    self.send(chunk)\n    \n   if encode_chunked and self._http_vsn ==11:\n   \n    self.send(b'0\\r\\n\\r\\n')\n    \n def putrequest(self,method,url,skip_host=False ,\n skip_accept_encoding=False ):\n  ''\n\n\n\n\n\n\n  \n  \n  \n  if self.__response and self.__response.isclosed():\n   self.__response=None\n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n  if self.__state ==_CS_IDLE:\n   self.__state=_CS_REQ_STARTED\n  else :\n   raise CannotSendRequest(self.__state)\n   \n  self._validate_method(method)\n  \n  \n  self._method=method\n  \n  url=url or '/'\n  self._validate_path(url)\n  \n  request='%s %s %s'%(method,url,self._http_vsn_str)\n  \n  self._output(self._encode_request(request))\n  \n  if self._http_vsn ==11:\n  \n  \n   if not skip_host:\n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n    netloc=''\n    if url.startswith('http'):\n     nil,netloc,nil,nil,nil=urlsplit(url)\n     \n    if netloc:\n     try :\n      netloc_enc=netloc.encode(\"ascii\")\n     except UnicodeEncodeError:\n      netloc_enc=netloc.encode(\"idna\")\n     self.putheader('Host',netloc_enc)\n    else :\n     if self._tunnel_host:\n      host=self._tunnel_host\n      port=self._tunnel_port\n     else :\n      host=self.host\n      port=self.port\n      \n     try :\n      host_enc=host.encode(\"ascii\")\n     except UnicodeEncodeError:\n      host_enc=host.encode(\"idna\")\n      \n      \n      \n      \n     if host.find(':')>=0:\n      host_enc=b'['+host_enc+b']'\n      \n     if port ==self.default_port:\n      self.putheader('Host',host_enc)\n     else :\n      host_enc=host_enc.decode(\"ascii\")\n      self.putheader('Host',\"%s:%s\"%(host_enc,port))\n      \n      \n      \n      \n      \n      \n      \n      \n      \n   if not skip_accept_encoding:\n    self.putheader('Accept-Encoding','identity')\n    \n    \n    \n    \n    \n    \n    \n    \n    \n  else :\n  \n   pass\n   \n def _encode_request(self,request):\n \n  return request.encode('ascii')\n  \n def _validate_method(self,method):\n  ''\n  \n  match=_contains_disallowed_method_pchar_re.search(method)\n  if match:\n   raise ValueError(\n   f\"method can't contain control characters. {method!r} \"\n   f\"(found at least {match.group()!r})\")\n   \n def _validate_path(self,url):\n  ''\n  \n  match=_contains_disallowed_url_pchar_re.search(url)\n  if match:\n   raise InvalidURL(f\"URL can't contain control characters. {url!r} \"\n   f\"(found at least {match.group()!r})\")\n   \n def _validate_host(self,host):\n  ''\n  \n  match=_contains_disallowed_url_pchar_re.search(host)\n  if match:\n   raise InvalidURL(f\"URL can't contain control characters. {host!r} \"\n   f\"(found at least {match.group()!r})\")\n   \n def putheader(self,header,*values):\n  ''\n\n\n  \n  if self.__state !=_CS_REQ_STARTED:\n   raise CannotSendHeader()\n   \n  if hasattr(header,'encode'):\n   header=header.encode('ascii')\n   \n  if not _is_legal_header_name(header):\n   raise ValueError('Invalid header name %r'%(header,))\n   \n  values=list(values)\n  for i,one_value in enumerate(values):\n   if hasattr(one_value,'encode'):\n    values[i]=one_value.encode('latin-1')\n   elif isinstance(one_value,int):\n    values[i]=str(one_value).encode('ascii')\n    \n   if _is_illegal_header_value(values[i]):\n    raise ValueError('Invalid header value %r'%(values[i],))\n    \n  value=b'\\r\\n\\t'.join(values)\n  header=header+b': '+value\n  self._output(header)\n  \n def endheaders(self,message_body=None ,*,encode_chunked=False ):\n  ''\n\n\n\n\n  \n  if self.__state ==_CS_REQ_STARTED:\n   self.__state=_CS_REQ_SENT\n  else :\n   raise CannotSendHeader()\n  self._send_output(message_body,encode_chunked=encode_chunked)\n  \n def request(self,method,url,body=None ,headers={},*,\n encode_chunked=False ):\n  ''\n  self._send_request(method,url,body,headers,encode_chunked)\n  \n def _send_request(self,method,url,body,headers,encode_chunked):\n \n  header_names=frozenset(k.lower()for k in headers)\n  skips={}\n  if 'host'in header_names:\n   skips['skip_host']=1\n  if 'accept-encoding'in header_names:\n   skips['skip_accept_encoding']=1\n   \n  self.putrequest(method,url,**skips)\n  \n  \n  \n  \n  \n  \n  \n  \n  if 'content-length'not in header_names:\n  \n  \n  \n   if 'transfer-encoding'not in header_names:\n   \n   \n    encode_chunked=False\n    content_length=self._get_content_length(body,method)\n    if content_length is None :\n     if body is not None :\n      if self.debuglevel >0:\n       print('Unable to determine size of %r'%body)\n      encode_chunked=True\n      self.putheader('Transfer-Encoding','chunked')\n    else :\n     self.putheader('Content-Length',str(content_length))\n  else :\n   encode_chunked=False\n   \n  for hdr,value in headers.items():\n   self.putheader(hdr,value)\n  if isinstance(body,str):\n  \n  \n   body=_encode(body,'body')\n  self.endheaders(body,encode_chunked=encode_chunked)\n  \n def getresponse(self):\n  ''\n\n\n\n\n\n\n\n\n\n\n  \n  \n  \n  if self.__response and self.__response.isclosed():\n   self.__response=None\n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n   \n  if self.__state !=_CS_REQ_SENT or self.__response:\n   raise ResponseNotReady(self.__state)\n   \n  if self.debuglevel >0:\n   response=self.response_class(self.sock,self.debuglevel,\n   method=self._method)\n  else :\n   response=self.response_class(self.sock,method=self._method)\n   \n  try :\n   try :\n    response.begin()\n   except ConnectionError:\n    self.close()\n    raise\n   assert response.will_close !=_UNKNOWN\n   self.__state=_CS_IDLE\n   \n   if response.will_close:\n   \n    self.close()\n   else :\n   \n    self.__response=response\n    \n   return response\n  except :\n   response.close()\n   raise\n   \ntry :\n import ssl\nexcept ImportError:\n pass\nelse :\n class HTTPSConnection(HTTPConnection):\n  ''\n  \n  default_port=HTTPS_PORT\n  \n  \n  \n  def __init__(self,host,port=None ,key_file=None ,cert_file=None ,\n  timeout=socket._GLOBAL_DEFAULT_TIMEOUT,\n  source_address=None ,*,context=None ,\n  check_hostname=None ,blocksize=8192):\n   super(HTTPSConnection,self).__init__(host,port,timeout,\n   source_address,\n   blocksize=blocksize)\n   if (key_file is not None or cert_file is not None or\n   check_hostname is not None ):\n    import warnings\n    warnings.warn(\"key_file, cert_file and check_hostname are \"\n    \"deprecated, use a custom context instead.\",\n    DeprecationWarning,2)\n   self.key_file=key_file\n   self.cert_file=cert_file\n   if context is None :\n    context=ssl._create_default_https_context()\n    \n    if context.post_handshake_auth is not None :\n     context.post_handshake_auth=True\n   will_verify=context.verify_mode !=ssl.CERT_NONE\n   if check_hostname is None :\n    check_hostname=context.check_hostname\n   if check_hostname and not will_verify:\n    raise ValueError(\"check_hostname needs a SSL context with \"\n    \"either CERT_OPTIONAL or CERT_REQUIRED\")\n   if key_file or cert_file:\n    context.load_cert_chain(cert_file,key_file)\n    \n    \n    if context.post_handshake_auth is not None :\n     context.post_handshake_auth=True\n   self._context=context\n   if check_hostname is not None :\n    self._context.check_hostname=check_hostname\n    \n  def connect(self):\n   ''\n   \n   super().connect()\n   \n   if self._tunnel_host:\n    server_hostname=self._tunnel_host\n   else :\n    server_hostname=self.host\n    \n   self.sock=self._context.wrap_socket(self.sock,\n   server_hostname=server_hostname)\n   \n __all__.append(\"HTTPSConnection\")\n \nclass HTTPException(Exception):\n\n\n pass\n \nclass NotConnected(HTTPException):\n pass\n \nclass InvalidURL(HTTPException):\n pass\n \nclass UnknownProtocol(HTTPException):\n def __init__(self,version):\n  self.args=version,\n  self.version=version\n  \nclass UnknownTransferEncoding(HTTPException):\n pass\n \nclass UnimplementedFileMode(HTTPException):\n pass\n \nclass IncompleteRead(HTTPException):\n def __init__(self,partial,expected=None ):\n  self.args=partial,\n  self.partial=partial\n  self.expected=expected\n def __repr__(self):\n  if self.expected is not None :\n   e=', %i more expected'%self.expected\n  else :\n   e=''\n  return '%s(%i bytes read%s)'%(self.__class__.__name__,\n  len(self.partial),e)\n __str__=object.__str__\n \nclass ImproperConnectionState(HTTPException):\n pass\n \nclass CannotSendRequest(ImproperConnectionState):\n pass\n \nclass CannotSendHeader(ImproperConnectionState):\n pass\n \nclass ResponseNotReady(ImproperConnectionState):\n pass\n \nclass BadStatusLine(HTTPException):\n def __init__(self,line):\n  if not line:\n   line=repr(line)\n  self.args=line,\n  self.line=line\n  \nclass LineTooLong(HTTPException):\n def __init__(self,line_type):\n  HTTPException.__init__(self,\"got more than %d bytes when reading %s\"\n  %(_MAXLINE,line_type))\n  \nclass RemoteDisconnected(ConnectionResetError,BadStatusLine):\n def __init__(self,*pos,**kw):\n  BadStatusLine.__init__(self,\"\")\n  ConnectionResetError.__init__(self,*pos,**kw)\n  \n  \nerror=HTTPException\n", ["collections.abc", "email.message", "email.parser", "http", "io", "re", "socket", "ssl", "urllib.parse", "warnings"]],
     "http.cookies": [".py", "#!/usr/bin/env python3\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nr\"\"\"\nHere's a sample session to show how to use this module.\nAt the moment, this is the only documentation.\n\nThe Basics\n----------\n\nImporting is easy...\n\n   >>> from http import cookies\n\nMost of the time you start by creating a cookie.\n\n   >>> C = cookies.SimpleCookie()\n\nOnce you've created your Cookie, you can add values just as if it were\na dictionary.\n\n   >>> C = cookies.SimpleCookie()\n   >>> C[\"fig\"] = \"newton\"\n   >>> C[\"sugar\"] = \"wafer\"\n   >>> C.output()\n   'Set-Cookie: fig=newton\\r\\nSet-Cookie: sugar=wafer'\n\nNotice that the printable representation of a Cookie is the\nappropriate format for a Set-Cookie: header.  This is the\ndefault behavior.  You can change the header and printed\nattributes by using the .output() function\n\n   >>> C = cookies.SimpleCookie()\n   >>> C[\"rocky\"] = \"road\"\n   >>> C[\"rocky\"][\"path\"] = \"/cookie\"\n   >>> print(C.output(header=\"Cookie:\"))\n   Cookie: rocky=road; Path=/cookie\n   >>> print(C.output(attrs=[], header=\"Cookie:\"))\n   Cookie: rocky=road\n\nThe load() method of a Cookie extracts cookies from a string.  In a\nCGI script, you would use this method to extract the cookies from the\nHTTP_COOKIE environment variable.\n\n   >>> C = cookies.SimpleCookie()\n   >>> C.load(\"chips=ahoy; vienna=finger\")\n   >>> C.output()\n   'Set-Cookie: chips=ahoy\\r\\nSet-Cookie: vienna=finger'\n\nThe load() method is darn-tootin smart about identifying cookies\nwithin a string.  Escaped quotation marks, nested semicolons, and other\nsuch trickeries do not confuse it.\n\n   >>> C = cookies.SimpleCookie()\n   >>> C.load('keebler=\"E=everybody; L=\\\\\"Loves\\\\\"; fudge=\\\\012;\";')\n   >>> print(C)\n   Set-Cookie: keebler=\"E=everybody; L=\\\"Loves\\\"; fudge=\\012;\"\n\nEach element of the Cookie also supports all of the RFC 2109\nCookie attributes.  Here's an example which sets the Path\nattribute.\n\n   >>> C = cookies.SimpleCookie()\n   >>> C[\"oreo\"] = \"doublestuff\"\n   >>> C[\"oreo\"][\"path\"] = \"/\"\n   >>> print(C)\n   Set-Cookie: oreo=doublestuff; Path=/\n\nEach dictionary element has a 'value' attribute, which gives you\nback the value associated with the key.\n\n   >>> C = cookies.SimpleCookie()\n   >>> C[\"twix\"] = \"none for you\"\n   >>> C[\"twix\"].value\n   'none for you'\n\nThe SimpleCookie expects that all values should be standard strings.\nJust to be sure, SimpleCookie invokes the str() builtin to convert\nthe value to a string, when the values are set dictionary-style.\n\n   >>> C = cookies.SimpleCookie()\n   >>> C[\"number\"] = 7\n   >>> C[\"string\"] = \"seven\"\n   >>> C[\"number\"].value\n   '7'\n   >>> C[\"string\"].value\n   'seven'\n   >>> C.output()\n   'Set-Cookie: number=7\\r\\nSet-Cookie: string=seven'\n\nFinis.\n\"\"\"\n\n\n\n\nimport _jsre as re\n\n__all__=[\"CookieError\",\"BaseCookie\",\"SimpleCookie\"]\n\n_nulljoin=''.join\n_semispacejoin='; '.join\n_spacejoin=' '.join\n\n\n\n\nclass CookieError(Exception):\n pass\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \n \nascii_lowercase='abcdefghijklmnopqrstuvwxyz'\nascii_uppercase='ABCDEFGHIJKLMNOPQRSTUVWXYZ'\nascii_letters=ascii_lowercase+ascii_uppercase\ndigits='0123456789'\n\n_LegalChars=ascii_letters+digits+\"!#$%&'*+-.^_`|~:\"\n_Translator={\n'\\000':'\\\\000','\\001':'\\\\001','\\002':'\\\\002',\n'\\003':'\\\\003','\\004':'\\\\004','\\005':'\\\\005',\n'\\006':'\\\\006','\\007':'\\\\007','\\010':'\\\\010',\n'\\011':'\\\\011','\\012':'\\\\012','\\013':'\\\\013',\n'\\014':'\\\\014','\\015':'\\\\015','\\016':'\\\\016',\n'\\017':'\\\\017','\\020':'\\\\020','\\021':'\\\\021',\n'\\022':'\\\\022','\\023':'\\\\023','\\024':'\\\\024',\n'\\025':'\\\\025','\\026':'\\\\026','\\027':'\\\\027',\n'\\030':'\\\\030','\\031':'\\\\031','\\032':'\\\\032',\n'\\033':'\\\\033','\\034':'\\\\034','\\035':'\\\\035',\n'\\036':'\\\\036','\\037':'\\\\037',\n\n\n\n\n',':'\\\\054',';':'\\\\073',\n\n'\"':'\\\\\"','\\\\':'\\\\\\\\',\n\n'\\177':'\\\\177','\\200':'\\\\200','\\201':'\\\\201',\n'\\202':'\\\\202','\\203':'\\\\203','\\204':'\\\\204',\n'\\205':'\\\\205','\\206':'\\\\206','\\207':'\\\\207',\n'\\210':'\\\\210','\\211':'\\\\211','\\212':'\\\\212',\n'\\213':'\\\\213','\\214':'\\\\214','\\215':'\\\\215',\n'\\216':'\\\\216','\\217':'\\\\217','\\220':'\\\\220',\n'\\221':'\\\\221','\\222':'\\\\222','\\223':'\\\\223',\n'\\224':'\\\\224','\\225':'\\\\225','\\226':'\\\\226',\n'\\227':'\\\\227','\\230':'\\\\230','\\231':'\\\\231',\n'\\232':'\\\\232','\\233':'\\\\233','\\234':'\\\\234',\n'\\235':'\\\\235','\\236':'\\\\236','\\237':'\\\\237',\n'\\240':'\\\\240','\\241':'\\\\241','\\242':'\\\\242',\n'\\243':'\\\\243','\\244':'\\\\244','\\245':'\\\\245',\n'\\246':'\\\\246','\\247':'\\\\247','\\250':'\\\\250',\n'\\251':'\\\\251','\\252':'\\\\252','\\253':'\\\\253',\n'\\254':'\\\\254','\\255':'\\\\255','\\256':'\\\\256',\n'\\257':'\\\\257','\\260':'\\\\260','\\261':'\\\\261',\n'\\262':'\\\\262','\\263':'\\\\263','\\264':'\\\\264',\n'\\265':'\\\\265','\\266':'\\\\266','\\267':'\\\\267',\n'\\270':'\\\\270','\\271':'\\\\271','\\272':'\\\\272',\n'\\273':'\\\\273','\\274':'\\\\274','\\275':'\\\\275',\n'\\276':'\\\\276','\\277':'\\\\277','\\300':'\\\\300',\n'\\301':'\\\\301','\\302':'\\\\302','\\303':'\\\\303',\n'\\304':'\\\\304','\\305':'\\\\305','\\306':'\\\\306',\n'\\307':'\\\\307','\\310':'\\\\310','\\311':'\\\\311',\n'\\312':'\\\\312','\\313':'\\\\313','\\314':'\\\\314',\n'\\315':'\\\\315','\\316':'\\\\316','\\317':'\\\\317',\n'\\320':'\\\\320','\\321':'\\\\321','\\322':'\\\\322',\n'\\323':'\\\\323','\\324':'\\\\324','\\325':'\\\\325',\n'\\326':'\\\\326','\\327':'\\\\327','\\330':'\\\\330',\n'\\331':'\\\\331','\\332':'\\\\332','\\333':'\\\\333',\n'\\334':'\\\\334','\\335':'\\\\335','\\336':'\\\\336',\n'\\337':'\\\\337','\\340':'\\\\340','\\341':'\\\\341',\n'\\342':'\\\\342','\\343':'\\\\343','\\344':'\\\\344',\n'\\345':'\\\\345','\\346':'\\\\346','\\347':'\\\\347',\n'\\350':'\\\\350','\\351':'\\\\351','\\352':'\\\\352',\n'\\353':'\\\\353','\\354':'\\\\354','\\355':'\\\\355',\n'\\356':'\\\\356','\\357':'\\\\357','\\360':'\\\\360',\n'\\361':'\\\\361','\\362':'\\\\362','\\363':'\\\\363',\n'\\364':'\\\\364','\\365':'\\\\365','\\366':'\\\\366',\n'\\367':'\\\\367','\\370':'\\\\370','\\371':'\\\\371',\n'\\372':'\\\\372','\\373':'\\\\373','\\374':'\\\\374',\n'\\375':'\\\\375','\\376':'\\\\376','\\377':'\\\\377'\n}\n\ndef _quote(str,LegalChars=_LegalChars):\n ''\n\n\n\n\n \n if all(c in LegalChars for c in str):\n  return str\n else :\n  return '\"'+_nulljoin(_Translator.get(s,s)for s in str)+'\"'\n  \n  \n_OctalPatt=re.compile(r\"\\\\[0-3][0-7][0-7]\")\n_QuotePatt=re.compile(r\"[\\\\].\")\n\ndef _unquote(str):\n\n\n if len(str)<2:\n  return str\n if str[0]!='\"'or str[-1]!='\"':\n  return str\n  \n  \n  \n  \n  \n str=str[1:-1]\n \n \n \n \n \n i=0\n n=len(str)\n res=[]\n while 0 <=i <n:\n  o_match=_OctalPatt.search(str,i)\n  q_match=_QuotePatt.search(str,i)\n  if not o_match and not q_match:\n   res.append(str[i:])\n   break\n   \n  j=k=-1\n  if o_match:\n   j=o_match.start(0)\n  if q_match:\n   k=q_match.start(0)\n  if q_match and (not o_match or k <j):\n   res.append(str[i:k])\n   res.append(str[k+1])\n   i=k+2\n  else :\n   res.append(str[i:j])\n   res.append(chr(int(str[j+1:j+4],8)))\n   i=j+4\n return _nulljoin(res)\n \n \n \n \n \n \n \n \n_weekdayname=['Mon','Tue','Wed','Thu','Fri','Sat','Sun']\n\n_monthname=[None ,\n'Jan','Feb','Mar','Apr','May','Jun',\n'Jul','Aug','Sep','Oct','Nov','Dec']\n\ndef _getdate(future=0,weekdayname=_weekdayname,monthname=_monthname):\n from time import gmtime,time\n now=time()\n year,month,day,hh,mm,ss,wd,y,z=gmtime(now+future)\n return \"%s, %02d %3s %4d %02d:%02d:%02d GMT\"%\\\n (weekdayname[wd],day,monthname[month],year,hh,mm,ss)\n \n \nclass Morsel(dict):\n ''\n\n\n\n\n\n\n \n \n \n \n \n \n \n \n \n \n \n \n \n \n _reserved={\n \"expires\":\"expires\",\n \"path\":\"Path\",\n \"comment\":\"Comment\",\n \"domain\":\"Domain\",\n \"max-age\":\"Max-Age\",\n \"secure\":\"secure\",\n \"httponly\":\"httponly\",\n \"version\":\"Version\",\n }\n \n _flags={'secure','httponly'}\n \n def __init__(self):\n \n  self.key=self.value=self.coded_value=None\n  \n  \n  for key in self._reserved:\n   dict.__setitem__(self,key,\"\")\n   \n def __setitem__(self,K,V):\n  K=K.lower()\n  if not K in self._reserved:\n   raise CookieError(\"Invalid Attribute %s\"%K)\n  dict.__setitem__(self,K,V)\n  \n def isReservedKey(self,K):\n  return K.lower()in self._reserved\n  \n def set(self,key,val,coded_val,LegalChars=_LegalChars):\n \n \n  if key.lower()in self._reserved:\n   raise CookieError(\"Attempt to set a reserved key: %s\"%key)\n  if any(c not in LegalChars for c in key):\n   raise CookieError(\"Illegal key value: %s\"%key)\n   \n   \n  self.key=key\n  self.value=val\n  self.coded_value=coded_val\n  \n def output(self,attrs=None ,header=\"Set-Cookie:\"):\n  return \"%s %s\"%(header,self.OutputString(attrs))\n  \n __str__=output\n \n def __repr__(self):\n  return '<%s: %s=%s>'%(self.__class__.__name__,\n  self.key,repr(self.value))\n  \n def js_output(self,attrs=None ):\n \n  return \"\"\"\n        <script type=\"text/javascript\">\n        <!-- begin hiding\n        document.cookie = \\\"%s\\\";\n        // end hiding -->\n        </script>\n        \"\"\"%(self.OutputString(attrs).replace('\"',r'\\\"'))\n  \n def OutputString(self,attrs=None ):\n \n \n  result=[]\n  append=result.append\n  \n  \n  append(\"%s=%s\"%(self.key,self.coded_value))\n  \n  \n  if attrs is None :\n   attrs=self._reserved\n  items=sorted(self.items())\n  for key,value in items:\n   if value ==\"\":\n    continue\n   if key not in attrs:\n    continue\n   if key ==\"expires\"and isinstance(value,int):\n    append(\"%s=%s\"%(self._reserved[key],_getdate(value)))\n   elif key ==\"max-age\"and isinstance(value,int):\n    append(\"%s=%d\"%(self._reserved[key],value))\n   elif key ==\"secure\":\n    append(str(self._reserved[key]))\n   elif key ==\"httponly\":\n    append(str(self._reserved[key]))\n   else :\n    append(\"%s=%s\"%(self._reserved[key],value))\n    \n    \n  return _semispacejoin(result)\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n_LegalCharsPatt=r\"[\\w\\d!#%&'~_`><@,:/\\$\\*\\+\\-\\.\\^\\|\\)\\(\\?\\}\\{\\=]\"\n_CookiePattern=re.compile(r\"\"\"\n    (?x)                           # This is a verbose pattern\n    (?P<key>                       # Start of group 'key'\n    \"\"\"+_LegalCharsPatt+r\"\"\"+?   # Any word of at least one letter\n    )                              # End of group 'key'\n    (                              # Optional group: there may not be a value.\n    \\s*=\\s*                          # Equal Sign\n    (?P<val>                         # Start of group 'val'\n    \"(?:[^\\\\\"]|\\\\.)*\"                  # Any doublequoted string\n    |                                  # or\n    \\w{3},\\s[\\w\\d\\s-]{9,11}\\s[\\d:]{8}\\sGMT  # Special case for \"expires\" attr\n    |                                  # or\n    \"\"\"+_LegalCharsPatt+r\"\"\"*      # Any word or empty string\n    )                                # End of group 'val'\n    )?                             # End of optional value group\n    \\s*                            # Any number of spaces.\n    (\\s+|;|$)                      # Ending either at space, semicolon, or EOS.\n    \"\"\",re.ASCII)\n\n\n\n\n\nclass BaseCookie(dict):\n ''\n \n def value_decode(self,val):\n  ''\n\n\n\n\n  \n  return val,val\n  \n def value_encode(self,val):\n  ''\n\n\n\n  \n  strval=str(val)\n  return strval,strval\n  \n def __init__(self,input=None ):\n  if input:\n   self.load(input)\n   \n def __set(self,key,real_value,coded_value):\n  ''\n  M=self.get(key,Morsel())\n  M.set(key,real_value,coded_value)\n  dict.__setitem__(self,key,M)\n  \n def __setitem__(self,key,value):\n  ''\n  rval,cval=self.value_encode(value)\n  self.__set(key,rval,cval)\n  \n def output(self,attrs=None ,header=\"Set-Cookie:\",sep=\"\\015\\012\"):\n  ''\n  result=[]\n  items=sorted(self.items())\n  for key,value in items:\n   result.append(value.output(attrs,header))\n  return sep.join(result)\n  \n __str__=output\n \n def __repr__(self):\n  l=[]\n  items=sorted(self.items())\n  for key,value in items:\n   l.append('%s=%s'%(key,repr(value.value)))\n  return '<%s: %s>'%(self.__class__.__name__,_spacejoin(l))\n  \n def js_output(self,attrs=None ):\n  ''\n  result=[]\n  items=sorted(self.items())\n  for key,value in items:\n   result.append(value.js_output(attrs))\n  return _nulljoin(result)\n  \n def load(self,rawdata):\n  ''\n\n\n\n  \n  if isinstance(rawdata,str):\n   self.__parse_string(rawdata)\n  else :\n  \n   for key,value in rawdata.items():\n    self[key]=value\n  return\n  \n def __parse_string(self,str,patt=_CookiePattern):\n  i=0\n  n=len(str)\n  M=None\n  \n  while 0 <=i <n:\n  \n   match=patt.search(str,i)\n   if not match:\n   \n    break\n    \n   key,value=match.group(\"key\"),match.group(\"val\")\n   i=match.end(0)\n   \n   \n   if key[0]==\"$\":\n   \n   \n   \n    if M:\n     M[key[1:]]=value\n   elif key.lower()in Morsel._reserved:\n    if M:\n     if value is None :\n      if key.lower()in Morsel._flags:\n       M[key]=True\n     else :\n      M[key]=_unquote(value)\n   elif value is not None :\n    rval,cval=self.value_decode(value)\n    self.__set(key,rval,cval)\n    M=self[key]\n    \n    \nclass SimpleCookie(BaseCookie):\n ''\n\n\n\n\n \n def value_decode(self,val):\n  return _unquote(val),val\n  \n def value_encode(self,val):\n  strval=str(val)\n  return strval,_quote(strval)\n", ["_jsre", "time"]],
     "http": [".py", "from enum import IntEnum\n\n__all__=['HTTPStatus']\n\nclass HTTPStatus(IntEnum):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n def __new__(cls,value,phrase,description=''):\n  obj=int.__new__(cls,value)\n  obj._value_=value\n  \n  obj.phrase=phrase\n  obj.description=description\n  return obj\n  \n  \n CONTINUE=100,'Continue','Request received, please continue'\n SWITCHING_PROTOCOLS=(101,'Switching Protocols',\n 'Switching to new protocol; obey Upgrade header')\n PROCESSING=102,'Processing'\n \n \n OK=200,'OK','Request fulfilled, document follows'\n CREATED=201,'Created','Document created, URL follows'\n ACCEPTED=(202,'Accepted',\n 'Request accepted, processing continues off-line')\n NON_AUTHORITATIVE_INFORMATION=(203,\n 'Non-Authoritative Information','Request fulfilled from cache')\n NO_CONTENT=204,'No Content','Request fulfilled, nothing follows'\n RESET_CONTENT=205,'Reset Content','Clear input form for further input'\n PARTIAL_CONTENT=206,'Partial Content','Partial content follows'\n MULTI_STATUS=207,'Multi-Status'\n ALREADY_REPORTED=208,'Already Reported'\n IM_USED=226,'IM Used'\n \n \n MULTIPLE_CHOICES=(300,'Multiple Choices',\n 'Object has several resources -- see URI list')\n MOVED_PERMANENTLY=(301,'Moved Permanently',\n 'Object moved permanently -- see URI list')\n FOUND=302,'Found','Object moved temporarily -- see URI list'\n SEE_OTHER=303,'See Other','Object moved -- see Method and URL list'\n NOT_MODIFIED=(304,'Not Modified',\n 'Document has not changed since given time')\n USE_PROXY=(305,'Use Proxy',\n 'You must use proxy specified in Location to access this resource')\n TEMPORARY_REDIRECT=(307,'Temporary Redirect',\n 'Object moved temporarily -- see URI list')\n PERMANENT_REDIRECT=(308,'Permanent Redirect',\n 'Object moved permanently -- see URI list')\n \n \n BAD_REQUEST=(400,'Bad Request',\n 'Bad request syntax or unsupported method')\n UNAUTHORIZED=(401,'Unauthorized',\n 'No permission -- see authorization schemes')\n PAYMENT_REQUIRED=(402,'Payment Required',\n 'No payment -- see charging schemes')\n FORBIDDEN=(403,'Forbidden',\n 'Request forbidden -- authorization will not help')\n NOT_FOUND=(404,'Not Found',\n 'Nothing matches the given URI')\n METHOD_NOT_ALLOWED=(405,'Method Not Allowed',\n 'Specified method is invalid for this resource')\n NOT_ACCEPTABLE=(406,'Not Acceptable',\n 'URI not available in preferred format')\n PROXY_AUTHENTICATION_REQUIRED=(407,\n 'Proxy Authentication Required',\n 'You must authenticate with this proxy before proceeding')\n REQUEST_TIMEOUT=(408,'Request Timeout',\n 'Request timed out; try again later')\n CONFLICT=409,'Conflict','Request conflict'\n GONE=(410,'Gone',\n 'URI no longer exists and has been permanently removed')\n LENGTH_REQUIRED=(411,'Length Required',\n 'Client must specify Content-Length')\n PRECONDITION_FAILED=(412,'Precondition Failed',\n 'Precondition in headers is false')\n REQUEST_ENTITY_TOO_LARGE=(413,'Request Entity Too Large',\n 'Entity is too large')\n REQUEST_URI_TOO_LONG=(414,'Request-URI Too Long',\n 'URI is too long')\n UNSUPPORTED_MEDIA_TYPE=(415,'Unsupported Media Type',\n 'Entity body in unsupported format')\n REQUESTED_RANGE_NOT_SATISFIABLE=(416,\n 'Requested Range Not Satisfiable',\n 'Cannot satisfy request range')\n EXPECTATION_FAILED=(417,'Expectation Failed',\n 'Expect condition could not be satisfied')\n MISDIRECTED_REQUEST=(421,'Misdirected Request',\n 'Server is not able to produce a response')\n UNPROCESSABLE_ENTITY=422,'Unprocessable Entity'\n LOCKED=423,'Locked'\n FAILED_DEPENDENCY=424,'Failed Dependency'\n UPGRADE_REQUIRED=426,'Upgrade Required'\n PRECONDITION_REQUIRED=(428,'Precondition Required',\n 'The origin server requires the request to be conditional')\n TOO_MANY_REQUESTS=(429,'Too Many Requests',\n 'The user has sent too many requests in '\n 'a given amount of time (\"rate limiting\")')\n REQUEST_HEADER_FIELDS_TOO_LARGE=(431,\n 'Request Header Fields Too Large',\n 'The server is unwilling to process the request because its header '\n 'fields are too large')\n UNAVAILABLE_FOR_LEGAL_REASONS=(451,\n 'Unavailable For Legal Reasons',\n 'The server is denying access to the '\n 'resource as a consequence of a legal demand')\n \n \n INTERNAL_SERVER_ERROR=(500,'Internal Server Error',\n 'Server got itself in trouble')\n NOT_IMPLEMENTED=(501,'Not Implemented',\n 'Server does not support this operation')\n BAD_GATEWAY=(502,'Bad Gateway',\n 'Invalid responses from another server/proxy')\n SERVICE_UNAVAILABLE=(503,'Service Unavailable',\n 'The server cannot process the request due to a high load')\n GATEWAY_TIMEOUT=(504,'Gateway Timeout',\n 'The gateway server did not receive a timely response')\n HTTP_VERSION_NOT_SUPPORTED=(505,'HTTP Version Not Supported',\n 'Cannot fulfill request')\n VARIANT_ALSO_NEGOTIATES=506,'Variant Also Negotiates'\n INSUFFICIENT_STORAGE=507,'Insufficient Storage'\n LOOP_DETECTED=508,'Loop Detected'\n NOT_EXTENDED=510,'Not Extended'\n NETWORK_AUTHENTICATION_REQUIRED=(511,\n 'Network Authentication Required',\n 'The client needs to authenticate to gain network access')\n \n", ["enum"], 1],
     "importlib.abc": [".py", "''\nfrom . import _bootstrap\nfrom . import _bootstrap_external\nfrom . import machinery\ntry :\n import _frozen_importlib\nexcept ImportError as exc:\n if exc.name !='_frozen_importlib':\n  raise\n _frozen_importlib=None\ntry :\n import _frozen_importlib_external\nexcept ImportError:\n _frozen_importlib_external=_bootstrap_external\nimport abc\nimport warnings\nfrom typing import Protocol,runtime_checkable\n\n\ndef _register(abstract_cls,*classes):\n for cls in classes:\n  abstract_cls.register(cls)\n  if _frozen_importlib is not None :\n   try :\n    frozen_cls=getattr(_frozen_importlib,cls.__name__)\n   except AttributeError:\n    frozen_cls=getattr(_frozen_importlib_external,cls.__name__)\n   abstract_cls.register(frozen_cls)\n   \n   \nclass Finder(metaclass=abc.ABCMeta):\n\n ''\n\n\n\n\n\n\n\n \n \n @abc.abstractmethod\n def find_module(self,fullname,path=None ):\n  ''\n\n\n  \n  \n  \nclass MetaPathFinder(Finder):\n\n ''\n \n \n \n \n def find_module(self,fullname,path):\n  ''\n\n\n\n\n\n\n\n\n  \n  warnings.warn(\"MetaPathFinder.find_module() is deprecated since Python \"\n  \"3.4 in favor of MetaPathFinder.find_spec() \"\n  \"(available since 3.4)\",\n  DeprecationWarning,\n  stacklevel=2)\n  if not hasattr(self,'find_spec'):\n   return None\n  found=self.find_spec(fullname,path)\n  return found.loader if found is not None else None\n  \n def invalidate_caches(self):\n  ''\n\n  \n  \n_register(MetaPathFinder,machinery.BuiltinImporter,machinery.FrozenImporter,\nmachinery.PathFinder,machinery.WindowsRegistryFinder)\n\n\nclass PathEntryFinder(Finder):\n\n ''\n \n \n \n \n def find_loader(self,fullname):\n  ''\n\n\n\n\n\n\n\n\n\n\n\n\n  \n  warnings.warn(\"PathEntryFinder.find_loader() is deprecated since Python \"\n  \"3.4 in favor of PathEntryFinder.find_spec() \"\n  \"(available since 3.4)\",\n  DeprecationWarning,\n  stacklevel=2)\n  if not hasattr(self,'find_spec'):\n   return None ,[]\n  found=self.find_spec(fullname)\n  if found is not None :\n   if not found.submodule_search_locations:\n    portions=[]\n   else :\n    portions=found.submodule_search_locations\n   return found.loader,portions\n  else :\n   return None ,[]\n   \n find_module=_bootstrap_external._find_module_shim\n \n def invalidate_caches(self):\n  ''\n\n  \n  \n_register(PathEntryFinder,machinery.FileFinder)\n\n\nclass Loader(metaclass=abc.ABCMeta):\n\n ''\n \n def create_module(self,spec):\n  ''\n\n\n\n\n  \n  \n  return None\n  \n  \n  \n  \n def load_module(self,fullname):\n  ''\n\n\n\n\n\n\n\n\n\n\n  \n  if not hasattr(self,'exec_module'):\n   raise ImportError\n  return _bootstrap._load_module_shim(self,fullname)\n  \n def module_repr(self,module):\n  ''\n\n\n\n\n\n\n  \n  \n  raise NotImplementedError\n  \n  \nclass ResourceLoader(Loader):\n\n ''\n\n\n\n\n \n \n @abc.abstractmethod\n def get_data(self,path):\n  ''\n  \n  raise OSError\n  \n  \nclass InspectLoader(Loader):\n\n ''\n\n\n\n\n \n \n def is_package(self,fullname):\n  ''\n\n\n\n  \n  raise ImportError\n  \n def get_code(self,fullname):\n  ''\n\n\n\n\n\n  \n  source=self.get_source(fullname)\n  if source is None :\n   return None\n  return self.source_to_code(source)\n  \n @abc.abstractmethod\n def get_source(self,fullname):\n  ''\n\n\n\n  \n  raise ImportError\n  \n @staticmethod\n def source_to_code(data,path='<string>'):\n  ''\n\n\n  \n  return compile(data,path,'exec',dont_inherit=True )\n  \n exec_module=_bootstrap_external._LoaderBasics.exec_module\n load_module=_bootstrap_external._LoaderBasics.load_module\n \n_register(InspectLoader,machinery.BuiltinImporter,machinery.FrozenImporter)\n\n\nclass ExecutionLoader(InspectLoader):\n\n ''\n\n\n\n\n \n \n @abc.abstractmethod\n def get_filename(self,fullname):\n  ''\n\n\n\n  \n  raise ImportError\n  \n def get_code(self,fullname):\n  ''\n\n\n\n  \n  source=self.get_source(fullname)\n  if source is None :\n   return None\n  try :\n   path=self.get_filename(fullname)\n  except ImportError:\n   return self.source_to_code(source)\n  else :\n   return self.source_to_code(source,path)\n   \n_register(ExecutionLoader,machinery.ExtensionFileLoader)\n\n\nclass FileLoader(_bootstrap_external.FileLoader,ResourceLoader,ExecutionLoader):\n\n ''\n \n \n_register(FileLoader,machinery.SourceFileLoader,\nmachinery.SourcelessFileLoader)\n\n\nclass SourceLoader(_bootstrap_external.SourceLoader,ResourceLoader,ExecutionLoader):\n\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n def path_mtime(self,path):\n  ''\n  if self.path_stats.__func__ is SourceLoader.path_stats:\n   raise OSError\n  return int(self.path_stats(path)['mtime'])\n  \n def path_stats(self,path):\n  ''\n\n\n\n\n  \n  if self.path_mtime.__func__ is SourceLoader.path_mtime:\n   raise OSError\n  return {'mtime':self.path_mtime(path)}\n  \n def set_data(self,path,data):\n  ''\n\n\n\n\n\n\n  \n  \n_register(SourceLoader,machinery.SourceFileLoader)\n\n\nclass ResourceReader(metaclass=abc.ABCMeta):\n\n ''\n\n\n\n\n \n \n @abc.abstractmethod\n def open_resource(self,resource):\n  ''\n\n\n\n\n\n  \n  raise FileNotFoundError\n  \n @abc.abstractmethod\n def resource_path(self,resource):\n  ''\n\n\n\n\n\n\n  \n  raise FileNotFoundError\n  \n @abc.abstractmethod\n def is_resource(self,name):\n  ''\n  raise FileNotFoundError\n  \n @abc.abstractmethod\n def contents(self):\n  ''\n  return []\n  \n  \n_register(ResourceReader,machinery.SourceFileLoader)\n\n\n@runtime_checkable\nclass Traversable(Protocol):\n ''\n\n\n \n \n @abc.abstractmethod\n def iterdir(self):\n  ''\n\n  \n  \n @abc.abstractmethod\n def read_bytes(self):\n  ''\n\n  \n  \n @abc.abstractmethod\n def read_text(self,encoding=None ):\n  ''\n\n  \n  \n @abc.abstractmethod\n def is_dir(self):\n  ''\n\n  \n  \n @abc.abstractmethod\n def is_file(self):\n  ''\n\n  \n  \n @abc.abstractmethod\n def joinpath(self,child):\n  ''\n\n  \n  \n @abc.abstractmethod\n def __truediv__(self,child):\n  ''\n\n  \n  \n @abc.abstractmethod\n def open(self,mode='r',*args,**kwargs):\n  ''\n\n\n\n\n\n  \n  \n @abc.abstractproperty\n def name(self):\n \n  ''\n\n  \n  \n  \nclass TraversableResources(ResourceReader):\n @abc.abstractmethod\n def files(self):\n  ''\n  \n def open_resource(self,resource):\n  return self.files().joinpath(resource).open('rb')\n  \n def resource_path(self,resource):\n  raise FileNotFoundError(resource)\n  \n def is_resource(self,path):\n  return self.files().joinpath(path).isfile()\n  \n def contents(self):\n  return (item.name for item in self.files().iterdir())\n", ["_frozen_importlib", "_frozen_importlib_external", "abc", "importlib", "importlib._bootstrap", "importlib._bootstrap_external", "importlib.machinery", "typing", "warnings"]],
-    "importlib.basehook": [".py", "from browser import window\nimport urllib.request\n\nclass TempMod:\n\n def __init__(self,name):\n  self.name=name\n  \n  \nclass BaseHook:\n\n def __init__(self,fullname=None ,path=None ):\n  self._fullname=fullname\n  self._path=path\n  self._modpath=''\n  self._module=''\n  \n def find_module(self,name=None ,path=None ):\n  if name is None :\n   name=self._fullname\n   \n  for _i in ('libs/%s.js'%name,'Lib/%s.py'%name,\n  'Lib/%s/__init__.py'%name):\n   _path=\"%s%s\"%(__BRYTHON__.brython_path,_i)\n   try :\n    _fp,_,_headers=urllib.request.urlopen(_path)\n    if _headers['status']!=200:\n     continue\n    self._module=_fp.read()\n    self._modpath=_path\n    return self\n   except urllib.error.HTTPError as e:\n    self._modpath=''\n    self._module=''\n    \n  raise ImportError\n  \n def is_package(self):\n  return '.'in self._fullname\n  \n def load_module(self,name):\n  if name is None :\n   name=self._fullname\n  window.eval('__BRYTHON__.imported[\"%s\"] = {}'%name)\n  return __BRYTHON__.run_py(self._module,\n  self._modpath,TempMod(name))\n", ["browser", "urllib.request"]],
     "importlib.machinery": [".py", "''\n\nimport _imp\n\nfrom ._bootstrap import ModuleSpec\nfrom ._bootstrap import BuiltinImporter\nfrom ._bootstrap import FrozenImporter\nfrom ._bootstrap_external import (SOURCE_SUFFIXES,DEBUG_BYTECODE_SUFFIXES,\nOPTIMIZED_BYTECODE_SUFFIXES,BYTECODE_SUFFIXES,\nEXTENSION_SUFFIXES)\nfrom ._bootstrap_external import WindowsRegistryFinder\nfrom ._bootstrap_external import PathFinder\nfrom ._bootstrap_external import FileFinder\nfrom ._bootstrap_external import SourceFileLoader\nfrom ._bootstrap_external import SourcelessFileLoader\nfrom ._bootstrap_external import ExtensionFileLoader\n\n\ndef all_suffixes():\n ''\n return SOURCE_SUFFIXES+BYTECODE_SUFFIXES+EXTENSION_SUFFIXES\n", ["_imp", "importlib._bootstrap", "importlib._bootstrap_external"]],
+    "importlib.metadata": [".py", "import io\nimport os\nimport re\nimport abc\nimport csv\nimport sys\nimport email\nimport pathlib\nimport zipfile\nimport operator\nimport functools\nimport itertools\nimport posixpath\nimport collections\n\nfrom configparser import ConfigParser\nfrom contextlib import suppress\nfrom importlib import import_module\nfrom importlib.abc import MetaPathFinder\nfrom itertools import starmap\n\n\n__all__=[\n'Distribution',\n'DistributionFinder',\n'PackageNotFoundError',\n'distribution',\n'distributions',\n'entry_points',\n'files',\n'metadata',\n'requires',\n'version',\n]\n\n\nclass PackageNotFoundError(ModuleNotFoundError):\n ''\n \n \nclass EntryPoint(\ncollections.namedtuple('EntryPointBase','name value group')):\n ''\n\n\n\n\n \n \n pattern=re.compile(\n r'(?P<module>[\\w.]+)\\s*'\n r'(:\\s*(?P<attr>[\\w.]+))?\\s*'\n r'(?P<extras>\\[.*\\])?\\s*$'\n )\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n def load(self):\n  ''\n\n\n  \n  match=self.pattern.match(self.value)\n  module=import_module(match.group('module'))\n  attrs=filter(None ,(match.group('attr')or '').split('.'))\n  return functools.reduce(getattr,attrs,module)\n  \n @property\n def module(self):\n  match=self.pattern.match(self.value)\n  return match.group('module')\n  \n @property\n def attr(self):\n  match=self.pattern.match(self.value)\n  return match.group('attr')\n  \n @property\n def extras(self):\n  match=self.pattern.match(self.value)\n  return list(re.finditer(r'\\w+',match.group('extras')or ''))\n  \n @classmethod\n def _from_config(cls,config):\n  return [\n  cls(name,value,group)\n  for group in config.sections()\n  for name,value in config.items(group)\n  ]\n  \n @classmethod\n def _from_text(cls,text):\n  config=ConfigParser(delimiters='=')\n  \n  config.optionxform=str\n  try :\n   config.read_string(text)\n  except AttributeError:\n  \n   config.readfp(io.StringIO(text))\n  return EntryPoint._from_config(config)\n  \n def __iter__(self):\n  ''\n\n  \n  return iter((self.name,self))\n  \n def __reduce__(self):\n  return (\n  self.__class__,\n  (self.name,self.value,self.group),\n  )\n  \n  \nclass PackagePath(pathlib.PurePosixPath):\n ''\n \n def read_text(self,encoding='utf-8'):\n  with self.locate().open(encoding=encoding)as stream:\n   return stream.read()\n   \n def read_binary(self):\n  with self.locate().open('rb')as stream:\n   return stream.read()\n   \n def locate(self):\n  ''\n  return self.dist.locate_file(self)\n  \n  \nclass FileHash:\n def __init__(self,spec):\n  self.mode,_,self.value=spec.partition('=')\n  \n def __repr__(self):\n  return '<FileHash mode: {} value: {}>'.format(self.mode,self.value)\n  \n  \nclass Distribution:\n ''\n \n @abc.abstractmethod\n def read_text(self,filename):\n  ''\n\n\n\n  \n  \n @abc.abstractmethod\n def locate_file(self,path):\n  ''\n\n\n  \n  \n @classmethod\n def from_name(cls,name):\n  ''\n\n\n\n\n\n\n  \n  for resolver in cls._discover_resolvers():\n   dists=resolver(DistributionFinder.Context(name=name))\n   dist=next(iter(dists),None )\n   if dist is not None :\n    return dist\n  else :\n   raise PackageNotFoundError(name)\n   \n @classmethod\n def discover(cls,**kwargs):\n  ''\n\n\n\n\n\n\n  \n  context=kwargs.pop('context',None )\n  if context and kwargs:\n   raise ValueError(\"cannot accept context and kwargs\")\n  context=context or DistributionFinder.Context(**kwargs)\n  return itertools.chain.from_iterable(\n  resolver(context)\n  for resolver in cls._discover_resolvers()\n  )\n  \n @staticmethod\n def at(path):\n  ''\n\n\n\n  \n  return PathDistribution(pathlib.Path(path))\n  \n @staticmethod\n def _discover_resolvers():\n  ''\n  declared=(\n  getattr(finder,'find_distributions',None )\n  for finder in sys.meta_path\n  )\n  return filter(None ,declared)\n  \n @classmethod\n def _local(cls,root='.'):\n  from pep517 import build,meta\n  system=build.compat_system(root)\n  builder=functools.partial(\n  meta.build,\n  source_dir=root,\n  system=system,\n  )\n  return PathDistribution(zipfile.Path(meta.build_as_zip(builder)))\n  \n @property\n def metadata(self):\n  ''\n\n\n\n  \n  text=(\n  self.read_text('METADATA')\n  or self.read_text('PKG-INFO')\n  \n  \n  \n  or self.read_text('')\n  )\n  return email.message_from_string(text)\n  \n @property\n def version(self):\n  ''\n  return self.metadata['Version']\n  \n @property\n def entry_points(self):\n  return EntryPoint._from_text(self.read_text('entry_points.txt'))\n  \n @property\n def files(self):\n  ''\n\n\n\n\n\n\n\n  \n  file_lines=self._read_files_distinfo()or self._read_files_egginfo()\n  \n  def make_file(name,hash=None ,size_str=None ):\n   result=PackagePath(name)\n   result.hash=FileHash(hash)if hash else None\n   result.size=int(size_str)if size_str else None\n   result.dist=self\n   return result\n   \n  return file_lines and list(starmap(make_file,csv.reader(file_lines)))\n  \n def _read_files_distinfo(self):\n  ''\n\n  \n  text=self.read_text('RECORD')\n  return text and text.splitlines()\n  \n def _read_files_egginfo(self):\n  ''\n\n\n  \n  text=self.read_text('SOURCES.txt')\n  return text and map('\"{}\"'.format,text.splitlines())\n  \n @property\n def requires(self):\n  ''\n  reqs=self._read_dist_info_reqs()or self._read_egg_info_reqs()\n  return reqs and list(reqs)\n  \n def _read_dist_info_reqs(self):\n  return self.metadata.get_all('Requires-Dist')\n  \n def _read_egg_info_reqs(self):\n  source=self.read_text('requires.txt')\n  return source and self._deps_from_requires_text(source)\n  \n @classmethod\n def _deps_from_requires_text(cls,source):\n  section_pairs=cls._read_sections(source.splitlines())\n  sections={\n  section:list(map(operator.itemgetter('line'),results))\n  for section,results in\n  itertools.groupby(section_pairs,operator.itemgetter('section'))\n  }\n  return cls._convert_egg_info_reqs_to_simple_reqs(sections)\n  \n @staticmethod\n def _read_sections(lines):\n  section=None\n  for line in filter(None ,lines):\n   section_match=re.match(r'\\[(.*)\\]$',line)\n   if section_match:\n    section=section_match.group(1)\n    continue\n   yield locals()\n   \n @staticmethod\n def _convert_egg_info_reqs_to_simple_reqs(sections):\n  ''\n\n\n\n\n\n\n\n  \n  def make_condition(name):\n   return name and 'extra == \"{name}\"'.format(name=name)\n   \n  def parse_condition(section):\n   section=section or ''\n   extra,sep,markers=section.partition(':')\n   if extra and markers:\n    markers='({markers})'.format(markers=markers)\n   conditions=list(filter(None ,[markers,make_condition(extra)]))\n   return '; '+' and '.join(conditions)if conditions else ''\n   \n  for section,deps in sections.items():\n   for dep in deps:\n    yield dep+parse_condition(section)\n    \n    \nclass DistributionFinder(MetaPathFinder):\n ''\n\n \n \n class Context:\n  ''\n\n\n\n\n\n\n\n\n  \n  \n  name=None\n  ''\n\n\n  \n  \n  def __init__(self,**kwargs):\n   vars(self).update(kwargs)\n   \n  @property\n  def path(self):\n   ''\n\n\n\n\n   \n   return vars(self).get('path',sys.path)\n   \n @abc.abstractmethod\n def find_distributions(self,context=Context()):\n  ''\n\n\n\n\n\n  \n  \n  \nclass FastPath:\n ''\n\n\n \n \n def __init__(self,root):\n  self.root=root\n  self.base=os.path.basename(self.root).lower()\n  \n def joinpath(self,child):\n  return pathlib.Path(self.root,child)\n  \n def children(self):\n  with suppress(Exception):\n   return os.listdir(self.root or '')\n  with suppress(Exception):\n   return self.zip_children()\n  return []\n  \n def zip_children(self):\n  zip_path=zipfile.Path(self.root)\n  names=zip_path.root.namelist()\n  self.joinpath=zip_path.joinpath\n  \n  return dict.fromkeys(\n  child.split(posixpath.sep,1)[0]\n  for child in names\n  )\n  \n def is_egg(self,search):\n  base=self.base\n  return (\n  base ==search.versionless_egg_name\n  or base.startswith(search.prefix)\n  and base.endswith('.egg'))\n  \n def search(self,name):\n  for child in self.children():\n   n_low=child.lower()\n   if (n_low in name.exact_matches\n   or n_low.startswith(name.prefix)\n   and n_low.endswith(name.suffixes)\n   \n   or self.is_egg(name)and n_low =='egg-info'):\n    yield self.joinpath(child)\n    \n    \nclass Prepared:\n ''\n\n \n normalized=''\n prefix=''\n suffixes='.dist-info','.egg-info'\n exact_matches=[''][:0]\n versionless_egg_name=''\n \n def __init__(self,name):\n  self.name=name\n  if name is None :\n   return\n  self.normalized=name.lower().replace('-','_')\n  self.prefix=self.normalized+'-'\n  self.exact_matches=[\n  self.normalized+suffix for suffix in self.suffixes]\n  self.versionless_egg_name=self.normalized+'.egg'\n  \n  \nclass MetadataPathFinder(DistributionFinder):\n @classmethod\n def find_distributions(cls,context=DistributionFinder.Context()):\n  ''\n\n\n\n\n\n\n  \n  found=cls._search_paths(context.name,context.path)\n  return map(PathDistribution,found)\n  \n @classmethod\n def _search_paths(cls,name,paths):\n  ''\n  return itertools.chain.from_iterable(\n  path.search(Prepared(name))\n  for path in map(FastPath,paths)\n  )\n  \n  \nclass PathDistribution(Distribution):\n def __init__(self,path):\n  ''\n\n\n\n  \n  self._path=path\n  \n def read_text(self,filename):\n  with suppress(FileNotFoundError,IsADirectoryError,KeyError,\n  NotADirectoryError,PermissionError):\n   return self._path.joinpath(filename).read_text(encoding='utf-8')\n read_text.__doc__=Distribution.read_text.__doc__\n \n def locate_file(self,path):\n  return self._path.parent /path\n  \n  \ndef distribution(distribution_name):\n ''\n\n\n\n \n return Distribution.from_name(distribution_name)\n \n \ndef distributions(**kwargs):\n ''\n\n\n \n return Distribution.discover(**kwargs)\n \n \ndef metadata(distribution_name):\n ''\n\n\n\n \n return Distribution.from_name(distribution_name).metadata\n \n \ndef version(distribution_name):\n ''\n\n\n\n\n \n return distribution(distribution_name).version\n \n \ndef entry_points():\n ''\n\n\n \n eps=itertools.chain.from_iterable(\n dist.entry_points for dist in distributions())\n by_group=operator.attrgetter('group')\n ordered=sorted(eps,key=by_group)\n grouped=itertools.groupby(ordered,by_group)\n return {\n group:tuple(eps)\n for group,eps in grouped\n }\n \n \ndef files(distribution_name):\n ''\n\n\n\n \n return distribution(distribution_name).files\n \n \ndef requires(distribution_name):\n ''\n\n\n\n\n \n return distribution(distribution_name).requires\n", ["abc", "collections", "configparser", "contextlib", "csv", "email", "functools", "importlib", "importlib.abc", "io", "itertools", "operator", "os", "pathlib", "pep517", "posixpath", "re", "sys", "zipfile"]],
     "importlib.resources": [".py", "import os\n\nfrom . import abc as resources_abc\nfrom . import _common\nfrom ._common import as_file\nfrom contextlib import contextmanager,suppress\nfrom importlib import import_module\nfrom importlib.abc import ResourceLoader\nfrom io import BytesIO,TextIOWrapper\nfrom pathlib import Path\nfrom types import ModuleType\nfrom typing import ContextManager,Iterable,Optional,Union\nfrom typing import cast\nfrom typing.io import BinaryIO,TextIO\n\n\n__all__=[\n'Package',\n'Resource',\n'as_file',\n'contents',\n'files',\n'is_resource',\n'open_binary',\n'open_text',\n'path',\n'read_binary',\n'read_text',\n]\n\n\nPackage=Union[str,ModuleType]\nResource=Union[str,os.PathLike]\n\n\ndef _resolve(name)->ModuleType:\n ''\n if hasattr(name,'__spec__'):\n  return name\n return import_module(name)\n \n \ndef _get_package(package)->ModuleType:\n ''\n\n\n\n \n module=_resolve(package)\n if module.__spec__.submodule_search_locations is None :\n  raise TypeError('{!r} is not a package'.format(package))\n return module\n \n \ndef _normalize_path(path)->str:\n ''\n\n\n \n parent,file_name=os.path.split(path)\n if parent:\n  raise ValueError('{!r} must be only a file name'.format(path))\n return file_name\n \n \ndef _get_resource_reader(\npackage:ModuleType)->Optional[resources_abc.ResourceReader]:\n\n\n\n\n\n spec=package.__spec__\n if hasattr(spec.loader,'get_resource_reader'):\n  return cast(resources_abc.ResourceReader,\n  spec.loader.get_resource_reader(spec.name))\n return None\n \n \ndef _check_location(package):\n if package.__spec__.origin is None or not package.__spec__.has_location:\n  raise FileNotFoundError(f'Package has no location {package!r}')\n  \n  \ndef open_binary(package:Package,resource:Resource)->BinaryIO:\n ''\n resource=_normalize_path(resource)\n package=_get_package(package)\n reader=_get_resource_reader(package)\n if reader is not None :\n  return reader.open_resource(resource)\n absolute_package_path=os.path.abspath(\n package.__spec__.origin or 'non-existent file')\n package_path=os.path.dirname(absolute_package_path)\n full_path=os.path.join(package_path,resource)\n try :\n  return open(full_path,mode='rb')\n except OSError:\n \n \n \n  loader=cast(ResourceLoader,package.__spec__.loader)\n  data=None\n  if hasattr(package.__spec__.loader,'get_data'):\n   with suppress(OSError):\n    data=loader.get_data(full_path)\n  if data is None :\n   package_name=package.__spec__.name\n   message='{!r} resource not found in {!r}'.format(\n   resource,package_name)\n   raise FileNotFoundError(message)\n  return BytesIO(data)\n  \n  \ndef open_text(package:Package,\nresource:Resource,\nencoding:str='utf-8',\nerrors:str='strict')->TextIO:\n ''\n return TextIOWrapper(\n open_binary(package,resource),encoding=encoding,errors=errors)\n \n \ndef read_binary(package:Package,resource:Resource)->bytes:\n ''\n with open_binary(package,resource)as fp:\n  return fp.read()\n  \n  \ndef read_text(package:Package,\nresource:Resource,\nencoding:str='utf-8',\nerrors:str='strict')->str:\n ''\n\n\n\n \n with open_text(package,resource,encoding,errors)as fp:\n  return fp.read()\n  \n  \ndef files(package:Package)->resources_abc.Traversable:\n ''\n\n \n return _common.from_package(_get_package(package))\n \n \ndef path(\npackage:Package,resource:Resource,\n)->'ContextManager[Path]':\n ''\n\n\n\n\n\n\n \n reader=_get_resource_reader(_get_package(package))\n return (\n _path_from_reader(reader,resource)\n if reader else\n _common.as_file(files(package).joinpath(_normalize_path(resource)))\n )\n \n \n@contextmanager\ndef _path_from_reader(reader,resource):\n norm_resource=_normalize_path(resource)\n with suppress(FileNotFoundError):\n  yield Path(reader.resource_path(norm_resource))\n  return\n opener_reader=reader.open_resource(norm_resource)\n with _common._tempfile(opener_reader.read,suffix=norm_resource)as res:\n  yield res\n  \n  \ndef is_resource(package:Package,name:str)->bool:\n ''\n\n\n \n package=_get_package(package)\n _normalize_path(name)\n reader=_get_resource_reader(package)\n if reader is not None :\n  return reader.is_resource(name)\n package_contents=set(contents(package))\n if name not in package_contents:\n  return False\n return (_common.from_package(package)/name).is_file()\n \n \ndef contents(package:Package)->Iterable[str]:\n ''\n\n\n\n\n \n package=_get_package(package)\n reader=_get_resource_reader(package)\n if reader is not None :\n  return reader.contents()\n  \n  \n namespace=(\n package.__spec__.origin is None or\n package.__spec__.origin =='namespace'\n )\n if namespace or not package.__spec__.has_location:\n  return ()\n return list(item.name for item in _common.from_package(package).iterdir())\n", ["contextlib", "importlib", "importlib._common", "importlib.abc", "io", "os", "pathlib", "types", "typing", "typing.io"]],
     "importlib.util": [".py", "''\nfrom . import abc\nfrom ._bootstrap import module_from_spec\nfrom ._bootstrap import _resolve_name\nfrom ._bootstrap import spec_from_loader\nfrom ._bootstrap import _find_spec\nfrom ._bootstrap_external import MAGIC_NUMBER\nfrom ._bootstrap_external import _RAW_MAGIC_NUMBER\nfrom ._bootstrap_external import cache_from_source\nfrom ._bootstrap_external import decode_source\nfrom ._bootstrap_external import source_from_cache\nfrom ._bootstrap_external import spec_from_file_location\n\nfrom contextlib import contextmanager\nimport _imp\nimport functools\nimport sys\nimport types\nimport warnings\n\n\ndef source_hash(source_bytes):\n ''\n return _imp.source_hash(_RAW_MAGIC_NUMBER,source_bytes)\n \n \ndef resolve_name(name,package):\n ''\n if not name.startswith('.'):\n  return name\n elif not package:\n  raise ImportError(f'no package specified for {repr(name)} '\n  '(required for relative module names)')\n level=0\n for character in name:\n  if character !='.':\n   break\n  level +=1\n return _resolve_name(name[level:],package,level)\n \n \ndef _find_spec_from_path(name,path=None ):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n \n if name not in sys.modules:\n  return _find_spec(name,path)\n else :\n  module=sys.modules[name]\n  if module is None :\n   return None\n  try :\n   spec=module.__spec__\n  except AttributeError:\n   raise ValueError('{}.__spec__ is not set'.format(name))from None\n  else :\n   if spec is None :\n    raise ValueError('{}.__spec__ is None'.format(name))\n   return spec\n   \n   \ndef find_spec(name,package=None ):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n fullname=resolve_name(name,package)if name.startswith('.')else name\n if fullname not in sys.modules:\n  parent_name=fullname.rpartition('.')[0]\n  if parent_name:\n   parent=__import__(parent_name,fromlist=['__path__'])\n   try :\n    parent_path=parent.__path__\n   except AttributeError as e:\n    raise ModuleNotFoundError(\n    f\"__path__ attribute not found on {parent_name!r} \"\n    f\"while trying to find {fullname!r}\",name=fullname)from e\n  else :\n   parent_path=None\n  return _find_spec(fullname,parent_path)\n else :\n  module=sys.modules[fullname]\n  if module is None :\n   return None\n  try :\n   spec=module.__spec__\n  except AttributeError:\n   raise ValueError('{}.__spec__ is not set'.format(name))from None\n  else :\n   if spec is None :\n    raise ValueError('{}.__spec__ is None'.format(name))\n   return spec\n   \n   \n@contextmanager\ndef _module_to_load(name):\n is_reload=name in sys.modules\n \n module=sys.modules.get(name)\n if not is_reload:\n \n \n \n  module=type(sys)(name)\n  \n  \n  module.__initializing__=True\n  sys.modules[name]=module\n try :\n  yield module\n except Exception:\n  if not is_reload:\n   try :\n    del sys.modules[name]\n   except KeyError:\n    pass\n finally :\n  module.__initializing__=False\n  \n  \ndef set_package(fxn):\n ''\n\n\n\n \n @functools.wraps(fxn)\n def set_package_wrapper(*args,**kwargs):\n  warnings.warn('The import system now takes care of this automatically.',\n  DeprecationWarning,stacklevel=2)\n  module=fxn(*args,**kwargs)\n  if getattr(module,'__package__',None )is None :\n   module.__package__=module.__name__\n   if not hasattr(module,'__path__'):\n    module.__package__=module.__package__.rpartition('.')[0]\n  return module\n return set_package_wrapper\n \n \ndef set_loader(fxn):\n ''\n\n\n\n \n @functools.wraps(fxn)\n def set_loader_wrapper(self,*args,**kwargs):\n  warnings.warn('The import system now takes care of this automatically.',\n  DeprecationWarning,stacklevel=2)\n  module=fxn(self,*args,**kwargs)\n  if getattr(module,'__loader__',None )is None :\n   module.__loader__=self\n  return module\n return set_loader_wrapper\n \n \ndef module_for_loader(fxn):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n warnings.warn('The import system now takes care of this automatically.',\n DeprecationWarning,stacklevel=2)\n @functools.wraps(fxn)\n def module_for_loader_wrapper(self,fullname,*args,**kwargs):\n  with _module_to_load(fullname)as module:\n   module.__loader__=self\n   try :\n    is_package=self.is_package(fullname)\n   except (ImportError,AttributeError):\n    pass\n   else :\n    if is_package:\n     module.__package__=fullname\n    else :\n     module.__package__=fullname.rpartition('.')[0]\n     \n   return fxn(self,module,*args,**kwargs)\n   \n return module_for_loader_wrapper\n \n \nclass _LazyModule(types.ModuleType):\n\n ''\n \n def __getattribute__(self,attr):\n  ''\n  \n  \n  \n  self.__class__=types.ModuleType\n  \n  \n  original_name=self.__spec__.name\n  \n  \n  attrs_then=self.__spec__.loader_state['__dict__']\n  original_type=self.__spec__.loader_state['__class__']\n  attrs_now=self.__dict__\n  attrs_updated={}\n  for key,value in attrs_now.items():\n  \n  \n   if key not in attrs_then:\n    attrs_updated[key]=value\n   elif id(attrs_now[key])!=id(attrs_then[key]):\n    attrs_updated[key]=value\n  self.__spec__.loader.exec_module(self)\n  \n  \n  if original_name in sys.modules:\n   if id(self)!=id(sys.modules[original_name]):\n    raise ValueError(f\"module object for {original_name!r} \"\n    \"substituted in sys.modules during a lazy \"\n    \"load\")\n    \n    \n  self.__dict__.update(attrs_updated)\n  return getattr(self,attr)\n  \n def __delattr__(self,attr):\n  ''\n  \n  \n  self.__getattribute__(attr)\n  delattr(self,attr)\n  \n  \nclass LazyLoader(abc.Loader):\n\n ''\n \n @staticmethod\n def __check_eager_loader(loader):\n  if not hasattr(loader,'exec_module'):\n   raise TypeError('loader must define exec_module()')\n   \n @classmethod\n def factory(cls,loader):\n  ''\n  cls.__check_eager_loader(loader)\n  return lambda *args,**kwargs:cls(loader(*args,**kwargs))\n  \n def __init__(self,loader):\n  self.__check_eager_loader(loader)\n  self.loader=loader\n  \n def create_module(self,spec):\n  return self.loader.create_module(spec)\n  \n def exec_module(self,module):\n  ''\n  module.__spec__.loader=self.loader\n  module.__loader__=self.loader\n  \n  \n  \n  \n  loader_state={}\n  loader_state['__dict__']=module.__dict__.copy()\n  loader_state['__class__']=module.__class__\n  module.__spec__.loader_state=loader_state\n  module.__class__=_LazyModule\n", ["_imp", "contextlib", "functools", "importlib", "importlib._bootstrap", "importlib._bootstrap_external", "importlib.abc", "sys", "types", "warnings"]],
     "importlib._bootstrap": [".py", "''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n_bootstrap_external=None\n_thread=None\nimport _weakref\n\ndef _wrap(new,old):\n ''\n for replace in ['__module__','__name__','__qualname__','__doc__']:\n  if hasattr(old,replace):\n   setattr(new,replace,getattr(old,replace))\n new.__dict__.update(old.__dict__)\n \n \ndef _new_module(name):\n return type(sys)(name)\n \n \n \n \n \n \n_module_locks={}\n\n_blocking_on={}\n\n\nclass _DeadlockError(RuntimeError):\n pass\n \n \nclass _ModuleLock:\n ''\n\n\n \n \n def __init__(self,name):\n  self.lock=_thread.allocate_lock()\n  self.wakeup=_thread.allocate_lock()\n  self.name=name\n  self.owner=None\n  self.count=0\n  self.waiters=0\n  \n def has_deadlock(self):\n \n  me=_thread.get_ident()\n  tid=self.owner\n  while True :\n   lock=_blocking_on.get(tid)\n   if lock is None :\n    return False\n   tid=lock.owner\n   if tid ==me:\n    return True\n    \n def acquire(self):\n  ''\n\n\n\n  \n  tid=_thread.get_ident()\n  _blocking_on[tid]=self\n  try :\n   while True :\n    with self.lock:\n     if self.count ==0 or self.owner ==tid:\n      self.owner=tid\n      self.count +=1\n      return True\n     if self.has_deadlock():\n      raise _DeadlockError('deadlock detected by %r'%self)\n     if self.wakeup.acquire(False ):\n      self.waiters +=1\n      \n    self.wakeup.acquire()\n    self.wakeup.release()\n  finally :\n   del _blocking_on[tid]\n   \n def release(self):\n  tid=_thread.get_ident()\n  with self.lock:\n   if self.owner !=tid:\n    raise RuntimeError('cannot release un-acquired lock')\n   assert self.count >0\n   self.count -=1\n   if self.count ==0:\n    self.owner=None\n    if self.waiters:\n     self.waiters -=1\n     self.wakeup.release()\n     \n def __repr__(self):\n  return '_ModuleLock({!r}) at {}'.format(self.name,id(self))\n  \n  \nclass _DummyModuleLock:\n ''\n \n \n def __init__(self,name):\n  self.name=name\n  self.count=0\n  \n def acquire(self):\n  self.count +=1\n  return True\n  \n def release(self):\n  if self.count ==0:\n   raise RuntimeError('cannot release un-acquired lock')\n  self.count -=1\n  \n def __repr__(self):\n  return '_DummyModuleLock({!r}) at {}'.format(self.name,id(self))\n  \n  \nclass _ModuleLockManager:\n\n def __init__(self,name):\n  self._name=name\n  self._lock=None\n  \n def __enter__(self):\n  self._lock=_get_module_lock(self._name)\n  self._lock.acquire()\n  \n def __exit__(self,*args,**kwargs):\n  self._lock.release()\n  \n  \n  \n  \ndef _get_module_lock(name):\n ''\n\n\n \n \n _imp.acquire_lock()\n try :\n  try :\n   lock=_module_locks[name]()\n  except KeyError:\n   lock=None\n   \n  if lock is None :\n   if _thread is None :\n    lock=_DummyModuleLock(name)\n   else :\n    lock=_ModuleLock(name)\n    \n   def cb(ref,name=name):\n    _imp.acquire_lock()\n    try :\n    \n    \n    \n     if _module_locks.get(name)is ref:\n      del _module_locks[name]\n    finally :\n     _imp.release_lock()\n     \n   _module_locks[name]=_weakref.ref(lock,cb)\n finally :\n  _imp.release_lock()\n  \n return lock\n \n \ndef _lock_unlock_module(name):\n ''\n\n\n\n \n lock=_get_module_lock(name)\n try :\n  lock.acquire()\n except _DeadlockError:\n \n \n  pass\n else :\n  lock.release()\n  \n  \ndef _call_with_frames_removed(f,*args,**kwds):\n ''\n\n\n\n\n\n \n return f(*args,**kwds)\n \n \ndef _verbose_message(message,*args,verbosity=1):\n ''\n if sys.flags.verbose >=verbosity:\n  if not message.startswith(('#','import ')):\n   message='# '+message\n  print(message.format(*args),file=sys.stderr)\n  \n  \ndef _requires_builtin(fxn):\n ''\n def _requires_builtin_wrapper(self,fullname):\n  if fullname not in sys.builtin_module_names:\n   raise ImportError('{!r} is not a built-in module'.format(fullname),\n   name=fullname)\n  return fxn(self,fullname)\n _wrap(_requires_builtin_wrapper,fxn)\n return _requires_builtin_wrapper\n \n \ndef _requires_frozen(fxn):\n ''\n def _requires_frozen_wrapper(self,fullname):\n  if not _imp.is_frozen(fullname):\n   raise ImportError('{!r} is not a frozen module'.format(fullname),\n   name=fullname)\n  return fxn(self,fullname)\n _wrap(_requires_frozen_wrapper,fxn)\n return _requires_frozen_wrapper\n \n \n \ndef _load_module_shim(self,fullname):\n ''\n\n\n\n \n spec=spec_from_loader(fullname,self)\n if fullname in sys.modules:\n  module=sys.modules[fullname]\n  _exec(spec,module)\n  return sys.modules[fullname]\n else :\n  return _load(spec)\n  \n  \n  \ndef _module_repr(module):\n\n loader=getattr(module,'__loader__',None )\n if hasattr(loader,'module_repr'):\n \n \n \n  try :\n   return loader.module_repr(module)\n  except Exception:\n   pass\n try :\n  spec=module.__spec__\n except AttributeError:\n  pass\n else :\n  if spec is not None :\n   return _module_repr_from_spec(spec)\n   \n   \n   \n try :\n  name=module.__name__\n except AttributeError:\n  name='?'\n try :\n  filename=module.__file__\n except AttributeError:\n  if loader is None :\n   return '<module {!r}>'.format(name)\n  else :\n   return '<module {!r} ({!r})>'.format(name,loader)\n else :\n  return '<module {!r} from {!r}>'.format(name,filename)\n  \n  \nclass _installed_safely:\n\n def __init__(self,module):\n  self._module=module\n  self._spec=module.__spec__\n  \n def __enter__(self):\n \n \n \n  self._spec._initializing=True\n  sys.modules[self._spec.name]=self._module\n  \n def __exit__(self,*args):\n  try :\n   spec=self._spec\n   if any(arg is not None for arg in args):\n    try :\n     del sys.modules[spec.name]\n    except KeyError:\n     pass\n   else :\n    _verbose_message('import {!r} # {!r}',spec.name,spec.loader)\n  finally :\n   self._spec._initializing=False\n   \n   \nclass ModuleSpec:\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n \n def __init__(self,name,loader,*,origin=None ,loader_state=None ,\n is_package=None ):\n  self.name=name\n  self.loader=loader\n  self.origin=origin\n  self.loader_state=loader_state\n  self.submodule_search_locations=[]if is_package else None\n  \n  \n  self._set_fileattr=False\n  self._cached=None\n  \n def __repr__(self):\n  args=['name={!r}'.format(self.name),\n  'loader={!r}'.format(self.loader)]\n  if self.origin is not None :\n   args.append('origin={!r}'.format(self.origin))\n  if self.submodule_search_locations is not None :\n   args.append('submodule_search_locations={}'\n   .format(self.submodule_search_locations))\n  return '{}({})'.format(self.__class__.__name__,', '.join(args))\n  \n def __eq__(self,other):\n  smsl=self.submodule_search_locations\n  try :\n   return (self.name ==other.name and\n   self.loader ==other.loader and\n   self.origin ==other.origin and\n   smsl ==other.submodule_search_locations and\n   self.cached ==other.cached and\n   self.has_location ==other.has_location)\n  except AttributeError:\n   return False\n   \n @property\n def cached(self):\n  if self._cached is None :\n   if self.origin is not None and self._set_fileattr:\n    if _bootstrap_external is None :\n     raise NotImplementedError\n    self._cached=_bootstrap_external._get_cached(self.origin)\n  return self._cached\n  \n @cached.setter\n def cached(self,cached):\n  self._cached=cached\n  \n @property\n def parent(self):\n  ''\n  if self.submodule_search_locations is None :\n   return self.name.rpartition('.')[0]\n  else :\n   return self.name\n   \n @property\n def has_location(self):\n  return self._set_fileattr\n  \n @has_location.setter\n def has_location(self,value):\n  self._set_fileattr=bool(value)\n  \n  \ndef spec_from_loader(name,loader,*,origin=None ,is_package=None ):\n ''\n if hasattr(loader,'get_filename'):\n  if _bootstrap_external is None :\n   raise NotImplementedError\n  spec_from_file_location=_bootstrap_external.spec_from_file_location\n  \n  if is_package is None :\n   return spec_from_file_location(name,loader=loader)\n  search=[]if is_package else None\n  return spec_from_file_location(name,loader=loader,\n  submodule_search_locations=search)\n  \n if is_package is None :\n  if hasattr(loader,'is_package'):\n   try :\n    is_package=loader.is_package(name)\n   except ImportError:\n    is_package=None\n  else :\n  \n   is_package=False\n   \n return ModuleSpec(name,loader,origin=origin,is_package=is_package)\n \n \ndef _spec_from_module(module,loader=None ,origin=None ):\n\n try :\n  spec=module.__spec__\n except AttributeError:\n  pass\n else :\n  if spec is not None :\n   return spec\n   \n name=module.__name__\n if loader is None :\n  try :\n   loader=module.__loader__\n  except AttributeError:\n  \n   pass\n try :\n  location=module.__file__\n except AttributeError:\n  location=None\n if origin is None :\n  if location is None :\n   try :\n    origin=loader._ORIGIN\n   except AttributeError:\n    origin=None\n  else :\n   origin=location\n try :\n  cached=module.__cached__\n except AttributeError:\n  cached=None\n try :\n  submodule_search_locations=list(module.__path__)\n except AttributeError:\n  submodule_search_locations=None\n  \n spec=ModuleSpec(name,loader,origin=origin)\n spec._set_fileattr=False if location is None else True\n spec.cached=cached\n spec.submodule_search_locations=submodule_search_locations\n return spec\n \n \ndef _init_module_attrs(spec,module,*,override=False ):\n\n\n\n if (override or getattr(module,'__name__',None )is None ):\n  try :\n   module.__name__=spec.name\n  except AttributeError:\n   pass\n   \n if override or getattr(module,'__loader__',None )is None :\n  loader=spec.loader\n  if loader is None :\n  \n   if spec.submodule_search_locations is not None :\n    if _bootstrap_external is None :\n     raise NotImplementedError\n    _NamespaceLoader=_bootstrap_external._NamespaceLoader\n    \n    loader=_NamespaceLoader.__new__(_NamespaceLoader)\n    loader._path=spec.submodule_search_locations\n    spec.loader=loader\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    module.__file__=None\n  try :\n   module.__loader__=loader\n  except AttributeError:\n   pass\n   \n if override or getattr(module,'__package__',None )is None :\n  try :\n   module.__package__=spec.parent\n  except AttributeError:\n   pass\n   \n try :\n  module.__spec__=spec\n except AttributeError:\n  pass\n  \n if override or getattr(module,'__path__',None )is None :\n  if spec.submodule_search_locations is not None :\n   try :\n    module.__path__=spec.submodule_search_locations\n   except AttributeError:\n    pass\n    \n if spec.has_location:\n  if override or getattr(module,'__file__',None )is None :\n   try :\n    module.__file__=spec.origin\n   except AttributeError:\n    pass\n    \n  if override or getattr(module,'__cached__',None )is None :\n   if spec.cached is not None :\n    try :\n     module.__cached__=spec.cached\n    except AttributeError:\n     pass\n return module\n \n \ndef module_from_spec(spec):\n ''\n \n module=None\n if hasattr(spec.loader,'create_module'):\n \n \n  module=spec.loader.create_module(spec)\n elif hasattr(spec.loader,'exec_module'):\n  raise ImportError('loaders that define exec_module() '\n  'must also define create_module()')\n if module is None :\n  module=_new_module(spec.name)\n _init_module_attrs(spec,module)\n return module\n \n \ndef _module_repr_from_spec(spec):\n ''\n \n name='?'if spec.name is None else spec.name\n if spec.origin is None :\n  if spec.loader is None :\n   return '<module {!r}>'.format(name)\n  else :\n   return '<module {!r} ({!r})>'.format(name,spec.loader)\n else :\n  if spec.has_location:\n   return '<module {!r} from {!r}>'.format(name,spec.origin)\n  else :\n   return '<module {!r} ({})>'.format(spec.name,spec.origin)\n   \n   \n   \ndef _exec(spec,module):\n ''\n name=spec.name\n with _ModuleLockManager(name):\n  if sys.modules.get(name)is not module:\n   msg='module {!r} not in sys.modules'.format(name)\n   raise ImportError(msg,name=name)\n  if spec.loader is None :\n   if spec.submodule_search_locations is None :\n    raise ImportError('missing loader',name=spec.name)\n    \n   _init_module_attrs(spec,module,override=True )\n   return module\n  _init_module_attrs(spec,module,override=True )\n  if not hasattr(spec.loader,'exec_module'):\n  \n  \n  \n   spec.loader.load_module(name)\n  else :\n   spec.loader.exec_module(module)\n return sys.modules[name]\n \n \ndef _load_backward_compatible(spec):\n\n\n\n spec.loader.load_module(spec.name)\n \n module=sys.modules[spec.name]\n if getattr(module,'__loader__',None )is None :\n  try :\n   module.__loader__=spec.loader\n  except AttributeError:\n   pass\n if getattr(module,'__package__',None )is None :\n  try :\n  \n  \n  \n   module.__package__=module.__name__\n   if not hasattr(module,'__path__'):\n    module.__package__=spec.name.rpartition('.')[0]\n  except AttributeError:\n   pass\n if getattr(module,'__spec__',None )is None :\n  try :\n   module.__spec__=spec\n  except AttributeError:\n   pass\n return module\n \ndef _load_unlocked(spec):\n\n if spec.loader is not None :\n \n  if not hasattr(spec.loader,'exec_module'):\n   return _load_backward_compatible(spec)\n   \n module=module_from_spec(spec)\n with _installed_safely(module):\n  if spec.loader is None :\n   if spec.submodule_search_locations is None :\n    raise ImportError('missing loader',name=spec.name)\n    \n  else :\n   spec.loader.exec_module(module)\n   \n   \n   \n   \n return sys.modules[spec.name]\n \n \n \ndef _load(spec):\n ''\n\n\n\n\n\n\n \n with _ModuleLockManager(spec.name):\n  return _load_unlocked(spec)\n  \n  \n  \n  \nclass BuiltinImporter:\n\n ''\n\n\n\n\n \n \n @staticmethod\n def module_repr(module):\n  ''\n\n\n\n  \n  return '<module {!r} (built-in)>'.format(module.__name__)\n  \n @classmethod\n def find_spec(cls,fullname,path=None ,target=None ):\n  if path is not None :\n   return None\n  if _imp.is_builtin(fullname):\n   return spec_from_loader(fullname,cls,origin='built-in')\n  else :\n   return None\n   \n @classmethod\n def find_module(cls,fullname,path=None ):\n  ''\n\n\n\n\n\n  \n  spec=cls.find_spec(fullname,path)\n  return spec.loader if spec is not None else None\n  \n @classmethod\n def create_module(self,spec):\n  ''\n  if spec.name not in sys.builtin_module_names:\n   raise ImportError('{!r} is not a built-in module'.format(spec.name),\n   name=spec.name)\n  return _call_with_frames_removed(_imp.create_builtin,spec)\n  \n @classmethod\n def exec_module(self,module):\n  ''\n  _call_with_frames_removed(_imp.exec_builtin,module)\n  \n @classmethod\n @_requires_builtin\n def get_code(cls,fullname):\n  ''\n  return None\n  \n @classmethod\n @_requires_builtin\n def get_source(cls,fullname):\n  ''\n  return None\n  \n @classmethod\n @_requires_builtin\n def is_package(cls,fullname):\n  ''\n  return False\n  \n load_module=classmethod(_load_module_shim)\n \n \nclass FrozenImporter:\n\n ''\n\n\n\n\n \n \n @staticmethod\n def module_repr(m):\n  ''\n\n\n\n  \n  return '<module {!r} (frozen)>'.format(m.__name__)\n  \n @classmethod\n def find_spec(cls,fullname,path=None ,target=None ):\n  if _imp.is_frozen(fullname):\n   return spec_from_loader(fullname,cls,origin='frozen')\n  else :\n   return None\n   \n @classmethod\n def find_module(cls,fullname,path=None ):\n  ''\n\n\n\n  \n  return cls if _imp.is_frozen(fullname)else None\n  \n @classmethod\n def create_module(cls,spec):\n  ''\n  \n @staticmethod\n def exec_module(module):\n  name=module.__spec__.name\n  if not _imp.is_frozen(name):\n   raise ImportError('{!r} is not a frozen module'.format(name),\n   name=name)\n  code=_call_with_frames_removed(_imp.get_frozen_object,name)\n  exec(code,module.__dict__)\n  \n @classmethod\n def load_module(cls,fullname):\n  ''\n\n\n\n  \n  return _load_module_shim(cls,fullname)\n  \n @classmethod\n @_requires_frozen\n def get_code(cls,fullname):\n  ''\n  return _imp.get_frozen_object(fullname)\n  \n @classmethod\n @_requires_frozen\n def get_source(cls,fullname):\n  ''\n  return None\n  \n @classmethod\n @_requires_frozen\n def is_package(cls,fullname):\n  ''\n  return _imp.is_frozen_package(fullname)\n  \n  \n  \n  \nclass _ImportLockContext:\n\n ''\n \n def __enter__(self):\n  ''\n  _imp.acquire_lock()\n  \n def __exit__(self,exc_type,exc_value,exc_traceback):\n  ''\n  _imp.release_lock()\n  \n  \ndef _resolve_name(name,package,level):\n ''\n bits=package.rsplit('.',level -1)\n if len(bits)<level:\n  raise ValueError('attempted relative import beyond top-level package')\n base=bits[0]\n return '{}.{}'.format(base,name)if name else base\n \n \ndef _find_spec_legacy(finder,name,path):\n\n\n loader=finder.find_module(name,path)\n if loader is None :\n  return None\n return spec_from_loader(name,loader)\n \n \ndef _find_spec(name,path,target=None ):\n ''\n meta_path=sys.meta_path\n if meta_path is None :\n \n  raise ImportError(\"sys.meta_path is None, Python is likely \"\n  \"shutting down\")\n  \n if not meta_path:\n  _warnings.warn('sys.meta_path is empty',ImportWarning)\n  \n  \n  \n  \n is_reload=name in sys.modules\n for finder in meta_path:\n  with _ImportLockContext():\n   try :\n    find_spec=finder.find_spec\n   except AttributeError:\n    spec=_find_spec_legacy(finder,name,path)\n    if spec is None :\n     continue\n   else :\n    spec=find_spec(name,path,target)\n  if spec is not None :\n  \n   if not is_reload and name in sys.modules:\n    module=sys.modules[name]\n    try :\n     __spec__=module.__spec__\n    except AttributeError:\n    \n    \n    \n     return spec\n    else :\n     if __spec__ is None :\n      return spec\n     else :\n      return __spec__\n   else :\n    return spec\n else :\n  return None\n  \n  \ndef _sanity_check(name,package,level):\n ''\n if not isinstance(name,str):\n  raise TypeError('module name must be str, not {}'.format(type(name)))\n if level <0:\n  raise ValueError('level must be >= 0')\n if level >0:\n  if not isinstance(package,str):\n   raise TypeError('__package__ not set to a string')\n  elif not package:\n   raise ImportError('attempted relative import with no known parent '\n   'package')\n if not name and level ==0:\n  raise ValueError('Empty module name')\n  \n  \n_ERR_MSG_PREFIX='No module named '\n_ERR_MSG=_ERR_MSG_PREFIX+'{!r}'\n\ndef _find_and_load_unlocked(name,import_):\n path=None\n parent=name.rpartition('.')[0]\n if parent:\n  if parent not in sys.modules:\n   _call_with_frames_removed(import_,parent)\n   \n  if name in sys.modules:\n   return sys.modules[name]\n  parent_module=sys.modules[parent]\n  try :\n   path=parent_module.__path__\n  except AttributeError:\n   msg=(_ERR_MSG+'; {!r} is not a package').format(name,parent)\n   raise ModuleNotFoundError(msg,name=name)from None\n spec=_find_spec(name,path)\n if spec is None :\n  raise ModuleNotFoundError(_ERR_MSG.format(name),name=name)\n else :\n  module=_load_unlocked(spec)\n if parent:\n \n  parent_module=sys.modules[parent]\n  setattr(parent_module,name.rpartition('.')[2],module)\n return module\n \n \n_NEEDS_LOADING=object()\n\n\ndef _find_and_load(name,import_):\n ''\n with _ModuleLockManager(name):\n  module=sys.modules.get(name,_NEEDS_LOADING)\n  if module is _NEEDS_LOADING:\n   return _find_and_load_unlocked(name,import_)\n   \n if module is None :\n  message=('import of {} halted; '\n  'None in sys.modules'.format(name))\n  raise ModuleNotFoundError(message,name=name)\n  \n _lock_unlock_module(name)\n return module\n \n \ndef _gcd_import(name,package=None ,level=0):\n ''\n\n\n\n\n\n\n \n _sanity_check(name,package,level)\n if level >0:\n  name=_resolve_name(name,package,level)\n return _find_and_load(name,_gcd_import)\n \n \ndef _handle_fromlist(module,fromlist,import_,*,recursive=False ):\n ''\n\n\n\n\n\n \n \n \n if hasattr(module,'__path__'):\n  for x in fromlist:\n   if not isinstance(x,str):\n    if recursive:\n     where=module.__name__+'.__all__'\n    else :\n     where=\"``from list''\"\n    raise TypeError(f\"Item in {where} must be str, \"\n    f\"not {type(x).__name__}\")\n   elif x =='*':\n    if not recursive and hasattr(module,'__all__'):\n     _handle_fromlist(module,module.__all__,import_,\n     recursive=True )\n   elif not hasattr(module,x):\n    from_name='{}.{}'.format(module.__name__,x)\n    try :\n     _call_with_frames_removed(import_,from_name)\n    except ModuleNotFoundError as exc:\n    \n    \n    \n     if (exc.name ==from_name and\n     sys.modules.get(from_name,_NEEDS_LOADING)is not None ):\n      continue\n     raise\n return module\n \n \ndef _calc___package__(globals):\n ''\n\n\n\n\n \n package=globals.get('__package__')\n spec=globals.get('__spec__')\n if package is not None :\n  if spec is not None and package !=spec.parent:\n   _warnings.warn(\"__package__ != __spec__.parent \"\n   f\"({package!r} != {spec.parent!r})\",\n   ImportWarning,stacklevel=3)\n  return package\n elif spec is not None :\n  return spec.parent\n else :\n  _warnings.warn(\"can't resolve package from __spec__ or __package__, \"\n  \"falling back on __name__ and __path__\",\n  ImportWarning,stacklevel=3)\n  package=globals['__name__']\n  if '__path__'not in globals:\n   package=package.rpartition('.')[0]\n return package\n \n \ndef __import__(name,globals=None ,locals=None ,fromlist=(),level=0):\n ''\n\n\n\n\n\n\n\n\n \n if level ==0:\n  module=_gcd_import(name)\n else :\n  globals_=globals if globals is not None else {}\n  package=_calc___package__(globals_)\n  module=_gcd_import(name,package,level)\n if not fromlist:\n \n \n  if level ==0:\n   return _gcd_import(name.partition('.')[0])\n  elif not name:\n   return module\n  else :\n  \n  \n   cut_off=len(name)-len(name.partition('.')[0])\n   \n   \n   return sys.modules[module.__name__[:len(module.__name__)-cut_off]]\n else :\n  return _handle_fromlist(module,fromlist,_gcd_import)\n  \n  \ndef _builtin_from_name(name):\n spec=BuiltinImporter.find_spec(name)\n if spec is None :\n  raise ImportError('no built-in module named '+name)\n return _load_unlocked(spec)\n \n \ndef _setup(sys_module,_imp_module):\n ''\n\n\n\n\n\n \n global _imp,sys\n _imp=_imp_module\n sys=sys_module\n \n \n module_type=type(sys)\n for name,module in sys.modules.items():\n  if isinstance(module,module_type):\n   if name in sys.builtin_module_names:\n    loader=BuiltinImporter\n   elif _imp.is_frozen(name):\n    loader=FrozenImporter\n   else :\n    continue\n   spec=_spec_from_module(module,loader)\n   _init_module_attrs(spec,module)\n   \n   \n self_module=sys.modules[__name__]\n \n \n for builtin_name in ('_warnings',):\n  if builtin_name not in sys.modules:\n   builtin_module=_builtin_from_name(builtin_name)\n  else :\n   builtin_module=sys.modules[builtin_name]\n  setattr(self_module,builtin_name,builtin_module)\n  \n  \ndef _install(sys_module,_imp_module):\n ''\n _setup(sys_module,_imp_module)\n \n sys.meta_path.append(BuiltinImporter)\n sys.meta_path.append(FrozenImporter)\n \n \ndef _install_external_importers():\n ''\n global _bootstrap_external\n import _frozen_importlib_external\n _bootstrap_external=_frozen_importlib_external\n _frozen_importlib_external._install(sys.modules[__name__])\n", ["_frozen_importlib_external", "_weakref"]],
     "importlib._bootstrap_external": [".py", "''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nimport _io\n\n_CASE_INSENSITIVE_PLATFORMS_STR_KEY='win',\n_CASE_INSENSITIVE_PLATFORMS_BYTES_KEY='cygwin','darwin'\n_CASE_INSENSITIVE_PLATFORMS=(_CASE_INSENSITIVE_PLATFORMS_BYTES_KEY\n+_CASE_INSENSITIVE_PLATFORMS_STR_KEY)\n\n\ndef _make_relax_case():\n if sys.platform.startswith(_CASE_INSENSITIVE_PLATFORMS):\n  if sys.platform.startswith(_CASE_INSENSITIVE_PLATFORMS_STR_KEY):\n   key='PYTHONCASEOK'\n  else :\n   key=b'PYTHONCASEOK'\n   \n  def _relax_case():\n   ''\n   return key in _os.environ\n else :\n  def _relax_case():\n   ''\n   return False\n return _relax_case\n \n \ndef _pack_uint32(x):\n ''\n return (int(x)&0xFFFFFFFF).to_bytes(4,'little')\n \n \ndef _unpack_uint32(data):\n ''\n assert len(data)==4\n return int.from_bytes(data,'little')\n \ndef _unpack_uint16(data):\n ''\n assert len(data)==2\n return int.from_bytes(data,'little')\n \n \ndef _path_join(*path_parts):\n ''\n return path_sep.join([part.rstrip(path_separators)\n for part in path_parts if part])\n \n \ndef _path_split(path):\n ''\n if len(path_separators)==1:\n  front,_,tail=path.rpartition(path_sep)\n  return front,tail\n for x in reversed(path):\n  if x in path_separators:\n   front,tail=path.rsplit(x,maxsplit=1)\n   return front,tail\n return '',path\n \n \ndef _path_stat(path):\n ''\n\n\n\n\n \n return _os.stat(path)\n \n \ndef _path_is_mode_type(path,mode):\n ''\n try :\n  stat_info=_path_stat(path)\n except OSError:\n  return False\n return (stat_info.st_mode&0o170000)==mode\n \n \ndef _path_isfile(path):\n ''\n return _path_is_mode_type(path,0o100000)\n \n \ndef _path_isdir(path):\n ''\n if not path:\n  path=_os.getcwd()\n return _path_is_mode_type(path,0o040000)\n \n \ndef _path_isabs(path):\n ''\n\n\n\n \n return path.startswith(path_separators)or path[1:3]in _pathseps_with_colon\n \n \ndef _write_atomic(path,data,mode=0o666):\n ''\n\n \n \n path_tmp='{}.{}'.format(path,id(path))\n fd=_os.open(path_tmp,\n _os.O_EXCL |_os.O_CREAT |_os.O_WRONLY,mode&0o666)\n try :\n \n \n  with _io.FileIO(fd,'wb')as file:\n   file.write(data)\n  _os.replace(path_tmp,path)\n except OSError:\n  try :\n   _os.unlink(path_tmp)\n  except OSError:\n   pass\n  raise\n  \n  \n_code_type=type(_write_atomic.__code__)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMAGIC_NUMBER=(3413).to_bytes(2,'little')+b'\\r\\n'\n_RAW_MAGIC_NUMBER=int.from_bytes(MAGIC_NUMBER,'little')\n\n_PYCACHE='__pycache__'\n_OPT='opt-'\n\nSOURCE_SUFFIXES=['.py']\n\nBYTECODE_SUFFIXES=['.pyc']\n\nDEBUG_BYTECODE_SUFFIXES=OPTIMIZED_BYTECODE_SUFFIXES=BYTECODE_SUFFIXES\n\ndef cache_from_source(path,debug_override=None ,*,optimization=None ):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n if debug_override is not None :\n  _warnings.warn('the debug_override parameter is deprecated; use '\n  \"'optimization' instead\",DeprecationWarning)\n  if optimization is not None :\n   message='debug_override or optimization must be set to None'\n   raise TypeError(message)\n  optimization=''if debug_override else 1\n path=_os.fspath(path)\n head,tail=_path_split(path)\n base,sep,rest=tail.rpartition('.')\n tag=sys.implementation.cache_tag\n if tag is None :\n  raise NotImplementedError('sys.implementation.cache_tag is None')\n almost_filename=''.join([(base if base else rest),sep,tag])\n if optimization is None :\n  if sys.flags.optimize ==0:\n   optimization=''\n  else :\n   optimization=sys.flags.optimize\n optimization=str(optimization)\n if optimization !='':\n  if not optimization.isalnum():\n   raise ValueError('{!r} is not alphanumeric'.format(optimization))\n  almost_filename='{}.{}{}'.format(almost_filename,_OPT,optimization)\n filename=almost_filename+BYTECODE_SUFFIXES[0]\n if sys.pycache_prefix is not None :\n \n \n \n \n \n \n \n \n  if not _path_isabs(head):\n   head=_path_join(_os.getcwd(),head)\n   \n   \n   \n   \n  if head[1]==':'and head[0]not in path_separators:\n   head=head[2:]\n   \n   \n   \n  return _path_join(\n  sys.pycache_prefix,\n  head.lstrip(path_separators),\n  filename,\n  )\n return _path_join(head,_PYCACHE,filename)\n \n \ndef source_from_cache(path):\n ''\n\n\n\n\n\n\n \n if sys.implementation.cache_tag is None :\n  raise NotImplementedError('sys.implementation.cache_tag is None')\n path=_os.fspath(path)\n head,pycache_filename=_path_split(path)\n found_in_pycache_prefix=False\n if sys.pycache_prefix is not None :\n  stripped_path=sys.pycache_prefix.rstrip(path_separators)\n  if head.startswith(stripped_path+path_sep):\n   head=head[len(stripped_path):]\n   found_in_pycache_prefix=True\n if not found_in_pycache_prefix:\n  head,pycache=_path_split(head)\n  if pycache !=_PYCACHE:\n   raise ValueError(f'{_PYCACHE} not bottom-level directory in '\n   f'{path!r}')\n dot_count=pycache_filename.count('.')\n if dot_count not in {2,3}:\n  raise ValueError(f'expected only 2 or 3 dots in {pycache_filename!r}')\n elif dot_count ==3:\n  optimization=pycache_filename.rsplit('.',2)[-2]\n  if not optimization.startswith(_OPT):\n   raise ValueError(\"optimization portion of filename does not start \"\n   f\"with {_OPT!r}\")\n  opt_level=optimization[len(_OPT):]\n  if not opt_level.isalnum():\n   raise ValueError(f\"optimization level {optimization!r} is not an \"\n   \"alphanumeric value\")\n base_filename=pycache_filename.partition('.')[0]\n return _path_join(head,base_filename+SOURCE_SUFFIXES[0])\n \n \ndef _get_sourcefile(bytecode_path):\n ''\n\n\n\n\n \n if len(bytecode_path)==0:\n  return None\n rest,_,extension=bytecode_path.rpartition('.')\n if not rest or extension.lower()[-3:-1]!='py':\n  return bytecode_path\n try :\n  source_path=source_from_cache(bytecode_path)\n except (NotImplementedError,ValueError):\n  source_path=bytecode_path[:-1]\n return source_path if _path_isfile(source_path)else bytecode_path\n \n \ndef _get_cached(filename):\n if filename.endswith(tuple(SOURCE_SUFFIXES)):\n  try :\n   return cache_from_source(filename)\n  except NotImplementedError:\n   pass\n elif filename.endswith(tuple(BYTECODE_SUFFIXES)):\n  return filename\n else :\n  return None\n  \n  \ndef _calc_mode(path):\n ''\n try :\n  mode=_path_stat(path).st_mode\n except OSError:\n  mode=0o666\n  \n  \n mode |=0o200\n return mode\n \n \ndef _check_name(method):\n ''\n\n\n\n\n\n \n def _check_name_wrapper(self,name=None ,*args,**kwargs):\n  if name is None :\n   name=self.name\n  elif self.name !=name:\n   raise ImportError('loader for %s cannot handle %s'%\n   (self.name,name),name=name)\n  return method(self,name,*args,**kwargs)\n try :\n  _wrap=_bootstrap._wrap\n except NameError:\n \n  def _wrap(new,old):\n   for replace in ['__module__','__name__','__qualname__','__doc__']:\n    if hasattr(old,replace):\n     setattr(new,replace,getattr(old,replace))\n   new.__dict__.update(old.__dict__)\n _wrap(_check_name_wrapper,method)\n return _check_name_wrapper\n \n \ndef _find_module_shim(self,fullname):\n ''\n\n\n\n\n \n \n \n \n loader,portions=self.find_loader(fullname)\n if loader is None and len(portions):\n  msg='Not importing directory {}: missing __init__'\n  _warnings.warn(msg.format(portions[0]),ImportWarning)\n return loader\n \n \ndef _classify_pyc(data,name,exc_details):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n magic=data[:4]\n if magic !=MAGIC_NUMBER:\n  message=f'bad magic number in {name!r}: {magic!r}'\n  _bootstrap._verbose_message('{}',message)\n  raise ImportError(message,**exc_details)\n if len(data)<16:\n  message=f'reached EOF while reading pyc header of {name!r}'\n  _bootstrap._verbose_message('{}',message)\n  raise EOFError(message)\n flags=_unpack_uint32(data[4:8])\n \n if flags&~0b11:\n  message=f'invalid flags {flags!r} in {name!r}'\n  raise ImportError(message,**exc_details)\n return flags\n \n \ndef _validate_timestamp_pyc(data,source_mtime,source_size,name,\nexc_details):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n if _unpack_uint32(data[8:12])!=(source_mtime&0xFFFFFFFF):\n  message=f'bytecode is stale for {name!r}'\n  _bootstrap._verbose_message('{}',message)\n  raise ImportError(message,**exc_details)\n if (source_size is not None and\n _unpack_uint32(data[12:16])!=(source_size&0xFFFFFFFF)):\n  raise ImportError(f'bytecode is stale for {name!r}',**exc_details)\n  \n  \ndef _validate_hash_pyc(data,source_hash,name,exc_details):\n ''\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n if data[8:16]!=source_hash:\n  raise ImportError(\n  f'hash in bytecode doesn\\'t match hash of source {name!r}',\n  **exc_details,\n  )\n  \n  \ndef _compile_bytecode(data,name=None ,bytecode_path=None ,source_path=None ):\n ''\n code=marshal.loads(data)\n if isinstance(code,_code_type):\n  _bootstrap._verbose_message('code object from {!r}',bytecode_path)\n  if source_path is not None :\n   _imp._fix_co_filename(code,source_path)\n  return code\n else :\n  raise ImportError('Non-code object in {!r}'.format(bytecode_path),\n  name=name,path=bytecode_path)\n  \n  \ndef _code_to_timestamp_pyc(code,mtime=0,source_size=0):\n ''\n data=bytearray(MAGIC_NUMBER)\n data.extend(_pack_uint32(0))\n data.extend(_pack_uint32(mtime))\n data.extend(_pack_uint32(source_size))\n data.extend(marshal.dumps(code))\n return data\n \n \ndef _code_to_hash_pyc(code,source_hash,checked=True ):\n ''\n data=bytearray(MAGIC_NUMBER)\n flags=0b1 |checked <<1\n data.extend(_pack_uint32(flags))\n assert len(source_hash)==8\n data.extend(source_hash)\n data.extend(marshal.dumps(code))\n return data\n \n \ndef decode_source(source_bytes):\n ''\n\n\n \n import tokenize\n source_bytes_readline=_io.BytesIO(source_bytes).readline\n encoding=tokenize.detect_encoding(source_bytes_readline)\n newline_decoder=_io.IncrementalNewlineDecoder(None ,True )\n return newline_decoder.decode(source_bytes.decode(encoding[0]))\n \n \n \n \n_POPULATE=object()\n\n\ndef spec_from_file_location(name,location=None ,*,loader=None ,\nsubmodule_search_locations=_POPULATE):\n ''\n\n\n\n\n\n\n\n\n \n if location is None :\n \n \n \n  location='<unknown>'\n  if hasattr(loader,'get_filename'):\n  \n   try :\n    location=loader.get_filename(name)\n   except ImportError:\n    pass\n else :\n  location=_os.fspath(location)\n  \n  \n  \n  \n  \n  \n  \n spec=_bootstrap.ModuleSpec(name,loader,origin=location)\n spec._set_fileattr=True\n \n \n if loader is None :\n  for loader_class,suffixes in _get_supported_file_loaders():\n   if location.endswith(tuple(suffixes)):\n    loader=loader_class(name,location)\n    spec.loader=loader\n    break\n  else :\n   return None\n   \n   \n if submodule_search_locations is _POPULATE:\n \n  if hasattr(loader,'is_package'):\n   try :\n    is_package=loader.is_package(name)\n   except ImportError:\n    pass\n   else :\n    if is_package:\n     spec.submodule_search_locations=[]\n else :\n  spec.submodule_search_locations=submodule_search_locations\n if spec.submodule_search_locations ==[]:\n  if location:\n   dirname=_path_split(location)[0]\n   spec.submodule_search_locations.append(dirname)\n   \n return spec\n \n \n \n \nclass WindowsRegistryFinder:\n\n ''\n \n REGISTRY_KEY=(\n 'Software\\\\Python\\\\PythonCore\\\\{sys_version}'\n '\\\\Modules\\\\{fullname}')\n REGISTRY_KEY_DEBUG=(\n 'Software\\\\Python\\\\PythonCore\\\\{sys_version}'\n '\\\\Modules\\\\{fullname}\\\\Debug')\n DEBUG_BUILD=False\n \n @classmethod\n def _open_registry(cls,key):\n  try :\n   return _winreg.OpenKey(_winreg.HKEY_CURRENT_USER,key)\n  except OSError:\n   return _winreg.OpenKey(_winreg.HKEY_LOCAL_MACHINE,key)\n   \n @classmethod\n def _search_registry(cls,fullname):\n  if cls.DEBUG_BUILD:\n   registry_key=cls.REGISTRY_KEY_DEBUG\n  else :\n   registry_key=cls.REGISTRY_KEY\n  key=registry_key.format(fullname=fullname,\n  sys_version='%d.%d'%sys.version_info[:2])\n  try :\n   with cls._open_registry(key)as hkey:\n    filepath=_winreg.QueryValue(hkey,'')\n  except OSError:\n   return None\n  return filepath\n  \n @classmethod\n def find_spec(cls,fullname,path=None ,target=None ):\n  filepath=cls._search_registry(fullname)\n  if filepath is None :\n   return None\n  try :\n   _path_stat(filepath)\n  except OSError:\n   return None\n  for loader,suffixes in _get_supported_file_loaders():\n   if filepath.endswith(tuple(suffixes)):\n    spec=_bootstrap.spec_from_loader(fullname,\n    loader(fullname,filepath),\n    origin=filepath)\n    return spec\n    \n @classmethod\n def find_module(cls,fullname,path=None ):\n  ''\n\n\n\n  \n  spec=cls.find_spec(fullname,path)\n  if spec is not None :\n   return spec.loader\n  else :\n   return None\n   \n   \nclass _LoaderBasics:\n\n ''\n \n \n def is_package(self,fullname):\n  ''\n  \n  filename=_path_split(self.get_filename(fullname))[1]\n  filename_base=filename.rsplit('.',1)[0]\n  tail_name=fullname.rpartition('.')[2]\n  return filename_base =='__init__'and tail_name !='__init__'\n  \n def create_module(self,spec):\n  ''\n  \n def exec_module(self,module):\n  ''\n  code=self.get_code(module.__name__)\n  if code is None :\n   raise ImportError('cannot load module {!r} when get_code() '\n   'returns None'.format(module.__name__))\n  _bootstrap._call_with_frames_removed(exec,code,module.__dict__)\n  \n def load_module(self,fullname):\n  ''\n  return _bootstrap._load_module_shim(self,fullname)\n  \n  \nclass SourceLoader(_LoaderBasics):\n\n def path_mtime(self,path):\n  ''\n\n\n\n  \n  raise OSError\n  \n def path_stats(self,path):\n  ''\n\n\n\n\n\n\n\n\n\n  \n  return {'mtime':self.path_mtime(path)}\n  \n def _cache_bytecode(self,source_path,cache_path,data):\n  ''\n\n\n\n\n  \n  \n  return self.set_data(cache_path,data)\n  \n def set_data(self,path,data):\n  ''\n\n\n  \n  \n  \n def get_source(self,fullname):\n  ''\n  path=self.get_filename(fullname)\n  try :\n   source_bytes=self.get_data(path)\n  except OSError as exc:\n   raise ImportError('source not available through get_data()',\n   name=fullname)from exc\n  return decode_source(source_bytes)\n  \n def source_to_code(self,data,path,*,_optimize=-1):\n  ''\n\n\n  \n  return _bootstrap._call_with_frames_removed(compile,data,path,'exec',\n  dont_inherit=True ,optimize=_optimize)\n  \n def get_code(self,fullname):\n  ''\n\n\n\n\n  \n  source_path=self.get_filename(fullname)\n  source_mtime=None\n  source_bytes=None\n  source_hash=None\n  hash_based=False\n  check_source=True\n  try :\n   bytecode_path=cache_from_source(source_path)\n  except NotImplementedError:\n   bytecode_path=None\n  else :\n   try :\n    st=self.path_stats(source_path)\n   except OSError:\n    pass\n   else :\n    source_mtime=int(st['mtime'])\n    try :\n     data=self.get_data(bytecode_path)\n    except OSError:\n     pass\n    else :\n     exc_details={\n     'name':fullname,\n     'path':bytecode_path,\n     }\n     try :\n      flags=_classify_pyc(data,fullname,exc_details)\n      bytes_data=memoryview(data)[16:]\n      hash_based=flags&0b1 !=0\n      if hash_based:\n       check_source=flags&0b10 !=0\n       if (_imp.check_hash_based_pycs !='never'and\n       (check_source or\n       _imp.check_hash_based_pycs =='always')):\n        source_bytes=self.get_data(source_path)\n        source_hash=_imp.source_hash(\n        _RAW_MAGIC_NUMBER,\n        source_bytes,\n        )\n        _validate_hash_pyc(data,source_hash,fullname,\n        exc_details)\n      else :\n       _validate_timestamp_pyc(\n       data,\n       source_mtime,\n       st['size'],\n       fullname,\n       exc_details,\n       )\n     except (ImportError,EOFError):\n      pass\n     else :\n      _bootstrap._verbose_message('{} matches {}',bytecode_path,\n      source_path)\n      return _compile_bytecode(bytes_data,name=fullname,\n      bytecode_path=bytecode_path,\n      source_path=source_path)\n  if source_bytes is None :\n   source_bytes=self.get_data(source_path)\n  code_object=self.source_to_code(source_bytes,source_path)\n  _bootstrap._verbose_message('code object from {}',source_path)\n  if (not sys.dont_write_bytecode and bytecode_path is not None and\n  source_mtime is not None ):\n   if hash_based:\n    if source_hash is None :\n     source_hash=_imp.source_hash(source_bytes)\n    data=_code_to_hash_pyc(code_object,source_hash,check_source)\n   else :\n    data=_code_to_timestamp_pyc(code_object,source_mtime,\n    len(source_bytes))\n   try :\n    self._cache_bytecode(source_path,bytecode_path,data)\n   except NotImplementedError:\n    pass\n  return code_object\n  \n  \nclass FileLoader:\n\n ''\n \n \n def __init__(self,fullname,path):\n  ''\n  \n  self.name=fullname\n  self.path=path\n  \n def __eq__(self,other):\n  return (self.__class__ ==other.__class__ and\n  self.__dict__ ==other.__dict__)\n  \n def __hash__(self):\n  return hash(self.name)^hash(self.path)\n  \n @_check_name\n def load_module(self,fullname):\n  ''\n\n\n\n  \n  \n  \n  \n  return super(FileLoader,self).load_module(fullname)\n  \n @_check_name\n def get_filename(self,fullname):\n  ''\n  return self.path\n  \n def get_data(self,path):\n  ''\n  if isinstance(self,(SourceLoader,ExtensionFileLoader)):\n   with _io.open_code(str(path))as file:\n    return file.read()\n  else :\n   with _io.FileIO(path,'r')as file:\n    return file.read()\n    \n    \n    \n @_check_name\n def get_resource_reader(self,module):\n  if self.is_package(module):\n   return self\n  return None\n  \n def open_resource(self,resource):\n  path=_path_join(_path_split(self.path)[0],resource)\n  return _io.FileIO(path,'r')\n  \n def resource_path(self,resource):\n  if not self.is_resource(resource):\n   raise FileNotFoundError\n  path=_path_join(_path_split(self.path)[0],resource)\n  return path\n  \n def is_resource(self,name):\n  if path_sep in name:\n   return False\n  path=_path_join(_path_split(self.path)[0],name)\n  return _path_isfile(path)\n  \n def contents(self):\n  return iter(_os.listdir(_path_split(self.path)[0]))\n  \n  \nclass SourceFileLoader(FileLoader,SourceLoader):\n\n ''\n \n def path_stats(self,path):\n  ''\n  st=_path_stat(path)\n  return {'mtime':st.st_mtime,'size':st.st_size}\n  \n def _cache_bytecode(self,source_path,bytecode_path,data):\n \n  mode=_calc_mode(source_path)\n  return self.set_data(bytecode_path,data,_mode=mode)\n  \n def set_data(self,path,data,*,_mode=0o666):\n  ''\n  parent,filename=_path_split(path)\n  path_parts=[]\n  \n  while parent and not _path_isdir(parent):\n   parent,part=_path_split(parent)\n   path_parts.append(part)\n   \n  for part in reversed(path_parts):\n   parent=_path_join(parent,part)\n   try :\n    _os.mkdir(parent)\n   except FileExistsError:\n   \n    continue\n   except OSError as exc:\n   \n   \n    _bootstrap._verbose_message('could not create {!r}: {!r}',\n    parent,exc)\n    return\n  try :\n   _write_atomic(path,data,_mode)\n   _bootstrap._verbose_message('created {!r}',path)\n  except OSError as exc:\n  \n   _bootstrap._verbose_message('could not create {!r}: {!r}',path,\n   exc)\n   \n   \nclass SourcelessFileLoader(FileLoader,_LoaderBasics):\n\n ''\n \n def get_code(self,fullname):\n  path=self.get_filename(fullname)\n  data=self.get_data(path)\n  \n  \n  exc_details={\n  'name':fullname,\n  'path':path,\n  }\n  _classify_pyc(data,fullname,exc_details)\n  return _compile_bytecode(\n  memoryview(data)[16:],\n  name=fullname,\n  bytecode_path=path,\n  )\n  \n def get_source(self,fullname):\n  ''\n  return None\n  \n  \n  \nEXTENSION_SUFFIXES=[]\n\n\nclass ExtensionFileLoader(FileLoader,_LoaderBasics):\n\n ''\n\n\n\n \n \n def __init__(self,name,path):\n  self.name=name\n  self.path=path\n  \n def __eq__(self,other):\n  return (self.__class__ ==other.__class__ and\n  self.__dict__ ==other.__dict__)\n  \n def __hash__(self):\n  return hash(self.name)^hash(self.path)\n  \n def create_module(self,spec):\n  ''\n  module=_bootstrap._call_with_frames_removed(\n  _imp.create_dynamic,spec)\n  _bootstrap._verbose_message('extension module {!r} loaded from {!r}',\n  spec.name,self.path)\n  return module\n  \n def exec_module(self,module):\n  ''\n  _bootstrap._call_with_frames_removed(_imp.exec_dynamic,module)\n  _bootstrap._verbose_message('extension module {!r} executed from {!r}',\n  self.name,self.path)\n  \n def is_package(self,fullname):\n  ''\n  file_name=_path_split(self.path)[1]\n  return any(file_name =='__init__'+suffix\n  for suffix in EXTENSION_SUFFIXES)\n  \n def get_code(self,fullname):\n  ''\n  return None\n  \n def get_source(self,fullname):\n  ''\n  return None\n  \n @_check_name\n def get_filename(self,fullname):\n  ''\n  return self.path\n  \n  \nclass _NamespacePath:\n ''\n\n\n\n \n \n def __init__(self,name,path,path_finder):\n  self._name=name\n  self._path=path\n  self._last_parent_path=tuple(self._get_parent_path())\n  self._path_finder=path_finder\n  \n def _find_parent_path_names(self):\n  ''\n  parent,dot,me=self._name.rpartition('.')\n  if dot =='':\n  \n   return 'sys','path'\n   \n   \n  return parent,'__path__'\n  \n def _get_parent_path(self):\n  parent_module_name,path_attr_name=self._find_parent_path_names()\n  return getattr(sys.modules[parent_module_name],path_attr_name)\n  \n def _recalculate(self):\n \n  parent_path=tuple(self._get_parent_path())\n  if parent_path !=self._last_parent_path:\n   spec=self._path_finder(self._name,parent_path)\n   \n   \n   if spec is not None and spec.loader is None :\n    if spec.submodule_search_locations:\n     self._path=spec.submodule_search_locations\n   self._last_parent_path=parent_path\n  return self._path\n  \n def __iter__(self):\n  return iter(self._recalculate())\n  \n def __getitem__(self,index):\n  return self._recalculate()[index]\n  \n def __setitem__(self,index,path):\n  self._path[index]=path\n  \n def __len__(self):\n  return len(self._recalculate())\n  \n def __repr__(self):\n  return '_NamespacePath({!r})'.format(self._path)\n  \n def __contains__(self,item):\n  return item in self._recalculate()\n  \n def append(self,item):\n  self._path.append(item)\n  \n  \n  \nclass _NamespaceLoader:\n def __init__(self,name,path,path_finder):\n  self._path=_NamespacePath(name,path,path_finder)\n  \n @classmethod\n def module_repr(cls,module):\n  ''\n\n\n\n  \n  return '<module {!r} (namespace)>'.format(module.__name__)\n  \n def is_package(self,fullname):\n  return True\n  \n def get_source(self,fullname):\n  return ''\n  \n def get_code(self,fullname):\n  return compile('','<string>','exec',dont_inherit=True )\n  \n def create_module(self,spec):\n  ''\n  \n def exec_module(self,module):\n  pass\n  \n def load_module(self,fullname):\n  ''\n\n\n\n  \n  \n  _bootstrap._verbose_message('namespace module loaded with path {!r}',\n  self._path)\n  return _bootstrap._load_module_shim(self,fullname)\n  \n  \n  \n  \nclass PathFinder:\n\n ''\n \n @classmethod\n def invalidate_caches(cls):\n  ''\n  \n  for name,finder in list(sys.path_importer_cache.items()):\n   if finder is None :\n    del sys.path_importer_cache[name]\n   elif hasattr(finder,'invalidate_caches'):\n    finder.invalidate_caches()\n    \n @classmethod\n def _path_hooks(cls,path):\n  ''\n  if sys.path_hooks is not None and not sys.path_hooks:\n   _warnings.warn('sys.path_hooks is empty',ImportWarning)\n  for hook in sys.path_hooks:\n   try :\n    return hook(path)\n   except ImportError:\n    continue\n  else :\n   return None\n   \n @classmethod\n def _path_importer_cache(cls,path):\n  ''\n\n\n\n\n  \n  if path =='':\n   try :\n    path=_os.getcwd()\n   except FileNotFoundError:\n   \n   \n    return None\n  try :\n   finder=sys.path_importer_cache[path]\n  except KeyError:\n   finder=cls._path_hooks(path)\n   sys.path_importer_cache[path]=finder\n  return finder\n  \n @classmethod\n def _legacy_get_spec(cls,fullname,finder):\n \n \n  if hasattr(finder,'find_loader'):\n   loader,portions=finder.find_loader(fullname)\n  else :\n   loader=finder.find_module(fullname)\n   portions=[]\n  if loader is not None :\n   return _bootstrap.spec_from_loader(fullname,loader)\n  spec=_bootstrap.ModuleSpec(fullname,None )\n  spec.submodule_search_locations=portions\n  return spec\n  \n @classmethod\n def _get_spec(cls,fullname,path,target=None ):\n  ''\n  \n  \n  namespace_path=[]\n  for entry in path:\n   if not isinstance(entry,(str,bytes)):\n    continue\n   finder=cls._path_importer_cache(entry)\n   if finder is not None :\n    if hasattr(finder,'find_spec'):\n     spec=finder.find_spec(fullname,target)\n    else :\n     spec=cls._legacy_get_spec(fullname,finder)\n    if spec is None :\n     continue\n    if spec.loader is not None :\n     return spec\n    portions=spec.submodule_search_locations\n    if portions is None :\n     raise ImportError('spec missing loader')\n     \n     \n     \n     \n    namespace_path.extend(portions)\n  else :\n   spec=_bootstrap.ModuleSpec(fullname,None )\n   spec.submodule_search_locations=namespace_path\n   return spec\n   \n @classmethod\n def find_spec(cls,fullname,path=None ,target=None ):\n  ''\n\n\n  \n  if path is None :\n   path=sys.path\n  spec=cls._get_spec(fullname,path,target)\n  if spec is None :\n   return None\n  elif spec.loader is None :\n   namespace_path=spec.submodule_search_locations\n   if namespace_path:\n   \n   \n    spec.origin=None\n    spec.submodule_search_locations=_NamespacePath(fullname,namespace_path,cls._get_spec)\n    return spec\n   else :\n    return None\n  else :\n   return spec\n   \n @classmethod\n def find_module(cls,fullname,path=None ):\n  ''\n\n\n\n\n  \n  spec=cls.find_spec(fullname,path)\n  if spec is None :\n   return None\n  return spec.loader\n  \n @classmethod\n def find_distributions(cls,*args,**kwargs):\n  ''\n\n\n\n\n\n\n  \n  from importlib.metadata import MetadataPathFinder\n  return MetadataPathFinder.find_distributions(*args,**kwargs)\n  \n  \nclass FileFinder:\n\n ''\n\n\n\n\n \n \n def __init__(self,path,*loader_details):\n  ''\n\n  \n  loaders=[]\n  for loader,suffixes in loader_details:\n   loaders.extend((suffix,loader)for suffix in suffixes)\n  self._loaders=loaders\n  \n  self.path=path or '.'\n  self._path_mtime=-1\n  self._path_cache=set()\n  self._relaxed_path_cache=set()\n  \n def invalidate_caches(self):\n  ''\n  self._path_mtime=-1\n  \n find_module=_find_module_shim\n \n def find_loader(self,fullname):\n  ''\n\n\n\n\n  \n  spec=self.find_spec(fullname)\n  if spec is None :\n   return None ,[]\n  return spec.loader,spec.submodule_search_locations or []\n  \n def _get_spec(self,loader_class,fullname,path,smsl,target):\n  loader=loader_class(fullname,path)\n  return spec_from_file_location(fullname,path,loader=loader,\n  submodule_search_locations=smsl)\n  \n def find_spec(self,fullname,target=None ):\n  ''\n\n\n  \n  is_namespace=False\n  tail_module=fullname.rpartition('.')[2]\n  try :\n   mtime=_path_stat(self.path or _os.getcwd()).st_mtime\n  except OSError:\n   mtime=-1\n  if mtime !=self._path_mtime:\n   self._fill_cache()\n   self._path_mtime=mtime\n   \n  if _relax_case():\n   cache=self._relaxed_path_cache\n   cache_module=tail_module.lower()\n  else :\n   cache=self._path_cache\n   cache_module=tail_module\n   \n  if cache_module in cache:\n   base_path=_path_join(self.path,tail_module)\n   for suffix,loader_class in self._loaders:\n    init_filename='__init__'+suffix\n    full_path=_path_join(base_path,init_filename)\n    if _path_isfile(full_path):\n     return self._get_spec(loader_class,fullname,full_path,[base_path],target)\n   else :\n   \n   \n    is_namespace=_path_isdir(base_path)\n    \n  for suffix,loader_class in self._loaders:\n   full_path=_path_join(self.path,tail_module+suffix)\n   _bootstrap._verbose_message('trying {}',full_path,verbosity=2)\n   if cache_module+suffix in cache:\n    if _path_isfile(full_path):\n     return self._get_spec(loader_class,fullname,full_path,\n     None ,target)\n  if is_namespace:\n   _bootstrap._verbose_message('possible namespace for {}',base_path)\n   spec=_bootstrap.ModuleSpec(fullname,None )\n   spec.submodule_search_locations=[base_path]\n   return spec\n  return None\n  \n def _fill_cache(self):\n  ''\n  path=self.path\n  try :\n   contents=_os.listdir(path or _os.getcwd())\n  except (FileNotFoundError,PermissionError,NotADirectoryError):\n  \n  \n   contents=[]\n   \n   \n  if not sys.platform.startswith('win'):\n   self._path_cache=set(contents)\n  else :\n  \n  \n  \n  \n  \n   lower_suffix_contents=set()\n   for item in contents:\n    name,dot,suffix=item.partition('.')\n    if dot:\n     new_name='{}.{}'.format(name,suffix.lower())\n    else :\n     new_name=name\n    lower_suffix_contents.add(new_name)\n   self._path_cache=lower_suffix_contents\n  if sys.platform.startswith(_CASE_INSENSITIVE_PLATFORMS):\n   self._relaxed_path_cache={fn.lower()for fn in contents}\n   \n @classmethod\n def path_hook(cls,*loader_details):\n  ''\n\n\n\n\n\n\n  \n  def path_hook_for_FileFinder(path):\n   ''\n   if not _path_isdir(path):\n    raise ImportError('only directories are supported',path=path)\n   return cls(path,*loader_details)\n   \n  return path_hook_for_FileFinder\n  \n def __repr__(self):\n  return 'FileFinder({!r})'.format(self.path)\n  \n  \n  \n  \ndef _fix_up_module(ns,name,pathname,cpathname=None ):\n\n loader=ns.get('__loader__')\n spec=ns.get('__spec__')\n if not loader:\n  if spec:\n   loader=spec.loader\n  elif pathname ==cpathname:\n   loader=SourcelessFileLoader(name,pathname)\n  else :\n   loader=SourceFileLoader(name,pathname)\n if not spec:\n  spec=spec_from_file_location(name,pathname,loader=loader)\n try :\n  ns['__spec__']=spec\n  ns['__loader__']=loader\n  ns['__file__']=pathname\n  ns['__cached__']=cpathname\n except Exception:\n \n  pass\n  \n  \ndef _get_supported_file_loaders():\n ''\n\n\n \n extensions=ExtensionFileLoader,_imp.extension_suffixes()\n source=SourceFileLoader,SOURCE_SUFFIXES\n bytecode=SourcelessFileLoader,BYTECODE_SUFFIXES\n return [extensions,source,bytecode]\n \n \ndef _setup(_bootstrap_module):\n ''\n\n\n\n\n \n global sys,_imp,_bootstrap\n _bootstrap=_bootstrap_module\n sys=_bootstrap.sys\n _imp=_bootstrap._imp\n \n \n self_module=sys.modules[__name__]\n \n \n for builtin_name in ('_warnings','builtins','marshal'):\n  if builtin_name not in sys.modules:\n   builtin_module=_bootstrap._builtin_from_name(builtin_name)\n  else :\n   builtin_module=sys.modules[builtin_name]\n  setattr(self_module,builtin_name,builtin_module)\n  \n  \n os_details=('posix',['/']),('nt',['\\\\','/'])\n for builtin_os,path_separators in os_details:\n \n  assert all(len(sep)==1 for sep in path_separators)\n  path_sep=path_separators[0]\n  if builtin_os in sys.modules:\n   os_module=sys.modules[builtin_os]\n   break\n  else :\n   try :\n    os_module=_bootstrap._builtin_from_name(builtin_os)\n    break\n   except ImportError:\n    continue\n else :\n  raise ImportError('importlib requires posix or nt')\n setattr(self_module,'_os',os_module)\n setattr(self_module,'path_sep',path_sep)\n setattr(self_module,'path_separators',''.join(path_separators))\n setattr(self_module,'_pathseps_with_colon',{f':{s}'for s in path_separators})\n \n \n \n \n import _thread\n setattr(self_module,'_thread',_thread)\n \n \n \n \n import _weakref\n setattr(self_module,'_weakref',_weakref)\n \n \n if builtin_os =='nt':\n  winreg_module=_bootstrap._builtin_from_name('winreg')\n  setattr(self_module,'_winreg',winreg_module)\n  \n  \n setattr(self_module,'_relax_case',_make_relax_case())\n EXTENSION_SUFFIXES.extend(_imp.extension_suffixes())\n if builtin_os =='nt':\n  SOURCE_SUFFIXES.append('.pyw')\n  if '_d.pyd'in EXTENSION_SUFFIXES:\n   WindowsRegistryFinder.DEBUG_BUILD=True\n   \n   \ndef _install(_bootstrap_module):\n ''\n _setup(_bootstrap_module)\n supported_loaders=_get_supported_file_loaders()\n sys.path_hooks.extend([FileFinder.path_hook(*supported_loaders)])\n sys.meta_path.append(PathFinder)\n \n", ["_io", "_thread", "_weakref", "importlib.metadata", "tokenize"]],
     "importlib._common": [".py", "import os\nimport pathlib\nimport zipfile\nimport tempfile\nimport functools\nimport contextlib\n\n\ndef from_package(package):\n ''\n\n\n \n return fallback_resources(package.__spec__)\n \n \ndef fallback_resources(spec):\n package_directory=pathlib.Path(spec.origin).parent\n try :\n  archive_path=spec.loader.archive\n  rel_path=package_directory.relative_to(archive_path)\n  return zipfile.Path(archive_path,str(rel_path)+'/')\n except Exception:\n  pass\n return package_directory\n \n \n@contextlib.contextmanager\ndef _tempfile(reader,suffix=''):\n\n\n\n fd,raw_path=tempfile.mkstemp(suffix=suffix)\n try :\n  os.write(fd,reader())\n  os.close(fd)\n  yield pathlib.Path(raw_path)\n finally :\n  try :\n   os.remove(raw_path)\n  except FileNotFoundError:\n   pass\n   \n   \n@functools.singledispatch\n@contextlib.contextmanager\ndef as_file(path):\n ''\n\n\n \n with _tempfile(path.read_bytes,suffix=path.name)as local:\n  yield local\n  \n  \n@as_file.register(pathlib.Path)\n@contextlib.contextmanager\ndef _(path):\n ''\n\n \n yield path\n", ["contextlib", "functools", "os", "pathlib", "tempfile", "zipfile"]],
     "importlib": [".py", "''\n__all__=['__import__','import_module','invalidate_caches','reload']\n\n\n\n\n\n\n\n\n\nimport _imp\nimport sys\n\ntry :\n import _frozen_importlib as _bootstrap\nexcept ImportError:\n from . import _bootstrap\n _bootstrap._setup(sys,_imp)\nelse :\n\n\n _bootstrap.__name__='importlib._bootstrap'\n _bootstrap.__package__='importlib'\n try :\n  _bootstrap.__file__=__file__.replace('__init__.py','_bootstrap.py')\n except NameError:\n \n \n  pass\n sys.modules['importlib._bootstrap']=_bootstrap\n \ntry :\n import _frozen_importlib_external as _bootstrap_external\nexcept ImportError:\n from . import _bootstrap_external\n _bootstrap_external._setup(_bootstrap)\n _bootstrap._bootstrap_external=_bootstrap_external\nelse :\n _bootstrap_external.__name__='importlib._bootstrap_external'\n _bootstrap_external.__package__='importlib'\n try :\n  _bootstrap_external.__file__=__file__.replace('__init__.py','_bootstrap_external.py')\n except NameError:\n \n \n  pass\n sys.modules['importlib._bootstrap_external']=_bootstrap_external\n \n \n_pack_uint32=_bootstrap_external._pack_uint32\n_unpack_uint32=_bootstrap_external._unpack_uint32\n\n\n\n\nimport types\nimport warnings\n\n\n\n\nfrom ._bootstrap import __import__\n\n\ndef invalidate_caches():\n ''\n \n for finder in sys.meta_path:\n  if hasattr(finder,'invalidate_caches'):\n   finder.invalidate_caches()\n   \n   \ndef find_loader(name,path=None ):\n ''\n\n\n\n\n\n \n warnings.warn('Deprecated since Python 3.4. '\n 'Use importlib.util.find_spec() instead.',\n DeprecationWarning,stacklevel=2)\n try :\n  loader=sys.modules[name].__loader__\n  if loader is None :\n   raise ValueError('{}.__loader__ is None'.format(name))\n  else :\n   return loader\n except KeyError:\n  pass\n except AttributeError:\n  raise ValueError('{}.__loader__ is not set'.format(name))from None\n  \n spec=_bootstrap._find_spec(name,path)\n \n if spec is None :\n  return None\n if spec.loader is None :\n  if spec.submodule_search_locations is None :\n   raise ImportError('spec for {} missing loader'.format(name),\n   name=name)\n  raise ImportError('namespace packages do not have loaders',\n  name=name)\n return spec.loader\n \n \ndef import_module(name,package=None ):\n ''\n\n\n\n\n\n \n level=0\n if name.startswith('.'):\n  if not package:\n   msg=(\"the 'package' argument is required to perform a relative \"\n   \"import for {!r}\")\n   raise TypeError(msg.format(name))\n  for character in name:\n   if character !='.':\n    break\n   level +=1\n return _bootstrap._gcd_import(name[level:],package,level)\n \n \n_RELOADING={}\n\n\ndef reload(module):\n ''\n\n\n\n \n if not module or not isinstance(module,types.ModuleType):\n  raise TypeError(\"reload() argument must be a module\")\n try :\n  name=module.__spec__.name\n except AttributeError:\n  name=module.__name__\n  \n if sys.modules.get(name)is not module:\n  msg=\"module {} not in sys.modules\"\n  raise ImportError(msg.format(name),name=name)\n if name in _RELOADING:\n  return _RELOADING[name]\n _RELOADING[name]=module\n try :\n  parent_name=name.rpartition('.')[0]\n  if parent_name:\n   try :\n    parent=sys.modules[parent_name]\n   except KeyError:\n    msg=\"parent {!r} not in sys.modules\"\n    raise ImportError(msg.format(parent_name),\n    name=parent_name)from None\n   else :\n    pkgpath=parent.__path__\n  else :\n   pkgpath=None\n  target=module\n  spec=module.__spec__=_bootstrap._find_spec(name,pkgpath,target)\n  if spec is None :\n   raise ModuleNotFoundError(f\"spec not found for the module {name!r}\",name=name)\n  _bootstrap._exec(spec,module)\n  \n  return sys.modules[name]\n finally :\n  try :\n   del _RELOADING[name]\n  except KeyError:\n   pass\n", ["_frozen_importlib", "_frozen_importlib_external", "_imp", "importlib", "importlib._bootstrap", "importlib._bootstrap_external", "sys", "types", "warnings"], 1],
     "logging.brython_handlers": [".py", "import logging\n\nfrom browser.ajax import ajax\n\n\nclass XMLHTTPHandler(logging.Handler):\n ''\n\n\n \n def __init__(self,url,method=\"GET\"):\n  ''\n\n\n  \n  logging.Handler.__init__(self)\n  method=method.upper()\n  if method not in [\"GET\",\"POST\"]:\n   raise ValueError(\"method must be GET or POST\")\n  self.url=url\n  self.method=method\n  \n def mapLogRecord(self,record):\n  ''\n\n\n\n  \n  return record.__dict__\n  \n def emit(self,record):\n  ''\n\n\n\n  \n  try :\n   req=ajax.open(self.method,self.url,sync=False )\n   req.send(self.mapLogRecord(record))\n  except :\n   self.handleError(record)\n", ["browser.ajax", "logging"]],
```

### Comparing `brython-3.9.5/brython/data/demo.html` & `brython-3.9.6/brython/data/demo.html`

 * *Files identical despite different names*

### Comparing `brython-3.9.5/brython/data/unicode.txt` & `brython-3.9.6/brython/data/unicode.txt`

 * *Files identical despite different names*

### Comparing `brython-3.9.5/brython/list_modules.py` & `brython-3.9.6/brython/list_modules.py`

 * *Files identical despite different names*

### Comparing `brython-3.9.5/brython/make_file_system.py` & `brython-3.9.6/brython/make_file_system.py`

 * *Files identical despite different names*

### Comparing `brython-3.9.5/brython/make_package.py` & `brython-3.9.6/brython/make_package.py`

 * *Files 5% similar despite different names*

```diff
@@ -66,15 +66,15 @@
         else:
             package = dirpath[len(package_path) + 1:].split(os.sep)
         if has_init:
             package.insert(0, package_name)
 
         for filename in filenames:
             name, ext = os.path.splitext(filename)
-            if ext not in ('.py', '.js'):
+            if ext != '.py':
                 continue
             is_package = name.endswith('__init__')
             if is_package:
                 mod_name = '.'.join(package)
             else:
                 mod_name = '.'.join(package + [name])
```

### Comparing `brython-3.9.5/brython/python_minifier.py` & `brython-3.9.6/brython/python_minifier.py`

 * *Files identical despite different names*

### Comparing `brython-3.9.5/brython.egg-info/PKG-INFO` & `brython-3.9.6/brython.egg-info/PKG-INFO`

 * *Files 1% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 1.1
 Name: brython
-Version: 3.9.5
+Version: 3.9.6
 Summary: Brython is an implementation of Python 3 running in the browser
 Home-page: http://brython.info
 Author: Pierre Quentel
 Author-email: quentel.pierre@orange.fr
 License: BSD
 Description: With Brython you can write browser programs in Python instead of Javascript,
         by inserting Python code in an HTML page by::
```

#### html2text {}

```diff
@@ -1,8 +1,8 @@
-Metadata-Version: 1.1 Name: brython Version: 3.9.5 Summary: Brython is an
+Metadata-Version: 1.1 Name: brython Version: 3.9.6 Summary: Brython is an
 implementation of Python 3 running in the browser Home-page: http://
 brython.info Author: Pierre Quentel Author-email: quentel.pierre@orange.fr
 License: BSD Description: With Brython you can write browser programs in Python
 instead of Javascript, by inserting Python code in an HTML page by::
  Usage:: pip install brython Then in an empty folder:: brython-cli --install or
 in a folder with older versions already present:: brython-cli --update The
 package includes a page **demo.html** with examples of use. For more
```

### Comparing `brython-3.9.5/setup.py` & `brython-3.9.6/setup.py`

 * *Files 1% similar despite different names*

```diff
@@ -112,15 +112,15 @@
 
     with open(os.path.join(data_dir, "demo.html"), "w", encoding="utf-8") as out:
         out.write(demo)
 
 setup(
     name='brython',
 
-    version='3.9.5',
+    version='3.9.6',
     description='Brython is an implementation of Python 3 running in the browser',
 
     long_description=LONG_DESCRIPTION,
 
     # The project's main homepage.
     url='http://brython.info',
```

#### html2text {}

```diff
@@ -29,15 +29,15 @@
 'demo.html'), encoding="utf-8") as f: demo = f.read() start_tag = "" end_tag =
 "" start = demo.find(start_tag) if start == -1: raise Exception("No tag  in
 demo.html") end = demo.find(end_tag) if end == -1: raise Exception("No tag  in
 demo.html") body = demo[start + len(start_tag) : end].strip() with open
 (os.path.join(release_dir, "demo.tmpl"), encoding="utf-8") as f: template =
 f.read() demo = template.replace("{{body}}", body) with open(os.path.join
 (data_dir, "demo.html"), "w", encoding="utf-8") as out: out.write(demo) setup
-( name='brython', version='3.9.5', description='Brython is an implementation of
+( name='brython', version='3.9.6', description='Brython is an implementation of
 Python 3 running in the browser', long_description=LONG_DESCRIPTION, # The
 project's main homepage. url='http://brython.info', # Author details
 author='Pierre Quentel', author_email='quentel.pierre@orange.fr',
 packages=find_packages(), # Choose your license license='BSD', # See https://
 pypi.python.org/pypi?%3Aaction=list_classifiers classifiers=[ # Indicate who
 your project is intended for 'Intended Audience :: Developers', 'Topic ::
 Software Development :: Interpreters', 'Operating System :: OS Independent', #
```

